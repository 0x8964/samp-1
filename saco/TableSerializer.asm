; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.31101.0 

	TITLE	Z:\sampsrc\02Xu1\raknet\TableSerializer.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
PUBLIC	?Size@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QBEIXZ ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::Size
PUBLIC	?GetListHead@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QBEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@XZ ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::GetListHead
PUBLIC	??A?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEAAUColumnDescriptor@Table@1@I@Z ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::operator[]
PUBLIC	?Size@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::Size
PUBLIC	?SerializeTable@TableSerializer@@SAXPAVTable@DataStructures@@PAVBitStream@RakNet@@@Z ; TableSerializer::SerializeTable
PUBLIC	?DeserializeTable@TableSerializer@@SA_NPAEIPAVTable@DataStructures@@@Z ; TableSerializer::DeserializeTable
PUBLIC	?SerializeRow@TableSerializer@@SAXPAURow@Table@DataStructures@@IAAV?$List@UColumnDescriptor@Table@DataStructures@@@4@PAVBitStream@RakNet@@@Z ; TableSerializer::SerializeRow
PUBLIC	?DeserializeRow@TableSerializer@@SA_NPAVBitStream@RakNet@@PAVTable@DataStructures@@@Z ; TableSerializer::DeserializeRow
PUBLIC	?SerializeCell@TableSerializer@@SAXPAVBitStream@RakNet@@PAUCell@Table@DataStructures@@W4ColumnType@56@@Z ; TableSerializer::SerializeCell
PUBLIC	?DeserializeCell@TableSerializer@@SA_NPAVBitStream@RakNet@@PAUCell@Table@DataStructures@@W4ColumnType@56@@Z ; TableSerializer::DeserializeCell
PUBLIC	?GetReadOffset@BitStream@RakNet@@QBEHXZ		; RakNet::BitStream::GetReadOffset
PUBLIC	?GetNumberOfUnreadBits@BitStream@RakNet@@QBEHXZ	; RakNet::BitStream::GetNumberOfUnreadBits
PUBLIC	?GetData@BitStream@RakNet@@QBEPAEXZ		; RakNet::BitStream::GetData
PUBLIC	??$Write@_N@BitStream@RakNet@@QAEX_N@Z		; RakNet::BitStream::Write<bool>
PUBLIC	??$Write@I@BitStream@RakNet@@QAEXI@Z		; RakNet::BitStream::Write<unsigned int>
PUBLIC	??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z	; RakNet::BitStream::Read<bool>
PUBLIC	??$Read@I@BitStream@RakNet@@QAE_NAAI@Z		; RakNet::BitStream::Read<unsigned int>
PUBLIC	??$Write@E@BitStream@RakNet@@QAEXE@Z		; RakNet::BitStream::Write<unsigned char>
PUBLIC	??$Read@E@BitStream@RakNet@@QAE_NAAE@Z		; RakNet::BitStream::Read<unsigned char>
PUBLIC	??$Write@H@BitStream@RakNet@@QAEXH@Z		; RakNet::BitStream::Write<int>
PUBLIC	??$Read@H@BitStream@RakNet@@QAE_NAAH@Z		; RakNet::BitStream::Read<int>
PUBLIC	?__LINE__Var@?1??SerializeCell@TableSerializer@@SAXPAVBitStream@RakNet@@PAUCell@Table@DataStructures@@W4ColumnType@67@@Z@4JA@a74e26c4 ; `TableSerializer::SerializeCell'::`2'::__LINE__Var
PUBLIC	??_C@_1FI@BBJMIGD@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAt?$AAa?$AAb?$AAl?$AAe?$AAs?$AAe?$AAr@ ; `string'
PUBLIC	??_C@_1FE@LFCOHDLN@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAT?$AAy?$AAp?$AAe?$AA?$DN?$AA?$DN?$AAD?$AAa?$AAt?$AAa?$AAS?$AAt?$AAr?$AAu?$AAc?$AAt?$AAu?$AAr?$AAe?$AAs?$AA?3?$AA?3?$AAT?$AAa?$AAb?$AAl@ ; `string'
PUBLIC	?__LINE__Var@?1??DeserializeCell@TableSerializer@@SA_NPAVBitStream@RakNet@@PAUCell@Table@DataStructures@@W4ColumnType@67@@Z@4JA@a74e26c4 ; `TableSerializer::DeserializeCell'::`2'::__LINE__Var
PUBLIC	??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@ ; `string'
PUBLIC	??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ ; `string'
EXTRN	__wassert:PROC
EXTRN	?Clear@Cell@Table@DataStructures@@QAEXXZ:PROC	; DataStructures::Table::Cell::Clear
EXTRN	?Set@Cell@Table@DataStructures@@QAEXH@Z:PROC	; DataStructures::Table::Cell::Set
EXTRN	?Set@Cell@Table@DataStructures@@QAEXPAD@Z:PROC	; DataStructures::Table::Cell::Set
EXTRN	?Set@Cell@Table@DataStructures@@QAEXPADH@Z:PROC	; DataStructures::Table::Cell::Set
EXTRN	?AddColumn@Table@DataStructures@@QAEIQADW4ColumnType@12@@Z:PROC ; DataStructures::Table::AddColumn
EXTRN	?AddRow@Table@DataStructures@@QAEPAURow@12@I@Z:PROC ; DataStructures::Table::AddRow
EXTRN	?RemoveRow@Table@DataStructures@@QAEXI@Z:PROC	; DataStructures::Table::RemoveRow
EXTRN	?Clear@Table@DataStructures@@QAEXXZ:PROC	; DataStructures::Table::Clear
EXTRN	?GetColumns@Table@DataStructures@@QAEAAV?$List@UColumnDescriptor@Table@DataStructures@@@2@XZ:PROC ; DataStructures::Table::GetColumns
EXTRN	?GetRows@Table@DataStructures@@QAEAAV?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@2@XZ:PROC ; DataStructures::Table::GetRows
EXTRN	??0BitStream@RakNet@@QAE@PAEI_N@Z:PROC		; RakNet::BitStream::BitStream
EXTRN	??1BitStream@RakNet@@QAE@XZ:PROC		; RakNet::BitStream::~BitStream
EXTRN	?IgnoreBits@BitStream@RakNet@@QAEXH@Z:PROC	; RakNet::BitStream::IgnoreBits
EXTRN	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z:PROC	; RakNet::BitStream::WriteBits
EXTRN	?WriteAlignedBytes@BitStream@RakNet@@QAEXPBEH@Z:PROC ; RakNet::BitStream::WriteAlignedBytes
EXTRN	?AlignReadToByteBoundary@BitStream@RakNet@@QAEXXZ:PROC ; RakNet::BitStream::AlignReadToByteBoundary
EXTRN	?ReadBits@BitStream@RakNet@@QAE_NPAEH_N@Z:PROC	; RakNet::BitStream::ReadBits
EXTRN	?Write0@BitStream@RakNet@@QAEXXZ:PROC		; RakNet::BitStream::Write0
EXTRN	?Write1@BitStream@RakNet@@QAEXXZ:PROC		; RakNet::BitStream::Write1
EXTRN	?Instance@StringCompressor@@SAPAV1@XZ:PROC	; StringCompressor::Instance
EXTRN	?EncodeString@StringCompressor@@QAEXPBDHPAVBitStream@RakNet@@H@Z:PROC ; StringCompressor::EncodeString
EXTRN	?DecodeString@StringCompressor@@QAE_NPADHPAVBitStream@RakNet@@H@Z:PROC ; StringCompressor::DecodeString
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__chkstk:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ DB 'p'
	DB	00H, 'o', 00H, 's', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'o', 00H
	DB	'n', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'l', 00H, 'i', 00H, 's'
	DB	00H, 't', 00H, '_', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
CONST	SEGMENT
??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@ DB 'z'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H
	DB	's', 00H, 'r', 00H, 'c', 00H, '\', 00H, '0', 00H, '2', 00H, 'x'
	DB	00H, 'u', 00H, '1', 00H, '\', 00H, 'r', 00H, 'a', 00H, 'k', 00H
	DB	'n', 00H, 'e', 00H, 't', 00H, '\', 00H, 'd', 00H, 's', 00H, '_'
	DB	00H, 'l', 00H, 'i', 00H, 's', 00H, 't', 00H, '.', 00H, 'h', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??DeserializeCell@TableSerializer@@SA_NPAVBitStream@RakNet@@PAUCell@Table@DataStructures@@W4ColumnType@67@@Z@4JA@a74e26c4
_DATA	SEGMENT
?__LINE__Var@?1??DeserializeCell@TableSerializer@@SA_NPAVBitStream@RakNet@@PAUCell@Table@DataStructures@@W4ColumnType@67@@Z@4JA@a74e26c4 DD 06eH ; `TableSerializer::DeserializeCell'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1FE@LFCOHDLN@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAT?$AAy?$AAp?$AAe?$AA?$DN?$AA?$DN?$AAD?$AAa?$AAt?$AAa?$AAS?$AAt?$AAr?$AAu?$AAc?$AAt?$AAu?$AAr?$AAe?$AAs?$AA?3?$AA?3?$AAT?$AAa?$AAb?$AAl@
CONST	SEGMENT
??_C@_1FE@LFCOHDLN@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAT?$AAy?$AAp?$AAe?$AA?$DN?$AA?$DN?$AAD?$AAa?$AAt?$AAa?$AAS?$AAt?$AAr?$AAu?$AAc?$AAt?$AAu?$AAr?$AAe?$AAs?$AA?3?$AA?3?$AAT?$AAa?$AAb?$AAl@ DB 'c'
	DB	00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, 'T', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, '=', 00H, '=', 00H, 'D', 00H, 'a'
	DB	00H, 't', 00H, 'a', 00H, 'S', 00H, 't', 00H, 'r', 00H, 'u', 00H
	DB	'c', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'e', 00H, 's', 00H, ':'
	DB	00H, ':', 00H, 'T', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	':', 00H, ':', 00H, 'B', 00H, 'I', 00H, 'N', 00H, 'A', 00H, 'R'
	DB	00H, 'Y', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1FI@BBJMIGD@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAt?$AAa?$AAb?$AAl?$AAe?$AAs?$AAe?$AAr@
CONST	SEGMENT
??_C@_1FI@BBJMIGD@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAt?$AAa?$AAb?$AAl?$AAe?$AAs?$AAe?$AAr@ DB 'z'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H
	DB	's', 00H, 'r', 00H, 'c', 00H, '\', 00H, '0', 00H, '2', 00H, 'x'
	DB	00H, 'u', 00H, '1', 00H, '\', 00H, 'r', 00H, 'a', 00H, 'k', 00H
	DB	'n', 00H, 'e', 00H, 't', 00H, '\', 00H, 't', 00H, 'a', 00H, 'b'
	DB	00H, 'l', 00H, 'e', 00H, 's', 00H, 'e', 00H, 'r', 00H, 'i', 00H
	DB	'a', 00H, 'l', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??SerializeCell@TableSerializer@@SAXPAVBitStream@RakNet@@PAUCell@Table@DataStructures@@W4ColumnType@67@@Z@4JA@a74e26c4
_DATA	SEGMENT
?__LINE__Var@?1??SerializeCell@TableSerializer@@SAXPAVBitStream@RakNet@@PAUCell@Table@DataStructures@@W4ColumnType@67@@Z@4JA@a74e26c4 DD 058H ; `TableSerializer::SerializeCell'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?DeserializeTable@TableSerializer@@SA_NPAEIPAVTable@DataStructures@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DeserializeTable@TableSerializer@@SA_NPAEIPAVTable@DataStructures@@@Z$0
__ehfuncinfo$?DeserializeTable@TableSerializer@@SA_NPAEIPAVTable@DataStructures@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DeserializeTable@TableSerializer@@SA_NPAEIPAVTable@DataStructures@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Read@H@BitStream@RakNet@@QAE_NAAH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 4
??$Read@H@BitStream@RakNet@@QAE_NAAH@Z PROC		; RakNet::BitStream::Read<int>, COMDAT
; _this$ = ecx

; 987  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 988  : #ifdef _MSC_VER
; 989  : #pragma warning(disable:4127)   // conditional expression is constant
; 990  : #endif
; 991  : 		if (sizeof(var)==1)

	xor	eax, eax
	je	SHORT $LN2@Read

; 992  : 			return ReadBits( ( unsigned char* ) &var, sizeof(templateType) * 8, true );

	push	1
	push	32					; 00000020H
	mov	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadBits@BitStream@RakNet@@QAE_NPAEH_N@Z ; RakNet::BitStream::ReadBits
	jmp	SHORT $LN3@Read

; 993  : 		else

	jmp	SHORT $LN3@Read
$LN2@Read:

; 994  : 		{
; 995  : #ifndef __BITSTREAM_NATIVE_END
; 996  : #ifdef _MSC_VER
; 997  : #pragma warning(disable:4244)   // '=' : conversion from 'unsigned long' to 'unsigned short', possible loss of data
; 998  : #endif
; 999  : 			if (DoEndianSwap())
; 1000 : 			{
; 1001 : 				unsigned char output[sizeof(templateType)];
; 1002 : 				if (ReadBits( ( unsigned char* ) output, sizeof(templateType) * 8, true ))
; 1003 : 				{
; 1004 : 					ReverseBytes(output, (unsigned char*)&var, sizeof(templateType));
; 1005 : 					return true;
; 1006 : 				}
; 1007 : 				return false;
; 1008 : 			}
; 1009 : 			else
; 1010 : #endif
; 1011 : 				return ReadBits( ( unsigned char* ) & var, sizeof(templateType) * 8, true );

	push	1
	push	32					; 00000020H
	mov	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadBits@BitStream@RakNet@@QAE_NPAEH_N@Z ; RakNet::BitStream::ReadBits
$LN3@Read:

; 1012 : 		}
; 1013 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$Read@H@BitStream@RakNet@@QAE_NAAH@Z ENDP		; RakNet::BitStream::Read<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Write@H@BitStream@RakNet@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 4
??$Write@H@BitStream@RakNet@@QAEXH@Z PROC		; RakNet::BitStream::Write<int>, COMDAT
; _this$ = ecx

; 729  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 730  : #ifdef _MSC_VER
; 731  : #pragma warning(disable:4127)   // conditional expression is constant
; 732  : #endif
; 733  : 		if (sizeof(var)==1)

	xor	eax, eax
	je	SHORT $LN2@Write

; 734  : 			WriteBits( ( unsigned char* ) & var, sizeof( templateType ) * 8, true );

	push	1
	push	32					; 00000020H
	lea	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z ; RakNet::BitStream::WriteBits

; 735  : 		else

	jmp	SHORT $LN3@Write
$LN2@Write:

; 736  : 		{
; 737  : #ifndef __BITSTREAM_NATIVE_END
; 738  : 			if (DoEndianSwap())
; 739  : 			{
; 740  : 				unsigned char output[sizeof(templateType)];
; 741  : 				ReverseBytes((unsigned char*)&var, output, sizeof(templateType));
; 742  : 				WriteBits( ( unsigned char* ) output, sizeof(templateType) * 8, true );
; 743  : 			}
; 744  : 			else
; 745  : #endif
; 746  : 				WriteBits( ( unsigned char* ) & var, sizeof(templateType) * 8, true );

	push	1
	push	32					; 00000020H
	lea	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z ; RakNet::BitStream::WriteBits
$LN3@Write:

; 747  : 		}
; 748  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$Write@H@BitStream@RakNet@@QAEXH@Z ENDP		; RakNet::BitStream::Write<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Read@E@BitStream@RakNet@@QAE_NAAE@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 4
??$Read@E@BitStream@RakNet@@QAE_NAAE@Z PROC		; RakNet::BitStream::Read<unsigned char>, COMDAT
; _this$ = ecx

; 987  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 988  : #ifdef _MSC_VER
; 989  : #pragma warning(disable:4127)   // conditional expression is constant
; 990  : #endif
; 991  : 		if (sizeof(var)==1)

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN2@Read

; 992  : 			return ReadBits( ( unsigned char* ) &var, sizeof(templateType) * 8, true );

	push	1
	push	8
	mov	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadBits@BitStream@RakNet@@QAE_NPAEH_N@Z ; RakNet::BitStream::ReadBits
	jmp	SHORT $LN3@Read

; 993  : 		else

	jmp	SHORT $LN3@Read
$LN2@Read:

; 994  : 		{
; 995  : #ifndef __BITSTREAM_NATIVE_END
; 996  : #ifdef _MSC_VER
; 997  : #pragma warning(disable:4244)   // '=' : conversion from 'unsigned long' to 'unsigned short', possible loss of data
; 998  : #endif
; 999  : 			if (DoEndianSwap())
; 1000 : 			{
; 1001 : 				unsigned char output[sizeof(templateType)];
; 1002 : 				if (ReadBits( ( unsigned char* ) output, sizeof(templateType) * 8, true ))
; 1003 : 				{
; 1004 : 					ReverseBytes(output, (unsigned char*)&var, sizeof(templateType));
; 1005 : 					return true;
; 1006 : 				}
; 1007 : 				return false;
; 1008 : 			}
; 1009 : 			else
; 1010 : #endif
; 1011 : 				return ReadBits( ( unsigned char* ) & var, sizeof(templateType) * 8, true );

	push	1
	push	8
	mov	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadBits@BitStream@RakNet@@QAE_NPAEH_N@Z ; RakNet::BitStream::ReadBits
$LN3@Read:

; 1012 : 		}
; 1013 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$Read@E@BitStream@RakNet@@QAE_NAAE@Z ENDP		; RakNet::BitStream::Read<unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Write@E@BitStream@RakNet@@QAEXE@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 1
??$Write@E@BitStream@RakNet@@QAEXE@Z PROC		; RakNet::BitStream::Write<unsigned char>, COMDAT
; _this$ = ecx

; 729  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 730  : #ifdef _MSC_VER
; 731  : #pragma warning(disable:4127)   // conditional expression is constant
; 732  : #endif
; 733  : 		if (sizeof(var)==1)

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN2@Write

; 734  : 			WriteBits( ( unsigned char* ) & var, sizeof( templateType ) * 8, true );

	push	1
	push	8
	lea	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z ; RakNet::BitStream::WriteBits

; 735  : 		else

	jmp	SHORT $LN3@Write
$LN2@Write:

; 736  : 		{
; 737  : #ifndef __BITSTREAM_NATIVE_END
; 738  : 			if (DoEndianSwap())
; 739  : 			{
; 740  : 				unsigned char output[sizeof(templateType)];
; 741  : 				ReverseBytes((unsigned char*)&var, output, sizeof(templateType));
; 742  : 				WriteBits( ( unsigned char* ) output, sizeof(templateType) * 8, true );
; 743  : 			}
; 744  : 			else
; 745  : #endif
; 746  : 				WriteBits( ( unsigned char* ) & var, sizeof(templateType) * 8, true );

	push	1
	push	8
	lea	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z ; RakNet::BitStream::WriteBits
$LN3@Write:

; 747  : 		}
; 748  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$Write@E@BitStream@RakNet@@QAEXE@Z ENDP		; RakNet::BitStream::Write<unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Read@I@BitStream@RakNet@@QAE_NAAI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 4
??$Read@I@BitStream@RakNet@@QAE_NAAI@Z PROC		; RakNet::BitStream::Read<unsigned int>, COMDAT
; _this$ = ecx

; 987  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 988  : #ifdef _MSC_VER
; 989  : #pragma warning(disable:4127)   // conditional expression is constant
; 990  : #endif
; 991  : 		if (sizeof(var)==1)

	xor	eax, eax
	je	SHORT $LN2@Read

; 992  : 			return ReadBits( ( unsigned char* ) &var, sizeof(templateType) * 8, true );

	push	1
	push	32					; 00000020H
	mov	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadBits@BitStream@RakNet@@QAE_NPAEH_N@Z ; RakNet::BitStream::ReadBits
	jmp	SHORT $LN3@Read

; 993  : 		else

	jmp	SHORT $LN3@Read
$LN2@Read:

; 994  : 		{
; 995  : #ifndef __BITSTREAM_NATIVE_END
; 996  : #ifdef _MSC_VER
; 997  : #pragma warning(disable:4244)   // '=' : conversion from 'unsigned long' to 'unsigned short', possible loss of data
; 998  : #endif
; 999  : 			if (DoEndianSwap())
; 1000 : 			{
; 1001 : 				unsigned char output[sizeof(templateType)];
; 1002 : 				if (ReadBits( ( unsigned char* ) output, sizeof(templateType) * 8, true ))
; 1003 : 				{
; 1004 : 					ReverseBytes(output, (unsigned char*)&var, sizeof(templateType));
; 1005 : 					return true;
; 1006 : 				}
; 1007 : 				return false;
; 1008 : 			}
; 1009 : 			else
; 1010 : #endif
; 1011 : 				return ReadBits( ( unsigned char* ) & var, sizeof(templateType) * 8, true );

	push	1
	push	32					; 00000020H
	mov	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadBits@BitStream@RakNet@@QAE_NPAEH_N@Z ; RakNet::BitStream::ReadBits
$LN3@Read:

; 1012 : 		}
; 1013 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$Read@I@BitStream@RakNet@@QAE_NAAI@Z ENDP		; RakNet::BitStream::Read<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z
_TEXT	SEGMENT
tv82 = -208						; size = 4
_this$ = -8						; size = 4
_var$ = 8						; size = 4
??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z PROC		; RakNet::BitStream::Read<bool>, COMDAT
; _this$ = ecx

; 1019 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1020 : 		if ( readOffset + 1 > numberOfBitsUsed )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [edx]
	jle	SHORT $LN3@Read

; 1021 : 			return false;

	xor	al, al
	jmp	SHORT $LN4@Read
$LN3@Read:

; 1022 : 
; 1023 : 		if ( data[ readOffset >> 3 ] & ( 0x80 >> ( readOffset++ % 8 ) ) )   // Is it faster to just write it out here?

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sar	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	movzx	edx, BYTE PTR [eax+ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -2147483641			; 80000007H
	jns	SHORT $LN6@Read
	dec	ecx
	or	ecx, -8					; fffffff8H
	inc	ecx
$LN6@Read:
	mov	eax, 128				; 00000080H
	sar	eax, cl
	and	edx, eax
	mov	DWORD PTR tv82[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx
	cmp	DWORD PTR tv82[ebp], 0
	je	SHORT $LN2@Read

; 1024 : 			var = true;

	mov	eax, DWORD PTR _var$[ebp]
	mov	BYTE PTR [eax], 1

; 1025 : 		else

	jmp	SHORT $LN1@Read
$LN2@Read:

; 1026 : 			var = false;

	mov	eax, DWORD PTR _var$[ebp]
	mov	BYTE PTR [eax], 0
$LN1@Read:

; 1027 : 
; 1028 : 		return true;

	mov	al, 1
$LN4@Read:

; 1029 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z ENDP		; RakNet::BitStream::Read<bool>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Write@I@BitStream@RakNet@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 4
??$Write@I@BitStream@RakNet@@QAEXI@Z PROC		; RakNet::BitStream::Write<unsigned int>, COMDAT
; _this$ = ecx

; 729  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 730  : #ifdef _MSC_VER
; 731  : #pragma warning(disable:4127)   // conditional expression is constant
; 732  : #endif
; 733  : 		if (sizeof(var)==1)

	xor	eax, eax
	je	SHORT $LN2@Write

; 734  : 			WriteBits( ( unsigned char* ) & var, sizeof( templateType ) * 8, true );

	push	1
	push	32					; 00000020H
	lea	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z ; RakNet::BitStream::WriteBits

; 735  : 		else

	jmp	SHORT $LN3@Write
$LN2@Write:

; 736  : 		{
; 737  : #ifndef __BITSTREAM_NATIVE_END
; 738  : 			if (DoEndianSwap())
; 739  : 			{
; 740  : 				unsigned char output[sizeof(templateType)];
; 741  : 				ReverseBytes((unsigned char*)&var, output, sizeof(templateType));
; 742  : 				WriteBits( ( unsigned char* ) output, sizeof(templateType) * 8, true );
; 743  : 			}
; 744  : 			else
; 745  : #endif
; 746  : 				WriteBits( ( unsigned char* ) & var, sizeof(templateType) * 8, true );

	push	1
	push	32					; 00000020H
	lea	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z ; RakNet::BitStream::WriteBits
$LN3@Write:

; 747  : 		}
; 748  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$Write@I@BitStream@RakNet@@QAEXI@Z ENDP		; RakNet::BitStream::Write<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Write@_N@BitStream@RakNet@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 1
??$Write@_N@BitStream@RakNet@@QAEX_N@Z PROC		; RakNet::BitStream::Write<bool>, COMDAT
; _this$ = ecx

; 754  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 755  : 		if ( var )

	movzx	eax, BYTE PTR _var$[ebp]
	test	eax, eax
	je	SHORT $LN2@Write

; 756  : 			Write1();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Write1@BitStream@RakNet@@QAEXXZ	; RakNet::BitStream::Write1

; 757  : 		else

	jmp	SHORT $LN3@Write
$LN2@Write:

; 758  : 			Write0();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Write0@BitStream@RakNet@@QAEXXZ	; RakNet::BitStream::Write0
$LN3@Write:

; 759  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$Write@_N@BitStream@RakNet@@QAEX_N@Z ENDP		; RakNet::BitStream::Write<bool>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ?GetData@BitStream@RakNet@@QBEPAEXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetData@BitStream@RakNet@@QBEPAEXZ PROC		; RakNet::BitStream::GetData, COMDAT
; _this$ = ecx

; 397  : 		inline unsigned char* GetData( void ) const {return data;}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetData@BitStream@RakNet@@QBEPAEXZ ENDP		; RakNet::BitStream::GetData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ?GetNumberOfUnreadBits@BitStream@RakNet@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetNumberOfUnreadBits@BitStream@RakNet@@QBEHXZ PROC	; RakNet::BitStream::GetNumberOfUnreadBits, COMDAT
; _this$ = ecx

; 382  : 		inline int GetNumberOfUnreadBits( void ) const {return numberOfBitsUsed - readOffset;}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR [ecx+8]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumberOfUnreadBits@BitStream@RakNet@@QBEHXZ ENDP	; RakNet::BitStream::GetNumberOfUnreadBits
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ?GetReadOffset@BitStream@RakNet@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetReadOffset@BitStream@RakNet@@QBEHXZ PROC		; RakNet::BitStream::GetReadOffset, COMDAT
; _this$ = ecx

; 376  : 		inline int GetReadOffset( void ) const {return readOffset;}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetReadOffset@BitStream@RakNet@@QBEHXZ ENDP		; RakNet::BitStream::GetReadOffset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\tableserializer.cpp
;	COMDAT ?DeserializeCell@TableSerializer@@SA_NPAVBitStream@RakNet@@PAUCell@Table@DataStructures@@W4ColumnType@56@@Z
_TEXT	SEGMENT
_tempString$ = -65568					; size = 65535
_value$ = -24						; size = 4
_isEmpty$ = -9						; size = 1
__$ArrayPad$ = -4					; size = 4
_in$ = 8						; size = 4
_cell$ = 12						; size = 4
_columnType$ = 16					; size = 4
?DeserializeCell@TableSerializer@@SA_NPAVBitStream@RakNet@@PAUCell@Table@DataStructures@@W4ColumnType@56@@Z PROC ; TableSerializer::DeserializeCell, COMDAT

; 110  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 65764				; 000100e4H
	call	__chkstk
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-65764]
	mov	ecx, 16441				; 00004039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 111  : 	bool isEmpty;
; 112  : 	int value;
; 113  : 	char tempString[65535];
; 114  : 	cell->Clear();

	mov	ecx, DWORD PTR _cell$[ebp]
	call	?Clear@Cell@Table@DataStructures@@QAEXXZ ; DataStructures::Table::Cell::Clear

; 115  : 
; 116  : 	if (in->Read(isEmpty)==false)

	lea	eax, DWORD PTR _isEmpty$[ebp]
	push	eax
	mov	ecx, DWORD PTR _in$[ebp]
	call	??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z ; RakNet::BitStream::Read<bool>
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN11@Deserializ

; 117  : 		return false;

	xor	al, al
	jmp	$LN12@Deserializ
$LN11@Deserializ:

; 118  : 	if (isEmpty==false)

	movzx	eax, BYTE PTR _isEmpty$[ebp]
	test	eax, eax
	jne	$LN10@Deserializ

; 119  : 	{
; 120  : 		if (columnType==DataStructures::Table::NUMERIC)

	cmp	DWORD PTR _columnType$[ebp], 0
	jne	SHORT $LN9@Deserializ

; 121  : 		{
; 122  : 			if (in->Read(value)==false)

	lea	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _in$[ebp]
	call	??$Read@H@BitStream@RakNet@@QAE_NAAH@Z	; RakNet::BitStream::Read<int>
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN8@Deserializ

; 123  : 				return false;

	xor	al, al
	jmp	$LN12@Deserializ
$LN8@Deserializ:

; 124  : 			cell->Set(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cell$[ebp]
	call	?Set@Cell@Table@DataStructures@@QAEXH@Z	; DataStructures::Table::Cell::Set
	jmp	$LN10@Deserializ
$LN9@Deserializ:

; 125  : 		}
; 126  : 		else if (columnType==DataStructures::Table::STRING)

	cmp	DWORD PTR _columnType$[ebp], 1
	jne	SHORT $LN6@Deserializ

; 127  : 		{
; 128  : 			if (stringCompressor->DecodeString(tempString, 65535, in)==false)

	push	0
	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	push	65535					; 0000ffffH
	lea	ecx, DWORD PTR _tempString$[ebp]
	push	ecx
	call	?Instance@StringCompressor@@SAPAV1@XZ	; StringCompressor::Instance
	mov	ecx, eax
	call	?DecodeString@StringCompressor@@QAE_NPADHPAVBitStream@RakNet@@H@Z ; StringCompressor::DecodeString
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN5@Deserializ

; 129  : 				return false;

	xor	al, al
	jmp	$LN12@Deserializ
$LN5@Deserializ:

; 130  : 			cell->Set(tempString);

	lea	eax, DWORD PTR _tempString$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cell$[ebp]
	call	?Set@Cell@Table@DataStructures@@QAEXPAD@Z ; DataStructures::Table::Cell::Set

; 131  : 		}
; 132  : 		else

	jmp	$LN10@Deserializ
$LN6@Deserializ:

; 133  : 		{
; 134  : 			// Binary
; 135  : 			assert(columnType==DataStructures::Table::BINARY);

	cmp	DWORD PTR _columnType$[ebp], 2
	je	SHORT $LN14@Deserializ
	mov	eax, DWORD PTR ?__LINE__Var@?1??DeserializeCell@TableSerializer@@SA_NPAVBitStream@RakNet@@PAUCell@Table@DataStructures@@W4ColumnType@67@@Z@4JA@a74e26c4
	add	eax, 25					; 00000019H
	push	eax
	push	OFFSET ??_C@_1FI@BBJMIGD@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAt?$AAa?$AAb?$AAl?$AAe?$AAs?$AAe?$AAr@
	push	OFFSET ??_C@_1FE@LFCOHDLN@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAT?$AAy?$AAp?$AAe?$AA?$DN?$AA?$DN?$AAD?$AAa?$AAt?$AAa?$AAS?$AAt?$AAr?$AAu?$AAc?$AAt?$AAu?$AAr?$AAe?$AAs?$AA?3?$AA?3?$AAT?$AAa?$AAb?$AAl@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN14@Deserializ:

; 136  : 			if (in->Read(value)==false || value > 10000000)

	lea	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _in$[ebp]
	call	??$Read@H@BitStream@RakNet@@QAE_NAAH@Z	; RakNet::BitStream::Read<int>
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Deserializ
	cmp	DWORD PTR _value$[ebp], 10000000	; 00989680H
	jle	SHORT $LN3@Deserializ
$LN2@Deserializ:

; 137  : 				return false; // Sanity check to max binary cell of 10 megabytes

	xor	al, al
	jmp	SHORT $LN12@Deserializ
$LN3@Deserializ:

; 138  : 			in->AlignReadToByteBoundary();

	mov	ecx, DWORD PTR _in$[ebp]
	call	?AlignReadToByteBoundary@BitStream@RakNet@@QAEXXZ ; RakNet::BitStream::AlignReadToByteBoundary

; 139  : 			if (BITS_TO_BYTES(in->GetNumberOfUnreadBits())<value)

	mov	ecx, DWORD PTR _in$[ebp]
	call	?GetNumberOfUnreadBits@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfUnreadBits
	add	eax, 7
	sar	eax, 3
	cmp	eax, DWORD PTR _value$[ebp]
	jge	SHORT $LN1@Deserializ

; 140  : 				return false;

	xor	al, al
	jmp	SHORT $LN12@Deserializ
$LN1@Deserializ:

; 141  : 			cell->Set((char*) in->GetData()+BITS_TO_BYTES(in->GetReadOffset()), value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _in$[ebp]
	call	?GetData@BitStream@RakNet@@QBEPAEXZ	; RakNet::BitStream::GetData
	mov	esi, eax
	mov	ecx, DWORD PTR _in$[ebp]
	call	?GetReadOffset@BitStream@RakNet@@QBEHXZ	; RakNet::BitStream::GetReadOffset
	add	eax, 7
	sar	eax, 3
	add	esi, eax
	push	esi
	mov	ecx, DWORD PTR _cell$[ebp]
	call	?Set@Cell@Table@DataStructures@@QAEXPADH@Z ; DataStructures::Table::Cell::Set

; 142  : 			in->IgnoreBits(BYTES_TO_BITS(value));

	mov	eax, DWORD PTR _value$[ebp]
	shl	eax, 3
	push	eax
	mov	ecx, DWORD PTR _in$[ebp]
	call	?IgnoreBits@BitStream@RakNet@@QAEXH@Z	; RakNet::BitStream::IgnoreBits
$LN10@Deserializ:

; 143  : 		}
; 144  : 	}
; 145  : 	return true;

	mov	al, 1
$LN12@Deserializ:

; 146  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN19@Deserializ
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 65764				; 000100e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@Deserializ:
	DD	3
	DD	$LN18@Deserializ
$LN18@Deserializ:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN15@Deserializ
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN16@Deserializ
	DD	-65568					; fffeffe0H
	DD	65535					; 0000ffffH
	DD	$LN17@Deserializ
$LN17@Deserializ:
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	0
$LN16@Deserializ:
	DB	118					; 00000076H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	0
$LN15@Deserializ:
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	69					; 00000045H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	121					; 00000079H
	DB	0
?DeserializeCell@TableSerializer@@SA_NPAVBitStream@RakNet@@PAUCell@Table@DataStructures@@W4ColumnType@56@@Z ENDP ; TableSerializer::DeserializeCell
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\tableserializer.cpp
;	COMDAT ?SerializeCell@TableSerializer@@SAXPAVBitStream@RakNet@@PAUCell@Table@DataStructures@@W4ColumnType@56@@Z
_TEXT	SEGMENT
_out$ = 8						; size = 4
_cell$ = 12						; size = 4
_columnType$ = 16					; size = 4
?SerializeCell@TableSerializer@@SAXPAVBitStream@RakNet@@PAUCell@Table@DataStructures@@W4ColumnType@56@@Z PROC ; TableSerializer::SerializeCell, COMDAT

; 88   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 89   : 	out->Write(cell->isEmpty);

	mov	eax, DWORD PTR _cell$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _out$[ebp]
	call	??$Write@_N@BitStream@RakNet@@QAEX_N@Z	; RakNet::BitStream::Write<bool>

; 90   : 	if (cell->isEmpty==false)

	mov	eax, DWORD PTR _cell$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	$LN6@SerializeC

; 91   : 	{
; 92   : 		if (columnType==DataStructures::Table::NUMERIC)

	cmp	DWORD PTR _columnType$[ebp], 0
	jne	SHORT $LN4@SerializeC

; 93   : 		{
; 94   : 			out->Write(cell->i);

	mov	eax, DWORD PTR _cell$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	push	ecx
	mov	ecx, DWORD PTR _out$[ebp]
	call	??$Write@H@BitStream@RakNet@@QAEXH@Z	; RakNet::BitStream::Write<int>
	jmp	SHORT $LN6@SerializeC
$LN4@SerializeC:

; 95   : 		}
; 96   : 		else if (columnType==DataStructures::Table::STRING)

	cmp	DWORD PTR _columnType$[ebp], 1
	jne	SHORT $LN2@SerializeC

; 97   : 		{
; 98   : 			stringCompressor->EncodeString(cell->c, 65535, out);

	push	0
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	push	65535					; 0000ffffH
	mov	ecx, DWORD PTR _cell$[ebp]
	mov	edx, DWORD PTR [ecx+5]
	push	edx
	call	?Instance@StringCompressor@@SAPAV1@XZ	; StringCompressor::Instance
	mov	ecx, eax
	call	?EncodeString@StringCompressor@@QAEXPBDHPAVBitStream@RakNet@@H@Z ; StringCompressor::EncodeString

; 99   : 		}
; 100  : 		else

	jmp	SHORT $LN6@SerializeC
$LN2@SerializeC:

; 101  : 		{
; 102  : 			// Binary
; 103  : 			assert(columnType==DataStructures::Table::BINARY);

	cmp	DWORD PTR _columnType$[ebp], 2
	je	SHORT $LN8@SerializeC
	mov	eax, DWORD PTR ?__LINE__Var@?1??SerializeCell@TableSerializer@@SAXPAVBitStream@RakNet@@PAUCell@Table@DataStructures@@W4ColumnType@67@@Z@4JA@a74e26c4
	add	eax, 15					; 0000000fH
	push	eax
	push	OFFSET ??_C@_1FI@BBJMIGD@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAt?$AAa?$AAb?$AAl?$AAe?$AAs?$AAe?$AAr@
	push	OFFSET ??_C@_1FE@LFCOHDLN@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAT?$AAy?$AAp?$AAe?$AA?$DN?$AA?$DN?$AAD?$AAa?$AAt?$AAa?$AAS?$AAt?$AAr?$AAu?$AAc?$AAt?$AAu?$AAr?$AAe?$AAs?$AA?3?$AA?3?$AAT?$AAa?$AAb?$AAl@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN8@SerializeC:

; 104  : 			out->Write((unsigned)cell->i);

	mov	eax, DWORD PTR _cell$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	push	ecx
	mov	ecx, DWORD PTR _out$[ebp]
	call	??$Write@I@BitStream@RakNet@@QAEXI@Z	; RakNet::BitStream::Write<unsigned int>

; 105  : 			out->WriteAlignedBytes((const unsigned char *) cell->c, cell->i);

	mov	eax, DWORD PTR _cell$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	push	ecx
	mov	edx, DWORD PTR _cell$[ebp]
	mov	eax, DWORD PTR [edx+5]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	call	?WriteAlignedBytes@BitStream@RakNet@@QAEXPBEH@Z ; RakNet::BitStream::WriteAlignedBytes
$LN6@SerializeC:

; 106  : 		}
; 107  : 	}
; 108  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?SerializeCell@TableSerializer@@SAXPAVBitStream@RakNet@@PAUCell@Table@DataStructures@@W4ColumnType@56@@Z ENDP ; TableSerializer::SerializeCell
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\tableserializer.cpp
;	COMDAT ?DeserializeRow@TableSerializer@@SA_NPAVBitStream@RakNet@@PAVTable@DataStructures@@@Z
_TEXT	SEGMENT
_key$ = -44						; size = 4
_row$ = -32						; size = 4
_cellIndex$ = -20					; size = 4
_columns$ = -8						; size = 4
_in$ = 8						; size = 4
_out$ = 12						; size = 4
?DeserializeRow@TableSerializer@@SA_NPAVBitStream@RakNet@@PAVTable@DataStructures@@@Z PROC ; TableSerializer::DeserializeRow, COMDAT

; 69   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 70   : 	DataStructures::List<DataStructures::Table::ColumnDescriptor> &columns=out->GetColumns();

	mov	ecx, DWORD PTR _out$[ebp]
	call	?GetColumns@Table@DataStructures@@QAEAAV?$List@UColumnDescriptor@Table@DataStructures@@@2@XZ ; DataStructures::Table::GetColumns
	mov	DWORD PTR _columns$[ebp], eax

; 71   : 	unsigned cellIndex;
; 72   : 	DataStructures::Table::Row *row;
; 73   : 	unsigned key;
; 74   : 	if (in->Read(key)==false)

	lea	eax, DWORD PTR _key$[ebp]
	push	eax
	mov	ecx, DWORD PTR _in$[ebp]
	call	??$Read@I@BitStream@RakNet@@QAE_NAAI@Z	; RakNet::BitStream::Read<unsigned int>
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN5@Deserializ

; 75   : 		return false;

	xor	al, al
	jmp	SHORT $LN6@Deserializ
$LN5@Deserializ:

; 76   : 	row=out->AddRow(key);

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	call	?AddRow@Table@DataStructures@@QAEPAURow@12@I@Z ; DataStructures::Table::AddRow
	mov	DWORD PTR _row$[ebp], eax

; 77   : 	for (cellIndex=0; cellIndex<columns.Size(); cellIndex++)

	mov	DWORD PTR _cellIndex$[ebp], 0
	jmp	SHORT $LN4@Deserializ
$LN3@Deserializ:
	mov	eax, DWORD PTR _cellIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _cellIndex$[ebp], eax
$LN4@Deserializ:
	mov	ecx, DWORD PTR _columns$[ebp]
	call	?Size@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::Size
	cmp	DWORD PTR _cellIndex$[ebp], eax
	jae	SHORT $LN2@Deserializ

; 78   : 	{
; 79   : 		if (DeserializeCell(in, row->cells[cellIndex], columns[cellIndex].columnType)==false)

	mov	eax, DWORD PTR _cellIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _columns$[ebp]
	call	??A?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEAAUColumnDescriptor@Table@1@I@Z ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::operator[]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _cellIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _row$[ebp]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	call	?DeserializeCell@TableSerializer@@SA_NPAVBitStream@RakNet@@PAUCell@Table@DataStructures@@W4ColumnType@56@@Z ; TableSerializer::DeserializeCell
	add	esp, 12					; 0000000cH
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN1@Deserializ

; 80   : 		{
; 81   : 			out->RemoveRow(key);

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	call	?RemoveRow@Table@DataStructures@@QAEXI@Z ; DataStructures::Table::RemoveRow

; 82   : 			return false;

	xor	al, al
	jmp	SHORT $LN6@Deserializ
$LN1@Deserializ:

; 83   : 		}
; 84   : 	}

	jmp	SHORT $LN3@Deserializ
$LN2@Deserializ:

; 85   : 	return true;

	mov	al, 1
$LN6@Deserializ:

; 86   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@Deserializ
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN10@Deserializ:
	DD	1
	DD	$LN9@Deserializ
$LN9@Deserializ:
	DD	-44					; ffffffd4H
	DD	4
	DD	$LN8@Deserializ
$LN8@Deserializ:
	DB	107					; 0000006bH
	DB	101					; 00000065H
	DB	121					; 00000079H
	DB	0
?DeserializeRow@TableSerializer@@SA_NPAVBitStream@RakNet@@PAVTable@DataStructures@@@Z ENDP ; TableSerializer::DeserializeRow
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\tableserializer.cpp
;	COMDAT ?SerializeRow@TableSerializer@@SAXPAURow@Table@DataStructures@@IAAV?$List@UColumnDescriptor@Table@DataStructures@@@4@PAVBitStream@RakNet@@@Z
_TEXT	SEGMENT
_cellIndex$ = -8					; size = 4
_in$ = 8						; size = 4
_keyIn$ = 12						; size = 4
_columns$ = 16						; size = 4
_out$ = 20						; size = 4
?SerializeRow@TableSerializer@@SAXPAURow@Table@DataStructures@@IAAV?$List@UColumnDescriptor@Table@DataStructures@@@4@PAVBitStream@RakNet@@@Z PROC ; TableSerializer::SerializeRow, COMDAT

; 60   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 61   : 	unsigned cellIndex;
; 62   : 	out->Write(keyIn);

	mov	eax, DWORD PTR _keyIn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	call	??$Write@I@BitStream@RakNet@@QAEXI@Z	; RakNet::BitStream::Write<unsigned int>

; 63   : 	for (cellIndex=0; cellIndex<columns.Size(); cellIndex++)

	mov	DWORD PTR _cellIndex$[ebp], 0
	jmp	SHORT $LN3@SerializeR
$LN2@SerializeR:
	mov	eax, DWORD PTR _cellIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _cellIndex$[ebp], eax
$LN3@SerializeR:
	mov	ecx, DWORD PTR _columns$[ebp]
	call	?Size@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::Size
	cmp	DWORD PTR _cellIndex$[ebp], eax
	jae	SHORT $LN4@SerializeR

; 64   : 	{
; 65   : 		SerializeCell(out, in->cells[cellIndex], columns[cellIndex].columnType);

	mov	eax, DWORD PTR _cellIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _columns$[ebp]
	call	??A?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEAAUColumnDescriptor@Table@1@I@Z ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::operator[]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _cellIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _in$[ebp]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	?SerializeCell@TableSerializer@@SAXPAVBitStream@RakNet@@PAUCell@Table@DataStructures@@W4ColumnType@56@@Z ; TableSerializer::SerializeCell
	add	esp, 12					; 0000000cH

; 66   : 	}

	jmp	SHORT $LN2@SerializeR
$LN4@SerializeR:

; 67   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?SerializeRow@TableSerializer@@SAXPAURow@Table@DataStructures@@IAAV?$List@UColumnDescriptor@Table@DataStructures@@@4@PAVBitStream@RakNet@@@Z ENDP ; TableSerializer::SerializeRow
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\tableserializer.cpp
;	COMDAT ?DeserializeTable@TableSerializer@@SA_NPAEIPAVTable@DataStructures@@@Z
_TEXT	SEGMENT
$T2 = -633						; size = 1
$T3 = -621						; size = 1
$T4 = -609						; size = 1
$T5 = -597						; size = 1
_rowIndex$ = -396					; size = 4
_i$ = -384						; size = 4
_columnName$ = -372					; size = 32
_rowSize$ = -332					; size = 4
_columnType$ = -317					; size = 1
_columnSize$ = -308					; size = 4
_in$ = -296						; size = 273
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_serializedTable$ = 8					; size = 4
_tableLength$ = 12					; size = 4
_out$ = 16						; size = 4
?DeserializeTable@TableSerializer@@SA_NPAEIPAVTable@DataStructures@@@Z PROC ; TableSerializer::DeserializeTable, COMDAT

; 29   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DeserializeTable@TableSerializer@@SA_NPAEIPAVTable@DataStructures@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 628				; 00000274H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-640]
	mov	ecx, 157				; 0000009dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 30   : 	RakNet::BitStream in((unsigned char*) serializedTable, tableLength, false);

	push	0
	mov	eax, DWORD PTR _tableLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _serializedTable$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _in$[ebp]
	call	??0BitStream@RakNet@@QAE@PAEI_N@Z	; RakNet::BitStream::BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 31   : 
; 32   : 	unsigned columnSize;
; 33   : 	unsigned char columnType;
; 34   : 	unsigned rowSize;
; 35   : 	char columnName[_TABLE_MAX_COLUMN_NAME_LENGTH];
; 36   : 	if (in.Read(columnSize)==false || columnSize > 10000)

	lea	eax, DWORD PTR _columnSize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _in$[ebp]
	call	??$Read@I@BitStream@RakNet@@QAE_NAAI@Z	; RakNet::BitStream::Read<unsigned int>
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN10@Deserializ
	cmp	DWORD PTR _columnSize$[ebp], 10000	; 00002710H
	jbe	SHORT $LN11@Deserializ
$LN10@Deserializ:

; 37   : 		return false; // Hacker crash prevention

	mov	BYTE PTR $T2[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _in$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	al, BYTE PTR $T2[ebp]
	jmp	$LN12@Deserializ
$LN11@Deserializ:

; 38   : 
; 39   : 	out->Clear();

	mov	ecx, DWORD PTR _out$[ebp]
	call	?Clear@Table@DataStructures@@QAEXXZ	; DataStructures::Table::Clear

; 40   : 	unsigned i;
; 41   : 	for (i=0; i<columnSize; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN9@Deserializ
$LN8@Deserializ:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN9@Deserializ:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _columnSize$[ebp]
	jae	SHORT $LN7@Deserializ

; 42   : 	{
; 43   : 		stringCompressor->DecodeString(columnName, 32, &in);

	push	0
	lea	eax, DWORD PTR _in$[ebp]
	push	eax
	push	32					; 00000020H
	lea	ecx, DWORD PTR _columnName$[ebp]
	push	ecx
	call	?Instance@StringCompressor@@SAPAV1@XZ	; StringCompressor::Instance
	mov	ecx, eax
	call	?DecodeString@StringCompressor@@QAE_NPADHPAVBitStream@RakNet@@H@Z ; StringCompressor::DecodeString

; 44   : 		in.Read(columnType);

	lea	eax, DWORD PTR _columnType$[ebp]
	push	eax
	lea	ecx, DWORD PTR _in$[ebp]
	call	??$Read@E@BitStream@RakNet@@QAE_NAAE@Z	; RakNet::BitStream::Read<unsigned char>

; 45   : 		out->AddColumn(columnName, (DataStructures::Table::ColumnType)columnType);

	movzx	eax, BYTE PTR _columnType$[ebp]
	push	eax
	lea	ecx, DWORD PTR _columnName$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _out$[ebp]
	call	?AddColumn@Table@DataStructures@@QAEIQADW4ColumnType@12@@Z ; DataStructures::Table::AddColumn

; 46   : 	}

	jmp	SHORT $LN8@Deserializ
$LN7@Deserializ:

; 47   : 
; 48   : 	if (in.Read(rowSize)==false || rowSize>100000)

	lea	eax, DWORD PTR _rowSize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _in$[ebp]
	call	??$Read@I@BitStream@RakNet@@QAE_NAAI@Z	; RakNet::BitStream::Read<unsigned int>
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@Deserializ
	cmp	DWORD PTR _rowSize$[ebp], 100000	; 000186a0H
	jbe	SHORT $LN6@Deserializ
$LN5@Deserializ:

; 49   : 		return false; // Hacker crash prevention

	mov	BYTE PTR $T3[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _in$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	al, BYTE PTR $T3[ebp]
	jmp	$LN12@Deserializ
$LN6@Deserializ:

; 50   : 
; 51   : 	unsigned rowIndex;
; 52   : 	for (rowIndex=0; rowIndex < rowSize; rowIndex++)

	mov	DWORD PTR _rowIndex$[ebp], 0
	jmp	SHORT $LN4@Deserializ
$LN3@Deserializ:
	mov	eax, DWORD PTR _rowIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _rowIndex$[ebp], eax
$LN4@Deserializ:
	mov	eax, DWORD PTR _rowIndex$[ebp]
	cmp	eax, DWORD PTR _rowSize$[ebp]
	jae	SHORT $LN2@Deserializ

; 53   : 	{
; 54   : 		if (DeserializeRow(&in, out)==false)

	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	lea	ecx, DWORD PTR _in$[ebp]
	push	ecx
	call	?DeserializeRow@TableSerializer@@SA_NPAVBitStream@RakNet@@PAVTable@DataStructures@@@Z ; TableSerializer::DeserializeRow
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN1@Deserializ

; 55   : 			return false;

	mov	BYTE PTR $T4[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _in$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	al, BYTE PTR $T4[ebp]
	jmp	SHORT $LN12@Deserializ
$LN1@Deserializ:

; 56   : 	}

	jmp	SHORT $LN3@Deserializ
$LN2@Deserializ:

; 57   : 	return true;

	mov	BYTE PTR $T5[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _in$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	al, BYTE PTR $T5[ebp]
$LN12@Deserializ:

; 58   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN22@Deserializ
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 640				; 00000280H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN22@Deserializ:
	DD	5
	DD	$LN21@Deserializ
$LN21@Deserializ:
	DD	-296					; fffffed8H
	DD	273					; 00000111H
	DD	$LN15@Deserializ
	DD	-308					; fffffeccH
	DD	4
	DD	$LN16@Deserializ
	DD	-317					; fffffec3H
	DD	1
	DD	$LN17@Deserializ
	DD	-332					; fffffeb4H
	DD	4
	DD	$LN18@Deserializ
	DD	-372					; fffffe8cH
	DD	32					; 00000020H
	DD	$LN19@Deserializ
$LN19@Deserializ:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	110					; 0000006eH
	DB	78					; 0000004eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$LN18@Deserializ:
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	119					; 00000077H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$LN17@Deserializ:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	110					; 0000006eH
	DB	84					; 00000054H
	DB	121					; 00000079H
	DB	112					; 00000070H
	DB	101					; 00000065H
	DB	0
$LN16@Deserializ:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	110					; 0000006eH
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$LN15@Deserializ:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DeserializeTable@TableSerializer@@SA_NPAEIPAVTable@DataStructures@@@Z$0:
	lea	ecx, DWORD PTR _in$[ebp]
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__ehhandler$?DeserializeTable@TableSerializer@@SA_NPAEIPAVTable@DataStructures@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-644]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DeserializeTable@TableSerializer@@SA_NPAEIPAVTable@DataStructures@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DeserializeTable@TableSerializer@@SA_NPAEIPAVTable@DataStructures@@@Z ENDP ; TableSerializer::DeserializeTable
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\tableserializer.cpp
;	COMDAT ?SerializeTable@TableSerializer@@SAXPAVTable@DataStructures@@PAVBitStream@RakNet@@@Z
_TEXT	SEGMENT
_rowIndex$ = -44					; size = 4
_i$ = -32						; size = 4
_cur$ = -20						; size = 4
_columns$ = -8						; size = 4
_in$ = 8						; size = 4
_out$ = 12						; size = 4
?SerializeTable@TableSerializer@@SAXPAVTable@DataStructures@@PAVBitStream@RakNet@@@Z PROC ; TableSerializer::SerializeTable, COMDAT

; 7    : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 8    : 	DataStructures::List<DataStructures::Table::ColumnDescriptor> &columns=in->GetColumns();

	mov	ecx, DWORD PTR _in$[ebp]
	call	?GetColumns@Table@DataStructures@@QAEAAV?$List@UColumnDescriptor@Table@DataStructures@@@2@XZ ; DataStructures::Table::GetColumns
	mov	DWORD PTR _columns$[ebp], eax

; 9    : 	DataStructures::Page<unsigned, DataStructures::Table::Row*, _TABLE_BPLUS_TREE_ORDER> *cur = in->GetRows().GetListHead();

	mov	ecx, DWORD PTR _in$[ebp]
	call	?GetRows@Table@DataStructures@@QAEAAV?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@2@XZ ; DataStructures::Table::GetRows
	mov	ecx, eax
	call	?GetListHead@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QBEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@XZ ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::GetListHead
	mov	DWORD PTR _cur$[ebp], eax

; 10   : 	out->Write((unsigned)columns.Size());

	mov	ecx, DWORD PTR _columns$[ebp]
	call	?Size@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::Size
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	call	??$Write@I@BitStream@RakNet@@QAEXI@Z	; RakNet::BitStream::Write<unsigned int>

; 11   : 	unsigned i;
; 12   : 	for (i=0; i<columns.Size(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN8@SerializeT
$LN7@SerializeT:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN8@SerializeT:
	mov	ecx, DWORD PTR _columns$[ebp]
	call	?Size@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN6@SerializeT

; 13   : 	{
; 14   : 		stringCompressor->EncodeString(columns[i].columnName, _TABLE_MAX_COLUMN_NAME_LENGTH, out);

	push	0
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	push	32					; 00000020H
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _columns$[ebp]
	call	??A?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEAAUColumnDescriptor@Table@1@I@Z ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::operator[]
	push	eax
	call	?Instance@StringCompressor@@SAPAV1@XZ	; StringCompressor::Instance
	mov	ecx, eax
	call	?EncodeString@StringCompressor@@QAEXPBDHPAVBitStream@RakNet@@H@Z ; StringCompressor::EncodeString

; 15   : 		out->Write((unsigned char)columns[i].columnType);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _columns$[ebp]
	call	??A?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEAAUColumnDescriptor@Table@1@I@Z ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::operator[]
	mov	cl, BYTE PTR [eax+32]
	movzx	edx, cl
	push	edx
	mov	ecx, DWORD PTR _out$[ebp]
	call	??$Write@E@BitStream@RakNet@@QAEXE@Z	; RakNet::BitStream::Write<unsigned char>

; 16   : 	}

	jmp	SHORT $LN7@SerializeT
$LN6@SerializeT:

; 17   : 	out->Write((unsigned)in->GetRows().Size());

	mov	ecx, DWORD PTR _in$[ebp]
	call	?GetRows@Table@DataStructures@@QAEAAV?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@2@XZ ; DataStructures::Table::GetRows
	mov	ecx, eax
	call	?Size@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QBEIXZ ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::Size
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	call	??$Write@I@BitStream@RakNet@@QAEXI@Z	; RakNet::BitStream::Write<unsigned int>
$LN5@SerializeT:

; 18   : 	unsigned rowIndex;
; 19   : 	while (cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN9@SerializeT

; 20   : 	{
; 21   : 		for (rowIndex=0; rowIndex < (unsigned)cur->size; rowIndex++)

	mov	DWORD PTR _rowIndex$[ebp], 0
	jmp	SHORT $LN3@SerializeT
$LN2@SerializeT:
	mov	eax, DWORD PTR _rowIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _rowIndex$[ebp], eax
$LN3@SerializeT:
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _rowIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+1]
	jae	SHORT $LN1@SerializeT

; 22   : 		{
; 23   : 			SerializeRow(cur->data[rowIndex], cur->keys[rowIndex], columns, out);

	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	mov	ecx, DWORD PTR _columns$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rowIndex$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+5]
	push	ecx
	mov	edx, DWORD PTR _rowIndex$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+69]
	push	ecx
	call	?SerializeRow@TableSerializer@@SAXPAURow@Table@DataStructures@@IAAV?$List@UColumnDescriptor@Table@DataStructures@@@4@PAVBitStream@RakNet@@@Z ; TableSerializer::SerializeRow
	add	esp, 16					; 00000010H

; 24   : 		}

	jmp	SHORT $LN2@SerializeT
$LN1@SerializeT:

; 25   : 		cur=cur->next;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+133]
	mov	DWORD PTR _cur$[ebp], ecx

; 26   : 	}

	jmp	SHORT $LN5@SerializeT
$LN9@SerializeT:

; 27   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?SerializeTable@TableSerializer@@SAXPAVTable@DataStructures@@PAVBitStream@RakNet@@@Z ENDP ; TableSerializer::SerializeTable
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Size@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEIXZ PROC ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::Size, COMDAT
; _this$ = ecx

; 373  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 374  : 		return list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 375  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEIXZ ENDP ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??A?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEAAUColumnDescriptor@Table@1@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
??A?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEAAUColumnDescriptor@Table@1@I@Z PROC ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::operator[], COMDAT
; _this$ = ecx

; 185  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 186  : #ifdef _DEBUG
; 187  : 		assert ( position < list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN3@operator
	push	187					; 000000bbH
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@operator:

; 188  : #endif
; 189  : 		return listArray[ position ];

	imul	eax, DWORD PTR _position$[ebp], 36
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]

; 190  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEAAUColumnDescriptor@Table@1@I@Z ENDP ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?GetListHead@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QBEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetListHead@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QBEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@XZ PROC ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::GetListHead, COMDAT
; _this$ = ecx

; 947  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 948  : 		return leftmostLeaf;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]

; 949  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetListHead@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QBEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@XZ ENDP ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::GetListHead
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?Size@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_cur$ = -32						; size = 4
_count$ = -20						; size = 4
_this$ = -8						; size = 4
?Size@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QBEIXZ PROC ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::Size, COMDAT
; _this$ = ecx

; 878  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 879  : 		int count=0;

	mov	DWORD PTR _count$[ebp], 0

; 880  : 		DataStructures::Page<KeyType, DataType, order> *cur = GetListHead();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetListHead@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QBEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@XZ ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::GetListHead
	mov	DWORD PTR _cur$[ebp], eax
$LN2@Size:

; 881  : 		while (cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN1@Size

; 882  : 		{
; 883  : 			count+=cur->size;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	add	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR _count$[ebp], ecx

; 884  : 			cur=cur->next;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+133]
	mov	DWORD PTR _cur$[ebp], ecx

; 885  : 		}

	jmp	SHORT $LN2@Size
$LN1@Size:

; 886  : 		return count;

	mov	eax, DWORD PTR _count$[ebp]

; 887  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QBEIXZ ENDP ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z PROC ; DataStructures::List<DataStructures::Table::Cell *>::operator[], COMDAT
; _this$ = ecx

; 185  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 186  : #ifdef _DEBUG
; 187  : 		assert ( position < list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN3@operator
	push	187					; 000000bbH
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@operator:

; 188  : #endif
; 189  : 		return listArray[ position ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _position$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 190  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ENDP ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
_TEXT	ENDS
END
