; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.31101.0 

	TITLE	Z:\sampsrc\02Xu1\raknet\ReliabilityLayer.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
_PACKETLOSS_TOLERANCE DD 03ca3d70ar		; 0.02
_PING_MULTIPLIER_TO_RESEND DD 040400000r	; 3
_MINIMUM_SEND_BPS DQ 040cc200000000000r		; 14400
_STARTING_SEND_BPS DQ 040dc200000000000r	; 28800
CONST	ENDS
PUBLIC	?Instance@SocketLayer@@SAPAV1@XZ		; SocketLayer::Instance
PUBLIC	?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ	; RakNet::BitStream::GetNumberOfBitsUsed
PUBLIC	?GetWriteOffset@BitStream@RakNet@@QBEHXZ	; RakNet::BitStream::GetWriteOffset
PUBLIC	?GetNumberOfBytesUsed@BitStream@RakNet@@QBEHXZ	; RakNet::BitStream::GetNumberOfBytesUsed
PUBLIC	?GetNumberOfUnreadBits@BitStream@RakNet@@QBEHXZ	; RakNet::BitStream::GetNumberOfUnreadBits
PUBLIC	?GetData@BitStream@RakNet@@QBEPAEXZ		; RakNet::BitStream::GetData
PUBLIC	??$Write@_N@BitStream@RakNet@@QAEX_N@Z		; RakNet::BitStream::Write<bool>
PUBLIC	??$Write@G@BitStream@RakNet@@QAEXG@Z		; RakNet::BitStream::Write<unsigned short>
PUBLIC	??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z	; RakNet::BitStream::Read<bool>
PUBLIC	??$Read@G@BitStream@RakNet@@QAE_NAAG@Z		; RakNet::BitStream::Read<unsigned short>
PUBLIC	?GetPointer@InternalPacketPool@@QAEPAUInternalPacket@@XZ ; InternalPacketPool::GetPointer
PUBLIC	??0?$Queue@PAUInternalPacket@@@DataStructures@@QAE@XZ ; DataStructures::Queue<InternalPacket *>::Queue<InternalPacket *>
PUBLIC	??1?$Queue@PAUInternalPacket@@@DataStructures@@QAE@XZ ; DataStructures::Queue<InternalPacket *>::~Queue<InternalPacket *>
PUBLIC	?Push@?$Queue@PAUInternalPacket@@@DataStructures@@QAEXABQAUInternalPacket@@@Z ; DataStructures::Queue<InternalPacket *>::Push
PUBLIC	?PushAtHead@?$Queue@PAUInternalPacket@@@DataStructures@@QAEXABQAUInternalPacket@@I@Z ; DataStructures::Queue<InternalPacket *>::PushAtHead
PUBLIC	??A?$Queue@PAUInternalPacket@@@DataStructures@@QBEAAPAUInternalPacket@@I@Z ; DataStructures::Queue<InternalPacket *>::operator[]
PUBLIC	?Del@?$Queue@PAUInternalPacket@@@DataStructures@@QAEXI@Z ; DataStructures::Queue<InternalPacket *>::Del
PUBLIC	?Peek@?$Queue@PAUInternalPacket@@@DataStructures@@QBEPAUInternalPacket@@XZ ; DataStructures::Queue<InternalPacket *>::Peek
PUBLIC	?Pop@?$Queue@PAUInternalPacket@@@DataStructures@@QAEPAUInternalPacket@@XZ ; DataStructures::Queue<InternalPacket *>::Pop
PUBLIC	?Size@?$Queue@PAUInternalPacket@@@DataStructures@@QBEIXZ ; DataStructures::Queue<InternalPacket *>::Size
PUBLIC	?ClearAndForceAllocation@?$Queue@PAUInternalPacket@@@DataStructures@@QAEXH@Z ; DataStructures::Queue<InternalPacket *>::ClearAndForceAllocation
PUBLIC	?SplitPacketIndexComp@@YAHABIABQAUInternalPacket@@@Z ; SplitPacketIndexComp
PUBLIC	??0?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>
PUBLIC	??1?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::~OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>
PUBLIC	?GetIndexFromKey@?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEIABIPA_N@Z ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::GetIndexFromKey
PUBLIC	?Insert@?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QAEIABIABQAUInternalPacket@@@Z ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::Insert
PUBLIC	??A?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEAAPAUInternalPacket@@I@Z ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::operator[]
PUBLIC	?Clear@?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QAEXXZ ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::Clear
PUBLIC	?Size@?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::Size
PUBLIC	??0?$List@PAUInternalPacket@@@DataStructures@@QAE@XZ ; DataStructures::List<InternalPacket *>::List<InternalPacket *>
PUBLIC	??1?$List@PAUInternalPacket@@@DataStructures@@QAE@XZ ; DataStructures::List<InternalPacket *>::~List<InternalPacket *>
PUBLIC	??A?$List@PAUInternalPacket@@@DataStructures@@QBEAAPAUInternalPacket@@I@Z ; DataStructures::List<InternalPacket *>::operator[]
PUBLIC	?Insert@?$List@PAUInternalPacket@@@DataStructures@@QAEXQAUInternalPacket@@I@Z ; DataStructures::List<InternalPacket *>::Insert
PUBLIC	?Insert@?$List@PAUInternalPacket@@@DataStructures@@QAEXQAUInternalPacket@@@Z ; DataStructures::List<InternalPacket *>::Insert
PUBLIC	?RemoveAtIndex@?$List@PAUInternalPacket@@@DataStructures@@QAEXI@Z ; DataStructures::List<InternalPacket *>::RemoveAtIndex
PUBLIC	?Del@?$List@PAUInternalPacket@@@DataStructures@@QAEXI@Z ; DataStructures::List<InternalPacket *>::Del
PUBLIC	?Size@?$List@PAUInternalPacket@@@DataStructures@@QBEIXZ ; DataStructures::List<InternalPacket *>::Size
PUBLIC	?Clear@?$List@PAUInternalPacket@@@DataStructures@@QAEX_N@Z ; DataStructures::List<InternalPacket *>::Clear
PUBLIC	??0SplitPacketChannel@@QAE@XZ			; SplitPacketChannel::SplitPacketChannel
PUBLIC	??1SplitPacketChannel@@QAE@XZ			; SplitPacketChannel::~SplitPacketChannel
PUBLIC	??_GSplitPacketChannel@@QAEPAXI@Z		; SplitPacketChannel::`scalar deleting destructor'
PUBLIC	?SplitPacketChannelComp@@YAHABGABQAUSplitPacketChannel@@@Z ; SplitPacketChannelComp
PUBLIC	??0ReliabilityLayer@@QAE@XZ			; ReliabilityLayer::ReliabilityLayer
PUBLIC	??1ReliabilityLayer@@QAE@XZ			; ReliabilityLayer::~ReliabilityLayer
PUBLIC	?Reset@ReliabilityLayer@@QAEX_N@Z		; ReliabilityLayer::Reset
PUBLIC	?SetEncryptionKey@ReliabilityLayer@@QAEXPBE@Z	; ReliabilityLayer::SetEncryptionKey
PUBLIC	?SetSocket@ReliabilityLayer@@QAEXI@Z		; ReliabilityLayer::SetSocket
PUBLIC	?GetSocket@ReliabilityLayer@@QAEIXZ		; ReliabilityLayer::GetSocket
PUBLIC	?SetTimeoutTime@ReliabilityLayer@@QAEXI@Z	; ReliabilityLayer::SetTimeoutTime
PUBLIC	?GetTimeoutTime@ReliabilityLayer@@QAEIXZ	; ReliabilityLayer::GetTimeoutTime
PUBLIC	?HandleSocketReceiveFromConnectedPlayer@ReliabilityLayer@@QAE_NPBDHUPlayerID@@AAV?$List@PAVPluginInterface@@@DataStructures@@H@Z ; ReliabilityLayer::HandleSocketReceiveFromConnectedPlayer
PUBLIC	?Receive@ReliabilityLayer@@QAEHPAPAE@Z		; ReliabilityLayer::Receive
PUBLIC	?Send@ReliabilityLayer@@QAE_NPADHW4PacketPriority@@W4PacketReliability@@E_NH_J@Z ; ReliabilityLayer::Send
PUBLIC	?Update@ReliabilityLayer@@QAEXIUPlayerID@@H_JAAV?$List@PAVPluginInterface@@@DataStructures@@@Z ; ReliabilityLayer::Update
PUBLIC	?IsCheater@ReliabilityLayer@@QBE_NXZ		; ReliabilityLayer::IsCheater
PUBLIC	?IsDeadConnection@ReliabilityLayer@@QBE_NXZ	; ReliabilityLayer::IsDeadConnection
PUBLIC	?KillConnection@ReliabilityLayer@@QAEXXZ	; ReliabilityLayer::KillConnection
PUBLIC	?SetPing@ReliabilityLayer@@QAEXI@Z		; ReliabilityLayer::SetPing
PUBLIC	?GetStatistics@ReliabilityLayer@@QAEQAURakNetStatisticsStruct@@XZ ; ReliabilityLayer::GetStatistics
PUBLIC	?IsDataWaiting@ReliabilityLayer@@QAE_NXZ	; ReliabilityLayer::IsDataWaiting
PUBLIC	?AreAcksWaiting@ReliabilityLayer@@QAE_NXZ	; ReliabilityLayer::AreAcksWaiting
PUBLIC	?ApplyNetworkSimulator@ReliabilityLayer@@QAEXNII@Z ; ReliabilityLayer::ApplyNetworkSimulator
PUBLIC	?SetSplitMessageProgressInterval@ReliabilityLayer@@QAEXH@Z ; ReliabilityLayer::SetSplitMessageProgressInterval
PUBLIC	?SetUnreliableTimeout@ReliabilityLayer@@QAEXI@Z	; ReliabilityLayer::SetUnreliableTimeout
PUBLIC	?GenerateDatagram@ReliabilityLayer@@AAEIPAVBitStream@RakNet@@HPA_N_JUPlayerID@@AAV?$List@PAVPluginInterface@@@DataStructures@@@Z ; ReliabilityLayer::GenerateDatagram
PUBLIC	?SendBitStream@ReliabilityLayer@@AAEXIUPlayerID@@PAVBitStream@RakNet@@@Z ; ReliabilityLayer::SendBitStream
PUBLIC	?WriteToBitStreamFromInternalPacket@ReliabilityLayer@@AAEHPAVBitStream@RakNet@@QBUInternalPacket@@@Z ; ReliabilityLayer::WriteToBitStreamFromInternalPacket
PUBLIC	?CreateInternalPacketFromBitStream@ReliabilityLayer@@AAEPAUInternalPacket@@PAVBitStream@RakNet@@_J@Z ; ReliabilityLayer::CreateInternalPacketFromBitStream
PUBLIC	?RemovePacketFromResendListAndDeleteOlderReliableSequenced@ReliabilityLayer@@AAEIG_J@Z ; ReliabilityLayer::RemovePacketFromResendListAndDeleteOlderReliableSequenced
PUBLIC	?SendAcknowledgementPacket@ReliabilityLayer@@AAEXG_J@Z ; ReliabilityLayer::SendAcknowledgementPacket
PUBLIC	?IsSendThrottled@ReliabilityLayer@@AAE_NH@Z	; ReliabilityLayer::IsSendThrottled
PUBLIC	?UpdateWindowFromPacketloss@ReliabilityLayer@@AAEX_J@Z ; ReliabilityLayer::UpdateWindowFromPacketloss
PUBLIC	?UpdateWindowFromAck@ReliabilityLayer@@AAEX_J@Z	; ReliabilityLayer::UpdateWindowFromAck
PUBLIC	?GetBitStreamHeaderLength@ReliabilityLayer@@AAEHQBUInternalPacket@@@Z ; ReliabilityLayer::GetBitStreamHeaderLength
PUBLIC	?GetSHA1@ReliabilityLayer@@AAEXQAEIQAD@Z	; ReliabilityLayer::GetSHA1
PUBLIC	?CheckSHA1@ReliabilityLayer@@AAE_NQADQAEI@Z	; ReliabilityLayer::CheckSHA1
PUBLIC	?DeleteSequencedPacketsInList@ReliabilityLayer@@AAEXEAAV?$List@PAUInternalPacket@@@DataStructures@@H@Z ; ReliabilityLayer::DeleteSequencedPacketsInList
PUBLIC	?DeleteSequencedPacketsInList@ReliabilityLayer@@AAEXEAAV?$Queue@PAUInternalPacket@@@DataStructures@@@Z ; ReliabilityLayer::DeleteSequencedPacketsInList
PUBLIC	?IsOlderOrderedPacket@ReliabilityLayer@@AAE_NGG@Z ; ReliabilityLayer::IsOlderOrderedPacket
PUBLIC	?SplitPacket@ReliabilityLayer@@AAEXPAUInternalPacket@@H@Z ; ReliabilityLayer::SplitPacket
PUBLIC	?InsertIntoSplitPacketList@ReliabilityLayer@@AAEXPAUInternalPacket@@_J@Z ; ReliabilityLayer::InsertIntoSplitPacketList
PUBLIC	?BuildPacketFromSplitPacketList@ReliabilityLayer@@AAEPAUInternalPacket@@G_J@Z ; ReliabilityLayer::BuildPacketFromSplitPacketList
PUBLIC	?DeleteOldUnreliableSplitPackets@ReliabilityLayer@@AAEX_J@Z ; ReliabilityLayer::DeleteOldUnreliableSplitPackets
PUBLIC	?CreateInternalPacketCopy@ReliabilityLayer@@AAEPAUInternalPacket@@PAU2@HH_J@Z ; ReliabilityLayer::CreateInternalPacketCopy
PUBLIC	?GetOrderingListAtOrderingStream@ReliabilityLayer@@AAEPAV?$LinkedList@PAUInternalPacket@@@DataStructures@@E@Z ; ReliabilityLayer::GetOrderingListAtOrderingStream
PUBLIC	?AddToOrderingList@ReliabilityLayer@@AAEXPAUInternalPacket@@@Z ; ReliabilityLayer::AddToOrderingList
PUBLIC	?InsertPacketIntoResendList@ReliabilityLayer@@AAEXPAUInternalPacket@@_J_N2@Z ; ReliabilityLayer::InsertPacketIntoResendList
PUBLIC	?FreeMemory@ReliabilityLayer@@AAEX_N@Z		; ReliabilityLayer::FreeMemory
PUBLIC	?FreeThreadedMemory@ReliabilityLayer@@AAEXXZ	; ReliabilityLayer::FreeThreadedMemory
PUBLIC	?FreeThreadSafeMemory@ReliabilityLayer@@AAEXXZ	; ReliabilityLayer::FreeThreadSafeMemory
PUBLIC	?InitializeVariables@ReliabilityLayer@@AAEXXZ	; ReliabilityLayer::InitializeVariables
PUBLIC	?UpdateNextActionTime@ReliabilityLayer@@AAEXXZ	; ReliabilityLayer::UpdateNextActionTime
PUBLIC	?GetResendListDataSize@ReliabilityLayer@@ABEIXZ	; ReliabilityLayer::GetResendListDataSize
PUBLIC	?UpdateThreadedMemory@ReliabilityLayer@@AAEXXZ	; ReliabilityLayer::UpdateThreadedMemory
PUBLIC	??0?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::List<DataStructures::LinkedList<InternalPacket *> *>::List<DataStructures::LinkedList<InternalPacket *> *>
PUBLIC	??1?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::List<DataStructures::LinkedList<InternalPacket *> *>::~List<DataStructures::LinkedList<InternalPacket *> *>
PUBLIC	??A?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QBEAAPAV?$LinkedList@PAUInternalPacket@@@1@I@Z ; DataStructures::List<DataStructures::LinkedList<InternalPacket *> *>::operator[]
PUBLIC	?Replace@?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QAEXQAV?$LinkedList@PAUInternalPacket@@@2@0I@Z ; DataStructures::List<DataStructures::LinkedList<InternalPacket *> *>::Replace
PUBLIC	?Size@?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::LinkedList<InternalPacket *> *>::Size
PUBLIC	?Clear@?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QAEX_N@Z ; DataStructures::List<DataStructures::LinkedList<InternalPacket *> *>::Clear
PUBLIC	??0?$RangeList@G@DataStructures@@QAE@XZ		; DataStructures::RangeList<unsigned short>::RangeList<unsigned short>
PUBLIC	??1?$RangeList@G@DataStructures@@QAE@XZ		; DataStructures::RangeList<unsigned short>::~RangeList<unsigned short>
PUBLIC	?Insert@?$RangeList@G@DataStructures@@QAEXG@Z	; DataStructures::RangeList<unsigned short>::Insert
PUBLIC	?Clear@?$RangeList@G@DataStructures@@QAEXXZ	; DataStructures::RangeList<unsigned short>::Clear
PUBLIC	?Size@?$RangeList@G@DataStructures@@QAEIXZ	; DataStructures::RangeList<unsigned short>::Size
PUBLIC	?Serialize@?$RangeList@G@DataStructures@@QAEIPAVBitStream@RakNet@@H_N@Z ; DataStructures::RangeList<unsigned short>::Serialize
PUBLIC	?Deserialize@?$RangeList@G@DataStructures@@QAE_NPAVBitStream@RakNet@@@Z ; DataStructures::RangeList<unsigned short>::Deserialize
PUBLIC	??$RangeNodeComp@G@DataStructures@@YAHABGABU?$RangeNode@G@0@@Z ; DataStructures::RangeNodeComp<unsigned short>
PUBLIC	??0?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >
PUBLIC	??1?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::~OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >
PUBLIC	?GetIndexFromKey@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEIABGPA_N@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::GetIndexFromKey
PUBLIC	?Insert@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAEIABGABU?$RangeNode@G@2@@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::Insert
PUBLIC	??A?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::operator[]
PUBLIC	?RemoveAtIndex@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAEXI@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::RemoveAtIndex
PUBLIC	?InsertAtIndex@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAEXABU?$RangeNode@G@2@I@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::InsertAtIndex
PUBLIC	?InsertAtEnd@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAEXABU?$RangeNode@G@2@@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::InsertAtEnd
PUBLIC	?Del@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAEXI@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::Del
PUBLIC	?Clear@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAEXXZ ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::Clear
PUBLIC	?Size@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::Size
PUBLIC	??0?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::List<DataStructures::RangeNode<unsigned short> >
PUBLIC	??1?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::~List<DataStructures::RangeNode<unsigned short> >
PUBLIC	??A?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::operator[]
PUBLIC	?Insert@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXU?$RangeNode@G@2@I@Z ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::Insert
PUBLIC	?Insert@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXU?$RangeNode@G@2@@Z ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::Insert
PUBLIC	?RemoveAtIndex@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXI@Z ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::RemoveAtIndex
PUBLIC	?Del@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXI@Z ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::Del
PUBLIC	?Size@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::Size
PUBLIC	?Clear@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEX_N@Z ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::Clear
PUBLIC	??0?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QAE@XZ ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::BPlusTree<unsigned short,InternalPacket *,32>
PUBLIC	??1?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QAE@XZ ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::~BPlusTree<unsigned short,InternalPacket *,32>
PUBLIC	?Delete@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QAE_NGAAPAUInternalPacket@@@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::Delete
PUBLIC	?Insert@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QAE_NGABQAUInternalPacket@@@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::Insert
PUBLIC	?Preallocate@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QAEXH@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::Preallocate
PUBLIC	?Clear@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QAEXXZ ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::Clear
PUBLIC	?Size@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QBEIXZ ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::Size
PUBLIC	?IsEmpty@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QBE_NXZ ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::IsEmpty
PUBLIC	?GetListHead@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QBEPAU?$Page@GPAUInternalPacket@@$0CA@@2@XZ ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::GetListHead
PUBLIC	?DeleteFromPageAtIndex@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEXHPAU?$Page@GPAUInternalPacket@@$0CA@@2@@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::DeleteFromPageAtIndex
PUBLIC	?FreePages@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEXXZ ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::FreePages
PUBLIC	?GetIndexOf@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IBE_NGPAU?$Page@GPAUInternalPacket@@$0CA@@2@PAH@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::GetIndexOf
PUBLIC	?CanRotateLeft@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAE_NPAU?$Page@GPAUInternalPacket@@$0CA@@2@H@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::CanRotateLeft
PUBLIC	?CanRotateRight@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAE_NPAU?$Page@GPAUInternalPacket@@$0CA@@2@H@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::CanRotateRight
PUBLIC	?RotateRight@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEXPAU?$Page@GPAUInternalPacket@@$0CA@@2@HPAUReturnAction@12@@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::RotateRight
PUBLIC	?RotateLeft@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEXPAU?$Page@GPAUInternalPacket@@$0CA@@2@HPAUReturnAction@12@@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::RotateLeft
PUBLIC	?InsertIntoNode@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEPAU?$Page@GPAUInternalPacket@@$0CA@@2@GABQAUInternalPacket@@HPAU32@1PAUReturnAction@12@@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::InsertIntoNode
PUBLIC	?InsertBranchDown@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEPAU?$Page@GPAUInternalPacket@@$0CA@@2@GABQAUInternalPacket@@PAU32@PAUReturnAction@12@PA_N@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::InsertBranchDown
PUBLIC	?FindDeleteRebalance@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAE_NGPAU?$Page@GPAUInternalPacket@@$0CA@@2@PA_NGPAUReturnAction@12@AAPAUInternalPacket@@@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::FindDeleteRebalance
PUBLIC	?FixUnderflow@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAE_NHPAU?$Page@GPAUInternalPacket@@$0CA@@2@GPAUReturnAction@12@@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::FixUnderflow
PUBLIC	?ShiftNodeLeft@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEXPAU?$Page@GPAUInternalPacket@@$0CA@@2@@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::ShiftNodeLeft
PUBLIC	?ShiftNodeRight@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEXPAU?$Page@GPAUInternalPacket@@$0CA@@2@@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::ShiftNodeRight
PUBLIC	??0?$MemoryPool@U?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::MemoryPool<DataStructures::Page<unsigned short,InternalPacket *,32> >::MemoryPool<DataStructures::Page<unsigned short,InternalPacket *,32> >
PUBLIC	??1?$MemoryPool@U?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::MemoryPool<DataStructures::Page<unsigned short,InternalPacket *,32> >::~MemoryPool<DataStructures::Page<unsigned short,InternalPacket *,32> >
PUBLIC	?Preallocate@?$MemoryPool@U?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEXI@Z ; DataStructures::MemoryPool<DataStructures::Page<unsigned short,InternalPacket *,32> >::Preallocate
PUBLIC	?Allocate@?$MemoryPool@U?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEPAU?$Page@GPAUInternalPacket@@$0CA@@2@XZ ; DataStructures::MemoryPool<DataStructures::Page<unsigned short,InternalPacket *,32> >::Allocate
PUBLIC	?Release@?$MemoryPool@U?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEXPAU?$Page@GPAUInternalPacket@@$0CA@@2@@Z ; DataStructures::MemoryPool<DataStructures::Page<unsigned short,InternalPacket *,32> >::Release
PUBLIC	??0?$List@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::List<DataStructures::Page<unsigned short,InternalPacket *,32> *>::List<DataStructures::Page<unsigned short,InternalPacket *,32> *>
PUBLIC	??1?$List@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::List<DataStructures::Page<unsigned short,InternalPacket *,32> *>::~List<DataStructures::Page<unsigned short,InternalPacket *,32> *>
PUBLIC	??A?$List@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QBEAAPAU?$Page@GPAUInternalPacket@@$0CA@@1@I@Z ; DataStructures::List<DataStructures::Page<unsigned short,InternalPacket *,32> *>::operator[]
PUBLIC	?Insert@?$List@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEXQAU?$Page@GPAUInternalPacket@@$0CA@@2@@Z ; DataStructures::List<DataStructures::Page<unsigned short,InternalPacket *,32> *>::Insert
PUBLIC	?Del@?$List@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEXI@Z ; DataStructures::List<DataStructures::Page<unsigned short,InternalPacket *,32> *>::Del
PUBLIC	?Size@?$List@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Page<unsigned short,InternalPacket *,32> *>::Size
PUBLIC	??0?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>
PUBLIC	??1?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::~OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>
PUBLIC	?GetIndexFromKey@?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEIABGPA_N@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::GetIndexFromKey
PUBLIC	?Insert@?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QAEIABGABQAUSplitPacketChannel@@@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::Insert
PUBLIC	??A?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::operator[]
PUBLIC	?RemoveAtIndex@?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QAEXI@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::RemoveAtIndex
PUBLIC	?Clear@?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QAEXXZ ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::Clear
PUBLIC	?Size@?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::Size
PUBLIC	??0?$List@PAUSplitPacketChannel@@@DataStructures@@QAE@XZ ; DataStructures::List<SplitPacketChannel *>::List<SplitPacketChannel *>
PUBLIC	??1?$List@PAUSplitPacketChannel@@@DataStructures@@QAE@XZ ; DataStructures::List<SplitPacketChannel *>::~List<SplitPacketChannel *>
PUBLIC	??A?$List@PAUSplitPacketChannel@@@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ; DataStructures::List<SplitPacketChannel *>::operator[]
PUBLIC	?Insert@?$List@PAUSplitPacketChannel@@@DataStructures@@QAEXQAUSplitPacketChannel@@I@Z ; DataStructures::List<SplitPacketChannel *>::Insert
PUBLIC	?Insert@?$List@PAUSplitPacketChannel@@@DataStructures@@QAEXQAUSplitPacketChannel@@@Z ; DataStructures::List<SplitPacketChannel *>::Insert
PUBLIC	?RemoveAtIndex@?$List@PAUSplitPacketChannel@@@DataStructures@@QAEXI@Z ; DataStructures::List<SplitPacketChannel *>::RemoveAtIndex
PUBLIC	?Del@?$List@PAUSplitPacketChannel@@@DataStructures@@QAEXI@Z ; DataStructures::List<SplitPacketChannel *>::Del
PUBLIC	?Size@?$List@PAUSplitPacketChannel@@@DataStructures@@QBEIXZ ; DataStructures::List<SplitPacketChannel *>::Size
PUBLIC	?Clear@?$List@PAUSplitPacketChannel@@@DataStructures@@QAEX_N@Z ; DataStructures::List<SplitPacketChannel *>::Clear
PUBLIC	??0?$Queue@_J@DataStructures@@QAE@XZ		; DataStructures::Queue<__int64>::Queue<__int64>
PUBLIC	??1?$Queue@_J@DataStructures@@QAE@XZ		; DataStructures::Queue<__int64>::~Queue<__int64>
PUBLIC	?Push@?$Queue@_J@DataStructures@@QAEXAB_J@Z	; DataStructures::Queue<__int64>::Push
PUBLIC	??A?$Queue@_J@DataStructures@@QBEAA_JI@Z	; DataStructures::Queue<__int64>::operator[]
PUBLIC	?Peek@?$Queue@_J@DataStructures@@QBE_JXZ	; DataStructures::Queue<__int64>::Peek
PUBLIC	?Pop@?$Queue@_J@DataStructures@@QAE_JXZ		; DataStructures::Queue<__int64>::Pop
PUBLIC	?Size@?$Queue@_J@DataStructures@@QBEIXZ		; DataStructures::Queue<__int64>::Size
PUBLIC	?AllocationSize@?$Queue@_J@DataStructures@@QBEIXZ ; DataStructures::Queue<__int64>::AllocationSize
PUBLIC	?Compress@?$Queue@_J@DataStructures@@QAEXXZ	; DataStructures::Queue<__int64>::Compress
PUBLIC	?ClearAndForceAllocation@?$Queue@_J@DataStructures@@QAEXH@Z ; DataStructures::Queue<__int64>::ClearAndForceAllocation
PUBLIC	??0?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QAE@XZ ; DataStructures::List<ReliabilityLayer::DataAndTime *>::List<ReliabilityLayer::DataAndTime *>
PUBLIC	??1?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QAE@XZ ; DataStructures::List<ReliabilityLayer::DataAndTime *>::~List<ReliabilityLayer::DataAndTime *>
PUBLIC	??A?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QBEAAPAUDataAndTime@ReliabilityLayer@@I@Z ; DataStructures::List<ReliabilityLayer::DataAndTime *>::operator[]
PUBLIC	?Insert@?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QAEXQAUDataAndTime@ReliabilityLayer@@@Z ; DataStructures::List<ReliabilityLayer::DataAndTime *>::Insert
PUBLIC	?Del@?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QAEXI@Z ; DataStructures::List<ReliabilityLayer::DataAndTime *>::Del
PUBLIC	?Size@?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QBEIXZ ; DataStructures::List<ReliabilityLayer::DataAndTime *>::Size
PUBLIC	?Clear@?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QAEX_N@Z ; DataStructures::List<ReliabilityLayer::DataAndTime *>::Clear
PUBLIC	??0?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAE@XZ ; DataStructures::CircularLinkedList<InternalPacket *>::CircularLinkedList<InternalPacket *>
PUBLIC	??1?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAE@XZ ; DataStructures::CircularLinkedList<InternalPacket *>::~CircularLinkedList<InternalPacket *>
PUBLIC	?Add@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEAAPAUInternalPacket@@ABQAU3@@Z ; DataStructures::CircularLinkedList<InternalPacket *>::Add
PUBLIC	?Del@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEXXZ ; DataStructures::CircularLinkedList<InternalPacket *>::Del
PUBLIC	?Size@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEIXZ ; DataStructures::CircularLinkedList<InternalPacket *>::Size
PUBLIC	?Peek@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEAAPAUInternalPacket@@XZ ; DataStructures::CircularLinkedList<InternalPacket *>::Peek
PUBLIC	?Pop@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEPAUInternalPacket@@XZ ; DataStructures::CircularLinkedList<InternalPacket *>::Pop
PUBLIC	?Clear@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEXXZ ; DataStructures::CircularLinkedList<InternalPacket *>::Clear
PUBLIC	?Beginning@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEXXZ ; DataStructures::CircularLinkedList<InternalPacket *>::Beginning
PUBLIC	?End@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEXXZ ; DataStructures::CircularLinkedList<InternalPacket *>::End
PUBLIC	??0?$LinkedList@PAUInternalPacket@@@DataStructures@@QAE@XZ ; DataStructures::LinkedList<InternalPacket *>::LinkedList<InternalPacket *>
PUBLIC	??1?$LinkedList@PAUInternalPacket@@@DataStructures@@QAE@XZ ; DataStructures::LinkedList<InternalPacket *>::~LinkedList<InternalPacket *>
PUBLIC	??E?$LinkedList@PAUInternalPacket@@@DataStructures@@QAEAAV01@XZ ; DataStructures::LinkedList<InternalPacket *>::operator++
PUBLIC	??E?$LinkedList@PAUInternalPacket@@@DataStructures@@QAEAAV01@H@Z ; DataStructures::LinkedList<InternalPacket *>::operator++
PUBLIC	??_G?$LinkedList@PAUInternalPacket@@@DataStructures@@QAEPAXI@Z ; DataStructures::LinkedList<InternalPacket *>::`scalar deleting destructor'
PUBLIC	??0?$RangeNode@G@DataStructures@@QAE@XZ		; DataStructures::RangeNode<unsigned short>::RangeNode<unsigned short>
PUBLIC	??1?$RangeNode@G@DataStructures@@QAE@XZ		; DataStructures::RangeNode<unsigned short>::~RangeNode<unsigned short>
PUBLIC	??0?$RangeNode@G@DataStructures@@QAE@GG@Z	; DataStructures::RangeNode<unsigned short>::RangeNode<unsigned short>
PUBLIC	??_E?$RangeNode@G@DataStructures@@QAEPAXI@Z	; DataStructures::RangeNode<unsigned short>::`vector deleting destructor'
PUBLIC	??A?$List@PAVPluginInterface@@@DataStructures@@QBEAAPAVPluginInterface@@I@Z ; DataStructures::List<PluginInterface *>::operator[]
PUBLIC	?Size@?$List@PAVPluginInterface@@@DataStructures@@QBEIXZ ; DataStructures::List<PluginInterface *>::Size
PUBLIC	??$WriteCompressed@I@BitStream@RakNet@@QAEXI@Z	; RakNet::BitStream::WriteCompressed<unsigned int>
PUBLIC	??$WriteCompressed@G@BitStream@RakNet@@QAEXG@Z	; RakNet::BitStream::WriteCompressed<unsigned short>
PUBLIC	??$ReadCompressed@I@BitStream@RakNet@@QAE_NAAI@Z ; RakNet::BitStream::ReadCompressed<unsigned int>
PUBLIC	??$ReadCompressed@G@BitStream@RakNet@@QAE_NAAG@Z ; RakNet::BitStream::ReadCompressed<unsigned short>
PUBLIC	??0?$Queue@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::Queue<DataStructures::Page<unsigned short,InternalPacket *,32> *>::Queue<DataStructures::Page<unsigned short,InternalPacket *,32> *>
PUBLIC	??1?$Queue@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::Queue<DataStructures::Page<unsigned short,InternalPacket *,32> *>::~Queue<DataStructures::Page<unsigned short,InternalPacket *,32> *>
PUBLIC	?Push@?$Queue@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEXABQAU?$Page@GPAUInternalPacket@@$0CA@@2@@Z ; DataStructures::Queue<DataStructures::Page<unsigned short,InternalPacket *,32> *>::Push
PUBLIC	?Pop@?$Queue@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEPAU?$Page@GPAUInternalPacket@@$0CA@@2@XZ ; DataStructures::Queue<DataStructures::Page<unsigned short,InternalPacket *,32> *>::Pop
PUBLIC	?Size@?$Queue@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::Queue<DataStructures::Page<unsigned short,InternalPacket *,32> *>::Size
PUBLIC	?__LINE__Var@?1??HandleSocketReceiveFromConnectedPlayer@ReliabilityLayer@@QAE_NPBDHUPlayerID@@AAV?$List@PAVPluginInterface@@@DataStructures@@H@Z@4JA ; `ReliabilityLayer::HandleSocketReceiveFromConnectedPlayer'::`2'::__LINE__Var
PUBLIC	??_C@_1FK@FKLHGKMO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAe?$AAl?$AAi?$AAa?$AAb?$AAi?$AAl@ ; `string'
PUBLIC	??_C@_1EA@BNPCOFAI@?$AA?$CB?$AA?$CI?$AA?5?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1IC@KPHIMKPK@?$AAi?$AAn?$AAc?$AAo?$AAm?$AAi?$AAn?$AAg?$AAA?$AAc?$AAk?$AAs?$AA?4?$AAr?$AAa?$AAn?$AAg?$AAe?$AAs?$AA?$FL?$AAi?$AA?$FN?$AA?4?$AAm?$AAi?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?$DM@ ; `string'
PUBLIC	??_C@_1JA@FAAHMOBE@?$AAh?$AAa?$AAs?$AAR?$AAe?$AAc?$AAe?$AAi?$AAv?$AAe?$AAd?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AAQ?$AAu?$AAe?$AAu?$AAe?$AA?4?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?5@ ; `string'
PUBLIC	??_C@_1HI@MKMNOBIC@?$AAi?$AAn?$AAt?$AAe?$AAr?$AAn?$AAa?$AAl?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?9?$AA?$DO?$AAo?$AAr?$AAd?$AAe?$AAr?$AAi?$AAn?$AAg?$AAC?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AA?5@ ; `string'
PUBLIC	??_C@_0BE@HCJJFHJF@Got?5invalid?5packet?6?$AA@	; `string'
PUBLIC	??_C@_0DA@MOADJCKG@Got?5invalid?5ordering?5channel?5?$CFi?5@ ; `string'
PUBLIC	?__LINE__Var@?1??Send@ReliabilityLayer@@QAE_NPADHW4PacketPriority@@W4PacketReliability@@E_NH_J@Z@4JA ; `ReliabilityLayer::Send'::`2'::__LINE__Var
PUBLIC	??_C@_1HC@GDCNHECB@?$AA?$CB?$AA?$CI?$AA?5?$AAr?$AAe?$AAl?$AAi?$AAa?$AAb?$AAi?$AAl?$AAi?$AAt?$AAy?$AA?5?$AA?$DO?$AA?5?$AAR?$AAE?$AAL?$AAI?$AAA?$AAB?$AAL?$AAE?$AA_?$AAS?$AAE?$AAQ?$AAU?$AAE?$AAN@ ; `string'
PUBLIC	??_C@_1GK@MADIINNK@?$AA?$CB?$AA?$CI?$AA?5?$AAp?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA?5?$AA?$DO?$AA?5?$AAN?$AAU?$AAM?$AAB?$AAE?$AAR?$AA_?$AAO?$AAF?$AA_?$AAP?$AAR?$AAI?$AAO?$AAR?$AAI?$AAT?$AAI@ ; `string'
PUBLIC	??_C@_1JC@KFGENCHD@?$AA?$CB?$AA?$CI?$AA?5?$AAo?$AAr?$AAd?$AAe?$AAr?$AAi?$AAn?$AAg?$AAC?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AA?5?$AA?$DM?$AA?5?$AA0?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAo?$AAr?$AAd?$AAe?$AAr?$AAi@ ; `string'
PUBLIC	??_C@_1CO@KEDLFNFL@?$AAn?$AAu?$AAm?$AAb?$AAe?$AAr?$AAO?$AAf?$AAB?$AAi?$AAt?$AAs?$AAT?$AAo?$AAS?$AAe?$AAn?$AAd?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_0EF@BEKPCEMB@Error?$CB?$CB?5ReliabilityLayer?3?3Send?5b@ ; `string'
PUBLIC	?__LINE__Var@?1??SendBitStream@ReliabilityLayer@@AAEXIUPlayerID@@PAVBitStream@RakNet@@@Z@4JA ; `ReliabilityLayer::SendBitStream'::`2'::__LINE__Var
PUBLIC	??_C@_1CI@ENDPABPL@?$AA?$CI?$AA?5?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$CF?$AA?5?$AA8?$AA?5?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??GenerateDatagram@ReliabilityLayer@@AAEIPAVBitStream@RakNet@@HPA_N_JUPlayerID@@AAV?$List@PAVPluginInterface@@@DataStructures@@@Z@4JA ; `ReliabilityLayer::GenerateDatagram'::`2'::__LINE__Var
PUBLIC	??_C@_1DM@HJOKLFNH@?$AAi?$AAn?$AAt?$AAe?$AAr?$AAn?$AAa?$AAl?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?9?$AA?$DO?$AAp?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??GetBitStreamHeaderLength@ReliabilityLayer@@AAEHQBUInternalPacket@@@Z@4JA ; `ReliabilityLayer::GetBitStreamHeaderLength'::`2'::__LINE__Var
PUBLIC	??_C@_1BO@FAHOLNMM@?$AAi?$AAn?$AAt?$AAe?$AAr?$AAn?$AAa?$AAl?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??WriteToBitStreamFromInternalPacket@ReliabilityLayer@@AAEHPAVBitStream@RakNet@@QBUInternalPacket@@@Z@4JA ; `ReliabilityLayer::WriteToBitStreamFromInternalPacket'::`2'::__LINE__Var
PUBLIC	??_C@_1DI@CEDLGLL@?$AAb?$AAi?$AAt?$AAS?$AAt?$AAr?$AAe?$AAa?$AAm?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAt?$AAe?$AAr?$AAn?$AAa?$AAl?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EE@LOHKMABB@?$AAi?$AAn?$AAt?$AAe?$AAr?$AAn?$AAa?$AAl?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AAB?$AAi?$AAt?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5@ ; `string'
PUBLIC	??_C@_1IE@GICOMIGA@?$AAB?$AAI?$AAT?$AAS?$AA_?$AAT?$AAO?$AA_?$AAB?$AAY?$AAT?$AAE?$AAS?$AA?$CI?$AA?5?$AAi?$AAn?$AAt?$AAe?$AAr?$AAn?$AAa?$AAl?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?9?$AA?$DO?$AAd@ ; `string'
PUBLIC	?__LINE__Var@?1??SplitPacket@ReliabilityLayer@@AAEXPAUInternalPacket@@H@Z@4JA ; `ReliabilityLayer::SplitPacket'::`2'::__LINE__Var
PUBLIC	??_C@_1FI@DMENGPEG@?$AAd?$AAa?$AAt?$AAa?$AAB?$AAy?$AAt?$AAe?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AAm?$AAa?$AAx?$AAD?$AAa?$AAt?$AAa?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?9?$AA?5?$AAh@ ; `string'
PUBLIC	?__LINE__Var@?1??BuildPacketFromSplitPacketList@ReliabilityLayer@@AAEPAUInternalPacket@@G_J@Z@4JA ; `ReliabilityLayer::BuildPacketFromSplitPacketList'::`2'::__LINE__Var
PUBLIC	??_C@_1BK@EBNJALNF@?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAE?$AAx?$AAi?$AAs?$AAt?$AAs?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??AddToOrderingList@ReliabilityLayer@@AAEXPAUInternalPacket@@@Z@4JA ; `ReliabilityLayer::AddToOrderingList'::`2'::__LINE__Var
PUBLIC	?__LINE__Var@?1??InsertPacketIntoResendList@ReliabilityLayer@@AAEXPAUInternalPacket@@_J_N2@Z@4JA ; `ReliabilityLayer::InsertPacketIntoResendList'::`2'::__LINE__Var
PUBLIC	??_C@_1EE@KHBHHHAB@?$AAi?$AAn?$AAt?$AAe?$AAr?$AAn?$AAa?$AAl?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAA?$AAc?$AAt?$AAi?$AAo?$AAn?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN@ ; `string'
PUBLIC	??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@ ; `string'
PUBLIC	??_C@_1BE@OMEGJCHO@?$AAn?$AAe?$AAw?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CE@CLDOPLDF@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BK@BHOIKEPB@?$AAh?$AAe?$AAa?$AAd?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAt?$AAa?$AAi?$AAl?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EG@MGMFGCAG@?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN@ ; `string'
PUBLIC	??_C@_1GG@JDEIIJCO@?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN@ ; `string'
PUBLIC	??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@ ; `string'
PUBLIC	??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DE@KHAHCBKC@?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$CL?$AA?5?$AA1?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EO@BAKEJDDB@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAr?$AAa?$AAn?$AAg?$AAe@ ; `string'
PUBLIC	??_C@_1EG@DIEFEKLO@?$AAr?$AAa?$AAn?$AAg?$AAe?$AAs?$AA?4?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAu?$AAn?$AAs?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AAs?$AAh?$AAo?$AAr?$AAt?$AA?$CJ@ ; `string'
PUBLIC	??_C@_1EO@DHNPHPFC@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAb?$AAp?$AAl?$AAu?$AAs@ ; `string'
PUBLIC	??_C@_1GM@PECFPFGO@?$AAr?$AAe?$AAt?$AAu?$AAr?$AAn?$AAA?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?4?$AAa?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$DN?$AA?$DN?$AAR?$AAe?$AAt?$AAu?$AAr?$AAn?$AAA?$AAc?$AAt?$AAi?$AAo@ ; `string'
PUBLIC	??_C@_1BO@JBFMBKMD@?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$DO?$AA?$DN?$AAn?$AAu?$AAm?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CM@FMCFHBCK@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BK@CAFOCCOP@?$AAp?$AAa?$AAg?$AAe?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$DO?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1GO@DFNPOHCN@?$AAr?$AAe?$AAt?$AAu?$AAr?$AAn?$AAA?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?9?$AA?$DO?$AAa?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$DN?$AA?$DN?$AAR?$AAe?$AAt?$AAu?$AAr?$AAn?$AAA?$AAc?$AAt?$AAi@ ; `string'
PUBLIC	??_C@_1FA@EECGGCBA@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAm?$AAe?$AAm?$AAo?$AAr@ ; `string'
PUBLIC	??_C@_1BK@JNGCOJCH@?$AAb?$AAl?$AAo?$AAc?$AAk?$AAs?$AAO?$AAu?$AAt?$AA?$DN?$AA?$DN?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BI@OFKIDLPK@?$AAb?$AAl?$AAo?$AAc?$AAk?$AAs?$AAO?$AAu?$AAt?$AA?$DO?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@GBMFMLDI@?$AAb?$AA?$DN?$AA?$DN?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3fc999999999999a
PUBLIC	__real@3feccccccccccccd
PUBLIC	__real@3ff0cccccccccccd
PUBLIC	__real@3ff8000000000000
PUBLIC	__real@40000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@4010000000000000
PUBLIC	__real@40800000
PUBLIC	__real@412e848000000000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_memmove:PROC
EXTRN	?SendTo@SocketLayer@@QAEHIPBDHIG@Z:PROC		; SocketLayer::SendTo
EXTRN	__wassert:PROC
EXTRN	??0BitStream@RakNet@@QAE@XZ:PROC		; RakNet::BitStream::BitStream
EXTRN	??0BitStream@RakNet@@QAE@H@Z:PROC		; RakNet::BitStream::BitStream
EXTRN	??0BitStream@RakNet@@QAE@PAEI_N@Z:PROC		; RakNet::BitStream::BitStream
EXTRN	??1BitStream@RakNet@@QAE@XZ:PROC		; RakNet::BitStream::~BitStream
EXTRN	?Reset@BitStream@RakNet@@QAEXXZ:PROC		; RakNet::BitStream::Reset
EXTRN	?Write@BitStream@RakNet@@QAEXPBDH@Z:PROC	; RakNet::BitStream::Write
EXTRN	?Write@BitStream@RakNet@@QAEXPAV12@H@Z:PROC	; RakNet::BitStream::Write
EXTRN	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z:PROC	; RakNet::BitStream::WriteBits
EXTRN	?WriteAlignedBytes@BitStream@RakNet@@QAEXPBEH@Z:PROC ; RakNet::BitStream::WriteAlignedBytes
EXTRN	?ReadAlignedBytes@BitStream@RakNet@@QAE_NPAEH@Z:PROC ; RakNet::BitStream::ReadAlignedBytes
EXTRN	?ReadBits@BitStream@RakNet@@QAE_NPAEH_N@Z:PROC	; RakNet::BitStream::ReadBits
EXTRN	?Write0@BitStream@RakNet@@QAEXXZ:PROC		; RakNet::BitStream::Write0
EXTRN	?Write1@BitStream@RakNet@@QAEXXZ:PROC		; RakNet::BitStream::Write1
EXTRN	?WriteCompressed@BitStream@RakNet@@AAEXPBEH_N@Z:PROC ; RakNet::BitStream::WriteCompressed
EXTRN	?ReadCompressed@BitStream@RakNet@@AAE_NPAEH_N@Z:PROC ; RakNet::BitStream::ReadCompressed
EXTRN	??0InternalPacketPool@@QAE@XZ:PROC		; InternalPacketPool::InternalPacketPool
EXTRN	??1InternalPacketPool@@QAE@XZ:PROC		; InternalPacketPool::~InternalPacketPool
EXTRN	?ReleasePointer@InternalPacketPool@@QAEXPAUInternalPacket@@@Z:PROC ; InternalPacketPool::ReleasePointer
EXTRN	?ClearPool@InternalPacketPool@@QAEXXZ:PROC	; InternalPacketPool::ClearPool
EXTRN	_printf:PROC
EXTRN	??0TEABlockEncryptor@@QAE@XZ:PROC		; TEABlockEncryptor::TEABlockEncryptor
EXTRN	??1TEABlockEncryptor@@QAE@XZ:PROC		; TEABlockEncryptor::~TEABlockEncryptor
EXTRN	?IsKeySet@TEABlockEncryptor@@QBE_NXZ:PROC	; TEABlockEncryptor::IsKeySet
EXTRN	?SetKey@TEABlockEncryptor@@QAEXQBE@Z:PROC	; TEABlockEncryptor::SetKey
EXTRN	?UnsetKey@TEABlockEncryptor@@QAEXXZ:PROC	; TEABlockEncryptor::UnsetKey
EXTRN	?Encrypt@TEABlockEncryptor@@QAEXPAEH0PAH@Z:PROC	; TEABlockEncryptor::Encrypt
EXTRN	?Decrypt@TEABlockEncryptor@@QAE_NPAEH0PAH@Z:PROC ; TEABlockEncryptor::Decrypt
EXTRN	??0CSHA1@@QAE@XZ:PROC				; CSHA1::CSHA1
EXTRN	??1CSHA1@@UAE@XZ:PROC				; CSHA1::~CSHA1
EXTRN	?Reset@CSHA1@@QAEXXZ:PROC			; CSHA1::Reset
EXTRN	?Update@CSHA1@@QAEXPAEI@Z:PROC			; CSHA1::Update
EXTRN	?Final@CSHA1@@QAEXXZ:PROC			; CSHA1::Final
EXTRN	?GetHash@CSHA1@@QBEPAEXZ:PROC			; CSHA1::GetHash
EXTRN	?GetTime@RakNet@@YAIXZ:PROC			; RakNet::GetTime
EXTRN	?GetTimeNS@RakNet@@YA_JXZ:PROC			; RakNet::GetTimeNS
EXTRN	?randomMT@@YAIXZ:PROC				; randomMT
EXTRN	?frandomMT@@YAMXZ:PROC				; frandomMT
EXTRN	@_RTC_AllocaHelper@12:PROC
EXTRN	@_RTC_CheckStackVars2@12:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__alldiv:PROC
EXTRN	__alloca_probe_16:PROC
EXTRN	__ftoui3:PROC
EXTRN	__ltod3:PROC
EXTRN	?I@SocketLayer@@0V1@A:BYTE			; SocketLayer::I
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@412e848000000000
CONST	SEGMENT
__real@412e848000000000 DQ 0412e848000000000r	; 1e+006
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@4010000000000000
CONST	SEGMENT
__real@4010000000000000 DQ 04010000000000000r	; 4
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff8000000000000
CONST	SEGMENT
__real@3ff8000000000000 DQ 03ff8000000000000r	; 1.5
CONST	ENDS
;	COMDAT __real@3ff0cccccccccccd
CONST	SEGMENT
__real@3ff0cccccccccccd DQ 03ff0cccccccccccdr	; 1.05
CONST	ENDS
;	COMDAT __real@3feccccccccccccd
CONST	SEGMENT
__real@3feccccccccccccd DQ 03feccccccccccccdr	; 0.9
CONST	ENDS
;	COMDAT __real@3fc999999999999a
CONST	SEGMENT
__real@3fc999999999999a DQ 03fc999999999999ar	; 0.2
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_1BC@GBMFMLDI@?$AAb?$AA?$DN?$AA?$DN?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@GBMFMLDI@?$AAb?$AA?$DN?$AA?$DN?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@ DB 'b'
	DB	00H, '=', 00H, '=', 00H, 'f', 00H, 'a', 00H, 'l', 00H, 's', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@OFKIDLPK@?$AAb?$AAl?$AAo?$AAc?$AAk?$AAs?$AAO?$AAu?$AAt?$AA?$DO?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@OFKIDLPK@?$AAb?$AAl?$AAo?$AAc?$AAk?$AAs?$AAO?$AAu?$AAt?$AA?$DO?$AA0?$AA?$AA@ DB 'b'
	DB	00H, 'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, 's', 00H, 'O', 00H
	DB	'u', 00H, 't', 00H, '>', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@JNGCOJCH@?$AAb?$AAl?$AAo?$AAc?$AAk?$AAs?$AAO?$AAu?$AAt?$AA?$DN?$AA?$DN?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@JNGCOJCH@?$AAb?$AAl?$AAo?$AAc?$AAk?$AAs?$AAO?$AAu?$AAt?$AA?$DN?$AA?$DN?$AA0?$AA?$AA@ DB 'b'
	DB	00H, 'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, 's', 00H, 'O', 00H
	DB	'u', 00H, 't', 00H, '=', 00H, '=', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FA@EECGGCBA@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAm?$AAe?$AAm?$AAo?$AAr@
CONST	SEGMENT
??_C@_1FA@EECGGCBA@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAm?$AAe?$AAm?$AAo?$AAr@ DB 'z'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H
	DB	's', 00H, 'r', 00H, 'c', 00H, '\', 00H, '0', 00H, '2', 00H, 'x'
	DB	00H, 'u', 00H, '1', 00H, '\', 00H, 'r', 00H, 'a', 00H, 'k', 00H
	DB	'n', 00H, 'e', 00H, 't', 00H, '\', 00H, 'd', 00H, 's', 00H, '_'
	DB	00H, 'm', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H
	DB	'p', 00H, 'o', 00H, 'o', 00H, 'l', 00H, '.', 00H, 'h', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1GO@DFNPOHCN@?$AAr?$AAe?$AAt?$AAu?$AAr?$AAn?$AAA?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?9?$AA?$DO?$AAa?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$DN?$AA?$DN?$AAR?$AAe?$AAt?$AAu?$AAr?$AAn?$AAA?$AAc?$AAt?$AAi@
CONST	SEGMENT
??_C@_1GO@DFNPOHCN@?$AAr?$AAe?$AAt?$AAu?$AAr?$AAn?$AAA?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?9?$AA?$DO?$AAa?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$DN?$AA?$DN?$AAR?$AAe?$AAt?$AAu?$AAr?$AAn?$AAA?$AAc?$AAt?$AAi@ DB 'r'
	DB	00H, 'e', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'n', 00H, 'A', 00H
	DB	'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, '-', 00H, '>'
	DB	00H, 'a', 00H, 'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H
	DB	'=', 00H, '=', 00H, 'R', 00H, 'e', 00H, 't', 00H, 'u', 00H, 'r'
	DB	00H, 'n', 00H, 'A', 00H, 'c', 00H, 't', 00H, 'i', 00H, 'o', 00H
	DB	'n', 00H, ':', 00H, ':', 00H, 'P', 00H, 'U', 00H, 'S', 00H, 'H'
	DB	00H, '_', 00H, 'K', 00H, 'E', 00H, 'Y', 00H, '_', 00H, 'T', 00H
	DB	'O', 00H, '_', 00H, 'P', 00H, 'A', 00H, 'R', 00H, 'E', 00H, 'N'
	DB	00H, 'T', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@CAFOCCOP@?$AAp?$AAa?$AAg?$AAe?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$DO?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@CAFOCCOP@?$AAp?$AAa?$AAg?$AAe?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$DO?$AA0?$AA?$AA@ DB 'p'
	DB	00H, 'a', 00H, 'g', 00H, 'e', 00H, '-', 00H, '>', 00H, 's', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, '>', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CM@FMCFHBCK@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@FMCFHBCK@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ DB 'p'
	DB	00H, 'o', 00H, 's', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'o', 00H
	DB	'n', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'l', 00H, 'i'
	DB	00H, 's', 00H, 't', 00H, '_', 00H, 's', 00H, 'i', 00H, 'z', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@JBFMBKMD@?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$DO?$AA?$DN?$AAn?$AAu?$AAm?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@JBFMBKMD@?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$DO?$AA?$DN?$AAn?$AAu?$AAm?$AA?$AA@ DB 'l'
	DB	00H, 'i', 00H, 's', 00H, 't', 00H, '_', 00H, 's', 00H, 'i', 00H
	DB	'z', 00H, 'e', 00H, '>', 00H, '=', 00H, 'n', 00H, 'u', 00H, 'm'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1GM@PECFPFGO@?$AAr?$AAe?$AAt?$AAu?$AAr?$AAn?$AAA?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?4?$AAa?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$DN?$AA?$DN?$AAR?$AAe?$AAt?$AAu?$AAr?$AAn?$AAA?$AAc?$AAt?$AAi?$AAo@
CONST	SEGMENT
??_C@_1GM@PECFPFGO@?$AAr?$AAe?$AAt?$AAu?$AAr?$AAn?$AAA?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?4?$AAa?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$DN?$AA?$DN?$AAR?$AAe?$AAt?$AAu?$AAr?$AAn?$AAA?$AAc?$AAt?$AAi?$AAo@ DB 'r'
	DB	00H, 'e', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'n', 00H, 'A', 00H
	DB	'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, '.', 00H, 'a'
	DB	00H, 'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, '=', 00H
	DB	'=', 00H, 'R', 00H, 'e', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'n'
	DB	00H, 'A', 00H, 'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H
	DB	':', 00H, ':', 00H, 'P', 00H, 'U', 00H, 'S', 00H, 'H', 00H, '_'
	DB	00H, 'K', 00H, 'E', 00H, 'Y', 00H, '_', 00H, 'T', 00H, 'O', 00H
	DB	'_', 00H, 'P', 00H, 'A', 00H, 'R', 00H, 'E', 00H, 'N', 00H, 'T'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1EO@DHNPHPFC@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAb?$AAp?$AAl?$AAu?$AAs@
CONST	SEGMENT
??_C@_1EO@DHNPHPFC@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAb?$AAp?$AAl?$AAu?$AAs@ DB 'z'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H
	DB	's', 00H, 'r', 00H, 'c', 00H, '\', 00H, '0', 00H, '2', 00H, 'x'
	DB	00H, 'u', 00H, '1', 00H, '\', 00H, 'r', 00H, 'a', 00H, 'k', 00H
	DB	'n', 00H, 'e', 00H, 't', 00H, '\', 00H, 'd', 00H, 's', 00H, '_'
	DB	00H, 'b', 00H, 'p', 00H, 'l', 00H, 'u', 00H, 's', 00H, 't', 00H
	DB	'r', 00H, 'e', 00H, 'e', 00H, '.', 00H, 'h', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EG@DIEFEKLO@?$AAr?$AAa?$AAn?$AAg?$AAe?$AAs?$AA?4?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAu?$AAn?$AAs?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AAs?$AAh?$AAo?$AAr?$AAt?$AA?$CJ@
CONST	SEGMENT
??_C@_1EG@DIEFEKLO@?$AAr?$AAa?$AAn?$AAg?$AAe?$AAs?$AA?4?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAu?$AAn?$AAs?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AAs?$AAh?$AAo?$AAr?$AAt?$AA?$CJ@ DB 'r'
	DB	00H, 'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H, 's', 00H, '.', 00H
	DB	'S', 00H, 'i', 00H, 'z', 00H, 'e', 00H, '(', 00H, ')', 00H, ' '
	DB	00H, '<', 00H, ' ', 00H, '(', 00H, 'u', 00H, 'n', 00H, 's', 00H
	DB	'i', 00H, 'g', 00H, 'n', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 's'
	DB	00H, 'h', 00H, 'o', 00H, 'r', 00H, 't', 00H, ')', 00H, '-', 00H
	DB	'1', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1EO@BAKEJDDB@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAr?$AAa?$AAn?$AAg?$AAe@
CONST	SEGMENT
??_C@_1EO@BAKEJDDB@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAr?$AAa?$AAn?$AAg?$AAe@ DB 'z'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H
	DB	's', 00H, 'r', 00H, 'c', 00H, '\', 00H, '0', 00H, '2', 00H, 'x'
	DB	00H, 'u', 00H, '1', 00H, '\', 00H, 'r', 00H, 'a', 00H, 'k', 00H
	DB	'n', 00H, 'e', 00H, 't', 00H, '\', 00H, 'd', 00H, 's', 00H, '_'
	DB	00H, 'r', 00H, 'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H, 'l', 00H
	DB	'i', 00H, 's', 00H, 't', 00H, '.', 00H, 'h', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DE@KHAHCBKC@?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$CL?$AA?5?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@KHAHCBKC@?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$CL?$AA?5?$AA1?$AA?$AA@ DB 'l'
	DB	00H, 'i', 00H, 's', 00H, 't', 00H, '_', 00H, 's', 00H, 'i', 00H
	DB	'z', 00H, 'e', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'p'
	DB	00H, 'o', 00H, 's', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'o', 00H
	DB	'n', 00H, ' ', 00H, '+', 00H, ' ', 00H, '1', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ DB 'p'
	DB	00H, 'o', 00H, 's', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'o', 00H
	DB	'n', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'l', 00H, 'i', 00H, 's'
	DB	00H, 't', 00H, '_', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
CONST	SEGMENT
??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@ DB 'z'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H
	DB	's', 00H, 'r', 00H, 'c', 00H, '\', 00H, '0', 00H, '2', 00H, 'x'
	DB	00H, 'u', 00H, '1', 00H, '\', 00H, 'r', 00H, 'a', 00H, 'k', 00H
	DB	'n', 00H, 'e', 00H, 't', 00H, '\', 00H, 'd', 00H, 's', 00H, '_'
	DB	00H, 'l', 00H, 'i', 00H, 's', 00H, 't', 00H, '.', 00H, 'h', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1GG@JDEIIJCO@?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN@
CONST	SEGMENT
??_C@_1GG@JDEIIJCO@?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN@ DB 'a'
	DB	00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H
	DB	'i', 00H, 'o', 00H, 'n', 00H, '_', 00H, 's', 00H, 'i', 00H, 'z'
	DB	00H, 'e', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e'
	DB	00H, '(', 00H, ')', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H
	DB	'0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'h', 00H, 'e'
	DB	00H, 'a', 00H, 'd', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H
	DB	't', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EG@MGMFGCAG@?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN@
CONST	SEGMENT
??_C@_1EG@MGMFGCAG@?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN@ DB 'a'
	DB	00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H
	DB	'i', 00H, 'o', 00H, 'n', 00H, '_', 00H, 's', 00H, 'i', 00H, 'z'
	DB	00H, 'e', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e'
	DB	00H, '(', 00H, ')', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H
	DB	'0', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@BHOIKEPB@?$AAh?$AAe?$AAa?$AAd?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAt?$AAa?$AAi?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@BHOIKEPB@?$AAh?$AAe?$AAa?$AAd?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAt?$AAa?$AAi?$AAl?$AA?$AA@ DB 'h'
	DB	00H, 'e', 00H, 'a', 00H, 'd', 00H, ' ', 00H, '!', 00H, '=', 00H
	DB	' ', 00H, 't', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@CLDOPLDF@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@CLDOPLDF@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@ DB 'p'
	DB	00H, 'o', 00H, 's', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'o', 00H
	DB	'n', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'S', 00H, 'i', 00H, 'z'
	DB	00H, 'e', 00H, '(', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@OMEGJCHO@?$AAn?$AAe?$AAw?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@OMEGJCHO@?$AAn?$AAe?$AAw?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?$AA@ DB 'n'
	DB	00H, 'e', 00H, 'w', 00H, '_', 00H, 'a', 00H, 'r', 00H, 'r', 00H
	DB	'a', 00H, 'y', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@
CONST	SEGMENT
??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@ DB 'z'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H
	DB	's', 00H, 'r', 00H, 'c', 00H, '\', 00H, '0', 00H, '2', 00H, 'x'
	DB	00H, 'u', 00H, '1', 00H, '\', 00H, 'r', 00H, 'a', 00H, 'k', 00H
	DB	'n', 00H, 'e', 00H, 't', 00H, '\', 00H, 'd', 00H, 's', 00H, '_'
	DB	00H, 'q', 00H, 'u', 00H, 'e', 00H, 'u', 00H, 'e', 00H, '.', 00H
	DB	'h', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@KHBHHHAB@?$AAi?$AAn?$AAt?$AAe?$AAr?$AAn?$AAa?$AAl?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAA?$AAc?$AAt?$AAi?$AAo?$AAn?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN@
CONST	SEGMENT
??_C@_1EE@KHBHHHAB@?$AAi?$AAn?$AAt?$AAe?$AAr?$AAn?$AAa?$AAl?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAA?$AAc?$AAt?$AAi?$AAo?$AAn?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN@ DB 'i'
	DB	00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'n', 00H, 'a', 00H
	DB	'l', 00H, 'P', 00H, 'a', 00H, 'c', 00H, 'k', 00H, 'e', 00H, 't'
	DB	00H, '-', 00H, '>', 00H, 'n', 00H, 'e', 00H, 'x', 00H, 't', 00H
	DB	'A', 00H, 'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 'T'
	DB	00H, 'i', 00H, 'm', 00H, 'e', 00H, '!', 00H, '=', 00H, '0', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??InsertPacketIntoResendList@ReliabilityLayer@@AAEXPAUInternalPacket@@_J_N2@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??InsertPacketIntoResendList@ReliabilityLayer@@AAEXPAUInternalPacket@@_J_N2@Z@4JA DD 0962H ; `ReliabilityLayer::InsertPacketIntoResendList'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??AddToOrderingList@ReliabilityLayer@@AAEXPAUInternalPacket@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??AddToOrderingList@ReliabilityLayer@@AAEXPAUInternalPacket@@@Z@4JA DD 093bH ; `ReliabilityLayer::AddToOrderingList'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1BK@EBNJALNF@?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAE?$AAx?$AAi?$AAs?$AAt?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@EBNJALNF@?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAE?$AAx?$AAi?$AAs?$AAt?$AAs?$AA?$AA@ DB 'o'
	DB	00H, 'b', 00H, 'j', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'E', 00H
	DB	'x', 00H, 'i', 00H, 's', 00H, 't', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??BuildPacketFromSplitPacketList@ReliabilityLayer@@AAEPAUInternalPacket@@G_J@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??BuildPacketFromSplitPacketList@ReliabilityLayer@@AAEPAUInternalPacket@@G_J@Z@4JA DD 08caH ; `ReliabilityLayer::BuildPacketFromSplitPacketList'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1FI@DMENGPEG@?$AAd?$AAa?$AAt?$AAa?$AAB?$AAy?$AAt?$AAe?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AAm?$AAa?$AAx?$AAD?$AAa?$AAt?$AAa?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?9?$AA?5?$AAh@
CONST	SEGMENT
??_C@_1FI@DMENGPEG@?$AAd?$AAa?$AAt?$AAa?$AAB?$AAy?$AAt?$AAe?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AAm?$AAa?$AAx?$AAD?$AAa?$AAt?$AAa?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?9?$AA?5?$AAh@ DB 'd'
	DB	00H, 'a', 00H, 't', 00H, 'a', 00H, 'B', 00H, 'y', 00H, 't', 00H
	DB	'e', 00H, 'L', 00H, 'e', 00H, 'n', 00H, 'g', 00H, 't', 00H, 'h'
	DB	00H, ' ', 00H, '>', 00H, ' ', 00H, 'm', 00H, 'a', 00H, 'x', 00H
	DB	'D', 00H, 'a', 00H, 't', 00H, 'a', 00H, 'S', 00H, 'i', 00H, 'z'
	DB	00H, 'e', 00H, ' ', 00H, '-', 00H, ' ', 00H, 'h', 00H, 'e', 00H
	DB	'a', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 'L', 00H, 'e', 00H, 'n'
	DB	00H, 'g', 00H, 't', 00H, 'h', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??SplitPacket@ReliabilityLayer@@AAEXPAUInternalPacket@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??SplitPacket@ReliabilityLayer@@AAEXPAUInternalPacket@@H@Z@4JA DD 0818H ; `ReliabilityLayer::SplitPacket'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1IE@GICOMIGA@?$AAB?$AAI?$AAT?$AAS?$AA_?$AAT?$AAO?$AA_?$AAB?$AAY?$AAT?$AAE?$AAS?$AA?$CI?$AA?5?$AAi?$AAn?$AAt?$AAe?$AAr?$AAn?$AAa?$AAl?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?9?$AA?$DO?$AAd@
CONST	SEGMENT
??_C@_1IE@GICOMIGA@?$AAB?$AAI?$AAT?$AAS?$AA_?$AAT?$AAO?$AA_?$AAB?$AAY?$AAT?$AAE?$AAS?$AA?$CI?$AA?5?$AAi?$AAn?$AAt?$AAe?$AAr?$AAn?$AAa?$AAl?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?9?$AA?$DO?$AAd@ DB 'B'
	DB	00H, 'I', 00H, 'T', 00H, 'S', 00H, '_', 00H, 'T', 00H, 'O', 00H
	DB	'_', 00H, 'B', 00H, 'Y', 00H, 'T', 00H, 'E', 00H, 'S', 00H, '('
	DB	00H, ' ', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H
	DB	'n', 00H, 'a', 00H, 'l', 00H, 'P', 00H, 'a', 00H, 'c', 00H, 'k'
	DB	00H, 'e', 00H, 't', 00H, '-', 00H, '>', 00H, 'd', 00H, 'a', 00H
	DB	't', 00H, 'a', 00H, 'B', 00H, 'i', 00H, 't', 00H, 'L', 00H, 'e'
	DB	00H, 'n', 00H, 'g', 00H, 't', 00H, 'h', 00H, ' ', 00H, ')', 00H
	DB	' ', 00H, '<', 00H, ' ', 00H, 'M', 00H, 'A', 00H, 'X', 00H, 'I'
	DB	00H, 'M', 00H, 'U', 00H, 'M', 00H, '_', 00H, 'M', 00H, 'T', 00H
	DB	'U', 00H, '_', 00H, 'S', 00H, 'I', 00H, 'Z', 00H, 'E', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@LOHKMABB@?$AAi?$AAn?$AAt?$AAe?$AAr?$AAn?$AAa?$AAl?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AAB?$AAi?$AAt?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5@
CONST	SEGMENT
??_C@_1EE@LOHKMABB@?$AAi?$AAn?$AAt?$AAe?$AAr?$AAn?$AAa?$AAl?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AAB?$AAi?$AAt?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5@ DB 'i'
	DB	00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'n', 00H, 'a', 00H
	DB	'l', 00H, 'P', 00H, 'a', 00H, 'c', 00H, 'k', 00H, 'e', 00H, 't'
	DB	00H, '-', 00H, '>', 00H, 'd', 00H, 'a', 00H, 't', 00H, 'a', 00H
	DB	'B', 00H, 'i', 00H, 't', 00H, 'L', 00H, 'e', 00H, 'n', 00H, 'g'
	DB	00H, 't', 00H, 'h', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1DI@CEDLGLL@?$AAb?$AAi?$AAt?$AAS?$AAt?$AAr?$AAe?$AAa?$AAm?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAt?$AAe?$AAr?$AAn?$AAa?$AAl?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1DI@CEDLGLL@?$AAb?$AAi?$AAt?$AAS?$AAt?$AAr?$AAe?$AAa?$AAm?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAt?$AAe?$AAr?$AAn?$AAa?$AAl?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?$AA@ DB 'b'
	DB	00H, 'i', 00H, 't', 00H, 'S', 00H, 't', 00H, 'r', 00H, 'e', 00H
	DB	'a', 00H, 'm', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'i'
	DB	00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'n', 00H, 'a', 00H
	DB	'l', 00H, 'P', 00H, 'a', 00H, 'c', 00H, 'k', 00H, 'e', 00H, 't'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??WriteToBitStreamFromInternalPacket@ReliabilityLayer@@AAEHPAVBitStream@RakNet@@QBUInternalPacket@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??WriteToBitStreamFromInternalPacket@ReliabilityLayer@@AAEHPAVBitStream@RakNet@@QBUInternalPacket@@@Z@4JA DD 0688H ; `ReliabilityLayer::WriteToBitStreamFromInternalPacket'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1BO@FAHOLNMM@?$AAi?$AAn?$AAt?$AAe?$AAr?$AAn?$AAa?$AAl?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@FAHOLNMM@?$AAi?$AAn?$AAt?$AAe?$AAr?$AAn?$AAa?$AAl?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?$AA@ DB 'i'
	DB	00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'n', 00H, 'a', 00H
	DB	'l', 00H, 'P', 00H, 'a', 00H, 'c', 00H, 'k', 00H, 'e', 00H, 't'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??GetBitStreamHeaderLength@ReliabilityLayer@@AAEHQBUInternalPacket@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??GetBitStreamHeaderLength@ReliabilityLayer@@AAEHQBUInternalPacket@@@Z@4JA DD 064eH ; `ReliabilityLayer::GetBitStreamHeaderLength'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1DM@HJOKLFNH@?$AAi?$AAn?$AAt?$AAe?$AAr?$AAn?$AAa?$AAl?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?9?$AA?$DO?$AAp?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1DM@HJOKLFNH@?$AAi?$AAn?$AAt?$AAe?$AAr?$AAn?$AAa?$AAl?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?9?$AA?$DO?$AAp?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'i'
	DB	00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'n', 00H, 'a', 00H
	DB	'l', 00H, 'P', 00H, 'a', 00H, 'c', 00H, 'k', 00H, 'e', 00H, 't'
	DB	00H, '-', 00H, '>', 00H, 'p', 00H, 'r', 00H, 'i', 00H, 'o', 00H
	DB	'r', 00H, 'i', 00H, 't', 00H, 'y', 00H, ' ', 00H, '>', 00H, '='
	DB	00H, ' ', 00H, '0', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??GenerateDatagram@ReliabilityLayer@@AAEIPAVBitStream@RakNet@@HPA_N_JUPlayerID@@AAV?$List@PAVPluginInterface@@@DataStructures@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??GenerateDatagram@ReliabilityLayer@@AAEIPAVBitStream@RakNet@@HPA_N_JUPlayerID@@AAV?$List@PAVPluginInterface@@@DataStructures@@@Z@4JA DD 04d9H ; `ReliabilityLayer::GenerateDatagram'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1CI@ENDPABPL@?$AA?$CI?$AA?5?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$CF?$AA?5?$AA8?$AA?5?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@ENDPABPL@?$AA?$CI?$AA?5?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$CF?$AA?5?$AA8?$AA?5?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB '('
	DB	00H, ' ', 00H, 'l', 00H, 'e', 00H, 'n', 00H, 'g', 00H, 't', 00H
	DB	'h', 00H, ' ', 00H, '%', 00H, ' ', 00H, '8', 00H, ' ', 00H, ')'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??SendBitStream@ReliabilityLayer@@AAEXIUPlayerID@@PAVBitStream@RakNet@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??SendBitStream@ReliabilityLayer@@AAEXIUPlayerID@@PAVBitStream@RakNet@@@Z@4JA DD 0497H ; `ReliabilityLayer::SendBitStream'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0EF@BEKPCEMB@Error?$CB?$CB?5ReliabilityLayer?3?3Send?5b@
CONST	SEGMENT
??_C@_0EF@BEKPCEMB@Error?$CB?$CB?5ReliabilityLayer?3?3Send?5b@ DB 'Error!'
	DB	'! ReliabilityLayer::Send bitStream->GetNumberOfBytesUsed()==0'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@KEDLFNFL@?$AAn?$AAu?$AAm?$AAb?$AAe?$AAr?$AAO?$AAf?$AAB?$AAi?$AAt?$AAs?$AAT?$AAo?$AAS?$AAe?$AAn?$AAd?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@KEDLFNFL@?$AAn?$AAu?$AAm?$AAb?$AAe?$AAr?$AAO?$AAf?$AAB?$AAi?$AAt?$AAs?$AAT?$AAo?$AAS?$AAe?$AAn?$AAd?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB 'n'
	DB	00H, 'u', 00H, 'm', 00H, 'b', 00H, 'e', 00H, 'r', 00H, 'O', 00H
	DB	'f', 00H, 'B', 00H, 'i', 00H, 't', 00H, 's', 00H, 'T', 00H, 'o'
	DB	00H, 'S', 00H, 'e', 00H, 'n', 00H, 'd', 00H, ' ', 00H, '>', 00H
	DB	' ', 00H, '0', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1JC@KFGENCHD@?$AA?$CB?$AA?$CI?$AA?5?$AAo?$AAr?$AAd?$AAe?$AAr?$AAi?$AAn?$AAg?$AAC?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AA?5?$AA?$DM?$AA?5?$AA0?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAo?$AAr?$AAd?$AAe?$AAr?$AAi@
CONST	SEGMENT
??_C@_1JC@KFGENCHD@?$AA?$CB?$AA?$CI?$AA?5?$AAo?$AAr?$AAd?$AAe?$AAr?$AAi?$AAn?$AAg?$AAC?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AA?5?$AA?$DM?$AA?5?$AA0?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAo?$AAr?$AAd?$AAe?$AAr?$AAi@ DB '!'
	DB	00H, '(', 00H, ' ', 00H, 'o', 00H, 'r', 00H, 'd', 00H, 'e', 00H
	DB	'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 'C', 00H, 'h', 00H, 'a'
	DB	00H, 'n', 00H, 'n', 00H, 'e', 00H, 'l', 00H, ' ', 00H, '<', 00H
	DB	' ', 00H, '0', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, 'o'
	DB	00H, 'r', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, 'C', 00H, 'h', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'e'
	DB	00H, 'l', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, 'N', 00H
	DB	'U', 00H, 'M', 00H, 'B', 00H, 'E', 00H, 'R', 00H, '_', 00H, 'O'
	DB	00H, 'F', 00H, '_', 00H, 'O', 00H, 'R', 00H, 'D', 00H, 'E', 00H
	DB	'R', 00H, 'E', 00H, 'D', 00H, '_', 00H, 'S', 00H, 'T', 00H, 'R'
	DB	00H, 'E', 00H, 'A', 00H, 'M', 00H, 'S', 00H, ' ', 00H, ')', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1GK@MADIINNK@?$AA?$CB?$AA?$CI?$AA?5?$AAp?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA?5?$AA?$DO?$AA?5?$AAN?$AAU?$AAM?$AAB?$AAE?$AAR?$AA_?$AAO?$AAF?$AA_?$AAP?$AAR?$AAI?$AAO?$AAR?$AAI?$AAT?$AAI@
CONST	SEGMENT
??_C@_1GK@MADIINNK@?$AA?$CB?$AA?$CI?$AA?5?$AAp?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA?5?$AA?$DO?$AA?5?$AAN?$AAU?$AAM?$AAB?$AAE?$AAR?$AA_?$AAO?$AAF?$AA_?$AAP?$AAR?$AAI?$AAO?$AAR?$AAI?$AAT?$AAI@ DB '!'
	DB	00H, '(', 00H, ' ', 00H, 'p', 00H, 'r', 00H, 'i', 00H, 'o', 00H
	DB	'r', 00H, 'i', 00H, 't', 00H, 'y', 00H, ' ', 00H, '>', 00H, ' '
	DB	00H, 'N', 00H, 'U', 00H, 'M', 00H, 'B', 00H, 'E', 00H, 'R', 00H
	DB	'_', 00H, 'O', 00H, 'F', 00H, '_', 00H, 'P', 00H, 'R', 00H, 'I'
	DB	00H, 'O', 00H, 'R', 00H, 'I', 00H, 'T', 00H, 'I', 00H, 'E', 00H
	DB	'S', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, 'p', 00H, 'r'
	DB	00H, 'i', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 't', 00H, 'y', 00H
	DB	' ', 00H, '<', 00H, ' ', 00H, '0', 00H, ' ', 00H, ')', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1HC@GDCNHECB@?$AA?$CB?$AA?$CI?$AA?5?$AAr?$AAe?$AAl?$AAi?$AAa?$AAb?$AAi?$AAl?$AAi?$AAt?$AAy?$AA?5?$AA?$DO?$AA?5?$AAR?$AAE?$AAL?$AAI?$AAA?$AAB?$AAL?$AAE?$AA_?$AAS?$AAE?$AAQ?$AAU?$AAE?$AAN@
CONST	SEGMENT
??_C@_1HC@GDCNHECB@?$AA?$CB?$AA?$CI?$AA?5?$AAr?$AAe?$AAl?$AAi?$AAa?$AAb?$AAi?$AAl?$AAi?$AAt?$AAy?$AA?5?$AA?$DO?$AA?5?$AAR?$AAE?$AAL?$AAI?$AAA?$AAB?$AAL?$AAE?$AA_?$AAS?$AAE?$AAQ?$AAU?$AAE?$AAN@ DB '!'
	DB	00H, '(', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 'l', 00H, 'i', 00H
	DB	'a', 00H, 'b', 00H, 'i', 00H, 'l', 00H, 'i', 00H, 't', 00H, 'y'
	DB	00H, ' ', 00H, '>', 00H, ' ', 00H, 'R', 00H, 'E', 00H, 'L', 00H
	DB	'I', 00H, 'A', 00H, 'B', 00H, 'L', 00H, 'E', 00H, '_', 00H, 'S'
	DB	00H, 'E', 00H, 'Q', 00H, 'U', 00H, 'E', 00H, 'N', 00H, 'C', 00H
	DB	'E', 00H, 'D', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, 'r'
	DB	00H, 'e', 00H, 'l', 00H, 'i', 00H, 'a', 00H, 'b', 00H, 'i', 00H
	DB	'l', 00H, 'i', 00H, 't', 00H, 'y', 00H, ' ', 00H, '<', 00H, ' '
	DB	00H, '0', 00H, ' ', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??Send@ReliabilityLayer@@QAE_NPADHW4PacketPriority@@W4PacketReliability@@E_NH_J@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??Send@ReliabilityLayer@@QAE_NPADHW4PacketPriority@@W4PacketReliability@@E_NH_J@Z@4JA DD 0336H ; `ReliabilityLayer::Send'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DA@MOADJCKG@Got?5invalid?5ordering?5channel?5?$CFi?5@
CONST	SEGMENT
??_C@_0DA@MOADJCKG@Got?5invalid?5ordering?5channel?5?$CFi?5@ DB 'Got inva'
	DB	'lid ordering channel %i from packet %i', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@HCJJFHJF@Got?5invalid?5packet?6?$AA@
CONST	SEGMENT
??_C@_0BE@HCJJFHJF@Got?5invalid?5packet?6?$AA@ DB 'Got invalid packet', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1HI@MKMNOBIC@?$AAi?$AAn?$AAt?$AAe?$AAr?$AAn?$AAa?$AAl?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?9?$AA?$DO?$AAo?$AAr?$AAd?$AAe?$AAr?$AAi?$AAn?$AAg?$AAC?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AA?5@
CONST	SEGMENT
??_C@_1HI@MKMNOBIC@?$AAi?$AAn?$AAt?$AAe?$AAr?$AAn?$AAa?$AAl?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?9?$AA?$DO?$AAo?$AAr?$AAd?$AAe?$AAr?$AAi?$AAn?$AAg?$AAC?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AA?5@ DB 'i'
	DB	00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'n', 00H, 'a', 00H
	DB	'l', 00H, 'P', 00H, 'a', 00H, 'c', 00H, 'k', 00H, 'e', 00H, 't'
	DB	00H, '-', 00H, '>', 00H, 'o', 00H, 'r', 00H, 'd', 00H, 'e', 00H
	DB	'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 'C', 00H, 'h', 00H, 'a'
	DB	00H, 'n', 00H, 'n', 00H, 'e', 00H, 'l', 00H, ' ', 00H, '<', 00H
	DB	' ', 00H, 'N', 00H, 'U', 00H, 'M', 00H, 'B', 00H, 'E', 00H, 'R'
	DB	00H, '_', 00H, 'O', 00H, 'F', 00H, '_', 00H, 'O', 00H, 'R', 00H
	DB	'D', 00H, 'E', 00H, 'R', 00H, 'E', 00H, 'D', 00H, '_', 00H, 'S'
	DB	00H, 'T', 00H, 'R', 00H, 'E', 00H, 'A', 00H, 'M', 00H, 'S', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1JA@FAAHMOBE@?$AAh?$AAa?$AAs?$AAR?$AAe?$AAc?$AAe?$AAi?$AAv?$AAe?$AAd?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AAQ?$AAu?$AAe?$AAu?$AAe?$AA?4?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?5@
CONST	SEGMENT
??_C@_1JA@FAAHMOBE@?$AAh?$AAa?$AAs?$AAR?$AAe?$AAc?$AAe?$AAi?$AAv?$AAe?$AAd?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AAQ?$AAu?$AAe?$AAu?$AAe?$AA?4?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?5@ DB 'h'
	DB	00H, 'a', 00H, 's', 00H, 'R', 00H, 'e', 00H, 'c', 00H, 'e', 00H
	DB	'i', 00H, 'v', 00H, 'e', 00H, 'd', 00H, 'P', 00H, 'a', 00H, 'c'
	DB	00H, 'k', 00H, 'e', 00H, 't', 00H, 'Q', 00H, 'u', 00H, 'e', 00H
	DB	'u', 00H, 'e', 00H, '.', 00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e'
	DB	00H, '(', 00H, ')', 00H, ' ', 00H, '<', 00H, ' ', 00H, '(', 00H
	DB	'u', 00H, 'n', 00H, 's', 00H, 'i', 00H, 'g', 00H, 'n', 00H, 'e'
	DB	00H, 'd', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 't', 00H, ')', 00H
	DB	'(', 00H, '(', 00H, 'M', 00H, 'e', 00H, 's', 00H, 's', 00H, 'a'
	DB	00H, 'g', 00H, 'e', 00H, 'N', 00H, 'u', 00H, 'm', 00H, 'b', 00H
	DB	'e', 00H, 'r', 00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H, ')'
	DB	00H, '(', 00H, '-', 00H, '1', 00H, ')', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1IC@KPHIMKPK@?$AAi?$AAn?$AAc?$AAo?$AAm?$AAi?$AAn?$AAg?$AAA?$AAc?$AAk?$AAs?$AA?4?$AAr?$AAa?$AAn?$AAg?$AAe?$AAs?$AA?$FL?$AAi?$AA?$FN?$AA?4?$AAm?$AAi?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?$DM@
CONST	SEGMENT
??_C@_1IC@KPHIMKPK@?$AAi?$AAn?$AAc?$AAo?$AAm?$AAi?$AAn?$AAg?$AAA?$AAc?$AAk?$AAs?$AA?4?$AAr?$AAa?$AAn?$AAg?$AAe?$AAs?$AA?$FL?$AAi?$AA?$FN?$AA?4?$AAm?$AAi?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?$DM@ DB 'i'
	DB	00H, 'n', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, 'A', 00H, 'c', 00H, 'k', 00H, 's', 00H, '.', 00H, 'r'
	DB	00H, 'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H, 's', 00H, '[', 00H
	DB	'i', 00H, ']', 00H, '.', 00H, 'm', 00H, 'i', 00H, 'n', 00H, 'I'
	DB	00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, '<', 00H, '=', 00H
	DB	'i', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, 'A', 00H, 'c', 00H, 'k', 00H, 's', 00H, '.', 00H
	DB	'r', 00H, 'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H, 's', 00H, '['
	DB	00H, 'i', 00H, ']', 00H, '.', 00H, 'm', 00H, 'a', 00H, 'x', 00H
	DB	'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@BNPCOFAI@?$AA?$CB?$AA?$CI?$AA?5?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1EA@BNPCOFAI@?$AA?$CB?$AA?$CI?$AA?5?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CJ?$AA?$AA@ DB '!'
	DB	00H, '(', 00H, ' ', 00H, 'l', 00H, 'e', 00H, 'n', 00H, 'g', 00H
	DB	't', 00H, 'h', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, '0'
	DB	00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, 'b', 00H, 'u', 00H
	DB	'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H, ' ', 00H, '=', 00H, '='
	DB	00H, ' ', 00H, '0', 00H, ' ', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FK@FKLHGKMO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAe?$AAl?$AAi?$AAa?$AAb?$AAi?$AAl@
CONST	SEGMENT
??_C@_1FK@FKLHGKMO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAe?$AAl?$AAi?$AAa?$AAb?$AAi?$AAl@ DB 'z'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H
	DB	's', 00H, 'r', 00H, 'c', 00H, '\', 00H, '0', 00H, '2', 00H, 'x'
	DB	00H, 'u', 00H, '1', 00H, '\', 00H, 'r', 00H, 'a', 00H, 'k', 00H
	DB	'n', 00H, 'e', 00H, 't', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'l'
	DB	00H, 'i', 00H, 'a', 00H, 'b', 00H, 'i', 00H, 'l', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, 'l', 00H, 'a', 00H, 'y', 00H, 'e', 00H, 'r'
	DB	00H, '.', 00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??HandleSocketReceiveFromConnectedPlayer@ReliabilityLayer@@QAE_NPBDHUPlayerID@@AAV?$List@PAVPluginInterface@@@DataStructures@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??HandleSocketReceiveFromConnectedPlayer@ReliabilityLayer@@QAE_NPBDHUPlayerID@@AAV?$List@PAVPluginInterface@@@DataStructures@@H@Z@4JA DD 014dH ; `ReliabilityLayer::HandleSocketReceiveFromConnectedPlayer'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$LinkedList@PAUInternalPacket@@@DataStructures@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$LinkedList@PAUInternalPacket@@@DataStructures@@QAE@XZ$0
__ehfuncinfo$??1?$LinkedList@PAUInternalPacket@@@DataStructures@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$LinkedList@PAUInternalPacket@@@DataStructures@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QAE@XZ$0
__ehfuncinfo$??1?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$MemoryPool@U?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$MemoryPool@U?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAE@XZ$0
__ehfuncinfo$??1?$MemoryPool@U?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$MemoryPool@U?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?FreePages@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FreePages@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEXXZ$0
__ehfuncinfo$?FreePages@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FreePages@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QAE@XZ$0
__ehfuncinfo$??1?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Insert@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXU?$RangeNode@G@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Insert@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXU?$RangeNode@G@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Insert@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXU?$RangeNode@G@2@@Z$1
__ehfuncinfo$?Insert@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXU?$RangeNode@G@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Insert@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXU?$RangeNode@G@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Insert@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXU?$RangeNode@G@2@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Insert@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXU?$RangeNode@G@2@I@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Insert@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXU?$RangeNode@G@2@I@Z$1
__ehfuncinfo$?Insert@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXU?$RangeNode@G@2@I@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Insert@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXU?$RangeNode@G@2@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAE@XZ$0
__ehfuncinfo$??1?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Deserialize@?$RangeList@G@DataStructures@@QAE_NPAVBitStream@RakNet@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Deserialize@?$RangeList@G@DataStructures@@QAE_NPAVBitStream@RakNet@@@Z$0
__ehfuncinfo$?Deserialize@?$RangeList@G@DataStructures@@QAE_NPAVBitStream@RakNet@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Deserialize@?$RangeList@G@DataStructures@@QAE_NPAVBitStream@RakNet@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Serialize@?$RangeList@G@DataStructures@@QAEIPAVBitStream@RakNet@@H_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Serialize@?$RangeList@G@DataStructures@@QAEIPAVBitStream@RakNet@@H_N@Z$0
__ehfuncinfo$?Serialize@?$RangeList@G@DataStructures@@QAEIPAVBitStream@RakNet@@H_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Serialize@?$RangeList@G@DataStructures@@QAEIPAVBitStream@RakNet@@H_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Insert@?$RangeList@G@DataStructures@@QAEXG@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Insert@?$RangeList@G@DataStructures@@QAEXG@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Insert@?$RangeList@G@DataStructures@@QAEXG@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Insert@?$RangeList@G@DataStructures@@QAEXG@Z$2
__ehfuncinfo$?Insert@?$RangeList@G@DataStructures@@QAEXG@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?Insert@?$RangeList@G@DataStructures@@QAEXG@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$RangeList@G@DataStructures@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$RangeList@G@DataStructures@@QAE@XZ$0
__ehfuncinfo$??1?$RangeList@G@DataStructures@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$RangeList@G@DataStructures@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$RangeList@G@DataStructures@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$RangeList@G@DataStructures@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$RangeList@G@DataStructures@@QAE@XZ$1
__ehfuncinfo$??0?$RangeList@G@DataStructures@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$RangeList@G@DataStructures@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?AddToOrderingList@ReliabilityLayer@@AAEXPAUInternalPacket@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddToOrderingList@ReliabilityLayer@@AAEXPAUInternalPacket@@@Z$0
__ehfuncinfo$?AddToOrderingList@ReliabilityLayer@@AAEXPAUInternalPacket@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddToOrderingList@ReliabilityLayer@@AAEXPAUInternalPacket@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?InsertIntoSplitPacketList@ReliabilityLayer@@AAEXPAUInternalPacket@@_J@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?InsertIntoSplitPacketList@ReliabilityLayer@@AAEXPAUInternalPacket@@_J@Z$0
__ehfuncinfo$?InsertIntoSplitPacketList@ReliabilityLayer@@AAEXPAUInternalPacket@@_J@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?InsertIntoSplitPacketList@ReliabilityLayer@@AAEXPAUInternalPacket@@_J@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetSHA1@ReliabilityLayer@@AAEXQAEIQAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetSHA1@ReliabilityLayer@@AAEXQAEIQAD@Z$0
__ehfuncinfo$?GetSHA1@ReliabilityLayer@@AAEXQAEIQAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetSHA1@ReliabilityLayer@@AAEXQAEIQAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?HandleSocketReceiveFromConnectedPlayer@ReliabilityLayer@@QAE_NPBDHUPlayerID@@AAV?$List@PAVPluginInterface@@@DataStructures@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?HandleSocketReceiveFromConnectedPlayer@ReliabilityLayer@@QAE_NPBDHUPlayerID@@AAV?$List@PAVPluginInterface@@@DataStructures@@H@Z$7
	DD	00H
	DD	FLAT:__unwindfunclet$?HandleSocketReceiveFromConnectedPlayer@ReliabilityLayer@@QAE_NPBDHUPlayerID@@AAV?$List@PAVPluginInterface@@@DataStructures@@H@Z$8
__ehfuncinfo$?HandleSocketReceiveFromConnectedPlayer@ReliabilityLayer@@QAE_NPBDHUPlayerID@@AAV?$List@PAVPluginInterface@@@DataStructures@@H@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?HandleSocketReceiveFromConnectedPlayer@ReliabilityLayer@@QAE_NPBDHUPlayerID@@AAV?$List@PAVPluginInterface@@@DataStructures@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1ReliabilityLayer@@QAE@XZ DD 019930522H
	DD	0cH
	DD	FLAT:__unwindtable$??1ReliabilityLayer@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1ReliabilityLayer@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1ReliabilityLayer@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1ReliabilityLayer@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1ReliabilityLayer@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1ReliabilityLayer@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1ReliabilityLayer@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1ReliabilityLayer@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1ReliabilityLayer@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1ReliabilityLayer@@QAE@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??1ReliabilityLayer@@QAE@XZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$??1ReliabilityLayer@@QAE@XZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$??1ReliabilityLayer@@QAE@XZ$10
	DD	0aH
	DD	FLAT:__unwindfunclet$??1ReliabilityLayer@@QAE@XZ$11
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0ReliabilityLayer@@QAE@XZ DD 019930522H
	DD	0cH
	DD	FLAT:__unwindtable$??0ReliabilityLayer@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0ReliabilityLayer@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ReliabilityLayer@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0ReliabilityLayer@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0ReliabilityLayer@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0ReliabilityLayer@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0ReliabilityLayer@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0ReliabilityLayer@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0ReliabilityLayer@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??0ReliabilityLayer@@QAE@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??0ReliabilityLayer@@QAE@XZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$??0ReliabilityLayer@@QAE@XZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$??0ReliabilityLayer@@QAE@XZ$10
	DD	0aH
	DD	FLAT:__unwindfunclet$??0ReliabilityLayer@@QAE@XZ$11
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QAE@XZ$0
__ehfuncinfo$??1?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ?Size@?$Queue@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$Queue@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QBEIXZ PROC ; DataStructures::Queue<DataStructures::Page<unsigned short,InternalPacket *,32> *>::Size, COMDAT
; _this$ = ecx

; 62   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 63   : 		if ( head <= tail )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	ja	SHORT $LN2@Size

; 64   : 			return tail -head;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	jmp	SHORT $LN3@Size

; 65   : 		else

	jmp	SHORT $LN3@Size
$LN2@Size:

; 66   : 			return allocation_size -head + tail;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx+8]
$LN3@Size:

; 67   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$Queue@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QBEIXZ ENDP ; DataStructures::Queue<DataStructures::Page<unsigned short,InternalPacket *,32> *>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ?Pop@?$Queue@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEPAU?$Page@GPAUInternalPacket@@$0CA@@2@XZ
_TEXT	SEGMENT
tv78 = -208						; size = 4
_this$ = -8						; size = 4
?Pop@?$Queue@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEPAU?$Page@GPAUInternalPacket@@$0CA@@2@XZ PROC ; DataStructures::Queue<DataStructures::Page<unsigned short,InternalPacket *,32> *>::Pop, COMDAT
; _this$ = ecx

; 99   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 100  : #ifdef _DEBUG
; 101  : 		assert( allocation_size > 0 && Size() >= 0 && head != tail);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jbe	SHORT $LN5@Pop
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$Queue@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::Queue<DataStructures::Page<unsigned short,InternalPacket *,32> *>::Size
	test	eax, eax
	jb	SHORT $LN5@Pop
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN6@Pop
$LN5@Pop:
	push	101					; 00000065H
	push	OFFSET ??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@
	push	OFFSET ??_C@_1GG@JDEIIJCO@?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN6@Pop:

; 102  : #endif
; 103  : 		//head=(head+1) % allocation_size;
; 104  : 
; 105  : 		if ( ++head == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	DWORD PTR tv78[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv78[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv78[ebp]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN2@Pop

; 106  : 			head = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
$LN2@Pop:

; 107  : 
; 108  : 		if ( head == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN1@Pop

; 109  : 			return ( queue_type ) array[ allocation_size -1 ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+ecx*4-4]
	jmp	SHORT $LN3@Pop
$LN1@Pop:

; 110  : 
; 111  : 		return ( queue_type ) array[ head -1 ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+ecx*4-4]
$LN3@Pop:

; 112  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Pop@?$Queue@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEPAU?$Page@GPAUInternalPacket@@$0CA@@2@XZ ENDP ; DataStructures::Queue<DataStructures::Page<unsigned short,InternalPacket *,32> *>::Pop
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ?Push@?$Queue@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEXABQAU?$Page@GPAUInternalPacket@@$0CA@@2@@Z
_TEXT	SEGMENT
$T1 = -260						; size = 4
$T2 = -248						; size = 4
$T3 = -236						; size = 4
_counter$4 = -32					; size = 4
_new_array$5 = -20					; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
?Push@?$Queue@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEXABQAU?$Page@GPAUInternalPacket@@$0CA@@2@@Z PROC ; DataStructures::Queue<DataStructures::Page<unsigned short,InternalPacket *,32> *>::Push, COMDAT
; _this$ = ecx

; 182  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 183  : 		if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN6@Push

; 184  : 		{
; 185  : 			array = new queue_type[ 16 ];

	push	64					; 00000040H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax], ecx

; 186  : 			head = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 187  : 			tail = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 1

; 188  : 			array[ 0 ] = input;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+eax], edx

; 189  : 			allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 16			; 00000010H

; 190  : 			return ;

	jmp	$LN7@Push
$LN6@Push:

; 191  : 		}
; 192  : 
; 193  : 		array[ tail++ ] = input;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [eax+ecx*4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 194  : 
; 195  : 		if ( tail == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN5@Push

; 196  : 			tail = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
$LN5@Push:

; 197  : 
; 198  : 		if ( tail == head )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+4]
	jne	$LN7@Push

; 199  : 		{
; 200  : 			//  unsigned int index=tail;
; 201  : 
; 202  : 			// Need to allocate more memory.
; 203  : 			queue_type * new_array;
; 204  : 			new_array = new queue_type[ allocation_size * 2 ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	shl	eax, 1
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _new_array$5[ebp], eax

; 205  : #ifdef _DEBUG
; 206  : 
; 207  : 			assert( new_array );

	cmp	DWORD PTR _new_array$5[ebp], 0
	jne	SHORT $LN9@Push
	push	207					; 000000cfH
	push	OFFSET ??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@
	push	OFFSET ??_C@_1BE@OMEGJCHO@?$AAn?$AAe?$AAw?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN9@Push:

; 208  : #endif
; 209  : 
; 210  : 			for ( unsigned int counter = 0; counter < allocation_size; ++counter )

	mov	DWORD PTR _counter$4[ebp], 0
	jmp	SHORT $LN3@Push
$LN2@Push:
	mov	eax, DWORD PTR _counter$4[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$4[ebp], eax
$LN3@Push:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _counter$4[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN1@Push

; 211  : 				new_array[ counter ] = array[ ( head + counter ) % ( allocation_size ) ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, DWORD PTR _counter$4[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _counter$4[ebp]
	mov	esi, DWORD PTR _new_array$5[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [esi+eax*4], ecx
	jmp	SHORT $LN2@Push
$LN1@Push:

; 212  : 
; 213  : 			head = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 214  : 
; 215  : 			tail = allocation_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+8], edx

; 216  : 
; 217  : 			allocation_size *= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 218  : 
; 219  : 			// Delete the old array and move the pointer to the new array
; 220  : 			delete [] array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T3[ebp], ecx
	mov	edx, DWORD PTR $T3[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 221  : 
; 222  : 			array = new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$5[ebp]
	mov	DWORD PTR [eax], ecx
$LN7@Push:

; 223  : 		}
; 224  : 
; 225  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Push@?$Queue@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEXABQAU?$Page@GPAUInternalPacket@@$0CA@@2@@Z ENDP ; DataStructures::Queue<DataStructures::Page<unsigned short,InternalPacket *,32> *>::Push
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ??1?$Queue@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
??1?$Queue@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAE@XZ PROC ; DataStructures::Queue<DataStructures::Page<unsigned short,InternalPacket *,32> *>::~Queue<DataStructures::Page<unsigned short,InternalPacket *,32> *>, COMDAT
; _this$ = ecx

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		if (allocation_size>0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jbe	SHORT $LN2@Queue

; 94   : 			delete [] array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@Queue:

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$Queue@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAE@XZ ENDP ; DataStructures::Queue<DataStructures::Page<unsigned short,InternalPacket *,32> *>::~Queue<DataStructures::Page<unsigned short,InternalPacket *,32> *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ??0?$Queue@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
??0?$Queue@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAE@XZ PROC ; DataStructures::Queue<DataStructures::Page<unsigned short,InternalPacket *,32> *>::Queue<DataStructures::Page<unsigned short,InternalPacket *,32> *>, COMDAT
; _this$ = ecx

; 83   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 84   : 		allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 16			; 00000010H

; 85   : 		array = new queue_type[ allocation_size ];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax], ecx

; 86   : 		head = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 87   : 		tail = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 88   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$Queue@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAE@XZ ENDP ; DataStructures::Queue<DataStructures::Page<unsigned short,InternalPacket *,32> *>::Queue<DataStructures::Page<unsigned short,InternalPacket *,32> *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$ReadCompressed@G@BitStream@RakNet@@QAE_NAAG@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 4
??$ReadCompressed@G@BitStream@RakNet@@QAE_NAAG@Z PROC	; RakNet::BitStream::ReadCompressed<unsigned short>, COMDAT
; _this$ = ecx

; 1080 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1081 : #ifdef _MSC_VER
; 1082 : #pragma warning(disable:4127)   // conditional expression is constant
; 1083 : #endif
; 1084 : 		if (sizeof(var)==1)

	xor	eax, eax
	je	SHORT $LN2@ReadCompre

; 1085 : 			return ReadCompressed( ( unsigned char* ) &var, sizeof(templateType) * 8, true );

	push	1
	push	16					; 00000010H
	mov	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadCompressed@BitStream@RakNet@@AAE_NPAEH_N@Z ; RakNet::BitStream::ReadCompressed
	jmp	SHORT $LN3@ReadCompre

; 1086 : 		else

	jmp	SHORT $LN3@ReadCompre
$LN2@ReadCompre:

; 1087 : 		{
; 1088 : #ifndef __BITSTREAM_NATIVE_END
; 1089 : 			if (DoEndianSwap())
; 1090 : 			{
; 1091 : 				unsigned char output[sizeof(templateType)];
; 1092 : 				if (ReadCompressed( ( unsigned char* ) output, sizeof(templateType) * 8, true ))
; 1093 : 				{
; 1094 : 					ReverseBytes(output, (unsigned char*)&var, sizeof(templateType));
; 1095 : 					return true;
; 1096 : 				}
; 1097 : 				return false;
; 1098 : 			}
; 1099 : 			else
; 1100 : #endif
; 1101 : 				return ReadCompressed( ( unsigned char* ) & var, sizeof(templateType) * 8, true );

	push	1
	push	16					; 00000010H
	mov	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadCompressed@BitStream@RakNet@@AAE_NPAEH_N@Z ; RakNet::BitStream::ReadCompressed
$LN3@ReadCompre:

; 1102 : 		}
; 1103 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$ReadCompressed@G@BitStream@RakNet@@QAE_NAAG@Z ENDP	; RakNet::BitStream::ReadCompressed<unsigned short>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$ReadCompressed@I@BitStream@RakNet@@QAE_NAAI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 4
??$ReadCompressed@I@BitStream@RakNet@@QAE_NAAI@Z PROC	; RakNet::BitStream::ReadCompressed<unsigned int>, COMDAT
; _this$ = ecx

; 1080 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1081 : #ifdef _MSC_VER
; 1082 : #pragma warning(disable:4127)   // conditional expression is constant
; 1083 : #endif
; 1084 : 		if (sizeof(var)==1)

	xor	eax, eax
	je	SHORT $LN2@ReadCompre

; 1085 : 			return ReadCompressed( ( unsigned char* ) &var, sizeof(templateType) * 8, true );

	push	1
	push	32					; 00000020H
	mov	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadCompressed@BitStream@RakNet@@AAE_NPAEH_N@Z ; RakNet::BitStream::ReadCompressed
	jmp	SHORT $LN3@ReadCompre

; 1086 : 		else

	jmp	SHORT $LN3@ReadCompre
$LN2@ReadCompre:

; 1087 : 		{
; 1088 : #ifndef __BITSTREAM_NATIVE_END
; 1089 : 			if (DoEndianSwap())
; 1090 : 			{
; 1091 : 				unsigned char output[sizeof(templateType)];
; 1092 : 				if (ReadCompressed( ( unsigned char* ) output, sizeof(templateType) * 8, true ))
; 1093 : 				{
; 1094 : 					ReverseBytes(output, (unsigned char*)&var, sizeof(templateType));
; 1095 : 					return true;
; 1096 : 				}
; 1097 : 				return false;
; 1098 : 			}
; 1099 : 			else
; 1100 : #endif
; 1101 : 				return ReadCompressed( ( unsigned char* ) & var, sizeof(templateType) * 8, true );

	push	1
	push	32					; 00000020H
	mov	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadCompressed@BitStream@RakNet@@AAE_NPAEH_N@Z ; RakNet::BitStream::ReadCompressed
$LN3@ReadCompre:

; 1102 : 		}
; 1103 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$ReadCompressed@I@BitStream@RakNet@@QAE_NAAI@Z ENDP	; RakNet::BitStream::ReadCompressed<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$WriteCompressed@G@BitStream@RakNet@@QAEXG@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 2
??$WriteCompressed@G@BitStream@RakNet@@QAEXG@Z PROC	; RakNet::BitStream::WriteCompressed<unsigned short>, COMDAT
; _this$ = ecx

; 865  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 866  : #ifdef _MSC_VER
; 867  : #pragma warning(disable:4127)   // conditional expression is constant
; 868  : #endif
; 869  : 		if (sizeof(var)==1)

	xor	eax, eax
	je	SHORT $LN2@WriteCompr

; 870  : 			WriteCompressed( ( unsigned char* ) & var, sizeof( templateType ) * 8, true );

	push	1
	push	16					; 00000010H
	lea	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteCompressed@BitStream@RakNet@@AAEXPBEH_N@Z ; RakNet::BitStream::WriteCompressed

; 871  : 		else

	jmp	SHORT $LN3@WriteCompr
$LN2@WriteCompr:

; 872  : 		{
; 873  : #ifndef __BITSTREAM_NATIVE_END
; 874  : #ifdef _MSC_VER
; 875  : #pragma warning(disable:4244)   // '=' : conversion from 'unsigned long' to 'unsigned short', possible loss of data
; 876  : #endif
; 877  : 
; 878  : 			if (DoEndianSwap())
; 879  : 			{
; 880  : 				unsigned char output[sizeof(templateType)];
; 881  : 				ReverseBytes((unsigned char*)&var, output, sizeof(templateType));
; 882  : 				WriteCompressed( ( unsigned char* ) output, sizeof(templateType) * 8, true );
; 883  : 			}
; 884  : 			else
; 885  : #endif
; 886  : 				WriteCompressed( ( unsigned char* ) & var, sizeof(templateType) * 8, true );

	push	1
	push	16					; 00000010H
	lea	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteCompressed@BitStream@RakNet@@AAEXPBEH_N@Z ; RakNet::BitStream::WriteCompressed
$LN3@WriteCompr:

; 887  : 		}
; 888  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$WriteCompressed@G@BitStream@RakNet@@QAEXG@Z ENDP	; RakNet::BitStream::WriteCompressed<unsigned short>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$WriteCompressed@I@BitStream@RakNet@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 4
??$WriteCompressed@I@BitStream@RakNet@@QAEXI@Z PROC	; RakNet::BitStream::WriteCompressed<unsigned int>, COMDAT
; _this$ = ecx

; 865  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 866  : #ifdef _MSC_VER
; 867  : #pragma warning(disable:4127)   // conditional expression is constant
; 868  : #endif
; 869  : 		if (sizeof(var)==1)

	xor	eax, eax
	je	SHORT $LN2@WriteCompr

; 870  : 			WriteCompressed( ( unsigned char* ) & var, sizeof( templateType ) * 8, true );

	push	1
	push	32					; 00000020H
	lea	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteCompressed@BitStream@RakNet@@AAEXPBEH_N@Z ; RakNet::BitStream::WriteCompressed

; 871  : 		else

	jmp	SHORT $LN3@WriteCompr
$LN2@WriteCompr:

; 872  : 		{
; 873  : #ifndef __BITSTREAM_NATIVE_END
; 874  : #ifdef _MSC_VER
; 875  : #pragma warning(disable:4244)   // '=' : conversion from 'unsigned long' to 'unsigned short', possible loss of data
; 876  : #endif
; 877  : 
; 878  : 			if (DoEndianSwap())
; 879  : 			{
; 880  : 				unsigned char output[sizeof(templateType)];
; 881  : 				ReverseBytes((unsigned char*)&var, output, sizeof(templateType));
; 882  : 				WriteCompressed( ( unsigned char* ) output, sizeof(templateType) * 8, true );
; 883  : 			}
; 884  : 			else
; 885  : #endif
; 886  : 				WriteCompressed( ( unsigned char* ) & var, sizeof(templateType) * 8, true );

	push	1
	push	32					; 00000020H
	lea	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteCompressed@BitStream@RakNet@@AAEXPBEH_N@Z ; RakNet::BitStream::WriteCompressed
$LN3@WriteCompr:

; 887  : 		}
; 888  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$WriteCompressed@I@BitStream@RakNet@@QAEXI@Z ENDP	; RakNet::BitStream::WriteCompressed<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Size@?$List@PAVPluginInterface@@@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$List@PAVPluginInterface@@@DataStructures@@QBEIXZ PROC ; DataStructures::List<PluginInterface *>::Size, COMDAT
; _this$ = ecx

; 373  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 374  : 		return list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 375  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$List@PAVPluginInterface@@@DataStructures@@QBEIXZ ENDP ; DataStructures::List<PluginInterface *>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??A?$List@PAVPluginInterface@@@DataStructures@@QBEAAPAVPluginInterface@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
??A?$List@PAVPluginInterface@@@DataStructures@@QBEAAPAVPluginInterface@@I@Z PROC ; DataStructures::List<PluginInterface *>::operator[], COMDAT
; _this$ = ecx

; 185  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 186  : #ifdef _DEBUG
; 187  : 		assert ( position < list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN3@operator
	push	187					; 000000bbH
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@operator:

; 188  : #endif
; 189  : 		return listArray[ position ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _position$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 190  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@PAVPluginInterface@@@DataStructures@@QBEAAPAVPluginInterface@@I@Z ENDP ; DataStructures::List<PluginInterface *>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_E?$RangeNode@G@DataStructures@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_E?$RangeNode@G@DataStructures@@QAEPAXI@Z PROC	; DataStructures::RangeNode<unsigned short>::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector
	push	OFFSET ??1?$RangeNode@G@DataStructures@@QAE@XZ ; DataStructures::RangeNode<unsigned short>::~RangeNode<unsigned short>
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax-4]
	push	ecx
	push	4
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@vector
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@vector:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector
$LN3@vector:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$RangeNode@G@DataStructures@@QAE@XZ	; DataStructures::RangeNode<unsigned short>::~RangeNode<unsigned short>
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector:
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_E?$RangeNode@G@DataStructures@@QAEPAXI@Z ENDP	; DataStructures::RangeNode<unsigned short>::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_rangelist.h
;	COMDAT ??0?$RangeNode@G@DataStructures@@QAE@GG@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_min$ = 8						; size = 2
_max$ = 12						; size = 2
??0?$RangeNode@G@DataStructures@@QAE@GG@Z PROC		; DataStructures::RangeNode<unsigned short>::RangeNode<unsigned short>, COMDAT
; _this$ = ecx

; 15   :         RangeNode(range_type min, range_type max) {minIndex=min; maxIndex=max;}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _min$[ebp]
	mov	WORD PTR [eax], cx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _max$[ebp]
	mov	WORD PTR [eax+2], cx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$RangeNode@G@DataStructures@@QAE@GG@Z ENDP		; DataStructures::RangeNode<unsigned short>::RangeNode<unsigned short>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_rangelist.h
;	COMDAT ??1?$RangeNode@G@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$RangeNode@G@DataStructures@@QAE@XZ PROC		; DataStructures::RangeNode<unsigned short>::~RangeNode<unsigned short>, COMDAT
; _this$ = ecx

; 14   :         ~RangeNode() {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$RangeNode@G@DataStructures@@QAE@XZ ENDP		; DataStructures::RangeNode<unsigned short>::~RangeNode<unsigned short>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_rangelist.h
;	COMDAT ??0?$RangeNode@G@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$RangeNode@G@DataStructures@@QAE@XZ PROC		; DataStructures::RangeNode<unsigned short>::RangeNode<unsigned short>, COMDAT
; _this$ = ecx

; 13   :         RangeNode() {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$RangeNode@G@DataStructures@@QAE@XZ ENDP		; DataStructures::RangeNode<unsigned short>::RangeNode<unsigned short>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_G?$LinkedList@PAUInternalPacket@@@DataStructures@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_G?$LinkedList@PAUInternalPacket@@@DataStructures@@QAEPAXI@Z PROC ; DataStructures::LinkedList<InternalPacket *>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$LinkedList@PAUInternalPacket@@@DataStructures@@QAE@XZ ; DataStructures::LinkedList<InternalPacket *>::~LinkedList<InternalPacket *>
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$LinkedList@PAUInternalPacket@@@DataStructures@@QAEPAXI@Z ENDP ; DataStructures::LinkedList<InternalPacket *>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_linkedlist.h
;	COMDAT ??E?$LinkedList@PAUInternalPacket@@@DataStructures@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 4
??E?$LinkedList@PAUInternalPacket@@@DataStructures@@QAEAAV01@H@Z PROC ; DataStructures::LinkedList<InternalPacket *>::operator++, COMDAT
; _this$ = ecx

; 1219 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1220 : 		return this->operator++();

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$LinkedList@PAUInternalPacket@@@DataStructures@@QAEAAV01@XZ ; DataStructures::LinkedList<InternalPacket *>::operator++

; 1221 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??E?$LinkedList@PAUInternalPacket@@@DataStructures@@QAEAAV01@H@Z ENDP ; DataStructures::LinkedList<InternalPacket *>::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_linkedlist.h
;	COMDAT ??E?$LinkedList@PAUInternalPacket@@@DataStructures@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??E?$LinkedList@PAUInternalPacket@@@DataStructures@@QAEAAV01@XZ PROC ; DataStructures::LinkedList<InternalPacket *>::operator++, COMDAT
; _this$ = ecx

; 1198 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1199 : 		if ( ( this->list_size != 0 ) && ( this->position->next != this->root ) )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	cmp	eax, DWORD PTR [edx+4]
	je	SHORT $LN1@operator

; 1200 : 			this->position = this->position->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
$LN1@operator:

; 1201 : 
; 1202 : 		return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1203 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$LinkedList@PAUInternalPacket@@@DataStructures@@QAEAAV01@XZ ENDP ; DataStructures::LinkedList<InternalPacket *>::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_linkedlist.h
;	COMDAT ??1?$LinkedList@PAUInternalPacket@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$LinkedList@PAUInternalPacket@@@DataStructures@@QAE@XZ PROC ; DataStructures::LinkedList<InternalPacket *>::~LinkedList<InternalPacket *>, COMDAT
; _this$ = ecx

; 361  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$LinkedList@PAUInternalPacket@@@DataStructures@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 362  : 		this->Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEXXZ ; DataStructures::CircularLinkedList<InternalPacket *>::Clear

; 363  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAE@XZ ; DataStructures::CircularLinkedList<InternalPacket *>::~CircularLinkedList<InternalPacket *>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$LinkedList@PAUInternalPacket@@@DataStructures@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAE@XZ ; DataStructures::CircularLinkedList<InternalPacket *>::~CircularLinkedList<InternalPacket *>
__ehhandler$??1?$LinkedList@PAUInternalPacket@@@DataStructures@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$LinkedList@PAUInternalPacket@@@DataStructures@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$LinkedList@PAUInternalPacket@@@DataStructures@@QAE@XZ ENDP ; DataStructures::LinkedList<InternalPacket *>::~LinkedList<InternalPacket *>
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_linkedlist.h
;	COMDAT ??0?$LinkedList@PAUInternalPacket@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$LinkedList@PAUInternalPacket@@@DataStructures@@QAE@XZ PROC ; DataStructures::LinkedList<InternalPacket *>::LinkedList<InternalPacket *>, COMDAT
; _this$ = ecx

; 222  : 		LinkedList()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAE@XZ ; DataStructures::CircularLinkedList<InternalPacket *>::CircularLinkedList<InternalPacket *>
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$LinkedList@PAUInternalPacket@@@DataStructures@@QAE@XZ ENDP ; DataStructures::LinkedList<InternalPacket *>::LinkedList<InternalPacket *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_linkedlist.h
;	COMDAT ?End@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?End@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEXXZ PROC ; DataStructures::CircularLinkedList<InternalPacket *>::End, COMDAT
; _this$ = ecx

; 249  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 250  : 		if ( this->root )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN2@End

; 251  : 			this->position = this->root->previous;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+8], eax
$LN2@End:

; 252  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?End@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEXXZ ENDP ; DataStructures::CircularLinkedList<InternalPacket *>::End
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_linkedlist.h
;	COMDAT ?Beginning@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Beginning@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEXXZ PROC ; DataStructures::CircularLinkedList<InternalPacket *>::Beginning, COMDAT
; _this$ = ecx

; 242  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 243  : 		if ( this->root )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN2@Beginning

; 244  : 			this->position = this->root;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+8], edx
$LN2@Beginning:

; 245  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Beginning@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEXXZ ENDP ; DataStructures::CircularLinkedList<InternalPacket *>::Beginning
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_linkedlist.h
;	COMDAT ?Clear@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEXXZ
_TEXT	SEGMENT
$T1 = -248						; size = 4
$T2 = -236						; size = 4
_temp$3 = -32						; size = 4
_current$4 = -20					; size = 4
_this$ = -8						; size = 4
?Clear@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEXXZ PROC ; DataStructures::CircularLinkedList<InternalPacket *>::Clear, COMDAT
; _this$ = ecx

; 959  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 960  : 		if ( this->list_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN7@Clear

; 961  : 			return ;

	jmp	SHORT $LN8@Clear

; 962  : 		else

	jmp	SHORT $LN6@Clear
$LN7@Clear:

; 963  : 			if ( this->list_size == 1 )  // {delete root->item; delete root;}

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN5@Clear

; 964  : 			{
; 965  : 				delete this->root;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 966  : 			}
; 967  : 
; 968  : 			else

	jmp	SHORT $LN6@Clear
$LN5@Clear:

; 969  : 			{
; 970  : 				node* current;
; 971  : 				node* temp;
; 972  : 
; 973  : 				current = this->root;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _current$4[ebp], ecx
$LN3@Clear:

; 974  : 
; 975  : 				do
; 976  : 				{
; 977  : 					temp = current;

	mov	eax, DWORD PTR _current$4[ebp]
	mov	DWORD PTR _temp$3[ebp], eax

; 978  : 					current = current->next;

	mov	eax, DWORD PTR _current$4[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _current$4[ebp], ecx

; 979  : 					// delete temp->item;
; 980  : 					delete temp;

	mov	eax, DWORD PTR _temp$3[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 981  : 				}
; 982  : 
; 983  : 				while ( current != this->root );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _current$4[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN3@Clear
$LN6@Clear:

; 984  : 			}
; 985  : 
; 986  : 			this->list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 987  : 			this->root = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 988  : 			this->position = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
$LN8@Clear:

; 989  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEXXZ ENDP ; DataStructures::CircularLinkedList<InternalPacket *>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_linkedlist.h
;	COMDAT ?Pop@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEPAUInternalPacket@@XZ
_TEXT	SEGMENT
_element$ = -20						; size = 4
_this$ = -8						; size = 4
?Pop@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEPAUInternalPacket@@XZ PROC ; DataStructures::CircularLinkedList<InternalPacket *>::Pop, COMDAT
; _this$ = ecx

; 894  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 895  : 		CircularLinkedListType element;
; 896  : 		element = Peek();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Peek@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEAAPAUInternalPacket@@XZ ; DataStructures::CircularLinkedList<InternalPacket *>::Peek
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _element$[ebp], eax

; 897  : 		Del();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Del@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEXXZ ; DataStructures::CircularLinkedList<InternalPacket *>::Del

; 898  : 		return CircularLinkedListType( element ); // return temporary

	mov	eax, DWORD PTR _element$[ebp]

; 899  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Pop@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEPAUInternalPacket@@XZ ENDP ; DataStructures::CircularLinkedList<InternalPacket *>::Pop
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_linkedlist.h
;	COMDAT ?Peek@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEAAPAUInternalPacket@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Peek@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEAAPAUInternalPacket@@XZ PROC ; DataStructures::CircularLinkedList<InternalPacket *>::Peek, COMDAT
; _this$ = ecx

; 887  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 888  : 		// return *(position->item);
; 889  : 		return this->position->item;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 890  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Peek@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEAAPAUInternalPacket@@XZ ENDP ; DataStructures::CircularLinkedList<InternalPacket *>::Peek
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_linkedlist.h
;	COMDAT ?Size@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEIXZ PROC ; DataStructures::CircularLinkedList<InternalPacket *>::Size, COMDAT
; _this$ = ecx

; 881  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 882  : 		return this->list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 883  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEIXZ ENDP ; DataStructures::CircularLinkedList<InternalPacket *>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_linkedlist.h
;	COMDAT ?Del@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEXXZ
_TEXT	SEGMENT
$T1 = -236						; size = 4
$T2 = -224						; size = 4
_new_position$ = -20					; size = 4
_this$ = -8						; size = 4
?Del@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEXXZ PROC ; DataStructures::CircularLinkedList<InternalPacket *>::Del, COMDAT
; _this$ = ecx

; 785  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 786  : 		node * new_position;
; 787  : 
; 788  : 		if ( this->list_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN5@Del

; 789  : 			return ;

	jmp	$LN6@Del

; 790  : 
; 791  : 		else

	jmp	$LN6@Del
$LN5@Del:

; 792  : 			if ( this->list_size == 1 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN3@Del

; 793  : 			{
; 794  : 				// delete root->item;
; 795  : 				delete this->root;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 796  : 				this->root = this->position = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 797  : 				this->list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 798  : 			}
; 799  : 
; 800  : 			else

	jmp	SHORT $LN6@Del
$LN3@Del:

; 801  : 			{
; 802  : 				( this->position->previous ) ->next = this->position->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax

; 803  : 				( this->position->next ) ->previous = this->position->previous;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax

; 804  : 				new_position = this->position->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _new_position$[ebp], edx

; 805  : 
; 806  : 				if ( this->position == this->root )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN1@Del

; 807  : 					this->root = new_position;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_position$[ebp]
	mov	DWORD PTR [eax+4], ecx
$LN1@Del:

; 808  : 
; 809  : 				// delete position->item;
; 810  : 				delete this->position;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 811  : 
; 812  : 				this->position = new_position;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_position$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 813  : 
; 814  : 				this->list_size--;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
$LN6@Del:

; 815  : 			}
; 816  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Del@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEXXZ ENDP ; DataStructures::CircularLinkedList<InternalPacket *>::Del
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_linkedlist.h
;	COMDAT ?Add@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEAAPAUInternalPacket@@ABQAU3@@Z
_TEXT	SEGMENT
$T1 = -248						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_new_node$ = -20					; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
?Add@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEAAPAUInternalPacket@@ABQAU3@@Z PROC ; DataStructures::CircularLinkedList<InternalPacket *>::Add, COMDAT
; _this$ = ecx

; 701  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 702  : 		node * new_node;
; 703  : 
; 704  : 		if ( this->list_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN4@Add

; 705  : 		{
; 706  : 			this->root = new typename CircularLinkedList::node;

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax+4], ecx

; 707  : 			// root->item = new CircularLinkedListType;
; 708  : 			// *(root->item)=input;
; 709  : 			this->root->item = input;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _input$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 710  : 			this->root->next = this->root;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+8], eax

; 711  : 			this->root->previous = this->root;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 712  : 			this->list_size = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 1

; 713  : 			this->position = this->root;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+8], edx

; 714  : 			// return *(position->item);
; 715  : 			return this->position->item;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	jmp	$LN5@Add

; 716  : 		}
; 717  : 
; 718  : 		else

	jmp	$LN5@Add
$LN4@Add:

; 719  : 			if ( list_size == 1 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 1
	jne	$LN2@Add

; 720  : 			{
; 721  : 				this->position = new typename CircularLinkedList::node;

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [eax+8], ecx

; 722  : 				// position->item = new CircularLinkedListType;
; 723  : 				this->root->next = this->position;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax

; 724  : 				this->root->previous = this->position;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+4], eax

; 725  : 				this->position->previous = this->root;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 726  : 				this->position->next = this->root;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+8], eax

; 727  : 				// *(position->item)=input;
; 728  : 				this->position->item = input;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _input$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 729  : 				this->list_size = 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 2

; 730  : 				this->position = this->root; // Don't move the position from the root

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+8], edx

; 731  : 				// return *(position->item);
; 732  : 				return this->position->item;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN5@Add

; 733  : 			}
; 734  : 
; 735  : 			else

	jmp	SHORT $LN5@Add
$LN2@Add:

; 736  : 			{
; 737  : 				/*
; 738  : 
; 739  : 				   B
; 740  : 			       |
; 741  : 				A --- C
; 742  : 
; 743  : 				new_node=B
; 744  : 				position=A
; 745  : 				position->next=C
; 746  : 
; 747  : 				Note that the order of the following statements is important  */
; 748  : 
; 749  : 				new_node = new typename CircularLinkedList::node;

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR _new_node$[ebp], eax

; 750  : 				// new_node->item = new CircularLinkedListType;
; 751  : 
; 752  : 				// *(new_node->item)=input;
; 753  : 				new_node->item = input;

	mov	eax, DWORD PTR _new_node$[ebp]
	mov	ecx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 754  : 
; 755  : 				// Point last of B to A
; 756  : 				new_node->previous = this->position;

	mov	eax, DWORD PTR _new_node$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+4], edx

; 757  : 
; 758  : 				// Point next of B to C
; 759  : 				new_node->next = ( this->position->next );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _new_node$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax

; 760  : 
; 761  : 				// Point last of C to B
; 762  : 				( this->position->next ) ->previous = new_node;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _new_node$[ebp]
	mov	DWORD PTR [edx+4], eax

; 763  : 
; 764  : 				// Point next of A to B
; 765  : 				( this->position->next ) = new_node;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _new_node$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 766  : 
; 767  : 				// Increase the recorded size of the list by one
; 768  : 				this->list_size++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 769  : 
; 770  : 				// return *(new_node->item);
; 771  : 				return new_node->item;

	mov	eax, DWORD PTR _new_node$[ebp]
$LN5@Add:

; 772  : 			}
; 773  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Add@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEAAPAUInternalPacket@@ABQAU3@@Z ENDP ; DataStructures::CircularLinkedList<InternalPacket *>::Add
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_linkedlist.h
;	COMDAT ??1?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAE@XZ PROC ; DataStructures::CircularLinkedList<InternalPacket *>::~CircularLinkedList<InternalPacket *>, COMDAT
; _this$ = ecx

; 355  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 356  : 		this->Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEXXZ ; DataStructures::CircularLinkedList<InternalPacket *>::Clear

; 357  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAE@XZ ENDP ; DataStructures::CircularLinkedList<InternalPacket *>::~CircularLinkedList<InternalPacket *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_linkedlist.h
;	COMDAT ??0?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAE@XZ PROC ; DataStructures::CircularLinkedList<InternalPacket *>::CircularLinkedList<InternalPacket *>, COMDAT
; _this$ = ecx

; 347  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 348  : 		this->root = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 349  : 		this->position = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 350  : 		this->list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 351  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAE@XZ ENDP ; DataStructures::CircularLinkedList<InternalPacket *>::CircularLinkedList<InternalPacket *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Clear@?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QAEX_N@Z
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
_doNotDeallocate$ = 8					; size = 1
?Clear@?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QAEX_N@Z PROC ; DataStructures::List<ReliabilityLayer::DataAndTime *>::Clear, COMDAT
; _this$ = ecx

; 379  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  : 		if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Clear

; 381  : 			return;

	jmp	SHORT $LN3@Clear
$LN2@Clear:

; 382  : 
; 383  : 		if (allocation_size>512 && doNotDeallocate==false)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 512			; 00000200H
	jbe	SHORT $LN1@Clear
	movzx	eax, BYTE PTR _doNotDeallocate$[ebp]
	test	eax, eax
	jne	SHORT $LN1@Clear

; 384  : 		{
; 385  : 			delete [] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 386  : 			allocation_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 387  : 			listArray = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN1@Clear:

; 388  : 		}
; 389  : 		list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
$LN3@Clear:

; 390  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Clear@?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QAEX_N@Z ENDP ; DataStructures::List<ReliabilityLayer::DataAndTime *>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Size@?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QBEIXZ PROC ; DataStructures::List<ReliabilityLayer::DataAndTime *>::Size, COMDAT
; _this$ = ecx

; 373  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 374  : 		return list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 375  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QBEIXZ ENDP ; DataStructures::List<ReliabilityLayer::DataAndTime *>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Del@?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_num$ = 8						; size = 4
?Del@?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QAEXI@Z PROC ; DataStructures::List<ReliabilityLayer::DataAndTime *>::Del, COMDAT
; _this$ = ecx

; 353  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 354  : 		// Delete the last elements on the list.  No compression needed
; 355  : #ifdef _DEBUG
; 356  : 		assert(list_size>=num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _num$[ebp]
	jae	SHORT $LN3@Del
	push	356					; 00000164H
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1BO@JBFMBKMD@?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$DO?$AA?$DN?$AAn?$AAu?$AAm?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@Del:

; 357  : #endif
; 358  : 		list_size-=num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _num$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 359  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Del@?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QAEXI@Z ENDP ; DataStructures::List<ReliabilityLayer::DataAndTime *>::Del
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Insert@?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QAEXQAUDataAndTime@ReliabilityLayer@@@Z
_TEXT	SEGMENT
$T1 = -236						; size = 4
$T2 = -224						; size = 4
_new_array$3 = -20					; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
?Insert@?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QAEXQAUDataAndTime@ReliabilityLayer@@@Z PROC ; DataStructures::List<ReliabilityLayer::DataAndTime *>::Insert, COMDAT
; _this$ = ecx

; 242  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 243  : 		// Reallocate list if necessary
; 244  : 
; 245  : 		if ( list_size == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	$LN3@Insert

; 246  : 		{
; 247  : 			// allocate twice the currently allocated memory
; 248  : 			list_type * new_array;
; 249  : 
; 250  : 			if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Insert

; 251  : 				allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 16			; 00000010H

; 252  : 			else

	jmp	SHORT $LN1@Insert
$LN2@Insert:

; 253  : 				allocation_size *= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN1@Insert:

; 254  : 
; 255  : 			new_array = new list_type [ allocation_size ];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _new_array$3[ebp], eax

; 256  : 
; 257  : 			// copy old array over
; 258  : 			//	for ( unsigned int counter = 0; counter < list_size; ++counter )
; 259  : 			//		new_array[ counter ] = listArray[ counter ];
; 260  : 
; 261  : 			// Don't call constructors, assignment operators, etc.
; 262  : 			memcpy(new_array, listArray, list_size*sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _new_array$3[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 263  : 
; 264  : 			// set old array to point to the newly allocated and twice as large array
; 265  : 			delete[] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 266  : 
; 267  : 			listArray = new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$3[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Insert:

; 268  : 		}
; 269  : 
; 270  : 		// Insert the new item at the correct spot
; 271  : 		listArray[ list_size ] = input;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _input$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 272  : 
; 273  : 		++list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 274  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Insert@?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QAEXQAUDataAndTime@ReliabilityLayer@@@Z ENDP ; DataStructures::List<ReliabilityLayer::DataAndTime *>::Insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??A?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QBEAAPAUDataAndTime@ReliabilityLayer@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
??A?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QBEAAPAUDataAndTime@ReliabilityLayer@@I@Z PROC ; DataStructures::List<ReliabilityLayer::DataAndTime *>::operator[], COMDAT
; _this$ = ecx

; 185  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 186  : #ifdef _DEBUG
; 187  : 		assert ( position < list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN3@operator
	push	187					; 000000bbH
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@operator:

; 188  : #endif
; 189  : 		return listArray[ position ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _position$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 190  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QBEAAPAUDataAndTime@ReliabilityLayer@@I@Z ENDP ; DataStructures::List<ReliabilityLayer::DataAndTime *>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??1?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
??1?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QAE@XZ PROC ; DataStructures::List<ReliabilityLayer::DataAndTime *>::~List<ReliabilityLayer::DataAndTime *>, COMDAT
; _this$ = ecx

; 121  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 122  : 		if (allocation_size>0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jbe	SHORT $LN2@List

; 123  : 			delete [] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@List:

; 124  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QAE@XZ ENDP ; DataStructures::List<ReliabilityLayer::DataAndTime *>::~List<ReliabilityLayer::DataAndTime *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??0?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QAE@XZ PROC ; DataStructures::List<ReliabilityLayer::DataAndTime *>::List<ReliabilityLayer::DataAndTime *>, COMDAT
; _this$ = ecx

; 113  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 114  : 		allocation_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 115  : 		listArray = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 116  : 		list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 117  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QAE@XZ ENDP ; DataStructures::List<ReliabilityLayer::DataAndTime *>::List<ReliabilityLayer::DataAndTime *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ?ClearAndForceAllocation@?$Queue@_J@DataStructures@@QAEXH@Z
_TEXT	SEGMENT
$T1 = -224						; size = 4
$T2 = -212						; size = 4
_this$ = -8						; size = 4
_size$ = 8						; size = 4
?ClearAndForceAllocation@?$Queue@_J@DataStructures@@QAEXH@Z PROC ; DataStructures::Queue<__int64>::ClearAndForceAllocation, COMDAT
; _this$ = ecx

; 346  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 347  : 		delete [] array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 348  : 		array = new queue_type[ size ];

	xor	ecx, ecx
	mov	eax, DWORD PTR _size$[ebp]
	mov	edx, 8
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [eax], ecx

; 349  : 		allocation_size = size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 350  : 		head = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 351  : 		tail = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 352  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?ClearAndForceAllocation@?$Queue@_J@DataStructures@@QAEXH@Z ENDP ; DataStructures::Queue<__int64>::ClearAndForceAllocation
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ?Compress@?$Queue@_J@DataStructures@@QAEXXZ
_TEXT	SEGMENT
$T1 = -260						; size = 4
$T2 = -248						; size = 4
_counter$3 = -44					; size = 4
_newAllocationSize$ = -32				; size = 4
_new_array$ = -20					; size = 4
_this$ = -8						; size = 4
?Compress@?$Queue@_J@DataStructures@@QAEXXZ PROC	; DataStructures::Queue<__int64>::Compress, COMDAT
; _this$ = ecx

; 301  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 302  : 		queue_type* new_array;
; 303  : 		unsigned int newAllocationSize;
; 304  : 		if (allocation_size==0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN6@Compress

; 305  : 			return;

	jmp	$LN7@Compress
$LN6@Compress:

; 306  : 
; 307  : 		newAllocationSize=1;

	mov	DWORD PTR _newAllocationSize$[ebp], 1
$LN5@Compress:

; 308  : 		while (newAllocationSize <= Size())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$Queue@_J@DataStructures@@QBEIXZ	; DataStructures::Queue<__int64>::Size
	cmp	DWORD PTR _newAllocationSize$[ebp], eax
	ja	SHORT $LN4@Compress

; 309  : 			newAllocationSize<<=1; // Must be a better way to do this but I'm too dumb to figure it out quickly :)

	mov	eax, DWORD PTR _newAllocationSize$[ebp]
	shl	eax, 1
	mov	DWORD PTR _newAllocationSize$[ebp], eax
	jmp	SHORT $LN5@Compress
$LN4@Compress:

; 310  : 
; 311  : 		new_array = new queue_type [newAllocationSize];

	xor	ecx, ecx
	mov	eax, DWORD PTR _newAllocationSize$[ebp]
	mov	edx, 8
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _new_array$[ebp], eax

; 312  : 
; 313  : 		for (unsigned int counter=0; counter < Size(); ++counter)

	mov	DWORD PTR _counter$3[ebp], 0
	jmp	SHORT $LN3@Compress
$LN2@Compress:
	mov	eax, DWORD PTR _counter$3[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$3[ebp], eax
$LN3@Compress:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$Queue@_J@DataStructures@@QBEIXZ	; DataStructures::Queue<__int64>::Size
	cmp	DWORD PTR _counter$3[ebp], eax
	jae	SHORT $LN1@Compress

; 314  : 			new_array[counter] = array[(head + counter)%(allocation_size)];

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, DWORD PTR _counter$3[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _counter$3[ebp]
	mov	esi, DWORD PTR _new_array$[ebp]
	mov	edi, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR [esi+eax*8], edi
	mov	ecx, DWORD PTR [ecx+edx*8+4]
	mov	DWORD PTR [esi+eax*8+4], ecx
	jmp	SHORT $LN2@Compress
$LN1@Compress:

; 315  : 
; 316  : 		tail=Size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$Queue@_J@DataStructures@@QBEIXZ	; DataStructures::Queue<__int64>::Size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 317  : 		allocation_size=newAllocationSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newAllocationSize$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 318  : 		head=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 319  : 
; 320  : 		// Delete the old array and move the pointer to the new array
; 321  : 		delete [] array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 322  : 		array=new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$[ebp]
	mov	DWORD PTR [eax], ecx
$LN7@Compress:

; 323  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Compress@?$Queue@_J@DataStructures@@QAEXXZ ENDP	; DataStructures::Queue<__int64>::Compress
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ?AllocationSize@?$Queue@_J@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?AllocationSize@?$Queue@_J@DataStructures@@QBEIXZ PROC	; DataStructures::Queue<__int64>::AllocationSize, COMDAT
; _this$ = ecx

; 77   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 78   : 		return allocation_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]

; 79   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AllocationSize@?$Queue@_J@DataStructures@@QBEIXZ ENDP	; DataStructures::Queue<__int64>::AllocationSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ?Size@?$Queue@_J@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$Queue@_J@DataStructures@@QBEIXZ PROC		; DataStructures::Queue<__int64>::Size, COMDAT
; _this$ = ecx

; 62   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 63   : 		if ( head <= tail )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	ja	SHORT $LN2@Size

; 64   : 			return tail -head;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	jmp	SHORT $LN3@Size

; 65   : 		else

	jmp	SHORT $LN3@Size
$LN2@Size:

; 66   : 			return allocation_size -head + tail;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx+8]
$LN3@Size:

; 67   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$Queue@_J@DataStructures@@QBEIXZ ENDP		; DataStructures::Queue<__int64>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ?Pop@?$Queue@_J@DataStructures@@QAE_JXZ
_TEXT	SEGMENT
tv78 = -208						; size = 4
_this$ = -8						; size = 4
?Pop@?$Queue@_J@DataStructures@@QAE_JXZ PROC		; DataStructures::Queue<__int64>::Pop, COMDAT
; _this$ = ecx

; 99   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 100  : #ifdef _DEBUG
; 101  : 		assert( allocation_size > 0 && Size() >= 0 && head != tail);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jbe	SHORT $LN5@Pop
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$Queue@_J@DataStructures@@QBEIXZ	; DataStructures::Queue<__int64>::Size
	test	eax, eax
	jb	SHORT $LN5@Pop
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN6@Pop
$LN5@Pop:
	push	101					; 00000065H
	push	OFFSET ??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@
	push	OFFSET ??_C@_1GG@JDEIIJCO@?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN6@Pop:

; 102  : #endif
; 103  : 		//head=(head+1) % allocation_size;
; 104  : 
; 105  : 		if ( ++head == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	DWORD PTR tv78[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv78[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv78[ebp]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN2@Pop

; 106  : 			head = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
$LN2@Pop:

; 107  : 
; 108  : 		if ( head == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN1@Pop

; 109  : 			return ( queue_type ) array[ allocation_size -1 ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx+ecx*8-8]
	mov	edx, DWORD PTR [edx+ecx*8-4]
	jmp	SHORT $LN3@Pop
$LN1@Pop:

; 110  : 
; 111  : 		return ( queue_type ) array[ head -1 ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx+ecx*8-8]
	mov	edx, DWORD PTR [edx+ecx*8-4]
$LN3@Pop:

; 112  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Pop@?$Queue@_J@DataStructures@@QAE_JXZ ENDP		; DataStructures::Queue<__int64>::Pop
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ?Peek@?$Queue@_J@DataStructures@@QBE_JXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Peek@?$Queue@_J@DataStructures@@QBE_JXZ PROC		; DataStructures::Queue<__int64>::Peek, COMDAT
; _this$ = ecx

; 171  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 172  : #ifdef _DEBUG
; 173  : 		assert( head != tail );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN3@Peek
	push	173					; 000000adH
	push	OFFSET ??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@
	push	OFFSET ??_C@_1BK@BHOIKEPB@?$AAh?$AAe?$AAa?$AAd?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAt?$AAa?$AAi?$AAl?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@Peek:

; 174  : 		assert( allocation_size > 0 && Size() >= 0 );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jbe	SHORT $LN4@Peek
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$Queue@_J@DataStructures@@QBEIXZ	; DataStructures::Queue<__int64>::Size
	test	eax, eax
	jae	SHORT $LN5@Peek
$LN4@Peek:
	push	174					; 000000aeH
	push	OFFSET ??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@
	push	OFFSET ??_C@_1EG@MGMFGCAG@?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN5@Peek:

; 175  : #endif
; 176  : 
; 177  : 		return ( queue_type ) array[ head ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx+ecx*8]
	mov	edx, DWORD PTR [edx+ecx*8+4]

; 178  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Peek@?$Queue@_J@DataStructures@@QBE_JXZ ENDP		; DataStructures::Queue<__int64>::Peek
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ??A?$Queue@_J@DataStructures@@QBEAA_JI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
??A?$Queue@_J@DataStructures@@QBEAA_JI@Z PROC		; DataStructures::Queue<__int64>::operator[], COMDAT
; _this$ = ecx

; 356  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 357  : #ifdef _DEBUG
; 358  : 		assert( position < Size() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$Queue@_J@DataStructures@@QBEIXZ	; DataStructures::Queue<__int64>::Size
	cmp	DWORD PTR _position$[ebp], eax
	jb	SHORT $LN5@operator
	push	358					; 00000166H
	push	OFFSET ??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@
	push	OFFSET ??_C@_1CE@CLDOPLDF@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN5@operator:

; 359  : #endif
; 360  : 		//return array[(head + position) % allocation_size];
; 361  : 
; 362  : 		if ( head + position >= allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _position$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [edx+12]
	jb	SHORT $LN2@operator

; 363  : 			return array[ head + position - allocation_size ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _position$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	sub	ecx, DWORD PTR [edx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	lea	eax, DWORD PTR [edx+ecx*8]
	jmp	SHORT $LN3@operator

; 364  : 		else

	jmp	SHORT $LN3@operator
$LN2@operator:

; 365  : 			return array[ head + position ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _position$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	eax, DWORD PTR [eax+ecx*8]
$LN3@operator:

; 366  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$Queue@_J@DataStructures@@QBEAA_JI@Z ENDP		; DataStructures::Queue<__int64>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ?Push@?$Queue@_J@DataStructures@@QAEXAB_J@Z
_TEXT	SEGMENT
$T1 = -260						; size = 4
$T2 = -248						; size = 4
$T3 = -236						; size = 4
_counter$4 = -32					; size = 4
_new_array$5 = -20					; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
?Push@?$Queue@_J@DataStructures@@QAEXAB_J@Z PROC	; DataStructures::Queue<__int64>::Push, COMDAT
; _this$ = ecx

; 182  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 183  : 		if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN6@Push

; 184  : 		{
; 185  : 			array = new queue_type[ 16 ];

	push	128					; 00000080H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax], ecx

; 186  : 			head = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 187  : 			tail = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 1

; 188  : 			array[ 0 ] = input;

	mov	eax, 8
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _input$[ebp]
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx+eax], esi
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+eax+4], edx

; 189  : 			allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 16			; 00000010H

; 190  : 			return ;

	jmp	$LN7@Push
$LN6@Push:

; 191  : 		}
; 192  : 
; 193  : 		array[ tail++ ] = input;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _input$[ebp]
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax+ecx*8], esi
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+ecx*8+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 194  : 
; 195  : 		if ( tail == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN5@Push

; 196  : 			tail = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
$LN5@Push:

; 197  : 
; 198  : 		if ( tail == head )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+4]
	jne	$LN7@Push

; 199  : 		{
; 200  : 			//  unsigned int index=tail;
; 201  : 
; 202  : 			// Need to allocate more memory.
; 203  : 			queue_type * new_array;
; 204  : 			new_array = new queue_type[ allocation_size * 2 ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	shl	eax, 1
	xor	ecx, ecx
	mov	edx, 8
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _new_array$5[ebp], eax

; 205  : #ifdef _DEBUG
; 206  : 
; 207  : 			assert( new_array );

	cmp	DWORD PTR _new_array$5[ebp], 0
	jne	SHORT $LN9@Push
	push	207					; 000000cfH
	push	OFFSET ??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@
	push	OFFSET ??_C@_1BE@OMEGJCHO@?$AAn?$AAe?$AAw?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN9@Push:

; 208  : #endif
; 209  : 
; 210  : 			for ( unsigned int counter = 0; counter < allocation_size; ++counter )

	mov	DWORD PTR _counter$4[ebp], 0
	jmp	SHORT $LN3@Push
$LN2@Push:
	mov	eax, DWORD PTR _counter$4[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$4[ebp], eax
$LN3@Push:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _counter$4[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN1@Push

; 211  : 				new_array[ counter ] = array[ ( head + counter ) % ( allocation_size ) ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, DWORD PTR _counter$4[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _counter$4[ebp]
	mov	esi, DWORD PTR _new_array$5[ebp]
	mov	edi, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR [esi+eax*8], edi
	mov	ecx, DWORD PTR [ecx+edx*8+4]
	mov	DWORD PTR [esi+eax*8+4], ecx
	jmp	SHORT $LN2@Push
$LN1@Push:

; 212  : 
; 213  : 			head = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 214  : 
; 215  : 			tail = allocation_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+8], edx

; 216  : 
; 217  : 			allocation_size *= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 218  : 
; 219  : 			// Delete the old array and move the pointer to the new array
; 220  : 			delete [] array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T3[ebp], ecx
	mov	edx, DWORD PTR $T3[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 221  : 
; 222  : 			array = new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$5[ebp]
	mov	DWORD PTR [eax], ecx
$LN7@Push:

; 223  : 		}
; 224  : 
; 225  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Push@?$Queue@_J@DataStructures@@QAEXAB_J@Z ENDP	; DataStructures::Queue<__int64>::Push
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ??1?$Queue@_J@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
??1?$Queue@_J@DataStructures@@QAE@XZ PROC		; DataStructures::Queue<__int64>::~Queue<__int64>, COMDAT
; _this$ = ecx

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		if (allocation_size>0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jbe	SHORT $LN2@Queue

; 94   : 			delete [] array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@Queue:

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$Queue@_J@DataStructures@@QAE@XZ ENDP		; DataStructures::Queue<__int64>::~Queue<__int64>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ??0?$Queue@_J@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
??0?$Queue@_J@DataStructures@@QAE@XZ PROC		; DataStructures::Queue<__int64>::Queue<__int64>, COMDAT
; _this$ = ecx

; 83   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 84   : 		allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 16			; 00000010H

; 85   : 		array = new queue_type[ allocation_size ];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	edx, 8
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax], ecx

; 86   : 		head = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 87   : 		tail = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 88   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$Queue@_J@DataStructures@@QAE@XZ ENDP		; DataStructures::Queue<__int64>::Queue<__int64>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Clear@?$List@PAUSplitPacketChannel@@@DataStructures@@QAEX_N@Z
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
_doNotDeallocate$ = 8					; size = 1
?Clear@?$List@PAUSplitPacketChannel@@@DataStructures@@QAEX_N@Z PROC ; DataStructures::List<SplitPacketChannel *>::Clear, COMDAT
; _this$ = ecx

; 379  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  : 		if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Clear

; 381  : 			return;

	jmp	SHORT $LN3@Clear
$LN2@Clear:

; 382  : 
; 383  : 		if (allocation_size>512 && doNotDeallocate==false)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 512			; 00000200H
	jbe	SHORT $LN1@Clear
	movzx	eax, BYTE PTR _doNotDeallocate$[ebp]
	test	eax, eax
	jne	SHORT $LN1@Clear

; 384  : 		{
; 385  : 			delete [] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 386  : 			allocation_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 387  : 			listArray = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN1@Clear:

; 388  : 		}
; 389  : 		list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
$LN3@Clear:

; 390  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Clear@?$List@PAUSplitPacketChannel@@@DataStructures@@QAEX_N@Z ENDP ; DataStructures::List<SplitPacketChannel *>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Size@?$List@PAUSplitPacketChannel@@@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$List@PAUSplitPacketChannel@@@DataStructures@@QBEIXZ PROC ; DataStructures::List<SplitPacketChannel *>::Size, COMDAT
; _this$ = ecx

; 373  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 374  : 		return list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 375  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$List@PAUSplitPacketChannel@@@DataStructures@@QBEIXZ ENDP ; DataStructures::List<SplitPacketChannel *>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Del@?$List@PAUSplitPacketChannel@@@DataStructures@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_num$ = 8						; size = 4
?Del@?$List@PAUSplitPacketChannel@@@DataStructures@@QAEXI@Z PROC ; DataStructures::List<SplitPacketChannel *>::Del, COMDAT
; _this$ = ecx

; 353  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 354  : 		// Delete the last elements on the list.  No compression needed
; 355  : #ifdef _DEBUG
; 356  : 		assert(list_size>=num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _num$[ebp]
	jae	SHORT $LN3@Del
	push	356					; 00000164H
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1BO@JBFMBKMD@?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$DO?$AA?$DN?$AAn?$AAu?$AAm?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@Del:

; 357  : #endif
; 358  : 		list_size-=num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _num$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 359  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Del@?$List@PAUSplitPacketChannel@@@DataStructures@@QAEXI@Z ENDP ; DataStructures::List<SplitPacketChannel *>::Del
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?RemoveAtIndex@?$List@PAUSplitPacketChannel@@@DataStructures@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
?RemoveAtIndex@?$List@PAUSplitPacketChannel@@@DataStructures@@QAEXI@Z PROC ; DataStructures::List<SplitPacketChannel *>::RemoveAtIndex, COMDAT
; _this$ = ecx

; 333  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 334  : #ifdef _DEBUG
; 335  : 		assert( position < list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN4@RemoveAtIn
	push	335					; 0000014fH
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@RemoveAtIn:

; 336  : #endif
; 337  : 
; 338  : 		if ( position < list_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN2@RemoveAtIn

; 339  : 		{
; 340  : 			// Compress the array
; 341  : 			/*
; 342  : 			for ( unsigned int counter = position; counter < list_size - 1 ; ++counter )
; 343  : 			listArray[ counter ] = listArray[ counter + 1 ];
; 344  : 			*/
; 345  : 			memmove(listArray+position, listArray+position+1, (list_size-1-position) * sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	sub	ecx, DWORD PTR _position$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _position$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _position$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 346  : 
; 347  : 			Del();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Del@?$List@PAUSplitPacketChannel@@@DataStructures@@QAEXI@Z ; DataStructures::List<SplitPacketChannel *>::Del
$LN2@RemoveAtIn:

; 348  : 		}
; 349  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveAtIndex@?$List@PAUSplitPacketChannel@@@DataStructures@@QAEXI@Z ENDP ; DataStructures::List<SplitPacketChannel *>::RemoveAtIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Insert@?$List@PAUSplitPacketChannel@@@DataStructures@@QAEXQAUSplitPacketChannel@@@Z
_TEXT	SEGMENT
$T1 = -236						; size = 4
$T2 = -224						; size = 4
_new_array$3 = -20					; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
?Insert@?$List@PAUSplitPacketChannel@@@DataStructures@@QAEXQAUSplitPacketChannel@@@Z PROC ; DataStructures::List<SplitPacketChannel *>::Insert, COMDAT
; _this$ = ecx

; 242  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 243  : 		// Reallocate list if necessary
; 244  : 
; 245  : 		if ( list_size == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	$LN3@Insert

; 246  : 		{
; 247  : 			// allocate twice the currently allocated memory
; 248  : 			list_type * new_array;
; 249  : 
; 250  : 			if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Insert

; 251  : 				allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 16			; 00000010H

; 252  : 			else

	jmp	SHORT $LN1@Insert
$LN2@Insert:

; 253  : 				allocation_size *= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN1@Insert:

; 254  : 
; 255  : 			new_array = new list_type [ allocation_size ];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _new_array$3[ebp], eax

; 256  : 
; 257  : 			// copy old array over
; 258  : 			//	for ( unsigned int counter = 0; counter < list_size; ++counter )
; 259  : 			//		new_array[ counter ] = listArray[ counter ];
; 260  : 
; 261  : 			// Don't call constructors, assignment operators, etc.
; 262  : 			memcpy(new_array, listArray, list_size*sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _new_array$3[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 263  : 
; 264  : 			// set old array to point to the newly allocated and twice as large array
; 265  : 			delete[] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 266  : 
; 267  : 			listArray = new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$3[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Insert:

; 268  : 		}
; 269  : 
; 270  : 		// Insert the new item at the correct spot
; 271  : 		listArray[ list_size ] = input;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _input$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 272  : 
; 273  : 		++list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 274  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Insert@?$List@PAUSplitPacketChannel@@@DataStructures@@QAEXQAUSplitPacketChannel@@@Z ENDP ; DataStructures::List<SplitPacketChannel *>::Insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Insert@?$List@PAUSplitPacketChannel@@@DataStructures@@QAEXQAUSplitPacketChannel@@I@Z
_TEXT	SEGMENT
$T1 = -236						; size = 4
$T2 = -224						; size = 4
_new_array$3 = -20					; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
_position$ = 12						; size = 4
?Insert@?$List@PAUSplitPacketChannel@@@DataStructures@@QAEXQAUSplitPacketChannel@@I@Z PROC ; DataStructures::List<SplitPacketChannel *>::Insert, COMDAT
; _this$ = ecx

; 194  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 195  : #ifdef _DEBUG
; 196  : 		assert( position <= list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jbe	SHORT $LN6@Insert
	push	196					; 000000c4H
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CM@FMCFHBCK@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN6@Insert:

; 197  : #endif
; 198  : 
; 199  : 		// Reallocate list if necessary
; 200  : 		if ( list_size == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	$LN3@Insert

; 201  : 		{
; 202  : 			// allocate twice the currently allocated memory
; 203  : 			list_type * new_array;
; 204  : 
; 205  : 			if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Insert

; 206  : 				allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 16			; 00000010H

; 207  : 			else

	jmp	SHORT $LN1@Insert
$LN2@Insert:

; 208  : 				allocation_size *= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN1@Insert:

; 209  : 
; 210  : 			new_array = new list_type [ allocation_size ];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _new_array$3[ebp], eax

; 211  : 
; 212  : 			// copy old array over
; 213  : 			//for ( unsigned int counter = 0; counter < list_size; ++counter )
; 214  : 			//	new_array[ counter ] = listArray[ counter ];
; 215  : 
; 216  : 			// Don't call constructors, assignment operators, etc.
; 217  : 			memcpy(new_array, listArray, list_size*sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _new_array$3[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 218  : 
; 219  : 			// set old array to point to the newly allocated and twice as large array
; 220  : 			delete[] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 221  : 
; 222  : 			listArray = new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$3[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Insert:

; 223  : 		}
; 224  : 
; 225  : 		// Move the elements in the list to make room
; 226  : 		//for ( unsigned int counter = list_size; counter != position; counter-- )
; 227  : 		//	listArray[ counter ] = listArray[ counter - 1 ];
; 228  : 
; 229  : 		// Don't call constructors, assignment operators, etc.
; 230  : 		memmove(listArray+position+1, listArray+position, (list_size-position)*sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _position$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _position$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _position$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4+4]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 231  : 
; 232  : 		// Insert the new item at the correct spot
; 233  : 		listArray[ position ] = input;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _position$[ebp]
	mov	eax, DWORD PTR _input$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 234  : 
; 235  : 		++list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 236  : 
; 237  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?Insert@?$List@PAUSplitPacketChannel@@@DataStructures@@QAEXQAUSplitPacketChannel@@I@Z ENDP ; DataStructures::List<SplitPacketChannel *>::Insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??A?$List@PAUSplitPacketChannel@@@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
??A?$List@PAUSplitPacketChannel@@@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z PROC ; DataStructures::List<SplitPacketChannel *>::operator[], COMDAT
; _this$ = ecx

; 185  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 186  : #ifdef _DEBUG
; 187  : 		assert ( position < list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN3@operator
	push	187					; 000000bbH
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@operator:

; 188  : #endif
; 189  : 		return listArray[ position ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _position$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 190  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@PAUSplitPacketChannel@@@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ENDP ; DataStructures::List<SplitPacketChannel *>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??1?$List@PAUSplitPacketChannel@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
??1?$List@PAUSplitPacketChannel@@@DataStructures@@QAE@XZ PROC ; DataStructures::List<SplitPacketChannel *>::~List<SplitPacketChannel *>, COMDAT
; _this$ = ecx

; 121  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 122  : 		if (allocation_size>0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jbe	SHORT $LN2@List

; 123  : 			delete [] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@List:

; 124  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@PAUSplitPacketChannel@@@DataStructures@@QAE@XZ ENDP ; DataStructures::List<SplitPacketChannel *>::~List<SplitPacketChannel *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??0?$List@PAUSplitPacketChannel@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$List@PAUSplitPacketChannel@@@DataStructures@@QAE@XZ PROC ; DataStructures::List<SplitPacketChannel *>::List<SplitPacketChannel *>, COMDAT
; _this$ = ecx

; 113  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 114  : 		allocation_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 115  : 		listArray = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 116  : 		list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 117  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@PAUSplitPacketChannel@@@DataStructures@@QAE@XZ ENDP ; DataStructures::List<SplitPacketChannel *>::List<SplitPacketChannel *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?Size@?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEIXZ PROC ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::Size, COMDAT
; _this$ = ecx

; 231  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 232  : 		return orderedList.Size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@PAUSplitPacketChannel@@@DataStructures@@QBEIXZ ; DataStructures::List<SplitPacketChannel *>::Size

; 233  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEIXZ ENDP ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?Clear@?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Clear@?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QAEXXZ PROC ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::Clear, COMDAT
; _this$ = ecx

; 219  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 220  : 		orderedList.Clear();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@PAUSplitPacketChannel@@@DataStructures@@QAEX_N@Z ; DataStructures::List<SplitPacketChannel *>::Clear

; 221  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QAEXXZ ENDP ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?RemoveAtIndex@?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_index$ = 8						; size = 4
?RemoveAtIndex@?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QAEXI@Z PROC ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::RemoveAtIndex, COMDAT
; _this$ = ecx

; 195  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 196  : 		orderedList.RemoveAtIndex(index);

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAtIndex@?$List@PAUSplitPacketChannel@@@DataStructures@@QAEXI@Z ; DataStructures::List<SplitPacketChannel *>::RemoveAtIndex

; 197  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveAtIndex@?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QAEXI@Z ENDP ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::RemoveAtIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ??A?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
??A?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z PROC ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::operator[], COMDAT
; _this$ = ecx

; 225  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 226  : 		return orderedList[position];

	mov	eax, DWORD PTR _position$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@PAUSplitPacketChannel@@@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ; DataStructures::List<SplitPacketChannel *>::operator[]

; 227  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ENDP ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?Insert@?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QAEIABGABQAUSplitPacketChannel@@@Z
_TEXT	SEGMENT
_index$ = -32						; size = 4
_objectExists$ = -17					; size = 1
_this$ = -8						; size = 4
_key$ = 8						; size = 4
_data$ = 12						; size = 4
?Insert@?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QAEIABGABQAUSplitPacketChannel@@@Z PROC ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::Insert, COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		bool objectExists;
; 158  : 		unsigned index;
; 159  : 		index = GetIndexFromKey(key, &objectExists);

	lea	eax, DWORD PTR _objectExists$[ebp]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexFromKey@?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEIABGPA_N@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::GetIndexFromKey
	mov	DWORD PTR _index$[ebp], eax

; 160  : 
; 161  : 		// Don't allow duplicate insertion.
; 162  : 		if (objectExists)

	movzx	eax, BYTE PTR _objectExists$[ebp]
	test	eax, eax
	je	SHORT $LN3@Insert

; 163  : 			return (unsigned)-1;

	or	eax, -1
	jmp	SHORT $LN4@Insert
$LN3@Insert:

; 164  : 
; 165  : 		if (index>=orderedList.Size())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@PAUSplitPacketChannel@@@DataStructures@@QBEIXZ ; DataStructures::List<SplitPacketChannel *>::Size
	cmp	DWORD PTR _index$[ebp], eax
	jb	SHORT $LN2@Insert

; 166  : 		{
; 167  : 			orderedList.Insert(data);

	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Insert@?$List@PAUSplitPacketChannel@@@DataStructures@@QAEXQAUSplitPacketChannel@@@Z ; DataStructures::List<SplitPacketChannel *>::Insert

; 168  : 			return orderedList.Size()-1;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@PAUSplitPacketChannel@@@DataStructures@@QBEIXZ ; DataStructures::List<SplitPacketChannel *>::Size
	sub	eax, 1
	jmp	SHORT $LN4@Insert

; 169  : 		}
; 170  : 		else

	jmp	SHORT $LN4@Insert
$LN2@Insert:

; 171  : 		{
; 172  : 			orderedList.Insert(data,index);

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Insert@?$List@PAUSplitPacketChannel@@@DataStructures@@QAEXQAUSplitPacketChannel@@I@Z ; DataStructures::List<SplitPacketChannel *>::Insert

; 173  : 			return index;

	mov	eax, DWORD PTR _index$[ebp]
$LN4@Insert:

; 174  : 		}		
; 175  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@Insert
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN8@Insert:
	DD	1
	DD	$LN7@Insert
$LN7@Insert:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN6@Insert
$LN6@Insert:
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
?Insert@?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QAEIABGABQAUSplitPacketChannel@@@Z ENDP ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::Insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?GetIndexFromKey@?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEIABGPA_N@Z
_TEXT	SEGMENT
_res$ = -56						; size = 4
_lowerBound$ = -44					; size = 4
_upperBound$ = -32					; size = 4
_index$ = -20						; size = 4
_this$ = -8						; size = 4
_key$ = 8						; size = 4
_objectExists$ = 12					; size = 4
?GetIndexFromKey@?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEIABGPA_N@Z PROC ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::GetIndexFromKey, COMDAT
; _this$ = ecx

; 110  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 111  : 		int index, upperBound, lowerBound;
; 112  : 		int res;
; 113  : 
; 114  : 		if (orderedList.Size()==0)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@PAUSplitPacketChannel@@@DataStructures@@QBEIXZ ; DataStructures::List<SplitPacketChannel *>::Size
	test	eax, eax
	jne	SHORT $LN8@GetIndexFr

; 115  : 		{
; 116  : 			*objectExists=false;

	mov	eax, DWORD PTR _objectExists$[ebp]
	mov	BYTE PTR [eax], 0

; 117  : 			return 0;

	xor	eax, eax
	jmp	$LN9@GetIndexFr
$LN8@GetIndexFr:

; 118  : 		}
; 119  : 
; 120  : 		upperBound=(int)orderedList.Size()-1;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@PAUSplitPacketChannel@@@DataStructures@@QBEIXZ ; DataStructures::List<SplitPacketChannel *>::Size
	sub	eax, 1
	mov	DWORD PTR _upperBound$[ebp], eax

; 121  : 		lowerBound=0;

	mov	DWORD PTR _lowerBound$[ebp], 0

; 122  : 		index = (int)orderedList.Size()/2;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@PAUSplitPacketChannel@@@DataStructures@@QBEIXZ ; DataStructures::List<SplitPacketChannel *>::Size
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _index$[ebp], eax
$LN7@GetIndexFr:

; 123  : 
; 124  : #ifdef _MSC_VER
; 125  : 	#pragma warning( disable : 4127 ) // warning C4127: conditional expression is constant
; 126  : #endif
; 127  : 		while (1)

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN9@GetIndexFr

; 128  : 		{
; 129  : 			res = comparison_function(key,orderedList[index]);

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@PAUSplitPacketChannel@@@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ; DataStructures::List<SplitPacketChannel *>::operator[]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	call	?SplitPacketChannelComp@@YAHABGABQAUSplitPacketChannel@@@Z ; SplitPacketChannelComp
	add	esp, 8
	mov	DWORD PTR _res$[ebp], eax

; 130  : 			if (res==0)

	cmp	DWORD PTR _res$[ebp], 0
	jne	SHORT $LN5@GetIndexFr

; 131  : 			{
; 132  : 				*objectExists=true;

	mov	eax, DWORD PTR _objectExists$[ebp]
	mov	BYTE PTR [eax], 1

; 133  : 				return index;

	mov	eax, DWORD PTR _index$[ebp]
	jmp	SHORT $LN9@GetIndexFr
	jmp	SHORT $LN4@GetIndexFr
$LN5@GetIndexFr:

; 134  : 			}
; 135  : 			else if (res<0)

	cmp	DWORD PTR _res$[ebp], 0
	jge	SHORT $LN3@GetIndexFr

; 136  : 			{
; 137  : 				upperBound=index-1;

	mov	eax, DWORD PTR _index$[ebp]
	sub	eax, 1
	mov	DWORD PTR _upperBound$[ebp], eax

; 138  : 			}
; 139  : 			else// if (res>0)

	jmp	SHORT $LN4@GetIndexFr
$LN3@GetIndexFr:

; 140  : 			{
; 141  : 				lowerBound=index+1;

	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 1
	mov	DWORD PTR _lowerBound$[ebp], eax
$LN4@GetIndexFr:

; 142  : 			}
; 143  : 
; 144  : 			index=lowerBound+(upperBound-lowerBound)/2;

	mov	eax, DWORD PTR _upperBound$[ebp]
	sub	eax, DWORD PTR _lowerBound$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _lowerBound$[ebp]
	mov	DWORD PTR _index$[ebp], eax

; 145  : 
; 146  : 			if (lowerBound>upperBound)

	mov	eax, DWORD PTR _lowerBound$[ebp]
	cmp	eax, DWORD PTR _upperBound$[ebp]
	jle	SHORT $LN1@GetIndexFr

; 147  : 			{
; 148  : 				*objectExists=false;

	mov	eax, DWORD PTR _objectExists$[ebp]
	mov	BYTE PTR [eax], 0

; 149  : 				return lowerBound; // No match

	mov	eax, DWORD PTR _lowerBound$[ebp]
	jmp	SHORT $LN9@GetIndexFr
$LN1@GetIndexFr:

; 150  : 			}
; 151  : 		}

	jmp	SHORT $LN7@GetIndexFr
$LN9@GetIndexFr:

; 152  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?GetIndexFromKey@?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEIABGPA_N@Z ENDP ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::GetIndexFromKey
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ??1?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QAE@XZ PROC ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::~OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>, COMDAT
; _this$ = ecx

; 72   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 73   : 		Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QAEXXZ ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::Clear

; 74   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$List@PAUSplitPacketChannel@@@DataStructures@@QAE@XZ ; DataStructures::List<SplitPacketChannel *>::~List<SplitPacketChannel *>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$List@PAUSplitPacketChannel@@@DataStructures@@QAE@XZ ; DataStructures::List<SplitPacketChannel *>::~List<SplitPacketChannel *>
__ehhandler$??1?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QAE@XZ ENDP ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::~OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ??0?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QAE@XZ PROC ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>, COMDAT
; _this$ = ecx

; 67   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$List@PAUSplitPacketChannel@@@DataStructures@@QAE@XZ ; DataStructures::List<SplitPacketChannel *>::List<SplitPacketChannel *>

; 68   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QAE@XZ ENDP ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Size@?$List@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$List@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QBEIXZ PROC ; DataStructures::List<DataStructures::Page<unsigned short,InternalPacket *,32> *>::Size, COMDAT
; _this$ = ecx

; 373  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 374  : 		return list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 375  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$List@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QBEIXZ ENDP ; DataStructures::List<DataStructures::Page<unsigned short,InternalPacket *,32> *>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Del@?$List@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_num$ = 8						; size = 4
?Del@?$List@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEXI@Z PROC ; DataStructures::List<DataStructures::Page<unsigned short,InternalPacket *,32> *>::Del, COMDAT
; _this$ = ecx

; 353  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 354  : 		// Delete the last elements on the list.  No compression needed
; 355  : #ifdef _DEBUG
; 356  : 		assert(list_size>=num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _num$[ebp]
	jae	SHORT $LN3@Del
	push	356					; 00000164H
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1BO@JBFMBKMD@?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$DO?$AA?$DN?$AAn?$AAu?$AAm?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@Del:

; 357  : #endif
; 358  : 		list_size-=num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _num$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 359  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Del@?$List@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEXI@Z ENDP ; DataStructures::List<DataStructures::Page<unsigned short,InternalPacket *,32> *>::Del
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Insert@?$List@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEXQAU?$Page@GPAUInternalPacket@@$0CA@@2@@Z
_TEXT	SEGMENT
$T1 = -236						; size = 4
$T2 = -224						; size = 4
_new_array$3 = -20					; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
?Insert@?$List@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEXQAU?$Page@GPAUInternalPacket@@$0CA@@2@@Z PROC ; DataStructures::List<DataStructures::Page<unsigned short,InternalPacket *,32> *>::Insert, COMDAT
; _this$ = ecx

; 242  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 243  : 		// Reallocate list if necessary
; 244  : 
; 245  : 		if ( list_size == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	$LN3@Insert

; 246  : 		{
; 247  : 			// allocate twice the currently allocated memory
; 248  : 			list_type * new_array;
; 249  : 
; 250  : 			if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Insert

; 251  : 				allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 16			; 00000010H

; 252  : 			else

	jmp	SHORT $LN1@Insert
$LN2@Insert:

; 253  : 				allocation_size *= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN1@Insert:

; 254  : 
; 255  : 			new_array = new list_type [ allocation_size ];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _new_array$3[ebp], eax

; 256  : 
; 257  : 			// copy old array over
; 258  : 			//	for ( unsigned int counter = 0; counter < list_size; ++counter )
; 259  : 			//		new_array[ counter ] = listArray[ counter ];
; 260  : 
; 261  : 			// Don't call constructors, assignment operators, etc.
; 262  : 			memcpy(new_array, listArray, list_size*sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _new_array$3[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 263  : 
; 264  : 			// set old array to point to the newly allocated and twice as large array
; 265  : 			delete[] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 266  : 
; 267  : 			listArray = new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$3[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Insert:

; 268  : 		}
; 269  : 
; 270  : 		// Insert the new item at the correct spot
; 271  : 		listArray[ list_size ] = input;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _input$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 272  : 
; 273  : 		++list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 274  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Insert@?$List@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEXQAU?$Page@GPAUInternalPacket@@$0CA@@2@@Z ENDP ; DataStructures::List<DataStructures::Page<unsigned short,InternalPacket *,32> *>::Insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??A?$List@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QBEAAPAU?$Page@GPAUInternalPacket@@$0CA@@1@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
??A?$List@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QBEAAPAU?$Page@GPAUInternalPacket@@$0CA@@1@I@Z PROC ; DataStructures::List<DataStructures::Page<unsigned short,InternalPacket *,32> *>::operator[], COMDAT
; _this$ = ecx

; 185  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 186  : #ifdef _DEBUG
; 187  : 		assert ( position < list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN3@operator
	push	187					; 000000bbH
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@operator:

; 188  : #endif
; 189  : 		return listArray[ position ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _position$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 190  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QBEAAPAU?$Page@GPAUInternalPacket@@$0CA@@1@I@Z ENDP ; DataStructures::List<DataStructures::Page<unsigned short,InternalPacket *,32> *>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??1?$List@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
??1?$List@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAE@XZ PROC ; DataStructures::List<DataStructures::Page<unsigned short,InternalPacket *,32> *>::~List<DataStructures::Page<unsigned short,InternalPacket *,32> *>, COMDAT
; _this$ = ecx

; 121  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 122  : 		if (allocation_size>0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jbe	SHORT $LN2@List

; 123  : 			delete [] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@List:

; 124  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAE@XZ ENDP ; DataStructures::List<DataStructures::Page<unsigned short,InternalPacket *,32> *>::~List<DataStructures::Page<unsigned short,InternalPacket *,32> *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??0?$List@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$List@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAE@XZ PROC ; DataStructures::List<DataStructures::Page<unsigned short,InternalPacket *,32> *>::List<DataStructures::Page<unsigned short,InternalPacket *,32> *>, COMDAT
; _this$ = ecx

; 113  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 114  : 		allocation_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 115  : 		listArray = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 116  : 		list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 117  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAE@XZ ENDP ; DataStructures::List<DataStructures::Page<unsigned short,InternalPacket *,32> *>::List<DataStructures::Page<unsigned short,InternalPacket *,32> *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_memorypool.h
;	COMDAT ?Release@?$MemoryPool@U?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEXPAU?$Page@GPAUInternalPacket@@$0CA@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_m$ = 8							; size = 4
?Release@?$MemoryPool@U?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEXPAU?$Page@GPAUInternalPacket@@$0CA@@2@@Z PROC ; DataStructures::MemoryPool<DataStructures::Page<unsigned short,InternalPacket *,32> >::Release, COMDAT
; _this$ = ecx

; 70   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 71   : 		pool.Insert(m);

	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Insert@?$List@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEXQAU?$Page@GPAUInternalPacket@@$0CA@@2@@Z ; DataStructures::List<DataStructures::Page<unsigned short,InternalPacket *,32> *>::Insert

; 72   : #ifdef _DEBUG
; 73   : 		assert(blocksOut>0);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jg	SHORT $LN3@Release
	push	73					; 00000049H
	push	OFFSET ??_C@_1FA@EECGGCBA@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAm?$AAe?$AAm?$AAo?$AAr@
	push	OFFSET ??_C@_1BI@OFKIDLPK@?$AAb?$AAl?$AAo?$AAc?$AAk?$AAs?$AAO?$AAu?$AAt?$AA?$DO?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@Release:

; 74   : 		blocksOut--;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 75   : #endif
; 76   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Release@?$MemoryPool@U?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEXPAU?$Page@GPAUInternalPacket@@$0CA@@2@@Z ENDP ; DataStructures::MemoryPool<DataStructures::Page<unsigned short,InternalPacket *,32> >::Release
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_memorypool.h
;	COMDAT ?Allocate@?$MemoryPool@U?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEPAU?$Page@GPAUInternalPacket@@$0CA@@2@XZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_out$2 = -20						; size = 4
_this$ = -8						; size = 4
?Allocate@?$MemoryPool@U?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEPAU?$Page@GPAUInternalPacket@@$0CA@@2@XZ PROC ; DataStructures::MemoryPool<DataStructures::Page<unsigned short,InternalPacket *,32> >::Allocate, COMDAT
; _this$ = ecx

; 54   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 55   : #ifdef _DEBUG
; 56   : 		blocksOut++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 57   : #endif
; 58   : 		if (pool.Size()==0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Size@?$List@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Page<unsigned short,InternalPacket *,32> *>::Size
	test	eax, eax
	jne	SHORT $LN2@Allocate

; 59   : 			return new MemoryBlockType;

	push	337					; 00000151H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	jmp	SHORT $LN3@Allocate

; 60   : 		else

	jmp	SHORT $LN3@Allocate
$LN2@Allocate:

; 61   : 		{
; 62   : 			MemoryBlockType* out;
; 63   : 			out=pool[pool.Size()-1];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Size@?$List@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Page<unsigned short,InternalPacket *,32> *>::Size
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$List@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QBEAAPAU?$Page@GPAUInternalPacket@@$0CA@@1@I@Z ; DataStructures::List<DataStructures::Page<unsigned short,InternalPacket *,32> *>::operator[]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _out$2[ebp], eax

; 64   : 			pool.Del();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Del@?$List@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEXI@Z ; DataStructures::List<DataStructures::Page<unsigned short,InternalPacket *,32> *>::Del

; 65   : 			return out;

	mov	eax, DWORD PTR _out$2[ebp]
$LN3@Allocate:

; 66   : 		}
; 67   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Allocate@?$MemoryPool@U?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEPAU?$Page@GPAUInternalPacket@@$0CA@@2@XZ ENDP ; DataStructures::MemoryPool<DataStructures::Page<unsigned short,InternalPacket *,32> >::Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_memorypool.h
;	COMDAT ?Preallocate@?$MemoryPool@U?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEXI@Z
_TEXT	SEGMENT
$T1 = -224						; size = 4
_i$ = -20						; size = 4
_this$ = -8						; size = 4
_numElements$ = 8					; size = 4
?Preallocate@?$MemoryPool@U?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEXI@Z PROC ; DataStructures::MemoryPool<DataStructures::Page<unsigned short,InternalPacket *,32> >::Preallocate, COMDAT
; _this$ = ecx

; 44   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 45   : 		unsigned i;
; 46   : 		for (i=pool.Size(); i < numElements; i++)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Size@?$List@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Page<unsigned short,InternalPacket *,32> *>::Size
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN3@Preallocat
$LN2@Preallocat:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@Preallocat:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numElements$[ebp]
	jae	SHORT $LN4@Preallocat

; 47   : 		{
; 48   : 			pool.Insert(new MemoryBlockType);

	push	337					; 00000151H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Insert@?$List@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEXQAU?$Page@GPAUInternalPacket@@$0CA@@2@@Z ; DataStructures::List<DataStructures::Page<unsigned short,InternalPacket *,32> *>::Insert

; 49   : 		}

	jmp	SHORT $LN2@Preallocat
$LN4@Preallocat:

; 50   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Preallocate@?$MemoryPool@U?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEXI@Z ENDP ; DataStructures::MemoryPool<DataStructures::Page<unsigned short,InternalPacket *,32> >::Preallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_memorypool.h
;	COMDAT ??1?$MemoryPool@U?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T2 = -236						; size = 4
_i$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$MemoryPool@U?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAE@XZ PROC ; DataStructures::MemoryPool<DataStructures::Page<unsigned short,InternalPacket *,32> >::~MemoryPool<DataStructures::Page<unsigned short,InternalPacket *,32> >, COMDAT
; _this$ = ecx

; 33   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$MemoryPool@U?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 34   : #ifdef _DEBUG
; 35   : 		assert(blocksOut==0);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN6@MemoryPool
	push	35					; 00000023H
	push	OFFSET ??_C@_1FA@EECGGCBA@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAm?$AAe?$AAm?$AAo?$AAr@
	push	OFFSET ??_C@_1BK@JNGCOJCH@?$AAb?$AAl?$AAo?$AAc?$AAk?$AAs?$AAO?$AAu?$AAt?$AA?$DN?$AA?$DN?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN6@MemoryPool:

; 36   : #endif
; 37   : 		unsigned i;
; 38   : 		for (i=0; i < pool.Size(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@MemoryPool
$LN2@MemoryPool:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@MemoryPool:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Size@?$List@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Page<unsigned short,InternalPacket *,32> *>::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN4@MemoryPool

; 39   : 			delete pool[i];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$List@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QBEAAPAU?$Page@GPAUInternalPacket@@$0CA@@1@I@Z ; DataStructures::List<DataStructures::Page<unsigned short,InternalPacket *,32> *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	jmp	SHORT $LN2@MemoryPool
$LN4@MemoryPool:

; 40   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1?$List@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::List<DataStructures::Page<unsigned short,InternalPacket *,32> *>::~List<DataStructures::Page<unsigned short,InternalPacket *,32> *>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$MemoryPool@U?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$List@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::List<DataStructures::Page<unsigned short,InternalPacket *,32> *>::~List<DataStructures::Page<unsigned short,InternalPacket *,32> *>
__ehhandler$??1?$MemoryPool@U?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-244]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$MemoryPool@U?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$MemoryPool@U?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAE@XZ ENDP ; DataStructures::MemoryPool<DataStructures::Page<unsigned short,InternalPacket *,32> >::~MemoryPool<DataStructures::Page<unsigned short,InternalPacket *,32> >
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_memorypool.h
;	COMDAT ??0?$MemoryPool@U?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$MemoryPool@U?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAE@XZ PROC ; DataStructures::MemoryPool<DataStructures::Page<unsigned short,InternalPacket *,32> >::MemoryPool<DataStructures::Page<unsigned short,InternalPacket *,32> >, COMDAT
; _this$ = ecx

; 26   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0?$List@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::List<DataStructures::Page<unsigned short,InternalPacket *,32> *>::List<DataStructures::Page<unsigned short,InternalPacket *,32> *>

; 27   : #ifdef _DEBUG
; 28   : 		blocksOut=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 29   : #endif
; 30   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$MemoryPool@U?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAE@XZ ENDP ; DataStructures::MemoryPool<DataStructures::Page<unsigned short,InternalPacket *,32> >::MemoryPool<DataStructures::Page<unsigned short,InternalPacket *,32> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?ShiftNodeRight@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEXPAU?$Page@GPAUInternalPacket@@$0CA@@2@@Z
_TEXT	SEGMENT
_i$ = -20						; size = 4
_this$ = -8						; size = 4
_cur$ = 8						; size = 4
?ShiftNodeRight@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEXPAU?$Page@GPAUInternalPacket@@$0CA@@2@@Z PROC ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::ShiftNodeRight, COMDAT
; _this$ = ecx

; 459  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 460  : 		int i;
; 461  : 		for (i=cur->size; i>0; i--)

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN11@ShiftNodeR
$LN10@ShiftNodeR:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN11@ShiftNodeR:
	cmp	DWORD PTR _i$[ebp], 0
	jle	SHORT $LN9@ShiftNodeR

; 462  : 			cur->keys[i]=cur->keys[i-1];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	dx, WORD PTR [esi+edx*2+3]
	mov	WORD PTR [ecx+eax*2+5], dx
	jmp	SHORT $LN10@ShiftNodeR
$LN9@ShiftNodeR:

; 463  : 		if (cur->isLeaf)

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN8@ShiftNodeR

; 464  : 		{
; 465  : 			for (i=cur->size; i>0; i--)

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN7@ShiftNodeR
$LN6@ShiftNodeR:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@ShiftNodeR:
	cmp	DWORD PTR _i$[ebp], 0
	jle	SHORT $LN5@ShiftNodeR

; 466  : 				cur->data[i]=cur->data[i-1];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+65]
	mov	DWORD PTR [ecx+eax*4+69], edx
	jmp	SHORT $LN6@ShiftNodeR
$LN5@ShiftNodeR:

; 467  : 		}
; 468  : 		else

	jmp	SHORT $LN4@ShiftNodeR
$LN8@ShiftNodeR:

; 469  : 		{
; 470  : 			for (i=cur->size+1; i>0; i--)

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN3@ShiftNodeR
$LN2@ShiftNodeR:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@ShiftNodeR:
	cmp	DWORD PTR _i$[ebp], 0
	jle	SHORT $LN4@ShiftNodeR

; 471  : 				cur->children[i]=cur->children[i-1];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+201]
	mov	DWORD PTR [ecx+eax*4+205], edx
	jmp	SHORT $LN2@ShiftNodeR
$LN4@ShiftNodeR:

; 472  : 		}
; 473  : 
; 474  : 		cur->size++;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	add	ecx, 1
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx+1], ecx

; 475  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ShiftNodeRight@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEXPAU?$Page@GPAUInternalPacket@@$0CA@@2@@Z ENDP ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::ShiftNodeRight
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?ShiftNodeLeft@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEXPAU?$Page@GPAUInternalPacket@@$0CA@@2@@Z
_TEXT	SEGMENT
_i$ = -20						; size = 4
_this$ = -8						; size = 4
_cur$ = 8						; size = 4
?ShiftNodeLeft@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEXPAU?$Page@GPAUInternalPacket@@$0CA@@2@@Z PROC ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::ShiftNodeLeft, COMDAT
; _this$ = ecx

; 478  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 479  : 		int i;
; 480  : 		for (i=0; i < cur->size-1; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN11@ShiftNodeL
$LN10@ShiftNodeL:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN11@ShiftNodeL:
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	sub	ecx, 1
	cmp	DWORD PTR _i$[ebp], ecx
	jge	SHORT $LN9@ShiftNodeL

; 481  : 			cur->keys[i]=cur->keys[i+1];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	dx, WORD PTR [esi+edx*2+7]
	mov	WORD PTR [ecx+eax*2+5], dx
	jmp	SHORT $LN10@ShiftNodeL
$LN9@ShiftNodeL:

; 482  : 		if (cur->isLeaf)

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN8@ShiftNodeL

; 483  : 		{
; 484  : 			for (i=0; i < cur->size; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@ShiftNodeL
$LN6@ShiftNodeL:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@ShiftNodeL:
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+1]
	jge	SHORT $LN5@ShiftNodeL

; 485  : 				cur->data[i]=cur->data[i+1];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+73]
	mov	DWORD PTR [ecx+eax*4+69], edx
	jmp	SHORT $LN6@ShiftNodeL
$LN5@ShiftNodeL:

; 486  : 		}
; 487  : 		else

	jmp	SHORT $LN4@ShiftNodeL
$LN8@ShiftNodeL:

; 488  : 		{
; 489  : 			for (i=0; i < cur->size; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@ShiftNodeL
$LN2@ShiftNodeL:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@ShiftNodeL:
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+1]
	jge	SHORT $LN4@ShiftNodeL

; 490  : 				cur->children[i]=cur->children[i+1];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+209]
	mov	DWORD PTR [ecx+eax*4+205], edx
	jmp	SHORT $LN2@ShiftNodeL
$LN4@ShiftNodeL:

; 491  : 		}
; 492  : 		cur->size--;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	sub	ecx, 1
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx+1], ecx

; 493  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ShiftNodeLeft@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEXPAU?$Page@GPAUInternalPacket@@$0CA@@2@@Z ENDP ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::ShiftNodeLeft
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?FixUnderflow@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAE_NHPAU?$Page@GPAUInternalPacket@@$0CA@@2@GPAUReturnAction@12@@Z
_TEXT	SEGMENT
tv375 = -244						; size = 4
_sourceIndex$1 = -44					; size = 4
_dest$ = -32						; size = 4
_source$ = -20						; size = 4
_this$ = -8						; size = 4
_branchIndex$ = 8					; size = 4
_cur$ = 12						; size = 4
_rightRootKey$ = 16					; size = 2
_returnAction$ = 20					; size = 4
?FixUnderflow@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAE_NHPAU?$Page@GPAUInternalPacket@@$0CA@@2@GPAUReturnAction@12@@Z PROC ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::FixUnderflow, COMDAT
; _this$ = ecx

; 279  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 280  : 		// Borrow from a neighbor that has excess.
; 281  : 		Page<KeyType, DataType, order> *source;
; 282  : 		Page<KeyType, DataType, order> *dest;
; 283  : 
; 284  : 		if (branchIndex>0 && cur->children[branchIndex-1]->size > order/2)

	cmp	DWORD PTR _branchIndex$[ebp], 0
	jle	$LN31@FixUnderfl
	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+201]
	cmp	DWORD PTR [edx+1], 16			; 00000010H
	jle	$LN31@FixUnderfl

; 285  : 		{
; 286  : 			dest=cur->children[branchIndex];

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+205]
	mov	DWORD PTR _dest$[ebp], edx

; 287  : 			source=cur->children[branchIndex-1];

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+201]
	mov	DWORD PTR _source$[ebp], edx

; 288  : 
; 289  : 			// Left has excess
; 290  : 			ShiftNodeRight(dest);

	mov	eax, DWORD PTR _dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShiftNodeRight@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEXPAU?$Page@GPAUInternalPacket@@$0CA@@2@@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::ShiftNodeRight

; 291  : 			if (dest->isLeaf)

	mov	eax, DWORD PTR _dest$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN30@FixUnderfl

; 292  : 			{
; 293  : 				dest->keys[0]=source->keys[source->size-1];

	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	mov	edx, 2
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dest$[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	cx, WORD PTR [esi+ecx*2+3]
	mov	WORD PTR [edx+eax+5], cx

; 294  : 				dest->data[0]=source->data[source->size-1];

	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dest$[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4+65]
	mov	DWORD PTR [edx+eax+69], ecx

; 295  : 			}
; 296  : 			else

	jmp	SHORT $LN29@FixUnderfl
$LN30@FixUnderfl:

; 297  : 			{
; 298  : 				dest->children[0]=source->children[source->size];

	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dest$[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4+205]
	mov	DWORD PTR [edx+eax+205], ecx

; 299  : 				dest->keys[0]=cur->keys[branchIndex-1];

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	ax, WORD PTR [esi+eax*2+3]
	mov	WORD PTR [edx+ecx+5], ax
$LN29@FixUnderfl:

; 300  : 			}
; 301  : 			// Update the parent key for the child (middle)
; 302  : 			cur->keys[branchIndex-1]=source->keys[source->size-1];

	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	mov	edx, DWORD PTR _branchIndex$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	cx, WORD PTR [esi+ecx*2+3]
	mov	WORD PTR [eax+edx*2+3], cx

; 303  : 			source->size--;

	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	sub	ecx, 1
	mov	edx, DWORD PTR _source$[ebp]
	mov	DWORD PTR [edx+1], ecx

; 304  : 
; 305  : 	//		if (branchIndex==0)
; 306  : 	//		{
; 307  : 	//			returnAction->action=ReturnAction::SET_BRANCH_KEY;
; 308  : 	//			returnAction->key1=dest->keys[0];
; 309  : 	//		}
; 310  : 
; 311  : 			// No underflow
; 312  : 			return false;

	xor	al, al
	jmp	$LN32@FixUnderfl
	jmp	$LN32@FixUnderfl
$LN31@FixUnderfl:

; 313  : 		}
; 314  : 		else if (branchIndex<cur->size && cur->children[branchIndex+1]->size > order/2)

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _branchIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+1]
	jge	$LN27@FixUnderfl
	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+209]
	cmp	DWORD PTR [edx+1], 16			; 00000010H
	jle	$LN27@FixUnderfl

; 315  : 		{
; 316  : 			dest=cur->children[branchIndex];

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+205]
	mov	DWORD PTR _dest$[ebp], edx

; 317  : 			source=cur->children[branchIndex+1];

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+209]
	mov	DWORD PTR _source$[ebp], edx

; 318  : 
; 319  : 			// Right has excess
; 320  : 			if (dest->isLeaf)

	mov	eax, DWORD PTR _dest$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN26@FixUnderfl

; 321  : 			{
; 322  : 				dest->keys[dest->size]=source->keys[0];

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR [edx+1]
	mov	edx, DWORD PTR _dest$[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	cx, WORD PTR [esi+ecx+5]
	mov	WORD PTR [edx+eax*2+5], cx

; 323  : 				dest->data[dest->size]=source->data[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR [edx+1]
	mov	edx, DWORD PTR _dest$[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+69]
	mov	DWORD PTR [edx+eax*4+69], ecx

; 324  : 
; 325  : 				// The first key in the leaf after shifting is the parent key for the right branch
; 326  : 				cur->keys[branchIndex]=source->keys[1];

	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _branchIndex$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	ax, WORD PTR [esi+eax+5]
	mov	WORD PTR [edx+ecx*2+5], ax

; 327  : 
; 328  : #ifdef _MSC_VER
; 329  : #pragma warning( disable : 4127 ) // warning C4127: conditional expression is constant
; 330  : #endif
; 331  : 				if (order<=3 && dest->size==0)

	xor	eax, eax
	je	SHORT $LN25@FixUnderfl

; 332  : 				{
; 333  : 					if (branchIndex==0)

	cmp	DWORD PTR _branchIndex$[ebp], 0
	jne	SHORT $LN24@FixUnderfl

; 334  : 					{
; 335  : 						returnAction->action=ReturnAction::SET_BRANCH_KEY;

	mov	eax, DWORD PTR _returnAction$[ebp]
	mov	DWORD PTR [eax+4], 3

; 336  : 						returnAction->key1=dest->keys[0];

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _returnAction$[ebp]
	mov	eax, DWORD PTR _dest$[ebp]
	mov	cx, WORD PTR [eax+ecx+5]
	mov	WORD PTR [edx], cx

; 337  : 					}
; 338  : 					else

	jmp	SHORT $LN25@FixUnderfl
$LN24@FixUnderfl:

; 339  : 						cur->keys[branchIndex-1]=cur->children[branchIndex]->keys[0];

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+205]
	mov	eax, 2
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	cx, WORD PTR [edx+ecx+5]
	mov	WORD PTR [esi+eax*2+3], cx
$LN25@FixUnderfl:

; 340  : 				}
; 341  : 			}
; 342  : 			else

	jmp	SHORT $LN22@FixUnderfl
$LN26@FixUnderfl:

; 343  : 			{
; 344  : 				if (returnAction->action==ReturnAction::NO_ACTION)

	mov	eax, DWORD PTR _returnAction$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN21@FixUnderfl

; 345  : 				{
; 346  : 					returnAction->action=ReturnAction::SET_BRANCH_KEY;

	mov	eax, DWORD PTR _returnAction$[ebp]
	mov	DWORD PTR [eax+4], 3

; 347  : 					returnAction->key1=dest->keys[0];

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _returnAction$[ebp]
	mov	eax, DWORD PTR _dest$[ebp]
	mov	cx, WORD PTR [eax+ecx+5]
	mov	WORD PTR [edx], cx
$LN21@FixUnderfl:

; 348  : 				}
; 349  : 				
; 350  : 				dest->keys[dest->size]=rightRootKey;

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	mov	edx, DWORD PTR _dest$[ebp]
	mov	ax, WORD PTR _rightRootKey$[ebp]
	mov	WORD PTR [edx+ecx*2+5], ax

; 351  : 				dest->children[dest->size+1]=source->children[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR [edx+1]
	mov	edx, DWORD PTR _dest$[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+205]
	mov	DWORD PTR [edx+eax*4+209], ecx

; 352  : 
; 353  : 				// The shifted off key is the leftmost key for a node
; 354  : 				cur->keys[branchIndex]=source->keys[0];

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _branchIndex$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	cx, WORD PTR [esi+ecx+5]
	mov	WORD PTR [eax+edx*2+5], cx
$LN22@FixUnderfl:

; 355  : 			}
; 356  : 
; 357  : 
; 358  : 			dest->size++;

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	add	ecx, 1
	mov	edx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR [edx+1], ecx

; 359  : 			ShiftNodeLeft(source);

	mov	eax, DWORD PTR _source$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShiftNodeLeft@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEXPAU?$Page@GPAUInternalPacket@@$0CA@@2@@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::ShiftNodeLeft

; 360  : 
; 361  : 			//cur->keys[branchIndex]=source->keys[0];
; 362  : 
; 363  : //			returnAction->action=ReturnAction::SET_BRANCH_KEY;
; 364  : //			returnAction->key1=dest->keys[dest->size-1];
; 365  : 
; 366  : 			// No underflow
; 367  : 			return false;

	xor	al, al
	jmp	$LN32@FixUnderfl

; 368  : 		}
; 369  : 		else

	jmp	$LN32@FixUnderfl
$LN27@FixUnderfl:

; 370  : 		{
; 371  : 			int sourceIndex;
; 372  : 
; 373  : 			// If no neighbors have excess, merge two branches.
; 374  : 			//
; 375  : 			// To merge two leaves, just copy the data and keys over.
; 376  : 			//
; 377  : 			// To merge two branches, copy the pointers and keys over, using rightRootKey as the key for the extra pointer
; 378  : 			if (branchIndex<cur->size)

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _branchIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+1]
	jge	SHORT $LN19@FixUnderfl

; 379  : 			{
; 380  : 				// Merge right child to current child and delete right child.
; 381  : 				dest=cur->children[branchIndex];

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+205]
	mov	DWORD PTR _dest$[ebp], edx

; 382  : 				source=cur->children[branchIndex+1];

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+209]
	mov	DWORD PTR _source$[ebp], edx

; 383  : 			}
; 384  : 			else

	jmp	SHORT $LN18@FixUnderfl
$LN19@FixUnderfl:

; 385  : 			{
; 386  : 				// Move current child to left and delete current child
; 387  : 				dest=cur->children[branchIndex-1];

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+201]
	mov	DWORD PTR _dest$[ebp], edx

; 388  : 				source=cur->children[branchIndex];

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+205]
	mov	DWORD PTR _source$[ebp], edx
$LN18@FixUnderfl:

; 389  : 			}
; 390  : 
; 391  : 			// Merge
; 392  : 			if (dest->isLeaf)

	mov	eax, DWORD PTR _dest$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN17@FixUnderfl

; 393  : 			{
; 394  : 				for (sourceIndex=0; sourceIndex<source->size; sourceIndex++)

	mov	DWORD PTR _sourceIndex$1[ebp], 0
	jmp	SHORT $LN16@FixUnderfl
$LN15@FixUnderfl:
	mov	eax, DWORD PTR _sourceIndex$1[ebp]
	add	eax, 1
	mov	DWORD PTR _sourceIndex$1[ebp], eax
$LN16@FixUnderfl:
	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR _sourceIndex$1[ebp]
	cmp	ecx, DWORD PTR [eax+1]
	jge	SHORT $LN14@FixUnderfl

; 395  : 				{
; 396  : 					dest->keys[dest->size]=source->keys[sourceIndex];

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR _sourceIndex$1[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	ax, WORD PTR [esi+eax*2+5]
	mov	WORD PTR [edx+ecx*2+5], ax

; 397  : 					dest->data[dest->size++]=source->data[sourceIndex];

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR _sourceIndex$1[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	eax, DWORD PTR [esi+eax*4+69]
	mov	DWORD PTR [edx+ecx*4+69], eax
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR [ecx+1]
	add	edx, 1
	mov	eax, DWORD PTR _dest$[ebp]
	mov	DWORD PTR [eax+1], edx

; 398  : 				}

	jmp	SHORT $LN15@FixUnderfl
$LN14@FixUnderfl:

; 399  : 			}
; 400  : 			else

	jmp	$LN13@FixUnderfl
$LN17@FixUnderfl:

; 401  : 			{
; 402  : 				// We want the tree root key of the source, not the current.
; 403  : 				dest->keys[dest->size]=rightRootKey;

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	mov	edx, DWORD PTR _dest$[ebp]
	mov	ax, WORD PTR _rightRootKey$[ebp]
	mov	WORD PTR [edx+ecx*2+5], ax

; 404  : 				dest->children[dest->size++ + 1]=source->children[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR [edx+1]
	mov	edx, DWORD PTR _dest$[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+205]
	mov	DWORD PTR [edx+eax*4+209], ecx
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR [edx+1]
	add	eax, 1
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR [ecx+1], eax

; 405  : 				for (sourceIndex=0; sourceIndex<source->size; sourceIndex++)

	mov	DWORD PTR _sourceIndex$1[ebp], 0
	jmp	SHORT $LN12@FixUnderfl
$LN11@FixUnderfl:
	mov	eax, DWORD PTR _sourceIndex$1[ebp]
	add	eax, 1
	mov	DWORD PTR _sourceIndex$1[ebp], eax
$LN12@FixUnderfl:
	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR _sourceIndex$1[ebp]
	cmp	ecx, DWORD PTR [eax+1]
	jge	SHORT $LN13@FixUnderfl

; 406  : 				{
; 407  : 					dest->keys[dest->size]=source->keys[sourceIndex];

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR _sourceIndex$1[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	ax, WORD PTR [esi+eax*2+5]
	mov	WORD PTR [edx+ecx*2+5], ax

; 408  : 					dest->children[dest->size++ + 1]=source->children[sourceIndex + 1];

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR _sourceIndex$1[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	eax, DWORD PTR [esi+eax*4+209]
	mov	DWORD PTR [edx+ecx*4+209], eax
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR [ecx+1]
	add	edx, 1
	mov	eax, DWORD PTR _dest$[ebp]
	mov	DWORD PTR [eax+1], edx

; 409  : 				}

	jmp	SHORT $LN11@FixUnderfl
$LN13@FixUnderfl:

; 410  : 			}
; 411  : 
; 412  : #ifdef _MSC_VER
; 413  : #pragma warning( disable : 4127 ) // warning C4127: conditional expression is constant
; 414  : #endif
; 415  : 			if (order<=3 && branchIndex>0 && cur->children[branchIndex]->isLeaf) // With order==2 it is possible to delete data[0], which is not possible with higher orders.

	xor	eax, eax
	je	SHORT $LN9@FixUnderfl

; 416  : 				cur->keys[branchIndex-1]=cur->children[branchIndex]->keys[0];

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+205]
	mov	eax, 2
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	cx, WORD PTR [edx+ecx+5]
	mov	WORD PTR [esi+eax*2+3], cx
$LN9@FixUnderfl:

; 417  : 
; 418  : 			if (branchIndex<cur->size)

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _branchIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+1]
	jge	SHORT $LN8@FixUnderfl

; 419  : 			{
; 420  : 				// Update the parent key, removing the source (right)
; 421  : 				DeleteFromPageAtIndex(branchIndex, cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _branchIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DeleteFromPageAtIndex@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEXHPAU?$Page@GPAUInternalPacket@@$0CA@@2@@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::DeleteFromPageAtIndex

; 422  : 			}
; 423  : 			else

	jmp	SHORT $LN7@FixUnderfl
$LN8@FixUnderfl:

; 424  : 			{
; 425  : 				if (branchIndex>0)

	cmp	DWORD PTR _branchIndex$[ebp], 0
	jle	SHORT $LN7@FixUnderfl

; 426  : 				{
; 427  : 					// Update parent key, removing the source (current)
; 428  : 					DeleteFromPageAtIndex(branchIndex-1, cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _branchIndex$[ebp]
	sub	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DeleteFromPageAtIndex@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEXHPAU?$Page@GPAUInternalPacket@@$0CA@@2@@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::DeleteFromPageAtIndex
$LN7@FixUnderfl:

; 429  : 				}
; 430  : 			}
; 431  : 
; 432  : 			if (branchIndex==0 && dest->isLeaf)

	cmp	DWORD PTR _branchIndex$[ebp], 0
	jne	SHORT $LN5@FixUnderfl
	mov	eax, DWORD PTR _dest$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN5@FixUnderfl

; 433  : 			{
; 434  : 				returnAction->action=ReturnAction::SET_BRANCH_KEY;

	mov	eax, DWORD PTR _returnAction$[ebp]
	mov	DWORD PTR [eax+4], 3

; 435  : 				returnAction->key1=dest->keys[0];

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _returnAction$[ebp]
	mov	eax, DWORD PTR _dest$[ebp]
	mov	cx, WORD PTR [eax+ecx+5]
	mov	WORD PTR [edx], cx
$LN5@FixUnderfl:

; 436  : 			}
; 437  : 
; 438  : 			if (source==leftmostLeaf)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _source$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	jne	SHORT $LN4@FixUnderfl

; 439  : 				leftmostLeaf=source->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _source$[ebp]
	mov	edx, DWORD PTR [ecx+197]
	mov	DWORD PTR [eax+20], edx
$LN4@FixUnderfl:

; 440  : 
; 441  : 			if (source->isLeaf)

	mov	eax, DWORD PTR _source$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@FixUnderfl

; 442  : 			{
; 443  : 				if (source->previous)

	mov	eax, DWORD PTR _source$[ebp]
	cmp	DWORD PTR [eax+201], 0
	je	SHORT $LN2@FixUnderfl

; 444  : 					source->previous->next=source->next;

	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+201]
	mov	edx, DWORD PTR _source$[ebp]
	mov	eax, DWORD PTR [edx+197]
	mov	DWORD PTR [ecx+197], eax
$LN2@FixUnderfl:

; 445  : 				if (source->next)

	mov	eax, DWORD PTR _source$[ebp]
	cmp	DWORD PTR [eax+197], 0
	je	SHORT $LN3@FixUnderfl

; 446  : 					source->next->previous=source->previous;

	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+197]
	mov	edx, DWORD PTR _source$[ebp]
	mov	eax, DWORD PTR [edx+201]
	mov	DWORD PTR [ecx+201], eax
$LN3@FixUnderfl:

; 447  : 			}			
; 448  : 
; 449  : 			// Free the source node
; 450  : 			pagePool.Release(source);

	mov	eax, DWORD PTR _source$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Release@?$MemoryPool@U?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEXPAU?$Page@GPAUInternalPacket@@$0CA@@2@@Z ; DataStructures::MemoryPool<DataStructures::Page<unsigned short,InternalPacket *,32> >::Release

; 451  : 			memset(source,0,sizeof(root));

	push	4
	push	0
	mov	eax, DWORD PTR _source$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 452  : 
; 453  : 			// Return underflow or not of parent.
; 454  : 			return cur->size < order/2;

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+1], 16			; 00000010H
	jge	SHORT $LN34@FixUnderfl
	mov	DWORD PTR tv375[ebp], 1
	jmp	SHORT $LN35@FixUnderfl
$LN34@FixUnderfl:
	mov	DWORD PTR tv375[ebp], 0
$LN35@FixUnderfl:
	mov	al, BYTE PTR tv375[ebp]
$LN32@FixUnderfl:

; 455  : 		}
; 456  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?FixUnderflow@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAE_NHPAU?$Page@GPAUInternalPacket@@$0CA@@2@GPAUReturnAction@12@@Z ENDP ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::FixUnderflow
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?FindDeleteRebalance@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAE_NGPAU?$Page@GPAUInternalPacket@@$0CA@@2@PA_NGPAUReturnAction@12@AAPAUInternalPacket@@@Z
_TEXT	SEGMENT
_childIndex$ = -32					; size = 4
_branchIndex$ = -20					; size = 4
_this$ = -8						; size = 4
_key$ = 8						; size = 2
_cur$ = 12						; size = 4
_underflow$ = 16					; size = 4
_rightRootKey$ = 20					; size = 2
_returnAction$ = 24					; size = 4
_out$ = 28						; size = 4
?FindDeleteRebalance@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAE_NGPAU?$Page@GPAUInternalPacket@@$0CA@@2@PA_NGPAUReturnAction@12@AAPAUInternalPacket@@@Z PROC ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::FindDeleteRebalance, COMDAT
; _this$ = ecx

; 204  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 205  : 		// Get index of child to follow.
; 206  : 		int branchIndex, childIndex;
; 207  : 		if (GetIndexOf(key, cur, &childIndex))

	lea	eax, DWORD PTR _childIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	movzx	edx, WORD PTR _key$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexOf@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IBE_NGPAU?$Page@GPAUInternalPacket@@$0CA@@2@PAH@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::GetIndexOf
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN19@FindDelete

; 208  : 			branchIndex=childIndex+1;

	mov	eax, DWORD PTR _childIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _branchIndex$[ebp], eax

; 209  : 		else

	jmp	SHORT $LN18@FindDelete
$LN19@FindDelete:

; 210  : 			branchIndex=childIndex;

	mov	eax, DWORD PTR _childIndex$[ebp]
	mov	DWORD PTR _branchIndex$[ebp], eax
$LN18@FindDelete:

; 211  : 
; 212  : 		// If child is not a leaf, call recursively
; 213  : 		if (cur->children[branchIndex]->isLeaf==false)

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+205]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	$LN17@FindDelete

; 214  : 		{
; 215  : 			if (branchIndex<cur->size)

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _branchIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+1]
	jge	SHORT $LN16@FindDelete

; 216  : 				rightRootKey=cur->keys[branchIndex]; // Shift right to left

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	dx, WORD PTR [ecx+eax*2+5]
	mov	WORD PTR _rightRootKey$[ebp], dx

; 217  : 			else

	jmp	SHORT $LN15@FindDelete
$LN16@FindDelete:

; 218  : 				rightRootKey=cur->keys[branchIndex-1]; // Shift center to left

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	dx, WORD PTR [ecx+eax*2+3]
	mov	WORD PTR _rightRootKey$[ebp], dx
$LN15@FindDelete:

; 219  : 
; 220  : 			if (FindDeleteRebalance(key, cur->children[branchIndex], underflow, rightRootKey, returnAction, out)==false)

	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	mov	ecx, DWORD PTR _returnAction$[ebp]
	push	ecx
	movzx	edx, WORD PTR _rightRootKey$[ebp]
	push	edx
	mov	eax, DWORD PTR _underflow$[ebp]
	push	eax
	mov	ecx, DWORD PTR _branchIndex$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+205]
	push	eax
	movzx	ecx, WORD PTR _key$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindDeleteRebalance@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAE_NGPAU?$Page@GPAUInternalPacket@@$0CA@@2@PA_NGPAUReturnAction@12@AAPAUInternalPacket@@@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::FindDeleteRebalance
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN14@FindDelete

; 221  : 				return false;

	xor	al, al
	jmp	$LN20@FindDelete
$LN14@FindDelete:

; 222  : 
; 223  : 			// Call again in case the root key changed
; 224  : 			if (branchIndex<cur->size)

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _branchIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+1]
	jge	SHORT $LN13@FindDelete

; 225  : 				rightRootKey=cur->keys[branchIndex]; // Shift right to left

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	dx, WORD PTR [ecx+eax*2+5]
	mov	WORD PTR _rightRootKey$[ebp], dx

; 226  : 			else

	jmp	SHORT $LN12@FindDelete
$LN13@FindDelete:

; 227  : 				rightRootKey=cur->keys[branchIndex-1]; // Shift center to left

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	dx, WORD PTR [ecx+eax*2+3]
	mov	WORD PTR _rightRootKey$[ebp], dx
$LN12@FindDelete:

; 228  : 
; 229  : 			if (returnAction->action==ReturnAction::SET_BRANCH_KEY && branchIndex!=childIndex)

	mov	eax, DWORD PTR _returnAction$[ebp]
	cmp	DWORD PTR [eax+4], 3
	jne	SHORT $LN11@FindDelete
	mov	eax, DWORD PTR _branchIndex$[ebp]
	cmp	eax, DWORD PTR _childIndex$[ebp]
	je	SHORT $LN11@FindDelete

; 230  : 			{
; 231  : 				returnAction->action=ReturnAction::NO_ACTION;

	mov	eax, DWORD PTR _returnAction$[ebp]
	mov	DWORD PTR [eax+4], 0

; 232  : 				cur->keys[childIndex]=returnAction->key1;

	mov	eax, DWORD PTR _childIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _returnAction$[ebp]
	mov	dx, WORD PTR [edx]
	mov	WORD PTR [ecx+eax*2+5], dx

; 233  : 
; 234  : 				if (branchIndex<cur->size)

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _branchIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+1]
	jge	SHORT $LN10@FindDelete

; 235  : 					rightRootKey=cur->keys[branchIndex]; // Shift right to left

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	dx, WORD PTR [ecx+eax*2+5]
	mov	WORD PTR _rightRootKey$[ebp], dx

; 236  : 				else

	jmp	SHORT $LN11@FindDelete
$LN10@FindDelete:

; 237  : 					rightRootKey=cur->keys[branchIndex-1]; // Shift center to left

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	dx, WORD PTR [ecx+eax*2+3]
	mov	WORD PTR _rightRootKey$[ebp], dx
$LN11@FindDelete:

; 238  : 			}
; 239  : 		}
; 240  : 		else

	jmp	$LN8@FindDelete
$LN17@FindDelete:

; 241  : 		{
; 242  : 			// If child is a leaf, get the index of the key.  If the item is not found, cancel delete.
; 243  : 			if (GetIndexOf(key, cur->children[branchIndex], &childIndex)==false)

	lea	eax, DWORD PTR _childIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _branchIndex$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+205]
	push	eax
	movzx	ecx, WORD PTR _key$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexOf@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IBE_NGPAU?$Page@GPAUInternalPacket@@$0CA@@2@PAH@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::GetIndexOf
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN7@FindDelete

; 244  : 				return false;

	xor	al, al
	jmp	$LN20@FindDelete
$LN7@FindDelete:

; 245  : 
; 246  : 			// Delete:
; 247  : 			// Remove childIndex from the child at branchIndex
; 248  : 			out=cur->children[branchIndex]->data[childIndex];

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+205]
	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _childIndex$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4+69]
	mov	DWORD PTR [eax], edx

; 249  : 			DeleteFromPageAtIndex(childIndex, cur->children[branchIndex]);

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+205]
	push	edx
	mov	eax, DWORD PTR _childIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DeleteFromPageAtIndex@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEXHPAU?$Page@GPAUInternalPacket@@$0CA@@2@@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::DeleteFromPageAtIndex

; 250  : 
; 251  : 			if (childIndex==0)

	cmp	DWORD PTR _childIndex$[ebp], 0
	jne	SHORT $LN6@FindDelete

; 252  : 			{
; 253  : 				if (branchIndex>0)

	cmp	DWORD PTR _branchIndex$[ebp], 0
	jle	SHORT $LN5@FindDelete

; 254  : 					cur->keys[branchIndex-1]=cur->children[branchIndex]->keys[0];

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+205]
	mov	eax, 2
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	cx, WORD PTR [edx+ecx+5]
	mov	WORD PTR [esi+eax*2+3], cx
$LN5@FindDelete:

; 255  : 
; 256  : 				if (branchIndex==0)

	cmp	DWORD PTR _branchIndex$[ebp], 0
	jne	SHORT $LN6@FindDelete

; 257  : 				{
; 258  : 					returnAction->action=ReturnAction::SET_BRANCH_KEY;

	mov	eax, DWORD PTR _returnAction$[ebp]
	mov	DWORD PTR [eax+4], 3

; 259  : 					returnAction->key1=cur->children[0]->keys[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+ecx+205]
	mov	ecx, 2
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _returnAction$[ebp]
	mov	dx, WORD PTR [eax+edx+5]
	mov	WORD PTR [ecx], dx
$LN6@FindDelete:

; 260  : 				}				
; 261  : 			}
; 262  : 
; 263  : 			if (cur->children[branchIndex]->size < order/2)

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+205]
	cmp	DWORD PTR [edx+1], 16			; 00000010H
	jge	SHORT $LN3@FindDelete

; 264  : 				*underflow=true;

	mov	eax, DWORD PTR _underflow$[ebp]
	mov	BYTE PTR [eax], 1

; 265  : 			else

	jmp	SHORT $LN8@FindDelete
$LN3@FindDelete:

; 266  : 				*underflow=false;

	mov	eax, DWORD PTR _underflow$[ebp]
	mov	BYTE PTR [eax], 0
$LN8@FindDelete:

; 267  : 		}
; 268  : 
; 269  : 		// Fix underflow:
; 270  : 		if (*underflow)

	mov	eax, DWORD PTR _underflow$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN1@FindDelete

; 271  : 		{
; 272  : 			*underflow=FixUnderflow(branchIndex, cur, rightRootKey, returnAction);

	mov	eax, DWORD PTR _returnAction$[ebp]
	push	eax
	movzx	ecx, WORD PTR _rightRootKey$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _branchIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FixUnderflow@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAE_NHPAU?$Page@GPAUInternalPacket@@$0CA@@2@GPAUReturnAction@12@@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::FixUnderflow
	mov	ecx, DWORD PTR _underflow$[ebp]
	mov	BYTE PTR [ecx], al
$LN1@FindDelete:

; 273  : 		}
; 274  : 
; 275  : 		return true;

	mov	al, 1
$LN20@FindDelete:

; 276  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN24@FindDelete
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$LN24@FindDelete:
	DD	1
	DD	$LN23@FindDelete
$LN23@FindDelete:
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN22@FindDelete
$LN22@FindDelete:
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	100					; 00000064H
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	0
?FindDeleteRebalance@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAE_NGPAU?$Page@GPAUInternalPacket@@$0CA@@2@PA_NGPAUReturnAction@12@AAPAUInternalPacket@@@Z ENDP ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::FindDeleteRebalance
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?InsertBranchDown@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEPAU?$Page@GPAUInternalPacket@@$0CA@@2@GABQAUInternalPacket@@PAU32@PAUReturnAction@12@PA_N@Z
_TEXT	SEGMENT
_insertionIndex$1 = -92					; size = 4
_source$2 = -80						; size = 4
_dest$3 = -68						; size = 4
_insertionIndex$4 = -56					; size = 4
_newPage$ = -44						; size = 4
_branchIndex$ = -32					; size = 4
_childIndex$ = -20					; size = 4
_this$ = -8						; size = 4
_key$ = 8						; size = 2
_data$ = 12						; size = 4
_cur$ = 16						; size = 4
_returnAction$ = 20					; size = 4
_success$ = 24						; size = 4
?InsertBranchDown@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEPAU?$Page@GPAUInternalPacket@@$0CA@@2@GABQAUInternalPacket@@PAU32@PAUReturnAction@12@PA_N@Z PROC ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::InsertBranchDown, COMDAT
; _this$ = ecx

; 700  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 288				; 00000120H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-288]
	mov	ecx, 72					; 00000048H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 701  : 		int childIndex;
; 702  : 		int branchIndex;
; 703  : 		if (GetIndexOf(key, cur, &childIndex))

	lea	eax, DWORD PTR _childIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	movzx	edx, WORD PTR _key$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexOf@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IBE_NGPAU?$Page@GPAUInternalPacket@@$0CA@@2@PAH@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::GetIndexOf
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN20@InsertBran

; 704  : 			branchIndex=childIndex+1;

	mov	eax, DWORD PTR _childIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _branchIndex$[ebp], eax

; 705  : 		else

	jmp	SHORT $LN19@InsertBran
$LN20@InsertBran:

; 706  : 			branchIndex=childIndex;

	mov	eax, DWORD PTR _childIndex$[ebp]
	mov	DWORD PTR _branchIndex$[ebp], eax
$LN19@InsertBran:

; 707  : 		Page<KeyType, DataType, order>* newPage;
; 708  : 		if (cur->isLeaf==false)

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	$LN18@InsertBran

; 709  : 		{
; 710  : 			if (cur->children[branchIndex]->isLeaf==true && cur->children[branchIndex]->size==order)

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+205]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 1
	jne	$LN17@InsertBran
	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+205]
	cmp	DWORD PTR [edx+1], 32			; 00000020H
	jne	$LN17@InsertBran

; 711  : 			{
; 712  : 				if (branchIndex==childIndex+1)

	mov	eax, DWORD PTR _childIndex$[ebp]
	add	eax, 1
	cmp	DWORD PTR _branchIndex$[ebp], eax
	jne	SHORT $LN16@InsertBran

; 713  : 				{
; 714  : 					*success=false;

	mov	eax, DWORD PTR _success$[ebp]
	mov	BYTE PTR [eax], 0

; 715  : 					return 0; // Already exists

	xor	eax, eax
	jmp	$LN21@InsertBran
$LN16@InsertBran:

; 716  : 				}
; 717  : 
; 718  : 				if (CanRotateLeft(cur, branchIndex))

	mov	eax, DWORD PTR _branchIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CanRotateLeft@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAE_NPAU?$Page@GPAUInternalPacket@@$0CA@@2@H@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::CanRotateLeft
	movzx	edx, al
	test	edx, edx
	je	$LN15@InsertBran

; 719  : 				{
; 720  : 					returnAction->action=ReturnAction::REPLACE_KEY1_WITH_KEY2;

	mov	eax, DWORD PTR _returnAction$[ebp]
	mov	DWORD PTR [eax+4], 1

; 721  : 					if (key > cur->children[branchIndex]->keys[0])

	movzx	eax, WORD PTR _key$[ebp]
	mov	ecx, DWORD PTR _branchIndex$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+205]
	mov	edx, 2
	imul	edx, edx, 0
	movzx	ecx, WORD PTR [ecx+edx+5]
	cmp	eax, ecx
	jle	SHORT $LN14@InsertBran

; 722  : 					{						
; 723  : 						RotateLeft(cur, branchIndex, returnAction);

	mov	eax, DWORD PTR _returnAction$[ebp]
	push	eax
	mov	ecx, DWORD PTR _branchIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RotateLeft@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEXPAU?$Page@GPAUInternalPacket@@$0CA@@2@HPAUReturnAction@12@@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::RotateLeft

; 724  : 
; 725  : 						int insertionIndex;
; 726  : 						GetIndexOf(key, cur->children[branchIndex], &insertionIndex);

	lea	eax, DWORD PTR _insertionIndex$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _branchIndex$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+205]
	push	eax
	movzx	ecx, WORD PTR _key$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexOf@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IBE_NGPAU?$Page@GPAUInternalPacket@@$0CA@@2@PAH@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::GetIndexOf

; 727  : 						InsertIntoNode(key, data, insertionIndex, 0, cur->children[branchIndex], 0);

	push	0
	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+205]
	push	edx
	push	0
	mov	eax, DWORD PTR _insertionIndex$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	movzx	edx, WORD PTR _key$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertIntoNode@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEPAU?$Page@GPAUInternalPacket@@$0CA@@2@GABQAUInternalPacket@@HPAU32@1PAUReturnAction@12@@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::InsertIntoNode

; 728  : 					}
; 729  : 					else

	jmp	$LN13@InsertBran
$LN14@InsertBran:

; 730  : 					{
; 731  : 						// Move head element to left and replace it with key,data
; 732  : 						Page<KeyType, DataType, order>* dest=cur->children[branchIndex-1];

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+201]
	mov	DWORD PTR _dest$3[ebp], edx

; 733  : 						Page<KeyType, DataType, order>* source=cur->children[branchIndex];

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+205]
	mov	DWORD PTR _source$2[ebp], edx

; 734  : 						returnAction->key1=source->keys[0];

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _returnAction$[ebp]
	mov	eax, DWORD PTR _source$2[ebp]
	mov	cx, WORD PTR [eax+ecx+5]
	mov	WORD PTR [edx], cx

; 735  : 						returnAction->key2=key;

	mov	eax, DWORD PTR _returnAction$[ebp]
	mov	cx, WORD PTR _key$[ebp]
	mov	WORD PTR [eax+2], cx

; 736  : 						dest->keys[dest->size]=source->keys[0];

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _dest$3[ebp]
	mov	eax, DWORD PTR [edx+1]
	mov	edx, DWORD PTR _dest$3[ebp]
	mov	esi, DWORD PTR _source$2[ebp]
	mov	cx, WORD PTR [esi+ecx+5]
	mov	WORD PTR [edx+eax*2+5], cx

; 737  : 						dest->data[dest->size]=source->data[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _dest$3[ebp]
	mov	eax, DWORD PTR [edx+1]
	mov	edx, DWORD PTR _dest$3[ebp]
	mov	esi, DWORD PTR _source$2[ebp]
	mov	ecx, DWORD PTR [esi+ecx+69]
	mov	DWORD PTR [edx+eax*4+69], ecx

; 738  : 						dest->size++;

	mov	eax, DWORD PTR _dest$3[ebp]
	mov	ecx, DWORD PTR [eax+1]
	add	ecx, 1
	mov	edx, DWORD PTR _dest$3[ebp]
	mov	DWORD PTR [edx+1], ecx

; 739  : 						source->keys[0]=key;

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _source$2[ebp]
	mov	ax, WORD PTR _key$[ebp]
	mov	WORD PTR [edx+ecx+5], ax

; 740  : 						source->data[0]=data;	

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _source$2[ebp]
	mov	eax, DWORD PTR _data$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx+ecx+69], eax
$LN13@InsertBran:

; 741  : 					}
; 742  : 					cur->keys[branchIndex-1]=cur->children[branchIndex]->keys[0];

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+205]
	mov	eax, 2
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	cx, WORD PTR [edx+ecx+5]
	mov	WORD PTR [esi+eax*2+3], cx

; 743  : 					
; 744  : 					return 0;

	xor	eax, eax
	jmp	$LN21@InsertBran
	jmp	$LN17@InsertBran
$LN15@InsertBran:

; 745  : 				}
; 746  : 				else if (CanRotateRight(cur, branchIndex))

	mov	eax, DWORD PTR _branchIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CanRotateRight@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAE_NPAU?$Page@GPAUInternalPacket@@$0CA@@2@H@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::CanRotateRight
	movzx	edx, al
	test	edx, edx
	je	$LN17@InsertBran

; 747  : 				{
; 748  : 					returnAction->action=ReturnAction::REPLACE_KEY1_WITH_KEY2;

	mov	eax, DWORD PTR _returnAction$[ebp]
	mov	DWORD PTR [eax+4], 1

; 749  : 					
; 750  : 					if (key < cur->children[branchIndex]->keys[cur->children[branchIndex]->size-1])

	movzx	eax, WORD PTR _key$[ebp]
	mov	ecx, DWORD PTR _branchIndex$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+205]
	mov	edx, DWORD PTR _branchIndex$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+205]
	mov	edx, DWORD PTR [edx+1]
	movzx	ecx, WORD PTR [ecx+edx*2+3]
	cmp	eax, ecx
	jge	SHORT $LN10@InsertBran

; 751  : 					{
; 752  : 						RotateRight(cur, branchIndex, returnAction);

	mov	eax, DWORD PTR _returnAction$[ebp]
	push	eax
	mov	ecx, DWORD PTR _branchIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RotateRight@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEXPAU?$Page@GPAUInternalPacket@@$0CA@@2@HPAUReturnAction@12@@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::RotateRight

; 753  : 
; 754  : 						int insertionIndex;
; 755  : 						GetIndexOf(key, cur->children[branchIndex], &insertionIndex);

	lea	eax, DWORD PTR _insertionIndex$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _branchIndex$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+205]
	push	eax
	movzx	ecx, WORD PTR _key$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexOf@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IBE_NGPAU?$Page@GPAUInternalPacket@@$0CA@@2@PAH@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::GetIndexOf

; 756  : 						InsertIntoNode(key, data, insertionIndex, 0, cur->children[branchIndex], 0);

	push	0
	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+205]
	push	edx
	push	0
	mov	eax, DWORD PTR _insertionIndex$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	movzx	edx, WORD PTR _key$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertIntoNode@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEPAU?$Page@GPAUInternalPacket@@$0CA@@2@GABQAUInternalPacket@@HPAU32@1PAUReturnAction@12@@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::InsertIntoNode

; 757  : 						
; 758  : 					}
; 759  : 					else

	jmp	SHORT $LN9@InsertBran
$LN10@InsertBran:

; 760  : 					{
; 761  : 						// Insert to the head of the right leaf instead and change our key
; 762  : 						returnAction->key1=cur->children[branchIndex+1]->keys[0];

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+209]
	mov	eax, 2
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _returnAction$[ebp]
	mov	cx, WORD PTR [edx+ecx+5]
	mov	WORD PTR [eax], cx

; 763  : 						InsertIntoNode(key, data, 0, 0, cur->children[branchIndex+1], 0);						

	push	0
	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+209]
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	movzx	ecx, WORD PTR _key$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertIntoNode@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEPAU?$Page@GPAUInternalPacket@@$0CA@@2@GABQAUInternalPacket@@HPAU32@1PAUReturnAction@12@@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::InsertIntoNode

; 764  : 						returnAction->key2=key;

	mov	eax, DWORD PTR _returnAction$[ebp]
	mov	cx, WORD PTR _key$[ebp]
	mov	WORD PTR [eax+2], cx
$LN9@InsertBran:

; 765  : 					}
; 766  : 					cur->keys[branchIndex]=cur->children[branchIndex+1]->keys[0];

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+209]
	mov	eax, 2
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	cx, WORD PTR [edx+ecx+5]
	mov	WORD PTR [esi+eax*2+5], cx

; 767  : 					return 0;					

	xor	eax, eax
	jmp	$LN21@InsertBran
$LN17@InsertBran:

; 768  : 				}
; 769  : 			}
; 770  : 
; 771  : 			newPage=InsertBranchDown(key,data,cur->children[branchIndex], returnAction, success);

	mov	eax, DWORD PTR _success$[ebp]
	push	eax
	mov	ecx, DWORD PTR _returnAction$[ebp]
	push	ecx
	mov	edx, DWORD PTR _branchIndex$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+205]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	push	edx
	movzx	eax, WORD PTR _key$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertBranchDown@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEPAU?$Page@GPAUInternalPacket@@$0CA@@2@GABQAUInternalPacket@@PAU32@PAUReturnAction@12@PA_N@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::InsertBranchDown
	mov	DWORD PTR _newPage$[ebp], eax

; 772  : 			if (returnAction->action==ReturnAction::REPLACE_KEY1_WITH_KEY2)

	mov	eax, DWORD PTR _returnAction$[ebp]
	cmp	DWORD PTR [eax+4], 1
	jne	SHORT $LN8@InsertBran

; 773  : 			{
; 774  : 				if (branchIndex>0 && cur->keys[branchIndex-1]==returnAction->key1)

	cmp	DWORD PTR _branchIndex$[ebp], 0
	jle	SHORT $LN8@InsertBran
	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2+3]
	mov	eax, DWORD PTR _returnAction$[ebp]
	movzx	ecx, WORD PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN8@InsertBran

; 775  : 					cur->keys[branchIndex-1]=returnAction->key2;

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _returnAction$[ebp]
	mov	dx, WORD PTR [edx+2]
	mov	WORD PTR [ecx+eax*2+3], dx
$LN8@InsertBran:

; 776  : 			}
; 777  : 			if (newPage)

	cmp	DWORD PTR _newPage$[ebp], 0
	je	$LN6@InsertBran

; 778  : 			{
; 779  : 				if (newPage->isLeaf==false)

	mov	eax, DWORD PTR _newPage$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@InsertBran

; 780  : 				{
; 781  : 					assert(returnAction->action==ReturnAction::PUSH_KEY_TO_PARENT);

	mov	eax, DWORD PTR _returnAction$[ebp]
	cmp	DWORD PTR [eax+4], 2
	je	SHORT $LN23@InsertBran
	push	781					; 0000030dH
	push	OFFSET ??_C@_1EO@DHNPHPFC@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAb?$AAp?$AAl?$AAu?$AAs@
	push	OFFSET ??_C@_1GO@DFNPOHCN@?$AAr?$AAe?$AAt?$AAu?$AAr?$AAn?$AAA?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?9?$AA?$DO?$AAa?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$DN?$AA?$DN?$AAR?$AAe?$AAt?$AAu?$AAr?$AAn?$AAA?$AAc?$AAt?$AAi@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN23@InsertBran:

; 782  : 					newPage->size--; 

	mov	eax, DWORD PTR _newPage$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	sub	ecx, 1
	mov	edx, DWORD PTR _newPage$[ebp]
	mov	DWORD PTR [edx+1], ecx

; 783  : 					return InsertIntoNode(returnAction->key1, data, branchIndex, newPage, cur, returnAction);

	mov	eax, DWORD PTR _returnAction$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _newPage$[ebp]
	push	edx
	mov	eax, DWORD PTR _branchIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _returnAction$[ebp]
	movzx	eax, WORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertIntoNode@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEPAU?$Page@GPAUInternalPacket@@$0CA@@2@GABQAUInternalPacket@@HPAU32@1PAUReturnAction@12@@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::InsertIntoNode
	jmp	SHORT $LN21@InsertBran

; 784  : 				}
; 785  : 				else

	jmp	SHORT $LN6@InsertBran
$LN5@InsertBran:

; 786  : 				{
; 787  : 					return InsertIntoNode(newPage->keys[0], data, branchIndex, newPage, cur, returnAction);

	mov	eax, DWORD PTR _returnAction$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _newPage$[ebp]
	push	edx
	mov	eax, DWORD PTR _branchIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, 2
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _newPage$[ebp]
	movzx	edx, WORD PTR [ecx+eax+5]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertIntoNode@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEPAU?$Page@GPAUInternalPacket@@$0CA@@2@GABQAUInternalPacket@@HPAU32@1PAUReturnAction@12@@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::InsertIntoNode
	jmp	SHORT $LN21@InsertBran
$LN6@InsertBran:

; 788  : 				}				
; 789  : 			}
; 790  : 		}
; 791  : 		else

	jmp	SHORT $LN3@InsertBran
$LN18@InsertBran:

; 792  : 		{
; 793  : 			if (branchIndex==childIndex+1)

	mov	eax, DWORD PTR _childIndex$[ebp]
	add	eax, 1
	cmp	DWORD PTR _branchIndex$[ebp], eax
	jne	SHORT $LN2@InsertBran

; 794  : 			{
; 795  : 				*success=false;

	mov	eax, DWORD PTR _success$[ebp]
	mov	BYTE PTR [eax], 0

; 796  : 				return 0; // Already exists				

	xor	eax, eax
	jmp	SHORT $LN21@InsertBran

; 797  : 			}
; 798  : 			else

	jmp	SHORT $LN3@InsertBran
$LN2@InsertBran:

; 799  : 			{
; 800  : 				return InsertIntoNode(key, data, branchIndex, 0, cur, returnAction);

	mov	eax, DWORD PTR _returnAction$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _branchIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	movzx	ecx, WORD PTR _key$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertIntoNode@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEPAU?$Page@GPAUInternalPacket@@$0CA@@2@GABQAUInternalPacket@@HPAU32@1PAUReturnAction@12@@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::InsertIntoNode
	jmp	SHORT $LN21@InsertBran
$LN3@InsertBran:

; 801  : 			}
; 802  : 		}
; 803  : 		
; 804  : 		return 0;

	xor	eax, eax
$LN21@InsertBran:

; 805  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN28@InsertBran
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 288				; 00000120H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
	npad	2
$LN28@InsertBran:
	DD	3
	DD	$LN27@InsertBran
$LN27@InsertBran:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN24@InsertBran
	DD	-56					; ffffffc8H
	DD	4
	DD	$LN25@InsertBran
	DD	-92					; ffffffa4H
	DD	4
	DD	$LN26@InsertBran
$LN26@InsertBran:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	0
$LN25@InsertBran:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	0
$LN24@InsertBran:
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	100					; 00000064H
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	0
?InsertBranchDown@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEPAU?$Page@GPAUInternalPacket@@$0CA@@2@GABQAUInternalPacket@@PAU32@PAUReturnAction@12@PA_N@Z ENDP ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::InsertBranchDown
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?InsertIntoNode@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEPAU?$Page@GPAUInternalPacket@@$0CA@@2@GABQAUInternalPacket@@HPAU32@1PAUReturnAction@12@@Z
_TEXT	SEGMENT
_b$1 = -89						; size = 1
_i$2 = -80						; size = 4
_i$3 = -68						; size = 4
_sourceIndex$4 = -56					; size = 4
_destIndex$5 = -44					; size = 4
_newPage$6 = -32					; size = 4
_i$ = -20						; size = 4
_this$ = -8						; size = 4
_key$ = 8						; size = 2
_leafData$ = 12						; size = 4
_insertionIndex$ = 16					; size = 4
_nodeData$ = 20						; size = 4
_cur$ = 24						; size = 4
_returnAction$ = 28					; size = 4
?InsertIntoNode@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEPAU?$Page@GPAUInternalPacket@@$0CA@@2@GABQAUInternalPacket@@HPAU32@1PAUReturnAction@12@@Z PROC ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::InsertIntoNode, COMDAT
; _this$ = ecx

; 496  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 288				; 00000120H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-288]
	mov	ecx, 72					; 00000048H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		int i;
; 498  : 		if (cur->size < order)

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+1], 32			; 00000020H
	jge	$LN58@InsertInto

; 499  : 		{
; 500  : 			for (i=cur->size; i > insertionIndex; i--)

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN57@InsertInto
$LN56@InsertInto:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN57@InsertInto:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _insertionIndex$[ebp]
	jle	SHORT $LN55@InsertInto

; 501  : 				cur->keys[i]=cur->keys[i-1];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	dx, WORD PTR [esi+edx*2+3]
	mov	WORD PTR [ecx+eax*2+5], dx
	jmp	SHORT $LN56@InsertInto
$LN55@InsertInto:

; 502  : 			if (cur->isLeaf)

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN54@InsertInto

; 503  : 			{
; 504  : 				for (i=cur->size; i > insertionIndex; i--)

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN53@InsertInto
$LN52@InsertInto:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN53@InsertInto:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _insertionIndex$[ebp]
	jle	SHORT $LN51@InsertInto

; 505  : 					cur->data[i]=cur->data[i-1];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+65]
	mov	DWORD PTR [ecx+eax*4+69], edx
	jmp	SHORT $LN52@InsertInto
$LN51@InsertInto:

; 506  : 			}
; 507  : 			else

	jmp	SHORT $LN50@InsertInto
$LN54@InsertInto:

; 508  : 			{
; 509  : 				for (i=cur->size+1; i > insertionIndex+1; i--)

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN49@InsertInto
$LN48@InsertInto:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN49@InsertInto:
	mov	eax, DWORD PTR _insertionIndex$[ebp]
	add	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	jle	SHORT $LN50@InsertInto

; 510  : 					cur->children[i]=cur->children[i-1];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+201]
	mov	DWORD PTR [ecx+eax*4+205], edx
	jmp	SHORT $LN48@InsertInto
$LN50@InsertInto:

; 511  : 			}
; 512  : 			cur->keys[insertionIndex]=key;

	mov	eax, DWORD PTR _insertionIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	dx, WORD PTR _key$[ebp]
	mov	WORD PTR [ecx+eax*2+5], dx

; 513  : 			if (cur->isLeaf)

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN46@InsertInto

; 514  : 				cur->data[insertionIndex]=leafData;

	mov	eax, DWORD PTR _insertionIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _leafData$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+eax*4+69], edx

; 515  : 			else

	jmp	SHORT $LN45@InsertInto
$LN46@InsertInto:

; 516  : 				cur->children[insertionIndex+1]=nodeData;

	mov	eax, DWORD PTR _insertionIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _nodeData$[ebp]
	mov	DWORD PTR [ecx+eax*4+209], edx
$LN45@InsertInto:

; 517  : 
; 518  : 			cur->size++;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	add	ecx, 1
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx+1], ecx

; 519  : 		}
; 520  : 		else

	jmp	$LN44@InsertInto
$LN58@InsertInto:

; 521  : 		{
; 522  : 			Page<KeyType, DataType, order>* newPage = pagePool.Allocate();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Allocate@?$MemoryPool@U?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEPAU?$Page@GPAUInternalPacket@@$0CA@@2@XZ ; DataStructures::MemoryPool<DataStructures::Page<unsigned short,InternalPacket *,32> >::Allocate
	mov	DWORD PTR _newPage$6[ebp], eax

; 523  : 			newPage->isLeaf=cur->isLeaf;

	mov	eax, DWORD PTR _newPage$6[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 524  : 			if (cur->isLeaf)

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN43@InsertInto

; 525  : 			{
; 526  : 				newPage->next=cur->next;

	mov	eax, DWORD PTR _newPage$6[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+197]
	mov	DWORD PTR [eax+197], edx

; 527  : 				if (cur->next)

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+197], 0
	je	SHORT $LN42@InsertInto

; 528  : 					cur->next->previous=newPage;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+197]
	mov	edx, DWORD PTR _newPage$6[ebp]
	mov	DWORD PTR [ecx+201], edx
$LN42@InsertInto:

; 529  : 				newPage->previous=cur;

	mov	eax, DWORD PTR _newPage$6[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax+201], ecx

; 530  : 				cur->next=newPage;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _newPage$6[ebp]
	mov	DWORD PTR [eax+197], ecx
$LN43@InsertInto:

; 531  : 			}
; 532  : 
; 533  : 			int destIndex, sourceIndex;
; 534  : 
; 535  : 			if (insertionIndex>=(order+1)/2)

	cmp	DWORD PTR _insertionIndex$[ebp], 16	; 00000010H
	jl	$LN41@InsertInto

; 536  : 			{
; 537  : 				destIndex=0;

	mov	DWORD PTR _destIndex$5[ebp], 0

; 538  : 				sourceIndex=order/2;

	mov	DWORD PTR _sourceIndex$4[ebp], 16	; 00000010H

; 539  : 
; 540  : 				for (; sourceIndex < insertionIndex; sourceIndex++, destIndex++)

	jmp	SHORT $LN40@InsertInto
$LN39@InsertInto:
	mov	eax, DWORD PTR _sourceIndex$4[ebp]
	add	eax, 1
	mov	DWORD PTR _sourceIndex$4[ebp], eax
	mov	ecx, DWORD PTR _destIndex$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _destIndex$5[ebp], ecx
$LN40@InsertInto:
	mov	eax, DWORD PTR _sourceIndex$4[ebp]
	cmp	eax, DWORD PTR _insertionIndex$[ebp]
	jge	SHORT $LN38@InsertInto

; 541  : 				{
; 542  : 					newPage->keys[destIndex]=cur->keys[sourceIndex];

	mov	eax, DWORD PTR _destIndex$5[ebp]
	mov	ecx, DWORD PTR _newPage$6[ebp]
	mov	edx, DWORD PTR _sourceIndex$4[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	dx, WORD PTR [esi+edx*2+5]
	mov	WORD PTR [ecx+eax*2+5], dx

; 543  : 				}

	jmp	SHORT $LN39@InsertInto
$LN38@InsertInto:

; 544  : 				newPage->keys[destIndex++]=key;

	mov	eax, DWORD PTR _destIndex$5[ebp]
	mov	ecx, DWORD PTR _newPage$6[ebp]
	mov	dx, WORD PTR _key$[ebp]
	mov	WORD PTR [ecx+eax*2+5], dx
	mov	eax, DWORD PTR _destIndex$5[ebp]
	add	eax, 1
	mov	DWORD PTR _destIndex$5[ebp], eax

; 545  : 				for (; sourceIndex < order; sourceIndex++, destIndex++)

	jmp	SHORT $LN37@InsertInto
$LN36@InsertInto:
	mov	eax, DWORD PTR _sourceIndex$4[ebp]
	add	eax, 1
	mov	DWORD PTR _sourceIndex$4[ebp], eax
	mov	ecx, DWORD PTR _destIndex$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _destIndex$5[ebp], ecx
$LN37@InsertInto:
	cmp	DWORD PTR _sourceIndex$4[ebp], 32	; 00000020H
	jge	SHORT $LN35@InsertInto

; 546  : 				{
; 547  : 					newPage->keys[destIndex]=cur->keys[sourceIndex];

	mov	eax, DWORD PTR _destIndex$5[ebp]
	mov	ecx, DWORD PTR _newPage$6[ebp]
	mov	edx, DWORD PTR _sourceIndex$4[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	dx, WORD PTR [esi+edx*2+5]
	mov	WORD PTR [ecx+eax*2+5], dx

; 548  : 				}

	jmp	SHORT $LN36@InsertInto
$LN35@InsertInto:

; 549  : 
; 550  : 				destIndex=0;

	mov	DWORD PTR _destIndex$5[ebp], 0

; 551  : 				sourceIndex=order/2;

	mov	DWORD PTR _sourceIndex$4[ebp], 16	; 00000010H

; 552  : 				if (cur->isLeaf)

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN34@InsertInto

; 553  : 				{
; 554  : 					for (; sourceIndex < insertionIndex; sourceIndex++, destIndex++)

	jmp	SHORT $LN33@InsertInto
$LN32@InsertInto:
	mov	eax, DWORD PTR _sourceIndex$4[ebp]
	add	eax, 1
	mov	DWORD PTR _sourceIndex$4[ebp], eax
	mov	ecx, DWORD PTR _destIndex$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _destIndex$5[ebp], ecx
$LN33@InsertInto:
	mov	eax, DWORD PTR _sourceIndex$4[ebp]
	cmp	eax, DWORD PTR _insertionIndex$[ebp]
	jge	SHORT $LN31@InsertInto

; 555  : 					{
; 556  : 						newPage->data[destIndex]=cur->data[sourceIndex];

	mov	eax, DWORD PTR _destIndex$5[ebp]
	mov	ecx, DWORD PTR _newPage$6[ebp]
	mov	edx, DWORD PTR _sourceIndex$4[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+69]
	mov	DWORD PTR [ecx+eax*4+69], edx

; 557  : 					}

	jmp	SHORT $LN32@InsertInto
$LN31@InsertInto:

; 558  : 					newPage->data[destIndex++]=leafData;

	mov	eax, DWORD PTR _destIndex$5[ebp]
	mov	ecx, DWORD PTR _newPage$6[ebp]
	mov	edx, DWORD PTR _leafData$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+eax*4+69], edx
	mov	eax, DWORD PTR _destIndex$5[ebp]
	add	eax, 1
	mov	DWORD PTR _destIndex$5[ebp], eax

; 559  : 					for (; sourceIndex < order; sourceIndex++, destIndex++)

	jmp	SHORT $LN30@InsertInto
$LN29@InsertInto:
	mov	eax, DWORD PTR _sourceIndex$4[ebp]
	add	eax, 1
	mov	DWORD PTR _sourceIndex$4[ebp], eax
	mov	ecx, DWORD PTR _destIndex$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _destIndex$5[ebp], ecx
$LN30@InsertInto:
	cmp	DWORD PTR _sourceIndex$4[ebp], 32	; 00000020H
	jge	SHORT $LN28@InsertInto

; 560  : 					{
; 561  : 						newPage->data[destIndex]=cur->data[sourceIndex];

	mov	eax, DWORD PTR _destIndex$5[ebp]
	mov	ecx, DWORD PTR _newPage$6[ebp]
	mov	edx, DWORD PTR _sourceIndex$4[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+69]
	mov	DWORD PTR [ecx+eax*4+69], edx

; 562  : 					}

	jmp	SHORT $LN29@InsertInto
$LN28@InsertInto:

; 563  : 				}
; 564  : 				else

	jmp	$LN27@InsertInto
$LN34@InsertInto:

; 565  : 				{
; 566  : 					
; 567  : 					for (; sourceIndex < insertionIndex; sourceIndex++, destIndex++)

	jmp	SHORT $LN26@InsertInto
$LN25@InsertInto:
	mov	eax, DWORD PTR _sourceIndex$4[ebp]
	add	eax, 1
	mov	DWORD PTR _sourceIndex$4[ebp], eax
	mov	ecx, DWORD PTR _destIndex$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _destIndex$5[ebp], ecx
$LN26@InsertInto:
	mov	eax, DWORD PTR _sourceIndex$4[ebp]
	cmp	eax, DWORD PTR _insertionIndex$[ebp]
	jge	SHORT $LN24@InsertInto

; 568  : 					{
; 569  : 						newPage->children[destIndex]=cur->children[sourceIndex+1];

	mov	eax, DWORD PTR _destIndex$5[ebp]
	mov	ecx, DWORD PTR _newPage$6[ebp]
	mov	edx, DWORD PTR _sourceIndex$4[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+209]
	mov	DWORD PTR [ecx+eax*4+205], edx

; 570  : 					}

	jmp	SHORT $LN25@InsertInto
$LN24@InsertInto:

; 571  : 					newPage->children[destIndex++]=nodeData;

	mov	eax, DWORD PTR _destIndex$5[ebp]
	mov	ecx, DWORD PTR _newPage$6[ebp]
	mov	edx, DWORD PTR _nodeData$[ebp]
	mov	DWORD PTR [ecx+eax*4+205], edx
	mov	eax, DWORD PTR _destIndex$5[ebp]
	add	eax, 1
	mov	DWORD PTR _destIndex$5[ebp], eax

; 572  : 
; 573  : 					// sourceIndex+1 is sort of a hack but it works - because there is one extra child than keys
; 574  : 					// skip past the last child for cur
; 575  : 					for (; sourceIndex+1 < cur->size+1; sourceIndex++, destIndex++)

	jmp	SHORT $LN23@InsertInto
$LN22@InsertInto:
	mov	eax, DWORD PTR _sourceIndex$4[ebp]
	add	eax, 1
	mov	DWORD PTR _sourceIndex$4[ebp], eax
	mov	ecx, DWORD PTR _destIndex$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _destIndex$5[ebp], ecx
$LN23@InsertInto:
	mov	eax, DWORD PTR _sourceIndex$4[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+1]
	add	edx, 1
	cmp	eax, edx
	jge	SHORT $LN21@InsertInto

; 576  : 					{
; 577  : 						newPage->children[destIndex]=cur->children[sourceIndex+1];

	mov	eax, DWORD PTR _destIndex$5[ebp]
	mov	ecx, DWORD PTR _newPage$6[ebp]
	mov	edx, DWORD PTR _sourceIndex$4[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+209]
	mov	DWORD PTR [ecx+eax*4+205], edx

; 578  : 					}

	jmp	SHORT $LN22@InsertInto
$LN21@InsertInto:

; 579  : 
; 580  : 					// the first key is the middle key.  Remove it from the page and push it to the parent
; 581  : 					returnAction->action=ReturnAction::PUSH_KEY_TO_PARENT;

	mov	eax, DWORD PTR _returnAction$[ebp]
	mov	DWORD PTR [eax+4], 2

; 582  : 					returnAction->key1=newPage->keys[0];

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _returnAction$[ebp]
	mov	eax, DWORD PTR _newPage$6[ebp]
	mov	cx, WORD PTR [eax+ecx+5]
	mov	WORD PTR [edx], cx

; 583  : 					for (int i=0; i < destIndex-1; i++)

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN20@InsertInto
$LN19@InsertInto:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN20@InsertInto:
	mov	eax, DWORD PTR _destIndex$5[ebp]
	sub	eax, 1
	cmp	DWORD PTR _i$3[ebp], eax
	jge	SHORT $LN27@InsertInto

; 584  : 						newPage->keys[i]=newPage->keys[i+1];

	mov	eax, DWORD PTR _i$3[ebp]
	mov	ecx, DWORD PTR _newPage$6[ebp]
	mov	edx, DWORD PTR _i$3[ebp]
	mov	esi, DWORD PTR _newPage$6[ebp]
	mov	dx, WORD PTR [esi+edx*2+7]
	mov	WORD PTR [ecx+eax*2+5], dx
	jmp	SHORT $LN19@InsertInto
$LN27@InsertInto:

; 585  : 					
; 586  : 				}
; 587  : 				cur->size=order/2;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax+1], 16			; 00000010H

; 588  : 			}
; 589  : 			else

	jmp	$LN17@InsertInto
$LN41@InsertInto:

; 590  : 			{
; 591  : 				destIndex=0;

	mov	DWORD PTR _destIndex$5[ebp], 0

; 592  : 				sourceIndex=(order+1)/2-1;

	mov	DWORD PTR _sourceIndex$4[ebp], 15	; 0000000fH

; 593  : 				for (; sourceIndex < order; sourceIndex++, destIndex++)

	jmp	SHORT $LN16@InsertInto
$LN15@InsertInto:
	mov	eax, DWORD PTR _sourceIndex$4[ebp]
	add	eax, 1
	mov	DWORD PTR _sourceIndex$4[ebp], eax
	mov	ecx, DWORD PTR _destIndex$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _destIndex$5[ebp], ecx
$LN16@InsertInto:
	cmp	DWORD PTR _sourceIndex$4[ebp], 32	; 00000020H
	jge	SHORT $LN14@InsertInto

; 594  : 					newPage->keys[destIndex]=cur->keys[sourceIndex];

	mov	eax, DWORD PTR _destIndex$5[ebp]
	mov	ecx, DWORD PTR _newPage$6[ebp]
	mov	edx, DWORD PTR _sourceIndex$4[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	dx, WORD PTR [esi+edx*2+5]
	mov	WORD PTR [ecx+eax*2+5], dx
	jmp	SHORT $LN15@InsertInto
$LN14@InsertInto:

; 595  : 				destIndex=0;

	mov	DWORD PTR _destIndex$5[ebp], 0

; 596  : 				if (cur->isLeaf)

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN13@InsertInto

; 597  : 				{
; 598  : 					sourceIndex=(order+1)/2-1;

	mov	DWORD PTR _sourceIndex$4[ebp], 15	; 0000000fH

; 599  : 					for (; sourceIndex < order; sourceIndex++, destIndex++)

	jmp	SHORT $LN12@InsertInto
$LN11@InsertInto:
	mov	eax, DWORD PTR _sourceIndex$4[ebp]
	add	eax, 1
	mov	DWORD PTR _sourceIndex$4[ebp], eax
	mov	ecx, DWORD PTR _destIndex$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _destIndex$5[ebp], ecx
$LN12@InsertInto:
	cmp	DWORD PTR _sourceIndex$4[ebp], 32	; 00000020H
	jge	SHORT $LN10@InsertInto

; 600  : 						newPage->data[destIndex]=cur->data[sourceIndex];

	mov	eax, DWORD PTR _destIndex$5[ebp]
	mov	ecx, DWORD PTR _newPage$6[ebp]
	mov	edx, DWORD PTR _sourceIndex$4[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+69]
	mov	DWORD PTR [ecx+eax*4+69], edx
	jmp	SHORT $LN11@InsertInto
$LN10@InsertInto:

; 601  : 				}
; 602  : 				else

	jmp	$LN9@InsertInto
$LN13@InsertInto:

; 603  : 				{
; 604  : 					sourceIndex=(order+1)/2;

	mov	DWORD PTR _sourceIndex$4[ebp], 16	; 00000010H

; 605  : 					for (; sourceIndex < order+1; sourceIndex++, destIndex++)

	jmp	SHORT $LN8@InsertInto
$LN7@InsertInto:
	mov	eax, DWORD PTR _sourceIndex$4[ebp]
	add	eax, 1
	mov	DWORD PTR _sourceIndex$4[ebp], eax
	mov	ecx, DWORD PTR _destIndex$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _destIndex$5[ebp], ecx
$LN8@InsertInto:
	cmp	DWORD PTR _sourceIndex$4[ebp], 33	; 00000021H
	jge	SHORT $LN6@InsertInto

; 606  : 						newPage->children[destIndex]=cur->children[sourceIndex];

	mov	eax, DWORD PTR _destIndex$5[ebp]
	mov	ecx, DWORD PTR _newPage$6[ebp]
	mov	edx, DWORD PTR _sourceIndex$4[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+205]
	mov	DWORD PTR [ecx+eax*4+205], edx
	jmp	SHORT $LN7@InsertInto
$LN6@InsertInto:

; 607  : 
; 608  : 					// the first key is the middle key.  Remove it from the page and push it to the parent
; 609  : 					returnAction->action=ReturnAction::PUSH_KEY_TO_PARENT;

	mov	eax, DWORD PTR _returnAction$[ebp]
	mov	DWORD PTR [eax+4], 2

; 610  : 					returnAction->key1=newPage->keys[0];

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _returnAction$[ebp]
	mov	eax, DWORD PTR _newPage$6[ebp]
	mov	cx, WORD PTR [eax+ecx+5]
	mov	WORD PTR [edx], cx

; 611  : 					for (int i=0; i < destIndex-1; i++)

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN5@InsertInto
$LN4@InsertInto:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN5@InsertInto:
	mov	eax, DWORD PTR _destIndex$5[ebp]
	sub	eax, 1
	cmp	DWORD PTR _i$2[ebp], eax
	jge	SHORT $LN9@InsertInto

; 612  : 						newPage->keys[i]=newPage->keys[i+1];

	mov	eax, DWORD PTR _i$2[ebp]
	mov	ecx, DWORD PTR _newPage$6[ebp]
	mov	edx, DWORD PTR _i$2[ebp]
	mov	esi, DWORD PTR _newPage$6[ebp]
	mov	dx, WORD PTR [esi+edx*2+7]
	mov	WORD PTR [ecx+eax*2+5], dx
	jmp	SHORT $LN4@InsertInto
$LN9@InsertInto:

; 613  : 				}
; 614  : 				cur->size=(order+1)/2-1;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax+1], 15			; 0000000fH

; 615  : 				if (cur->size)

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+1], 0
	je	SHORT $LN2@InsertInto

; 616  : 				{
; 617  : 					bool b = GetIndexOf(key, cur, &insertionIndex);

	lea	eax, DWORD PTR _insertionIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	movzx	edx, WORD PTR _key$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexOf@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IBE_NGPAU?$Page@GPAUInternalPacket@@$0CA@@2@PAH@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::GetIndexOf
	mov	BYTE PTR _b$1[ebp], al

; 618  : 					assert(b==false);

	movzx	eax, BYTE PTR _b$1[ebp]
	test	eax, eax
	je	SHORT $LN61@InsertInto
	push	618					; 0000026aH
	push	OFFSET ??_C@_1EO@DHNPHPFC@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAb?$AAp?$AAl?$AAu?$AAs@
	push	OFFSET ??_C@_1BC@GBMFMLDI@?$AAb?$AA?$DN?$AA?$DN?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN61@InsertInto:

; 619  : 				}
; 620  : 				else

	jmp	SHORT $LN1@InsertInto
$LN2@InsertInto:

; 621  : 					insertionIndex=0;

	mov	DWORD PTR _insertionIndex$[ebp], 0
$LN1@InsertInto:

; 622  : 				InsertIntoNode(key, leafData, insertionIndex, nodeData, cur, returnAction);

	mov	eax, DWORD PTR _returnAction$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nodeData$[ebp]
	push	edx
	mov	eax, DWORD PTR _insertionIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _leafData$[ebp]
	push	ecx
	movzx	edx, WORD PTR _key$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertIntoNode@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEPAU?$Page@GPAUInternalPacket@@$0CA@@2@GABQAUInternalPacket@@HPAU32@1PAUReturnAction@12@@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::InsertIntoNode
$LN17@InsertInto:

; 623  : 			}
; 624  : 
; 625  : 			newPage->size=destIndex;

	mov	eax, DWORD PTR _newPage$6[ebp]
	mov	ecx, DWORD PTR _destIndex$5[ebp]
	mov	DWORD PTR [eax+1], ecx

; 626  : 
; 627  : 			return newPage;

	mov	eax, DWORD PTR _newPage$6[ebp]
	jmp	SHORT $LN59@InsertInto
$LN44@InsertInto:

; 628  : 		}
; 629  : 
; 630  : 		return 0;

	xor	eax, eax
$LN59@InsertInto:

; 631  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 288				; 00000120H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?InsertIntoNode@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEPAU?$Page@GPAUInternalPacket@@$0CA@@2@GABQAUInternalPacket@@HPAU32@1PAUReturnAction@12@@Z ENDP ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::InsertIntoNode
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?RotateLeft@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEXPAU?$Page@GPAUInternalPacket@@$0CA@@2@HPAUReturnAction@12@@Z
_TEXT	SEGMENT
_i$1 = -44						; size = 4
_source$ = -32						; size = 4
_dest$ = -20						; size = 4
_this$ = -8						; size = 4
_cur$ = 8						; size = 4
_childIndex$ = 12					; size = 4
_returnAction$ = 16					; size = 4
?RotateLeft@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEXPAU?$Page@GPAUInternalPacket@@$0CA@@2@HPAUReturnAction@12@@Z PROC ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::RotateLeft, COMDAT
; _this$ = ecx

; 641  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		Page<KeyType, DataType, order> *dest = cur->children[childIndex-1];

	mov	eax, DWORD PTR _childIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+201]
	mov	DWORD PTR _dest$[ebp], edx

; 643  : 		Page<KeyType, DataType, order> *source = cur->children[childIndex];

	mov	eax, DWORD PTR _childIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+205]
	mov	DWORD PTR _source$[ebp], edx

; 644  : 		returnAction->key1=source->keys[0];

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _returnAction$[ebp]
	mov	eax, DWORD PTR _source$[ebp]
	mov	cx, WORD PTR [eax+ecx+5]
	mov	WORD PTR [edx], cx

; 645  : 		dest->keys[dest->size]=source->keys[0];

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR [edx+1]
	mov	edx, DWORD PTR _dest$[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	cx, WORD PTR [esi+ecx+5]
	mov	WORD PTR [edx+eax*2+5], cx

; 646  : 		dest->data[dest->size]=source->data[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR [edx+1]
	mov	edx, DWORD PTR _dest$[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+69]
	mov	DWORD PTR [edx+eax*4+69], ecx

; 647  : 		dest->size++;

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	add	ecx, 1
	mov	edx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR [edx+1], ecx

; 648  : 		for (int i=0; i < source->size-1; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN3@RotateLeft
$LN2@RotateLeft:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN3@RotateLeft:
	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	sub	ecx, 1
	cmp	DWORD PTR _i$1[ebp], ecx
	jge	SHORT $LN1@RotateLeft

; 649  : 		{
; 650  : 			source->keys[i]=source->keys[i+1];

	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _source$[ebp]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	dx, WORD PTR [esi+edx*2+7]
	mov	WORD PTR [ecx+eax*2+5], dx

; 651  : 			source->data[i]=source->data[i+1];

	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _source$[ebp]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+73]
	mov	DWORD PTR [ecx+eax*4+69], edx

; 652  : 		}

	jmp	SHORT $LN2@RotateLeft
$LN1@RotateLeft:

; 653  : 		source->size--;

	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	sub	ecx, 1
	mov	edx, DWORD PTR _source$[ebp]
	mov	DWORD PTR [edx+1], ecx

; 654  : 		cur->keys[childIndex-1]=source->keys[0];

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _childIndex$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	cx, WORD PTR [esi+ecx+5]
	mov	WORD PTR [eax+edx*2+3], cx

; 655  : 		returnAction->key2=source->keys[0];

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _returnAction$[ebp]
	mov	eax, DWORD PTR _source$[ebp]
	mov	cx, WORD PTR [eax+ecx+5]
	mov	WORD PTR [edx+2], cx

; 656  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?RotateLeft@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEXPAU?$Page@GPAUInternalPacket@@$0CA@@2@HPAUReturnAction@12@@Z ENDP ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::RotateLeft
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?RotateRight@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEXPAU?$Page@GPAUInternalPacket@@$0CA@@2@HPAUReturnAction@12@@Z
_TEXT	SEGMENT
_i$1 = -44						; size = 4
_source$ = -32						; size = 4
_dest$ = -20						; size = 4
_this$ = -8						; size = 4
_cur$ = 8						; size = 4
_childIndex$ = 12					; size = 4
_returnAction$ = 16					; size = 4
?RotateRight@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEXPAU?$Page@GPAUInternalPacket@@$0CA@@2@HPAUReturnAction@12@@Z PROC ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::RotateRight, COMDAT
; _this$ = ecx

; 666  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 667  : 		Page<KeyType, DataType, order> *dest = cur->children[childIndex+1];

	mov	eax, DWORD PTR _childIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+209]
	mov	DWORD PTR _dest$[ebp], edx

; 668  : 		Page<KeyType, DataType, order> *source = cur->children[childIndex];

	mov	eax, DWORD PTR _childIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+205]
	mov	DWORD PTR _source$[ebp], edx

; 669  : 		returnAction->key1=dest->keys[0];

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _returnAction$[ebp]
	mov	eax, DWORD PTR _dest$[ebp]
	mov	cx, WORD PTR [eax+ecx+5]
	mov	WORD PTR [edx], cx

; 670  : 		for (int i= dest->size; i > 0; i--)

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR _i$1[ebp], ecx
	jmp	SHORT $LN3@RotateRigh
$LN2@RotateRigh:
	mov	eax, DWORD PTR _i$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN3@RotateRigh:
	cmp	DWORD PTR _i$1[ebp], 0
	jle	SHORT $LN1@RotateRigh

; 671  : 		{
; 672  : 			dest->keys[i]=dest->keys[i-1];

	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _dest$[ebp]
	mov	dx, WORD PTR [esi+edx*2+3]
	mov	WORD PTR [ecx+eax*2+5], dx

; 673  : 			dest->data[i]=dest->data[i-1];

	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+65]
	mov	DWORD PTR [ecx+eax*4+69], edx

; 674  : 		}

	jmp	SHORT $LN2@RotateRigh
$LN1@RotateRigh:

; 675  : 		dest->keys[0]=source->keys[source->size-1];

	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	mov	edx, 2
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dest$[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	cx, WORD PTR [esi+ecx*2+3]
	mov	WORD PTR [edx+eax+5], cx

; 676  : 		dest->data[0]=source->data[source->size-1];

	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dest$[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4+65]
	mov	DWORD PTR [edx+eax+69], ecx

; 677  : 		dest->size++;

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	add	ecx, 1
	mov	edx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR [edx+1], ecx

; 678  : 		source->size--;

	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	sub	ecx, 1
	mov	edx, DWORD PTR _source$[ebp]
	mov	DWORD PTR [edx+1], ecx

; 679  : 
; 680  : 		cur->keys[childIndex]=dest->keys[0];

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _childIndex$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	esi, DWORD PTR _dest$[ebp]
	mov	cx, WORD PTR [esi+ecx+5]
	mov	WORD PTR [eax+edx*2+5], cx

; 681  : 		returnAction->key2=dest->keys[0];

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _returnAction$[ebp]
	mov	eax, DWORD PTR _dest$[ebp]
	mov	cx, WORD PTR [eax+ecx+5]
	mov	WORD PTR [edx+2], cx

; 682  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?RotateRight@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEXPAU?$Page@GPAUInternalPacket@@$0CA@@2@HPAUReturnAction@12@@Z ENDP ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::RotateRight
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?CanRotateRight@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAE_NPAU?$Page@GPAUInternalPacket@@$0CA@@2@H@Z
_TEXT	SEGMENT
tv72 = -208						; size = 4
_this$ = -8						; size = 4
_cur$ = 8						; size = 4
_childIndex$ = 12					; size = 4
?CanRotateRight@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAE_NPAU?$Page@GPAUInternalPacket@@$0CA@@2@H@Z PROC ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::CanRotateRight, COMDAT
; _this$ = ecx

; 660  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return childIndex < cur->size && cur->children[childIndex+1]->size<order;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _childIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+1]
	jge	SHORT $LN3@CanRotateR
	mov	edx, DWORD PTR _childIndex$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+209]
	cmp	DWORD PTR [ecx+1], 32			; 00000020H
	jge	SHORT $LN3@CanRotateR
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN4@CanRotateR
$LN3@CanRotateR:
	mov	DWORD PTR tv72[ebp], 0
$LN4@CanRotateR:
	mov	al, BYTE PTR tv72[ebp]

; 662  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?CanRotateRight@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAE_NPAU?$Page@GPAUInternalPacket@@$0CA@@2@H@Z ENDP ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::CanRotateRight
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?CanRotateLeft@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAE_NPAU?$Page@GPAUInternalPacket@@$0CA@@2@H@Z
_TEXT	SEGMENT
tv71 = -208						; size = 4
_this$ = -8						; size = 4
_cur$ = 8						; size = 4
_childIndex$ = 12					; size = 4
?CanRotateLeft@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAE_NPAU?$Page@GPAUInternalPacket@@$0CA@@2@H@Z PROC ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::CanRotateLeft, COMDAT
; _this$ = ecx

; 635  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 636  : 		return childIndex>0 && cur->children[childIndex-1]->size<order;

	cmp	DWORD PTR _childIndex$[ebp], 0
	jle	SHORT $LN3@CanRotateL
	mov	eax, DWORD PTR _childIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+201]
	cmp	DWORD PTR [edx+1], 32			; 00000020H
	jge	SHORT $LN3@CanRotateL
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN4@CanRotateL
$LN3@CanRotateL:
	mov	DWORD PTR tv71[ebp], 0
$LN4@CanRotateL:
	mov	al, BYTE PTR tv71[ebp]

; 637  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?CanRotateLeft@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAE_NPAU?$Page@GPAUInternalPacket@@$0CA@@2@H@Z ENDP ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::CanRotateLeft
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?GetIndexOf@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IBE_NGPAU?$Page@GPAUInternalPacket@@$0CA@@2@PAH@Z
_TEXT	SEGMENT
_lowerBound$ = -44					; size = 4
_upperBound$ = -32					; size = 4
_index$ = -20						; size = 4
_this$ = -8						; size = 4
_key$ = 8						; size = 2
_page$ = 12						; size = 4
_out$ = 16						; size = 4
?GetIndexOf@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IBE_NGPAU?$Page@GPAUInternalPacket@@$0CA@@2@PAH@Z PROC ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::GetIndexOf, COMDAT
; _this$ = ecx

; 895  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 896  : 		assert(page->size>0);

	mov	eax, DWORD PTR _page$[ebp]
	cmp	DWORD PTR [eax+1], 0
	jg	SHORT $LN10@GetIndexOf
	push	896					; 00000380H
	push	OFFSET ??_C@_1EO@DHNPHPFC@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAb?$AAp?$AAl?$AAu?$AAs@
	push	OFFSET ??_C@_1BK@CAFOCCOP@?$AAp?$AAa?$AAg?$AAe?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$DO?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN10@GetIndexOf:

; 897  : 		int index, upperBound, lowerBound;
; 898  : 		upperBound=page->size-1;

	mov	eax, DWORD PTR _page$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	sub	ecx, 1
	mov	DWORD PTR _upperBound$[ebp], ecx

; 899  : 		lowerBound=0;

	mov	DWORD PTR _lowerBound$[ebp], 0

; 900  : 		index = page->size/2;

	mov	eax, DWORD PTR _page$[ebp]
	mov	eax, DWORD PTR [eax+1]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _index$[ebp], eax
$LN7@GetIndexOf:

; 901  : 
; 902  : #ifdef _MSC_VER
; 903  : #pragma warning( disable : 4127 ) // warning C4127: conditional expression is constant
; 904  : #endif
; 905  : 		while (1)

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN8@GetIndexOf

; 906  : 		{
; 907  : 			if (key==page->keys[index])

	movzx	eax, WORD PTR _key$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	mov	edx, DWORD PTR _page$[ebp]
	movzx	ecx, WORD PTR [edx+ecx*2+5]
	cmp	eax, ecx
	jne	SHORT $LN5@GetIndexOf

; 908  : 			{
; 909  : 				*out=index;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	mov	DWORD PTR [eax], ecx

; 910  : 				return true;

	mov	al, 1
	jmp	SHORT $LN8@GetIndexOf
	jmp	SHORT $LN4@GetIndexOf
$LN5@GetIndexOf:

; 911  : 			}
; 912  : 			else if (key<page->keys[index])

	movzx	eax, WORD PTR _key$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	mov	edx, DWORD PTR _page$[ebp]
	movzx	ecx, WORD PTR [edx+ecx*2+5]
	cmp	eax, ecx
	jge	SHORT $LN3@GetIndexOf

; 913  : 				upperBound=index-1;

	mov	eax, DWORD PTR _index$[ebp]
	sub	eax, 1
	mov	DWORD PTR _upperBound$[ebp], eax

; 914  : 			else

	jmp	SHORT $LN4@GetIndexOf
$LN3@GetIndexOf:

; 915  : 				lowerBound=index+1;

	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 1
	mov	DWORD PTR _lowerBound$[ebp], eax
$LN4@GetIndexOf:

; 916  : 
; 917  : 			index=lowerBound+(upperBound-lowerBound)/2;

	mov	eax, DWORD PTR _upperBound$[ebp]
	sub	eax, DWORD PTR _lowerBound$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _lowerBound$[ebp]
	mov	DWORD PTR _index$[ebp], eax

; 918  : 
; 919  : 			if (lowerBound>upperBound)

	mov	eax, DWORD PTR _lowerBound$[ebp]
	cmp	eax, DWORD PTR _upperBound$[ebp]
	jle	SHORT $LN1@GetIndexOf

; 920  : 			{
; 921  : 				*out=lowerBound;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _lowerBound$[ebp]
	mov	DWORD PTR [eax], ecx

; 922  : 				return false; // No match

	xor	al, al
	jmp	SHORT $LN8@GetIndexOf
$LN1@GetIndexOf:

; 923  : 			}
; 924  : 		}

	jmp	SHORT $LN7@GetIndexOf
$LN8@GetIndexOf:

; 925  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetIndexOf@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IBE_NGPAU?$Page@GPAUInternalPacket@@$0CA@@2@PAH@Z ENDP ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::GetIndexOf
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?FreePages@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEXXZ
_TEXT	SEGMENT
_i$ = -68						; size = 4
_ptr$ = -56						; size = 4
_queue$ = -44						; size = 16
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?FreePages@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEXXZ PROC ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::FreePages, COMDAT
; _this$ = ecx

; 928  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?FreePages@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 929  : 		DataStructures::Queue<DataStructures::Page<KeyType, DataType, order> *> queue;

	lea	ecx, DWORD PTR _queue$[ebp]
	call	??0?$Queue@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::Queue<DataStructures::Page<unsigned short,InternalPacket *,32> *>::Queue<DataStructures::Page<unsigned short,InternalPacket *,32> *>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 930  : 		DataStructures::Page<KeyType, DataType, order> *ptr;
; 931  : 		int i;
; 932  : 		queue.Push(root);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR _queue$[ebp]
	call	?Push@?$Queue@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEXABQAU?$Page@GPAUInternalPacket@@$0CA@@2@@Z ; DataStructures::Queue<DataStructures::Page<unsigned short,InternalPacket *,32> *>::Push
$LN6@FreePages:

; 933  : 		while (queue.Size())

	lea	ecx, DWORD PTR _queue$[ebp]
	call	?Size@?$Queue@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::Queue<DataStructures::Page<unsigned short,InternalPacket *,32> *>::Size
	test	eax, eax
	je	SHORT $LN5@FreePages

; 934  : 		{
; 935  : 			ptr=queue.Pop();

	lea	ecx, DWORD PTR _queue$[ebp]
	call	?Pop@?$Queue@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEPAU?$Page@GPAUInternalPacket@@$0CA@@2@XZ ; DataStructures::Queue<DataStructures::Page<unsigned short,InternalPacket *,32> *>::Pop
	mov	DWORD PTR _ptr$[ebp], eax

; 936  : 			if (ptr->isLeaf==false)

	mov	eax, DWORD PTR _ptr$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN4@FreePages

; 937  : 			{
; 938  : 				for (i=0; i < ptr->size+1; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@FreePages
$LN2@FreePages:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@FreePages:
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	add	ecx, 1
	cmp	DWORD PTR _i$[ebp], ecx
	jge	SHORT $LN4@FreePages

; 939  : 					queue.Push(ptr->children[i]);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _ptr$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4+205]
	push	edx
	lea	ecx, DWORD PTR _queue$[ebp]
	call	?Push@?$Queue@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEXABQAU?$Page@GPAUInternalPacket@@$0CA@@2@@Z ; DataStructures::Queue<DataStructures::Page<unsigned short,InternalPacket *,32> *>::Push
	jmp	SHORT $LN2@FreePages
$LN4@FreePages:

; 940  : 			}			
; 941  : 			pagePool.Release(ptr);

	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Release@?$MemoryPool@U?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEXPAU?$Page@GPAUInternalPacket@@$0CA@@2@@Z ; DataStructures::MemoryPool<DataStructures::Page<unsigned short,InternalPacket *,32> >::Release

; 942  : 			memset(ptr,0,sizeof(root));

	push	4
	push	0
	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 943  : 		};

	jmp	SHORT $LN6@FreePages
$LN5@FreePages:

; 944  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _queue$[ebp]
	call	??1?$Queue@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::Queue<DataStructures::Page<unsigned short,InternalPacket *,32> *>::~Queue<DataStructures::Page<unsigned short,InternalPacket *,32> *>
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN13@FreePages
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN13@FreePages:
	DD	1
	DD	$LN12@FreePages
$LN12@FreePages:
	DD	-44					; ffffffd4H
	DD	16					; 00000010H
	DD	$LN10@FreePages
$LN10@FreePages:
	DB	113					; 00000071H
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FreePages@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEXXZ$0:
	lea	ecx, DWORD PTR _queue$[ebp]
	jmp	??1?$Queue@PAU?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::Queue<DataStructures::Page<unsigned short,InternalPacket *,32> *>::~Queue<DataStructures::Page<unsigned short,InternalPacket *,32> *>
__ehhandler$?FreePages@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-268]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?FreePages@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?FreePages@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEXXZ ENDP ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::FreePages
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?DeleteFromPageAtIndex@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEXHPAU?$Page@GPAUInternalPacket@@$0CA@@2@@Z
_TEXT	SEGMENT
_i$ = -20						; size = 4
_this$ = -8						; size = 4
_index$ = 8						; size = 4
_cur$ = 12						; size = 4
?DeleteFromPageAtIndex@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEXHPAU?$Page@GPAUInternalPacket@@$0CA@@2@@Z PROC ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::DeleteFromPageAtIndex, COMDAT
; _this$ = ecx

; 139  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		int i;
; 141  : 		for (i=index; i < cur->size-1; i++)

	mov	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN11@DeleteFrom
$LN10@DeleteFrom:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN11@DeleteFrom:
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	sub	ecx, 1
	cmp	DWORD PTR _i$[ebp], ecx
	jge	SHORT $LN9@DeleteFrom

; 142  : 			cur->keys[i]=cur->keys[i+1];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	dx, WORD PTR [esi+edx*2+7]
	mov	WORD PTR [ecx+eax*2+5], dx
	jmp	SHORT $LN10@DeleteFrom
$LN9@DeleteFrom:

; 143  : 		if (cur->isLeaf)

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN8@DeleteFrom

; 144  : 		{
; 145  : 			for (i=index; i < cur->size-1; i++)

	mov	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN7@DeleteFrom
$LN6@DeleteFrom:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@DeleteFrom:
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	sub	ecx, 1
	cmp	DWORD PTR _i$[ebp], ecx
	jge	SHORT $LN5@DeleteFrom

; 146  : 				cur->data[i]=cur->data[i+1];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+73]
	mov	DWORD PTR [ecx+eax*4+69], edx
	jmp	SHORT $LN6@DeleteFrom
$LN5@DeleteFrom:

; 147  : 		}
; 148  : 		else

	jmp	SHORT $LN4@DeleteFrom
$LN8@DeleteFrom:

; 149  : 		{
; 150  : 			for (i=index; i < cur->size-1; i++)

	mov	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN3@DeleteFrom
$LN2@DeleteFrom:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@DeleteFrom:
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	sub	ecx, 1
	cmp	DWORD PTR _i$[ebp], ecx
	jge	SHORT $LN4@DeleteFrom

; 151  : 				cur->children[i+1]=cur->children[i+2];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+213]
	mov	DWORD PTR [ecx+eax*4+209], edx
	jmp	SHORT $LN2@DeleteFrom
$LN4@DeleteFrom:

; 152  : 		}
; 153  : 		cur->size--;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	sub	ecx, 1
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx+1], ecx

; 154  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?DeleteFromPageAtIndex@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEXHPAU?$Page@GPAUInternalPacket@@$0CA@@2@@Z ENDP ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::DeleteFromPageAtIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?GetListHead@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QBEPAU?$Page@GPAUInternalPacket@@$0CA@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetListHead@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QBEPAU?$Page@GPAUInternalPacket@@$0CA@@2@XZ PROC ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::GetListHead, COMDAT
; _this$ = ecx

; 947  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 948  : 		return leftmostLeaf;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]

; 949  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetListHead@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QBEPAU?$Page@GPAUInternalPacket@@$0CA@@2@XZ ENDP ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::GetListHead
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?IsEmpty@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QBE_NXZ
_TEXT	SEGMENT
tv66 = -208						; size = 4
_this$ = -8						; size = 4
?IsEmpty@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QBE_NXZ PROC ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::IsEmpty, COMDAT
; _this$ = ecx

; 890  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 891  : 		return root==0;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN3@IsEmpty
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@IsEmpty
$LN3@IsEmpty:
	mov	DWORD PTR tv66[ebp], 0
$LN4@IsEmpty:
	mov	al, BYTE PTR tv66[ebp]

; 892  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsEmpty@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QBE_NXZ ENDP ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::IsEmpty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?Size@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_cur$ = -32						; size = 4
_count$ = -20						; size = 4
_this$ = -8						; size = 4
?Size@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QBEIXZ PROC ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::Size, COMDAT
; _this$ = ecx

; 878  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 879  : 		int count=0;

	mov	DWORD PTR _count$[ebp], 0

; 880  : 		DataStructures::Page<KeyType, DataType, order> *cur = GetListHead();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetListHead@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QBEPAU?$Page@GPAUInternalPacket@@$0CA@@2@XZ ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::GetListHead
	mov	DWORD PTR _cur$[ebp], eax
$LN2@Size:

; 881  : 		while (cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN1@Size

; 882  : 		{
; 883  : 			count+=cur->size;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	add	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR _count$[ebp], ecx

; 884  : 			cur=cur->next;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+197]
	mov	DWORD PTR _cur$[ebp], ecx

; 885  : 		}

	jmp	SHORT $LN2@Size
$LN1@Size:

; 886  : 		return count;

	mov	eax, DWORD PTR _count$[ebp]

; 887  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QBEIXZ ENDP ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?Clear@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Clear@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QAEXXZ PROC ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::Clear, COMDAT
; _this$ = ecx

; 868  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 869  : 		if (root)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN2@Clear

; 870  : 		{
; 871  : 			FreePages();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreePages@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEXXZ ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::FreePages

; 872  : 			leftmostLeaf=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 873  : 			root=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0
$LN2@Clear:

; 874  : 		}
; 875  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QAEXXZ ENDP ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?Preallocate@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_size$ = 8						; size = 4
?Preallocate@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QAEXH@Z PROC ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::Preallocate, COMDAT
; _this$ = ecx

; 856  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 857  : 		pagePool.Preallocate(size);

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Preallocate@?$MemoryPool@U?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEXI@Z ; DataStructures::MemoryPool<DataStructures::Page<unsigned short,InternalPacket *,32> >::Preallocate

; 858  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Preallocate@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QAEXH@Z ENDP ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::Preallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?Insert@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QAE_NGABQAUInternalPacket@@@Z
_TEXT	SEGMENT
_newRoot$1 = -72					; size = 4
_newKey$2 = -60						; size = 2
_newPage$3 = -48					; size = 4
_returnAction$4 = -36					; size = 8
_success$5 = -17					; size = 1
_this$ = -8						; size = 4
_key$ = 8						; size = 2
_data$ = 12						; size = 4
?Insert@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QAE_NGABQAUInternalPacket@@@Z PROC ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::Insert, COMDAT
; _this$ = ecx

; 808  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-268]
	mov	ecx, 67					; 00000043H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 809  : 		if (root==0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	$LN6@Insert

; 810  : 		{
; 811  : 			// Allocate root and make root a leaf
; 812  : 			root = pagePool.Allocate();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Allocate@?$MemoryPool@U?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEPAU?$Page@GPAUInternalPacket@@$0CA@@2@XZ ; DataStructures::MemoryPool<DataStructures::Page<unsigned short,InternalPacket *,32> >::Allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 813  : 			root->isLeaf=true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	BYTE PTR [ecx], 1

; 814  : 			leftmostLeaf=root;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+20], edx

; 815  : 			root->size=1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+1], 1

; 816  : 			root->keys[0]=key;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, 2
	imul	eax, edx, 0
	mov	dx, WORD PTR _key$[ebp]
	mov	WORD PTR [ecx+eax+5], dx

; 817  : 			root->data[0]=data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _data$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+eax+69], edx

; 818  : 			root->next=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+197], 0

; 819  : 			root->previous=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+201], 0

; 820  : 		}
; 821  : 		else

	jmp	$LN5@Insert
$LN6@Insert:

; 822  : 		{
; 823  : 			bool success=true;

	mov	BYTE PTR _success$5[ebp], 1

; 824  : 			ReturnAction returnAction;
; 825  : 			returnAction.action=ReturnAction::NO_ACTION;

	mov	DWORD PTR _returnAction$4[ebp+4], 0

; 826  : 			Page<KeyType, DataType, order>* newPage = InsertBranchDown(key, data, root, &returnAction, &success);

	lea	eax, DWORD PTR _success$5[ebp]
	push	eax
	lea	ecx, DWORD PTR _returnAction$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	movzx	edx, WORD PTR _key$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertBranchDown@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEPAU?$Page@GPAUInternalPacket@@$0CA@@2@GABQAUInternalPacket@@PAU32@PAUReturnAction@12@PA_N@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::InsertBranchDown
	mov	DWORD PTR _newPage$3[ebp], eax

; 827  : 			if (success==false)

	movzx	eax, BYTE PTR _success$5[ebp]
	test	eax, eax
	jne	SHORT $LN4@Insert

; 828  : 				return false;

	xor	al, al
	jmp	$LN7@Insert
$LN4@Insert:

; 829  : 			if (newPage)

	cmp	DWORD PTR _newPage$3[ebp], 0
	je	$LN5@Insert

; 830  : 			{
; 831  : 				KeyType newKey;
; 832  : 				if (newPage->isLeaf==false)

	mov	eax, DWORD PTR _newPage$3[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@Insert

; 833  : 				{
; 834  : 					// One key is pushed up through the stack.  I store that at keys[0] but it has to be removed for the page to be correct
; 835  : 					assert(returnAction.action==ReturnAction::PUSH_KEY_TO_PARENT);

	cmp	DWORD PTR _returnAction$4[ebp+4], 2
	je	SHORT $LN9@Insert
	push	835					; 00000343H
	push	OFFSET ??_C@_1EO@DHNPHPFC@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAb?$AAp?$AAl?$AAu?$AAs@
	push	OFFSET ??_C@_1GM@PECFPFGO@?$AAr?$AAe?$AAt?$AAu?$AAr?$AAn?$AAA?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?4?$AAa?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$DN?$AA?$DN?$AAR?$AAe?$AAt?$AAu?$AAr?$AAn?$AAA?$AAc?$AAt?$AAi?$AAo@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN9@Insert:

; 836  : 					newKey=returnAction.key1;

	mov	ax, WORD PTR _returnAction$4[ebp]
	mov	WORD PTR _newKey$2[ebp], ax

; 837  : 					newPage->size--;

	mov	eax, DWORD PTR _newPage$3[ebp]
	mov	ecx, DWORD PTR [eax+1]
	sub	ecx, 1
	mov	edx, DWORD PTR _newPage$3[ebp]
	mov	DWORD PTR [edx+1], ecx

; 838  : 				}
; 839  : 				else

	jmp	SHORT $LN1@Insert
$LN2@Insert:

; 840  : 					 newKey = newPage->keys[0];

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _newPage$3[ebp]
	mov	ax, WORD PTR [edx+ecx+5]
	mov	WORD PTR _newKey$2[ebp], ax
$LN1@Insert:

; 841  : 				// propagate the root
; 842  : 				Page<KeyType, DataType, order>* newRoot = pagePool.Allocate();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Allocate@?$MemoryPool@U?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEPAU?$Page@GPAUInternalPacket@@$0CA@@2@XZ ; DataStructures::MemoryPool<DataStructures::Page<unsigned short,InternalPacket *,32> >::Allocate
	mov	DWORD PTR _newRoot$1[ebp], eax

; 843  : 				newRoot->isLeaf=false;

	mov	eax, DWORD PTR _newRoot$1[ebp]
	mov	BYTE PTR [eax], 0

; 844  : 				newRoot->size=1;

	mov	eax, DWORD PTR _newRoot$1[ebp]
	mov	DWORD PTR [eax+1], 1

; 845  : 				newRoot->keys[0]=newKey;

	mov	eax, 2
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _newRoot$1[ebp]
	mov	ax, WORD PTR _newKey$2[ebp]
	mov	WORD PTR [edx+ecx+5], ax

; 846  : 				newRoot->children[0]=root;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _newRoot$1[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+ecx+205], eax

; 847  : 				newRoot->children[1]=newPage;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _newRoot$1[ebp]
	mov	edx, DWORD PTR _newPage$3[ebp]
	mov	DWORD PTR [ecx+eax+205], edx

; 848  : 				root=newRoot;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newRoot$1[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN5@Insert:

; 849  : 			}
; 850  : 		}
; 851  : 
; 852  : 		return true;

	mov	al, 1
$LN7@Insert:

; 853  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN13@Insert
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 268				; 0000010cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$LN13@Insert:
	DD	2
	DD	$LN12@Insert
$LN12@Insert:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN10@Insert
	DD	-36					; ffffffdcH
	DD	8
	DD	$LN11@Insert
$LN11@Insert:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	110					; 0000006eH
	DB	65					; 00000041H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
$LN10@Insert:
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	99					; 00000063H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	115					; 00000073H
	DB	0
?Insert@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QAE_NGABQAUInternalPacket@@@Z ENDP ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::Insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?Delete@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QAE_NGAAPAUInternalPacket@@@Z
_TEXT	SEGMENT
_oldRoot$1 = -60					; size = 4
_underflow$ = -45					; size = 1
_childIndex$ = -36					; size = 4
_returnAction$ = -24					; size = 8
_this$ = -8						; size = 4
_key$ = 8						; size = 2
_out$ = 12						; size = 4
?Delete@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QAE_NGAAPAUInternalPacket@@@Z PROC ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::Delete, COMDAT
; _this$ = ecx

; 163  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 164  : 		if (root==0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN7@Delete

; 165  : 			return false;

	xor	al, al
	jmp	$LN8@Delete
$LN7@Delete:

; 166  : 
; 167  : 		ReturnAction returnAction;
; 168  : 		returnAction.action=ReturnAction::NO_ACTION;

	mov	DWORD PTR _returnAction$[ebp+4], 0

; 169  : 		int childIndex;
; 170  : 		bool underflow=false;

	mov	BYTE PTR _underflow$[ebp], 0

; 171  : 		if (root==leftmostLeaf)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+16]
	cmp	edx, DWORD PTR [ecx+20]
	jne	$LN6@Delete

; 172  : 		{
; 173  : 			if (GetIndexOf(key, root, &childIndex)==false)

	lea	eax, DWORD PTR _childIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	movzx	eax, WORD PTR _key$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexOf@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IBE_NGPAU?$Page@GPAUInternalPacket@@$0CA@@2@PAH@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::GetIndexOf
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN5@Delete

; 174  : 				return false;

	xor	al, al
	jmp	$LN8@Delete
$LN5@Delete:

; 175  : 			out=root->data[childIndex];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _childIndex$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+69]
	mov	DWORD PTR [edx], ecx

; 176  : 			DeleteFromPageAtIndex(childIndex,root);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _childIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DeleteFromPageAtIndex@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAEXHPAU?$Page@GPAUInternalPacket@@$0CA@@2@@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::DeleteFromPageAtIndex

; 177  : 			if (root->size==0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx+1], 0
	jne	SHORT $LN4@Delete

; 178  : 			{
; 179  : 				pagePool.Release(root);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Release@?$MemoryPool@U?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEXPAU?$Page@GPAUInternalPacket@@$0CA@@2@@Z ; DataStructures::MemoryPool<DataStructures::Page<unsigned short,InternalPacket *,32> >::Release

; 180  : 				memset(root,0,sizeof(root));

	push	4
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 181  : 				root=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 182  : 				leftmostLeaf=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0
$LN4@Delete:

; 183  : 			}
; 184  : 			return true;

	mov	al, 1
	jmp	$LN8@Delete
	jmp	SHORT $LN3@Delete
$LN6@Delete:

; 185  : 		}
; 186  : 		else if (FindDeleteRebalance(key, root, &underflow,root->keys[0], &returnAction, out)==false)

	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	lea	ecx, DWORD PTR _returnAction$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, 2
	imul	edx, ecx, 0
	movzx	eax, WORD PTR [eax+edx+5]
	push	eax
	lea	ecx, DWORD PTR _underflow$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	movzx	ecx, WORD PTR _key$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindDeleteRebalance@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@IAE_NGPAU?$Page@GPAUInternalPacket@@$0CA@@2@PA_NGPAUReturnAction@12@AAPAUInternalPacket@@@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::FindDeleteRebalance
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@Delete

; 187  : 			return false;

	xor	al, al
	jmp	SHORT $LN8@Delete
$LN3@Delete:

; 188  : 
; 189  : //		assert(returnAction.action==ReturnAction::NO_ACTION);
; 190  : 
; 191  : 		if (underflow && root->size==0)

	movzx	eax, BYTE PTR _underflow$[ebp]
	test	eax, eax
	je	SHORT $LN1@Delete
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx+1], 0
	jne	SHORT $LN1@Delete

; 192  : 		{
; 193  : 			// Move the root down.
; 194  : 			Page<KeyType, DataType, order> *oldRoot=root;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _oldRoot$1[ebp], ecx

; 195  : 			root=root->children[0];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax+205]
	mov	DWORD PTR [edx+16], eax

; 196  : 			pagePool.Release(oldRoot);

	mov	eax, DWORD PTR _oldRoot$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Release@?$MemoryPool@U?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAEXPAU?$Page@GPAUInternalPacket@@$0CA@@2@@Z ; DataStructures::MemoryPool<DataStructures::Page<unsigned short,InternalPacket *,32> >::Release

; 197  : 			memset(oldRoot,0,sizeof(root));

	push	4
	push	0
	mov	eax, DWORD PTR _oldRoot$1[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN1@Delete:

; 198  : 		}		
; 199  : 	
; 200  : 		return true;

	mov	al, 1
$LN8@Delete:

; 201  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN14@Delete
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN14@Delete:
	DD	3
	DD	$LN13@Delete
$LN13@Delete:
	DD	-24					; ffffffe8H
	DD	8
	DD	$LN10@Delete
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN11@Delete
	DD	-45					; ffffffd3H
	DD	1
	DD	$LN12@Delete
$LN12@Delete:
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	102					; 00000066H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	119					; 00000077H
	DB	0
$LN11@Delete:
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	100					; 00000064H
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	0
$LN10@Delete:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	110					; 0000006eH
	DB	65					; 00000041H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
?Delete@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QAE_NGAAPAUInternalPacket@@@Z ENDP ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::Delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ??1?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QAE@XZ PROC ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::~BPlusTree<unsigned short,InternalPacket *,32>, COMDAT
; _this$ = ecx

; 118  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 119  : 		Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QAEXXZ ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::Clear

; 120  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$MemoryPool@U?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::MemoryPool<DataStructures::Page<unsigned short,InternalPacket *,32> >::~MemoryPool<DataStructures::Page<unsigned short,InternalPacket *,32> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$MemoryPool@U?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::MemoryPool<DataStructures::Page<unsigned short,InternalPacket *,32> >::~MemoryPool<DataStructures::Page<unsigned short,InternalPacket *,32> >
__ehhandler$??1?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QAE@XZ ENDP ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::~BPlusTree<unsigned short,InternalPacket *,32>
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ??0?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QAE@XZ PROC ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::BPlusTree<unsigned short,InternalPacket *,32>, COMDAT
; _this$ = ecx

; 111  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$MemoryPool@U?$Page@GPAUInternalPacket@@$0CA@@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::MemoryPool<DataStructures::Page<unsigned short,InternalPacket *,32> >::MemoryPool<DataStructures::Page<unsigned short,InternalPacket *,32> >

; 112  : 		assert(order>1);
; 113  : 		root=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 114  : 		leftmostLeaf=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 115  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QAE@XZ ENDP ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::BPlusTree<unsigned short,InternalPacket *,32>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Clear@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEX_N@Z
_TEXT	SEGMENT
tv75 = -232						; size = 4
$T1 = -224						; size = 4
$T2 = -212						; size = 4
_this$ = -8						; size = 4
_doNotDeallocate$ = 8					; size = 1
?Clear@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEX_N@Z PROC ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::Clear, COMDAT
; _this$ = ecx

; 379  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  : 		if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Clear

; 381  : 			return;

	jmp	SHORT $LN3@Clear
$LN2@Clear:

; 382  : 
; 383  : 		if (allocation_size>512 && doNotDeallocate==false)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 512			; 00000200H
	jbe	SHORT $LN1@Clear
	movzx	eax, BYTE PTR _doNotDeallocate$[ebp]
	test	eax, eax
	jne	SHORT $LN1@Clear

; 384  : 		{
; 385  : 			delete [] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T1[ebp], edx
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN5@Clear
	push	3
	mov	ecx, DWORD PTR $T1[ebp]
	call	??_E?$RangeNode@G@DataStructures@@QAEPAXI@Z
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN6@Clear
$LN5@Clear:
	mov	DWORD PTR tv75[ebp], 0
$LN6@Clear:

; 386  : 			allocation_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 387  : 			listArray = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN1@Clear:

; 388  : 		}
; 389  : 		list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
$LN3@Clear:

; 390  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Clear@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEX_N@Z ENDP ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Size@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QBEIXZ PROC ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::Size, COMDAT
; _this$ = ecx

; 373  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 374  : 		return list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 375  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QBEIXZ ENDP ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Del@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_num$ = 8						; size = 4
?Del@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXI@Z PROC ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::Del, COMDAT
; _this$ = ecx

; 353  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 354  : 		// Delete the last elements on the list.  No compression needed
; 355  : #ifdef _DEBUG
; 356  : 		assert(list_size>=num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _num$[ebp]
	jae	SHORT $LN3@Del
	push	356					; 00000164H
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1BO@JBFMBKMD@?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$DO?$AA?$DN?$AAn?$AAu?$AAm?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@Del:

; 357  : #endif
; 358  : 		list_size-=num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _num$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 359  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Del@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXI@Z ENDP ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::Del
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?RemoveAtIndex@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
?RemoveAtIndex@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXI@Z PROC ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::RemoveAtIndex, COMDAT
; _this$ = ecx

; 333  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 334  : #ifdef _DEBUG
; 335  : 		assert( position < list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN4@RemoveAtIn
	push	335					; 0000014fH
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@RemoveAtIn:

; 336  : #endif
; 337  : 
; 338  : 		if ( position < list_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN2@RemoveAtIn

; 339  : 		{
; 340  : 			// Compress the array
; 341  : 			/*
; 342  : 			for ( unsigned int counter = position; counter < list_size - 1 ; ++counter )
; 343  : 			listArray[ counter ] = listArray[ counter + 1 ];
; 344  : 			*/
; 345  : 			memmove(listArray+position, listArray+position+1, (list_size-1-position) * sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	sub	ecx, DWORD PTR _position$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _position$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _position$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 346  : 
; 347  : 			Del();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Del@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXI@Z ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::Del
$LN2@RemoveAtIn:

; 348  : 		}
; 349  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveAtIndex@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXI@Z ENDP ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::RemoveAtIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Insert@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXU?$RangeNode@G@2@@Z
_TEXT	SEGMENT
tv140 = -292						; size = 4
tv129 = -292						; size = 4
$T2 = -284						; size = 4
$T3 = -272						; size = 4
$T4 = -260						; size = 4
$T5 = -248						; size = 4
$T6 = -236						; size = 4
_new_array$7 = -32					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_input$ = 8						; size = 4
?Insert@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXU?$RangeNode@G@2@@Z PROC ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::Insert, COMDAT
; _this$ = ecx

; 242  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Insert@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXU?$RangeNode@G@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 280				; 00000118H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-292]
	mov	ecx, 70					; 00000046H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 243  : 		// Reallocate list if necessary
; 244  : 
; 245  : 		if ( list_size == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	$LN3@Insert

; 246  : 		{
; 247  : 			// allocate twice the currently allocated memory
; 248  : 			list_type * new_array;
; 249  : 
; 250  : 			if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Insert

; 251  : 				allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 16			; 00000010H

; 252  : 			else

	jmp	SHORT $LN1@Insert
$LN2@Insert:

; 253  : 				allocation_size *= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN1@Insert:

; 254  : 
; 255  : 			new_array = new list_type [ allocation_size ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T2[ebp], ecx
	xor	ecx, ecx
	mov	eax, DWORD PTR $T2[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN6@Insert
	mov	ecx, DWORD PTR $T4[ebp]
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [ecx], edx
	push	OFFSET ??1?$RangeNode@G@DataStructures@@QAE@XZ ; DataStructures::RangeNode<unsigned short>::~RangeNode<unsigned short>
	push	OFFSET ??0?$RangeNode@G@DataStructures@@QAE@XZ ; DataStructures::RangeNode<unsigned short>::RangeNode<unsigned short>
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	push	4
	mov	ecx, DWORD PTR $T4[ebp]
	add	ecx, 4
	push	ecx
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	edx, DWORD PTR $T4[ebp]
	add	edx, 4
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN7@Insert
$LN6@Insert:
	mov	DWORD PTR tv129[ebp], 0
$LN7@Insert:
	mov	eax, DWORD PTR tv129[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR _new_array$7[ebp], ecx

; 256  : 
; 257  : 			// copy old array over
; 258  : 			//	for ( unsigned int counter = 0; counter < list_size; ++counter )
; 259  : 			//		new_array[ counter ] = listArray[ counter ];
; 260  : 
; 261  : 			// Don't call constructors, assignment operators, etc.
; 262  : 			memcpy(new_array, listArray, list_size*sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _new_array$7[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 263  : 
; 264  : 			// set old array to point to the newly allocated and twice as large array
; 265  : 			delete[] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T6[ebp], ecx
	mov	edx, DWORD PTR $T6[ebp]
	mov	DWORD PTR $T5[ebp], edx
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN8@Insert
	push	3
	mov	ecx, DWORD PTR $T5[ebp]
	call	??_E?$RangeNode@G@DataStructures@@QAEPAXI@Z
	mov	DWORD PTR tv140[ebp], eax
	jmp	SHORT $LN9@Insert
$LN8@Insert:
	mov	DWORD PTR tv140[ebp], 0
$LN9@Insert:

; 266  : 
; 267  : 			listArray = new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$7[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Insert:

; 268  : 		}
; 269  : 
; 270  : 		// Insert the new item at the correct spot
; 271  : 		listArray[ list_size ] = input;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _input$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 272  : 
; 273  : 		++list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 274  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _input$[ebp]
	call	??1?$RangeNode@G@DataStructures@@QAE@XZ	; DataStructures::RangeNode<unsigned short>::~RangeNode<unsigned short>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 292				; 00000124H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Insert@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXU?$RangeNode@G@2@@Z$0:
	lea	ecx, DWORD PTR _input$[ebp]
	jmp	??1?$RangeNode@G@DataStructures@@QAE@XZ	; DataStructures::RangeNode<unsigned short>::~RangeNode<unsigned short>
__unwindfunclet$?Insert@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXU?$RangeNode@G@2@@Z$1:
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?Insert@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXU?$RangeNode@G@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-296]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Insert@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXU?$RangeNode@G@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Insert@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXU?$RangeNode@G@2@@Z ENDP ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::Insert
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Insert@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXU?$RangeNode@G@2@I@Z
_TEXT	SEGMENT
tv146 = -292						; size = 4
tv135 = -292						; size = 4
$T2 = -284						; size = 4
$T3 = -272						; size = 4
$T4 = -260						; size = 4
$T5 = -248						; size = 4
$T6 = -236						; size = 4
_new_array$7 = -32					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_input$ = 8						; size = 4
_position$ = 12						; size = 4
?Insert@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXU?$RangeNode@G@2@I@Z PROC ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::Insert, COMDAT
; _this$ = ecx

; 194  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Insert@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXU?$RangeNode@G@2@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 280				; 00000118H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-292]
	mov	ecx, 70					; 00000046H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 195  : #ifdef _DEBUG
; 196  : 		assert( position <= list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jbe	SHORT $LN6@Insert
	push	196					; 000000c4H
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CM@FMCFHBCK@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN6@Insert:

; 197  : #endif
; 198  : 
; 199  : 		// Reallocate list if necessary
; 200  : 		if ( list_size == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	$LN3@Insert

; 201  : 		{
; 202  : 			// allocate twice the currently allocated memory
; 203  : 			list_type * new_array;
; 204  : 
; 205  : 			if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Insert

; 206  : 				allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 16			; 00000010H

; 207  : 			else

	jmp	SHORT $LN1@Insert
$LN2@Insert:

; 208  : 				allocation_size *= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN1@Insert:

; 209  : 
; 210  : 			new_array = new list_type [ allocation_size ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T2[ebp], ecx
	xor	ecx, ecx
	mov	eax, DWORD PTR $T2[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN7@Insert
	mov	ecx, DWORD PTR $T4[ebp]
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [ecx], edx
	push	OFFSET ??1?$RangeNode@G@DataStructures@@QAE@XZ ; DataStructures::RangeNode<unsigned short>::~RangeNode<unsigned short>
	push	OFFSET ??0?$RangeNode@G@DataStructures@@QAE@XZ ; DataStructures::RangeNode<unsigned short>::RangeNode<unsigned short>
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	push	4
	mov	ecx, DWORD PTR $T4[ebp]
	add	ecx, 4
	push	ecx
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	edx, DWORD PTR $T4[ebp]
	add	edx, 4
	mov	DWORD PTR tv135[ebp], edx
	jmp	SHORT $LN8@Insert
$LN7@Insert:
	mov	DWORD PTR tv135[ebp], 0
$LN8@Insert:
	mov	eax, DWORD PTR tv135[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR _new_array$7[ebp], ecx

; 211  : 
; 212  : 			// copy old array over
; 213  : 			//for ( unsigned int counter = 0; counter < list_size; ++counter )
; 214  : 			//	new_array[ counter ] = listArray[ counter ];
; 215  : 
; 216  : 			// Don't call constructors, assignment operators, etc.
; 217  : 			memcpy(new_array, listArray, list_size*sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _new_array$7[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 218  : 
; 219  : 			// set old array to point to the newly allocated and twice as large array
; 220  : 			delete[] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T6[ebp], ecx
	mov	edx, DWORD PTR $T6[ebp]
	mov	DWORD PTR $T5[ebp], edx
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN9@Insert
	push	3
	mov	ecx, DWORD PTR $T5[ebp]
	call	??_E?$RangeNode@G@DataStructures@@QAEPAXI@Z
	mov	DWORD PTR tv146[ebp], eax
	jmp	SHORT $LN10@Insert
$LN9@Insert:
	mov	DWORD PTR tv146[ebp], 0
$LN10@Insert:

; 221  : 
; 222  : 			listArray = new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$7[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Insert:

; 223  : 		}
; 224  : 
; 225  : 		// Move the elements in the list to make room
; 226  : 		//for ( unsigned int counter = list_size; counter != position; counter-- )
; 227  : 		//	listArray[ counter ] = listArray[ counter - 1 ];
; 228  : 
; 229  : 		// Don't call constructors, assignment operators, etc.
; 230  : 		memmove(listArray+position+1, listArray+position, (list_size-position)*sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _position$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _position$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _position$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4+4]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 231  : 
; 232  : 		// Insert the new item at the correct spot
; 233  : 		listArray[ position ] = input;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _position$[ebp]
	mov	eax, DWORD PTR _input$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 234  : 
; 235  : 		++list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 236  : 
; 237  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _input$[ebp]
	call	??1?$RangeNode@G@DataStructures@@QAE@XZ	; DataStructures::RangeNode<unsigned short>::~RangeNode<unsigned short>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 292				; 00000124H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Insert@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXU?$RangeNode@G@2@I@Z$0:
	lea	ecx, DWORD PTR _input$[ebp]
	jmp	??1?$RangeNode@G@DataStructures@@QAE@XZ	; DataStructures::RangeNode<unsigned short>::~RangeNode<unsigned short>
__unwindfunclet$?Insert@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXU?$RangeNode@G@2@I@Z$1:
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?Insert@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXU?$RangeNode@G@2@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-296]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Insert@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXU?$RangeNode@G@2@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Insert@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXU?$RangeNode@G@2@I@Z ENDP ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::Insert
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??A?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
??A?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z PROC ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::operator[], COMDAT
; _this$ = ecx

; 185  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 186  : #ifdef _DEBUG
; 187  : 		assert ( position < list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN3@operator
	push	187					; 000000bbH
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@operator:

; 188  : #endif
; 189  : 		return listArray[ position ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _position$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 190  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z ENDP ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??1?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
tv71 = -232						; size = 4
$T1 = -224						; size = 4
$T2 = -212						; size = 4
_this$ = -8						; size = 4
??1?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAE@XZ PROC ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::~List<DataStructures::RangeNode<unsigned short> >, COMDAT
; _this$ = ecx

; 121  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 122  : 		if (allocation_size>0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jbe	SHORT $LN2@List

; 123  : 			delete [] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T1[ebp], edx
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN4@List
	push	3
	mov	ecx, DWORD PTR $T1[ebp]
	call	??_E?$RangeNode@G@DataStructures@@QAEPAXI@Z
	mov	DWORD PTR tv71[ebp], eax
	jmp	SHORT $LN2@List
$LN4@List:
	mov	DWORD PTR tv71[ebp], 0
$LN2@List:

; 124  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAE@XZ ENDP ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::~List<DataStructures::RangeNode<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??0?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAE@XZ PROC ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::List<DataStructures::RangeNode<unsigned short> >, COMDAT
; _this$ = ecx

; 113  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 114  : 		allocation_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 115  : 		listArray = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 116  : 		list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 117  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAE@XZ ENDP ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::List<DataStructures::RangeNode<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?Size@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEIXZ PROC ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::Size, COMDAT
; _this$ = ecx

; 231  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 232  : 		return orderedList.Size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::Size

; 233  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEIXZ ENDP ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?Clear@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Clear@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAEXXZ PROC ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::Clear, COMDAT
; _this$ = ecx

; 219  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 220  : 		orderedList.Clear();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEX_N@Z ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::Clear

; 221  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAEXXZ ENDP ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?Del@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_num$ = 8						; size = 4
?Del@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAEXI@Z PROC ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::Del, COMDAT
; _this$ = ecx

; 213  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 214  : 		orderedList.Del(num);

	mov	eax, DWORD PTR _num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Del@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXI@Z ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::Del

; 215  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Del@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAEXI@Z ENDP ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::Del
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?InsertAtEnd@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAEXABU?$RangeNode@G@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_data$ = 8						; size = 4
?InsertAtEnd@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAEXABU?$RangeNode@G@2@@Z PROC ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::InsertAtEnd, COMDAT
; _this$ = ecx

; 207  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 208  : 		orderedList.Insert(data);

	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Insert@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXU?$RangeNode@G@2@@Z ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::Insert

; 209  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?InsertAtEnd@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAEXABU?$RangeNode@G@2@@Z ENDP ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::InsertAtEnd
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?InsertAtIndex@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAEXABU?$RangeNode@G@2@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_data$ = 8						; size = 4
_index$ = 12						; size = 4
?InsertAtIndex@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAEXABU?$RangeNode@G@2@I@Z PROC ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::InsertAtIndex, COMDAT
; _this$ = ecx

; 201  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 202  : 		orderedList.Insert(data, index);

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Insert@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXU?$RangeNode@G@2@I@Z ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::Insert

; 203  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?InsertAtIndex@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAEXABU?$RangeNode@G@2@I@Z ENDP ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::InsertAtIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?RemoveAtIndex@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_index$ = 8						; size = 4
?RemoveAtIndex@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAEXI@Z PROC ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::RemoveAtIndex, COMDAT
; _this$ = ecx

; 195  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 196  : 		orderedList.RemoveAtIndex(index);

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAtIndex@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXI@Z ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::RemoveAtIndex

; 197  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveAtIndex@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAEXI@Z ENDP ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::RemoveAtIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ??A?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
??A?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z PROC ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::operator[], COMDAT
; _this$ = ecx

; 225  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 226  : 		return orderedList[position];

	mov	eax, DWORD PTR _position$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::operator[]

; 227  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z ENDP ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?Insert@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAEIABGABU?$RangeNode@G@2@@Z
_TEXT	SEGMENT
_index$ = -32						; size = 4
_objectExists$ = -17					; size = 1
_this$ = -8						; size = 4
_key$ = 8						; size = 4
_data$ = 12						; size = 4
?Insert@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAEIABGABU?$RangeNode@G@2@@Z PROC ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::Insert, COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		bool objectExists;
; 158  : 		unsigned index;
; 159  : 		index = GetIndexFromKey(key, &objectExists);

	lea	eax, DWORD PTR _objectExists$[ebp]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexFromKey@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEIABGPA_N@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::GetIndexFromKey
	mov	DWORD PTR _index$[ebp], eax

; 160  : 
; 161  : 		// Don't allow duplicate insertion.
; 162  : 		if (objectExists)

	movzx	eax, BYTE PTR _objectExists$[ebp]
	test	eax, eax
	je	SHORT $LN3@Insert

; 163  : 			return (unsigned)-1;

	or	eax, -1
	jmp	SHORT $LN4@Insert
$LN3@Insert:

; 164  : 
; 165  : 		if (index>=orderedList.Size())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::Size
	cmp	DWORD PTR _index$[ebp], eax
	jb	SHORT $LN2@Insert

; 166  : 		{
; 167  : 			orderedList.Insert(data);

	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Insert@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXU?$RangeNode@G@2@@Z ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::Insert

; 168  : 			return orderedList.Size()-1;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::Size
	sub	eax, 1
	jmp	SHORT $LN4@Insert

; 169  : 		}
; 170  : 		else

	jmp	SHORT $LN4@Insert
$LN2@Insert:

; 171  : 		{
; 172  : 			orderedList.Insert(data,index);

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Insert@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAEXU?$RangeNode@G@2@I@Z ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::Insert

; 173  : 			return index;

	mov	eax, DWORD PTR _index$[ebp]
$LN4@Insert:

; 174  : 		}		
; 175  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@Insert
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN8@Insert:
	DD	1
	DD	$LN7@Insert
$LN7@Insert:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN6@Insert
$LN6@Insert:
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
?Insert@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAEIABGABU?$RangeNode@G@2@@Z ENDP ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::Insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?GetIndexFromKey@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEIABGPA_N@Z
_TEXT	SEGMENT
_res$ = -56						; size = 4
_lowerBound$ = -44					; size = 4
_upperBound$ = -32					; size = 4
_index$ = -20						; size = 4
_this$ = -8						; size = 4
_key$ = 8						; size = 4
_objectExists$ = 12					; size = 4
?GetIndexFromKey@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEIABGPA_N@Z PROC ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::GetIndexFromKey, COMDAT
; _this$ = ecx

; 110  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 111  : 		int index, upperBound, lowerBound;
; 112  : 		int res;
; 113  : 
; 114  : 		if (orderedList.Size()==0)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::Size
	test	eax, eax
	jne	SHORT $LN8@GetIndexFr

; 115  : 		{
; 116  : 			*objectExists=false;

	mov	eax, DWORD PTR _objectExists$[ebp]
	mov	BYTE PTR [eax], 0

; 117  : 			return 0;

	xor	eax, eax
	jmp	$LN9@GetIndexFr
$LN8@GetIndexFr:

; 118  : 		}
; 119  : 
; 120  : 		upperBound=(int)orderedList.Size()-1;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::Size
	sub	eax, 1
	mov	DWORD PTR _upperBound$[ebp], eax

; 121  : 		lowerBound=0;

	mov	DWORD PTR _lowerBound$[ebp], 0

; 122  : 		index = (int)orderedList.Size()/2;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::Size
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _index$[ebp], eax
$LN7@GetIndexFr:

; 123  : 
; 124  : #ifdef _MSC_VER
; 125  : 	#pragma warning( disable : 4127 ) // warning C4127: conditional expression is constant
; 126  : #endif
; 127  : 		while (1)

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN9@GetIndexFr

; 128  : 		{
; 129  : 			res = comparison_function(key,orderedList[index]);

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::operator[]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	call	??$RangeNodeComp@G@DataStructures@@YAHABGABU?$RangeNode@G@0@@Z ; DataStructures::RangeNodeComp<unsigned short>
	add	esp, 8
	mov	DWORD PTR _res$[ebp], eax

; 130  : 			if (res==0)

	cmp	DWORD PTR _res$[ebp], 0
	jne	SHORT $LN5@GetIndexFr

; 131  : 			{
; 132  : 				*objectExists=true;

	mov	eax, DWORD PTR _objectExists$[ebp]
	mov	BYTE PTR [eax], 1

; 133  : 				return index;

	mov	eax, DWORD PTR _index$[ebp]
	jmp	SHORT $LN9@GetIndexFr
	jmp	SHORT $LN4@GetIndexFr
$LN5@GetIndexFr:

; 134  : 			}
; 135  : 			else if (res<0)

	cmp	DWORD PTR _res$[ebp], 0
	jge	SHORT $LN3@GetIndexFr

; 136  : 			{
; 137  : 				upperBound=index-1;

	mov	eax, DWORD PTR _index$[ebp]
	sub	eax, 1
	mov	DWORD PTR _upperBound$[ebp], eax

; 138  : 			}
; 139  : 			else// if (res>0)

	jmp	SHORT $LN4@GetIndexFr
$LN3@GetIndexFr:

; 140  : 			{
; 141  : 				lowerBound=index+1;

	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 1
	mov	DWORD PTR _lowerBound$[ebp], eax
$LN4@GetIndexFr:

; 142  : 			}
; 143  : 
; 144  : 			index=lowerBound+(upperBound-lowerBound)/2;

	mov	eax, DWORD PTR _upperBound$[ebp]
	sub	eax, DWORD PTR _lowerBound$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _lowerBound$[ebp]
	mov	DWORD PTR _index$[ebp], eax

; 145  : 
; 146  : 			if (lowerBound>upperBound)

	mov	eax, DWORD PTR _lowerBound$[ebp]
	cmp	eax, DWORD PTR _upperBound$[ebp]
	jle	SHORT $LN1@GetIndexFr

; 147  : 			{
; 148  : 				*objectExists=false;

	mov	eax, DWORD PTR _objectExists$[ebp]
	mov	BYTE PTR [eax], 0

; 149  : 				return lowerBound; // No match

	mov	eax, DWORD PTR _lowerBound$[ebp]
	jmp	SHORT $LN9@GetIndexFr
$LN1@GetIndexFr:

; 150  : 			}
; 151  : 		}

	jmp	SHORT $LN7@GetIndexFr
$LN9@GetIndexFr:

; 152  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?GetIndexFromKey@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEIABGPA_N@Z ENDP ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::GetIndexFromKey
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ??1?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAE@XZ PROC ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::~OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >, COMDAT
; _this$ = ecx

; 72   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 73   : 		Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAEXXZ ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::Clear

; 74   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::~List<DataStructures::RangeNode<unsigned short> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::~List<DataStructures::RangeNode<unsigned short> >
__ehhandler$??1?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAE@XZ ENDP ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::~OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ??0?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAE@XZ PROC ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >, COMDAT
; _this$ = ecx

; 67   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$List@U?$RangeNode@G@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::List<DataStructures::RangeNode<unsigned short> >::List<DataStructures::RangeNode<unsigned short> >

; 68   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAE@XZ ENDP ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_rangelist.h
;	COMDAT ??$RangeNodeComp@G@DataStructures@@YAHABGABU?$RangeNode@G@0@@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$RangeNodeComp@G@DataStructures@@YAHABGABU?$RangeNode@G@0@@Z PROC ; DataStructures::RangeNodeComp<unsigned short>, COMDAT

; 23   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 24   :         if (a<b.minIndex)

	mov	eax, DWORD PTR _a$[ebp]
	movzx	ecx, WORD PTR [eax]
	mov	edx, DWORD PTR _b$[ebp]
	movzx	eax, WORD PTR [edx]
	cmp	ecx, eax
	jge	SHORT $LN2@RangeNodeC

; 25   :             return -1;

	or	eax, -1
	jmp	SHORT $LN3@RangeNodeC
$LN2@RangeNodeC:

; 26   :         if (a==b.minIndex)

	mov	eax, DWORD PTR _a$[ebp]
	movzx	ecx, WORD PTR [eax]
	mov	edx, DWORD PTR _b$[ebp]
	movzx	eax, WORD PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN1@RangeNodeC

; 27   :             return 0;

	xor	eax, eax
	jmp	SHORT $LN3@RangeNodeC
$LN1@RangeNodeC:

; 28   :         return 1;

	mov	eax, 1
$LN3@RangeNodeC:

; 29   :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$RangeNodeComp@G@DataStructures@@YAHABGABU?$RangeNode@G@0@@Z ENDP ; DataStructures::RangeNodeComp<unsigned short>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_rangelist.h
;	COMDAT ?Deserialize@?$RangeList@G@DataStructures@@QAE_NPAVBitStream@RakNet@@@Z
_TEXT	SEGMENT
tv131 = -296						; size = 4
tv132 = -292						; size = 4
$T2 = -284						; size = 4
_maxEqualToMin$ = -77					; size = 1
_max$ = -68						; size = 2
_min$ = -56						; size = 2
_i$ = -44						; size = 2
_count$ = -32						; size = 2
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_out$ = 8						; size = 4
?Deserialize@?$RangeList@G@DataStructures@@QAE_NPAVBitStream@RakNet@@@Z PROC ; DataStructures::RangeList<unsigned short>::Deserialize, COMDAT
; _this$ = ecx

; 93   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Deserialize@?$RangeList@G@DataStructures@@QAE_NPAVBitStream@RakNet@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 284				; 0000011cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-296]
	mov	ecx, 71					; 00000047H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 94   : 		ranges.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAEXXZ ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::Clear

; 95   : 		unsigned short count;
; 96   : 		out->ReadCompressed(count);

	lea	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	call	??$ReadCompressed@G@BitStream@RakNet@@QAE_NAAG@Z ; RakNet::BitStream::ReadCompressed<unsigned short>

; 97   : 		unsigned short i;
; 98   : 		range_type min,max;
; 99   : 		bool maxEqualToMin;
; 100  : 
; 101  : 		for (i=0; i < count; i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN8@Deserializ
$LN7@Deserializ:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN8@Deserializ:
	movzx	eax, WORD PTR _i$[ebp]
	movzx	ecx, WORD PTR _count$[ebp]
	cmp	eax, ecx
	jge	$LN6@Deserializ

; 102  : 		{
; 103  : 			out->Read(maxEqualToMin);

	lea	eax, DWORD PTR _maxEqualToMin$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	call	??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z ; RakNet::BitStream::Read<bool>

; 104  : 			if (out->Read(min)==false)

	lea	eax, DWORD PTR _min$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	call	??$Read@G@BitStream@RakNet@@QAE_NAAG@Z	; RakNet::BitStream::Read<unsigned short>
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN5@Deserializ

; 105  : 				return false;

	xor	al, al
	jmp	$LN9@Deserializ
$LN5@Deserializ:

; 106  : 			if (maxEqualToMin==false)

	movzx	eax, BYTE PTR _maxEqualToMin$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Deserializ

; 107  : 			{
; 108  : 				if (out->Read(max)==false)

	lea	eax, DWORD PTR _max$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	call	??$Read@G@BitStream@RakNet@@QAE_NAAG@Z	; RakNet::BitStream::Read<unsigned short>
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@Deserializ

; 109  : 					return false;

	xor	al, al
	jmp	SHORT $LN9@Deserializ
$LN3@Deserializ:

; 110  : 				if (max<min)

	movzx	eax, WORD PTR _max$[ebp]
	movzx	ecx, WORD PTR _min$[ebp]
	cmp	eax, ecx
	jge	SHORT $LN2@Deserializ

; 111  : 					return false;

	xor	al, al
	jmp	SHORT $LN9@Deserializ
$LN2@Deserializ:

; 112  : 			}
; 113  : 			else

	jmp	SHORT $LN1@Deserializ
$LN4@Deserializ:

; 114  : 				max=min;

	mov	ax, WORD PTR _min$[ebp]
	mov	WORD PTR _max$[ebp], ax
$LN1@Deserializ:

; 115  : 
; 116  : 			ranges.InsertAtEnd(RangeNode<range_type>(min,max));

	movzx	eax, WORD PTR _max$[ebp]
	push	eax
	movzx	ecx, WORD PTR _min$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$RangeNode@G@DataStructures@@QAE@GG@Z ; DataStructures::RangeNode<unsigned short>::RangeNode<unsigned short>
	mov	DWORD PTR tv132[ebp], eax
	mov	edx, DWORD PTR tv132[ebp]
	mov	DWORD PTR tv131[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR tv131[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertAtEnd@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAEXABU?$RangeNode@G@2@@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::InsertAtEnd
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$RangeNode@G@DataStructures@@QAE@XZ	; DataStructures::RangeNode<unsigned short>::~RangeNode<unsigned short>

; 117  : 		}

	jmp	$LN7@Deserializ
$LN6@Deserializ:

; 118  : 		return true;

	mov	al, 1
$LN9@Deserializ:

; 119  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN18@Deserializ
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 296				; 00000128H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN18@Deserializ:
	DD	4
	DD	$LN17@Deserializ
$LN17@Deserializ:
	DD	-32					; ffffffe0H
	DD	2
	DD	$LN12@Deserializ
	DD	-56					; ffffffc8H
	DD	2
	DD	$LN13@Deserializ
	DD	-68					; ffffffbcH
	DD	2
	DD	$LN14@Deserializ
	DD	-77					; ffffffb3H
	DD	1
	DD	$LN15@Deserializ
$LN15@Deserializ:
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	120					; 00000078H
	DB	69					; 00000045H
	DB	113					; 00000071H
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	84					; 00000054H
	DB	111					; 0000006fH
	DB	77					; 0000004dH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	0
$LN14@Deserializ:
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	120					; 00000078H
	DB	0
$LN13@Deserializ:
	DB	109					; 0000006dH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	0
$LN12@Deserializ:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Deserialize@?$RangeList@G@DataStructures@@QAE_NPAVBitStream@RakNet@@@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$RangeNode@G@DataStructures@@QAE@XZ	; DataStructures::RangeNode<unsigned short>::~RangeNode<unsigned short>
__ehhandler$?Deserialize@?$RangeList@G@DataStructures@@QAE_NPAVBitStream@RakNet@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-300]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Deserialize@?$RangeList@G@DataStructures@@QAE_NPAVBitStream@RakNet@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Deserialize@?$RangeList@G@DataStructures@@QAE_NPAVBitStream@RakNet@@@Z ENDP ; DataStructures::RangeList<unsigned short>::Deserialize
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_rangelist.h
;	COMDAT ?Serialize@?$RangeList@G@DataStructures@@QAEIPAVBitStream@RakNet@@H_N@Z
_TEXT	SEGMENT
tv130 = -577						; size = 1
$T2 = -572						; size = 4
_rangeSize$3 = -368					; size = 4
_before$ = -356						; size = 4
_i$ = -344						; size = 4
_countWritten$ = -332					; size = 2
_bitsWritten$ = -320					; size = 4
_tempBS$ = -308						; size = 273
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_in$ = 8						; size = 4
_maxBits$ = 12						; size = 4
_clearSerialized$ = 16					; size = 1
?Serialize@?$RangeList@G@DataStructures@@QAEIPAVBitStream@RakNet@@H_N@Z PROC ; DataStructures::RangeList<unsigned short>::Serialize, COMDAT
; _this$ = ecx

; 49   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Serialize@?$RangeList@G@DataStructures@@QAEIPAVBitStream@RakNet@@H_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 568				; 00000238H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-580]
	mov	ecx, 142				; 0000008eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 50   : 		assert(ranges.Size() < (unsigned short)-1);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::Size
	cmp	eax, 65535				; 0000ffffH
	jb	SHORT $LN12@Serialize
	push	50					; 00000032H
	push	OFFSET ??_C@_1EO@BAKEJDDB@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAr?$AAa?$AAn?$AAg?$AAe@
	push	OFFSET ??_C@_1EG@DIEFEKLO@?$AAr?$AAa?$AAn?$AAg?$AAe?$AAs?$AA?4?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAu?$AAn?$AAs?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AAs?$AAh?$AAo?$AAr?$AAt?$AA?$CJ@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN12@Serialize:

; 51   : 		RakNet::BitStream tempBS;

	lea	ecx, DWORD PTR _tempBS$[ebp]
	call	??0BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 52   : 		int bitsWritten;
; 53   : 		unsigned short countWritten;
; 54   : 		unsigned i;
; 55   : 		countWritten=0;

	xor	eax, eax
	mov	WORD PTR _countWritten$[ebp], ax

; 56   : 		bitsWritten=0;

	mov	DWORD PTR _bitsWritten$[ebp], 0

; 57   : 		for (i=0; i < ranges.Size(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN9@Serialize
$LN8@Serialize:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN9@Serialize:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	$LN7@Serialize

; 58   : 		{
; 59   : 			if ((int)sizeof(unsigned short)*8+bitsWritten+(int)sizeof(range_type)*8*2+1>maxBits)

	mov	eax, DWORD PTR _bitsWritten$[ebp]
	add	eax, 49					; 00000031H
	cmp	eax, DWORD PTR _maxBits$[ebp]
	jle	SHORT $LN6@Serialize

; 60   : 				break;

	jmp	$LN7@Serialize
$LN6@Serialize:

; 61   : 			tempBS.Write(ranges[i].minIndex==ranges[i].maxIndex);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::operator[]
	movzx	esi, WORD PTR [eax]
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::operator[]
	movzx	edx, WORD PTR [eax+2]
	cmp	esi, edx
	jne	SHORT $LN13@Serialize
	mov	BYTE PTR tv130[ebp], 1
	jmp	SHORT $LN14@Serialize
$LN13@Serialize:
	mov	BYTE PTR tv130[ebp], 0
$LN14@Serialize:
	movzx	eax, BYTE PTR tv130[ebp]
	push	eax
	lea	ecx, DWORD PTR _tempBS$[ebp]
	call	??$Write@_N@BitStream@RakNet@@QAEX_N@Z	; RakNet::BitStream::Write<bool>

; 62   : 			tempBS.Write(ranges[i].minIndex);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::operator[]
	mov	cx, WORD PTR [eax]
	movzx	edx, cx
	push	edx
	lea	ecx, DWORD PTR _tempBS$[ebp]
	call	??$Write@G@BitStream@RakNet@@QAEXG@Z	; RakNet::BitStream::Write<unsigned short>

; 63   : 			bitsWritten+=sizeof(range_type)*8+1;

	mov	eax, DWORD PTR _bitsWritten$[ebp]
	add	eax, 17					; 00000011H
	mov	DWORD PTR _bitsWritten$[ebp], eax

; 64   : 			if (ranges[i].minIndex!=ranges[i].maxIndex)

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::operator[]
	movzx	esi, WORD PTR [eax]
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::operator[]
	movzx	edx, WORD PTR [eax+2]
	cmp	esi, edx
	je	SHORT $LN5@Serialize

; 65   : 			{
; 66   : 				tempBS.Write(ranges[i].maxIndex);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::operator[]
	mov	cx, WORD PTR [eax+2]
	movzx	edx, cx
	push	edx
	lea	ecx, DWORD PTR _tempBS$[ebp]
	call	??$Write@G@BitStream@RakNet@@QAEXG@Z	; RakNet::BitStream::Write<unsigned short>

; 67   : 				bitsWritten+=sizeof(range_type)*8;

	mov	eax, DWORD PTR _bitsWritten$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _bitsWritten$[ebp], eax
$LN5@Serialize:

; 68   : 			}
; 69   : 			countWritten++;

	mov	ax, WORD PTR _countWritten$[ebp]
	add	ax, 1
	mov	WORD PTR _countWritten$[ebp], ax

; 70   : 		}

	jmp	$LN8@Serialize
$LN7@Serialize:

; 71   : 
; 72   : 		int before=in->GetWriteOffset();

	mov	ecx, DWORD PTR _in$[ebp]
	call	?GetWriteOffset@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetWriteOffset
	mov	DWORD PTR _before$[ebp], eax

; 73   : 		in->WriteCompressed(countWritten);

	movzx	eax, WORD PTR _countWritten$[ebp]
	push	eax
	mov	ecx, DWORD PTR _in$[ebp]
	call	??$WriteCompressed@G@BitStream@RakNet@@QAEXG@Z ; RakNet::BitStream::WriteCompressed<unsigned short>

; 74   : 		bitsWritten+=in->GetWriteOffset()-before;

	mov	ecx, DWORD PTR _in$[ebp]
	call	?GetWriteOffset@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetWriteOffset
	sub	eax, DWORD PTR _before$[ebp]
	add	eax, DWORD PTR _bitsWritten$[ebp]
	mov	DWORD PTR _bitsWritten$[ebp], eax

; 75   : 	//	printf("%i ", in->GetNumberOfBitsUsed());
; 76   : 		in->Write(&tempBS, tempBS.GetNumberOfBitsUsed());

	lea	ecx, DWORD PTR _tempBS$[ebp]
	call	?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBitsUsed
	push	eax
	lea	eax, DWORD PTR _tempBS$[ebp]
	push	eax
	mov	ecx, DWORD PTR _in$[ebp]
	call	?Write@BitStream@RakNet@@QAEXPAV12@H@Z	; RakNet::BitStream::Write

; 77   : 	//	printf("%i %i \n", tempBS.GetNumberOfBitsUsed(),in->GetNumberOfBitsUsed());
; 78   : 
; 79   : 		if (clearSerialized && countWritten)

	movzx	eax, BYTE PTR _clearSerialized$[ebp]
	test	eax, eax
	je	$LN4@Serialize
	movzx	eax, WORD PTR _countWritten$[ebp]
	test	eax, eax
	je	SHORT $LN4@Serialize

; 80   : 		{
; 81   : 			unsigned rangeSize=ranges.Size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::Size
	mov	DWORD PTR _rangeSize$3[ebp], eax

; 82   : 			for (i=0; i < rangeSize-countWritten; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@Serialize
$LN2@Serialize:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@Serialize:
	movzx	eax, WORD PTR _countWritten$[ebp]
	mov	ecx, DWORD PTR _rangeSize$3[ebp]
	sub	ecx, eax
	cmp	DWORD PTR _i$[ebp], ecx
	jae	SHORT $LN1@Serialize

; 83   : 			{
; 84   : 				ranges[i]=ranges[i+countWritten];

	movzx	eax, WORD PTR _countWritten$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::operator[]
	mov	esi, DWORD PTR [eax]
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::operator[]
	mov	DWORD PTR [eax], esi

; 85   : 			}

	jmp	SHORT $LN2@Serialize
$LN1@Serialize:

; 86   : 			ranges.Del(countWritten);

	movzx	eax, WORD PTR _countWritten$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Del@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAEXI@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::Del
$LN4@Serialize:

; 87   : 		}
; 88   : 
; 89   : 		return bitsWritten;

	mov	eax, DWORD PTR _bitsWritten$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tempBS$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	eax, DWORD PTR $T2[ebp]

; 90   : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN19@Serialize
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 580				; 00000244H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	3
$LN19@Serialize:
	DD	1
	DD	$LN18@Serialize
$LN18@Serialize:
	DD	-308					; fffffeccH
	DD	273					; 00000111H
	DD	$LN16@Serialize
$LN16@Serialize:
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	66					; 00000042H
	DB	83					; 00000053H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Serialize@?$RangeList@G@DataStructures@@QAEIPAVBitStream@RakNet@@H_N@Z$0:
	lea	ecx, DWORD PTR _tempBS$[ebp]
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__ehhandler$?Serialize@?$RangeList@G@DataStructures@@QAEIPAVBitStream@RakNet@@H_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-584]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Serialize@?$RangeList@G@DataStructures@@QAEIPAVBitStream@RakNet@@H_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Serialize@?$RangeList@G@DataStructures@@QAEIPAVBitStream@RakNet@@H_N@Z ENDP ; DataStructures::RangeList<unsigned short>::Serialize
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_rangelist.h
;	COMDAT ?Size@?$RangeList@G@DataStructures@@QAEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$RangeList@G@DataStructures@@QAEIXZ PROC		; DataStructures::RangeList<unsigned short>::Size, COMDAT
; _this$ = ecx

; 203  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 		return ranges.Size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::Size

; 205  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$RangeList@G@DataStructures@@QAEIXZ ENDP		; DataStructures::RangeList<unsigned short>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_rangelist.h
;	COMDAT ?Clear@?$RangeList@G@DataStructures@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Clear@?$RangeList@G@DataStructures@@QAEXXZ PROC	; DataStructures::RangeList<unsigned short>::Clear, COMDAT
; _this$ = ecx

; 197  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 198  : 		ranges.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAEXXZ ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::Clear

; 199  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$RangeList@G@DataStructures@@QAEXXZ ENDP	; DataStructures::RangeList<unsigned short>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_rangelist.h
;	COMDAT ?Insert@?$RangeList@G@DataStructures@@QAEXG@Z
_TEXT	SEGMENT
tv293 = -284						; size = 4
tv291 = -284						; size = 4
tv289 = -284						; size = 4
tv296 = -280						; size = 4
tv295 = -280						; size = 4
tv294 = -280						; size = 4
tv252 = -280						; size = 4
tv190 = -280						; size = 4
tv135 = -280						; size = 4
$T2 = -272						; size = 4
$T3 = -260						; size = 4
$T4 = -248						; size = 4
_insertionIndex$ = -44					; size = 4
_objectExists$ = -29					; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_index$ = 8						; size = 2
?Insert@?$RangeList@G@DataStructures@@QAEXG@Z PROC	; DataStructures::RangeList<unsigned short>::Insert, COMDAT
; _this$ = ecx

; 135  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Insert@?$RangeList@G@DataStructures@@QAEXG@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 272				; 00000110H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-284]
	mov	ecx, 68					; 00000044H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 136  : 		if (ranges.Size()==0)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::Size
	test	eax, eax
	jne	SHORT $LN14@Insert

; 137  : 		{
; 138  : 			ranges.Insert(index, RangeNode<range_type>(index, index));

	movzx	eax, WORD PTR _index$[ebp]
	push	eax
	movzx	ecx, WORD PTR _index$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$RangeNode@G@DataStructures@@QAE@GG@Z ; DataStructures::RangeNode<unsigned short>::RangeNode<unsigned short>
	mov	DWORD PTR tv294[ebp], eax
	mov	edx, DWORD PTR tv294[ebp]
	mov	DWORD PTR tv289[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR tv289[ebp]
	push	eax
	lea	ecx, DWORD PTR _index$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Insert@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAEIABGABU?$RangeNode@G@2@@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::Insert
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$RangeNode@G@DataStructures@@QAE@XZ	; DataStructures::RangeNode<unsigned short>::~RangeNode<unsigned short>

; 139  : 			return;

	jmp	$LN15@Insert
$LN14@Insert:

; 140  : 		}
; 141  : 
; 142  : 		bool objectExists;
; 143  : 		unsigned insertionIndex=ranges.GetIndexFromKey(index, &objectExists);

	lea	eax, DWORD PTR _objectExists$[ebp]
	push	eax
	lea	ecx, DWORD PTR _index$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexFromKey@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEIABGPA_N@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::GetIndexFromKey
	mov	DWORD PTR _insertionIndex$[ebp], eax

; 144  : 		if (insertionIndex==ranges.Size())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::Size
	cmp	DWORD PTR _insertionIndex$[ebp], eax
	jne	$LN13@Insert

; 145  : 		{
; 146  : 			if (index == ranges[insertionIndex-1].maxIndex+1)

	movzx	esi, WORD PTR _index$[ebp]
	mov	eax, DWORD PTR _insertionIndex$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::operator[]
	movzx	ecx, WORD PTR [eax+2]
	add	ecx, 1
	cmp	esi, ecx
	jne	SHORT $LN12@Insert

; 147  : 				ranges[insertionIndex-1].maxIndex++;

	mov	eax, DWORD PTR _insertionIndex$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::operator[]
	add	eax, 2
	mov	DWORD PTR tv135[ebp], eax
	mov	ecx, DWORD PTR tv135[ebp]
	mov	dx, WORD PTR [ecx]
	add	dx, 1
	mov	eax, DWORD PTR tv135[ebp]
	mov	WORD PTR [eax], dx
	jmp	SHORT $LN11@Insert
$LN12@Insert:

; 148  : 			else if (index > ranges[insertionIndex-1].maxIndex+1)

	movzx	esi, WORD PTR _index$[ebp]
	mov	eax, DWORD PTR _insertionIndex$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::operator[]
	movzx	ecx, WORD PTR [eax+2]
	add	ecx, 1
	cmp	esi, ecx
	jle	SHORT $LN11@Insert

; 149  : 			{
; 150  : 				// Insert at end
; 151  : 				ranges.Insert(index, RangeNode<range_type>(index, index));

	movzx	eax, WORD PTR _index$[ebp]
	push	eax
	movzx	ecx, WORD PTR _index$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0?$RangeNode@G@DataStructures@@QAE@GG@Z ; DataStructures::RangeNode<unsigned short>::RangeNode<unsigned short>
	mov	DWORD PTR tv295[ebp], eax
	mov	edx, DWORD PTR tv295[ebp]
	mov	DWORD PTR tv291[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR tv291[ebp]
	push	eax
	lea	ecx, DWORD PTR _index$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Insert@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAEIABGABU?$RangeNode@G@2@@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::Insert
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$RangeNode@G@DataStructures@@QAE@XZ	; DataStructures::RangeNode<unsigned short>::~RangeNode<unsigned short>
$LN11@Insert:

; 152  : 			}
; 153  : 
; 154  : 			return;

	jmp	$LN15@Insert
$LN13@Insert:

; 155  : 		}
; 156  : 
; 157  : 		if (index < ranges[insertionIndex].minIndex-1)

	movzx	esi, WORD PTR _index$[ebp]
	mov	eax, DWORD PTR _insertionIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::operator[]
	movzx	ecx, WORD PTR [eax]
	sub	ecx, 1
	cmp	esi, ecx
	jge	SHORT $LN9@Insert

; 158  : 		{
; 159  : 			// Insert here
; 160  : 			ranges.InsertAtIndex(RangeNode<range_type>(index, index), insertionIndex);

	mov	eax, DWORD PTR _insertionIndex$[ebp]
	push	eax
	movzx	ecx, WORD PTR _index$[ebp]
	push	ecx
	movzx	edx, WORD PTR _index$[ebp]
	push	edx
	lea	ecx, DWORD PTR $T4[ebp]
	call	??0?$RangeNode@G@DataStructures@@QAE@GG@Z ; DataStructures::RangeNode<unsigned short>::RangeNode<unsigned short>
	mov	DWORD PTR tv296[ebp], eax
	mov	eax, DWORD PTR tv296[ebp]
	mov	DWORD PTR tv293[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR tv293[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertAtIndex@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAEXABU?$RangeNode@G@2@I@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::InsertAtIndex
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1?$RangeNode@G@DataStructures@@QAE@XZ	; DataStructures::RangeNode<unsigned short>::~RangeNode<unsigned short>

; 161  : 
; 162  : 			return;

	jmp	$LN15@Insert
	jmp	$LN15@Insert
$LN9@Insert:

; 163  : 		}
; 164  : 		else if (index == ranges[insertionIndex].minIndex-1)

	movzx	esi, WORD PTR _index$[ebp]
	mov	eax, DWORD PTR _insertionIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::operator[]
	movzx	ecx, WORD PTR [eax]
	sub	ecx, 1
	cmp	esi, ecx
	jne	$LN7@Insert

; 165  : 		{
; 166  : 			// Decrease minIndex and join left
; 167  : 			ranges[insertionIndex].minIndex--;

	mov	eax, DWORD PTR _insertionIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::operator[]
	mov	DWORD PTR tv190[ebp], eax
	mov	ecx, DWORD PTR tv190[ebp]
	mov	dx, WORD PTR [ecx]
	sub	dx, 1
	mov	eax, DWORD PTR tv190[ebp]
	mov	WORD PTR [eax], dx

; 168  : 			if (insertionIndex>0 && ranges[insertionIndex-1].maxIndex+1==ranges[insertionIndex].minIndex)

	cmp	DWORD PTR _insertionIndex$[ebp], 0
	jbe	SHORT $LN6@Insert
	mov	eax, DWORD PTR _insertionIndex$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::operator[]
	movzx	esi, WORD PTR [eax+2]
	add	esi, 1
	mov	ecx, DWORD PTR _insertionIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::operator[]
	movzx	edx, WORD PTR [eax]
	cmp	esi, edx
	jne	SHORT $LN6@Insert

; 169  : 			{
; 170  : 				ranges[insertionIndex-1].maxIndex=ranges[insertionIndex].maxIndex;

	mov	eax, DWORD PTR _insertionIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::operator[]
	mov	esi, eax
	mov	ecx, DWORD PTR _insertionIndex$[ebp]
	sub	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::operator[]
	mov	dx, WORD PTR [esi+2]
	mov	WORD PTR [eax+2], dx

; 171  : 				ranges.RemoveAtIndex(insertionIndex);

	mov	eax, DWORD PTR _insertionIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAtIndex@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAEXI@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::RemoveAtIndex
$LN6@Insert:

; 172  : 			}
; 173  : 
; 174  : 			return;

	jmp	$LN15@Insert
	jmp	$LN15@Insert
$LN7@Insert:

; 175  : 		}
; 176  : 		else if (index >= ranges[insertionIndex].minIndex && index <= ranges[insertionIndex].maxIndex)

	movzx	esi, WORD PTR _index$[ebp]
	mov	eax, DWORD PTR _insertionIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::operator[]
	movzx	ecx, WORD PTR [eax]
	cmp	esi, ecx
	jl	SHORT $LN4@Insert
	movzx	esi, WORD PTR _index$[ebp]
	mov	eax, DWORD PTR _insertionIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::operator[]
	movzx	ecx, WORD PTR [eax+2]
	cmp	esi, ecx
	jg	SHORT $LN4@Insert

; 177  : 		{
; 178  : 			// Already exists
; 179  : 			return;

	jmp	$LN15@Insert
	jmp	$LN15@Insert
$LN4@Insert:

; 180  : 		}
; 181  : 		else if (index == ranges[insertionIndex].maxIndex+1)

	movzx	esi, WORD PTR _index$[ebp]
	mov	eax, DWORD PTR _insertionIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::operator[]
	movzx	ecx, WORD PTR [eax+2]
	add	ecx, 1
	cmp	esi, ecx
	jne	$LN15@Insert

; 182  : 		{
; 183  : 			// Increase maxIndex and join right
; 184  : 			ranges[insertionIndex].maxIndex++;

	mov	eax, DWORD PTR _insertionIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::operator[]
	add	eax, 2
	mov	DWORD PTR tv252[ebp], eax
	mov	ecx, DWORD PTR tv252[ebp]
	mov	dx, WORD PTR [ecx]
	add	dx, 1
	mov	eax, DWORD PTR tv252[ebp]
	mov	WORD PTR [eax], dx

; 185  : 			if (insertionIndex<ranges.Size()-1 && ranges[insertionIndex+1].minIndex==ranges[insertionIndex].maxIndex+1)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::Size
	sub	eax, 1
	cmp	DWORD PTR _insertionIndex$[ebp], eax
	jae	SHORT $LN15@Insert
	mov	eax, DWORD PTR _insertionIndex$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::operator[]
	movzx	esi, WORD PTR [eax]
	mov	ecx, DWORD PTR _insertionIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::operator[]
	movzx	edx, WORD PTR [eax+2]
	add	edx, 1
	cmp	esi, edx
	jne	SHORT $LN15@Insert

; 186  : 			{
; 187  : 				ranges[insertionIndex+1].minIndex=ranges[insertionIndex].minIndex;

	mov	eax, DWORD PTR _insertionIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::operator[]
	mov	esi, eax
	mov	ecx, DWORD PTR _insertionIndex$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::operator[]
	mov	dx, WORD PTR [esi]
	mov	WORD PTR [eax], dx

; 188  : 				ranges.RemoveAtIndex(insertionIndex);

	mov	eax, DWORD PTR _insertionIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAtIndex@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAEXI@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::RemoveAtIndex
$LN15@Insert:

; 189  : 			}
; 190  : 
; 191  : 			return;
; 192  : 		}
; 193  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN23@Insert
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 284				; 0000011cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN23@Insert:
	DD	1
	DD	$LN22@Insert
$LN22@Insert:
	DD	-29					; ffffffe3H
	DD	1
	DD	$LN20@Insert
$LN20@Insert:
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Insert@?$RangeList@G@DataStructures@@QAEXG@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$RangeNode@G@DataStructures@@QAE@XZ	; DataStructures::RangeNode<unsigned short>::~RangeNode<unsigned short>
__unwindfunclet$?Insert@?$RangeList@G@DataStructures@@QAEXG@Z$1:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$RangeNode@G@DataStructures@@QAE@XZ	; DataStructures::RangeNode<unsigned short>::~RangeNode<unsigned short>
__unwindfunclet$?Insert@?$RangeList@G@DataStructures@@QAEXG@Z$2:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$RangeNode@G@DataStructures@@QAE@XZ	; DataStructures::RangeNode<unsigned short>::~RangeNode<unsigned short>
__ehhandler$?Insert@?$RangeList@G@DataStructures@@QAEXG@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-288]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Insert@?$RangeList@G@DataStructures@@QAEXG@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Insert@?$RangeList@G@DataStructures@@QAEXG@Z ENDP	; DataStructures::RangeList<unsigned short>::Insert
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_rangelist.h
;	COMDAT ??1?$RangeList@G@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$RangeList@G@DataStructures@@QAE@XZ PROC		; DataStructures::RangeList<unsigned short>::~RangeList<unsigned short>, COMDAT
; _this$ = ecx

; 129  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$RangeList@G@DataStructures@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 130  : 		Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$RangeList@G@DataStructures@@QAEXXZ ; DataStructures::RangeList<unsigned short>::Clear

; 131  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::~OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$RangeList@G@DataStructures@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::~OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >
__ehhandler$??1?$RangeList@G@DataStructures@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$RangeList@G@DataStructures@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$RangeList@G@DataStructures@@QAE@XZ ENDP		; DataStructures::RangeList<unsigned short>::~RangeList<unsigned short>
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_rangelist.h
;	COMDAT ??0?$RangeList@G@DataStructures@@QAE@XZ
_TEXT	SEGMENT
tv78 = -248						; size = 4
tv66 = -244						; size = 4
$T2 = -236						; size = 4
$T3 = -222						; size = 2
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$RangeList@G@DataStructures@@QAE@XZ PROC		; DataStructures::RangeList<unsigned short>::RangeList<unsigned short>, COMDAT
; _this$ = ecx

; 123  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$RangeList@G@DataStructures@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 236				; 000000ecH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-248]
	mov	ecx, 59					; 0000003bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 124  : 		RangeNodeComp<range_type>(0, RangeNode<range_type>());

	xor	eax, eax
	mov	WORD PTR $T3[ebp], ax
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$RangeNode@G@DataStructures@@QAE@XZ	; DataStructures::RangeNode<unsigned short>::RangeNode<unsigned short>
	mov	DWORD PTR tv66[ebp], eax
	mov	ecx, DWORD PTR tv66[ebp]
	mov	DWORD PTR tv78[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR tv78[ebp]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??$RangeNodeComp@G@DataStructures@@YAHABGABU?$RangeNode@G@0@@Z ; DataStructures::RangeNodeComp<unsigned short>
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$RangeNode@G@DataStructures@@QAE@XZ	; DataStructures::RangeNode<unsigned short>::~RangeNode<unsigned short>

; 125  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 248				; 000000f8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$RangeList@G@DataStructures@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::~OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >
__unwindfunclet$??0?$RangeList@G@DataStructures@@QAE@XZ$1:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$RangeNode@G@DataStructures@@QAE@XZ	; DataStructures::RangeNode<unsigned short>::~RangeNode<unsigned short>
__ehhandler$??0?$RangeList@G@DataStructures@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-252]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$RangeList@G@DataStructures@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$RangeList@G@DataStructures@@QAE@XZ ENDP		; DataStructures::RangeList<unsigned short>::RangeList<unsigned short>
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Clear@?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QAEX_N@Z
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
_doNotDeallocate$ = 8					; size = 1
?Clear@?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QAEX_N@Z PROC ; DataStructures::List<DataStructures::LinkedList<InternalPacket *> *>::Clear, COMDAT
; _this$ = ecx

; 379  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  : 		if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Clear

; 381  : 			return;

	jmp	SHORT $LN3@Clear
$LN2@Clear:

; 382  : 
; 383  : 		if (allocation_size>512 && doNotDeallocate==false)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 512			; 00000200H
	jbe	SHORT $LN1@Clear
	movzx	eax, BYTE PTR _doNotDeallocate$[ebp]
	test	eax, eax
	jne	SHORT $LN1@Clear

; 384  : 		{
; 385  : 			delete [] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 386  : 			allocation_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 387  : 			listArray = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN1@Clear:

; 388  : 		}
; 389  : 		list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
$LN3@Clear:

; 390  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Clear@?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QAEX_N@Z ENDP ; DataStructures::List<DataStructures::LinkedList<InternalPacket *> *>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Size@?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QBEIXZ PROC ; DataStructures::List<DataStructures::LinkedList<InternalPacket *> *>::Size, COMDAT
; _this$ = ecx

; 373  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 374  : 		return list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 375  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QBEIXZ ENDP ; DataStructures::List<DataStructures::LinkedList<InternalPacket *> *>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Replace@?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QAEXQAV?$LinkedList@PAUInternalPacket@@@2@0I@Z
_TEXT	SEGMENT
$T1 = -236						; size = 4
$T2 = -224						; size = 4
_new_array$3 = -20					; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
_filler$ = 12						; size = 4
_position$ = 16						; size = 4
?Replace@?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QAEXQAV?$LinkedList@PAUInternalPacket@@@2@0I@Z PROC ; DataStructures::List<DataStructures::LinkedList<InternalPacket *> *>::Replace, COMDAT
; _this$ = ecx

; 278  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 279  : 		if ( ( list_size > 0 ) && ( position < list_size ) )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jbe	SHORT $LN5@Replace
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN5@Replace

; 280  : 		{
; 281  : 			// Direct replacement
; 282  : 			listArray[ position ] = input;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _position$[ebp]
	mov	eax, DWORD PTR _input$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 283  : 		}
; 284  : 		else

	jmp	$LN6@Replace
$LN5@Replace:

; 285  : 		{
; 286  : 			if ( position >= allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jb	SHORT $LN2@Replace

; 287  : 			{
; 288  : 				// Reallocate the list to size position and fill in blanks with filler
; 289  : 				list_type * new_array;
; 290  : 				allocation_size = position + 1;

	mov	eax, DWORD PTR _position$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 291  : 
; 292  : 				new_array = new list_type [ allocation_size ];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _new_array$3[ebp], eax

; 293  : 
; 294  : 				// copy old array over
; 295  : 
; 296  : 				//for ( unsigned int counter = 0; counter < list_size; ++counter )
; 297  : 				//	new_array[ counter ] = listArray[ counter ];
; 298  : 
; 299  : 				// Don't call constructors, assignment operators, etc.
; 300  : 				memcpy(new_array, listArray, list_size*sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _new_array$3[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 301  : 
; 302  : 				// set old array to point to the newly allocated array
; 303  : 				delete[] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 304  : 
; 305  : 				listArray = new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$3[ebp]
	mov	DWORD PTR [eax], ecx
$LN2@Replace:

; 306  : 			}
; 307  : 
; 308  : 			// Fill in holes with filler
; 309  : 			while ( list_size < position )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _position$[ebp]
	jae	SHORT $LN1@Replace

; 310  : 				listArray[ list_size++ ] = filler;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _filler$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN2@Replace
$LN1@Replace:

; 311  : 
; 312  : 			// Fill in the last element with the new item
; 313  : 			listArray[ list_size++ ] = input;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _input$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 314  : 
; 315  : #ifdef _DEBUG
; 316  : 
; 317  : 			assert( list_size == position + 1 );

	mov	eax, DWORD PTR _position$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], eax
	je	SHORT $LN6@Replace
	push	317					; 0000013dH
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1DE@KHAHCBKC@?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$CL?$AA?5?$AA1?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN6@Replace:

; 318  : 
; 319  : #endif
; 320  : 
; 321  : 		}
; 322  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Replace@?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QAEXQAV?$LinkedList@PAUInternalPacket@@@2@0I@Z ENDP ; DataStructures::List<DataStructures::LinkedList<InternalPacket *> *>::Replace
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??A?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QBEAAPAV?$LinkedList@PAUInternalPacket@@@1@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
??A?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QBEAAPAV?$LinkedList@PAUInternalPacket@@@1@I@Z PROC ; DataStructures::List<DataStructures::LinkedList<InternalPacket *> *>::operator[], COMDAT
; _this$ = ecx

; 185  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 186  : #ifdef _DEBUG
; 187  : 		assert ( position < list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN3@operator
	push	187					; 000000bbH
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@operator:

; 188  : #endif
; 189  : 		return listArray[ position ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _position$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 190  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QBEAAPAV?$LinkedList@PAUInternalPacket@@@1@I@Z ENDP ; DataStructures::List<DataStructures::LinkedList<InternalPacket *> *>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??1?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
??1?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QAE@XZ PROC ; DataStructures::List<DataStructures::LinkedList<InternalPacket *> *>::~List<DataStructures::LinkedList<InternalPacket *> *>, COMDAT
; _this$ = ecx

; 121  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 122  : 		if (allocation_size>0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jbe	SHORT $LN2@List

; 123  : 			delete [] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@List:

; 124  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QAE@XZ ENDP ; DataStructures::List<DataStructures::LinkedList<InternalPacket *> *>::~List<DataStructures::LinkedList<InternalPacket *> *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??0?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QAE@XZ PROC ; DataStructures::List<DataStructures::LinkedList<InternalPacket *> *>::List<DataStructures::LinkedList<InternalPacket *> *>, COMDAT
; _this$ = ecx

; 113  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 114  : 		allocation_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 115  : 		listArray = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 116  : 		list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 117  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QAE@XZ ENDP ; DataStructures::List<DataStructures::LinkedList<InternalPacket *> *>::List<DataStructures::LinkedList<InternalPacket *> *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?UpdateThreadedMemory@ReliabilityLayer@@AAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?UpdateThreadedMemory@ReliabilityLayer@@AAEXXZ PROC	; ReliabilityLayer::UpdateThreadedMemory, COMDAT
; _this$ = ecx

; 2527 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2528 : 	if ( freeThreadedMemoryOnNextUpdate )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1645]
	test	ecx, ecx
	je	SHORT $LN2@UpdateThre

; 2529 : 	{
; 2530 : 		freeThreadedMemoryOnNextUpdate = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1645], 0

; 2531 : 		FreeThreadedMemory();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeThreadedMemory@ReliabilityLayer@@AAEXXZ ; ReliabilityLayer::FreeThreadedMemory
$LN2@UpdateThre:

; 2532 : 	}
; 2533 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateThreadedMemory@ReliabilityLayer@@AAEXXZ ENDP	; ReliabilityLayer::UpdateThreadedMemory
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?GetResendListDataSize@ReliabilityLayer@@ABEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetResendListDataSize@ReliabilityLayer@@ABEIXZ PROC	; ReliabilityLayer::GetResendListDataSize, COMDAT
; _this$ = ecx

; 2510 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2511 : 	/*
; 2512 : 	unsigned int i, count;
; 2513 : 	for (count=0, i=0; i < resendList.Size(); i++)
; 2514 : 		if (resendList[i]!=0)
; 2515 : 			count++;
; 2516 : 	return count;
; 2517 : 	*/
; 2518 : 
; 2519 : 	// Not accurate but thread-safe.  The commented version might crash if the queue is cleared while we loop through it
; 2520 : 	return resendList.Size();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	?Size@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QBEIXZ ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::Size

; 2521 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetResendListDataSize@ReliabilityLayer@@ABEIXZ ENDP	; ReliabilityLayer::GetResendListDataSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?UpdateNextActionTime@ReliabilityLayer@@AAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?UpdateNextActionTime@ReliabilityLayer@@AAEXXZ PROC	; ReliabilityLayer::UpdateNextActionTime, COMDAT
; _this$ = ecx

; 2472 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2473 : 	//double multiple = log10(currentBandwidth/MINIMUM_SEND_BPS) / 0.30102999566398119521373889472449;
; 2474 : 	if (ping*(RakNetTime)PING_MULTIPLIER_TO_RESEND < MIN_PING_TO_RESEND)

	movss	xmm0, DWORD PTR _PING_MULTIPLIER_TO_RESEND
	call	__ftoui3
	mov	ecx, DWORD PTR _this$[ebp]
	imul	eax, DWORD PTR [ecx+717]
	cmp	eax, 30					; 0000001eH
	jae	SHORT $LN2@UpdateNext

; 2475 : 		ackTimeIncrement=(RakNetTimeNS)MIN_PING_TO_RESEND*1000;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1637], 30000		; 00007530H
	mov	DWORD PTR [eax+1641], 0

; 2476 : 	else

	jmp	SHORT $LN1@UpdateNext
$LN2@UpdateNext:

; 2477 : 		ackTimeIncrement=(RakNetTimeNS)(ping*(RakNetTime)PING_MULTIPLIER_TO_RESEND)*1000;

	movss	xmm0, DWORD PTR _PING_MULTIPLIER_TO_RESEND
	call	__ftoui3
	mov	ecx, DWORD PTR _this$[ebp]
	imul	eax, DWORD PTR [ecx+717]
	mov	edx, 1000				; 000003e8H
	mul	edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1637], eax
	mov	DWORD PTR [ecx+1641], edx
$LN1@UpdateNext:

; 2478 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateNextActionTime@ReliabilityLayer@@AAEXXZ ENDP	; ReliabilityLayer::UpdateNextActionTime
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?InitializeVariables@ReliabilityLayer@@AAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?InitializeVariables@ReliabilityLayer@@AAEXXZ PROC	; ReliabilityLayer::InitializeVariables, COMDAT
; _this$ = ecx

; 179  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 180  : 	memset( waitingForOrderedPacketReadIndex, 0, NUMBER_OF_ORDERED_STREAMS * sizeof(OrderingIndexType));

	push	64					; 00000040H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 587				; 0000024bH
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 181  : 	memset( waitingForSequencedPacketReadIndex, 0, NUMBER_OF_ORDERED_STREAMS * sizeof(OrderingIndexType) );

	push	64					; 00000040H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 651				; 0000028bH
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 182  : 	memset( waitingForOrderedPacketWriteIndex, 0, NUMBER_OF_ORDERED_STREAMS * sizeof(OrderingIndexType) );

	push	64					; 00000040H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 459				; 000001cbH
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 183  : 	memset( waitingForSequencedPacketWriteIndex, 0, NUMBER_OF_ORDERED_STREAMS * sizeof(OrderingIndexType) );

	push	64					; 00000040H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 523				; 0000020bH
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 184  : 	memset( &statistics, 0, sizeof( statistics ) );

	push	196					; 000000c4H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 731				; 000002dbH
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 185  : 	statistics.connectionStartTime = RakNet::GetTime();

	call	?GetTime@RakNet@@YAIXZ			; RakNet::GetTime
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+923], eax

; 186  : 	splitPacketId = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+721], ax

; 187  : 	messageNumber = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+176], ax

; 188  : 	availableBandwidth=0;

	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR [eax+1010], xmm0

; 189  : 	lastUpdateTime= RakNet::GetTimeNS();

	call	?GetTimeNS@RakNet@@YA_JXZ		; RakNet::GetTimeNS
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+946], eax
	mov	DWORD PTR [ecx+950], edx

; 190  : 	currentBandwidth=STARTING_SEND_BPS;

	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR _STARTING_SEND_BPS
	movsd	QWORD PTR [eax+1002], xmm0

; 191  : 	// lastPacketSendTime=retransmittedFrames=sentPackets=sentFrames=receivedPacketsCount=bytesSent=bytesReceived=0;
; 192  : 
; 193  : 	deadConnection = cheater = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+716], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+715], 0

; 194  : 	lastAckTime = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+178], 0
	mov	DWORD PTR [eax+182], 0

; 195  : 
; 196  : 	lowBandwidth=STARTING_SEND_BPS;

	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR _STARTING_SEND_BPS
	movsd	QWORD PTR [eax+986], xmm0

; 197  : 	histogramStartTime=lastUpdateTime+TIME_TO_NEW_SAMPLE+ping*2*1000;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+946]
	add	ecx, 500000				; 0007a120H
	mov	edx, DWORD PTR [eax+950]
	adc	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+717]
	shl	eax, 1
	imul	eax, eax, 1000
	xor	esi, esi
	add	ecx, eax
	adc	edx, esi
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+962], ecx
	mov	DWORD PTR [eax+966], edx

; 198  : 	histogramEndTime=histogramStartTime+MAX_TIME_TO_SAMPLE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+962]
	add	ecx, 250000				; 0003d090H
	mov	edx, DWORD PTR [eax+966]
	adc	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+954], ecx
	mov	DWORD PTR [eax+958], edx

; 199  : 
; 200  : 	highBandwidth=0;

	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR [eax+994], xmm0

; 201  : 	histogramPlossCount=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+978], 0

; 202  : 	histogramAckCount=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+982], 0

; 203  : 	continuousSend=false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1018], 0

; 204  : 	histogramReceiveMarker=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+970], 0

; 205  : 	noPacketlossIncreaseCount=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+974], 0

; 206  : 	nextAckTime=statistics.connectionStartTime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+923]
	xor	edx, edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], ecx
	mov	DWORD PTR [eax+44], edx

; 207  : 
; 208  : 	receivedPacketsBaseIndex=0;

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+943], ax

; 209  : 	resetReceivedPackets=true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+945], 1

; 210  : 	sendPacketCount=receivePacketCount=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1633], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1629], 0

; 211  : 	SetPing( 1000 );

	push	1000					; 000003e8H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPing@ReliabilityLayer@@QAEXI@Z	; ReliabilityLayer::SetPing

; 212  : 	resendList.Preallocate(RESEND_TREE_ORDER*2);

	push	64					; 00000040H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	?Preallocate@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QAEXH@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::Preallocate

; 213  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?InitializeVariables@ReliabilityLayer@@AAEXXZ ENDP	; ReliabilityLayer::InitializeVariables
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?FreeThreadSafeMemory@ReliabilityLayer@@AAEXXZ
_TEXT	SEGMENT
tv198 = -388						; size = 4
tv139 = -388						; size = 4
$T1 = -380						; size = 4
$T2 = -368						; size = 4
$T3 = -356						; size = 4
$T4 = -344						; size = 4
$T5 = -332						; size = 4
$T6 = -320						; size = 4
$T7 = -308						; size = 4
$T8 = -296						; size = 4
$T9 = -284						; size = 4
$T10 = -272						; size = 4
_i$11 = -68						; size = 4
_theList$12 = -56					; size = 4
_internalPacket$ = -44					; size = 4
_j$ = -32						; size = 4
_i$ = -20						; size = 4
_this$ = -8						; size = 4
?FreeThreadSafeMemory@ReliabilityLayer@@AAEXXZ PROC	; ReliabilityLayer::FreeThreadSafeMemory, COMDAT
; _this$ = ecx

; 237  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 388				; 00000184H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-388]
	mov	ecx, 97					; 00000061H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 238  : 	unsigned i,j;
; 239  : 	InternalPacket *internalPacket;
; 240  : 
; 241  : 	for (i=0; i < splitPacketChannelList.Size(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN27@FreeThread
$LN26@FreeThread:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN27@FreeThread:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	?Size@?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	$LN25@FreeThread

; 242  : 	{
; 243  : 		for (j=0; j < splitPacketChannelList[i]->splitPacketList.Size(); j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN24@FreeThread
$LN23@FreeThread:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN24@FreeThread:
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??A?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	call	?Size@?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::Size
	cmp	DWORD PTR _j$[ebp], eax
	jae	SHORT $LN22@FreeThread

; 244  : 		{
; 245  : 			delete [] splitPacketChannelList[i]->splitPacketList[j]->data;

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??A?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	call	??A?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEAAPAUInternalPacket@@I@Z ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::operator[]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+47]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 246  : 			internalPacketPool.ReleasePointer( splitPacketChannelList[i]->splitPacketList[j] );

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??A?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	call	??A?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEAAPAUInternalPacket@@I@Z ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::operator[]
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	call	?ReleasePointer@InternalPacketPool@@QAEXPAUInternalPacket@@@Z ; InternalPacketPool::ReleasePointer

; 247  : 		}

	jmp	$LN23@FreeThread
$LN22@FreeThread:

; 248  : 		delete splitPacketChannelList[i];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??A?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T3[ebp], ecx
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR $T2[ebp], edx
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN30@FreeThread
	push	1
	mov	ecx, DWORD PTR $T2[ebp]
	call	??_GSplitPacketChannel@@QAEPAXI@Z
	mov	DWORD PTR tv139[ebp], eax
	jmp	SHORT $LN31@FreeThread
$LN30@FreeThread:
	mov	DWORD PTR tv139[ebp], 0
$LN31@FreeThread:

; 249  : 	}

	jmp	$LN26@FreeThread
$LN25@FreeThread:

; 250  : 	splitPacketChannelList.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	?Clear@?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QAEXXZ ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::Clear
$LN21@FreeThread:

; 251  : 
; 252  : 	while ( outputQueue.Size() > 0 )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?Size@?$Queue@PAUInternalPacket@@@DataStructures@@QBEIXZ ; DataStructures::Queue<InternalPacket *>::Size
	test	eax, eax
	jbe	SHORT $LN20@FreeThread

; 253  : 	{
; 254  : 		internalPacket = outputQueue.Pop();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?Pop@?$Queue@PAUInternalPacket@@@DataStructures@@QAEPAUInternalPacket@@XZ ; DataStructures::Queue<InternalPacket *>::Pop
	mov	DWORD PTR _internalPacket$[ebp], eax

; 255  : 		delete [] internalPacket->data;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR [eax+47]
	mov	DWORD PTR $T4[ebp], ecx
	mov	edx, DWORD PTR $T4[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 256  : 		internalPacketPool.ReleasePointer( internalPacket );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	call	?ReleasePointer@InternalPacketPool@@QAEXPAUInternalPacket@@@Z ; InternalPacketPool::ReleasePointer

; 257  : 	}

	jmp	SHORT $LN21@FreeThread
$LN20@FreeThread:

; 258  : 
; 259  : 	outputQueue.ClearAndForceAllocation( 32 );

	push	32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?ClearAndForceAllocation@?$Queue@PAUInternalPacket@@@DataStructures@@QAEXH@Z ; DataStructures::Queue<InternalPacket *>::ClearAndForceAllocation

; 260  : 
; 261  : 	for ( i = 0; i < orderingList.Size(); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN19@FreeThread
$LN18@FreeThread:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN19@FreeThread:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::LinkedList<InternalPacket *> *>::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	$LN17@FreeThread

; 262  : 	{
; 263  : 		if ( orderingList[ i ] )

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QBEAAPAV?$LinkedList@PAUInternalPacket@@@1@I@Z ; DataStructures::List<DataStructures::LinkedList<InternalPacket *> *>::operator[]
	cmp	DWORD PTR [eax], 0
	je	$LN16@FreeThread

; 264  : 		{
; 265  : 			DataStructures::LinkedList<InternalPacket*>* theList = orderingList[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QBEAAPAV?$LinkedList@PAUInternalPacket@@@1@I@Z ; DataStructures::List<DataStructures::LinkedList<InternalPacket *> *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _theList$12[ebp], ecx

; 266  : 
; 267  : 			if ( theList )

	cmp	DWORD PTR _theList$12[ebp], 0
	je	$LN16@FreeThread
$LN14@FreeThread:

; 268  : 			{
; 269  : 				while ( theList->Size() )

	mov	ecx, DWORD PTR _theList$12[ebp]
	call	?Size@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEIXZ ; DataStructures::CircularLinkedList<InternalPacket *>::Size
	test	eax, eax
	je	SHORT $LN13@FreeThread

; 270  : 				{
; 271  : 					internalPacket = orderingList[ i ]->Pop();

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QBEAAPAV?$LinkedList@PAUInternalPacket@@@1@I@Z ; DataStructures::List<DataStructures::LinkedList<InternalPacket *> *>::operator[]
	mov	ecx, DWORD PTR [eax]
	call	?Pop@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEPAUInternalPacket@@XZ ; DataStructures::CircularLinkedList<InternalPacket *>::Pop
	mov	DWORD PTR _internalPacket$[ebp], eax

; 272  : 					delete [] internalPacket->data;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR [eax+47]
	mov	DWORD PTR $T5[ebp], ecx
	mov	edx, DWORD PTR $T5[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 273  : 					internalPacketPool.ReleasePointer( internalPacket );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	call	?ReleasePointer@InternalPacketPool@@QAEXPAUInternalPacket@@@Z ; InternalPacketPool::ReleasePointer

; 274  : 				}

	jmp	SHORT $LN14@FreeThread
$LN13@FreeThread:

; 275  : 
; 276  : 				delete theList;

	mov	eax, DWORD PTR _theList$12[ebp]
	mov	DWORD PTR $T7[ebp], eax
	mov	ecx, DWORD PTR $T7[ebp]
	mov	DWORD PTR $T6[ebp], ecx
	cmp	DWORD PTR $T6[ebp], 0
	je	SHORT $LN32@FreeThread
	push	1
	mov	ecx, DWORD PTR $T6[ebp]
	call	??_G?$LinkedList@PAUInternalPacket@@@DataStructures@@QAEPAXI@Z
	mov	DWORD PTR tv198[ebp], eax
	jmp	SHORT $LN16@FreeThread
$LN32@FreeThread:
	mov	DWORD PTR tv198[ebp], 0
$LN16@FreeThread:

; 277  : 			}
; 278  : 		}
; 279  : 	}

	jmp	$LN18@FreeThread
$LN17@FreeThread:

; 280  : 
; 281  : 	orderingList.Clear();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QAEX_N@Z ; DataStructures::List<DataStructures::LinkedList<InternalPacket *> *>::Clear

; 282  : 
; 283  : 	//resendList.ForEachData(DeleteInternalPacket);
; 284  : 	resendList.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	?Clear@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QAEXXZ ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::Clear
$LN12@FreeThread:

; 285  : 	while ( resendQueue.Size() )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	?Size@?$Queue@PAUInternalPacket@@@DataStructures@@QBEIXZ ; DataStructures::Queue<InternalPacket *>::Size
	test	eax, eax
	je	SHORT $LN11@FreeThread

; 286  : 	{
; 287  : 		// The resend Queue can have NULL pointer holes.  This is so we can deallocate blocks without having to compress the array
; 288  : 		internalPacket = resendQueue.Pop();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	?Pop@?$Queue@PAUInternalPacket@@@DataStructures@@QAEPAUInternalPacket@@XZ ; DataStructures::Queue<InternalPacket *>::Pop
	mov	DWORD PTR _internalPacket$[ebp], eax

; 289  : 
; 290  : 		if ( internalPacket )

	cmp	DWORD PTR _internalPacket$[ebp], 0
	je	SHORT $LN10@FreeThread

; 291  : 		{
; 292  : 			delete [] internalPacket->data;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR [eax+47]
	mov	DWORD PTR $T8[ebp], ecx
	mov	edx, DWORD PTR $T8[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 293  : 			internalPacketPool.ReleasePointer( internalPacket );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	call	?ReleasePointer@InternalPacketPool@@QAEXPAUInternalPacket@@@Z ; InternalPacketPool::ReleasePointer
$LN10@FreeThread:

; 294  : 		}
; 295  : 	}

	jmp	SHORT $LN12@FreeThread
$LN11@FreeThread:

; 296  : 	resendQueue.ClearAndForceAllocation( DEFAULT_HAS_RECEIVED_PACKET_QUEUE_SIZE );

	push	512					; 00000200H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	?ClearAndForceAllocation@?$Queue@PAUInternalPacket@@@DataStructures@@QAEXH@Z ; DataStructures::Queue<InternalPacket *>::ClearAndForceAllocation

; 297  : 
; 298  : 
; 299  : 	for ( i = 0; i < NUMBER_OF_PRIORITIES; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN9@FreeThread
$LN8@FreeThread:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN9@FreeThread:
	cmp	DWORD PTR _i$[ebp], 4
	jae	$LN7@FreeThread

; 300  : 	{
; 301  : 		j = 0;

	mov	DWORD PTR _j$[ebp], 0

; 302  : 		for ( ; j < sendPacketSet[ i ].Size(); j++ )

	jmp	SHORT $LN6@FreeThread
$LN5@FreeThread:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN6@FreeThread:
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ecx+eax+100]
	call	?Size@?$Queue@PAUInternalPacket@@@DataStructures@@QBEIXZ ; DataStructures::Queue<InternalPacket *>::Size
	cmp	DWORD PTR _j$[ebp], eax
	jae	SHORT $LN4@FreeThread

; 303  : 		{
; 304  : 		delete [] ( sendPacketSet[ i ] ) [ j ]->data;

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+100]
	call	??A?$Queue@PAUInternalPacket@@@DataStructures@@QBEAAPAUInternalPacket@@I@Z ; DataStructures::Queue<InternalPacket *>::operator[]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+47]
	mov	DWORD PTR $T9[ebp], ecx
	mov	edx, DWORD PTR $T9[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 305  : 		internalPacketPool.ReleasePointer( ( sendPacketSet[ i ] ) [ j ] );

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+100]
	call	??A?$Queue@PAUInternalPacket@@@DataStructures@@QBEAAPAUInternalPacket@@I@Z ; DataStructures::Queue<InternalPacket *>::operator[]
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	call	?ReleasePointer@InternalPacketPool@@QAEXPAUInternalPacket@@@Z ; InternalPacketPool::ReleasePointer

; 306  : 		}

	jmp	SHORT $LN5@FreeThread
$LN4@FreeThread:

; 307  : 
; 308  : 		sendPacketSet[ i ].ClearAndForceAllocation( 32 ); // Preallocate the send lists so we don't do a bunch of reallocations unnecessarily

	push	32					; 00000020H
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ecx+eax+100]
	call	?ClearAndForceAllocation@?$Queue@PAUInternalPacket@@@DataStructures@@QAEXH@Z ; DataStructures::Queue<InternalPacket *>::ClearAndForceAllocation

; 309  : 	}

	jmp	$LN8@FreeThread
$LN7@FreeThread:

; 310  : 
; 311  : #ifndef _RELEASE
; 312  : 	for (unsigned i = 0; i < delayList.Size(); i++ )

	mov	DWORD PTR _i$11[ebp], 0
	jmp	SHORT $LN3@FreeThread
$LN2@FreeThread:
	mov	eax, DWORD PTR _i$11[ebp]
	add	eax, 1
	mov	DWORD PTR _i$11[ebp], eax
$LN3@FreeThread:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1646				; 0000066eH
	call	?Size@?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QBEIXZ ; DataStructures::List<ReliabilityLayer::DataAndTime *>::Size
	cmp	DWORD PTR _i$11[ebp], eax
	jae	SHORT $LN1@FreeThread

; 313  : 		delete delayList[ i ];

	mov	eax, DWORD PTR _i$11[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1646				; 0000066eH
	call	??A?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QBEAAPAUDataAndTime@ReliabilityLayer@@I@Z ; DataStructures::List<ReliabilityLayer::DataAndTime *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T10[ebp], ecx
	mov	edx, DWORD PTR $T10[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	jmp	SHORT $LN2@FreeThread
$LN1@FreeThread:

; 314  : 	delayList.Clear();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1646				; 0000066eH
	call	?Clear@?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QAEX_N@Z ; DataStructures::List<ReliabilityLayer::DataAndTime *>::Clear

; 315  : #endif
; 316  : 
; 317  : 	internalPacketPool.ClearPool();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	call	?ClearPool@InternalPacketPool@@QAEXXZ	; InternalPacketPool::ClearPool

; 318  : 
; 319  : 	//messageHistogram.Clear();
; 320  : 
; 321  : 	acknowlegements.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?Clear@?$RangeList@G@DataStructures@@QAEXXZ ; DataStructures::RangeList<unsigned short>::Clear

; 322  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 388				; 00000184H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeThreadSafeMemory@ReliabilityLayer@@AAEXXZ ENDP	; ReliabilityLayer::FreeThreadSafeMemory
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?FreeThreadedMemory@ReliabilityLayer@@AAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?FreeThreadedMemory@ReliabilityLayer@@AAEXXZ PROC	; ReliabilityLayer::FreeThreadedMemory, COMDAT
; _this$ = ecx

; 233  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 234  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeThreadedMemory@ReliabilityLayer@@AAEXXZ ENDP	; ReliabilityLayer::FreeThreadedMemory
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?FreeMemory@ReliabilityLayer@@AAEX_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_freeAllImmediately$ = 8				; size = 1
?FreeMemory@ReliabilityLayer@@AAEX_N@Z PROC		; ReliabilityLayer::FreeMemory, COMDAT
; _this$ = ecx

; 219  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 220  : 	if ( freeAllImmediately )

	movzx	eax, BYTE PTR _freeAllImmediately$[ebp]
	test	eax, eax
	je	SHORT $LN2@FreeMemory

; 221  : 	{
; 222  : 		FreeThreadedMemory();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeThreadedMemory@ReliabilityLayer@@AAEXXZ ; ReliabilityLayer::FreeThreadedMemory

; 223  : 		FreeThreadSafeMemory();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeThreadSafeMemory@ReliabilityLayer@@AAEXXZ ; ReliabilityLayer::FreeThreadSafeMemory

; 224  : 	}
; 225  : 	else

	jmp	SHORT $LN3@FreeMemory
$LN2@FreeMemory:

; 226  : 	{
; 227  : 		FreeThreadSafeMemory();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeThreadSafeMemory@ReliabilityLayer@@AAEXXZ ; ReliabilityLayer::FreeThreadSafeMemory

; 228  : 		freeThreadedMemoryOnNextUpdate = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1645], 1
$LN3@FreeMemory:

; 229  : 	}
; 230  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?FreeMemory@ReliabilityLayer@@AAEX_N@Z ENDP		; ReliabilityLayer::FreeMemory
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?InsertPacketIntoResendList@ReliabilityLayer@@AAEXPAUInternalPacket@@_J_N2@Z
_TEXT	SEGMENT
tv147 = -220						; size = 4
tv128 = -220						; size = 4
_pool$1 = -20						; size = 4
_this$ = -8						; size = 4
_internalPacket$ = 8					; size = 4
_time$ = 12						; size = 8
_makeCopyOfInternalPacket$ = 20				; size = 1
_firstResend$ = 24					; size = 1
?InsertPacketIntoResendList@ReliabilityLayer@@AAEXPAUInternalPacket@@_J_N2@Z PROC ; ReliabilityLayer::InsertPacketIntoResendList, COMDAT
; _this$ = ecx

; 2402 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2403 : 	// lastAckTime is the time we last got an acknowledgment - however we also initialize the value if this is the first resend and
; 2404 : 	// either we never got an ack before or we are inserting into an empty resend queue
; 2405 : 	if ( firstResend && (lastAckTime == 0 || resendList.IsEmpty()))

	movzx	eax, BYTE PTR _firstResend$[ebp]
	test	eax, eax
	je	SHORT $LN4@InsertPack
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv128[ebp], eax
	mov	ecx, DWORD PTR tv128[ebp]
	mov	edx, DWORD PTR tv128[ebp]
	mov	eax, DWORD PTR [ecx+178]
	or	eax, DWORD PTR [edx+182]
	je	SHORT $LN3@InsertPack
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	?IsEmpty@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QBE_NXZ ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::IsEmpty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@InsertPack
$LN3@InsertPack:

; 2406 : 	{
; 2407 : 		lastAckTime = time; // Start the timer for the ack of this packet if we aren't already waiting for an ack

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _time$[ebp]
	mov	DWORD PTR [eax+178], ecx
	mov	edx, DWORD PTR _time$[ebp+4]
	mov	DWORD PTR [eax+182], edx
$LN4@InsertPack:

; 2408 : 	}
; 2409 : 
; 2410 : 	if (makeCopyOfInternalPacket)

	movzx	eax, BYTE PTR _makeCopyOfInternalPacket$[ebp]
	test	eax, eax
	je	SHORT $LN2@InsertPack

; 2411 : 	{
; 2412 : 		InternalPacket *pool=internalPacketPool.GetPointer();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	call	?GetPointer@InternalPacketPool@@QAEPAUInternalPacket@@XZ ; InternalPacketPool::GetPointer
	mov	DWORD PTR _pool$1[ebp], eax

; 2413 : 		//printf("Adding %i\n", internalPacket->data);
; 2414 : 		memcpy(pool, internalPacket, sizeof(InternalPacket));

	push	55					; 00000037H
	mov	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pool$1[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2415 : 		resendQueue.Push( pool );

	lea	eax, DWORD PTR _pool$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	?Push@?$Queue@PAUInternalPacket@@@DataStructures@@QAEXABQAUInternalPacket@@@Z ; DataStructures::Queue<InternalPacket *>::Push

; 2416 : 	}
; 2417 : 	else

	jmp	SHORT $LN5@InsertPack
$LN2@InsertPack:

; 2418 : 	{
; 2419 : 		RakAssert(internalPacket->nextActionTime!=0);

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	DWORD PTR tv147[ebp], eax
	mov	ecx, DWORD PTR tv147[ebp]
	mov	edx, DWORD PTR tv147[ebp]
	mov	eax, DWORD PTR [ecx+35]
	or	eax, DWORD PTR [edx+39]
	jne	SHORT $LN7@InsertPack
	mov	ecx, DWORD PTR ?__LINE__Var@?1??InsertPacketIntoResendList@ReliabilityLayer@@AAEXPAUInternalPacket@@_J_N2@Z@4JA
	add	ecx, 17					; 00000011H
	push	ecx
	push	OFFSET ??_C@_1FK@FKLHGKMO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAe?$AAl?$AAi?$AAa?$AAb?$AAi?$AAl@
	push	OFFSET ??_C@_1EE@KHBHHHAB@?$AAi?$AAn?$AAt?$AAe?$AAr?$AAn?$AAa?$AAl?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAA?$AAc?$AAt?$AAi?$AAo?$AAn?$AAT?$AAi?$AAm?$AAe?$AA?$CB?$AA?$DN@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN7@InsertPack:

; 2420 : 
; 2421 : 		resendQueue.Push( internalPacket );

	lea	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	?Push@?$Queue@PAUInternalPacket@@@DataStructures@@QAEXABQAUInternalPacket@@@Z ; DataStructures::Queue<InternalPacket *>::Push
$LN5@InsertPack:

; 2422 : 	}
; 2423 : 
; 2424 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@InsertPack
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN10@InsertPack:
	DD	1
	DD	$LN9@InsertPack
$LN9@InsertPack:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN8@InsertPack
$LN8@InsertPack:
	DB	112					; 00000070H
	DB	111					; 0000006fH
	DB	111					; 0000006fH
	DB	108					; 0000006cH
	DB	0
?InsertPacketIntoResendList@ReliabilityLayer@@AAEXPAUInternalPacket@@_J_N2@Z ENDP ; ReliabilityLayer::InsertPacketIntoResendList
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?AddToOrderingList@ReliabilityLayer@@AAEXPAUInternalPacket@@@Z
_TEXT	SEGMENT
tv133 = -256						; size = 4
$T2 = -248						; size = 4
$T3 = -236						; size = 4
_theList$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_internalPacket$ = 8					; size = 4
?AddToOrderingList@ReliabilityLayer@@AAEXPAUInternalPacket@@@Z PROC ; ReliabilityLayer::AddToOrderingList, COMDAT
; _this$ = ecx

; 2363 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddToOrderingList@ReliabilityLayer@@AAEXPAUInternalPacket@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2364 : #ifdef _DEBUG
; 2365 : 	assert( internalPacket->orderingChannel < NUMBER_OF_ORDERED_STREAMS );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	movzx	ecx, BYTE PTR [eax+14]
	cmp	ecx, 32					; 00000020H
	jl	SHORT $LN9@AddToOrder
	mov	edx, DWORD PTR ?__LINE__Var@?1??AddToOrderingList@ReliabilityLayer@@AAEXPAUInternalPacket@@@Z@4JA
	add	edx, 2
	push	edx
	push	OFFSET ??_C@_1FK@FKLHGKMO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAe?$AAl?$AAi?$AAa?$AAb?$AAi?$AAl@
	push	OFFSET ??_C@_1HI@MKMNOBIC@?$AAi?$AAn?$AAt?$AAe?$AAr?$AAn?$AAa?$AAl?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?9?$AA?$DO?$AAo?$AAr?$AAd?$AAe?$AAr?$AAi?$AAn?$AAg?$AAC?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AA?5@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN9@AddToOrder:

; 2366 : #endif
; 2367 : 
; 2368 : 	if ( internalPacket->orderingChannel >= NUMBER_OF_ORDERED_STREAMS )

	mov	eax, DWORD PTR _internalPacket$[ebp]
	movzx	ecx, BYTE PTR [eax+14]
	cmp	ecx, 32					; 00000020H
	jl	SHORT $LN6@AddToOrder

; 2369 : 	{
; 2370 : 		return;

	jmp	$LN7@AddToOrder
$LN6@AddToOrder:

; 2371 : 	}
; 2372 : 
; 2373 : 	DataStructures::LinkedList<InternalPacket*> *theList;
; 2374 : 
; 2375 : 	if ( internalPacket->orderingChannel >= orderingList.Size() || orderingList[ internalPacket->orderingChannel ] == 0 )

	mov	eax, DWORD PTR _internalPacket$[ebp]
	movzx	esi, BYTE PTR [eax+14]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::LinkedList<InternalPacket *> *>::Size
	cmp	esi, eax
	jae	SHORT $LN4@AddToOrder
	mov	eax, DWORD PTR _internalPacket$[ebp]
	movzx	ecx, BYTE PTR [eax+14]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QBEAAPAV?$LinkedList@PAUInternalPacket@@@1@I@Z ; DataStructures::List<DataStructures::LinkedList<InternalPacket *> *>::operator[]
	cmp	DWORD PTR [eax], 0
	jne	$LN5@AddToOrder
$LN4@AddToOrder:

; 2376 : 	{
; 2377 : 		// Need a linked list in this index
; 2378 : 		orderingList.Replace( new DataStructures::LinkedList<InternalPacket*>, 0, internalPacket->orderingChannel );

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN10@AddToOrder
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0?$LinkedList@PAUInternalPacket@@@DataStructures@@QAE@XZ ; DataStructures::LinkedList<InternalPacket *>::LinkedList<InternalPacket *>
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN11@AddToOrder
$LN10@AddToOrder:
	mov	DWORD PTR tv133[ebp], 0
$LN11@AddToOrder:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _internalPacket$[ebp]
	movzx	edx, BYTE PTR [ecx+14]
	push	edx
	push	0
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Replace@?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QAEXQAV?$LinkedList@PAUInternalPacket@@@2@0I@Z ; DataStructures::List<DataStructures::LinkedList<InternalPacket *> *>::Replace

; 2379 : 		theList=orderingList[ internalPacket->orderingChannel ];

	mov	eax, DWORD PTR _internalPacket$[ebp]
	movzx	ecx, BYTE PTR [eax+14]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QBEAAPAV?$LinkedList@PAUInternalPacket@@@1@I@Z ; DataStructures::List<DataStructures::LinkedList<InternalPacket *> *>::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _theList$[ebp], edx

; 2380 : 	}
; 2381 : 	else

	jmp	SHORT $LN3@AddToOrder
$LN5@AddToOrder:

; 2382 : 	{
; 2383 : 		// Have a linked list in this index
; 2384 : 		if ( orderingList[ internalPacket->orderingChannel ]->Size() == 0 )

	mov	eax, DWORD PTR _internalPacket$[ebp]
	movzx	ecx, BYTE PTR [eax+14]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QBEAAPAV?$LinkedList@PAUInternalPacket@@@1@I@Z ; DataStructures::List<DataStructures::LinkedList<InternalPacket *> *>::operator[]
	mov	ecx, DWORD PTR [eax]
	call	?Size@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEIXZ ; DataStructures::CircularLinkedList<InternalPacket *>::Size
	test	eax, eax
	jne	SHORT $LN2@AddToOrder

; 2385 : 		{
; 2386 : 			theList=orderingList[ internalPacket->orderingChannel ];

	mov	eax, DWORD PTR _internalPacket$[ebp]
	movzx	ecx, BYTE PTR [eax+14]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QBEAAPAV?$LinkedList@PAUInternalPacket@@@1@I@Z ; DataStructures::List<DataStructures::LinkedList<InternalPacket *> *>::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _theList$[ebp], edx

; 2387 : 		}
; 2388 : 		else

	jmp	SHORT $LN3@AddToOrder
$LN2@AddToOrder:

; 2389 : 		{
; 2390 : 			theList = GetOrderingListAtOrderingStream( internalPacket->orderingChannel );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	movzx	ecx, BYTE PTR [eax+14]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOrderingListAtOrderingStream@ReliabilityLayer@@AAEPAV?$LinkedList@PAUInternalPacket@@@DataStructures@@E@Z ; ReliabilityLayer::GetOrderingListAtOrderingStream
	mov	DWORD PTR _theList$[ebp], eax
$LN3@AddToOrder:

; 2391 : 		}
; 2392 : 	}
; 2393 : 
; 2394 : 	theList->End();

	mov	ecx, DWORD PTR _theList$[ebp]
	call	?End@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEXXZ ; DataStructures::CircularLinkedList<InternalPacket *>::End

; 2395 : 	theList->Add(internalPacket);

	lea	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _theList$[ebp]
	call	?Add@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEAAPAUInternalPacket@@ABQAU3@@Z ; DataStructures::CircularLinkedList<InternalPacket *>::Add
$LN7@AddToOrder:

; 2396 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddToOrderingList@ReliabilityLayer@@AAEXPAUInternalPacket@@@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?AddToOrderingList@ReliabilityLayer@@AAEXPAUInternalPacket@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-260]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddToOrderingList@ReliabilityLayer@@AAEXPAUInternalPacket@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddToOrderingList@ReliabilityLayer@@AAEXPAUInternalPacket@@@Z ENDP ; ReliabilityLayer::AddToOrderingList
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?GetOrderingListAtOrderingStream@ReliabilityLayer@@AAEPAV?$LinkedList@PAUInternalPacket@@@DataStructures@@E@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_orderingChannel$ = 8					; size = 1
?GetOrderingListAtOrderingStream@ReliabilityLayer@@AAEPAV?$LinkedList@PAUInternalPacket@@@DataStructures@@E@Z PROC ; ReliabilityLayer::GetOrderingListAtOrderingStream, COMDAT
; _this$ = ecx

; 2352 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2353 : 	if ( orderingChannel >= orderingList.Size() )

	movzx	esi, BYTE PTR _orderingChannel$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::LinkedList<InternalPacket *> *>::Size
	cmp	esi, eax
	jb	SHORT $LN1@GetOrderin

; 2354 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN2@GetOrderin
$LN1@GetOrderin:

; 2355 : 
; 2356 : 	return orderingList[ orderingChannel ];

	movzx	eax, BYTE PTR _orderingChannel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QBEAAPAV?$LinkedList@PAUInternalPacket@@@1@I@Z ; DataStructures::List<DataStructures::LinkedList<InternalPacket *> *>::operator[]
	mov	eax, DWORD PTR [eax]
$LN2@GetOrderin:

; 2357 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetOrderingListAtOrderingStream@ReliabilityLayer@@AAEPAV?$LinkedList@PAUInternalPacket@@@DataStructures@@E@Z ENDP ; ReliabilityLayer::GetOrderingListAtOrderingStream
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?CreateInternalPacketCopy@ReliabilityLayer@@AAEPAUInternalPacket@@PAU2@HH_J@Z
_TEXT	SEGMENT
$T1 = -224						; size = 4
_copy$ = -20						; size = 4
_this$ = -8						; size = 4
_original$ = 8						; size = 4
_dataByteOffset$ = 12					; size = 4
_dataByteLength$ = 16					; size = 4
_time$ = 20						; size = 8
?CreateInternalPacketCopy@ReliabilityLayer@@AAEPAUInternalPacket@@PAU2@HH_J@Z PROC ; ReliabilityLayer::CreateInternalPacketCopy, COMDAT
; _this$ = ecx

; 2320 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2321 : 	InternalPacket * copy = internalPacketPool.GetPointer();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	call	?GetPointer@InternalPacketPool@@QAEPAUInternalPacket@@XZ ; InternalPacketPool::GetPointer
	mov	DWORD PTR _copy$[ebp], eax

; 2322 : #ifdef _DEBUG
; 2323 : 	// Remove accessing undefined memory error
; 2324 : 	memset( copy, 255, sizeof( InternalPacket ) );

	push	55					; 00000037H
	push	255					; 000000ffH
	mov	eax, DWORD PTR _copy$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2325 : #endif
; 2326 : 	// Copy over our chunk of data
; 2327 : 
; 2328 : 	if ( dataByteLength > 0 )

	cmp	DWORD PTR _dataByteLength$[ebp], 0
	jle	SHORT $LN2@CreateInte

; 2329 : 	{
; 2330 : 		copy->data = new unsigned char[ dataByteLength ];

	mov	eax, DWORD PTR _dataByteLength$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR _copy$[ebp]
	mov	edx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [ecx+47], edx

; 2331 : 		memcpy( copy->data, original->data + dataByteOffset, dataByteLength );

	mov	eax, DWORD PTR _dataByteLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _original$[ebp]
	mov	edx, DWORD PTR [ecx+47]
	add	edx, DWORD PTR _dataByteOffset$[ebp]
	push	edx
	mov	eax, DWORD PTR _copy$[ebp]
	mov	ecx, DWORD PTR [eax+47]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2332 : 	}
; 2333 : 	else

	jmp	SHORT $LN1@CreateInte
$LN2@CreateInte:

; 2334 : 		copy->data = 0;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	DWORD PTR [eax+47], 0
$LN1@CreateInte:

; 2335 : 
; 2336 : 	copy->dataBitLength = dataByteLength << 3;

	mov	eax, DWORD PTR _dataByteLength$[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR _copy$[ebp]
	mov	DWORD PTR [ecx+43], eax

; 2337 : 	copy->creationTime = time;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	ecx, DWORD PTR _time$[ebp]
	mov	DWORD PTR [eax+27], ecx
	mov	edx, DWORD PTR _time$[ebp+4]
	mov	DWORD PTR [eax+31], edx

; 2338 : 	copy->nextActionTime = 0;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	DWORD PTR [eax+35], 0
	mov	DWORD PTR [eax+39], 0

; 2339 : 	copy->orderingIndex = original->orderingIndex;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	ecx, DWORD PTR _original$[ebp]
	mov	dx, WORD PTR [ecx+15]
	mov	WORD PTR [eax+15], dx

; 2340 : 	copy->orderingChannel = original->orderingChannel;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	ecx, DWORD PTR _original$[ebp]
	mov	dl, BYTE PTR [ecx+14]
	mov	BYTE PTR [eax+14], dl

; 2341 : 	copy->messageNumber = original->messageNumber;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	ecx, DWORD PTR _original$[ebp]
	mov	dx, WORD PTR [ecx]
	mov	WORD PTR [eax], dx

; 2342 : 	copy->priority = original->priority;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	ecx, DWORD PTR _original$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	mov	DWORD PTR [eax+6], edx

; 2343 : 	copy->reliability = original->reliability;

	mov	eax, DWORD PTR _copy$[ebp]
	mov	ecx, DWORD PTR _original$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	mov	DWORD PTR [eax+10], edx

; 2344 : 
; 2345 : 	return copy;

	mov	eax, DWORD PTR _copy$[ebp]

; 2346 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?CreateInternalPacketCopy@ReliabilityLayer@@AAEPAUInternalPacket@@PAU2@HH_J@Z ENDP ; ReliabilityLayer::CreateInternalPacketCopy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?DeleteOldUnreliableSplitPackets@ReliabilityLayer@@AAEX_J@Z
_TEXT	SEGMENT
tv190 = -272						; size = 8
tv165 = -268						; size = 4
$T1 = -260						; size = 4
$T2 = -248						; size = 4
$T3 = -236						; size = 4
_j$ = -32						; size = 4
_i$ = -20						; size = 4
_this$ = -8						; size = 4
_time$ = 8						; size = 8
?DeleteOldUnreliableSplitPackets@ReliabilityLayer@@AAEX_J@Z PROC ; ReliabilityLayer::DeleteOldUnreliableSplitPackets, COMDAT
; _this$ = ecx

; 2294 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 272				; 00000110H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-272]
	mov	ecx, 68					; 00000044H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2295 : 	unsigned i,j;
; 2296 : 	i=0;

	mov	DWORD PTR _i$[ebp], 0
$LN8@DeleteOldU:

; 2297 : 	while (i < splitPacketChannelList.Size())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	?Size@?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	$LN9@DeleteOldU

; 2298 : 	{
; 2299 : 		if (time > splitPacketChannelList[i]->lastUpdateTime + 10000000 &&
; 2300 : 			(splitPacketChannelList[i]->splitPacketList[0]->reliability==UNRELIABLE || splitPacketChannelList[i]->splitPacketList[0]->reliability==UNRELIABLE_SEQUENCED))

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??A?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	add	edx, 10000000				; 00989680H
	mov	eax, DWORD PTR [ecx+4]
	adc	eax, 0
	mov	DWORD PTR tv190[ebp], edx
	mov	DWORD PTR tv190[ebp+4], eax
	mov	ecx, DWORD PTR _time$[ebp+4]
	cmp	ecx, DWORD PTR tv190[ebp+4]
	jl	$LN6@DeleteOldU
	jg	SHORT $LN13@DeleteOldU
	mov	edx, DWORD PTR _time$[ebp]
	cmp	edx, DWORD PTR tv190[ebp]
	jbe	$LN6@DeleteOldU
$LN13@DeleteOldU:
	push	0
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??A?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	call	??A?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEAAPAUInternalPacket@@I@Z ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+10], 0
	je	SHORT $LN5@DeleteOldU
	push	0
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??A?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	call	??A?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEAAPAUInternalPacket@@I@Z ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+10], 1
	jne	$LN6@DeleteOldU
$LN5@DeleteOldU:

; 2301 : 		{
; 2302 : 			for (j=0; j < splitPacketChannelList[i]->splitPacketList.Size(); j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN4@DeleteOldU
$LN3@DeleteOldU:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN4@DeleteOldU:
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??A?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	call	?Size@?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::Size
	cmp	DWORD PTR _j$[ebp], eax
	jae	SHORT $LN2@DeleteOldU

; 2303 : 			{
; 2304 : 				delete [] splitPacketChannelList[i]->splitPacketList[j]->data;

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??A?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	call	??A?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEAAPAUInternalPacket@@I@Z ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::operator[]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+47]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 2305 : 				internalPacketPool.ReleasePointer(splitPacketChannelList[i]->splitPacketList[j]);

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??A?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	call	??A?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEAAPAUInternalPacket@@I@Z ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::operator[]
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	call	?ReleasePointer@InternalPacketPool@@QAEXPAUInternalPacket@@@Z ; InternalPacketPool::ReleasePointer

; 2306 : 			}

	jmp	$LN3@DeleteOldU
$LN2@DeleteOldU:

; 2307 : 			delete splitPacketChannelList[i];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??A?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T3[ebp], ecx
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR $T2[ebp], edx
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN11@DeleteOldU
	push	1
	mov	ecx, DWORD PTR $T2[ebp]
	call	??_GSplitPacketChannel@@QAEPAXI@Z
	mov	DWORD PTR tv165[ebp], eax
	jmp	SHORT $LN12@DeleteOldU
$LN11@DeleteOldU:
	mov	DWORD PTR tv165[ebp], 0
$LN12@DeleteOldU:

; 2308 : 			splitPacketChannelList.RemoveAtIndex(i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	?RemoveAtIndex@?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QAEXI@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::RemoveAtIndex

; 2309 : 		}
; 2310 : 		else

	jmp	SHORT $LN1@DeleteOldU
$LN6@DeleteOldU:

; 2311 : 			i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN1@DeleteOldU:

; 2312 : 	}

	jmp	$LN8@DeleteOldU
$LN9@DeleteOldU:

; 2313 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 272				; 00000110H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?DeleteOldUnreliableSplitPackets@ReliabilityLayer@@AAEX_J@Z ENDP ; ReliabilityLayer::DeleteOldUnreliableSplitPackets
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?BuildPacketFromSplitPacketList@ReliabilityLayer@@AAEPAUInternalPacket@@G_J@Z
_TEXT	SEGMENT
tv251 = -316						; size = 4
$T1 = -308						; size = 4
$T2 = -296						; size = 4
$T3 = -284						; size = 4
$T4 = -272						; size = 4
_objectExists$ = -65					; size = 1
_internalPacket$ = -56					; size = 4
_byteProgress$ = -44					; size = 4
_j$ = -32						; size = 4
_i$ = -20						; size = 4
_this$ = -8						; size = 4
_splitPacketId$ = 8					; size = 2
_time$ = 12						; size = 8
?BuildPacketFromSplitPacketList@ReliabilityLayer@@AAEPAUInternalPacket@@G_J@Z PROC ; ReliabilityLayer::BuildPacketFromSplitPacketList, COMDAT
; _this$ = ecx

; 2250 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 316				; 0000013cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-316]
	mov	ecx, 79					; 0000004fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2251 : 	unsigned i, j;
; 2252 : 	unsigned byteProgress;
; 2253 : 	InternalPacket * internalPacket;
; 2254 : 	bool objectExists;
; 2255 : 
; 2256 : 	i=splitPacketChannelList.GetIndexFromKey(splitPacketId, &objectExists);

	lea	eax, DWORD PTR _objectExists$[ebp]
	push	eax
	lea	ecx, DWORD PTR _splitPacketId$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	?GetIndexFromKey@?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEIABGPA_N@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::GetIndexFromKey
	mov	DWORD PTR _i$[ebp], eax

; 2257 : #ifdef _DEBUG
; 2258 : 	assert(objectExists);

	movzx	eax, BYTE PTR _objectExists$[ebp]
	test	eax, eax
	jne	SHORT $LN13@BuildPacke
	mov	ecx, DWORD PTR ?__LINE__Var@?1??BuildPacketFromSplitPacketList@ReliabilityLayer@@AAEPAUInternalPacket@@G_J@Z@4JA
	add	ecx, 8
	push	ecx
	push	OFFSET ??_C@_1FK@FKLHGKMO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAe?$AAl?$AAi?$AAa?$AAb?$AAi?$AAl@
	push	OFFSET ??_C@_1BK@EBNJALNF@?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAE?$AAx?$AAi?$AAs?$AAt?$AAs?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN13@BuildPacke:

; 2259 : #endif
; 2260 : 
; 2261 : 	if (splitPacketChannelList[i]->splitPacketList.Size()==splitPacketChannelList[i]->splitPacketList[0]->splitPacketCount)

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??A?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	call	?Size@?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::Size
	mov	esi, eax
	push	0
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??A?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	call	??A?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEAAPAUInternalPacket@@I@Z ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::operator[]
	mov	edx, DWORD PTR [eax]
	cmp	esi, DWORD PTR [edx+23]
	jne	$LN10@BuildPacke

; 2262 : 	{
; 2263 : 		// Reconstruct
; 2264 : 		internalPacket = CreateInternalPacketCopy( splitPacketChannelList[i]->splitPacketList[0], 0, 0, time );

	mov	eax, DWORD PTR _time$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _time$[ebp]
	push	ecx
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??A?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	call	??A?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEAAPAUInternalPacket@@I@Z ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::operator[]
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CreateInternalPacketCopy@ReliabilityLayer@@AAEPAUInternalPacket@@PAU2@HH_J@Z ; ReliabilityLayer::CreateInternalPacketCopy
	mov	DWORD PTR _internalPacket$[ebp], eax

; 2265 : 		internalPacket->dataBitLength=0;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	DWORD PTR [eax+43], 0

; 2266 : 		for (j=0; j < splitPacketChannelList[i]->splitPacketList.Size(); j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN9@BuildPacke
$LN8@BuildPacke:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN9@BuildPacke:
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??A?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	call	?Size@?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::Size
	cmp	DWORD PTR _j$[ebp], eax
	jae	SHORT $LN7@BuildPacke

; 2267 : 			internalPacket->dataBitLength+=splitPacketChannelList[i]->splitPacketList[j]->dataBitLength;

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??A?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	call	??A?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEAAPAUInternalPacket@@I@Z ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::operator[]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR [eax+43]
	add	ecx, DWORD PTR [edx+43]
	mov	edx, DWORD PTR _internalPacket$[ebp]
	mov	DWORD PTR [edx+43], ecx
	jmp	SHORT $LN8@BuildPacke
$LN7@BuildPacke:

; 2268 : 
; 2269 : 		internalPacket->data = new unsigned char[ BITS_TO_BYTES( internalPacket->dataBitLength ) ];

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR [eax+43]
	add	ecx, 7
	shr	ecx, 3
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	edx, DWORD PTR _internalPacket$[ebp]
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR [edx+47], eax

; 2270 : 
; 2271 : 		byteProgress=0;

	mov	DWORD PTR _byteProgress$[ebp], 0

; 2272 : 		for (j=0; j < splitPacketChannelList[i]->splitPacketList.Size(); j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN6@BuildPacke
$LN5@BuildPacke:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN6@BuildPacke:
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??A?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	call	?Size@?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::Size
	cmp	DWORD PTR _j$[ebp], eax
	jae	$LN4@BuildPacke

; 2273 : 		{
; 2274 : 			memcpy(internalPacket->data+byteProgress, splitPacketChannelList[i]->splitPacketList[j]->data, BITS_TO_BYTES(splitPacketChannelList[i]->splitPacketList[j]->dataBitLength));

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??A?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	call	??A?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEAAPAUInternalPacket@@I@Z ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::operator[]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+43]
	add	eax, 7
	shr	eax, 3
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??A?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	call	??A?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEAAPAUInternalPacket@@I@Z ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::operator[]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+47]
	push	ecx
	mov	edx, DWORD PTR _internalPacket$[ebp]
	mov	eax, DWORD PTR [edx+47]
	add	eax, DWORD PTR _byteProgress$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2275 : 			byteProgress+=BITS_TO_BYTES(splitPacketChannelList[i]->splitPacketList[j]->dataBitLength);

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??A?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	call	??A?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEAAPAUInternalPacket@@I@Z ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::operator[]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+43]
	add	eax, 7
	shr	eax, 3
	add	eax, DWORD PTR _byteProgress$[ebp]
	mov	DWORD PTR _byteProgress$[ebp], eax

; 2276 : 		}

	jmp	$LN5@BuildPacke
$LN4@BuildPacke:

; 2277 : 
; 2278 : 		for (j=0; j < splitPacketChannelList[i]->splitPacketList.Size(); j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN3@BuildPacke
$LN2@BuildPacke:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN3@BuildPacke:
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??A?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	call	?Size@?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::Size
	cmp	DWORD PTR _j$[ebp], eax
	jae	SHORT $LN1@BuildPacke

; 2279 : 		{
; 2280 : 			delete [] splitPacketChannelList[i]->splitPacketList[j]->data;

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??A?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	call	??A?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEAAPAUInternalPacket@@I@Z ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::operator[]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+47]
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 2281 : 			internalPacketPool.ReleasePointer(splitPacketChannelList[i]->splitPacketList[j]);

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??A?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	call	??A?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEAAPAUInternalPacket@@I@Z ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::operator[]
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	call	?ReleasePointer@InternalPacketPool@@QAEXPAUInternalPacket@@@Z ; InternalPacketPool::ReleasePointer

; 2282 : 		}

	jmp	$LN2@BuildPacke
$LN1@BuildPacke:

; 2283 : 		delete splitPacketChannelList[i];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??A?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T4[ebp], ecx
	mov	edx, DWORD PTR $T4[ebp]
	mov	DWORD PTR $T3[ebp], edx
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN14@BuildPacke
	push	1
	mov	ecx, DWORD PTR $T3[ebp]
	call	??_GSplitPacketChannel@@QAEPAXI@Z
	mov	DWORD PTR tv251[ebp], eax
	jmp	SHORT $LN15@BuildPacke
$LN14@BuildPacke:
	mov	DWORD PTR tv251[ebp], 0
$LN15@BuildPacke:

; 2284 : 		splitPacketChannelList.RemoveAtIndex(i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	?RemoveAtIndex@?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QAEXI@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::RemoveAtIndex

; 2285 : 
; 2286 : 		return internalPacket;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	jmp	SHORT $LN11@BuildPacke
$LN10@BuildPacke:

; 2287 : 	}
; 2288 : 
; 2289 : 	return 0;

	xor	eax, eax
$LN11@BuildPacke:

; 2290 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN18@BuildPacke
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	1
$LN18@BuildPacke:
	DD	1
	DD	$LN17@BuildPacke
$LN17@BuildPacke:
	DD	-65					; ffffffbfH
	DD	1
	DD	$LN16@BuildPacke
$LN16@BuildPacke:
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
?BuildPacketFromSplitPacketList@ReliabilityLayer@@AAEPAUInternalPacket@@G_J@Z ENDP ; ReliabilityLayer::BuildPacketFromSplitPacketList
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?InsertIntoSplitPacketList@ReliabilityLayer@@AAEXPAUInternalPacket@@_J@Z
_TEXT	SEGMENT
tv79 = -328						; size = 4
$T2 = -320						; size = 4
$T3 = -308						; size = 4
$T4 = -296						; size = 4
_temp$5 = -92						; size = 4
_length$6 = -80						; size = 4
_progressIndicator$7 = -68				; size = 4
_newChannel$8 = -56					; size = 4
_index$ = -44						; size = 4
_objectExists$ = -29					; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_internalPacket$ = 8					; size = 4
_time$ = 12						; size = 8
?InsertIntoSplitPacketList@ReliabilityLayer@@AAEXPAUInternalPacket@@_J@Z PROC ; ReliabilityLayer::InsertIntoSplitPacketList, COMDAT
; _this$ = ecx

; 2199 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?InsertIntoSplitPacketList@ReliabilityLayer@@AAEXPAUInternalPacket@@_J@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 316				; 0000013cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-328]
	mov	ecx, 79					; 0000004fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2200 : 	bool objectExists;
; 2201 : 	unsigned index;
; 2202 : 	index=splitPacketChannelList.GetIndexFromKey(internalPacket->splitPacketId, &objectExists);

	lea	eax, DWORD PTR _objectExists$[ebp]
	push	eax
	mov	ecx, DWORD PTR _internalPacket$[ebp]
	add	ecx, 17					; 00000011H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	?GetIndexFromKey@?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEIABGPA_N@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::GetIndexFromKey
	mov	DWORD PTR _index$[ebp], eax

; 2203 : 	if (objectExists==false)

	movzx	eax, BYTE PTR _objectExists$[ebp]
	test	eax, eax
	jne	SHORT $LN2@InsertInto

; 2204 : 	{
; 2205 : 		SplitPacketChannel *newChannel = new SplitPacketChannel;

	push	20					; 00000014H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN5@InsertInto
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0SplitPacketChannel@@QAE@XZ
	mov	DWORD PTR tv79[ebp], eax
	jmp	SHORT $LN6@InsertInto
$LN5@InsertInto:
	mov	DWORD PTR tv79[ebp], 0
$LN6@InsertInto:
	mov	eax, DWORD PTR tv79[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _newChannel$8[ebp], ecx

; 2206 :         index=splitPacketChannelList.Insert(internalPacket->splitPacketId, newChannel);

	lea	eax, DWORD PTR _newChannel$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _internalPacket$[ebp]
	add	ecx, 17					; 00000011H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	?Insert@?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QAEIABGABQAUSplitPacketChannel@@@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::Insert
	mov	DWORD PTR _index$[ebp], eax
$LN2@InsertInto:

; 2207 : 	}
; 2208 : 	splitPacketChannelList[index]->splitPacketList.Insert(internalPacket->splitPacketIndex, internalPacket);

	lea	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _internalPacket$[ebp]
	add	ecx, 19					; 00000013H
	push	ecx
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??A?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	call	?Insert@?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QAEIABIABQAUInternalPacket@@@Z ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::Insert

; 2209 : 	splitPacketChannelList[index]->lastUpdateTime=time;

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??A?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _time$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _time$[ebp+4]
	mov	DWORD PTR [ecx+4], eax

; 2210 : 
; 2211 : 	if (splitMessageProgressInterval &&
; 2212 : 		splitPacketChannelList[index]->splitPacketList[0]->splitPacketIndex==0 &&
; 2213 : 		splitPacketChannelList[index]->splitPacketList.Size()!=splitPacketChannelList[index]->splitPacketList[0]->splitPacketCount &&
; 2214 : 		(splitPacketChannelList[index]->splitPacketList.Size()%splitMessageProgressInterval)==0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	$LN3@InsertInto
	push	0
	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??A?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	call	??A?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEAAPAUInternalPacket@@I@Z ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+19], 0
	jne	$LN3@InsertInto
	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??A?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	call	?Size@?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::Size
	mov	esi, eax
	push	0
	mov	ecx, DWORD PTR _index$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??A?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	call	??A?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEAAPAUInternalPacket@@I@Z ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::operator[]
	mov	edx, DWORD PTR [eax]
	cmp	esi, DWORD PTR [edx+23]
	je	$LN3@InsertInto
	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??A?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	call	?Size@?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::Size
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+48]
	test	edx, edx
	jne	$LN3@InsertInto

; 2215 : 	{
; 2216 : //		printf("msgID=%i Progress %i/%i Partsize=%i\n",
; 2217 : //			splitPacketChannelList[index]->splitPacketList[0]->data[0],
; 2218 : //			splitPacketChannelList[index]->splitPacketList.Size(),
; 2219 : //			internalPacket->splitPacketCount,
; 2220 : //			BITS_TO_BYTES(splitPacketChannelList[index]->splitPacketList[0]->dataBitLength));
; 2221 : 
; 2222 : 		// Return ID_DOWNLOAD_PROGRESS
; 2223 : 		// Write splitPacketIndex (SplitPacketIndexType)
; 2224 : 		// Write splitPacketCount (SplitPacketIndexType)
; 2225 : 		// Write byteLength (4)
; 2226 : 		// Write data, splitPacketChannelList[index]->splitPacketList[0]->data
; 2227 : 		InternalPacket *progressIndicator = internalPacketPool.GetPointer();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	call	?GetPointer@InternalPacketPool@@QAEPAUInternalPacket@@XZ ; InternalPacketPool::GetPointer
	mov	DWORD PTR _progressIndicator$7[ebp], eax

; 2228 : 		unsigned int length = sizeof(MessageID) + sizeof(unsigned int)*2 + sizeof(unsigned int) + BITS_TO_BYTES(splitPacketChannelList[index]->splitPacketList[0]->dataBitLength);

	push	0
	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??A?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	call	??A?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEAAPAUInternalPacket@@I@Z ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+43]
	add	edx, 7
	shr	edx, 3
	add	edx, 13					; 0000000dH
	mov	DWORD PTR _length$6[ebp], edx

; 2229 : 		progressIndicator->data = new unsigned char [length];

	mov	eax, DWORD PTR _length$6[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	ecx, DWORD PTR _progressIndicator$7[ebp]
	mov	edx, DWORD PTR $T4[ebp]
	mov	DWORD PTR [ecx+47], edx

; 2230 : 		progressIndicator->dataBitLength=BYTES_TO_BITS(length);

	mov	eax, DWORD PTR _length$6[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR _progressIndicator$7[ebp]
	mov	DWORD PTR [ecx+43], eax

; 2231 : 		progressIndicator->data[0]=(MessageID)ID_DOWNLOAD_PROGRESS;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _progressIndicator$7[ebp]
	mov	eax, DWORD PTR [edx+47]
	mov	BYTE PTR [ecx+eax], 91			; 0000005bH

; 2232 : 		unsigned int temp;
; 2233 : 		temp=splitPacketChannelList[index]->splitPacketList.Size();

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??A?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	call	?Size@?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::Size
	mov	DWORD PTR _temp$5[ebp], eax

; 2234 : 		memcpy(progressIndicator->data+sizeof(MessageID), &temp, sizeof(unsigned int));

	push	4
	lea	eax, DWORD PTR _temp$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _progressIndicator$7[ebp]
	mov	edx, DWORD PTR [ecx+47]
	add	edx, 1
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2235 : 		temp=(unsigned int)internalPacket->splitPacketCount;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR [eax+23]
	mov	DWORD PTR _temp$5[ebp], ecx

; 2236 : 		memcpy(progressIndicator->data+sizeof(MessageID)+sizeof(unsigned int)*1, &temp, sizeof(unsigned int));

	push	4
	lea	eax, DWORD PTR _temp$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _progressIndicator$7[ebp]
	mov	edx, DWORD PTR [ecx+47]
	add	edx, 5
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2237 : 		temp=BITS_TO_BYTES(splitPacketChannelList[index]->splitPacketList[0]->dataBitLength);

	push	0
	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??A?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	call	??A?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEAAPAUInternalPacket@@I@Z ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+43]
	add	edx, 7
	shr	edx, 3
	mov	DWORD PTR _temp$5[ebp], edx

; 2238 : 		memcpy(progressIndicator->data+sizeof(MessageID)+sizeof(unsigned int)*2, &temp, sizeof(unsigned int));

	push	4
	lea	eax, DWORD PTR _temp$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _progressIndicator$7[ebp]
	mov	edx, DWORD PTR [ecx+47]
	add	edx, 9
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2239 : 		memcpy(progressIndicator->data+sizeof(MessageID)+sizeof(unsigned int)*3, splitPacketChannelList[index]->splitPacketList[0]->data, BITS_TO_BYTES(splitPacketChannelList[index]->splitPacketList[0]->dataBitLength));

	push	0
	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??A?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	call	??A?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEAAPAUInternalPacket@@I@Z ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+43]
	add	edx, 7
	shr	edx, 3
	push	edx
	push	0
	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??A?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	call	??A?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEAAPAUInternalPacket@@I@Z ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+47]
	push	edx
	mov	eax, DWORD PTR _progressIndicator$7[ebp]
	mov	ecx, DWORD PTR [eax+47]
	add	ecx, 13					; 0000000dH
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2240 : 		outputQueue.Push(progressIndicator);

	lea	eax, DWORD PTR _progressIndicator$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?Push@?$Queue@PAUInternalPacket@@@DataStructures@@QAEXABQAUInternalPacket@@@Z ; DataStructures::Queue<InternalPacket *>::Push
$LN3@InsertInto:

; 2241 : 	}
; 2242 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN14@InsertInto
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 328				; 00000148H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN14@InsertInto:
	DD	4
	DD	$LN13@InsertInto
$LN13@InsertInto:
	DD	-29					; ffffffe3H
	DD	1
	DD	$LN8@InsertInto
	DD	-56					; ffffffc8H
	DD	4
	DD	$LN9@InsertInto
	DD	-68					; ffffffbcH
	DD	4
	DD	$LN10@InsertInto
	DD	-92					; ffffffa4H
	DD	4
	DD	$LN11@InsertInto
$LN11@InsertInto:
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
$LN10@InsertInto:
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	103					; 00000067H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	115					; 00000073H
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	0
$LN9@InsertInto:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	67					; 00000043H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	0
$LN8@InsertInto:
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?InsertIntoSplitPacketList@ReliabilityLayer@@AAEXPAUInternalPacket@@_J@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?InsertIntoSplitPacketList@ReliabilityLayer@@AAEXPAUInternalPacket@@_J@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-332]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?InsertIntoSplitPacketList@ReliabilityLayer@@AAEXPAUInternalPacket@@_J@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?InsertIntoSplitPacketList@ReliabilityLayer@@AAEXPAUInternalPacket@@_J@Z ENDP ; ReliabilityLayer::InsertIntoSplitPacketList
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?SplitPacket@ReliabilityLayer@@AAEXPAUInternalPacket@@H@Z
_TEXT	SEGMENT
tv137 = -396						; size = 4
tv232 = -392						; size = 4
$T1 = -384						; size = 4
$T2 = -372						; size = 4
$T3 = -360						; size = 4
$T4 = -348						; size = 4
__$AllocaPad$$ = -144					; size = 4
_usedAlloca$ = -129					; size = 1
_internalPacketArray$ = -120				; size = 4
_i$ = -108						; size = 4
_splitPacketIndex$ = -96				; size = 4
_bytesToSend$ = -84					; size = 4
_byteOffset$ = -72					; size = 4
_maximumSendBlock$ = -60				; size = 4
_maxDataSize$ = -48					; size = 4
_dataByteLength$ = -36					; size = 4
_headerLength$ = -24					; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_internalPacket$ = 8					; size = 4
_MTUSize$ = 12						; size = 4
?SplitPacket@ReliabilityLayer@@AAEXPAUInternalPacket@@H@Z PROC ; ReliabilityLayer::SplitPacket, COMDAT
; _this$ = ecx

; 2072 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 396				; 0000018cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-396]
	mov	ecx, 99					; 00000063H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$AllocaPad$$[ebp], 0

; 2073 : 	// Doing all sizes in bytes in this function so I don't write partial bytes with split packets
; 2074 : 	internalPacket->splitPacketCount = 1; // This causes GetBitStreamHeaderLength to account for the split packet header

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	DWORD PTR [eax+23], 1

; 2075 : 	int headerLength = BITS_TO_BYTES( GetBitStreamHeaderLength( internalPacket ) );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBitStreamHeaderLength@ReliabilityLayer@@AAEHQBUInternalPacket@@@Z ; ReliabilityLayer::GetBitStreamHeaderLength
	add	eax, 7
	sar	eax, 3
	mov	DWORD PTR _headerLength$[ebp], eax

; 2076 : 	int dataByteLength = BITS_TO_BYTES( internalPacket->dataBitLength );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR [eax+43]
	add	ecx, 7
	shr	ecx, 3
	mov	DWORD PTR _dataByteLength$[ebp], ecx

; 2077 : 	int maxDataSize;
; 2078 : 	int maximumSendBlock, byteOffset, bytesToSend;
; 2079 : 	SplitPacketIndexType splitPacketIndex;
; 2080 : 	int i;
; 2081 : 	InternalPacket **internalPacketArray;
; 2082 : 
; 2083 : 	maxDataSize = MTUSize - UDP_HEADER_SIZE;

	mov	eax, DWORD PTR _MTUSize$[ebp]
	sub	eax, 28					; 0000001cH
	mov	DWORD PTR _maxDataSize$[ebp], eax

; 2084 : 
; 2085 : 	if ( encryptor.IsKeySet() )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1019				; 000003fbH
	call	?IsKeySet@TEABlockEncryptor@@QBE_NXZ	; TEABlockEncryptor::IsKeySet
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN17@SplitPacke

; 2086 : #ifdef TEA_ENCRYPTOR
; 2087 : 		maxDataSize -= 8; // Extra data for the encryptor

	mov	eax, DWORD PTR _maxDataSize$[ebp]
	sub	eax, 8
	mov	DWORD PTR _maxDataSize$[ebp], eax
$LN17@SplitPacke:

; 2088 : #else
; 2089 : 		maxDataSize -= 16; // Extra data for the encryptor
; 2090 : #endif
; 2091 : 
; 2092 : #ifdef _DEBUG
; 2093 : 	// Make sure we need to split the packet to begin with
; 2094 : 	assert( dataByteLength > maxDataSize - headerLength );

	mov	eax, DWORD PTR _maxDataSize$[ebp]
	sub	eax, DWORD PTR _headerLength$[ebp]
	cmp	DWORD PTR _dataByteLength$[ebp], eax
	jg	SHORT $LN20@SplitPacke
	mov	ecx, DWORD PTR ?__LINE__Var@?1??SplitPacket@ReliabilityLayer@@AAEXPAUInternalPacket@@H@Z@4JA
	add	ecx, 22					; 00000016H
	push	ecx
	push	OFFSET ??_C@_1FK@FKLHGKMO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAe?$AAl?$AAi?$AAa?$AAb?$AAi?$AAl@
	push	OFFSET ??_C@_1FI@DMENGPEG@?$AAd?$AAa?$AAt?$AAa?$AAB?$AAy?$AAt?$AAe?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AAm?$AAa?$AAx?$AAD?$AAa?$AAt?$AAa?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?9?$AA?5?$AAh@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN20@SplitPacke:

; 2095 : #endif
; 2096 : 
; 2097 : 	// How much to send in the largest block
; 2098 : 	maximumSendBlock = maxDataSize - headerLength;

	mov	eax, DWORD PTR _maxDataSize$[ebp]
	sub	eax, DWORD PTR _headerLength$[ebp]
	mov	DWORD PTR _maximumSendBlock$[ebp], eax

; 2099 : 
; 2100 : 	// Calculate how many packets we need to create
; 2101 : 	internalPacket->splitPacketCount = ( ( dataByteLength - 1 ) / ( maximumSendBlock ) + 1 );

	mov	eax, DWORD PTR _dataByteLength$[ebp]
	sub	eax, 1
	cdq
	idiv	DWORD PTR _maximumSendBlock$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _internalPacket$[ebp]
	mov	DWORD PTR [ecx+23], eax

; 2102 : 
; 2103 : 	statistics.totalSplits += internalPacket->splitPacketCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+839]
	mov	edx, DWORD PTR _internalPacket$[ebp]
	add	ecx, DWORD PTR [edx+23]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+839], ecx

; 2104 : 
; 2105 : 	// Optimization
; 2106 : 	// internalPacketArray = new InternalPacket*[internalPacket->splitPacketCount];
; 2107 : 	bool usedAlloca=false;

	mov	BYTE PTR _usedAlloca$[ebp], 0

; 2108 : 	#if !defined(_COMPATIBILITY_1)
; 2109 : 	if (sizeof( InternalPacket* ) * internalPacket->splitPacketCount < MAX_ALLOCA_STACK_ALLOCATION)

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR [eax+23]
	shl	ecx, 2
	cmp	ecx, 1048576				; 00100000H
	jae	SHORT $LN16@SplitPacke

; 2110 : 	{
; 2111 : 		internalPacketArray = ( InternalPacket** ) alloca( sizeof( InternalPacket* ) * internalPacket->splitPacketCount );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR [eax+23]
	shl	ecx, 2
	add	ecx, 36					; 00000024H
	mov	DWORD PTR tv232[ebp], ecx
	mov	eax, DWORD PTR tv232[ebp]
	call	__alloca_probe_16
	mov	DWORD PTR tv137[ebp], esp
	lea	edx, DWORD PTR __$AllocaPad$$[ebp]
	push	edx
	mov	edx, DWORD PTR tv232[ebp]
	mov	ecx, DWORD PTR tv137[ebp]
	call	@_RTC_AllocaHelper@12
	add	DWORD PTR tv137[ebp], 32		; 00000020H
	mov	eax, DWORD PTR tv137[ebp]
	mov	DWORD PTR _internalPacketArray$[ebp], eax

; 2112 : 		usedAlloca=true;

	mov	BYTE PTR _usedAlloca$[ebp], 1

; 2113 : 	}
; 2114 : 	else

	jmp	SHORT $LN15@SplitPacke
$LN16@SplitPacke:

; 2115 : 	#endif
; 2116 : 		internalPacketArray = new InternalPacket*[internalPacket->splitPacketCount];

	xor	ecx, ecx
	mov	edx, DWORD PTR _internalPacket$[ebp]
	mov	eax, DWORD PTR [edx+23]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _internalPacketArray$[ebp], eax
$LN15@SplitPacke:

; 2117 : 
; 2118 : 	for ( i = 0; i < ( int ) internalPacket->splitPacketCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN14@SplitPacke
$LN13@SplitPacke:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN14@SplitPacke:
	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+23]
	jge	SHORT $LN12@SplitPacke

; 2119 : 	{
; 2120 : 		internalPacketArray[ i ] = internalPacketPool.GetPointer();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	call	?GetPointer@InternalPacketPool@@QAEPAUInternalPacket@@XZ ; InternalPacketPool::GetPointer
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _internalPacketArray$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 2121 : 		//internalPacketArray[ i ] = (InternalPacket*) alloca( sizeof( InternalPacket ) );
; 2122 : //		internalPacketArray[ i ] = sendPacketSet[internalPacket->priority].WriteLock();
; 2123 : 		memcpy( internalPacketArray[ i ], internalPacket, sizeof( InternalPacket ) );

	push	55					; 00000037H
	mov	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _internalPacketArray$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2124 : 	}

	jmp	SHORT $LN13@SplitPacke
$LN12@SplitPacke:

; 2125 : 
; 2126 : 	// This identifies which packet this is in the set
; 2127 : 	splitPacketIndex = 0;

	mov	DWORD PTR _splitPacketIndex$[ebp], 0
$LN11@SplitPacke:

; 2128 : 
; 2129 : 	// Do a loop to send out all the packets
; 2130 : 	do
; 2131 : 	{
; 2132 : 		byteOffset = splitPacketIndex * maximumSendBlock;

	mov	eax, DWORD PTR _splitPacketIndex$[ebp]
	imul	eax, DWORD PTR _maximumSendBlock$[ebp]
	mov	DWORD PTR _byteOffset$[ebp], eax

; 2133 : 		bytesToSend = dataByteLength - byteOffset;

	mov	eax, DWORD PTR _dataByteLength$[ebp]
	sub	eax, DWORD PTR _byteOffset$[ebp]
	mov	DWORD PTR _bytesToSend$[ebp], eax

; 2134 : 
; 2135 : 		if ( bytesToSend > maximumSendBlock )

	mov	eax, DWORD PTR _bytesToSend$[ebp]
	cmp	eax, DWORD PTR _maximumSendBlock$[ebp]
	jle	SHORT $LN8@SplitPacke

; 2136 : 			bytesToSend = maximumSendBlock;

	mov	eax, DWORD PTR _maximumSendBlock$[ebp]
	mov	DWORD PTR _bytesToSend$[ebp], eax
$LN8@SplitPacke:

; 2137 : 
; 2138 : 		// Copy over our chunk of data
; 2139 : 		internalPacketArray[ splitPacketIndex ]->data = new unsigned char[ bytesToSend ];

	mov	eax, DWORD PTR _bytesToSend$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR _splitPacketIndex$[ebp]
	mov	edx, DWORD PTR _internalPacketArray$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [eax+47], ecx

; 2140 : 
; 2141 : 		memcpy( internalPacketArray[ splitPacketIndex ]->data, internalPacket->data + byteOffset, bytesToSend );

	mov	eax, DWORD PTR _bytesToSend$[ebp]
	push	eax
	mov	ecx, DWORD PTR _internalPacket$[ebp]
	mov	edx, DWORD PTR [ecx+47]
	add	edx, DWORD PTR _byteOffset$[ebp]
	push	edx
	mov	eax, DWORD PTR _splitPacketIndex$[ebp]
	mov	ecx, DWORD PTR _internalPacketArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+47]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2142 : 
; 2143 : 		if ( bytesToSend != maximumSendBlock )

	mov	eax, DWORD PTR _bytesToSend$[ebp]
	cmp	eax, DWORD PTR _maximumSendBlock$[ebp]
	je	SHORT $LN7@SplitPacke

; 2144 : 			internalPacketArray[ splitPacketIndex ]->dataBitLength = internalPacket->dataBitLength - splitPacketIndex * ( maximumSendBlock << 3 );

	mov	eax, DWORD PTR _maximumSendBlock$[ebp]
	shl	eax, 3
	imul	eax, DWORD PTR _splitPacketIndex$[ebp]
	mov	ecx, DWORD PTR _internalPacket$[ebp]
	mov	edx, DWORD PTR [ecx+43]
	sub	edx, eax
	mov	eax, DWORD PTR _splitPacketIndex$[ebp]
	mov	ecx, DWORD PTR _internalPacketArray$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [eax+43], edx

; 2145 : 		else

	jmp	SHORT $LN6@SplitPacke
$LN7@SplitPacke:

; 2146 : 			internalPacketArray[ splitPacketIndex ]->dataBitLength = bytesToSend << 3;

	mov	eax, DWORD PTR _bytesToSend$[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR _splitPacketIndex$[ebp]
	mov	edx, DWORD PTR _internalPacketArray$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+43], eax
$LN6@SplitPacke:

; 2147 : 
; 2148 : 		internalPacketArray[ splitPacketIndex ]->splitPacketIndex = splitPacketIndex;

	mov	eax, DWORD PTR _splitPacketIndex$[ebp]
	mov	ecx, DWORD PTR _internalPacketArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _splitPacketIndex$[ebp]
	mov	DWORD PTR [edx+19], eax

; 2149 : 		internalPacketArray[ splitPacketIndex ]->splitPacketId = splitPacketId;

	mov	eax, DWORD PTR _splitPacketIndex$[ebp]
	mov	ecx, DWORD PTR _internalPacketArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+721]
	mov	WORD PTR [edx+17], cx

; 2150 : 		internalPacketArray[ splitPacketIndex ]->splitPacketCount = internalPacket->splitPacketCount;

	mov	eax, DWORD PTR _splitPacketIndex$[ebp]
	mov	ecx, DWORD PTR _internalPacketArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR [eax+23]
	mov	DWORD PTR [edx+23], ecx

; 2151 : 
; 2152 : 		if ( splitPacketIndex > 0 )   // For the first split packet index we keep the messageNumber already assigned

	cmp	DWORD PTR _splitPacketIndex$[ebp], 0
	jbe	SHORT $LN10@SplitPacke

; 2153 : 		{
; 2154 : 			// For every further packet we use a new messageNumber.
; 2155 : 			// Note that all split packets are reliable
; 2156 : 			internalPacketArray[ splitPacketIndex ]->messageNumber = messageNumber;

	mov	eax, DWORD PTR _splitPacketIndex$[ebp]
	mov	ecx, DWORD PTR _internalPacketArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+176]
	mov	WORD PTR [edx], cx

; 2157 : 
; 2158 : 			//if ( ++messageNumber == RECEIVED_PACKET_LOG_LENGTH )
; 2159 : 			//	messageNumber = 0;
; 2160 : 			++messageNumber;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+176]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+176], cx
$LN10@SplitPacke:

; 2161 : 
; 2162 : 		}
; 2163 : 
; 2164 : 		// Add the new packet to send list at the correct priority
; 2165 : 		//  sendQueue[internalPacket->priority].Insert(newInternalPacket);
; 2166 : 		// SHOW SPLIT PACKET GENERATION
; 2167 : 		// if (splitPacketIndex % 100 == 0)
; 2168 : 		//  printf("splitPacketIndex=%i\n",splitPacketIndex);
; 2169 : 		//} while(++splitPacketIndex < internalPacket->splitPacketCount);
; 2170 : 	}
; 2171 : 
; 2172 : 	while ( ++splitPacketIndex < internalPacket->splitPacketCount );

	mov	eax, DWORD PTR _splitPacketIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _splitPacketIndex$[ebp], eax
	mov	ecx, DWORD PTR _internalPacket$[ebp]
	mov	edx, DWORD PTR _splitPacketIndex$[ebp]
	cmp	edx, DWORD PTR [ecx+23]
	jb	$LN11@SplitPacke

; 2173 : 
; 2174 : 	splitPacketId++; // It's ok if this wraps to 0

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+721]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+721], cx

; 2175 : 
; 2176 : //	InternalPacket *workingPacket;
; 2177 : 
; 2178 : 	// Copy all the new packets into the split packet list
; 2179 : 	for ( i = 0; i < ( int ) internalPacket->splitPacketCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@SplitPacke
$LN3@SplitPacke:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@SplitPacke:
	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+23]
	jge	SHORT $LN2@SplitPacke

; 2180 : 	{
; 2181 : 		sendPacketSet[ internalPacket->priority ].Push( internalPacketArray[ i ] );

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _internalPacketArray$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+100]
	call	?Push@?$Queue@PAUInternalPacket@@@DataStructures@@QAEXABQAUInternalPacket@@@Z ; DataStructures::Queue<InternalPacket *>::Push

; 2182 : //		workingPacket=sendPacketSet[internalPacket->priority].WriteLock();
; 2183 : //		memcpy(workingPacket, internalPacketArray[ i ], sizeof(InternalPacket));
; 2184 : //		sendPacketSet[internalPacket->priority].WriteUnlock();
; 2185 : 	}

	jmp	SHORT $LN3@SplitPacke
$LN2@SplitPacke:

; 2186 : 
; 2187 : 	// Delete the original
; 2188 : 	delete [] internalPacket->data;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR [eax+47]
	mov	DWORD PTR $T3[ebp], ecx
	mov	edx, DWORD PTR $T3[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 2189 : 	internalPacketPool.ReleasePointer( internalPacket );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	call	?ReleasePointer@InternalPacketPool@@QAEXPAUInternalPacket@@@Z ; InternalPacketPool::ReleasePointer

; 2190 : 
; 2191 : 	if (usedAlloca==false)

	movzx	eax, BYTE PTR _usedAlloca$[ebp]
	test	eax, eax
	jne	SHORT $LN18@SplitPacke

; 2192 : 		delete [] internalPacketArray;

	mov	eax, DWORD PTR _internalPacketArray$[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	ecx, DWORD PTR $T4[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN18@SplitPacke:

; 2193 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN23@SplitPacke
	push	DWORD PTR __$AllocaPad$$[ebp]
	call	@_RTC_CheckStackVars2@12
	pop	eax
	pop	edx
	lea	esp, DWORD PTR [ebp-408]
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN23@SplitPacke:
	DD	1
	DD	$LN22@SplitPacke
$LN22@SplitPacke:
	DD	-144					; ffffff70H
	DD	4
	DD	$LN21@SplitPacke
$LN21@SplitPacke:
	DB	95					; 0000005fH
	DB	36					; 00000024H
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	36					; 00000024H
	DB	0
?SplitPacket@ReliabilityLayer@@AAEXPAUInternalPacket@@H@Z ENDP ; ReliabilityLayer::SplitPacket
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?IsOlderOrderedPacket@ReliabilityLayer@@AAE_NGG@Z
_TEXT	SEGMENT
_maxRange$ = -20					; size = 2
_this$ = -8						; size = 4
_newPacketOrderingIndex$ = 8				; size = 2
_waitingForPacketOrderingIndex$ = 12			; size = 2
?IsOlderOrderedPacket@ReliabilityLayer@@AAE_NGG@Z PROC	; ReliabilityLayer::IsOlderOrderedPacket, COMDAT
; _this$ = ecx

; 2044 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2045 : 	// This should give me 255 or 65535
; 2046 : 	OrderingIndexType maxRange = (OrderingIndexType) -1;

	mov	eax, 65535				; 0000ffffH
	mov	WORD PTR _maxRange$[ebp], ax

; 2047 : 
; 2048 : 	if ( waitingForPacketOrderingIndex > maxRange/2 )

	movzx	ecx, WORD PTR _waitingForPacketOrderingIndex$[ebp]
	movzx	eax, WORD PTR _maxRange$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	ecx, eax
	jle	SHORT $LN5@IsOlderOrd

; 2049 : 	{
; 2050 : 		if ( newPacketOrderingIndex >= waitingForPacketOrderingIndex - maxRange/2+1 && newPacketOrderingIndex < waitingForPacketOrderingIndex )

	movzx	ecx, WORD PTR _newPacketOrderingIndex$[ebp]
	movzx	esi, WORD PTR _waitingForPacketOrderingIndex$[ebp]
	movzx	eax, WORD PTR _maxRange$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	esi, eax
	add	esi, 1
	cmp	ecx, esi
	jl	SHORT $LN4@IsOlderOrd
	movzx	eax, WORD PTR _newPacketOrderingIndex$[ebp]
	movzx	ecx, WORD PTR _waitingForPacketOrderingIndex$[ebp]
	cmp	eax, ecx
	jge	SHORT $LN4@IsOlderOrd

; 2051 : 		{
; 2052 : 			return true;

	mov	al, 1
	jmp	SHORT $LN6@IsOlderOrd
$LN4@IsOlderOrd:

; 2053 : 		}
; 2054 : 	}
; 2055 : 
; 2056 : 	else

	jmp	SHORT $LN3@IsOlderOrd
$LN5@IsOlderOrd:

; 2057 : 		if ( newPacketOrderingIndex >= ( OrderingIndexType ) ( waitingForPacketOrderingIndex - (( OrderingIndexType ) maxRange/2+1) ) ||
; 2058 : 			newPacketOrderingIndex < waitingForPacketOrderingIndex )

	movzx	ecx, WORD PTR _newPacketOrderingIndex$[ebp]
	movzx	esi, WORD PTR _waitingForPacketOrderingIndex$[ebp]
	movzx	eax, WORD PTR _maxRange$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, 1
	sub	esi, eax
	movzx	edx, si
	cmp	ecx, edx
	jge	SHORT $LN1@IsOlderOrd
	movzx	eax, WORD PTR _newPacketOrderingIndex$[ebp]
	movzx	ecx, WORD PTR _waitingForPacketOrderingIndex$[ebp]
	cmp	eax, ecx
	jge	SHORT $LN3@IsOlderOrd
$LN1@IsOlderOrd:

; 2059 : 		{
; 2060 : 			return true;

	mov	al, 1
	jmp	SHORT $LN6@IsOlderOrd
$LN3@IsOlderOrd:

; 2061 : 		}
; 2062 : 
; 2063 : 	// Old packet
; 2064 : 	return false;

	xor	al, al
$LN6@IsOlderOrd:

; 2065 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?IsOlderOrderedPacket@ReliabilityLayer@@AAE_NGG@Z ENDP	; ReliabilityLayer::IsOlderOrderedPacket
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?DeleteSequencedPacketsInList@ReliabilityLayer@@AAEXEAAV?$Queue@PAUInternalPacket@@@DataStructures@@@Z
_TEXT	SEGMENT
$T1 = -248						; size = 4
_i$ = -44						; size = 4
_listSize$ = -32					; size = 4
_internalPacket$ = -20					; size = 4
_this$ = -8						; size = 4
_orderingChannel$ = 8					; size = 1
_theList$ = 12						; size = 4
?DeleteSequencedPacketsInList@ReliabilityLayer@@AAEXEAAV?$Queue@PAUInternalPacket@@@DataStructures@@@Z PROC ; ReliabilityLayer::DeleteSequencedPacketsInList, COMDAT
; _this$ = ecx

; 2019 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2020 : 	InternalPacket * internalPacket;
; 2021 : 	int listSize = theList.Size();

	mov	ecx, DWORD PTR _theList$[ebp]
	call	?Size@?$Queue@PAUInternalPacket@@@DataStructures@@QBEIXZ ; DataStructures::Queue<InternalPacket *>::Size
	mov	DWORD PTR _listSize$[ebp], eax

; 2022 : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0
$LN5@DeleteSequ:

; 2023 : 
; 2024 : 	while ( i < listSize )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _listSize$[ebp]
	jge	$LN6@DeleteSequ

; 2025 : 	{
; 2026 : 		if ( ( theList[ i ]->reliability == RELIABLE_SEQUENCED || theList[ i ]->reliability == UNRELIABLE_SEQUENCED ) && theList[ i ]->orderingChannel == orderingChannel )

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _theList$[ebp]
	call	??A?$Queue@PAUInternalPacket@@@DataStructures@@QBEAAPAUInternalPacket@@I@Z ; DataStructures::Queue<InternalPacket *>::operator[]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+10], 4
	je	SHORT $LN2@DeleteSequ
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _theList$[ebp]
	call	??A?$Queue@PAUInternalPacket@@@DataStructures@@QBEAAPAUInternalPacket@@I@Z ; DataStructures::Queue<InternalPacket *>::operator[]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+10], 1
	jne	SHORT $LN3@DeleteSequ
$LN2@DeleteSequ:
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _theList$[ebp]
	call	??A?$Queue@PAUInternalPacket@@@DataStructures@@QBEAAPAUInternalPacket@@I@Z ; DataStructures::Queue<InternalPacket *>::operator[]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx+14]
	movzx	eax, BYTE PTR _orderingChannel$[ebp]
	cmp	edx, eax
	jne	SHORT $LN3@DeleteSequ

; 2027 : 		{
; 2028 : 			internalPacket = theList[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _theList$[ebp]
	call	??A?$Queue@PAUInternalPacket@@@DataStructures@@QBEAAPAUInternalPacket@@I@Z ; DataStructures::Queue<InternalPacket *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _internalPacket$[ebp], ecx

; 2029 : 			theList.Del( i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _theList$[ebp]
	call	?Del@?$Queue@PAUInternalPacket@@@DataStructures@@QAEXI@Z ; DataStructures::Queue<InternalPacket *>::Del

; 2030 : 			delete [] internalPacket->data;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR [eax+47]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 2031 : 			internalPacketPool.ReleasePointer( internalPacket );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	call	?ReleasePointer@InternalPacketPool@@QAEXPAUInternalPacket@@@Z ; InternalPacketPool::ReleasePointer

; 2032 : 			listSize--;

	mov	eax, DWORD PTR _listSize$[ebp]
	sub	eax, 1
	mov	DWORD PTR _listSize$[ebp], eax

; 2033 : 		}
; 2034 : 
; 2035 : 		else

	jmp	SHORT $LN1@DeleteSequ
$LN3@DeleteSequ:

; 2036 : 			i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN1@DeleteSequ:

; 2037 : 	}

	jmp	$LN5@DeleteSequ
$LN6@DeleteSequ:

; 2038 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?DeleteSequencedPacketsInList@ReliabilityLayer@@AAEXEAAV?$Queue@PAUInternalPacket@@@DataStructures@@@Z ENDP ; ReliabilityLayer::DeleteSequencedPacketsInList
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?DeleteSequencedPacketsInList@ReliabilityLayer@@AAEXEAAV?$List@PAUInternalPacket@@@DataStructures@@H@Z
_TEXT	SEGMENT
$T1 = -236						; size = 4
_internalPacket$2 = -32					; size = 4
_i$ = -20						; size = 4
_this$ = -8						; size = 4
_orderingChannel$ = 8					; size = 1
_theList$ = 12						; size = 4
_splitPacketId$ = 16					; size = 4
?DeleteSequencedPacketsInList@ReliabilityLayer@@AAEXEAAV?$List@PAUInternalPacket@@@DataStructures@@H@Z PROC ; ReliabilityLayer::DeleteSequencedPacketsInList, COMDAT
; _this$ = ecx

; 1995 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1996 : 	unsigned i = 0;

	mov	DWORD PTR _i$[ebp], 0
$LN6@DeleteSequ:

; 1997 : 
; 1998 : 	while ( i < theList.Size() )

	mov	ecx, DWORD PTR _theList$[ebp]
	call	?Size@?$List@PAUInternalPacket@@@DataStructures@@QBEIXZ ; DataStructures::List<InternalPacket *>::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	$LN7@DeleteSequ

; 1999 : 	{
; 2000 : 		if ( ( theList[ i ]->reliability == RELIABLE_SEQUENCED || theList[ i ]->reliability == UNRELIABLE_SEQUENCED ) &&
; 2001 : 			theList[ i ]->orderingChannel == orderingChannel && ( splitPacketId == -1 || theList[ i ]->splitPacketId != (unsigned int) splitPacketId ) )

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _theList$[ebp]
	call	??A?$List@PAUInternalPacket@@@DataStructures@@QBEAAPAUInternalPacket@@I@Z ; DataStructures::List<InternalPacket *>::operator[]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+10], 4
	je	SHORT $LN3@DeleteSequ
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _theList$[ebp]
	call	??A?$List@PAUInternalPacket@@@DataStructures@@QBEAAPAUInternalPacket@@I@Z ; DataStructures::List<InternalPacket *>::operator[]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+10], 1
	jne	$LN4@DeleteSequ
$LN3@DeleteSequ:
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _theList$[ebp]
	call	??A?$List@PAUInternalPacket@@@DataStructures@@QBEAAPAUInternalPacket@@I@Z ; DataStructures::List<InternalPacket *>::operator[]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx+14]
	movzx	eax, BYTE PTR _orderingChannel$[ebp]
	cmp	edx, eax
	jne	SHORT $LN4@DeleteSequ
	cmp	DWORD PTR _splitPacketId$[ebp], -1
	je	SHORT $LN2@DeleteSequ
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _theList$[ebp]
	call	??A?$List@PAUInternalPacket@@@DataStructures@@QBEAAPAUInternalPacket@@I@Z ; DataStructures::List<InternalPacket *>::operator[]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, WORD PTR [ecx+17]
	cmp	edx, DWORD PTR _splitPacketId$[ebp]
	je	SHORT $LN4@DeleteSequ
$LN2@DeleteSequ:

; 2002 : 		{
; 2003 : 			InternalPacket * internalPacket = theList[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _theList$[ebp]
	call	??A?$List@PAUInternalPacket@@@DataStructures@@QBEAAPAUInternalPacket@@I@Z ; DataStructures::List<InternalPacket *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _internalPacket$2[ebp], ecx

; 2004 : 			theList.RemoveAtIndex( i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _theList$[ebp]
	call	?RemoveAtIndex@?$List@PAUInternalPacket@@@DataStructures@@QAEXI@Z ; DataStructures::List<InternalPacket *>::RemoveAtIndex

; 2005 : 			delete [] internalPacket->data;

	mov	eax, DWORD PTR _internalPacket$2[ebp]
	mov	ecx, DWORD PTR [eax+47]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 2006 : 			internalPacketPool.ReleasePointer( internalPacket );

	mov	eax, DWORD PTR _internalPacket$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	call	?ReleasePointer@InternalPacketPool@@QAEXPAUInternalPacket@@@Z ; InternalPacketPool::ReleasePointer

; 2007 : 		}
; 2008 : 
; 2009 : 		else

	jmp	SHORT $LN1@DeleteSequ
$LN4@DeleteSequ:

; 2010 : 			i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN1@DeleteSequ:

; 2011 : 	}

	jmp	$LN6@DeleteSequ
$LN7@DeleteSequ:

; 2012 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?DeleteSequencedPacketsInList@ReliabilityLayer@@AAEXEAAV?$List@PAUInternalPacket@@@DataStructures@@H@Z ENDP ; ReliabilityLayer::DeleteSequencedPacketsInList
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?CheckSHA1@ReliabilityLayer@@AAE_NQADQAEI@Z
_TEXT	SEGMENT
_i$1 = -52						; size = 4
_code2$ = -40						; size = 20
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_code$ = 8						; size = 4
_buffer$ = 12						; size = 4
_nbytes$ = 16						; size = 4
?CheckSHA1@ReliabilityLayer@@AAE_NQADQAEI@Z PROC	; ReliabilityLayer::CheckSHA1, COMDAT
; _this$ = ecx

; 1979 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 248				; 000000f8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-248]
	mov	ecx, 62					; 0000003eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1980 : 	char code2[ SHA1_LENGTH ];
; 1981 : 	GetSHA1( buffer, nbytes, code2 );

	lea	eax, DWORD PTR _code2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nbytes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSHA1@ReliabilityLayer@@AAEXQAEIQAD@Z ; ReliabilityLayer::GetSHA1

; 1982 : 
; 1983 : 	for ( int i = 0; i < SHA1_LENGTH; i++ )

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@CheckSHA1
$LN3@CheckSHA1:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@CheckSHA1:
	cmp	DWORD PTR _i$1[ebp], 20			; 00000014H
	jge	SHORT $LN2@CheckSHA1

; 1984 : 		if ( code[ i ] != code2[ i ] )

	mov	eax, DWORD PTR _code$[ebp]
	add	eax, DWORD PTR _i$1[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _i$1[ebp]
	movsx	eax, BYTE PTR _code2$[ebp+edx]
	cmp	ecx, eax
	je	SHORT $LN1@CheckSHA1

; 1985 : 			return false;

	xor	al, al
	jmp	SHORT $LN5@CheckSHA1
$LN1@CheckSHA1:

; 1986 : 
; 1987 : 	return true;

	jmp	SHORT $LN3@CheckSHA1
$LN2@CheckSHA1:
	mov	al, 1
$LN5@CheckSHA1:

; 1988 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@CheckSHA1
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 248				; 000000f8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	1
$LN9@CheckSHA1:
	DD	1
	DD	$LN8@CheckSHA1
$LN8@CheckSHA1:
	DD	-40					; ffffffd8H
	DD	20					; 00000014H
	DD	$LN7@CheckSHA1
$LN7@CheckSHA1:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	50					; 00000032H
	DB	0
?CheckSHA1@ReliabilityLayer@@AAE_NQADQAEI@Z ENDP	; ReliabilityLayer::CheckSHA1
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?GetSHA1@ReliabilityLayer@@AAEXQAEIQAD@Z
_TEXT	SEGMENT
_sha1$ = -212						; size = 180
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_buffer$ = 8						; size = 4
_nbytes$ = 12						; size = 4
_code$ = 16						; size = 4
?GetSHA1@ReliabilityLayer@@AAEXQAEIQAD@Z PROC		; ReliabilityLayer::GetSHA1, COMDAT
; _this$ = ecx

; 1965 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetSHA1@ReliabilityLayer@@AAEXQAEIQAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 396				; 0000018cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-408]
	mov	ecx, 99					; 00000063H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1966 : 	CSHA1 sha1;

	lea	ecx, DWORD PTR _sha1$[ebp]
	call	??0CSHA1@@QAE@XZ			; CSHA1::CSHA1
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1967 : 
; 1968 : 	sha1.Reset();

	lea	ecx, DWORD PTR _sha1$[ebp]
	call	?Reset@CSHA1@@QAEXXZ			; CSHA1::Reset

; 1969 : 	sha1.Update( ( unsigned char* ) buffer, nbytes );

	mov	eax, DWORD PTR _nbytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _sha1$[ebp]
	call	?Update@CSHA1@@QAEXPAEI@Z		; CSHA1::Update

; 1970 : 	sha1.Final();

	lea	ecx, DWORD PTR _sha1$[ebp]
	call	?Final@CSHA1@@QAEXXZ			; CSHA1::Final

; 1971 : 	memcpy( code, sha1.GetHash(), SHA1_LENGTH );

	push	20					; 00000014H
	lea	ecx, DWORD PTR _sha1$[ebp]
	call	?GetHash@CSHA1@@QBEPAEXZ		; CSHA1::GetHash
	push	eax
	mov	eax, DWORD PTR _code$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1972 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sha1$[ebp]
	call	??1CSHA1@@UAE@XZ			; CSHA1::~CSHA1
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@GetSHA1
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 408				; 00000198H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN7@GetSHA1:
	DD	1
	DD	$LN6@GetSHA1
$LN6@GetSHA1:
	DD	-212					; ffffff2cH
	DD	180					; 000000b4H
	DD	$LN4@GetSHA1
$LN4@GetSHA1:
	DB	115					; 00000073H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	49					; 00000031H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetSHA1@ReliabilityLayer@@AAEXQAEIQAD@Z$0:
	lea	ecx, DWORD PTR _sha1$[ebp]
	jmp	??1CSHA1@@UAE@XZ			; CSHA1::~CSHA1
__ehhandler$?GetSHA1@ReliabilityLayer@@AAEXQAEIQAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-412]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetSHA1@ReliabilityLayer@@AAEXQAEIQAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetSHA1@ReliabilityLayer@@AAEXQAEIQAD@Z ENDP		; ReliabilityLayer::GetSHA1
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?GetBitStreamHeaderLength@ReliabilityLayer@@AAEHQBUInternalPacket@@@Z
_TEXT	SEGMENT
tv81 = -232						; size = 4
_isSplitPacket$ = -29					; size = 1
_bitLength$ = -20					; size = 4
_this$ = -8						; size = 4
_internalPacket$ = 8					; size = 4
?GetBitStreamHeaderLength@ReliabilityLayer@@AAEHQBUInternalPacket@@@Z PROC ; ReliabilityLayer::GetBitStreamHeaderLength, COMDAT
; _this$ = ecx

; 1614 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1615 : #ifdef _DEBUG
; 1616 : 	assert( internalPacket );

	cmp	DWORD PTR _internalPacket$[ebp], 0
	jne	SHORT $LN6@GetBitStre
	mov	eax, DWORD PTR ?__LINE__Var@?1??GetBitStreamHeaderLength@ReliabilityLayer@@AAEHQBUInternalPacket@@@Z@4JA
	add	eax, 2
	push	eax
	push	OFFSET ??_C@_1FK@FKLHGKMO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAe?$AAl?$AAi?$AAa?$AAb?$AAi?$AAl@
	push	OFFSET ??_C@_1BO@FAHOLNMM@?$AAi?$AAn?$AAt?$AAe?$AAr?$AAn?$AAa?$AAl?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN6@GetBitStre:

; 1617 : #endif
; 1618 : 
; 1619 : 	int bitLength;
; 1620 : 
; 1621 : 	bitLength=sizeof(MessageNumberType)*2*8;

	mov	DWORD PTR _bitLength$[ebp], 32		; 00000020H

; 1622 : 
; 1623 : 	// Write the PacketReliability.  This is encoded in 3 bits
; 1624 : 	//bitStream->WriteBits((unsigned char*)&(internalPacket->reliability), 3, true);
; 1625 : 	bitLength += 3;

	mov	eax, DWORD PTR _bitLength$[ebp]
	add	eax, 3
	mov	DWORD PTR _bitLength$[ebp], eax

; 1626 : 
; 1627 : 	// If the reliability requires an ordering channel and ordering index, we Write those.
; 1628 : 	if ( internalPacket->reliability == UNRELIABLE_SEQUENCED || internalPacket->reliability == RELIABLE_SEQUENCED || internalPacket->reliability == RELIABLE_ORDERED )

	mov	eax, DWORD PTR _internalPacket$[ebp]
	cmp	DWORD PTR [eax+10], 1
	je	SHORT $LN2@GetBitStre
	mov	eax, DWORD PTR _internalPacket$[ebp]
	cmp	DWORD PTR [eax+10], 4
	je	SHORT $LN2@GetBitStre
	mov	eax, DWORD PTR _internalPacket$[ebp]
	cmp	DWORD PTR [eax+10], 3
	jne	SHORT $LN3@GetBitStre
$LN2@GetBitStre:

; 1629 : 	{
; 1630 : 		// ordering channel encoded in 5 bits (from 0 to 31)
; 1631 : 		//bitStream->WriteBits((unsigned char*)&(internalPacket->orderingChannel), 5, true);
; 1632 : 		bitLength+=5;

	mov	eax, DWORD PTR _bitLength$[ebp]
	add	eax, 5
	mov	DWORD PTR _bitLength$[ebp], eax

; 1633 : 
; 1634 : 		// ordering index is one byte
; 1635 : 		//bitStream->WriteCompressed(internalPacket->orderingIndex);
; 1636 : 		bitLength+=sizeof(OrderingIndexType)*8;

	mov	eax, DWORD PTR _bitLength$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _bitLength$[ebp], eax
$LN3@GetBitStre:

; 1637 : 	}
; 1638 : 
; 1639 : 	// Write if this is a split packet (1 bit)
; 1640 : 	bool isSplitPacket = internalPacket->splitPacketCount > 0;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	cmp	DWORD PTR [eax+23], 0
	jbe	SHORT $LN7@GetBitStre
	mov	DWORD PTR tv81[ebp], 1
	jmp	SHORT $LN8@GetBitStre
$LN7@GetBitStre:
	mov	DWORD PTR tv81[ebp], 0
$LN8@GetBitStre:
	mov	cl, BYTE PTR tv81[ebp]
	mov	BYTE PTR _isSplitPacket$[ebp], cl

; 1641 : 
; 1642 : 	//bitStream->Write(isSplitPacket);
; 1643 : 	bitLength += 1;

	mov	eax, DWORD PTR _bitLength$[ebp]
	add	eax, 1
	mov	DWORD PTR _bitLength$[ebp], eax

; 1644 : 
; 1645 : 	if ( isSplitPacket )

	movzx	eax, BYTE PTR _isSplitPacket$[ebp]
	test	eax, eax
	je	SHORT $LN1@GetBitStre

; 1646 : 	{
; 1647 : 		// split packet indices are two bytes (so one packet can be split up to 65535
; 1648 : 		// times - maximum packet size would be about 500 * 65535)
; 1649 : 		//bitStream->Write(internalPacket->splitPacketId);
; 1650 : 		//bitStream->WriteCompressed(internalPacket->splitPacketIndex);
; 1651 : 		//bitStream->WriteCompressed(internalPacket->splitPacketCount);
; 1652 : 		bitLength += (sizeof(SplitPacketIdType) + sizeof(SplitPacketIndexType) * 2) * 8;

	mov	eax, DWORD PTR _bitLength$[ebp]
	add	eax, 80					; 00000050H
	mov	DWORD PTR _bitLength$[ebp], eax
$LN1@GetBitStre:

; 1653 : 	}
; 1654 : 
; 1655 : 	// Write how many bits the packet data is. Stored in an unsigned short and
; 1656 : 	// read from 16 bits
; 1657 : 	//bitStream->WriteBits((unsigned char*)&(internalPacket->dataBitLength), 16, true);
; 1658 : 
; 1659 : 	// Read how many bits the packet data is.  Stored in 16 bits
; 1660 : 	bitLength += 16;

	mov	eax, DWORD PTR _bitLength$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _bitLength$[ebp], eax

; 1661 : 
; 1662 : 	// Byte alignment
; 1663 : 	//bitLength += 8 - ((bitLength -1) %8 + 1);
; 1664 : 
; 1665 : 	return bitLength;

	mov	eax, DWORD PTR _bitLength$[ebp]

; 1666 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetBitStreamHeaderLength@ReliabilityLayer@@AAEHQBUInternalPacket@@@Z ENDP ; ReliabilityLayer::GetBitStreamHeaderLength
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?UpdateWindowFromAck@ReliabilityLayer@@AAEX_J@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_time$ = 8						; size = 8
?UpdateWindowFromAck@ReliabilityLayer@@AAEX_J@Z PROC	; ReliabilityLayer::UpdateWindowFromAck, COMDAT
; _this$ = ecx

; 1538 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1539 : 
; 1540 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?UpdateWindowFromAck@ReliabilityLayer@@AAEX_J@Z ENDP	; ReliabilityLayer::UpdateWindowFromAck
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?UpdateWindowFromPacketloss@ReliabilityLayer@@AAEX_J@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_time$ = 8						; size = 8
?UpdateWindowFromPacketloss@ReliabilityLayer@@AAEX_J@Z PROC ; ReliabilityLayer::UpdateWindowFromPacketloss, COMDAT
; _this$ = ecx

; 1530 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1531 : 
; 1532 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?UpdateWindowFromPacketloss@ReliabilityLayer@@AAEX_J@Z ENDP ; ReliabilityLayer::UpdateWindowFromPacketloss
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?IsSendThrottled@ReliabilityLayer@@AAE_NH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_MTUSize$ = 8						; size = 4
?IsSendThrottled@ReliabilityLayer@@AAE_NH@Z PROC	; ReliabilityLayer::IsSendThrottled, COMDAT
; _this$ = ecx

; 1506 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1507 : 	return false;

	xor	al, al

; 1508 : //	return resendList.Size() > windowSize;
; 1509 : 
; 1510 : 	// Disabling this, because it can get stuck here forever
; 1511 : 	/*
; 1512 : 	unsigned packetsWaiting;
; 1513 : 	unsigned resendListDataSize=0;
; 1514 : 	unsigned i;
; 1515 : 	for (i=0; i < resendList.Size(); i++)
; 1516 : 	{
; 1517 : 		if (resendList[i])
; 1518 : 			resendListDataSize+=resendList[i]->dataBitLength;
; 1519 : 	}
; 1520 : 	packetsWaiting = 1 + ((BITS_TO_BYTES(resendListDataSize)) / (MTUSize - UDP_HEADER_SIZE - 10)); // 10 to roughly estimate the raknet header
; 1521 : 
; 1522 : 	return packetsWaiting >= windowSize;
; 1523 : 	*/
; 1524 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSendThrottled@ReliabilityLayer@@AAE_NH@Z ENDP	; ReliabilityLayer::IsSendThrottled
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?SendAcknowledgementPacket@ReliabilityLayer@@AAEXG_J@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_messageNumber$ = 8					; size = 2
_time$ = 12						; size = 8
?SendAcknowledgementPacket@ReliabilityLayer@@AAEXG_J@Z PROC ; ReliabilityLayer::SendAcknowledgementPacket, COMDAT
; _this$ = ecx

; 1604 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1605 : 	statistics.acknowlegementsSent++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+799]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+799], ecx

; 1606 :  	acknowlegements.Insert(messageNumber);

	movzx	eax, WORD PTR _messageNumber$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?Insert@?$RangeList@G@DataStructures@@QAEXG@Z ; DataStructures::RangeList<unsigned short>::Insert

; 1607 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SendAcknowledgementPacket@ReliabilityLayer@@AAEXG_J@Z ENDP ; ReliabilityLayer::SendAcknowledgementPacket
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?RemovePacketFromResendListAndDeleteOlderReliableSequenced@ReliabilityLayer@@AAEIG_J@Z
_TEXT	SEGMENT
_deleted$ = -65						; size = 1
_orderingIndex$ = -56					; size = 2
_orderingChannel$ = -41					; size = 1
_reliability$ = -32					; size = 4
_internalPacket$ = -20					; size = 4
_this$ = -8						; size = 4
_messageNumber$ = 8					; size = 2
_time$ = 12						; size = 8
?RemovePacketFromResendListAndDeleteOlderReliableSequenced@ReliabilityLayer@@AAEIG_J@Z PROC ; ReliabilityLayer::RemovePacketFromResendListAndDeleteOlderReliableSequenced, COMDAT
; _this$ = ecx

; 1546 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1547 : 	InternalPacket * internalPacket;
; 1548 : 	//InternalPacket *temp;
; 1549 : 	PacketReliability reliability; // What type of reliability algorithm to use with this packet
; 1550 : 	unsigned char orderingChannel; // What ordering channel this packet is on, if the reliability type uses ordering channels
; 1551 : 	OrderingIndexType orderingIndex; // The ID used as identification for ordering channels
; 1552 : //	unsigned j;
; 1553 : 
; 1554 : 	bool deleted;
; 1555 : 	deleted=resendList.Delete(messageNumber, internalPacket);

	lea	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	movzx	ecx, WORD PTR _messageNumber$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	?Delete@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QAE_NGAAPAUInternalPacket@@@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::Delete
	mov	BYTE PTR _deleted$[ebp], al

; 1556 : 	if (deleted)

	movzx	eax, BYTE PTR _deleted$[ebp]
	test	eax, eax
	je	SHORT $LN2@RemovePack

; 1557 : 	{
; 1558 : 		reliability = internalPacket->reliability;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	mov	DWORD PTR _reliability$[ebp], ecx

; 1559 : 		orderingChannel = internalPacket->orderingChannel;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	cl, BYTE PTR [eax+14]
	mov	BYTE PTR _orderingChannel$[ebp], cl

; 1560 : 		orderingIndex = internalPacket->orderingIndex;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	cx, WORD PTR [eax+15]
	mov	WORD PTR _orderingIndex$[ebp], cx

; 1561 : //		delete [] internalPacket->data;
; 1562 : //		internalPacketPool.ReleasePointer( internalPacket );
; 1563 : 		internalPacket->nextActionTime=0; // Will be freed in the update function

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	DWORD PTR [eax+35], 0
	mov	DWORD PTR [eax+39], 0

; 1564 : 		return internalPacket->histogramMarker;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	eax, DWORD PTR [eax+51]
	jmp	SHORT $LN3@RemovePack

; 1565 : 
; 1566 : 		// Rarely used and thus disabled for speed
; 1567 : 		/*
; 1568 : 		// If the deleted packet was reliable sequenced, also delete all older reliable sequenced resends on the same ordering channel.
; 1569 : 		// This is because we no longer need to send these.
; 1570 : 		if ( reliability == RELIABLE_SEQUENCED )
; 1571 : 		{
; 1572 : 			unsigned j = 0;
; 1573 : 			while ( j < resendList.Size() )
; 1574 : 			{
; 1575 : 				internalPacket = resendList[ j ];
; 1576 : 
; 1577 : 				if ( internalPacket && internalPacket->reliability == RELIABLE_SEQUENCED && internalPacket->orderingChannel == orderingChannel && IsOlderOrderedPacket( internalPacket->orderingIndex, orderingIndex ) )
; 1578 : 				{
; 1579 : 					// Delete the packet
; 1580 : 					delete [] internalPacket->data;
; 1581 : 					internalPacketPool.ReleasePointer( internalPacket );
; 1582 : 					resendList[ j ] = 0; // Generate a hole
; 1583 : 				}
; 1584 : 
; 1585 : 				j++;
; 1586 : 			}
; 1587 : 
; 1588 : 		}
; 1589 : 		*/
; 1590 : 	}
; 1591 : 	else

	jmp	SHORT $LN1@RemovePack
$LN2@RemovePack:

; 1592 : 	{
; 1593 : 
; 1594 : 		statistics.duplicateAcknowlegementsReceived++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+891]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+891], ecx
$LN1@RemovePack:

; 1595 : 	}
; 1596 : 
; 1597 : 	return (unsigned)-1;

	or	eax, -1
$LN3@RemovePack:

; 1598 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@RemovePack
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	3
$LN7@RemovePack:
	DD	1
	DD	$LN6@RemovePack
$LN6@RemovePack:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN5@RemovePack
$LN5@RemovePack:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	0
?RemovePacketFromResendListAndDeleteOlderReliableSequenced@ReliabilityLayer@@AAEIG_J@Z ENDP ; ReliabilityLayer::RemovePacketFromResendListAndDeleteOlderReliableSequenced
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?CreateInternalPacketFromBitStream@ReliabilityLayer@@AAEPAUInternalPacket@@PAVBitStream@RakNet@@_J@Z
_TEXT	SEGMENT
$T1 = -284						; size = 4
$T2 = -272						; size = 4
_length$ = -68						; size = 2
_isSplitPacket$ = -53					; size = 1
_reliability$ = -41					; size = 1
_internalPacket$ = -32					; size = 4
_bitStreamSucceeded$ = -17				; size = 1
_this$ = -8						; size = 4
_bitStream$ = 8						; size = 4
_time$ = 12						; size = 8
?CreateInternalPacketFromBitStream@ReliabilityLayer@@AAEPAUInternalPacket@@PAVBitStream@RakNet@@_J@Z PROC ; ReliabilityLayer::CreateInternalPacketFromBitStream, COMDAT
; _this$ = ecx

; 1745 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 288				; 00000120H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-288]
	mov	ecx, 72					; 00000048H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1746 : 	bool bitStreamSucceeded;
; 1747 : 	InternalPacket* internalPacket;
; 1748 : 
; 1749 : 	if ( bitStream->GetNumberOfUnreadBits() < (int) sizeof( internalPacket->messageNumber ) * 8 )

	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	?GetNumberOfUnreadBits@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfUnreadBits
	cmp	eax, 16					; 00000010H
	jge	SHORT $LN18@CreateInte

; 1750 : 		return 0; // leftover bits

	xor	eax, eax
	jmp	$LN19@CreateInte
$LN18@CreateInte:

; 1751 : 
; 1752 : 	internalPacket = internalPacketPool.GetPointer();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	call	?GetPointer@InternalPacketPool@@QAEPAUInternalPacket@@XZ ; InternalPacketPool::GetPointer
	mov	DWORD PTR _internalPacket$[ebp], eax

; 1753 : 
; 1754 : #ifdef _DEBUG
; 1755 : 	// Remove accessing undefined memory error
; 1756 : 	memset( internalPacket, 255, sizeof( InternalPacket ) );

	push	55					; 00000037H
	push	255					; 000000ffH
	mov	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1757 : #endif
; 1758 : 
; 1759 : 	internalPacket->creationTime = time;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR _time$[ebp]
	mov	DWORD PTR [eax+27], ecx
	mov	edx, DWORD PTR _time$[ebp+4]
	mov	DWORD PTR [eax+31], edx

; 1760 : 
; 1761 : 	//bitStream->AlignReadToByteBoundary();
; 1762 : 
; 1763 : 	// Read the packet number (2 bytes)
; 1764 : 	bitStreamSucceeded = bitStream->Read( internalPacket->messageNumber );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	??$Read@G@BitStream@RakNet@@QAE_NAAG@Z	; RakNet::BitStream::Read<unsigned short>
	mov	BYTE PTR _bitStreamSucceeded$[ebp], al

; 1765 : 
; 1766 : #ifdef _DEBUG
; 1767 : 	// 10/08/05 - Disabled assert since this hits from offline packets
; 1768 : 	//assert( bitStreamSucceeded );
; 1769 : #endif
; 1770 : 
; 1771 : 	if ( bitStreamSucceeded == false )

	movzx	eax, BYTE PTR _bitStreamSucceeded$[ebp]
	test	eax, eax
	jne	SHORT $LN17@CreateInte

; 1772 : 	{
; 1773 : 		internalPacketPool.ReleasePointer( internalPacket );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	call	?ReleasePointer@InternalPacketPool@@QAEXPAUInternalPacket@@@Z ; InternalPacketPool::ReleasePointer

; 1774 : 		return 0;

	xor	eax, eax
	jmp	$LN19@CreateInte
$LN17@CreateInte:

; 1775 : 	}
; 1776 : 
; 1777 : #ifdef _DEBUG
; 1778 : 	// 10/08/05 - Disabled assert since this hits from offline packets
; 1779 : 	//assert( bitStreamSucceeded );
; 1780 : #endif
; 1781 : 
; 1782 : 	if ( bitStreamSucceeded == false )

	movzx	eax, BYTE PTR _bitStreamSucceeded$[ebp]
	test	eax, eax
	jne	SHORT $LN16@CreateInte

; 1783 : 	{
; 1784 : 		internalPacketPool.ReleasePointer( internalPacket );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	call	?ReleasePointer@InternalPacketPool@@QAEXPAUInternalPacket@@@Z ; InternalPacketPool::ReleasePointer

; 1785 : 		return 0;

	xor	eax, eax
	jmp	$LN19@CreateInte
$LN16@CreateInte:

; 1786 : 	}
; 1787 : 
; 1788 : 	// Read the PacketReliability. This is encoded in 3 bits
; 1789 : 	unsigned char reliability;
; 1790 : 
; 1791 : 	bitStreamSucceeded = bitStream->ReadBits( ( unsigned char* ) ( &( reliability ) ), 3 );

	push	1
	push	3
	lea	eax, DWORD PTR _reliability$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	?ReadBits@BitStream@RakNet@@QAE_NPAEH_N@Z ; RakNet::BitStream::ReadBits
	mov	BYTE PTR _bitStreamSucceeded$[ebp], al

; 1792 : 
; 1793 : 	internalPacket->reliability = ( const PacketReliability ) reliability;

	movzx	eax, BYTE PTR _reliability$[ebp]
	mov	ecx, DWORD PTR _internalPacket$[ebp]
	mov	DWORD PTR [ecx+10], eax

; 1794 : 
; 1795 : #ifdef _DEBUG
; 1796 : 	// 10/08/05 - Disabled assert since this hits from offline packets
; 1797 : 	// assert( bitStreamSucceeded );
; 1798 : #endif
; 1799 : 
; 1800 : 	if ( bitStreamSucceeded == false )

	movzx	eax, BYTE PTR _bitStreamSucceeded$[ebp]
	test	eax, eax
	jne	SHORT $LN15@CreateInte

; 1801 : 	{
; 1802 : 		internalPacketPool.ReleasePointer( internalPacket );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	call	?ReleasePointer@InternalPacketPool@@QAEXPAUInternalPacket@@@Z ; InternalPacketPool::ReleasePointer

; 1803 : 		return 0;

	xor	eax, eax
	jmp	$LN19@CreateInte
$LN15@CreateInte:

; 1804 : 	}
; 1805 : 
; 1806 : 	// If the reliability requires an ordering channel and ordering index, we read those.
; 1807 : 	if ( internalPacket->reliability == UNRELIABLE_SEQUENCED || internalPacket->reliability == RELIABLE_SEQUENCED || internalPacket->reliability == RELIABLE_ORDERED )

	mov	eax, DWORD PTR _internalPacket$[ebp]
	cmp	DWORD PTR [eax+10], 1
	je	SHORT $LN13@CreateInte
	mov	eax, DWORD PTR _internalPacket$[ebp]
	cmp	DWORD PTR [eax+10], 4
	je	SHORT $LN13@CreateInte
	mov	eax, DWORD PTR _internalPacket$[ebp]
	cmp	DWORD PTR [eax+10], 3
	jne	SHORT $LN14@CreateInte
$LN13@CreateInte:

; 1808 : 	{
; 1809 : 		// ordering channel encoded in 5 bits (from 0 to 31)
; 1810 : 		bitStreamSucceeded = bitStream->ReadBits( ( unsigned char* ) & ( internalPacket->orderingChannel ), 5 );

	push	1
	push	5
	mov	eax, DWORD PTR _internalPacket$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	?ReadBits@BitStream@RakNet@@QAE_NPAEH_N@Z ; RakNet::BitStream::ReadBits
	mov	BYTE PTR _bitStreamSucceeded$[ebp], al

; 1811 : #ifdef _DEBUG
; 1812 : 		// 10/08/05 - Disabled assert since this hits from offline packets
; 1813 : 		//assert( bitStreamSucceeded );
; 1814 : #endif
; 1815 : 
; 1816 : 		if ( bitStreamSucceeded == false )

	movzx	eax, BYTE PTR _bitStreamSucceeded$[ebp]
	test	eax, eax
	jne	SHORT $LN12@CreateInte

; 1817 : 		{
; 1818 : 			internalPacketPool.ReleasePointer( internalPacket );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	call	?ReleasePointer@InternalPacketPool@@QAEXPAUInternalPacket@@@Z ; InternalPacketPool::ReleasePointer

; 1819 : 			return 0;

	xor	eax, eax
	jmp	$LN19@CreateInte
$LN12@CreateInte:

; 1820 : 		}
; 1821 : 
; 1822 : 		bitStreamSucceeded = bitStream->Read( internalPacket->orderingIndex );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	add	eax, 15					; 0000000fH
	push	eax
	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	??$Read@G@BitStream@RakNet@@QAE_NAAG@Z	; RakNet::BitStream::Read<unsigned short>
	mov	BYTE PTR _bitStreamSucceeded$[ebp], al

; 1823 : 
; 1824 : #ifdef _DEBUG
; 1825 : 		// 10/08/05 - Disabled assert since this hits from offline packets
; 1826 : 		//assert( bitStreamSucceeded );
; 1827 : #endif
; 1828 : 
; 1829 : 		if ( bitStreamSucceeded == false )

	movzx	eax, BYTE PTR _bitStreamSucceeded$[ebp]
	test	eax, eax
	jne	SHORT $LN14@CreateInte

; 1830 : 		{
; 1831 : 			internalPacketPool.ReleasePointer( internalPacket );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	call	?ReleasePointer@InternalPacketPool@@QAEXPAUInternalPacket@@@Z ; InternalPacketPool::ReleasePointer

; 1832 : 			return 0;

	xor	eax, eax
	jmp	$LN19@CreateInte
$LN14@CreateInte:

; 1833 : 		}
; 1834 : 	}
; 1835 : 
; 1836 : 	// Read if this is a split packet (1 bit)
; 1837 : 	bool isSplitPacket;
; 1838 : 
; 1839 : 	bitStreamSucceeded = bitStream->Read( isSplitPacket );

	lea	eax, DWORD PTR _isSplitPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z ; RakNet::BitStream::Read<bool>
	mov	BYTE PTR _bitStreamSucceeded$[ebp], al

; 1840 : 
; 1841 : #ifdef _DEBUG
; 1842 : 	// 10/08/05 - Disabled assert since this hits from offline packets
; 1843 : 	//assert( bitStreamSucceeded );
; 1844 : #endif
; 1845 : 
; 1846 : 	if ( bitStreamSucceeded == false )

	movzx	eax, BYTE PTR _bitStreamSucceeded$[ebp]
	test	eax, eax
	jne	SHORT $LN10@CreateInte

; 1847 : 	{
; 1848 : 		internalPacketPool.ReleasePointer( internalPacket );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	call	?ReleasePointer@InternalPacketPool@@QAEXPAUInternalPacket@@@Z ; InternalPacketPool::ReleasePointer

; 1849 : 		return 0;

	xor	eax, eax
	jmp	$LN19@CreateInte
$LN10@CreateInte:

; 1850 : 	}
; 1851 : 
; 1852 : 	if ( isSplitPacket )

	movzx	eax, BYTE PTR _isSplitPacket$[ebp]
	test	eax, eax
	je	$LN9@CreateInte

; 1853 : 	{
; 1854 : 		bitStreamSucceeded = bitStream->Read( internalPacket->splitPacketId );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	add	eax, 17					; 00000011H
	push	eax
	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	??$Read@G@BitStream@RakNet@@QAE_NAAG@Z	; RakNet::BitStream::Read<unsigned short>
	mov	BYTE PTR _bitStreamSucceeded$[ebp], al

; 1855 : #ifdef _DEBUG
; 1856 : 		// 10/08/05 - Disabled assert since this hits from offline packets
; 1857 : 		// assert( bitStreamSucceeded );
; 1858 : #endif
; 1859 : 
; 1860 : 		if ( bitStreamSucceeded == false )

	movzx	eax, BYTE PTR _bitStreamSucceeded$[ebp]
	test	eax, eax
	jne	SHORT $LN8@CreateInte

; 1861 : 		{
; 1862 : 			internalPacketPool.ReleasePointer( internalPacket );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	call	?ReleasePointer@InternalPacketPool@@QAEXPAUInternalPacket@@@Z ; InternalPacketPool::ReleasePointer

; 1863 : 			return 0;

	xor	eax, eax
	jmp	$LN19@CreateInte
$LN8@CreateInte:

; 1864 : 		}
; 1865 : 
; 1866 : 		bitStreamSucceeded = bitStream->ReadCompressed( internalPacket->splitPacketIndex );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	add	eax, 19					; 00000013H
	push	eax
	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	??$ReadCompressed@I@BitStream@RakNet@@QAE_NAAI@Z ; RakNet::BitStream::ReadCompressed<unsigned int>
	mov	BYTE PTR _bitStreamSucceeded$[ebp], al

; 1867 : #ifdef _DEBUG
; 1868 : 		// 10/08/05 - Disabled assert since this hits from offline packets
; 1869 : 		//assert( bitStreamSucceeded );
; 1870 : #endif
; 1871 : 
; 1872 : 		if ( bitStreamSucceeded == false )

	movzx	eax, BYTE PTR _bitStreamSucceeded$[ebp]
	test	eax, eax
	jne	SHORT $LN7@CreateInte

; 1873 : 		{
; 1874 : 			internalPacketPool.ReleasePointer( internalPacket );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	call	?ReleasePointer@InternalPacketPool@@QAEXPAUInternalPacket@@@Z ; InternalPacketPool::ReleasePointer

; 1875 : 			return 0;

	xor	eax, eax
	jmp	$LN19@CreateInte
$LN7@CreateInte:

; 1876 : 		}
; 1877 : 
; 1878 : 		bitStreamSucceeded = bitStream->ReadCompressed( internalPacket->splitPacketCount );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	add	eax, 23					; 00000017H
	push	eax
	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	??$ReadCompressed@I@BitStream@RakNet@@QAE_NAAI@Z ; RakNet::BitStream::ReadCompressed<unsigned int>
	mov	BYTE PTR _bitStreamSucceeded$[ebp], al

; 1879 : #ifdef _DEBUG
; 1880 : 		// 10/08/05 - Disabled assert since this hits from offline packets
; 1881 : 		//assert( bitStreamSucceeded );
; 1882 : #endif
; 1883 : 
; 1884 : 		if ( bitStreamSucceeded == false )

	movzx	eax, BYTE PTR _bitStreamSucceeded$[ebp]
	test	eax, eax
	jne	SHORT $LN6@CreateInte

; 1885 : 		{
; 1886 : 			internalPacketPool.ReleasePointer( internalPacket );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	call	?ReleasePointer@InternalPacketPool@@QAEXPAUInternalPacket@@@Z ; InternalPacketPool::ReleasePointer

; 1887 : 			return 0;

	xor	eax, eax
	jmp	$LN19@CreateInte
$LN6@CreateInte:

; 1888 : 		}
; 1889 : 	}
; 1890 : 
; 1891 : 	else

	jmp	SHORT $LN5@CreateInte
$LN9@CreateInte:

; 1892 : 		internalPacket->splitPacketIndex = internalPacket->splitPacketCount = 0;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	DWORD PTR [eax+23], 0
	mov	ecx, DWORD PTR _internalPacket$[ebp]
	mov	DWORD PTR [ecx+19], 0
$LN5@CreateInte:

; 1893 : 
; 1894 : 	// Optimization - do byte alignment here
; 1895 : 	//unsigned char zero;
; 1896 : 	//bitStream->ReadBits(&zero, 8 - (bitStream->GetNumberOfBitsUsed() %8));
; 1897 : 	//assert(zero==0);
; 1898 : 
; 1899 : 
; 1900 : 	unsigned short length;
; 1901 : 
; 1902 : 	bitStreamSucceeded = bitStream->ReadCompressed( length );

	lea	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	??$ReadCompressed@G@BitStream@RakNet@@QAE_NAAG@Z ; RakNet::BitStream::ReadCompressed<unsigned short>
	mov	BYTE PTR _bitStreamSucceeded$[ebp], al

; 1903 : 
; 1904 : 	// Read into an unsigned short.  Otherwise the data would be offset too high by two bytes
; 1905 : #ifdef _DEBUG
; 1906 : 	// 10/08/05 - Disabled assert since this hits from offline packets
; 1907 : 	//assert( bitStreamSucceeded );
; 1908 : #endif
; 1909 : 
; 1910 : 	if ( bitStreamSucceeded == false )

	movzx	eax, BYTE PTR _bitStreamSucceeded$[ebp]
	test	eax, eax
	jne	SHORT $LN4@CreateInte

; 1911 : 	{
; 1912 : 		internalPacketPool.ReleasePointer( internalPacket );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	call	?ReleasePointer@InternalPacketPool@@QAEXPAUInternalPacket@@@Z ; InternalPacketPool::ReleasePointer

; 1913 : 		return 0;

	xor	eax, eax
	jmp	$LN19@CreateInte
$LN4@CreateInte:

; 1914 : 	}
; 1915 : 
; 1916 : 	internalPacket->dataBitLength = length;

	movzx	eax, WORD PTR _length$[ebp]
	mov	ecx, DWORD PTR _internalPacket$[ebp]
	mov	DWORD PTR [ecx+43], eax

; 1917 : #ifdef _DEBUG
; 1918 : 	// 10/08/05 - Disabled assert since this hits from offline packets arriving when the sender does not know we just connected, which is an unavoidable condition sometimes
; 1919 : 	//	assert( internalPacket->dataBitLength > 0 && BITS_TO_BYTES( internalPacket->dataBitLength ) < MAXIMUM_MTU_SIZE );
; 1920 : #endif
; 1921 : 	if ( ! ( internalPacket->dataBitLength > 0 && BITS_TO_BYTES( internalPacket->dataBitLength ) < MAXIMUM_MTU_SIZE ) )

	mov	eax, DWORD PTR _internalPacket$[ebp]
	cmp	DWORD PTR [eax+43], 0
	jbe	SHORT $LN2@CreateInte
	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR [eax+43]
	add	ecx, 7
	shr	ecx, 3
	cmp	ecx, 576				; 00000240H
	jb	SHORT $LN3@CreateInte
$LN2@CreateInte:

; 1922 : 	{
; 1923 : 		// 10/08/05 - internalPacket->data wasn't allocated yet
; 1924 : 		//	delete [] internalPacket->data;
; 1925 : 		internalPacketPool.ReleasePointer( internalPacket );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	call	?ReleasePointer@InternalPacketPool@@QAEXPAUInternalPacket@@@Z ; InternalPacketPool::ReleasePointer

; 1926 : 		return 0;

	xor	eax, eax
	jmp	$LN19@CreateInte
$LN3@CreateInte:

; 1927 : 	}
; 1928 : 
; 1929 : 	// Allocate memory to hold our data
; 1930 : 	internalPacket->data = new unsigned char [ BITS_TO_BYTES( internalPacket->dataBitLength ) ];

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR [eax+43]
	add	ecx, 7
	shr	ecx, 3
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	edx, DWORD PTR _internalPacket$[ebp]
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR [edx+47], eax

; 1931 : 	//printf("Allocating %i\n",  internalPacket->data);
; 1932 : 
; 1933 : 	// Set the last byte to 0 so if ReadBits does not read a multiple of 8 the last bits are 0'ed out
; 1934 : 	internalPacket->data[ BITS_TO_BYTES( internalPacket->dataBitLength ) - 1 ] = 0;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR [eax+43]
	add	ecx, 7
	shr	ecx, 3
	mov	edx, DWORD PTR _internalPacket$[ebp]
	mov	eax, DWORD PTR [edx+47]
	mov	BYTE PTR [eax+ecx-1], 0

; 1935 : 
; 1936 : 	// Read the data the packet holds
; 1937 : 	bitStreamSucceeded = bitStream->ReadAlignedBytes( ( unsigned char* ) internalPacket->data, BITS_TO_BYTES( internalPacket->dataBitLength ) );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR [eax+43]
	add	ecx, 7
	shr	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _internalPacket$[ebp]
	mov	eax, DWORD PTR [edx+47]
	push	eax
	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	?ReadAlignedBytes@BitStream@RakNet@@QAE_NPAEH@Z ; RakNet::BitStream::ReadAlignedBytes
	mov	BYTE PTR _bitStreamSucceeded$[ebp], al

; 1938 : 
; 1939 : 	//bitStreamSucceeded = bitStream->ReadBits((unsigned char*)internalPacket->data, internalPacket->dataBitLength);
; 1940 : #ifdef _DEBUG
; 1941 : 
; 1942 : 	// 10/08/05 - Disabled assert since this hits from offline packets
; 1943 : 	//assert( bitStreamSucceeded );
; 1944 : #endif
; 1945 : 
; 1946 : 	if ( bitStreamSucceeded == false )

	movzx	eax, BYTE PTR _bitStreamSucceeded$[ebp]
	test	eax, eax
	jne	SHORT $LN1@CreateInte

; 1947 : 	{
; 1948 : 		delete [] internalPacket->data;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR [eax+47]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1949 : 		internalPacketPool.ReleasePointer( internalPacket );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	call	?ReleasePointer@InternalPacketPool@@QAEXPAUInternalPacket@@@Z ; InternalPacketPool::ReleasePointer

; 1950 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN19@CreateInte
$LN1@CreateInte:

; 1951 : 	}
; 1952 : 
; 1953 : 	// PRINTING UNRELIABLE STRINGS
; 1954 : 	// if (internalPacket->data && internalPacket->dataBitLength>5*8)
; 1955 : 	//  printf("Received %s\n",internalPacket->data);
; 1956 : 
; 1957 : 	return internalPacket;

	mov	eax, DWORD PTR _internalPacket$[ebp]
$LN19@CreateInte:

; 1958 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN25@CreateInte
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 288				; 00000120H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	3
$LN25@CreateInte:
	DD	3
	DD	$LN24@CreateInte
$LN24@CreateInte:
	DD	-41					; ffffffd7H
	DD	1
	DD	$LN21@CreateInte
	DD	-53					; ffffffcbH
	DD	1
	DD	$LN22@CreateInte
	DD	-68					; ffffffbcH
	DD	2
	DD	$LN23@CreateInte
$LN23@CreateInte:
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$LN22@CreateInte:
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	83					; 00000053H
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	0
$LN21@CreateInte:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	97					; 00000061H
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	121					; 00000079H
	DB	0
?CreateInternalPacketFromBitStream@ReliabilityLayer@@AAEPAUInternalPacket@@PAVBitStream@RakNet@@_J@Z ENDP ; ReliabilityLayer::CreateInternalPacketFromBitStream
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?WriteToBitStreamFromInternalPacket@ReliabilityLayer@@AAEHPAVBitStream@RakNet@@QBUInternalPacket@@@Z
_TEXT	SEGMENT
tv136 = -256						; size = 4
_length$ = -56						; size = 2
_isSplitPacket$ = -41					; size = 1
_c$ = -29						; size = 1
_start$ = -20						; size = 4
_this$ = -8						; size = 4
_bitStream$ = 8						; size = 4
_internalPacket$ = 12					; size = 4
?WriteToBitStreamFromInternalPacket@ReliabilityLayer@@AAEHPAVBitStream@RakNet@@QBUInternalPacket@@@Z PROC ; ReliabilityLayer::WriteToBitStreamFromInternalPacket, COMDAT
; _this$ = ecx

; 1672 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1673 : #ifdef _DEBUG
; 1674 : 	assert( bitStream && internalPacket );

	cmp	DWORD PTR _bitStream$[ebp], 0
	je	SHORT $LN6@WriteToBit
	cmp	DWORD PTR _internalPacket$[ebp], 0
	jne	SHORT $LN7@WriteToBit
$LN6@WriteToBit:
	mov	eax, DWORD PTR ?__LINE__Var@?1??WriteToBitStreamFromInternalPacket@ReliabilityLayer@@AAEHPAVBitStream@RakNet@@QBUInternalPacket@@@Z@4JA
	add	eax, 2
	push	eax
	push	OFFSET ??_C@_1FK@FKLHGKMO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAe?$AAl?$AAi?$AAa?$AAb?$AAi?$AAl@
	push	OFFSET ??_C@_1DI@CEDLGLL@?$AAb?$AAi?$AAt?$AAS?$AAt?$AAr?$AAe?$AAa?$AAm?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAt?$AAe?$AAr?$AAn?$AAa?$AAl?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN7@WriteToBit:

; 1675 : #endif
; 1676 : 
; 1677 : 	int start = bitStream->GetNumberOfBitsUsed();

	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBitsUsed
	mov	DWORD PTR _start$[ebp], eax

; 1678 : 	const unsigned char c = (unsigned char) internalPacket->reliability;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	cl, BYTE PTR [eax+10]
	mov	BYTE PTR _c$[ebp], cl

; 1679 : 
; 1680 : 	// testing
; 1681 : 	//if (internalPacket->reliability==UNRELIABLE)
; 1682 : 	//  printf("Sending unreliable packet %i\n", internalPacket->messageNumber);
; 1683 : 	//else if (internalPacket->reliability==RELIABLE_SEQUENCED || internalPacket->reliability==RELIABLE_ORDERED || internalPacket->reliability==RELIABLE)
; 1684 : 	//	  printf("Sending reliable packet number %i\n", internalPacket->messageNumber);
; 1685 : 
; 1686 : 	//bitStream->AlignWriteToByteBoundary();
; 1687 : 
; 1688 : 	// Write the message number (2 bytes)
; 1689 : 	bitStream->Write( internalPacket->messageNumber );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	movzx	ecx, WORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	??$Write@G@BitStream@RakNet@@QAEXG@Z	; RakNet::BitStream::Write<unsigned short>

; 1690 : 
; 1691 : 	// Acknowledgment packets have no more data than the messageNumber and whether it is anacknowledgment
; 1692 : 
; 1693 : 
; 1694 : #ifdef _DEBUG
; 1695 : 	assert( internalPacket->dataBitLength > 0 );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	cmp	DWORD PTR [eax+43], 0
	ja	SHORT $LN8@WriteToBit
	mov	ecx, DWORD PTR ?__LINE__Var@?1??WriteToBitStreamFromInternalPacket@ReliabilityLayer@@AAEHPAVBitStream@RakNet@@QBUInternalPacket@@@Z@4JA
	add	ecx, 23					; 00000017H
	push	ecx
	push	OFFSET ??_C@_1FK@FKLHGKMO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAe?$AAl?$AAi?$AAa?$AAb?$AAi?$AAl@
	push	OFFSET ??_C@_1EE@LOHKMABB@?$AAi?$AAn?$AAt?$AAe?$AAr?$AAn?$AAa?$AAl?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AAB?$AAi?$AAt?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN8@WriteToBit:

; 1696 : #endif
; 1697 : 
; 1698 : 	// Write the PacketReliability.  This is encoded in 3 bits
; 1699 : 	bitStream->WriteBits( (const unsigned char *)&c, 3, true );

	push	1
	push	3
	lea	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z ; RakNet::BitStream::WriteBits

; 1700 : 
; 1701 : 	// If the reliability requires an ordering channel and ordering index, we Write those.
; 1702 : 	if ( internalPacket->reliability == UNRELIABLE_SEQUENCED || internalPacket->reliability == RELIABLE_SEQUENCED || internalPacket->reliability == RELIABLE_ORDERED )

	mov	eax, DWORD PTR _internalPacket$[ebp]
	cmp	DWORD PTR [eax+10], 1
	je	SHORT $LN2@WriteToBit
	mov	eax, DWORD PTR _internalPacket$[ebp]
	cmp	DWORD PTR [eax+10], 4
	je	SHORT $LN2@WriteToBit
	mov	eax, DWORD PTR _internalPacket$[ebp]
	cmp	DWORD PTR [eax+10], 3
	jne	SHORT $LN3@WriteToBit
$LN2@WriteToBit:

; 1703 : 	{
; 1704 : 		// ordering channel encoded in 5 bits (from 0 to 31)
; 1705 : 		bitStream->WriteBits( ( unsigned char* ) & ( internalPacket->orderingChannel ), 5, true );

	push	1
	push	5
	mov	eax, DWORD PTR _internalPacket$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z ; RakNet::BitStream::WriteBits

; 1706 : 
; 1707 : 		// One or two bytes
; 1708 : 		bitStream->Write( internalPacket->orderingIndex );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	movzx	ecx, WORD PTR [eax+15]
	push	ecx
	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	??$Write@G@BitStream@RakNet@@QAEXG@Z	; RakNet::BitStream::Write<unsigned short>
$LN3@WriteToBit:

; 1709 : 	}
; 1710 : 
; 1711 : 	// Write if this is a split packet (1 bit)
; 1712 : 	bool isSplitPacket = internalPacket->splitPacketCount > 0;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	cmp	DWORD PTR [eax+23], 0
	jbe	SHORT $LN9@WriteToBit
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN10@WriteToBit
$LN9@WriteToBit:
	mov	DWORD PTR tv136[ebp], 0
$LN10@WriteToBit:
	mov	cl, BYTE PTR tv136[ebp]
	mov	BYTE PTR _isSplitPacket$[ebp], cl

; 1713 : 
; 1714 : 	bitStream->Write( isSplitPacket );

	movzx	eax, BYTE PTR _isSplitPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	??$Write@_N@BitStream@RakNet@@QAEX_N@Z	; RakNet::BitStream::Write<bool>

; 1715 : 
; 1716 : 	if ( isSplitPacket )

	movzx	eax, BYTE PTR _isSplitPacket$[ebp]
	test	eax, eax
	je	SHORT $LN1@WriteToBit

; 1717 : 	{
; 1718 : 		bitStream->Write( internalPacket->splitPacketId );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	movzx	ecx, WORD PTR [eax+17]
	push	ecx
	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	??$Write@G@BitStream@RakNet@@QAEXG@Z	; RakNet::BitStream::Write<unsigned short>

; 1719 : 		bitStream->WriteCompressed( internalPacket->splitPacketIndex );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR [eax+19]
	push	ecx
	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	??$WriteCompressed@I@BitStream@RakNet@@QAEXI@Z ; RakNet::BitStream::WriteCompressed<unsigned int>

; 1720 : 		bitStream->WriteCompressed( internalPacket->splitPacketCount );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR [eax+23]
	push	ecx
	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	??$WriteCompressed@I@BitStream@RakNet@@QAEXI@Z ; RakNet::BitStream::WriteCompressed<unsigned int>
$LN1@WriteToBit:

; 1721 : 	}
; 1722 : 
; 1723 : 	// Write how many bits the packet data is. Stored in 13 bits
; 1724 : #ifdef _DEBUG
; 1725 : 	assert( BITS_TO_BYTES( internalPacket->dataBitLength ) < MAXIMUM_MTU_SIZE ); // I never send more than MTU_SIZE bytes

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR [eax+43]
	add	ecx, 7
	shr	ecx, 3
	cmp	ecx, 576				; 00000240H
	jb	SHORT $LN11@WriteToBit
	mov	edx, DWORD PTR ?__LINE__Var@?1??WriteToBitStreamFromInternalPacket@ReliabilityLayer@@AAEHPAVBitStream@RakNet@@QBUInternalPacket@@@Z@4JA
	add	edx, 53					; 00000035H
	push	edx
	push	OFFSET ??_C@_1FK@FKLHGKMO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAe?$AAl?$AAi?$AAa?$AAb?$AAi?$AAl@
	push	OFFSET ??_C@_1IE@GICOMIGA@?$AAB?$AAI?$AAT?$AAS?$AA_?$AAT?$AAO?$AA_?$AAB?$AAY?$AAT?$AAE?$AAS?$AA?$CI?$AA?5?$AAi?$AAn?$AAt?$AAe?$AAr?$AAn?$AAa?$AAl?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?9?$AA?$DO?$AAd@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN11@WriteToBit:

; 1726 : 
; 1727 : #endif
; 1728 : 
; 1729 : 	unsigned short length = ( unsigned short ) internalPacket->dataBitLength; // Ignore the 2 high bytes for WriteBits

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	cx, WORD PTR [eax+43]
	mov	WORD PTR _length$[ebp], cx

; 1730 : 
; 1731 : 	bitStream->WriteCompressed( length );

	movzx	eax, WORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	??$WriteCompressed@G@BitStream@RakNet@@QAEXG@Z ; RakNet::BitStream::WriteCompressed<unsigned short>

; 1732 : 
; 1733 : 	// Write the actual data.
; 1734 : 	bitStream->WriteAlignedBytes( ( unsigned char* ) internalPacket->data, BITS_TO_BYTES( internalPacket->dataBitLength ) );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR [eax+43]
	add	ecx, 7
	shr	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _internalPacket$[ebp]
	mov	eax, DWORD PTR [edx+47]
	push	eax
	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	?WriteAlignedBytes@BitStream@RakNet@@QAEXPBEH@Z ; RakNet::BitStream::WriteAlignedBytes

; 1735 : 
; 1736 : 	//bitStream->WriteBits((unsigned char*)internalPacket->data, internalPacket->dataBitLength);
; 1737 : 
; 1738 : 	return bitStream->GetNumberOfBitsUsed() - start;

	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBitsUsed
	sub	eax, DWORD PTR _start$[ebp]

; 1739 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN14@WriteToBit
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN14@WriteToBit:
	DD	1
	DD	$LN13@WriteToBit
$LN13@WriteToBit:
	DD	-29					; ffffffe3H
	DD	1
	DD	$LN12@WriteToBit
$LN12@WriteToBit:
	DB	99					; 00000063H
	DB	0
?WriteToBitStreamFromInternalPacket@ReliabilityLayer@@AAEHPAVBitStream@RakNet@@QBUInternalPacket@@@Z ENDP ; ReliabilityLayer::WriteToBitStreamFromInternalPacket
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?SendBitStream@ReliabilityLayer@@AAEXIUPlayerID@@PAVBitStream@RakNet@@@Z
_TEXT	SEGMENT
tv170 = -248						; size = 4
_chanceToLosePacket$1 = -48				; size = 8
_length$ = -32						; size = 4
_oldLength$ = -20					; size = 4
_this$ = -8						; size = 4
_s$ = 8							; size = 4
_playerId$ = 12						; size = 6
_bitStream$ = 20					; size = 4
?SendBitStream@ReliabilityLayer@@AAEXIUPlayerID@@PAVBitStream@RakNet@@@Z PROC ; ReliabilityLayer::SendBitStream, COMDAT
; _this$ = ecx

; 1175 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 248				; 000000f8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-248]
	mov	ecx, 62					; 0000003eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1176 : 	// SHOW - showing reliable flow
; 1177 : 	// if (bitStream->GetNumberOfBytesUsed()>50)
; 1178 : 	//  printf("Sending %i bytes. sendQueue[0].Size()=%i, resendList.Size()=%i\n", bitStream->GetNumberOfBytesUsed(), sendQueue[0].Size(),resendList.Size());
; 1179 : 
; 1180 : 	int oldLength, length;
; 1181 : 
; 1182 : 	// sentFrames++;
; 1183 : 
; 1184 : #ifndef _RELEASE
; 1185 : 	if (maxSendBPS>0)

	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [eax+1658]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	SHORT $LN3@SendBitStr

; 1186 : 	{
; 1187 : 		double chanceToLosePacket = (double)currentBandwidth / (double)maxSendBPS;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [eax+1002]
	divsd	xmm0, QWORD PTR [ecx+1658]
	movsd	QWORD PTR _chanceToLosePacket$1[ebp], xmm0

; 1188 : 		if (frandomMT() < (float)chanceToLosePacket)

	call	?frandomMT@@YAMXZ			; frandomMT
	fstp	DWORD PTR tv170[ebp]
	cvtsd2ss xmm0, QWORD PTR _chanceToLosePacket$1[ebp]
	comiss	xmm0, DWORD PTR tv170[ebp]
	jbe	SHORT $LN3@SendBitStr

; 1189 : 			return;

	jmp	$LN5@SendBitStr
$LN3@SendBitStr:

; 1190 : 
; 1191 : 	}
; 1192 : #endif
; 1193 : 
; 1194 : 	// Encode the whole bitstream if the encoder is defined.
; 1195 : 
; 1196 : 	if ( encryptor.IsKeySet() )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1019				; 000003fbH
	call	?IsKeySet@TEABlockEncryptor@@QBE_NXZ	; TEABlockEncryptor::IsKeySet
	movzx	eax, al
	test	eax, eax
	je	$LN2@SendBitStr

; 1197 : 	{
; 1198 : 		length = bitStream->GetNumberOfBytesUsed();

	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	?GetNumberOfBytesUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBytesUsed
	mov	DWORD PTR _length$[ebp], eax

; 1199 : 		oldLength = length;

	mov	eax, DWORD PTR _length$[ebp]
	mov	DWORD PTR _oldLength$[ebp], eax

; 1200 : 
; 1201 : 		encryptor.Encrypt( ( unsigned char* ) bitStream->GetData(), length, ( unsigned char* ) bitStream->GetData(), &length );

	lea	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	?GetData@BitStream@RakNet@@QBEPAEXZ	; RakNet::BitStream::GetData
	push	eax
	mov	ecx, DWORD PTR _length$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	?GetData@BitStream@RakNet@@QBEPAEXZ	; RakNet::BitStream::GetData
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1019				; 000003fbH
	call	?Encrypt@TEABlockEncryptor@@QAEXPAEH0PAH@Z ; TEABlockEncryptor::Encrypt

; 1202 : 		statistics.encryptionBitsSent += ( length - oldLength ) * 8;

	mov	eax, DWORD PTR _length$[ebp]
	sub	eax, DWORD PTR _oldLength$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+847]
	lea	eax, DWORD PTR [edx+eax*8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+847], eax

; 1203 : 
; 1204 : #ifdef TEA_ENCRYPTOR
; 1205 : 		assert( ( length % 8 ) == 0 );

	mov	eax, DWORD PTR _length$[ebp]
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN11@SendBitStr
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN11@SendBitStr:
	test	eax, eax
	je	SHORT $LN7@SendBitStr
	mov	ecx, DWORD PTR ?__LINE__Var@?1??SendBitStream@ReliabilityLayer@@AAEXIUPlayerID@@PAVBitStream@RakNet@@@Z@4JA
	add	ecx, 30					; 0000001eH
	push	ecx
	push	OFFSET ??_C@_1FK@FKLHGKMO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAe?$AAl?$AAi?$AAa?$AAb?$AAi?$AAl@
	push	OFFSET ??_C@_1CI@ENDPABPL@?$AA?$CI?$AA?5?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$CF?$AA?5?$AA8?$AA?5?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN7@SendBitStr:

; 1206 : #else
; 1207 : 		assert( ( length % 16 ) == 0 );
; 1208 : #endif
; 1209 : 	}
; 1210 : 	else

	jmp	SHORT $LN1@SendBitStr
$LN2@SendBitStr:

; 1211 : 	{
; 1212 : 		length = bitStream->GetNumberOfBytesUsed();

	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	?GetNumberOfBytesUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBytesUsed
	mov	DWORD PTR _length$[ebp], eax
$LN1@SendBitStr:

; 1213 : 	}
; 1214 : 
; 1215 : #ifdef __USE_IO_COMPLETION_PORTS
; 1216 : 	if ( readWriteSocket == INVALID_SOCKET )
; 1217 : 	{
; 1218 : 		assert( 0 );
; 1219 : 		return ;
; 1220 : 	}
; 1221 : 
; 1222 : 	statistics.packetsSent++;
; 1223 : 	statistics.totalBitsSent += length * 8;
; 1224 : 	SocketLayer::Instance()->Write( readWriteSocket, ( const char* ) bitStream->GetData(), length );
; 1225 : #else
; 1226 : 
; 1227 : 	statistics.packetsSent++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+843]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+843], ecx

; 1228 : 	statistics.totalBitsSent += length * 8;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+851]
	mov	edx, DWORD PTR _length$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+851], eax

; 1229 : 	//printf("total bits=%i length=%i\n", BITS_TO_BYTES(statistics.totalBitsSent), length);
; 1230 : 
; 1231 : 	SocketLayer::Instance()->SendTo( s, ( char* ) bitStream->GetData(), length, playerId.binaryAddress, playerId.port );

	movzx	eax, WORD PTR _playerId$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _playerId$[ebp]
	push	ecx
	mov	edx, DWORD PTR _length$[ebp]
	push	edx
	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	?GetData@BitStream@RakNet@@QBEPAEXZ	; RakNet::BitStream::GetData
	push	eax
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	?Instance@SocketLayer@@SAPAV1@XZ	; SocketLayer::Instance
	mov	ecx, eax
	call	?SendTo@SocketLayer@@QAEHIPBDHIG@Z	; SocketLayer::SendTo
$LN5@SendBitStr:

; 1232 : #endif // __USE_IO_COMPLETION_PORTS
; 1233 : 
; 1234 : 	// lastPacketSendTime=time;
; 1235 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@SendBitStr
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 248				; 000000f8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN10@SendBitStr:
	DD	1
	DD	$LN9@SendBitStr
$LN9@SendBitStr:
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN8@SendBitStr
$LN8@SendBitStr:
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
?SendBitStream@ReliabilityLayer@@AAEXIUPlayerID@@PAVBitStream@RakNet@@@Z ENDP ; ReliabilityLayer::SendBitStream
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?GenerateDatagram@ReliabilityLayer@@AAEIPAVBitStream@RakNet@@HPA_N_JUPlayerID@@AAV?$List@PAVPluginInterface@@@DataStructures@@@Z
_TEXT	SEGMENT
tv620 = -368						; size = 8
tv603 = -364						; size = 4
tv572 = -364						; size = 4
tv496 = -364						; size = 4
tv482 = -364						; size = 4
tv433 = -364						; size = 4
tv347 = -364						; size = 4
tv200 = -364						; size = 4
$T1 = -356						; size = 4
$T2 = -344						; size = 4
$T3 = -332						; size = 4
_messagesSent$ = -128					; size = 4
_writeFalseToHeader$ = -113				; size = 1
_onlySendUnreliable$ = -101				; size = 1
_isReliable$ = -89					; size = 1
_messageHandlerIndex$ = -80				; size = 4
_i$ = -68						; size = 4
_nextPacketBitLength$ = -56				; size = 4
_reliableBits$ = -44					; size = 4
_maxDataBitSize$ = -32					; size = 4
_internalPacket$ = -20					; size = 4
_this$ = -8						; size = 4
_output$ = 8						; size = 4
_MTUSize$ = 12						; size = 4
_reliableDataSent$ = 16					; size = 4
_time$ = 20						; size = 8
_playerId$ = 28						; size = 6
_messageHandlerList$ = 36				; size = 4
?GenerateDatagram@ReliabilityLayer@@AAEIPAVBitStream@RakNet@@HPA_N_JUPlayerID@@AAV?$List@PAVPluginInterface@@@DataStructures@@@Z PROC ; ReliabilityLayer::GenerateDatagram, COMDAT
; _this$ = ecx

; 1241 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 368				; 00000170H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-368]
	mov	ecx, 92					; 0000005cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1242 : 	InternalPacket * internalPacket;
; 1243 : //	InternalPacket *temp;
; 1244 : 	int maxDataBitSize;
; 1245 : 	int reliableBits = 0;

	mov	DWORD PTR _reliableBits$[ebp], 0

; 1246 : 	int nextPacketBitLength;
; 1247 : 	unsigned i, messageHandlerIndex;
; 1248 : 	bool isReliable, onlySendUnreliable;
; 1249 : 	bool writeFalseToHeader;
; 1250 : 	unsigned messagesSent=0;

	mov	DWORD PTR _messagesSent$[ebp], 0

; 1251 : 
; 1252 : 	maxDataBitSize = MTUSize - UDP_HEADER_SIZE;

	mov	eax, DWORD PTR _MTUSize$[ebp]
	sub	eax, 28					; 0000001cH
	mov	DWORD PTR _maxDataBitSize$[ebp], eax

; 1253 : 
; 1254 : 	if ( encryptor.IsKeySet() )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1019				; 000003fbH
	call	?IsKeySet@TEABlockEncryptor@@QBE_NXZ	; TEABlockEncryptor::IsKeySet
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN37@GenerateDa

; 1255 : #ifdef TEA_ENCRYPTOR
; 1256 : 		maxDataBitSize -= 8; // Extra data for the encryptor

	mov	eax, DWORD PTR _maxDataBitSize$[ebp]
	sub	eax, 8
	mov	DWORD PTR _maxDataBitSize$[ebp], eax
$LN37@GenerateDa:

; 1257 : #else
; 1258 : 		maxDataBitSize -= 16; // Extra data for the encryptor
; 1259 : #endif
; 1260 : 
; 1261 : 	maxDataBitSize <<= 3;

	mov	eax, DWORD PTR _maxDataBitSize$[ebp]
	shl	eax, 3
	mov	DWORD PTR _maxDataBitSize$[ebp], eax

; 1262 : 
; 1263 : 	*reliableDataSent = false;

	mov	eax, DWORD PTR _reliableDataSent$[ebp]
	mov	BYTE PTR [eax], 0

; 1264 : 
; 1265 : 	if (time > nextAckTime)

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv433[ebp], eax
	mov	ecx, DWORD PTR tv433[ebp]
	mov	edx, DWORD PTR _time$[ebp+4]
	cmp	edx, DWORD PTR [ecx+44]
	jl	$LN36@GenerateDa
	jg	SHORT $LN43@GenerateDa
	mov	eax, DWORD PTR tv433[ebp]
	mov	ecx, DWORD PTR _time$[ebp]
	cmp	ecx, DWORD PTR [eax+40]
	jbe	$LN36@GenerateDa
$LN43@GenerateDa:

; 1266 : 	{
; 1267 : 		if (acknowlegements.Size()>0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?Size@?$RangeList@G@DataStructures@@QAEIXZ ; DataStructures::RangeList<unsigned short>::Size
	test	eax, eax
	jbe	$LN35@GenerateDa

; 1268 : 		{
; 1269 : 			output->Write(true);

	push	1
	mov	ecx, DWORD PTR _output$[ebp]
	call	??$Write@_N@BitStream@RakNet@@QAEX_N@Z	; RakNet::BitStream::Write<bool>

; 1270 : 			messagesSent++;

	mov	eax, DWORD PTR _messagesSent$[ebp]
	add	eax, 1
	mov	DWORD PTR _messagesSent$[ebp], eax

; 1271 : 			statistics.acknowlegementBitsSent +=acknowlegements.Serialize(output, (MTUSize-UDP_HEADER_SIZE)*8-1, true);

	push	1
	mov	eax, DWORD PTR _MTUSize$[ebp]
	lea	ecx, DWORD PTR [eax*8-225]
	push	ecx
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?Serialize@?$RangeList@G@DataStructures@@QAEIPAVBitStream@RakNet@@H_N@Z ; DataStructures::RangeList<unsigned short>::Serialize
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+807]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+807], eax

; 1272 : 			if (acknowlegements.Size()==0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?Size@?$RangeList@G@DataStructures@@QAEIXZ ; DataStructures::RangeList<unsigned short>::Size
	test	eax, eax
	jne	SHORT $LN34@GenerateDa

; 1273 : 				nextAckTime=time+(RakNetTimeNS)(ping*(RakNetTime)(PING_MULTIPLIER_TO_RESEND/4.0f));

	movss	xmm0, DWORD PTR _PING_MULTIPLIER_TO_RESEND
	divss	xmm0, DWORD PTR __real@40800000
	call	__ftoui3
	mov	ecx, DWORD PTR _this$[ebp]
	imul	eax, DWORD PTR [ecx+717]
	xor	edx, edx
	add	eax, DWORD PTR _time$[ebp]
	adc	edx, DWORD PTR _time$[ebp+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+40], eax
	mov	DWORD PTR [ecx+44], edx
$LN34@GenerateDa:

; 1274 : 			else
; 1275 : 			{
; 1276 : 			//	printf("Ack full\n");
; 1277 : 			}
; 1278 : 
; 1279 : 			writeFalseToHeader=false;

	mov	BYTE PTR _writeFalseToHeader$[ebp], 0

; 1280 : 		}
; 1281 : 		else

	jmp	SHORT $LN32@GenerateDa
$LN35@GenerateDa:

; 1282 : 		{
; 1283 : 			writeFalseToHeader=true;

	mov	BYTE PTR _writeFalseToHeader$[ebp], 1

; 1284 : 			nextAckTime=time+(RakNetTimeNS)(ping*(RakNetTime)(PING_MULTIPLIER_TO_RESEND/4.0f));

	movss	xmm0, DWORD PTR _PING_MULTIPLIER_TO_RESEND
	divss	xmm0, DWORD PTR __real@40800000
	call	__ftoui3
	mov	ecx, DWORD PTR _this$[ebp]
	imul	eax, DWORD PTR [ecx+717]
	xor	edx, edx
	add	eax, DWORD PTR _time$[ebp]
	adc	edx, DWORD PTR _time$[ebp+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+40], eax
	mov	DWORD PTR [ecx+44], edx
$LN32@GenerateDa:

; 1285 : 		}
; 1286 : 	}
; 1287 : 	else

	jmp	SHORT $LN31@GenerateDa
$LN36@GenerateDa:

; 1288 : 		writeFalseToHeader=true;

	mov	BYTE PTR _writeFalseToHeader$[ebp], 1
$LN31@GenerateDa:

; 1289 : 
; 1290 : 	while ( resendQueue.Size() > 0 )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	?Size@?$Queue@PAUInternalPacket@@@DataStructures@@QBEIXZ ; DataStructures::Queue<InternalPacket *>::Size
	test	eax, eax
	jbe	$LN29@GenerateDa

; 1291 : 	{
; 1292 : 		internalPacket = resendQueue.Peek();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	?Peek@?$Queue@PAUInternalPacket@@@DataStructures@@QBEPAUInternalPacket@@XZ ; DataStructures::Queue<InternalPacket *>::Peek
	mov	DWORD PTR _internalPacket$[ebp], eax

; 1293 : 		// The resend Queue can have holes.  This is so we can deallocate blocks without having to compress the array
; 1294 : 		if ( internalPacket->nextActionTime == 0 )

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	DWORD PTR tv482[ebp], eax
	mov	ecx, DWORD PTR tv482[ebp]
	mov	edx, DWORD PTR tv482[ebp]
	mov	eax, DWORD PTR [ecx+35]
	or	eax, DWORD PTR [edx+39]
	jne	SHORT $LN28@GenerateDa

; 1295 : 		{
; 1296 : 			resendQueue.Pop();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	?Pop@?$Queue@PAUInternalPacket@@@DataStructures@@QAEPAUInternalPacket@@XZ ; DataStructures::Queue<InternalPacket *>::Pop

; 1297 : 			delete [] internalPacket->data;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR [eax+47]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1298 : 			internalPacketPool.ReleasePointer( internalPacket );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	call	?ReleasePointer@InternalPacketPool@@QAEXPAUInternalPacket@@@Z ; InternalPacketPool::ReleasePointer

; 1299 : 			continue; // This was a hole

	jmp	SHORT $LN31@GenerateDa
$LN28@GenerateDa:

; 1300 : 		}
; 1301 : 
; 1302 : 		if ( resendQueue.Peek()->nextActionTime < time )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	?Peek@?$Queue@PAUInternalPacket@@@DataStructures@@QBEPAUInternalPacket@@XZ ; DataStructures::Queue<InternalPacket *>::Peek
	mov	DWORD PTR tv496[ebp], eax
	mov	eax, DWORD PTR tv496[ebp]
	mov	ecx, DWORD PTR [eax+39]
	cmp	ecx, DWORD PTR _time$[ebp+4]
	jg	$LN27@GenerateDa
	jl	SHORT $LN44@GenerateDa
	mov	edx, DWORD PTR tv496[ebp]
	mov	eax, DWORD PTR [edx+35]
	cmp	eax, DWORD PTR _time$[ebp]
	jae	$LN27@GenerateDa
$LN44@GenerateDa:

; 1303 : 		{
; 1304 : 			internalPacket = resendQueue.Pop();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	?Pop@?$Queue@PAUInternalPacket@@@DataStructures@@QAEPAUInternalPacket@@XZ ; DataStructures::Queue<InternalPacket *>::Pop
	mov	DWORD PTR _internalPacket$[ebp], eax

; 1305 : 
; 1306 : 			nextPacketBitLength = GetBitStreamHeaderLength( internalPacket ) + internalPacket->dataBitLength;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBitStreamHeaderLength@ReliabilityLayer@@AAEHQBUInternalPacket@@@Z ; ReliabilityLayer::GetBitStreamHeaderLength
	mov	ecx, DWORD PTR _internalPacket$[ebp]
	add	eax, DWORD PTR [ecx+43]
	mov	DWORD PTR _nextPacketBitLength$[ebp], eax

; 1307 : 
; 1308 : 			if ( output->GetNumberOfBitsUsed() + nextPacketBitLength > maxDataBitSize )

	mov	ecx, DWORD PTR _output$[ebp]
	call	?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBitsUsed
	add	eax, DWORD PTR _nextPacketBitLength$[ebp]
	cmp	eax, DWORD PTR _maxDataBitSize$[ebp]
	jle	SHORT $LN26@GenerateDa

; 1309 : 			{
; 1310 : 				resendQueue.PushAtHead( internalPacket ); // Not enough room to use this packet after all!

	push	0
	lea	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	?PushAtHead@?$Queue@PAUInternalPacket@@@DataStructures@@QAEXABQAUInternalPacket@@I@Z ; DataStructures::Queue<InternalPacket *>::PushAtHead

; 1311 : 
; 1312 : 				goto END_OF_GENERATE_FRAME;

	jmp	$LN25@GenerateDa
	jmp	$END_OF_GENERATE_FRAME$50
$LN26@GenerateDa:

; 1313 : 			}
; 1314 : 
; 1315 : 			RakAssert(internalPacket->priority >= 0);

	mov	eax, DWORD PTR _internalPacket$[ebp]
	cmp	DWORD PTR [eax+6], 0
	jge	SHORT $LN40@GenerateDa
	mov	ecx, DWORD PTR ?__LINE__Var@?1??GenerateDatagram@ReliabilityLayer@@AAEIPAVBitStream@RakNet@@HPA_N_JUPlayerID@@AAV?$List@PAVPluginInterface@@@DataStructures@@@Z@4JA
	add	ecx, 74					; 0000004aH
	push	ecx
	push	OFFSET ??_C@_1FK@FKLHGKMO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAe?$AAl?$AAi?$AAa?$AAb?$AAi?$AAl@
	push	OFFSET ??_C@_1DM@HJOKLFNH@?$AAi?$AAn?$AAt?$AAe?$AAr?$AAn?$AAa?$AAl?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?9?$AA?$DO?$AAp?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN40@GenerateDa:

; 1316 : 
; 1317 : #ifdef _DEBUG_LOGGER
; 1318 : 			{
; 1319 : 				char temp[256];
; 1320 : 				sprintf(temp, "%p: Resending packet %i data: %i bitlen: %i\n", this, internalPacket->messageNumber, (unsigned char) internalPacket->data[0], internalPacket->dataBitLength);
; 1321 : 				OutputDebugStr(temp);
; 1322 : 			}
; 1323 : #endif
; 1324 : 
; 1325 : 			for (messageHandlerIndex=0; messageHandlerIndex < messageHandlerList.Size(); messageHandlerIndex++)

	mov	DWORD PTR _messageHandlerIndex$[ebp], 0
	jmp	SHORT $LN24@GenerateDa
$LN23@GenerateDa:
	mov	eax, DWORD PTR _messageHandlerIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _messageHandlerIndex$[ebp], eax
$LN24@GenerateDa:
	mov	ecx, DWORD PTR _messageHandlerList$[ebp]
	call	?Size@?$List@PAVPluginInterface@@@DataStructures@@QBEIXZ ; DataStructures::List<PluginInterface *>::Size
	cmp	DWORD PTR _messageHandlerIndex$[ebp], eax
	jae	SHORT $LN22@GenerateDa

; 1326 : 				messageHandlerList[messageHandlerIndex]->OnInternalPacket(internalPacket, sendPacketCount, playerId, (RakNetTime)(time/(RakNetTimeNS)1000), true);

	mov	eax, DWORD PTR _messageHandlerIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _messageHandlerList$[ebp]
	call	??A?$List@PAVPluginInterface@@@DataStructures@@QBEAAPAVPluginInterface@@I@Z ; DataStructures::List<PluginInterface *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv200[ebp], ecx
	mov	esi, esp
	push	1
	push	0
	push	1000					; 000003e8H
	mov	edx, DWORD PTR _time$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _time$[ebp]
	push	eax
	call	__alldiv
	push	eax
	sub	esp, 8
	mov	ecx, esp
	mov	edx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	ax, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [ecx+4], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1629]
	push	edx
	mov	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv200[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv200[ebp]
	mov	eax, DWORD PTR [edx+36]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN23@GenerateDa
$LN22@GenerateDa:

; 1327 : 
; 1328 : 			// Write to the output bitstream
; 1329 : 			statistics.messageResends++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+815]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+815], ecx

; 1330 : 			statistics.messageDataBitsResent += internalPacket->dataBitLength;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+819]
	mov	edx, DWORD PTR _internalPacket$[ebp]
	add	ecx, DWORD PTR [edx+43]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+819], ecx

; 1331 : 
; 1332 : 			if (writeFalseToHeader)

	movzx	eax, BYTE PTR _writeFalseToHeader$[ebp]
	test	eax, eax
	je	SHORT $LN21@GenerateDa

; 1333 : 			{
; 1334 : 				output->Write(false);

	push	0
	mov	ecx, DWORD PTR _output$[ebp]
	call	??$Write@_N@BitStream@RakNet@@QAEX_N@Z	; RakNet::BitStream::Write<bool>

; 1335 : 				writeFalseToHeader=false;

	mov	BYTE PTR _writeFalseToHeader$[ebp], 0
$LN21@GenerateDa:

; 1336 : 			}
; 1337 : 			statistics.messagesTotalBitsResent += WriteToBitStreamFromInternalPacket( output, internalPacket );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteToBitStreamFromInternalPacket@ReliabilityLayer@@AAEHPAVBitStream@RakNet@@QBUInternalPacket@@@Z ; ReliabilityLayer::WriteToBitStreamFromInternalPacket
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx+823]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+823], eax

; 1338 : 			internalPacket->packetNumber=sendPacketCount;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1629]
	mov	DWORD PTR [eax+2], edx

; 1339 : 			messagesSent++;

	mov	eax, DWORD PTR _messagesSent$[ebp]
	add	eax, 1
	mov	DWORD PTR _messagesSent$[ebp], eax

; 1340 : 
; 1341 : 			*reliableDataSent = true;

	mov	eax, DWORD PTR _reliableDataSent$[ebp]
	mov	BYTE PTR [eax], 1

; 1342 : 
; 1343 : 			statistics.packetsContainingOnlyAcknowlegementsAndResends++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+811]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+811], ecx

; 1344 : 
; 1345 : 			internalPacket->nextActionTime = time + ackTimeIncrement;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _time$[ebp]
	add	ecx, DWORD PTR [eax+1637]
	mov	edx, DWORD PTR _time$[ebp+4]
	adc	edx, DWORD PTR [eax+1641]
	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	DWORD PTR [eax+35], ecx
	mov	DWORD PTR [eax+39], edx

; 1346 : 			if (time >= histogramStartTime && internalPacket->histogramMarker==histogramReceiveMarker)

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv572[ebp], eax
	mov	ecx, DWORD PTR tv572[ebp]
	mov	edx, DWORD PTR _time$[ebp+4]
	cmp	edx, DWORD PTR [ecx+966]
	jl	SHORT $LN20@GenerateDa
	jg	SHORT $LN45@GenerateDa
	mov	eax, DWORD PTR tv572[ebp]
	mov	ecx, DWORD PTR _time$[ebp]
	cmp	ecx, DWORD PTR [eax+962]
	jb	SHORT $LN20@GenerateDa
$LN45@GenerateDa:
	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+51]
	cmp	edx, DWORD PTR [ecx+970]
	jne	SHORT $LN20@GenerateDa

; 1347 : 				histogramPlossCount++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+978]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+978], ecx
$LN20@GenerateDa:

; 1348 : 
; 1349 : 			internalPacket->histogramMarker=histogramReceiveMarker;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+970]
	mov	DWORD PTR [eax+51], edx

; 1350 : 
; 1351 : 			//printf("PACKETLOSS\n ");
; 1352 : 
; 1353 : 			// Put the packet back into the resend list at the correct spot
; 1354 : 			// Don't make a copy since I'm reinserting an allocated struct
; 1355 : 			InsertPacketIntoResendList( internalPacket, time, false, false );

	push	0
	push	0
	mov	eax, DWORD PTR _time$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _time$[ebp]
	push	ecx
	mov	edx, DWORD PTR _internalPacket$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertPacketIntoResendList@ReliabilityLayer@@AAEXPAUInternalPacket@@_J_N2@Z ; ReliabilityLayer::InsertPacketIntoResendList

; 1356 : 
; 1357 : 		}
; 1358 : 		else

	jmp	SHORT $LN19@GenerateDa
$LN27@GenerateDa:

; 1359 : 		{
; 1360 : 			break;

	jmp	SHORT $LN29@GenerateDa
$LN19@GenerateDa:

; 1361 : 		}
; 1362 : 	}

	jmp	$LN31@GenerateDa
$LN29@GenerateDa:

; 1363 : 
; 1364 : 
; 1365 : 	onlySendUnreliable = false;

	mov	BYTE PTR _onlySendUnreliable$[ebp], 0

; 1366 : 
; 1367 : 
; 1368 : 	// From highest to lowest priority, fill up the output bitstream from the send lists
; 1369 : 	for ( i = 0; i < NUMBER_OF_PRIORITIES; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN18@GenerateDa
$LN17@GenerateDa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN18@GenerateDa:
	cmp	DWORD PTR _i$[ebp], 4
	jae	$LN16@GenerateDa
$LN42@GenerateDa:

; 1370 : 	{
; 1371 : 		while ( sendPacketSet[ i ].Size() )

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ecx+eax+100]
	call	?Size@?$Queue@PAUInternalPacket@@@DataStructures@@QBEIXZ ; DataStructures::Queue<InternalPacket *>::Size
	test	eax, eax
	je	$LN14@GenerateDa

; 1372 : 		{
; 1373 : 			internalPacket = sendPacketSet[ i ].Pop();

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ecx+eax+100]
	call	?Pop@?$Queue@PAUInternalPacket@@@DataStructures@@QAEPAUInternalPacket@@XZ ; DataStructures::Queue<InternalPacket *>::Pop
	mov	DWORD PTR _internalPacket$[ebp], eax

; 1374 : 
; 1375 : 			nextPacketBitLength = GetBitStreamHeaderLength( internalPacket ) + internalPacket->dataBitLength;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBitStreamHeaderLength@ReliabilityLayer@@AAEHQBUInternalPacket@@@Z ; ReliabilityLayer::GetBitStreamHeaderLength
	mov	ecx, DWORD PTR _internalPacket$[ebp]
	add	eax, DWORD PTR [ecx+43]
	mov	DWORD PTR _nextPacketBitLength$[ebp], eax

; 1376 : 
; 1377 : 			if (unreliableTimeout!=0 &&
; 1378 : 				(internalPacket->reliability==UNRELIABLE || internalPacket->reliability==UNRELIABLE_SEQUENCED) &&
; 1379 : 				time > internalPacket->creationTime+(RakNetTimeNS)unreliableTimeout)

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv603[ebp], eax
	mov	ecx, DWORD PTR tv603[ebp]
	mov	edx, DWORD PTR tv603[ebp]
	mov	eax, DWORD PTR [ecx+52]
	or	eax, DWORD PTR [edx+56]
	je	SHORT $LN13@GenerateDa
	mov	eax, DWORD PTR _internalPacket$[ebp]
	cmp	DWORD PTR [eax+10], 0
	je	SHORT $LN12@GenerateDa
	mov	eax, DWORD PTR _internalPacket$[ebp]
	cmp	DWORD PTR [eax+10], 1
	jne	SHORT $LN13@GenerateDa
$LN12@GenerateDa:
	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+27]
	add	edx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR [eax+31]
	adc	eax, DWORD PTR [ecx+56]
	mov	DWORD PTR tv620[ebp], edx
	mov	DWORD PTR tv620[ebp+4], eax
	mov	ecx, DWORD PTR _time$[ebp+4]
	cmp	ecx, DWORD PTR tv620[ebp+4]
	jl	SHORT $LN13@GenerateDa
	jg	SHORT $LN46@GenerateDa
	mov	edx, DWORD PTR _time$[ebp]
	cmp	edx, DWORD PTR tv620[ebp]
	jbe	SHORT $LN13@GenerateDa
$LN46@GenerateDa:

; 1380 : 			{
; 1381 : 				// Unreliable packets are deleted
; 1382 : 				delete [] internalPacket->data;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR [eax+47]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1383 : 				internalPacketPool.ReleasePointer( internalPacket );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	call	?ReleasePointer@InternalPacketPool@@QAEXPAUInternalPacket@@@Z ; InternalPacketPool::ReleasePointer

; 1384 : 				continue;

	jmp	$LN42@GenerateDa
$LN13@GenerateDa:

; 1385 : 			}
; 1386 : 
; 1387 : 
; 1388 : 			if ( output->GetNumberOfBitsUsed() + nextPacketBitLength > maxDataBitSize )

	mov	ecx, DWORD PTR _output$[ebp]
	call	?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBitsUsed
	add	eax, DWORD PTR _nextPacketBitLength$[ebp]
	cmp	eax, DWORD PTR _maxDataBitSize$[ebp]
	jle	SHORT $LN11@GenerateDa

; 1389 : 			{
; 1390 : 				// This output won't fit.
; 1391 : 				sendPacketSet[ i ].PushAtHead( internalPacket ); // Push this back at the head so it is the next thing to go out

	push	0
	lea	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+100]
	call	?PushAtHead@?$Queue@PAUInternalPacket@@@DataStructures@@QAEXABQAUInternalPacket@@I@Z ; DataStructures::Queue<InternalPacket *>::PushAtHead

; 1392 : 				break;

	jmp	$LN14@GenerateDa
$LN11@GenerateDa:

; 1393 : 			}
; 1394 : 
; 1395 : 			if ( internalPacket->reliability == RELIABLE || internalPacket->reliability == RELIABLE_SEQUENCED || internalPacket->reliability == RELIABLE_ORDERED )

	mov	eax, DWORD PTR _internalPacket$[ebp]
	cmp	DWORD PTR [eax+10], 2
	je	SHORT $LN9@GenerateDa
	mov	eax, DWORD PTR _internalPacket$[ebp]
	cmp	DWORD PTR [eax+10], 4
	je	SHORT $LN9@GenerateDa
	mov	eax, DWORD PTR _internalPacket$[ebp]
	cmp	DWORD PTR [eax+10], 3
	jne	SHORT $LN10@GenerateDa
$LN9@GenerateDa:

; 1396 : 				isReliable = true;

	mov	BYTE PTR _isReliable$[ebp], 1

; 1397 : 			else

	jmp	SHORT $LN8@GenerateDa
$LN10@GenerateDa:

; 1398 : 				isReliable = false;

	mov	BYTE PTR _isReliable$[ebp], 0
$LN8@GenerateDa:

; 1399 : 
; 1400 : 			// Write to the output bitstream
; 1401 : 			statistics.messagesSent[ i ] ++;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+747]
	add	edx, 1
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+747], edx

; 1402 : 			statistics.messageDataBitsSent[ i ] += internalPacket->dataBitLength;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+763]
	mov	eax, DWORD PTR _internalPacket$[ebp]
	add	edx, DWORD PTR [eax+43]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+ecx*4+763], edx

; 1403 : 
; 1404 : #ifdef _DEBUG_LOGGER
; 1405 : 			{
; 1406 : 				char temp[256];
; 1407 : 				sprintf(temp, "%p: Sending packet %i data: %i bitlen: %i\n", this, internalPacket->messageNumber, (unsigned char) internalPacket->data[0], internalPacket->dataBitLength);
; 1408 : 				OutputDebugStr(temp);
; 1409 : 			}
; 1410 : #endif
; 1411 : 
; 1412 : 			for (messageHandlerIndex=0; messageHandlerIndex < messageHandlerList.Size(); messageHandlerIndex++)

	mov	DWORD PTR _messageHandlerIndex$[ebp], 0
	jmp	SHORT $LN7@GenerateDa
$LN6@GenerateDa:
	mov	eax, DWORD PTR _messageHandlerIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _messageHandlerIndex$[ebp], eax
$LN7@GenerateDa:
	mov	ecx, DWORD PTR _messageHandlerList$[ebp]
	call	?Size@?$List@PAVPluginInterface@@@DataStructures@@QBEIXZ ; DataStructures::List<PluginInterface *>::Size
	cmp	DWORD PTR _messageHandlerIndex$[ebp], eax
	jae	SHORT $LN5@GenerateDa

; 1413 : 				messageHandlerList[messageHandlerIndex]->OnInternalPacket(internalPacket, sendPacketCount, playerId, (RakNetTime)(time/(RakNetTimeNS)1000), true);

	mov	eax, DWORD PTR _messageHandlerIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _messageHandlerList$[ebp]
	call	??A?$List@PAVPluginInterface@@@DataStructures@@QBEAAPAVPluginInterface@@I@Z ; DataStructures::List<PluginInterface *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv347[ebp], ecx
	mov	esi, esp
	push	1
	push	0
	push	1000					; 000003e8H
	mov	edx, DWORD PTR _time$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _time$[ebp]
	push	eax
	call	__alldiv
	push	eax
	sub	esp, 8
	mov	ecx, esp
	mov	edx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	ax, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [ecx+4], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1629]
	push	edx
	mov	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv347[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv347[ebp]
	mov	eax, DWORD PTR [edx+36]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN6@GenerateDa
$LN5@GenerateDa:

; 1414 : 
; 1415 : 			if (writeFalseToHeader)

	movzx	eax, BYTE PTR _writeFalseToHeader$[ebp]
	test	eax, eax
	je	SHORT $LN4@GenerateDa

; 1416 : 			{
; 1417 : 				output->Write(false);

	push	0
	mov	ecx, DWORD PTR _output$[ebp]
	call	??$Write@_N@BitStream@RakNet@@QAEX_N@Z	; RakNet::BitStream::Write<bool>

; 1418 : 				writeFalseToHeader=false;

	mov	BYTE PTR _writeFalseToHeader$[ebp], 0
$LN4@GenerateDa:

; 1419 : 			}
; 1420 : 			statistics.messageTotalBitsSent[ i ] += WriteToBitStreamFromInternalPacket( output, internalPacket );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteToBitStreamFromInternalPacket@ReliabilityLayer@@AAEHPAVBitStream@RakNet@@QBUInternalPacket@@@Z ; ReliabilityLayer::WriteToBitStreamFromInternalPacket
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+edx*4+779]
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx*4+779], eax

; 1421 : 			//output->PrintBits();
; 1422 : 			internalPacket->packetNumber=sendPacketCount;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1629]
	mov	DWORD PTR [eax+2], edx

; 1423 : 			messagesSent++;

	mov	eax, DWORD PTR _messagesSent$[ebp]
	add	eax, 1
	mov	DWORD PTR _messagesSent$[ebp], eax

; 1424 : 
; 1425 : 			if ( isReliable )

	movzx	eax, BYTE PTR _isReliable$[ebp]
	test	eax, eax
	je	SHORT $LN3@GenerateDa

; 1426 : 			{
; 1427 : 				// Reliable packets are saved to resend later
; 1428 : 				reliableBits += internalPacket->dataBitLength;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR _reliableBits$[ebp]
	add	ecx, DWORD PTR [eax+43]
	mov	DWORD PTR _reliableBits$[ebp], ecx

; 1429 : 				internalPacket->nextActionTime = time + ackTimeIncrement;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _time$[ebp]
	add	ecx, DWORD PTR [eax+1637]
	mov	edx, DWORD PTR _time$[ebp+4]
	adc	edx, DWORD PTR [eax+1641]
	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	DWORD PTR [eax+35], ecx
	mov	DWORD PTR [eax+39], edx

; 1430 : 				internalPacket->histogramMarker=histogramReceiveMarker;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+970]
	mov	DWORD PTR [eax+51], edx

; 1431 : 				resendList.Insert( internalPacket->messageNumber, internalPacket);

	lea	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _internalPacket$[ebp]
	movzx	edx, WORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	?Insert@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QAE_NGABQAUInternalPacket@@@Z ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::Insert

; 1432 : 				//printf("ackTimeIncrement=%i\n", ackTimeIncrement/1000);
; 1433 : 				InsertPacketIntoResendList( internalPacket, time, false, true);

	push	1
	push	0
	mov	eax, DWORD PTR _time$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _time$[ebp]
	push	ecx
	mov	edx, DWORD PTR _internalPacket$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertPacketIntoResendList@ReliabilityLayer@@AAEXPAUInternalPacket@@_J_N2@Z ; ReliabilityLayer::InsertPacketIntoResendList

; 1434 : 				*reliableDataSent = true;

	mov	eax, DWORD PTR _reliableDataSent$[ebp]
	mov	BYTE PTR [eax], 1

; 1435 : 			}
; 1436 : 			else

	jmp	SHORT $LN2@GenerateDa
$LN3@GenerateDa:

; 1437 : 			{
; 1438 : 				// Unreliable packets are deleted
; 1439 : 				delete [] internalPacket->data;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR [eax+47]
	mov	DWORD PTR $T3[ebp], ecx
	mov	edx, DWORD PTR $T3[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1440 : 				internalPacketPool.ReleasePointer( internalPacket );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	call	?ReleasePointer@InternalPacketPool@@QAEXPAUInternalPacket@@@Z ; InternalPacketPool::ReleasePointer
$LN2@GenerateDa:

; 1441 : 			}
; 1442 : 		}

	jmp	$LN42@GenerateDa
$LN14@GenerateDa:

; 1443 : 	}

	jmp	$LN17@GenerateDa
$LN16@GenerateDa:
$LN25@GenerateDa:
$END_OF_GENERATE_FRAME$50:

; 1444 : 
; 1445 : END_OF_GENERATE_FRAME:
; 1446 : 	;
; 1447 : 
; 1448 : 	// if (output->GetNumberOfBitsUsed()>0)
; 1449 : 	// {
; 1450 : 	// Update the throttle with the header
; 1451 : 	//  bytesSent+=output->GetNumberOfBytesUsed() + UDP_HEADER_SIZE;
; 1452 : 	//}
; 1453 : 
; 1454 : 	if (output->GetNumberOfBitsUsed()>0)

	mov	ecx, DWORD PTR _output$[ebp]
	call	?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBitsUsed
	test	eax, eax
	jle	SHORT $LN1@GenerateDa

; 1455 : 		sendPacketCount++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1629]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1629], ecx
$LN1@GenerateDa:

; 1456 : 
; 1457 : 	return messagesSent;

	mov	eax, DWORD PTR _messagesSent$[ebp]

; 1458 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN49@GenerateDa
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 368				; 00000170H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
	npad	1
$LN49@GenerateDa:
	DD	1
	DD	$LN48@GenerateDa
$LN48@GenerateDa:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN47@GenerateDa
$LN47@GenerateDa:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	0
?GenerateDatagram@ReliabilityLayer@@AAEIPAVBitStream@RakNet@@HPA_N_JUPlayerID@@AAV?$List@PAVPluginInterface@@@DataStructures@@@Z ENDP ; ReliabilityLayer::GenerateDatagram
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?SetUnreliableTimeout@ReliabilityLayer@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_timeoutMS$ = 8						; size = 4
?SetUnreliableTimeout@ReliabilityLayer@@QAEXI@Z PROC	; ReliabilityLayer::SetUnreliableTimeout, COMDAT
; _this$ = ecx

; 1498 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1499 : 	unreliableTimeout=(RakNetTimeNS)timeoutMS*(RakNetTimeNS)1000;

	mov	eax, DWORD PTR _timeoutMS$[ebp]
	mov	ecx, 1000				; 000003e8H
	mul	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+52], eax
	mov	DWORD PTR [ecx+56], edx

; 1500 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnreliableTimeout@ReliabilityLayer@@QAEXI@Z ENDP	; ReliabilityLayer::SetUnreliableTimeout
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?SetSplitMessageProgressInterval@ReliabilityLayer@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_interval$ = 8						; size = 4
?SetSplitMessageProgressInterval@ReliabilityLayer@@QAEXH@Z PROC ; ReliabilityLayer::SetSplitMessageProgressInterval, COMDAT
; _this$ = ecx

; 1493 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1494 : 	splitMessageProgressInterval=interval;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _interval$[ebp]
	mov	DWORD PTR [eax+48], ecx

; 1495 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSplitMessageProgressInterval@ReliabilityLayer@@QAEXH@Z ENDP ; ReliabilityLayer::SetSplitMessageProgressInterval
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?ApplyNetworkSimulator@ReliabilityLayer@@QAEXNII@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__maxSendBPS$ = 8					; size = 8
__minExtraPing$ = 16					; size = 4
__extraPingVariance$ = 20				; size = 4
?ApplyNetworkSimulator@ReliabilityLayer@@QAEXNII@Z PROC	; ReliabilityLayer::ApplyNetworkSimulator, COMDAT
; _this$ = ecx

; 1482 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1483 : #ifndef _RELEASE
; 1484 : 	maxSendBPS=_maxSendBPS;

	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR __maxSendBPS$[ebp]
	movsd	QWORD PTR [eax+1658], xmm0

; 1485 : 	minExtraPing=_minExtraPing;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __minExtraPing$[ebp]
	mov	DWORD PTR [eax+1666], ecx

; 1486 : 	extraPingVariance=_extraPingVariance;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __extraPingVariance$[ebp]
	mov	DWORD PTR [eax+1670], ecx

; 1487 : 	if (ping < (unsigned int)(minExtraPing+extraPingVariance)*2)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1666]
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+1670]
	shl	ecx, 1
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+717], ecx
	jae	SHORT $LN1@ApplyNetwo

; 1488 : 		ping=(minExtraPing+extraPingVariance)*2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1666]
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+1670]
	shl	ecx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+717], ecx
$LN1@ApplyNetwo:

; 1489 : #endif
; 1490 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?ApplyNetworkSimulator@ReliabilityLayer@@QAEXNII@Z ENDP	; ReliabilityLayer::ApplyNetworkSimulator
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?AreAcksWaiting@ReliabilityLayer@@QAE_NXZ
_TEXT	SEGMENT
tv68 = -208						; size = 4
_this$ = -8						; size = 4
?AreAcksWaiting@ReliabilityLayer@@QAE_NXZ PROC		; ReliabilityLayer::AreAcksWaiting, COMDAT
; _this$ = ecx

; 1476 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1477 : 	return acknowlegements.Size() > 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?Size@?$RangeList@G@DataStructures@@QAEIXZ ; DataStructures::RangeList<unsigned short>::Size
	test	eax, eax
	jbe	SHORT $LN3@AreAcksWai
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@AreAcksWai
$LN3@AreAcksWai:
	mov	DWORD PTR tv68[ebp], 0
$LN4@AreAcksWai:
	mov	al, BYTE PTR tv68[ebp]

; 1478 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?AreAcksWaiting@ReliabilityLayer@@QAE_NXZ ENDP		; ReliabilityLayer::AreAcksWaiting
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?IsDataWaiting@ReliabilityLayer@@QAE_NXZ
_TEXT	SEGMENT
tv93 = -220						; size = 4
_i$ = -20						; size = 4
_this$ = -8						; size = 4
?IsDataWaiting@ReliabilityLayer@@QAE_NXZ PROC		; ReliabilityLayer::IsDataWaiting, COMDAT
; _this$ = ecx

; 1464 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1465 : 	unsigned i;
; 1466 : 	for ( i = 0; i < NUMBER_OF_PRIORITIES; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@IsDataWait
$LN3@IsDataWait:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@IsDataWait:
	cmp	DWORD PTR _i$[ebp], 4
	jae	SHORT $LN2@IsDataWait

; 1467 : 	{
; 1468 : 		if (sendPacketSet[ i ].Size() > 0)

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ecx+eax+100]
	call	?Size@?$Queue@PAUInternalPacket@@@DataStructures@@QBEIXZ ; DataStructures::Queue<InternalPacket *>::Size
	test	eax, eax
	jbe	SHORT $LN1@IsDataWait

; 1469 : 			return true;

	mov	al, 1
	jmp	SHORT $LN5@IsDataWait
$LN1@IsDataWait:

; 1470 : 	}

	jmp	SHORT $LN3@IsDataWait
$LN2@IsDataWait:

; 1471 : 
; 1472 : 	return acknowlegements.Size() > 0 || resendList.IsEmpty()==false || outputQueue.Size() > 0 || orderingList.Size() > 0 || splitPacketChannelList.Size() > 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?Size@?$RangeList@G@DataStructures@@QAEIXZ ; DataStructures::RangeList<unsigned short>::Size
	test	eax, eax
	ja	SHORT $LN7@IsDataWait
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	?IsEmpty@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QBE_NXZ ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::IsEmpty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@IsDataWait
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?Size@?$Queue@PAUInternalPacket@@@DataStructures@@QBEIXZ ; DataStructures::Queue<InternalPacket *>::Size
	test	eax, eax
	ja	SHORT $LN7@IsDataWait
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::LinkedList<InternalPacket *> *>::Size
	test	eax, eax
	ja	SHORT $LN7@IsDataWait
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	?Size@?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::Size
	test	eax, eax
	ja	SHORT $LN7@IsDataWait
	mov	DWORD PTR tv93[ebp], 0
	jmp	SHORT $LN8@IsDataWait
$LN7@IsDataWait:
	mov	DWORD PTR tv93[ebp], 1
$LN8@IsDataWait:
	mov	al, BYTE PTR tv93[ebp]
$LN5@IsDataWait:

; 1473 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?IsDataWaiting@ReliabilityLayer@@QAE_NXZ ENDP		; ReliabilityLayer::IsDataWaiting
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?GetStatistics@ReliabilityLayer@@QAEQAURakNetStatisticsStruct@@XZ
_TEXT	SEGMENT
_i$ = -20						; size = 4
_this$ = -8						; size = 4
?GetStatistics@ReliabilityLayer@@QAEQAURakNetStatisticsStruct@@XZ PROC ; ReliabilityLayer::GetStatistics, COMDAT
; _this$ = ecx

; 2484 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2485 : 	unsigned i;
; 2486 : 
; 2487 : 	for ( i = 0; i < NUMBER_OF_PRIORITIES; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@GetStatist
$LN5@GetStatist:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@GetStatist:
	cmp	DWORD PTR _i$[ebp], 4
	jae	SHORT $LN4@GetStatist

; 2488 : 	{
; 2489 : 		statistics.messageSendBuffer[i] = sendPacketSet[i].Size();

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ecx+eax+100]
	call	?Size@?$Queue@PAUInternalPacket@@@DataStructures@@QBEIXZ ; DataStructures::Queue<InternalPacket *>::Size
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx*4+731], eax

; 2490 : 	//	statistics.messageSendBuffer[i] = sendPacketSet[i].Size();
; 2491 : 	}

	jmp	SHORT $LN5@GetStatist
$LN4@GetStatist:

; 2492 : 
; 2493 : 	statistics.acknowlegementsPending = acknowlegements.Size();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?Size@?$RangeList@G@DataStructures@@QAEIXZ ; DataStructures::RangeList<unsigned short>::Size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+803], eax

; 2494 : 	statistics.messagesWaitingForReassembly = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+907], 0

; 2495 : 	for (i=0; i < splitPacketChannelList.Size(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@GetStatist
$LN2@GetStatist:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@GetStatist:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	?Size@?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN1@GetStatist

; 2496 : 		statistics.messagesWaitingForReassembly+=splitPacketChannelList[i]->splitPacketList.Size();

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??A?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QBEAAPAUSplitPacketChannel@@I@Z ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	call	?Size@?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::Size
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+907]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+907], eax
	jmp	SHORT $LN2@GetStatist
$LN1@GetStatist:

; 2497 : 	statistics.internalOutputQueueSize = outputQueue.Size();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?Size@?$Queue@PAUInternalPacket@@@DataStructures@@QBEIXZ ; DataStructures::Queue<InternalPacket *>::Size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+911], eax

; 2498 : 	statistics.bitsPerSecond = currentBandwidth;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [ecx+1002]
	movsd	QWORD PTR [eax+915], xmm0

; 2499 : 	//statistics.lossySize = lossyWindowSize == MAXIMUM_WINDOW_SIZE + 1 ? 0 : lossyWindowSize;
; 2500 : //	statistics.lossySize=0;
; 2501 : 	statistics.messagesOnResendQueue = GetResendListDataSize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetResendListDataSize@ReliabilityLayer@@ABEIXZ ; ReliabilityLayer::GetResendListDataSize
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+827], eax

; 2502 : 
; 2503 : 	return &statistics;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 731				; 000002dbH

; 2504 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetStatistics@ReliabilityLayer@@QAEQAURakNetStatisticsStruct@@XZ ENDP ; ReliabilityLayer::GetStatistics
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?SetPing@ReliabilityLayer@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = 8							; size = 4
?SetPing@ReliabilityLayer@@QAEXI@Z PROC			; ReliabilityLayer::SetPing, COMDAT
; _this$ = ecx

; 2454 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2455 : 	//assert(i < (RakNetTimeNS)timeoutTime*1000);
; 2456 : 	if (i > timeoutTime)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+723]
	jbe	SHORT $LN4@SetPing

; 2457 : 		ping=500;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+717], 500		; 000001f4H

; 2458 : 	else

	jmp	SHORT $LN3@SetPing
$LN4@SetPing:

; 2459 : 		ping = i;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+717], ecx
$LN3@SetPing:

; 2460 : 	if (ping < 30)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+717], 30			; 0000001eH
	jae	SHORT $LN2@SetPing

; 2461 : 		ping=30; // Leave a buffer for variations in ping

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+717], 30			; 0000001eH
$LN2@SetPing:

; 2462 : #ifndef _RELEASE
; 2463 : 	if (ping < (RakNetTime)(minExtraPing+extraPingVariance)*2)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1666]
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+1670]
	shl	ecx, 1
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+717], ecx
	jae	SHORT $LN1@SetPing

; 2464 : 		ping=(minExtraPing+extraPingVariance)*2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1666]
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+1670]
	shl	ecx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+717], ecx
$LN1@SetPing:

; 2465 : #endif
; 2466 : 
; 2467 : 	UpdateNextActionTime();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateNextActionTime@ReliabilityLayer@@AAEXXZ ; ReliabilityLayer::UpdateNextActionTime

; 2468 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetPing@ReliabilityLayer@@QAEXI@Z ENDP			; ReliabilityLayer::SetPing
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?KillConnection@ReliabilityLayer@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?KillConnection@ReliabilityLayer@@QAEXXZ PROC		; ReliabilityLayer::KillConnection, COMDAT
; _this$ = ecx

; 2446 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2447 : 	deadConnection=true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+715], 1

; 2448 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?KillConnection@ReliabilityLayer@@QAEXXZ ENDP		; ReliabilityLayer::KillConnection
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?IsDeadConnection@ReliabilityLayer@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?IsDeadConnection@ReliabilityLayer@@QBE_NXZ PROC	; ReliabilityLayer::IsDeadConnection, COMDAT
; _this$ = ecx

; 2438 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2439 : 	return deadConnection;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+715]

; 2440 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsDeadConnection@ReliabilityLayer@@QBE_NXZ ENDP	; ReliabilityLayer::IsDeadConnection
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?IsCheater@ReliabilityLayer@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?IsCheater@ReliabilityLayer@@QBE_NXZ PROC		; ReliabilityLayer::IsCheater, COMDAT
; _this$ = ecx

; 2430 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2431 : 	return cheater;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+716]

; 2432 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsCheater@ReliabilityLayer@@QBE_NXZ ENDP		; ReliabilityLayer::IsCheater
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?Update@ReliabilityLayer@@QAEXIUPlayerID@@H_JAAV?$List@PAVPluginInterface@@@DataStructures@@@Z
_TEXT	SEGMENT
tv645 = -372						; size = 8
tv641 = -364						; size = 4
tv635 = -360						; size = 8
tv631 = -352						; size = 4
tv487 = -352						; size = 8
tv625 = -348						; size = 8
tv484 = -344						; size = 8
tv769 = -340						; size = 4
tv621 = -340						; size = 4
tv611 = -340						; size = 4
tv461 = -340						; size = 4
tv453 = -340						; size = 4
tv414 = -340						; size = 4
tv346 = -340						; size = 4
tv282 = -340						; size = 4
tv229 = -340						; size = 4
tv209 = -340						; size = 4
$T1 = -332						; size = 4
$T2 = -320						; size = 4
_i$ = -116						; size = 4
_delta$3 = -104						; size = 8
_packetloss$4 = -88					; size = 4
_lastContinuousSend$ = -73				; size = 1
_dt$5 = -64						; size = 4
_requiredBuffer$ = -52					; size = 8
_reliableDataSent$ = -33				; size = 1
_elapsedTime$ = -24					; size = 8
_this$ = -8						; size = 4
_s$ = 8							; size = 4
_playerId$ = 12						; size = 6
_MTUSize$ = 20						; size = 4
_time$ = 24						; size = 8
_messageHandlerList$ = 32				; size = 4
?Update@ReliabilityLayer@@QAEXIUPlayerID@@H_JAAV?$List@PAVPluginInterface@@@DataStructures@@@Z PROC ; ReliabilityLayer::Update, COMDAT
; _this$ = ecx

; 961  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 372				; 00000174H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-372]
	mov	ecx, 93					; 0000005dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 962  : #ifdef __USE_IO_COMPLETION_PORTS
; 963  : 
; 964  : 	if ( readWriteSocket == INVALID_SOCKET )
; 965  : 		return;
; 966  : 
; 967  : 	if (deadConnection)
; 968  : 		return;
; 969  : #endif
; 970  : 
; 971  : 	// This line is necessary because the timer isn't accurate
; 972  : 	if (time <= lastUpdateTime)

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv414[ebp], eax
	mov	ecx, DWORD PTR tv414[ebp]
	mov	edx, DWORD PTR _time$[ebp+4]
	cmp	edx, DWORD PTR [ecx+950]
	jg	SHORT $LN45@Update
	jl	SHORT $LN50@Update
	mov	eax, DWORD PTR tv414[ebp]
	mov	ecx, DWORD PTR _time$[ebp]
	cmp	ecx, DWORD PTR [eax+946]
	ja	SHORT $LN45@Update
$LN50@Update:

; 973  : 	{
; 974  : 		// Always set the last time in case of overflow
; 975  : 		lastUpdateTime=time;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _time$[ebp]
	mov	DWORD PTR [eax+946], ecx
	mov	edx, DWORD PTR _time$[ebp+4]
	mov	DWORD PTR [eax+950], edx

; 976  : 		return;

	jmp	$LN46@Update
$LN45@Update:

; 977  : 	}
; 978  : 
; 979  : 	RakNetTimeNS elapsedTime = time - lastUpdateTime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _time$[ebp]
	sub	ecx, DWORD PTR [eax+946]
	mov	edx, DWORD PTR _time$[ebp+4]
	sbb	edx, DWORD PTR [eax+950]
	mov	DWORD PTR _elapsedTime$[ebp], ecx
	mov	DWORD PTR _elapsedTime$[ebp+4], edx

; 980  : 	availableBandwidth+=currentBandwidth * ((double)elapsedTime/1000000.0f);

	mov	edx, DWORD PTR _elapsedTime$[ebp+4]
	mov	ecx, DWORD PTR _elapsedTime$[ebp]
	call	__ltod3
	divsd	xmm0, QWORD PTR __real@412e848000000000
	mov	eax, DWORD PTR _this$[ebp]
	mulsd	xmm0, QWORD PTR [eax+1002]
	mov	ecx, DWORD PTR _this$[ebp]
	addsd	xmm0, QWORD PTR [ecx+1010]
	mov	edx, DWORD PTR _this$[ebp]
	movsd	QWORD PTR [edx+1010], xmm0

; 981  : 	if (availableBandwidth > currentBandwidth)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [eax+1010]
	comisd	xmm0, QWORD PTR [ecx+1002]
	jbe	SHORT $LN44@Update

; 982  : 		availableBandwidth = currentBandwidth;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [ecx+1002]
	movsd	QWORD PTR [eax+1010], xmm0
$LN44@Update:

; 983  : 	lastUpdateTime=time;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _time$[ebp]
	mov	DWORD PTR [eax+946], ecx
	mov	edx, DWORD PTR _time$[ebp+4]
	mov	DWORD PTR [eax+950], edx

; 984  : 
; 985  : 	// unsigned resendListSize;
; 986  : 	bool reliableDataSent;
; 987  : 	UpdateThreadedMemory();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateThreadedMemory@ReliabilityLayer@@AAEXXZ ; ReliabilityLayer::UpdateThreadedMemory

; 988  : 
; 989  : 	// Due to thread vagarities and the way I store the time to avoid slow calls to RakNet::GetTime
; 990  : 	// time may be less than lastAck
; 991  : 	if ( resendList.IsEmpty()==false && time > lastAckTime && lastAckTime && time - lastAckTime > (RakNetTimeNS)timeoutTime*1000 )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	?IsEmpty@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QBE_NXZ ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::IsEmpty
	movzx	eax, al
	test	eax, eax
	jne	$LN43@Update
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv453[ebp], eax
	mov	ecx, DWORD PTR tv453[ebp]
	mov	edx, DWORD PTR _time$[ebp+4]
	cmp	edx, DWORD PTR [ecx+182]
	jl	$LN43@Update
	jg	SHORT $LN51@Update
	mov	eax, DWORD PTR tv453[ebp]
	mov	ecx, DWORD PTR _time$[ebp]
	cmp	ecx, DWORD PTR [eax+178]
	jbe	$LN43@Update
$LN51@Update:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv461[ebp], eax
	mov	ecx, DWORD PTR tv461[ebp]
	mov	edx, DWORD PTR tv461[ebp]
	mov	eax, DWORD PTR [ecx+178]
	or	eax, DWORD PTR [edx+182]
	je	SHORT $LN43@Update
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _time$[ebp]
	sub	ecx, DWORD PTR [eax+178]
	mov	esi, DWORD PTR _time$[ebp+4]
	sbb	esi, DWORD PTR [eax+182]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+723]
	mov	edx, 1000				; 000003e8H
	mul	edx
	mov	DWORD PTR tv484[ebp], ecx
	mov	DWORD PTR tv484[ebp+4], esi
	mov	DWORD PTR tv487[ebp], eax
	mov	DWORD PTR tv487[ebp+4], edx
	mov	eax, DWORD PTR tv484[ebp+4]
	cmp	eax, DWORD PTR tv487[ebp+4]
	jl	SHORT $LN43@Update
	jg	SHORT $LN52@Update
	mov	ecx, DWORD PTR tv484[ebp]
	cmp	ecx, DWORD PTR tv487[ebp]
	jbe	SHORT $LN43@Update
$LN52@Update:

; 992  : 	{
; 993  : 		// SHOW - dead connection
; 994  : 		// printf("The connection has been lost.\n");
; 995  : 		// We've waited a very long time for a reliable packet to get an ack and it never has
; 996  : 		deadConnection = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+715], 1

; 997  : 		return;

	jmp	$LN46@Update
$LN43@Update:

; 998  : 	}
; 999  : 
; 1000 : 	// Water canister has to have enough room to put more water in :)
; 1001 : 	double requiredBuffer=(float)((MTUSize+UDP_HEADER_SIZE)*8);

	mov	eax, DWORD PTR _MTUSize$[ebp]
	lea	ecx, DWORD PTR [eax*8+224]
	cvtsi2ss xmm0, ecx
	cvtss2sd xmm0, xmm0
	movsd	QWORD PTR _requiredBuffer$[ebp], xmm0

; 1002 : 	if (requiredBuffer > currentBandwidth)

	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR _requiredBuffer$[ebp]
	comisd	xmm0, QWORD PTR [eax+1002]
	jbe	SHORT $LN42@Update

; 1003 : 		requiredBuffer=currentBandwidth;

	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [eax+1002]
	movsd	QWORD PTR _requiredBuffer$[ebp], xmm0
$LN42@Update:

; 1004 : 
; 1005 : 	while ( availableBandwidth > requiredBuffer )

	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [eax+1010]
	comisd	xmm0, QWORD PTR _requiredBuffer$[ebp]
	jbe	$LN40@Update

; 1006 : 	{
; 1007 : 		updateBitStream.Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 186				; 000000baH
	call	?Reset@BitStream@RakNet@@QAEXXZ		; RakNet::BitStream::Reset

; 1008 : 		GenerateDatagram( &updateBitStream, MTUSize, &reliableDataSent, time, playerId, messageHandlerList );

	mov	eax, DWORD PTR _messageHandlerList$[ebp]
	push	eax
	sub	esp, 8
	mov	ecx, esp
	mov	edx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	ax, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [ecx+4], ax
	mov	ecx, DWORD PTR _time$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _time$[ebp]
	push	edx
	lea	eax, DWORD PTR _reliableDataSent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _MTUSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 186				; 000000baH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GenerateDatagram@ReliabilityLayer@@AAEIPAVBitStream@RakNet@@HPA_N_JUPlayerID@@AAV?$List@PAVPluginInterface@@@DataStructures@@@Z ; ReliabilityLayer::GenerateDatagram

; 1009 : 		if ( updateBitStream.GetNumberOfBitsUsed() > 0 )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 186				; 000000baH
	call	?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBitsUsed
	test	eax, eax
	jle	$LN39@Update

; 1010 : 		{
; 1011 : #ifndef _RELEASE
; 1012 : 			if (minExtraPing > 0 || extraPingVariance > 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1666], 0
	ja	SHORT $LN37@Update
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1670], 0
	jbe	$LN38@Update
$LN37@Update:

; 1013 : 			{
; 1014 : 				// Delay the send to simulate lag
; 1015 : 				DataAndTime *dt;
; 1016 : 				dt = new DataAndTime;

	push	588					; 0000024cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _dt$5[ebp], eax

; 1017 : 				memcpy( dt->data, updateBitStream.GetData(), updateBitStream.GetNumberOfBytesUsed() );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 186				; 000000baH
	call	?GetNumberOfBytesUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBytesUsed
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 186				; 000000baH
	call	?GetData@BitStream@RakNet@@QBEPAEXZ	; RakNet::BitStream::GetData
	push	eax
	mov	eax, DWORD PTR _dt$5[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1018 : 				dt->length = updateBitStream.GetNumberOfBytesUsed();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 186				; 000000baH
	call	?GetNumberOfBytesUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBytesUsed
	mov	ecx, DWORD PTR _dt$5[ebp]
	mov	DWORD PTR [ecx+576], eax

; 1019 : 				dt->sendTime = time + (RakNetTimeNS)minExtraPing*1000;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1666]
	mov	ecx, 1000				; 000003e8H
	mul	ecx
	add	eax, DWORD PTR _time$[ebp]
	adc	edx, DWORD PTR _time$[ebp+4]
	mov	ecx, DWORD PTR _dt$5[ebp]
	mov	DWORD PTR [ecx+580], eax
	mov	DWORD PTR [ecx+584], edx

; 1020 : 				if (extraPingVariance > 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1670], 0
	jbe	SHORT $LN36@Update

; 1021 : 					dt->sendTime += ( randomMT() % (int)extraPingVariance );

	call	?randomMT@@YAIXZ			; randomMT
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+1670]
	xor	eax, eax
	mov	ecx, DWORD PTR _dt$5[ebp]
	add	edx, DWORD PTR [ecx+580]
	adc	eax, DWORD PTR [ecx+584]
	mov	ecx, DWORD PTR _dt$5[ebp]
	mov	DWORD PTR [ecx+580], edx
	mov	DWORD PTR [ecx+584], eax
$LN36@Update:

; 1022 : 				delayList.Insert( dt );

	mov	eax, DWORD PTR _dt$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1646				; 0000066eH
	call	?Insert@?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QAEXQAUDataAndTime@ReliabilityLayer@@@Z ; DataStructures::List<ReliabilityLayer::DataAndTime *>::Insert

; 1023 : 			}
; 1024 : 			else

	jmp	SHORT $LN35@Update
$LN38@Update:

; 1025 : #endif
; 1026 : 			SendBitStream( s, playerId, &updateBitStream );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 186				; 000000baH
	push	eax
	sub	esp, 8
	mov	ecx, esp
	mov	edx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	ax, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [ecx+4], ax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendBitStream@ReliabilityLayer@@AAEXIUPlayerID@@PAVBitStream@RakNet@@@Z ; ReliabilityLayer::SendBitStream
$LN35@Update:

; 1027 : 
; 1028 : 			availableBandwidth-=updateBitStream.GetNumberOfBitsUsed()+UDP_HEADER_SIZE*8;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 186				; 000000baH
	call	?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBitsUsed
	add	eax, 224				; 000000e0H
	cvtsi2sd xmm0, eax
	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm1, QWORD PTR [eax+1010]
	subsd	xmm1, xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movsd	QWORD PTR [ecx+1010], xmm1

; 1029 : 		}
; 1030 : 		else

	jmp	SHORT $LN34@Update
$LN39@Update:

; 1031 : 			break;

	jmp	SHORT $LN40@Update
$LN34@Update:

; 1032 : 	}

	jmp	$LN42@Update
$LN40@Update:

; 1033 : 
; 1034 : 	bool lastContinuousSend=continuousSend;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+1018]
	mov	BYTE PTR _lastContinuousSend$[ebp], cl

; 1035 : 	continuousSend=availableBandwidth < requiredBuffer;

	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR _requiredBuffer$[ebp]
	comisd	xmm0, QWORD PTR [eax+1010]
	jbe	SHORT $LN48@Update
	mov	DWORD PTR tv209[ebp], 1
	jmp	SHORT $LN49@Update
$LN48@Update:
	mov	DWORD PTR tv209[ebp], 0
$LN49@Update:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR tv209[ebp]
	mov	BYTE PTR [ecx+1018], dl

; 1036 : 
; 1037 : 	if (continuousSend==true && lastContinuousSend==false)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1018]
	cmp	ecx, 1
	jne	$LN32@Update
	movzx	eax, BYTE PTR _lastContinuousSend$[ebp]
	test	eax, eax
	jne	$LN32@Update

; 1038 : 	{
; 1039 : 		histogramAckCount=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+982], 0

; 1040 : 		histogramPlossCount=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+978], 0

; 1041 : 		histogramStartTime=time+ping*2*1000;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+717]
	shl	ecx, 1
	imul	edx, ecx, 1000
	xor	eax, eax
	add	edx, DWORD PTR _time$[ebp]
	adc	eax, DWORD PTR _time$[ebp+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+962], edx
	mov	DWORD PTR [ecx+966], eax

; 1042 : 		histogramEndTime=histogramStartTime+MAX_TIME_TO_SAMPLE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+962]
	add	ecx, 250000				; 0003d090H
	mov	edx, DWORD PTR [eax+966]
	adc	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+954], ecx
	mov	DWORD PTR [eax+958], edx

; 1043 : 		if (++histogramReceiveMarker==(unsigned)-1)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+970]
	add	ecx, 1
	mov	DWORD PTR tv229[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv229[ebp]
	mov	DWORD PTR [edx+970], eax
	cmp	DWORD PTR tv229[ebp], -1
	jne	SHORT $LN32@Update

; 1044 : 			histogramReceiveMarker=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+970], 0
$LN32@Update:

; 1045 : 	}
; 1046 : 
; 1047 : 	if (time >= histogramEndTime )

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv611[ebp], eax
	mov	ecx, DWORD PTR tv611[ebp]
	mov	edx, DWORD PTR _time$[ebp+4]
	cmp	edx, DWORD PTR [ecx+958]
	jl	$LN6@Update
	jg	SHORT $LN53@Update
	mov	eax, DWORD PTR tv611[ebp]
	mov	ecx, DWORD PTR _time$[ebp]
	cmp	ecx, DWORD PTR [eax+954]
	jb	$LN6@Update
$LN53@Update:

; 1048 : 	{
; 1049 : 		float packetloss;
; 1050 : 
; 1051 : 		double delta;
; 1052 : 		if (histogramAckCount+histogramPlossCount)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+982]
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+978]
	je	$LN30@Update

; 1053 : 			packetloss=(float)histogramPlossCount / ((float)histogramAckCount+(float)histogramPlossCount);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+978]
	mov	DWORD PTR tv621[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv621[ebp]
	mov	edx, DWORD PTR tv621[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv625[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv625[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+982]
	mov	DWORD PTR tv631[ebp], ecx
	cvtsi2sd xmm1, DWORD PTR tv631[ebp]
	mov	edx, DWORD PTR tv631[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv635[ebp], xmm1
	cvtsd2ss xmm1, QWORD PTR tv635[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+978]
	mov	DWORD PTR tv641[ebp], ecx
	cvtsi2sd xmm2, DWORD PTR tv641[ebp]
	mov	edx, DWORD PTR tv641[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm2, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv645[ebp], xmm2
	cvtsd2ss xmm2, QWORD PTR tv645[ebp]
	addss	xmm1, xmm2
	divss	xmm0, xmm1
	movss	DWORD PTR _packetloss$4[ebp], xmm0

; 1054 : 		else

	jmp	SHORT $LN29@Update
$LN30@Update:

; 1055 : 			packetloss=0.0f; // This line can be true if we are sending only acks

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _packetloss$4[ebp], xmm0
$LN29@Update:

; 1056 : 
; 1057 : 		if (continuousSend==false)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1018]
	test	ecx, ecx
	jne	$LN28@Update

; 1058 : 		{
; 1059 : 			if (packetloss > PACKETLOSS_TOLERANCE)

	movss	xmm0, DWORD PTR _packetloss$4[ebp]
	comiss	xmm0, DWORD PTR _PACKETLOSS_TOLERANCE
	jbe	$LN27@Update

; 1060 : 			{
; 1061 : 				highBandwidth=currentBandwidth;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [ecx+1002]
	movsd	QWORD PTR [eax+994], xmm0

; 1062 : 				if (packetloss > .2)

	cvtss2sd xmm0, DWORD PTR _packetloss$4[ebp]
	comisd	xmm0, QWORD PTR __real@3fc999999999999a
	jbe	SHORT $LN26@Update

; 1063 : 				{
; 1064 : 					lowBandwidth/=2;

	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [eax+986]
	divsd	xmm0, QWORD PTR __real@4000000000000000
	mov	ecx, DWORD PTR _this$[ebp]
	movsd	QWORD PTR [ecx+986], xmm0

; 1065 : 				}
; 1066 : 				else

	jmp	SHORT $LN25@Update
$LN26@Update:

; 1067 : 				{
; 1068 : 					lowBandwidth*=.9;

	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [eax+986]
	mulsd	xmm0, QWORD PTR __real@3feccccccccccccd
	mov	ecx, DWORD PTR _this$[ebp]
	movsd	QWORD PTR [ecx+986], xmm0
$LN25@Update:

; 1069 : 				}
; 1070 : 
; 1071 : 				if (lowBandwidth < MINIMUM_SEND_BPS)

	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR _MINIMUM_SEND_BPS
	comisd	xmm0, QWORD PTR [eax+986]
	jbe	SHORT $LN24@Update

; 1072 : 					lowBandwidth=MINIMUM_SEND_BPS;

	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR _MINIMUM_SEND_BPS
	movsd	QWORD PTR [eax+986], xmm0
$LN24@Update:

; 1073 : 
; 1074 : 				delta = (highBandwidth-lowBandwidth)/2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [eax+994]
	subsd	xmm0, QWORD PTR [ecx+986]
	divsd	xmm0, QWORD PTR __real@4000000000000000
	movsd	QWORD PTR _delta$3[ebp], xmm0

; 1075 : 				currentBandwidth=delta+lowBandwidth;

	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR _delta$3[ebp]
	addsd	xmm0, QWORD PTR [eax+986]
	mov	ecx, DWORD PTR _this$[ebp]
	movsd	QWORD PTR [ecx+1002], xmm0

; 1076 : 				noPacketlossIncreaseCount=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+974], 0
$LN27@Update:

; 1077 : 			}
; 1078 : 		}
; 1079 : 		else

	jmp	$LN7@Update
$LN28@Update:

; 1080 : 		{
; 1081 : 			if (packetloss <= PACKETLOSS_TOLERANCE)

	movss	xmm0, DWORD PTR _PACKETLOSS_TOLERANCE
	comiss	xmm0, DWORD PTR _packetloss$4[ebp]
	jb	SHORT $LN22@Update

; 1082 : 				lowBandwidth=currentBandwidth;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [ecx+1002]
	movsd	QWORD PTR [eax+986], xmm0

; 1083 : 			else

	jmp	SHORT $LN21@Update
$LN22@Update:

; 1084 : 				highBandwidth=currentBandwidth;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [ecx+1002]
	movsd	QWORD PTR [eax+994], xmm0
$LN21@Update:

; 1085 : 
; 1086 : 			if (packetloss==0.0)

	cvtss2sd xmm0, DWORD PTR _packetloss$4[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN20@Update

; 1087 : 			{
; 1088 : 				// If no packetloss for many increases in a row, drop the high range and go into search mode.
; 1089 : 				if (++noPacketlossIncreaseCount==10)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+974]
	add	ecx, 1
	mov	DWORD PTR tv282[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv282[ebp]
	mov	DWORD PTR [edx+974], eax
	cmp	DWORD PTR tv282[ebp], 10		; 0000000aH
	jne	SHORT $LN19@Update

; 1090 : 				{
; 1091 : 					noPacketlossIncreaseCount=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+974], 0

; 1092 : 					highBandwidth=0;

	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR [eax+994], xmm0
$LN19@Update:

; 1093 : 				}
; 1094 : 			}
; 1095 : 			else

	jmp	SHORT $LN18@Update
$LN20@Update:

; 1096 : 				noPacketlossIncreaseCount=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+974], 0
$LN18@Update:

; 1097 : 			if (highBandwidth!=0.0)

	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [eax+994]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN17@Update

; 1098 : 			{
; 1099 : 				// If a lot of packetloss at any time, decrease the low range by half
; 1100 : 				if (packetloss > .2)

	cvtss2sd xmm0, DWORD PTR _packetloss$4[ebp]
	comisd	xmm0, QWORD PTR __real@3fc999999999999a
	jbe	SHORT $LN15@Update

; 1101 : 				{
; 1102 : 					lowBandwidth/=2;

	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [eax+986]
	divsd	xmm0, QWORD PTR __real@4000000000000000
	mov	ecx, DWORD PTR _this$[ebp]
	movsd	QWORD PTR [ecx+986], xmm0

; 1103 : 					if (lowBandwidth < MINIMUM_SEND_BPS)

	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR _MINIMUM_SEND_BPS
	comisd	xmm0, QWORD PTR [eax+986]
	jbe	SHORT $LN15@Update

; 1104 : 						lowBandwidth=MINIMUM_SEND_BPS;

	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR _MINIMUM_SEND_BPS
	movsd	QWORD PTR [eax+986], xmm0
$LN15@Update:

; 1105 : 				}
; 1106 : 
; 1107 : 				delta = (highBandwidth-lowBandwidth)/2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [eax+994]
	subsd	xmm0, QWORD PTR [ecx+986]
	divsd	xmm0, QWORD PTR __real@4000000000000000
	movsd	QWORD PTR _delta$3[ebp], xmm0

; 1108 : 				if (delta < MINIMUM_SEND_BPS/4)

	movsd	xmm0, QWORD PTR _MINIMUM_SEND_BPS
	divsd	xmm0, QWORD PTR __real@4010000000000000
	comisd	xmm0, QWORD PTR _delta$3[ebp]
	jbe	$LN14@Update

; 1109 : 				{
; 1110 : 					// If no packetloss and done searching, increase the high range by 50%
; 1111 : 					if (packetloss==0.0)

	cvtss2sd xmm0, DWORD PTR _packetloss$4[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN13@Update

; 1112 : 					{
; 1113 : 						highBandwidth*=1.5;

	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [eax+994]
	mulsd	xmm0, QWORD PTR __real@3ff8000000000000
	mov	ecx, DWORD PTR _this$[ebp]
	movsd	QWORD PTR [ecx+994], xmm0
	jmp	$LN8@Update
$LN13@Update:

; 1114 : 					}
; 1115 : 					else if (packetloss < PACKETLOSS_TOLERANCE)

	movss	xmm0, DWORD PTR _PACKETLOSS_TOLERANCE
	comiss	xmm0, DWORD PTR _packetloss$4[ebp]
	jbe	SHORT $LN11@Update

; 1116 : 					{
; 1117 : 						// If some packetloss and done searching, increase the high range by 5%
; 1118 : 						highBandwidth*=1.05;

	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [eax+994]
	mulsd	xmm0, QWORD PTR __real@3ff0cccccccccccd
	mov	ecx, DWORD PTR _this$[ebp]
	movsd	QWORD PTR [ecx+994], xmm0
	jmp	SHORT $LN8@Update
$LN11@Update:

; 1119 : 					}
; 1120 : 					else if (packetloss < PACKETLOSS_TOLERANCE*2)

	movss	xmm0, DWORD PTR _PACKETLOSS_TOLERANCE
	mulss	xmm0, DWORD PTR __real@40000000
	comiss	xmm0, DWORD PTR _packetloss$4[ebp]
	jbe	SHORT $LN8@Update

; 1121 : 					{
; 1122 : 						// If some packetloss, but not a huge amount and done searching, decrease the low range by 10%
; 1123 : 						lowBandwidth*=.9;

	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [eax+986]
	mulsd	xmm0, QWORD PTR __real@3feccccccccccccd
	mov	ecx, DWORD PTR _this$[ebp]
	movsd	QWORD PTR [ecx+986], xmm0

; 1124 : 						if (lowBandwidth < MINIMUM_SEND_BPS)

	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR _MINIMUM_SEND_BPS
	comisd	xmm0, QWORD PTR [eax+986]
	jbe	SHORT $LN8@Update

; 1125 : 							lowBandwidth=MINIMUM_SEND_BPS;

	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR _MINIMUM_SEND_BPS
	movsd	QWORD PTR [eax+986], xmm0
$LN8@Update:

; 1126 : 					}
; 1127 : 					delta = (highBandwidth-lowBandwidth)/2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [eax+994]
	subsd	xmm0, QWORD PTR [ecx+986]
	divsd	xmm0, QWORD PTR __real@4000000000000000
	movsd	QWORD PTR _delta$3[ebp], xmm0
$LN14@Update:

; 1128 : 				}
; 1129 : 				currentBandwidth=delta+lowBandwidth;

	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR _delta$3[ebp]
	addsd	xmm0, QWORD PTR [eax+986]
	mov	ecx, DWORD PTR _this$[ebp]
	movsd	QWORD PTR [ecx+1002], xmm0

; 1130 : 			}
; 1131 : 			else

	jmp	SHORT $LN7@Update
$LN17@Update:

; 1132 : 			{
; 1133 : 				// Don't know the maximum bandwidth, so keep doubling to find out
; 1134 : 				currentBandwidth*=2.0;

	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [eax+1002]
	mulsd	xmm0, QWORD PTR __real@4000000000000000
	mov	ecx, DWORD PTR _this$[ebp]
	movsd	QWORD PTR [ecx+1002], xmm0
$LN7@Update:

; 1135 : 			}
; 1136 : 		}
; 1137 : 
; 1138 : 		histogramPlossCount=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+978], 0

; 1139 : 		histogramAckCount=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+982], 0

; 1140 : 		histogramStartTime=time+TIME_TO_NEW_SAMPLE+ping*2*1000;

	mov	eax, DWORD PTR _time$[ebp]
	add	eax, 500000				; 0007a120H
	mov	ecx, DWORD PTR _time$[ebp+4]
	adc	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+717]
	shl	edx, 1
	imul	edx, edx, 1000
	xor	esi, esi
	add	eax, edx
	adc	ecx, esi
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+962], eax
	mov	DWORD PTR [edx+966], ecx

; 1141 : 		histogramEndTime=histogramStartTime+MAX_TIME_TO_SAMPLE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+962]
	add	ecx, 250000				; 0003d090H
	mov	edx, DWORD PTR [eax+966]
	adc	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+954], ecx
	mov	DWORD PTR [eax+958], edx

; 1142 : 		if (++histogramReceiveMarker==(unsigned)-1)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+970]
	add	ecx, 1
	mov	DWORD PTR tv346[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv346[ebp]
	mov	DWORD PTR [edx+970], eax
	cmp	DWORD PTR tv346[ebp], -1
	jne	SHORT $LN6@Update

; 1143 : 			histogramReceiveMarker=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+970], 0
$LN6@Update:

; 1144 : 	}
; 1145 : 
; 1146 : #ifndef _RELEASE
; 1147 : 	// Do any lagged sends
; 1148 : 	unsigned i = 0;

	mov	DWORD PTR _i$[ebp], 0
$LN5@Update:

; 1149 : 	while ( i < delayList.Size() )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1646				; 0000066eH
	call	?Size@?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QBEIXZ ; DataStructures::List<ReliabilityLayer::DataAndTime *>::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	$LN4@Update

; 1150 : 	{
; 1151 : 		if ( delayList[ i ]->sendTime < time )

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1646				; 0000066eH
	call	??A?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QBEAAPAUDataAndTime@ReliabilityLayer@@I@Z ; DataStructures::List<ReliabilityLayer::DataAndTime *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv769[ebp], ecx
	mov	edx, DWORD PTR tv769[ebp]
	mov	eax, DWORD PTR [edx+584]
	cmp	eax, DWORD PTR _time$[ebp+4]
	jg	$LN3@Update
	jl	SHORT $LN54@Update
	mov	ecx, DWORD PTR tv769[ebp]
	mov	edx, DWORD PTR [ecx+580]
	cmp	edx, DWORD PTR _time$[ebp]
	jae	$LN3@Update
$LN54@Update:

; 1152 : 		{
; 1153 : 			updateBitStream.Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 186				; 000000baH
	call	?Reset@BitStream@RakNet@@QAEXXZ		; RakNet::BitStream::Reset

; 1154 : 			updateBitStream.Write( delayList[ i ]->data, delayList[ i ]->length );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1646				; 0000066eH
	call	??A?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QBEAAPAUDataAndTime@ReliabilityLayer@@I@Z ; DataStructures::List<ReliabilityLayer::DataAndTime *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+576]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1646				; 0000066eH
	call	??A?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QBEAAPAUDataAndTime@ReliabilityLayer@@I@Z ; DataStructures::List<ReliabilityLayer::DataAndTime *>::operator[]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 186				; 000000baH
	call	?Write@BitStream@RakNet@@QAEXPBDH@Z	; RakNet::BitStream::Write

; 1155 : 			// Send it now
; 1156 : 			SendBitStream( s, playerId, &updateBitStream );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 186				; 000000baH
	push	eax
	sub	esp, 8
	mov	ecx, esp
	mov	edx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	ax, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [ecx+4], ax
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendBitStream@ReliabilityLayer@@AAEXIUPlayerID@@PAVBitStream@RakNet@@@Z ; ReliabilityLayer::SendBitStream

; 1157 : 
; 1158 : 			delete delayList[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1646				; 0000066eH
	call	??A?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QBEAAPAUDataAndTime@ReliabilityLayer@@I@Z ; DataStructures::List<ReliabilityLayer::DataAndTime *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1159 : 			if (i != delayList.Size() - 1)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1646				; 0000066eH
	call	?Size@?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QBEIXZ ; DataStructures::List<ReliabilityLayer::DataAndTime *>::Size
	sub	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	je	SHORT $LN2@Update

; 1160 : 				delayList[ i ] = delayList[ delayList.Size() - 1 ];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1646				; 0000066eH
	call	?Size@?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QBEIXZ ; DataStructures::List<ReliabilityLayer::DataAndTime *>::Size
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1646				; 0000066eH
	call	??A?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QBEAAPAUDataAndTime@ReliabilityLayer@@I@Z ; DataStructures::List<ReliabilityLayer::DataAndTime *>::operator[]
	mov	esi, eax
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1646				; 0000066eH
	call	??A?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QBEAAPAUDataAndTime@ReliabilityLayer@@I@Z ; DataStructures::List<ReliabilityLayer::DataAndTime *>::operator[]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx
$LN2@Update:

; 1161 : 			delayList.Del();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1646				; 0000066eH
	call	?Del@?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QAEXI@Z ; DataStructures::List<ReliabilityLayer::DataAndTime *>::Del

; 1162 : 		}
; 1163 : 
; 1164 : 		else

	jmp	SHORT $LN1@Update
$LN3@Update:

; 1165 : 			i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN1@Update:

; 1166 : 	}

	jmp	$LN5@Update
$LN4@Update:
$LN46@Update:

; 1167 : #endif
; 1168 : 
; 1169 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN57@Update
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 372				; 00000174H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
	npad	2
$LN57@Update:
	DD	1
	DD	$LN56@Update
$LN56@Update:
	DD	-33					; ffffffdfH
	DD	1
	DD	$LN55@Update
$LN55@Update:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	97					; 00000061H
	DB	98					; 00000062H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	83					; 00000053H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
?Update@ReliabilityLayer@@QAEXIUPlayerID@@H_JAAV?$List@PAVPluginInterface@@@DataStructures@@@Z ENDP ; ReliabilityLayer::Update
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?Send@ReliabilityLayer@@QAE_NPADHW4PacketPriority@@W4PacketReliability@@E_NH_J@Z
_TEXT	SEGMENT
tv173 = -280						; size = 4
$T1 = -272						; size = 4
_splitPacket$ = -65					; size = 1
_maxDataSize$ = -56					; size = 4
_headerLength$ = -44					; size = 4
_internalPacket$ = -32					; size = 4
_numberOfBytesToSend$ = -20				; size = 4
_this$ = -8						; size = 4
_data$ = 8						; size = 4
_numberOfBitsToSend$ = 12				; size = 4
_priority$ = 16						; size = 4
_reliability$ = 20					; size = 4
_orderingChannel$ = 24					; size = 1
_makeDataCopy$ = 28					; size = 1
_MTUSize$ = 32						; size = 4
_currentTime$ = 36					; size = 8
?Send@ReliabilityLayer@@QAE_NPADHW4PacketPriority@@W4PacketReliability@@E_NH_J@Z PROC ; ReliabilityLayer::Send, COMDAT
; _this$ = ecx

; 822  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 280				; 00000118H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-280]
	mov	ecx, 70					; 00000046H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 823  : #ifdef _DEBUG
; 824  : 	assert( !( reliability > RELIABLE_SEQUENCED || reliability < 0 ) );

	cmp	DWORD PTR _reliability$[ebp], 4
	jg	SHORT $LN19@Send
	cmp	DWORD PTR _reliability$[ebp], 0
	jge	SHORT $LN20@Send
$LN19@Send:
	mov	eax, DWORD PTR ?__LINE__Var@?1??Send@ReliabilityLayer@@QAE_NPADHW4PacketPriority@@W4PacketReliability@@E_NH_J@Z@4JA
	add	eax, 2
	push	eax
	push	OFFSET ??_C@_1FK@FKLHGKMO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAe?$AAl?$AAi?$AAa?$AAb?$AAi?$AAl@
	push	OFFSET ??_C@_1HC@GDCNHECB@?$AA?$CB?$AA?$CI?$AA?5?$AAr?$AAe?$AAl?$AAi?$AAa?$AAb?$AAi?$AAl?$AAi?$AAt?$AAy?$AA?5?$AA?$DO?$AA?5?$AAR?$AAE?$AAL?$AAI?$AAA?$AAB?$AAL?$AAE?$AA_?$AAS?$AAE?$AAQ?$AAU?$AAE?$AAN@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN20@Send:

; 825  : 	assert( !( priority > NUMBER_OF_PRIORITIES || priority < 0 ) );

	cmp	DWORD PTR _priority$[ebp], 4
	jg	SHORT $LN21@Send
	cmp	DWORD PTR _priority$[ebp], 0
	jge	SHORT $LN22@Send
$LN21@Send:
	mov	eax, DWORD PTR ?__LINE__Var@?1??Send@ReliabilityLayer@@QAE_NPADHW4PacketPriority@@W4PacketReliability@@E_NH_J@Z@4JA
	add	eax, 3
	push	eax
	push	OFFSET ??_C@_1FK@FKLHGKMO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAe?$AAl?$AAi?$AAa?$AAb?$AAi?$AAl@
	push	OFFSET ??_C@_1GK@MADIINNK@?$AA?$CB?$AA?$CI?$AA?5?$AAp?$AAr?$AAi?$AAo?$AAr?$AAi?$AAt?$AAy?$AA?5?$AA?$DO?$AA?5?$AAN?$AAU?$AAM?$AAB?$AAE?$AAR?$AA_?$AAO?$AAF?$AA_?$AAP?$AAR?$AAI?$AAO?$AAR?$AAI?$AAT?$AAI@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN22@Send:

; 826  : 	assert( !( orderingChannel < 0 || orderingChannel >= NUMBER_OF_ORDERED_STREAMS ) );

	movzx	eax, BYTE PTR _orderingChannel$[ebp]
	test	eax, eax
	jl	SHORT $LN23@Send
	movzx	ecx, BYTE PTR _orderingChannel$[ebp]
	cmp	ecx, 32					; 00000020H
	jl	SHORT $LN24@Send
$LN23@Send:
	mov	edx, DWORD PTR ?__LINE__Var@?1??Send@ReliabilityLayer@@QAE_NPADHW4PacketPriority@@W4PacketReliability@@E_NH_J@Z@4JA
	add	edx, 4
	push	edx
	push	OFFSET ??_C@_1FK@FKLHGKMO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAe?$AAl?$AAi?$AAa?$AAb?$AAi?$AAl@
	push	OFFSET ??_C@_1JC@KFGENCHD@?$AA?$CB?$AA?$CI?$AA?5?$AAo?$AAr?$AAd?$AAe?$AAr?$AAi?$AAn?$AAg?$AAC?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AA?5?$AA?$DM?$AA?5?$AA0?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAo?$AAr?$AAd?$AAe?$AAr?$AAi@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN24@Send:

; 827  : 	assert( numberOfBitsToSend > 0 );

	cmp	DWORD PTR _numberOfBitsToSend$[ebp], 0
	jg	SHORT $LN25@Send
	mov	eax, DWORD PTR ?__LINE__Var@?1??Send@ReliabilityLayer@@QAE_NPADHW4PacketPriority@@W4PacketReliability@@E_NH_J@Z@4JA
	add	eax, 5
	push	eax
	push	OFFSET ??_C@_1FK@FKLHGKMO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAe?$AAl?$AAi?$AAa?$AAb?$AAi?$AAl@
	push	OFFSET ??_C@_1CO@KEDLFNFL@?$AAn?$AAu?$AAm?$AAb?$AAe?$AAr?$AAO?$AAf?$AAB?$AAi?$AAt?$AAs?$AAT?$AAo?$AAS?$AAe?$AAn?$AAd?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN25@Send:

; 828  : #endif
; 829  : 
; 830  : #ifdef __USE_IO_COMPLETION_PORTS
; 831  : 
; 832  : 	if ( readWriteSocket == INVALID_SOCKET )
; 833  : 		return false;
; 834  : 
; 835  : #endif
; 836  : 
; 837  : 	// Fix any bad parameters
; 838  : 	if ( reliability > RELIABLE_SEQUENCED || reliability < 0 )

	cmp	DWORD PTR _reliability$[ebp], 4
	jg	SHORT $LN15@Send
	cmp	DWORD PTR _reliability$[ebp], 0
	jge	SHORT $LN16@Send
$LN15@Send:

; 839  : 		reliability = RELIABLE;

	mov	DWORD PTR _reliability$[ebp], 2
$LN16@Send:

; 840  : 
; 841  : 	if ( priority > NUMBER_OF_PRIORITIES || priority < 0 )

	cmp	DWORD PTR _priority$[ebp], 4
	jg	SHORT $LN13@Send
	cmp	DWORD PTR _priority$[ebp], 0
	jge	SHORT $LN14@Send
$LN13@Send:

; 842  : 		priority = HIGH_PRIORITY;

	mov	DWORD PTR _priority$[ebp], 1
$LN14@Send:

; 843  : 
; 844  : 	if ( orderingChannel >= NUMBER_OF_ORDERED_STREAMS )

	movzx	eax, BYTE PTR _orderingChannel$[ebp]
	cmp	eax, 32					; 00000020H
	jl	SHORT $LN12@Send

; 845  : 		orderingChannel = 0;

	mov	BYTE PTR _orderingChannel$[ebp], 0
$LN12@Send:

; 846  : 
; 847  : 	int numberOfBytesToSend=BITS_TO_BYTES(numberOfBitsToSend);

	mov	eax, DWORD PTR _numberOfBitsToSend$[ebp]
	add	eax, 7
	sar	eax, 3
	mov	DWORD PTR _numberOfBytesToSend$[ebp], eax

; 848  : 	if ( numberOfBitsToSend == 0 )

	cmp	DWORD PTR _numberOfBitsToSend$[ebp], 0
	jne	SHORT $LN11@Send

; 849  : 	{
; 850  : #ifdef _DEBUG
; 851  : 		printf( "Error!! ReliabilityLayer::Send bitStream->GetNumberOfBytesUsed()==0\n" );

	push	OFFSET ??_C@_0EF@BEKPCEMB@Error?$CB?$CB?5ReliabilityLayer?3?3Send?5b@
	call	_printf
	add	esp, 4

; 852  : #endif
; 853  : 
; 854  : 		return false;

	xor	al, al
	jmp	$LN17@Send
$LN11@Send:

; 855  : 	}
; 856  : 	InternalPacket * internalPacket = internalPacketPool.GetPointer();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	call	?GetPointer@InternalPacketPool@@QAEPAUInternalPacket@@XZ ; InternalPacketPool::GetPointer
	mov	DWORD PTR _internalPacket$[ebp], eax

; 857  : 	//InternalPacket * internalPacket = sendPacketSet[priority].WriteLock();
; 858  : #ifdef _DEBUG
; 859  : 	// Remove accessing undefined memory warning
; 860  : 	memset( internalPacket, 255, sizeof( InternalPacket ) );

	push	55					; 00000037H
	push	255					; 000000ffH
	mov	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 861  : #endif
; 862  : 
; 863  : 	internalPacket->creationTime = currentTime;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR _currentTime$[ebp]
	mov	DWORD PTR [eax+27], ecx
	mov	edx, DWORD PTR _currentTime$[ebp+4]
	mov	DWORD PTR [eax+31], edx

; 864  : 
; 865  : 	if ( makeDataCopy )

	movzx	eax, BYTE PTR _makeDataCopy$[ebp]
	test	eax, eax
	je	SHORT $LN10@Send

; 866  : 	{
; 867  : 		internalPacket->data = new unsigned char [ numberOfBytesToSend ];

	mov	eax, DWORD PTR _numberOfBytesToSend$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR _internalPacket$[ebp]
	mov	edx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [ecx+47], edx

; 868  : 		memcpy( internalPacket->data, data, numberOfBytesToSend );

	mov	eax, DWORD PTR _numberOfBytesToSend$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _internalPacket$[ebp]
	mov	eax, DWORD PTR [edx+47]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 869  : //		printf("Allocated %i\n", internalPacket->data);
; 870  : 	}
; 871  : 	else

	jmp	SHORT $LN9@Send
$LN10@Send:

; 872  : 	{
; 873  : 		// Allocated the data elsewhere, delete it in here
; 874  : 		internalPacket->data = ( unsigned char* ) data;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	mov	DWORD PTR [eax+47], ecx
$LN9@Send:

; 875  : //		printf("Using Pre-Allocated %i\n", internalPacket->data);
; 876  : 	}
; 877  : 
; 878  : 	internalPacket->dataBitLength = numberOfBitsToSend;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR _numberOfBitsToSend$[ebp]
	mov	DWORD PTR [eax+43], ecx

; 879  : 	internalPacket->nextActionTime = 0;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	DWORD PTR [eax+35], 0
	mov	DWORD PTR [eax+39], 0

; 880  : 
; 881  : 	internalPacket->messageNumber = messageNumber;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+176]
	mov	WORD PTR [eax], dx

; 882  : 
; 883  : 	internalPacket->priority = priority;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR _priority$[ebp]
	mov	DWORD PTR [eax+6], ecx

; 884  : 	internalPacket->reliability = reliability;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR _reliability$[ebp]
	mov	DWORD PTR [eax+10], ecx

; 885  : 	internalPacket->splitPacketCount = 0;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	DWORD PTR [eax+23], 0

; 886  : 
; 887  : 	// Calculate if I need to split the packet
; 888  : 	int headerLength = BITS_TO_BYTES( GetBitStreamHeaderLength( internalPacket ) );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBitStreamHeaderLength@ReliabilityLayer@@AAEHQBUInternalPacket@@@Z ; ReliabilityLayer::GetBitStreamHeaderLength
	add	eax, 7
	sar	eax, 3
	mov	DWORD PTR _headerLength$[ebp], eax

; 889  : 
; 890  : 	int maxDataSize = MTUSize - UDP_HEADER_SIZE - headerLength;

	mov	eax, DWORD PTR _MTUSize$[ebp]
	sub	eax, 28					; 0000001cH
	sub	eax, DWORD PTR _headerLength$[ebp]
	mov	DWORD PTR _maxDataSize$[ebp], eax

; 891  : 
; 892  : 	if ( encryptor.IsKeySet() )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1019				; 000003fbH
	call	?IsKeySet@TEABlockEncryptor@@QBE_NXZ	; TEABlockEncryptor::IsKeySet
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@Send

; 893  : #ifdef TEA_ENCRYPTOR
; 894  : 		maxDataSize -= 8; // Extra data for the encryptor

	mov	eax, DWORD PTR _maxDataSize$[ebp]
	sub	eax, 8
	mov	DWORD PTR _maxDataSize$[ebp], eax
$LN8@Send:

; 895  : #else
; 896  : 		maxDataSize -= 16; // Extra data for the encryptor
; 897  : #endif
; 898  : 
; 899  : 	bool splitPacket = numberOfBytesToSend > maxDataSize;

	mov	eax, DWORD PTR _numberOfBytesToSend$[ebp]
	cmp	eax, DWORD PTR _maxDataSize$[ebp]
	jle	SHORT $LN26@Send
	mov	DWORD PTR tv173[ebp], 1
	jmp	SHORT $LN27@Send
$LN26@Send:
	mov	DWORD PTR tv173[ebp], 0
$LN27@Send:
	mov	cl, BYTE PTR tv173[ebp]
	mov	BYTE PTR _splitPacket$[ebp], cl

; 900  : 
; 901  : 	// If a split packet, we might have to upgrade the reliability
; 902  : 	if ( splitPacket )

	movzx	eax, BYTE PTR _splitPacket$[ebp]
	test	eax, eax
	je	SHORT $LN7@Send

; 903  : 		statistics.numberOfSplitMessages++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+835]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+835], ecx

; 904  : 	else

	jmp	SHORT $LN6@Send
$LN7@Send:

; 905  : 		statistics.numberOfUnsplitMessages++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+831]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+831], ecx
$LN6@Send:

; 906  : 
; 907  : 	++messageNumber;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+176]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+176], cx

; 908  : 
; 909  : 
; 910  : 	if ( internalPacket->reliability == RELIABLE_SEQUENCED || internalPacket->reliability == UNRELIABLE_SEQUENCED )

	mov	eax, DWORD PTR _internalPacket$[ebp]
	cmp	DWORD PTR [eax+10], 4
	je	SHORT $LN4@Send
	mov	eax, DWORD PTR _internalPacket$[ebp]
	cmp	DWORD PTR [eax+10], 1
	jne	SHORT $LN5@Send
$LN4@Send:

; 911  : 	{
; 912  : 		// Assign the sequence stream and index
; 913  : 		internalPacket->orderingChannel = orderingChannel;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	cl, BYTE PTR _orderingChannel$[ebp]
	mov	BYTE PTR [eax+14], cl

; 914  : 		internalPacket->orderingIndex = waitingForSequencedPacketWriteIndex[ orderingChannel ] ++;

	movzx	eax, BYTE PTR _orderingChannel$[ebp]
	mov	ecx, DWORD PTR _internalPacket$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+eax*2+523]
	mov	WORD PTR [ecx+15], ax
	movzx	ecx, BYTE PTR _orderingChannel$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+ecx*2+523]
	add	ax, 1
	movzx	ecx, BYTE PTR _orderingChannel$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+ecx*2+523], ax

; 915  : 
; 916  : 		// This packet supersedes all other sequenced packets on the same ordering channel
; 917  : 		// Delete all packets in all send lists that are sequenced and on the same ordering channel
; 918  : 		// UPDATE:
; 919  : 		// Disabled.  We don't have enough info to consistently do this.  Sometimes newer data does supercede
; 920  : 		// older data such as with constantly declining health, but not in all cases.
; 921  : 		// For example, with sequenced unreliable sound packets just because you send a newer one doesn't mean you
; 922  : 		// don't need the older ones because the odds are they will still arrive in order
; 923  : 		/*
; 924  : 		  for (int i=0; i < NUMBER_OF_PRIORITIES; i++)
; 925  : 		  {
; 926  : 		  DeleteSequencedPacketsInList(orderingChannel, sendQueue[i]);
; 927  : 		  }
; 928  : 		*/
; 929  : 	}
; 930  : 
; 931  : 	else

	jmp	SHORT $LN3@Send
$LN5@Send:

; 932  : 		if ( internalPacket->reliability == RELIABLE_ORDERED )

	mov	eax, DWORD PTR _internalPacket$[ebp]
	cmp	DWORD PTR [eax+10], 3
	jne	SHORT $LN3@Send

; 933  : 		{
; 934  : 			// Assign the ordering channel and index
; 935  : 			internalPacket->orderingChannel = orderingChannel;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	cl, BYTE PTR _orderingChannel$[ebp]
	mov	BYTE PTR [eax+14], cl

; 936  : 			internalPacket->orderingIndex = waitingForOrderedPacketWriteIndex[ orderingChannel ] ++;

	movzx	eax, BYTE PTR _orderingChannel$[ebp]
	mov	ecx, DWORD PTR _internalPacket$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+eax*2+459]
	mov	WORD PTR [ecx+15], ax
	movzx	ecx, BYTE PTR _orderingChannel$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+ecx*2+459]
	add	ax, 1
	movzx	ecx, BYTE PTR _orderingChannel$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+ecx*2+459], ax
$LN3@Send:

; 937  : 		}
; 938  : 
; 939  : 	if ( splitPacket )   // If it uses a secure header it will be generated here

	movzx	eax, BYTE PTR _splitPacket$[ebp]
	test	eax, eax
	je	SHORT $LN1@Send

; 940  : 	{
; 941  : 		// Must split the packet.  This will also generate the SHA1 if it is required. It also adds it to the send list.
; 942  : 		//InternalPacket packetCopy;
; 943  : 		//memcpy(&packetCopy, internalPacket, sizeof(InternalPacket));
; 944  : 		//sendPacketSet[priority].CancelWriteLock(internalPacket);
; 945  : 		//SplitPacket( &packetCopy, MTUSize );
; 946  : 		SplitPacket( internalPacket, MTUSize );

	mov	eax, DWORD PTR _MTUSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _internalPacket$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SplitPacket@ReliabilityLayer@@AAEXPAUInternalPacket@@H@Z ; ReliabilityLayer::SplitPacket

; 947  : 		//delete [] packetCopy.data;
; 948  : 		return true;

	mov	al, 1
	jmp	SHORT $LN17@Send
$LN1@Send:

; 949  : 	}
; 950  : 
; 951  : 	sendPacketSet[ internalPacket->priority ].Push( internalPacket );

	lea	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _internalPacket$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+100]
	call	?Push@?$Queue@PAUInternalPacket@@@DataStructures@@QAEXABQAUInternalPacket@@@Z ; DataStructures::Queue<InternalPacket *>::Push

; 952  : 
; 953  : //	sendPacketSet[priority].WriteUnlock();
; 954  : 	return true;

	mov	al, 1
$LN17@Send:

; 955  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN30@Send
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 280				; 00000118H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
$LN30@Send:
	DD	1
	DD	$LN29@Send
$LN29@Send:
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN28@Send
$LN28@Send:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	0
?Send@ReliabilityLayer@@QAE_NPADHW4PacketPriority@@W4PacketReliability@@E_NH_J@Z ENDP ; ReliabilityLayer::Send
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?Receive@ReliabilityLayer@@QAEHPAPAE@Z
_TEXT	SEGMENT
_bitLength$1 = -32					; size = 4
_internalPacket$ = -20					; size = 4
_this$ = -8						; size = 4
_data$ = 8						; size = 4
?Receive@ReliabilityLayer@@QAEHPAPAE@Z PROC		; ReliabilityLayer::Receive, COMDAT
; _this$ = ecx

; 786  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 787  : 	// Wait until the clear occurs
; 788  : 	if (freeThreadedMemoryOnNextUpdate)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1645]
	test	ecx, ecx
	je	SHORT $LN3@Receive

; 789  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN4@Receive
$LN3@Receive:

; 790  : 
; 791  : 	InternalPacket * internalPacket;
; 792  : 
; 793  : 	if ( outputQueue.Size() > 0 )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?Size@?$Queue@PAUInternalPacket@@@DataStructures@@QBEIXZ ; DataStructures::Queue<InternalPacket *>::Size
	test	eax, eax
	jbe	SHORT $LN2@Receive

; 794  : 	{
; 795  : 		//  #ifdef _DEBUG
; 796  : 		//  assert(bitStream->GetNumberOfBitsUsed()==0);
; 797  : 		//  #endif
; 798  : 		internalPacket = outputQueue.Pop();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?Pop@?$Queue@PAUInternalPacket@@@DataStructures@@QAEPAUInternalPacket@@XZ ; DataStructures::Queue<InternalPacket *>::Pop
	mov	DWORD PTR _internalPacket$[ebp], eax

; 799  : 
; 800  : 		int bitLength;
; 801  : 		*data = internalPacket->data;

	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR _internalPacket$[ebp]
	mov	edx, DWORD PTR [ecx+47]
	mov	DWORD PTR [eax], edx

; 802  : 		bitLength = internalPacket->dataBitLength;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR [eax+43]
	mov	DWORD PTR _bitLength$1[ebp], ecx

; 803  : 		internalPacketPool.ReleasePointer( internalPacket );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	call	?ReleasePointer@InternalPacketPool@@QAEXPAUInternalPacket@@@Z ; InternalPacketPool::ReleasePointer

; 804  : 		return bitLength;

	mov	eax, DWORD PTR _bitLength$1[ebp]
	jmp	SHORT $LN4@Receive

; 805  : 	}
; 806  : 
; 807  : 	else

	jmp	SHORT $LN4@Receive
$LN2@Receive:

; 808  : 	{
; 809  : 		return 0;

	xor	eax, eax
$LN4@Receive:

; 810  : 	}
; 811  : 
; 812  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Receive@ReliabilityLayer@@QAEHPAPAE@Z ENDP		; ReliabilityLayer::Receive
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?HandleSocketReceiveFromConnectedPlayer@ReliabilityLayer@@QAE_NPBDHUPlayerID@@AAV?$List@PAVPluginInterface@@@DataStructures@@H@Z
_TEXT	SEGMENT
tv584 = -848						; size = 4
tv908 = -844						; size = 8
tv583 = -844						; size = 4
tv860 = -840						; size = 4
tv767 = -840						; size = 4
tv582 = -840						; size = 4
tv249 = -840						; size = 4
$T2 = -829						; size = 1
$T3 = -817						; size = 1
$T4 = -805						; size = 1
$T5 = -796						; size = 4
$T6 = -784						; size = 4
$T7 = -772						; size = 8
$T8 = -756						; size = 8
$T9 = -740						; size = 4
$T10 = -728						; size = 4
$T11 = -716						; size = 4
$T12 = -704						; size = 4
$T13 = -689						; size = 1
_orderingChannelCopy$14 = -485				; size = 1
_orderingListAtOrderingStream$15 = -476			; size = 4
_typeRange$16 = -464					; size = 4
_internalPacket$ = -452					; size = 4
_messageNumber$17 = -440				; size = 2
_incomingAcks$ = -428					; size = 12
_socketData$ = -408					; size = 273
_hasAcks$ = -121					; size = 1
_ackedHistogramCounter$ = -112				; size = 4
_i$ = -100						; size = 4
_holeCount$ = -88					; size = 2
_size$ = -76						; size = 4
_count$ = -64						; size = 4
_indexFound$ = -49					; size = 1
_time$ = -40						; size = 8
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_buffer$ = 8						; size = 4
_length$ = 12						; size = 4
_playerId$ = 16						; size = 6
_messageHandlerList$ = 24				; size = 4
_MTUSize$ = 28						; size = 4
?HandleSocketReceiveFromConnectedPlayer@ReliabilityLayer@@QAE_NPBDHUPlayerID@@AAV?$List@PAVPluginInterface@@@DataStructures@@H@Z PROC ; ReliabilityLayer::HandleSocketReceiveFromConnectedPlayer, COMDAT
; _this$ = ecx

; 333  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?HandleSocketReceiveFromConnectedPlayer@ReliabilityLayer@@QAE_NPBDHUPlayerID@@AAV?$List@PAVPluginInterface@@@DataStructures@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 836				; 00000344H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-848]
	mov	ecx, 209				; 000000d1H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 334  : #ifdef _DEBUG
; 335  : 	assert( !( length <= 0 || buffer == 0 ) );

	cmp	DWORD PTR _length$[ebp], 0
	jle	SHORT $LN74@HandleSock
	cmp	DWORD PTR _buffer$[ebp], 0
	jne	SHORT $LN75@HandleSock
$LN74@HandleSock:
	mov	eax, DWORD PTR ?__LINE__Var@?1??HandleSocketReceiveFromConnectedPlayer@ReliabilityLayer@@QAE_NPBDHUPlayerID@@AAV?$List@PAVPluginInterface@@@DataStructures@@H@Z@4JA
	add	eax, 2
	push	eax
	push	OFFSET ??_C@_1FK@FKLHGKMO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAe?$AAl?$AAi?$AAa?$AAb?$AAi?$AAl@
	push	OFFSET ??_C@_1EA@BNPCOFAI@?$AA?$CB?$AA?$CI?$AA?5?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CJ?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN75@HandleSock:

; 336  : #endif
; 337  : 
; 338  : 	if ( length <= 1 || buffer == 0 )   // Length of 1 is a connection request resend that we just ignore

	cmp	DWORD PTR _length$[ebp], 1
	jle	SHORT $LN70@HandleSock
	cmp	DWORD PTR _buffer$[ebp], 0
	jne	SHORT $LN71@HandleSock
$LN70@HandleSock:

; 339  : 		return true;

	mov	al, 1
	jmp	$LN72@HandleSock
$LN71@HandleSock:

; 340  : 
; 341  : 	//int numberOfAcksInFrame = 0;
; 342  : 	RakNetTimeNS time;
; 343  : 	bool indexFound;
; 344  : 	int count, size;
; 345  : 	MessageNumberType holeCount;
; 346  : 	unsigned i;
; 347  : 	unsigned ackedHistogramCounter;
; 348  : 	bool hasAcks=false;

	mov	BYTE PTR _hasAcks$[ebp], 0

; 349  : 
; 350  : //	bool duplicatePacket;
; 351  : 
; 352  : 	// bytesReceived+=length + UDP_HEADER_SIZE;
; 353  : 
; 354  : 	UpdateThreadedMemory();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateThreadedMemory@ReliabilityLayer@@AAEXXZ ; ReliabilityLayer::UpdateThreadedMemory

; 355  : 
; 356  : 	// decode this whole chunk if the decoder is defined.
; 357  : 	if ( encryptor.IsKeySet() )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1019				; 000003fbH
	call	?IsKeySet@TEABlockEncryptor@@QBE_NXZ	; TEABlockEncryptor::IsKeySet
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN69@HandleSock

; 358  : 	{
; 359  : 		if ( encryptor.Decrypt( ( unsigned char* ) buffer, length, ( unsigned char* ) buffer, &length ) == false )

	lea	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _length$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1019				; 000003fbH
	call	?Decrypt@TEABlockEncryptor@@QAE_NPAEH0PAH@Z ; TEABlockEncryptor::Decrypt
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN69@HandleSock

; 360  : 		{
; 361  : 			statistics.bitsWithBadCRCReceived += length * 8;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+883]
	mov	edx, DWORD PTR _length$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+883], eax

; 362  : 			statistics.packetsWithBadCRCReceived++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+875]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+875], ecx

; 363  : 			return false;

	xor	al, al
	jmp	$LN72@HandleSock
$LN69@HandleSock:

; 364  : 		}
; 365  : 	}
; 366  : 
; 367  : 	statistics.bitsReceived += length * 8;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+879]
	mov	edx, DWORD PTR _length$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+879], eax

; 368  : 	statistics.packetsReceived++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+871]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+871], ecx

; 369  : 
; 370  : 	RakNet::BitStream socketData( (unsigned char*) buffer, length, false ); // Convert the incoming data to a bitstream for easy parsing

	push	0
	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _socketData$[ebp]
	call	??0BitStream@RakNet@@QAE@PAEI_N@Z	; RakNet::BitStream::BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 371  : 	time = RakNet::GetTimeNS();

	call	?GetTimeNS@RakNet@@YA_JXZ		; RakNet::GetTimeNS
	mov	DWORD PTR _time$[ebp], eax
	mov	DWORD PTR _time$[ebp+4], edx

; 372  : 
; 373  : 	DataStructures::RangeList<MessageNumberType> incomingAcks;

	lea	ecx, DWORD PTR _incomingAcks$[ebp]
	call	??0?$RangeList@G@DataStructures@@QAE@XZ	; DataStructures::RangeList<unsigned short>::RangeList<unsigned short>
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 374  : 	socketData.Read(hasAcks);

	lea	eax, DWORD PTR _hasAcks$[ebp]
	push	eax
	lea	ecx, DWORD PTR _socketData$[ebp]
	call	??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z ; RakNet::BitStream::Read<bool>

; 375  : 	if (hasAcks)

	movzx	eax, BYTE PTR _hasAcks$[ebp]
	test	eax, eax
	je	$LN67@HandleSock

; 376  : 	{
; 377  : 		MessageNumberType messageNumber;
; 378  : 		if (incomingAcks.Deserialize(&socketData)==false)

	lea	eax, DWORD PTR _socketData$[ebp]
	push	eax
	lea	ecx, DWORD PTR _incomingAcks$[ebp]
	call	?Deserialize@?$RangeList@G@DataStructures@@QAE_NPAVBitStream@RakNet@@@Z ; DataStructures::RangeList<unsigned short>::Deserialize
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN66@HandleSock

; 379  : 			return false;

	mov	BYTE PTR $T2[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _incomingAcks$[ebp]
	call	??1?$RangeList@G@DataStructures@@QAE@XZ	; DataStructures::RangeList<unsigned short>::~RangeList<unsigned short>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _socketData$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	al, BYTE PTR $T2[ebp]
	jmp	$LN72@HandleSock
$LN66@HandleSock:

; 380  : 		for (i=0; i<incomingAcks.ranges.Size();i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN65@HandleSock
$LN64@HandleSock:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN65@HandleSock:
	lea	ecx, DWORD PTR _incomingAcks$[ebp]
	call	?Size@?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	$LN67@HandleSock

; 381  : 		{
; 382  : 			if (incomingAcks.ranges[i].minIndex>incomingAcks.ranges[i].maxIndex)

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	lea	ecx, DWORD PTR _incomingAcks$[ebp]
	call	??A?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::operator[]
	movzx	esi, WORD PTR [eax]
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _incomingAcks$[ebp]
	call	??A?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::operator[]
	movzx	edx, WORD PTR [eax+2]
	cmp	esi, edx
	jle	SHORT $LN62@HandleSock

; 383  : 			{
; 384  : 				RakAssert(incomingAcks.ranges[i].minIndex<=incomingAcks.ranges[i].maxIndex);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	lea	ecx, DWORD PTR _incomingAcks$[ebp]
	call	??A?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::operator[]
	movzx	esi, WORD PTR [eax]
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _incomingAcks$[ebp]
	call	??A?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::operator[]
	movzx	edx, WORD PTR [eax+2]
	cmp	esi, edx
	jle	SHORT $LN76@HandleSock
	mov	eax, DWORD PTR ?__LINE__Var@?1??HandleSocketReceiveFromConnectedPlayer@ReliabilityLayer@@QAE_NPBDHUPlayerID@@AAV?$List@PAVPluginInterface@@@DataStructures@@H@Z@4JA
	add	eax, 51					; 00000033H
	push	eax
	push	OFFSET ??_C@_1FK@FKLHGKMO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAe?$AAl?$AAi?$AAa?$AAb?$AAi?$AAl@
	push	OFFSET ??_C@_1IC@KPHIMKPK@?$AAi?$AAn?$AAc?$AAo?$AAm?$AAi?$AAn?$AAg?$AAA?$AAc?$AAk?$AAs?$AA?4?$AAr?$AAa?$AAn?$AAg?$AAe?$AAs?$AA?$FL?$AAi?$AA?$FN?$AA?4?$AAm?$AAi?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?$DM@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN76@HandleSock:

; 385  : 				return false;

	mov	BYTE PTR $T3[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _incomingAcks$[ebp]
	call	??1?$RangeList@G@DataStructures@@QAE@XZ	; DataStructures::RangeList<unsigned short>::~RangeList<unsigned short>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _socketData$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	al, BYTE PTR $T3[ebp]
	jmp	$LN72@HandleSock
$LN62@HandleSock:

; 386  : 			}
; 387  : 
; 388  : 			for (messageNumber=incomingAcks.ranges[i].minIndex; messageNumber >= incomingAcks.ranges[i].minIndex && messageNumber <= incomingAcks.ranges[i].maxIndex; messageNumber++)

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	lea	ecx, DWORD PTR _incomingAcks$[ebp]
	call	??A?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::operator[]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR _messageNumber$17[ebp], cx
	jmp	SHORT $LN61@HandleSock
$LN60@HandleSock:
	mov	ax, WORD PTR _messageNumber$17[ebp]
	add	ax, 1
	mov	WORD PTR _messageNumber$17[ebp], ax
$LN61@HandleSock:
	movzx	esi, WORD PTR _messageNumber$17[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	lea	ecx, DWORD PTR _incomingAcks$[ebp]
	call	??A?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::operator[]
	movzx	ecx, WORD PTR [eax]
	cmp	esi, ecx
	jl	$LN59@HandleSock
	movzx	esi, WORD PTR _messageNumber$17[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	lea	ecx, DWORD PTR _incomingAcks$[ebp]
	call	??A?$OrderedList@GU?$RangeNode@G@DataStructures@@$1??$RangeNodeComp@G@2@YAHABGABU12@@Z@DataStructures@@QBEAAU?$RangeNode@G@1@I@Z ; DataStructures::OrderedList<unsigned short,DataStructures::RangeNode<unsigned short>,&DataStructures::RangeNodeComp<unsigned short> >::operator[]
	movzx	ecx, WORD PTR [eax+2]
	cmp	esi, ecx
	jg	$LN59@HandleSock

; 389  : 			{
; 390  : 				hasAcks=true;

	mov	BYTE PTR _hasAcks$[ebp], 1

; 391  : 
; 392  : 				// SHOW - ack received
; 393  : 				//printf("Got Ack for %i. resendList.Size()=%i sendQueue[0].Size() = %i\n",internalPacket->messageNumber, resendList.Size(), sendQueue[0].Size());
; 394  : 				ackedHistogramCounter=RemovePacketFromResendListAndDeleteOlderReliableSequenced( messageNumber, time );

	mov	eax, DWORD PTR _time$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _time$[ebp]
	push	ecx
	movzx	edx, WORD PTR _messageNumber$17[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemovePacketFromResendListAndDeleteOlderReliableSequenced@ReliabilityLayer@@AAEIG_J@Z ; ReliabilityLayer::RemovePacketFromResendListAndDeleteOlderReliableSequenced
	mov	DWORD PTR _ackedHistogramCounter$[ebp], eax

; 395  : 
; 396  : #ifdef _DEBUG_LOGGER
; 397  : 				{
; 398  : 					char temp[256];
; 399  : 					sprintf(temp, "%p: Got ack for %i. Resend queue size=%i\n", this, messageNumber, resendQueue.Size());
; 400  : 					OutputDebugStr(temp);
; 401  : 				}
; 402  : #endif
; 403  : 
; 404  : 				if (time >= histogramStartTime && ackedHistogramCounter!=(unsigned)-1 && ackedHistogramCounter==histogramReceiveMarker)

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv767[ebp], eax
	mov	ecx, DWORD PTR tv767[ebp]
	mov	edx, DWORD PTR _time$[ebp+4]
	cmp	edx, DWORD PTR [ecx+966]
	jl	SHORT $LN58@HandleSock
	jg	SHORT $LN84@HandleSock
	mov	eax, DWORD PTR tv767[ebp]
	mov	ecx, DWORD PTR _time$[ebp]
	cmp	ecx, DWORD PTR [eax+962]
	jb	SHORT $LN58@HandleSock
$LN84@HandleSock:
	cmp	DWORD PTR _ackedHistogramCounter$[ebp], -1
	je	SHORT $LN58@HandleSock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _ackedHistogramCounter$[ebp]
	cmp	ecx, DWORD PTR [eax+970]
	jne	SHORT $LN58@HandleSock

; 405  : 					++histogramAckCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+982]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+982], ecx
$LN58@HandleSock:

; 406  : 
; 407  : //				internalPacketPool.ReleasePointer( internalPacket );
; 408  : 
; 409  : 
; 410  : 				if ( resendList.IsEmpty() )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	?IsEmpty@?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QBE_NXZ ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::IsEmpty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN57@HandleSock

; 411  : 				{
; 412  : 					lastAckTime = 0; // Not resending anything so clear this var so we don't drop the connection on not getting any more acks

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+178], 0
	mov	DWORD PTR [eax+182], 0

; 413  : 				}
; 414  : 				else

	jmp	SHORT $LN56@HandleSock
$LN57@HandleSock:

; 415  : 				{
; 416  : 					lastAckTime = time; // Just got an ack.  Record when we got it so we know the connection is alive

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _time$[ebp]
	mov	DWORD PTR [eax+178], ecx
	mov	edx, DWORD PTR _time$[ebp+4]
	mov	DWORD PTR [eax+182], edx
$LN56@HandleSock:

; 417  : 				}
; 418  : 			}

	jmp	$LN60@HandleSock
$LN59@HandleSock:

; 419  : 		}

	jmp	$LN64@HandleSock
$LN67@HandleSock:

; 420  : 	}
; 421  : 
; 422  : 
; 423  : 	// Parse the bitstream to create an internal packet
; 424  : 	InternalPacket* internalPacket = CreateInternalPacketFromBitStream( &socketData, time );

	mov	eax, DWORD PTR _time$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _time$[ebp]
	push	ecx
	lea	edx, DWORD PTR _socketData$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CreateInternalPacketFromBitStream@ReliabilityLayer@@AAEPAUInternalPacket@@PAVBitStream@RakNet@@_J@Z ; ReliabilityLayer::CreateInternalPacketFromBitStream
	mov	DWORD PTR _internalPacket$[ebp], eax

; 425  : 
; 426  : 	if (internalPacket==0)

	cmp	DWORD PTR _internalPacket$[ebp], 0
	jne	SHORT $LN54@HandleSock

; 427  : 		return hasAcks;

	mov	al, BYTE PTR _hasAcks$[ebp]
	mov	BYTE PTR $T4[ebp], al
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _incomingAcks$[ebp]
	call	??1?$RangeList@G@DataStructures@@QAE@XZ	; DataStructures::RangeList<unsigned short>::~RangeList<unsigned short>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _socketData$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	al, BYTE PTR $T4[ebp]
	jmp	$LN72@HandleSock
$LN54@HandleSock:

; 428  : 
; 429  : 	while ( internalPacket )

	cmp	DWORD PTR _internalPacket$[ebp], 0
	je	$LN53@HandleSock

; 430  : 	{
; 431  : 		for (i=0; i < messageHandlerList.Size(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN52@HandleSock
$LN51@HandleSock:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN52@HandleSock:
	mov	ecx, DWORD PTR _messageHandlerList$[ebp]
	call	?Size@?$List@PAVPluginInterface@@@DataStructures@@QBEIXZ ; DataStructures::List<PluginInterface *>::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN50@HandleSock

; 432  : 			messageHandlerList[i]->OnInternalPacket(internalPacket, receivePacketCount, playerId, (RakNetTime)(time/(RakNetTimeNS)1000), false);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _messageHandlerList$[ebp]
	call	??A?$List@PAVPluginInterface@@@DataStructures@@QBEAAPAVPluginInterface@@I@Z ; DataStructures::List<PluginInterface *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv249[ebp], ecx
	mov	esi, esp
	push	0
	push	0
	push	1000					; 000003e8H
	mov	edx, DWORD PTR _time$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _time$[ebp]
	push	eax
	call	__alldiv
	push	eax
	sub	esp, 8
	mov	ecx, esp
	mov	edx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	ax, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [ecx+4], ax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1633]
	push	edx
	mov	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv249[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv249[ebp]
	mov	eax, DWORD PTR [edx+36]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	$LN51@HandleSock
$LN50@HandleSock:

; 433  : 
; 434  : 		{
; 435  : #ifdef _DEBUG_LOGGER
; 436  : 			{
; 437  : 				char temp[256];
; 438  : 				sprintf(temp, "%p: Got packet %i data: %i bitlen: %i\n", this, internalPacket->messageNumber, (unsigned char) internalPacket->data[0], internalPacket->dataBitLength);
; 439  : 				OutputDebugStr(temp);
; 440  : 			}
; 441  : #endif
; 442  : 
; 443  : 			//   receivedPacketsCount++;
; 444  : 			if ( internalPacket->reliability == RELIABLE_SEQUENCED || internalPacket->reliability == RELIABLE_ORDERED || internalPacket->reliability == RELIABLE )

	mov	eax, DWORD PTR _internalPacket$[ebp]
	cmp	DWORD PTR [eax+10], 4
	je	SHORT $LN48@HandleSock
	mov	eax, DWORD PTR _internalPacket$[ebp]
	cmp	DWORD PTR [eax+10], 3
	je	SHORT $LN48@HandleSock
	mov	eax, DWORD PTR _internalPacket$[ebp]
	cmp	DWORD PTR [eax+10], 2
	jne	SHORT $LN49@HandleSock
$LN48@HandleSock:

; 445  : 			{
; 446  : 				SendAcknowledgementPacket( internalPacket->messageNumber, time );

	mov	eax, DWORD PTR _time$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _time$[ebp]
	push	ecx
	mov	edx, DWORD PTR _internalPacket$[ebp]
	movzx	eax, WORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendAcknowledgementPacket@ReliabilityLayer@@AAEXG_J@Z ; ReliabilityLayer::SendAcknowledgementPacket
$LN49@HandleSock:

; 447  : 			}
; 448  : 
; 449  : 			// resetReceivedPackets is set from a non-threadsafe function.
; 450  : 			// We do the actual reset in this function so the data is not modified by multiple threads
; 451  : 			if (resetReceivedPackets)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+945]
	test	ecx, ecx
	je	SHORT $LN47@HandleSock

; 452  : 			{
; 453  : 				hasReceivedPacketQueue.ClearAndForceAllocation(DEFAULT_HAS_RECEIVED_PACKET_QUEUE_SIZE);

	push	512					; 00000200H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 927				; 0000039fH
	call	?ClearAndForceAllocation@?$Queue@_J@DataStructures@@QAEXH@Z ; DataStructures::Queue<__int64>::ClearAndForceAllocation

; 454  : 				receivedPacketsBaseIndex=0;

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+943], ax

; 455  : 				resetReceivedPackets=false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+945], 0
$LN47@HandleSock:

; 456  : 			}
; 457  : 
; 458  : 			// If the following conditional is true then this either a duplicate packet
; 459  : 			// or an older out of order packet
; 460  : 			// The subtraction unsigned overflow is intentional
; 461  : 			holeCount = (MessageNumberType)(internalPacket->messageNumber-receivedPacketsBaseIndex);

	mov	eax, DWORD PTR _internalPacket$[ebp]
	movzx	ecx, WORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, WORD PTR [edx+943]
	sub	ecx, eax
	mov	WORD PTR _holeCount$[ebp], cx

; 462  : 			const int typeRange = (MessageNumberType)-1;

	mov	DWORD PTR _typeRange$16[ebp], 65535	; 0000ffffH

; 463  : 
; 464  : 			if (holeCount==0)

	movzx	eax, WORD PTR _holeCount$[ebp]
	test	eax, eax
	jne	SHORT $LN46@HandleSock

; 465  : 			{
; 466  : 				// Got what we were expecting
; 467  : 				if (hasReceivedPacketQueue.Size())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 927				; 0000039fH
	call	?Size@?$Queue@_J@DataStructures@@QBEIXZ	; DataStructures::Queue<__int64>::Size
	test	eax, eax
	je	SHORT $LN45@HandleSock

; 468  : 					hasReceivedPacketQueue.Pop();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 927				; 0000039fH
	call	?Pop@?$Queue@_J@DataStructures@@QAE_JXZ	; DataStructures::Queue<__int64>::Pop
$LN45@HandleSock:

; 469  : 				++receivedPacketsBaseIndex;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+943]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+943], cx
	jmp	$LN33@HandleSock
$LN46@HandleSock:

; 470  : 			}
; 471  : 			else if (holeCount > typeRange-typeRange/2)

	movzx	eax, WORD PTR _holeCount$[ebp]
	cmp	eax, 32768				; 00008000H
	jle	SHORT $LN43@HandleSock

; 472  : 			{
; 473  : 				// Underflow - got a packet we have already counted past
; 474  : 				statistics.duplicateMessagesReceived++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+903]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+903], ecx

; 475  : 
; 476  : 				// Duplicate packet
; 477  : 				delete [] internalPacket->data;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR [eax+47]
	mov	DWORD PTR $T5[ebp], ecx
	mov	edx, DWORD PTR $T5[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 478  : 				internalPacketPool.ReleasePointer( internalPacket );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	call	?ReleasePointer@InternalPacketPool@@QAEXPAUInternalPacket@@@Z ; InternalPacketPool::ReleasePointer

; 479  : 				goto CONTINUE_SOCKET_DATA_PARSE_LOOP;

	jmp	$CONTINUE_SOCKET_DATA_PARSE_LOOP$93
	jmp	$LN33@HandleSock
$LN43@HandleSock:

; 480  : 			}
; 481  : 			else if (holeCount<hasReceivedPacketQueue.Size())

	movzx	esi, WORD PTR _holeCount$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 927				; 0000039fH
	call	?Size@?$Queue@_J@DataStructures@@QBEIXZ	; DataStructures::Queue<__int64>::Size
	cmp	esi, eax
	jae	$LN35@HandleSock

; 482  : 			{
; 483  : 				// Got a higher count out of order packet that was missing in the sequence or we already got
; 484  : 				if (hasReceivedPacketQueue[holeCount]!=0) // non-zero means this is a hole

	movzx	eax, WORD PTR _holeCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 927				; 0000039fH
	call	??A?$Queue@_J@DataStructures@@QBEAA_JI@Z ; DataStructures::Queue<__int64>::operator[]
	mov	DWORD PTR tv860[ebp], eax
	mov	ecx, DWORD PTR tv860[ebp]
	mov	edx, DWORD PTR tv860[ebp]
	mov	eax, DWORD PTR [ecx]
	or	eax, DWORD PTR [edx+4]
	je	SHORT $LN39@HandleSock

; 485  : 				{
; 486  : 					// Fill in the hole
; 487  : 					hasReceivedPacketQueue[holeCount]=0; // We got the packet at holeCount

	movzx	eax, WORD PTR _holeCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 927				; 0000039fH
	call	??A?$Queue@_J@DataStructures@@QBEAA_JI@Z ; DataStructures::Queue<__int64>::operator[]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0

; 488  : 				}
; 489  : 				else

	jmp	SHORT $LN38@HandleSock
$LN39@HandleSock:

; 490  : 				{
; 491  : 					// Not a hole - just a duplicate packet
; 492  : 					statistics.duplicateMessagesReceived++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+903]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+903], ecx

; 493  : 
; 494  : 					// Duplicate packet
; 495  : 					delete [] internalPacket->data;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR [eax+47]
	mov	DWORD PTR $T6[ebp], ecx
	mov	edx, DWORD PTR $T6[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 496  : 					internalPacketPool.ReleasePointer( internalPacket );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	call	?ReleasePointer@InternalPacketPool@@QAEXPAUInternalPacket@@@Z ; InternalPacketPool::ReleasePointer

; 497  : 					goto CONTINUE_SOCKET_DATA_PARSE_LOOP;

	jmp	$CONTINUE_SOCKET_DATA_PARSE_LOOP$93
$LN38@HandleSock:

; 498  : 				}
; 499  : 			}
; 500  : 			else // holeCount>=receivedPackets.Size()

	jmp	$LN33@HandleSock
$LN35@HandleSock:

; 501  : 			{
; 502  : 				// Got a higher count out of order packet whose messageNumber is higher than we have ever got
; 503  : 
; 504  : 				// Add 0 times to the queue until (messageNumber - baseIndex) < queue size.
; 505  : 				while ((MessageNumberType)(holeCount) > hasReceivedPacketQueue.Size())

	movzx	esi, WORD PTR _holeCount$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 927				; 0000039fH
	call	?Size@?$Queue@_J@DataStructures@@QBEIXZ	; DataStructures::Queue<__int64>::Size
	cmp	esi, eax
	jbe	SHORT $LN34@HandleSock

; 506  : 					hasReceivedPacketQueue.Push(time+(RakNetTimeNS)timeoutTime*1000); // Didn't get this packet - set the time to give up waiting

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+723]
	mov	ecx, 1000				; 000003e8H
	mul	ecx
	add	eax, DWORD PTR _time$[ebp]
	adc	edx, DWORD PTR _time$[ebp+4]
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR $T7[ebp+4], edx
	lea	edx, DWORD PTR $T7[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 927				; 0000039fH
	call	?Push@?$Queue@_J@DataStructures@@QAEXAB_J@Z ; DataStructures::Queue<__int64>::Push
	jmp	SHORT $LN35@HandleSock
$LN34@HandleSock:

; 507  : 				hasReceivedPacketQueue.Push(0); // Got the packet

	xorpd	xmm0, xmm0
	movlpd	QWORD PTR $T8[ebp], xmm0
	lea	eax, DWORD PTR $T8[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 927				; 0000039fH
	call	?Push@?$Queue@_J@DataStructures@@QAEXAB_J@Z ; DataStructures::Queue<__int64>::Push

; 508  : #ifdef _DEBUG
; 509  : 				// If this assert hits then MessageNumberType has overflowed
; 510  : 				assert(hasReceivedPacketQueue.Size() < (unsigned int)((MessageNumberType)(-1)));

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 927				; 0000039fH
	call	?Size@?$Queue@_J@DataStructures@@QBEIXZ	; DataStructures::Queue<__int64>::Size
	cmp	eax, 65535				; 0000ffffH
	jb	SHORT $LN33@HandleSock
	mov	eax, DWORD PTR ?__LINE__Var@?1??HandleSocketReceiveFromConnectedPlayer@ReliabilityLayer@@QAE_NPBDHUPlayerID@@AAV?$List@PAVPluginInterface@@@DataStructures@@H@Z@4JA
	add	eax, 177				; 000000b1H
	push	eax
	push	OFFSET ??_C@_1FK@FKLHGKMO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAe?$AAl?$AAi?$AAa?$AAb?$AAi?$AAl@
	push	OFFSET ??_C@_1JA@FAAHMOBE@?$AAh?$AAa?$AAs?$AAR?$AAe?$AAc?$AAe?$AAi?$AAv?$AAe?$AAd?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AAQ?$AAu?$AAe?$AAu?$AAe?$AA?4?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?5@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN33@HandleSock:

; 511  : #endif
; 512  : 			}
; 513  : 
; 514  : 			// Pop all expired times.  0 means we got the packet, in which case we don't track this index either.
; 515  : 			while ( hasReceivedPacketQueue.Size()>0 && hasReceivedPacketQueue.Peek() < time )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 927				; 0000039fH
	call	?Size@?$Queue@_J@DataStructures@@QBEIXZ	; DataStructures::Queue<__int64>::Size
	test	eax, eax
	jbe	SHORT $LN32@HandleSock
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 927				; 0000039fH
	call	?Peek@?$Queue@_J@DataStructures@@QBE_JXZ ; DataStructures::Queue<__int64>::Peek
	mov	DWORD PTR tv908[ebp], eax
	mov	DWORD PTR tv908[ebp+4], edx
	mov	eax, DWORD PTR tv908[ebp+4]
	cmp	eax, DWORD PTR _time$[ebp+4]
	jg	SHORT $LN32@HandleSock
	jl	SHORT $LN85@HandleSock
	mov	ecx, DWORD PTR tv908[ebp]
	cmp	ecx, DWORD PTR _time$[ebp]
	jae	SHORT $LN32@HandleSock
$LN85@HandleSock:

; 516  : 			{
; 517  : 				hasReceivedPacketQueue.Pop();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 927				; 0000039fH
	call	?Pop@?$Queue@_J@DataStructures@@QAE_JXZ	; DataStructures::Queue<__int64>::Pop

; 518  : 				++receivedPacketsBaseIndex;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+943]
	add	cx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+943], cx

; 519  : 			}

	jmp	SHORT $LN33@HandleSock
$LN32@HandleSock:

; 520  : 
; 521  : 			statistics.messagesReceived++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+895]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+895], ecx

; 522  : 
; 523  : 			// If the allocated buffer is > DEFAULT_HAS_RECEIVED_PACKET_QUEUE_SIZE and it is 3x greater than the number of elements actually being used
; 524  : 			if (hasReceivedPacketQueue.AllocationSize() > (unsigned int) DEFAULT_HAS_RECEIVED_PACKET_QUEUE_SIZE && hasReceivedPacketQueue.AllocationSize() > hasReceivedPacketQueue.Size() * 3)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 927				; 0000039fH
	call	?AllocationSize@?$Queue@_J@DataStructures@@QBEIXZ ; DataStructures::Queue<__int64>::AllocationSize
	cmp	eax, 512				; 00000200H
	jbe	SHORT $LN31@HandleSock
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 927				; 0000039fH
	call	?AllocationSize@?$Queue@_J@DataStructures@@QBEIXZ ; DataStructures::Queue<__int64>::AllocationSize
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 927				; 0000039fH
	call	?Size@?$Queue@_J@DataStructures@@QBEIXZ	; DataStructures::Queue<__int64>::Size
	imul	eax, eax, 3
	cmp	esi, eax
	jbe	SHORT $LN31@HandleSock

; 525  : 				hasReceivedPacketQueue.Compress();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 927				; 0000039fH
	call	?Compress@?$Queue@_J@DataStructures@@QAEXXZ ; DataStructures::Queue<__int64>::Compress
$LN31@HandleSock:

; 526  : 
; 527  : 			// Keep on top of deleting old unreliable split packets so they don't clog the list.
; 528  : 			if ( internalPacket->splitPacketCount > 0 )

	mov	eax, DWORD PTR _internalPacket$[ebp]
	cmp	DWORD PTR [eax+23], 0
	jbe	SHORT $LN30@HandleSock

; 529  : 				DeleteOldUnreliableSplitPackets( time );

	mov	eax, DWORD PTR _time$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _time$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DeleteOldUnreliableSplitPackets@ReliabilityLayer@@AAEX_J@Z ; ReliabilityLayer::DeleteOldUnreliableSplitPackets
$LN30@HandleSock:

; 530  : 
; 531  : 			if ( internalPacket->reliability == RELIABLE_SEQUENCED || internalPacket->reliability == UNRELIABLE_SEQUENCED )

	mov	eax, DWORD PTR _internalPacket$[ebp]
	cmp	DWORD PTR [eax+10], 4
	je	SHORT $LN28@HandleSock
	mov	eax, DWORD PTR _internalPacket$[ebp]
	cmp	DWORD PTR [eax+10], 1
	jne	$LN29@HandleSock
$LN28@HandleSock:

; 532  : 			{
; 533  : #ifdef _DEBUG
; 534  : 				assert( internalPacket->orderingChannel < NUMBER_OF_ORDERED_STREAMS );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	movzx	ecx, BYTE PTR [eax+14]
	cmp	ecx, 32					; 00000020H
	jl	SHORT $LN78@HandleSock
	mov	edx, DWORD PTR ?__LINE__Var@?1??HandleSocketReceiveFromConnectedPlayer@ReliabilityLayer@@QAE_NPBDHUPlayerID@@AAV?$List@PAVPluginInterface@@@DataStructures@@H@Z@4JA
	add	edx, 201				; 000000c9H
	push	edx
	push	OFFSET ??_C@_1FK@FKLHGKMO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAe?$AAl?$AAi?$AAa?$AAb?$AAi?$AAl@
	push	OFFSET ??_C@_1HI@MKMNOBIC@?$AAi?$AAn?$AAt?$AAe?$AAr?$AAn?$AAa?$AAl?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?9?$AA?$DO?$AAo?$AAr?$AAd?$AAe?$AAr?$AAi?$AAn?$AAg?$AAC?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AA?5@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN78@HandleSock:

; 535  : #endif
; 536  : 
; 537  : 				if ( internalPacket->orderingChannel >= NUMBER_OF_ORDERED_STREAMS )

	mov	eax, DWORD PTR _internalPacket$[ebp]
	movzx	ecx, BYTE PTR [eax+14]
	cmp	ecx, 32					; 00000020H
	jl	SHORT $LN27@HandleSock

; 538  : 				{
; 539  : 					// Invalid packet
; 540  : #ifdef _DEBUG
; 541  : 					printf( "Got invalid packet\n" );

	push	OFFSET ??_C@_0BE@HCJJFHJF@Got?5invalid?5packet?6?$AA@
	call	_printf
	add	esp, 4

; 542  : #endif
; 543  : 
; 544  : 					delete [] internalPacket->data;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR [eax+47]
	mov	DWORD PTR $T9[ebp], ecx
	mov	edx, DWORD PTR $T9[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 545  : 					internalPacketPool.ReleasePointer( internalPacket );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	call	?ReleasePointer@InternalPacketPool@@QAEXPAUInternalPacket@@@Z ; InternalPacketPool::ReleasePointer

; 546  : 					goto CONTINUE_SOCKET_DATA_PARSE_LOOP;

	jmp	$CONTINUE_SOCKET_DATA_PARSE_LOOP$93
$LN27@HandleSock:

; 547  : 				}
; 548  : 
; 549  : 				if ( IsOlderOrderedPacket( internalPacket->orderingIndex, waitingForSequencedPacketReadIndex[ internalPacket->orderingChannel ] ) == false )

	mov	eax, DWORD PTR _internalPacket$[ebp]
	movzx	ecx, BYTE PTR [eax+14]
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, WORD PTR [edx+ecx*2+651]
	push	eax
	mov	ecx, DWORD PTR _internalPacket$[ebp]
	movzx	edx, WORD PTR [ecx+15]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsOlderOrderedPacket@ReliabilityLayer@@AAE_NGG@Z ; ReliabilityLayer::IsOlderOrderedPacket
	movzx	eax, al
	test	eax, eax
	jne	$LN25@HandleSock

; 550  : 				{
; 551  : 					statistics.sequencedMessagesInOrder++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+859]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+859], ecx

; 552  : 
; 553  : 
; 554  : 					// Is this a split packet?
; 555  : 					if ( internalPacket->splitPacketCount > 0 )

	mov	eax, DWORD PTR _internalPacket$[ebp]
	cmp	DWORD PTR [eax+23], 0
	jbe	$LN24@HandleSock

; 556  : 					{
; 557  : 						// Generate the split
; 558  : 						// Verify some parameters to make sure we don't get junk data
; 559  : 
; 560  : 
; 561  : 						// Check for a rebuilt packet
; 562  : 						InsertIntoSplitPacketList( internalPacket, time );

	mov	eax, DWORD PTR _time$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _time$[ebp]
	push	ecx
	mov	edx, DWORD PTR _internalPacket$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertIntoSplitPacketList@ReliabilityLayer@@AAEXPAUInternalPacket@@_J@Z ; ReliabilityLayer::InsertIntoSplitPacketList

; 563  : 
; 564  : 						// Sequenced
; 565  : 						internalPacket = BuildPacketFromSplitPacketList( internalPacket->splitPacketId, time );

	mov	eax, DWORD PTR _time$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _time$[ebp]
	push	ecx
	mov	edx, DWORD PTR _internalPacket$[ebp]
	movzx	eax, WORD PTR [edx+17]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildPacketFromSplitPacketList@ReliabilityLayer@@AAEPAUInternalPacket@@G_J@Z ; ReliabilityLayer::BuildPacketFromSplitPacketList
	mov	DWORD PTR _internalPacket$[ebp], eax

; 566  : 
; 567  : 						if ( internalPacket )

	cmp	DWORD PTR _internalPacket$[ebp], 0
	je	SHORT $LN23@HandleSock

; 568  : 						{
; 569  : 							// Update our index to the newest packet
; 570  : 							waitingForSequencedPacketReadIndex[ internalPacket->orderingChannel ] = internalPacket->orderingIndex + 1;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	movzx	ecx, WORD PTR [eax+15]
	add	ecx, 1
	mov	edx, DWORD PTR _internalPacket$[ebp]
	movzx	eax, BYTE PTR [edx+14]
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+eax*2+651], cx

; 571  : 
; 572  : 							// If there is a rebuilt packet, add it to the output queue
; 573  : 							outputQueue.Push( internalPacket );

	lea	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?Push@?$Queue@PAUInternalPacket@@@DataStructures@@QAEXABQAUInternalPacket@@@Z ; DataStructures::Queue<InternalPacket *>::Push

; 574  : 							internalPacket = 0;

	mov	DWORD PTR _internalPacket$[ebp], 0
$LN23@HandleSock:

; 575  : 						}
; 576  : 
; 577  : 						// else don't have all the parts yet
; 578  : 					}
; 579  : 
; 580  : 					else

	jmp	SHORT $LN22@HandleSock
$LN24@HandleSock:

; 581  : 					{
; 582  : 						// Update our index to the newest packet
; 583  : 						waitingForSequencedPacketReadIndex[ internalPacket->orderingChannel ] = internalPacket->orderingIndex + 1;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	movzx	ecx, WORD PTR [eax+15]
	add	ecx, 1
	mov	edx, DWORD PTR _internalPacket$[ebp]
	movzx	eax, BYTE PTR [edx+14]
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+eax*2+651], cx

; 584  : 
; 585  : 						// Not a split packet. Add the packet to the output queue
; 586  : 						outputQueue.Push( internalPacket );

	lea	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?Push@?$Queue@PAUInternalPacket@@@DataStructures@@QAEXABQAUInternalPacket@@@Z ; DataStructures::Queue<InternalPacket *>::Push

; 587  : 						internalPacket = 0;

	mov	DWORD PTR _internalPacket$[ebp], 0
$LN22@HandleSock:

; 588  : 					}
; 589  : 				}
; 590  : 				else

	jmp	SHORT __unwind$?HandleSocketReceiveFromConnectedPlayer@ReliabilityLayer@@QAE_NPBDHUPlayerID@@AAV?$List@PAVPluginInterface@@@DataStructures@@H@Z$3
$LN25@HandleSock:

; 591  : 				{
; 592  : 					statistics.sequencedMessagesOutOfOrder++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+855]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+855], ecx

; 593  : 
; 594  : 					// Older sequenced packet. Discard it
; 595  : 					delete [] internalPacket->data;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR [eax+47]
	mov	DWORD PTR $T10[ebp], ecx
	mov	edx, DWORD PTR $T10[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 596  : 					internalPacketPool.ReleasePointer( internalPacket );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	call	?ReleasePointer@InternalPacketPool@@QAEXPAUInternalPacket@@@Z ; InternalPacketPool::ReleasePointer
__unwind$?HandleSocketReceiveFromConnectedPlayer@ReliabilityLayer@@QAE_NPBDHUPlayerID@@AAV?$List@PAVPluginInterface@@@DataStructures@@H@Z$3:

; 597  : 				}
; 598  : 
; 599  : 				goto CONTINUE_SOCKET_DATA_PARSE_LOOP;

	jmp	$CONTINUE_SOCKET_DATA_PARSE_LOOP$93
$LN29@HandleSock:

; 600  : 			}
; 601  : 
; 602  : 			// Is this an unsequenced split packet?
; 603  : 			if ( internalPacket->splitPacketCount > 0 )

	mov	eax, DWORD PTR _internalPacket$[ebp]
	cmp	DWORD PTR [eax+23], 0
	jbe	SHORT $LN19@HandleSock

; 604  : 			{
; 605  : 				// An unsequenced split packet.  May be ordered though.
; 606  : 
; 607  : 				// Check for a rebuilt packet
; 608  : 				if ( internalPacket->reliability != RELIABLE_ORDERED )

	mov	eax, DWORD PTR _internalPacket$[ebp]
	cmp	DWORD PTR [eax+10], 3
	je	SHORT $LN18@HandleSock

; 609  : 					internalPacket->orderingChannel = 255; // Use 255 to designate not sequenced and not ordered

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	BYTE PTR [eax+14], 255			; 000000ffH
$LN18@HandleSock:

; 610  : 
; 611  : 				InsertIntoSplitPacketList( internalPacket, time );

	mov	eax, DWORD PTR _time$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _time$[ebp]
	push	ecx
	mov	edx, DWORD PTR _internalPacket$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertIntoSplitPacketList@ReliabilityLayer@@AAEXPAUInternalPacket@@_J@Z ; ReliabilityLayer::InsertIntoSplitPacketList

; 612  : 
; 613  : 				internalPacket = BuildPacketFromSplitPacketList( internalPacket->splitPacketId, time );

	mov	eax, DWORD PTR _time$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _time$[ebp]
	push	ecx
	mov	edx, DWORD PTR _internalPacket$[ebp]
	movzx	eax, WORD PTR [edx+17]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildPacketFromSplitPacketList@ReliabilityLayer@@AAEPAUInternalPacket@@G_J@Z ; ReliabilityLayer::BuildPacketFromSplitPacketList
	mov	DWORD PTR _internalPacket$[ebp], eax

; 614  : 
; 615  : 				if ( internalPacket == 0 )

	cmp	DWORD PTR _internalPacket$[ebp], 0
	jne	SHORT $LN19@HandleSock

; 616  : 				{
; 617  : 
; 618  : 					// Don't have all the parts yet
; 619  : 					goto CONTINUE_SOCKET_DATA_PARSE_LOOP;

	jmp	$CONTINUE_SOCKET_DATA_PARSE_LOOP$93
$LN19@HandleSock:

; 620  : 				}
; 621  : 
; 622  : 				// else continue down to handle RELIABLE_ORDERED
; 623  : 			}
; 624  : 
; 625  : 			if ( internalPacket->reliability == RELIABLE_ORDERED )

	mov	eax, DWORD PTR _internalPacket$[ebp]
	cmp	DWORD PTR [eax+10], 3
	jne	$LN15@HandleSock

; 626  : 			{
; 627  : #ifdef _DEBUG
; 628  : 				assert( internalPacket->orderingChannel < NUMBER_OF_ORDERED_STREAMS );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	movzx	ecx, BYTE PTR [eax+14]
	cmp	ecx, 32					; 00000020H
	jl	SHORT $LN79@HandleSock
	mov	edx, DWORD PTR ?__LINE__Var@?1??HandleSocketReceiveFromConnectedPlayer@ReliabilityLayer@@QAE_NPBDHUPlayerID@@AAV?$List@PAVPluginInterface@@@DataStructures@@H@Z@4JA
	add	edx, 295				; 00000127H
	push	edx
	push	OFFSET ??_C@_1FK@FKLHGKMO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAe?$AAl?$AAi?$AAa?$AAb?$AAi?$AAl@
	push	OFFSET ??_C@_1HI@MKMNOBIC@?$AAi?$AAn?$AAt?$AAe?$AAr?$AAn?$AAa?$AAl?$AAP?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?9?$AA?$DO?$AAo?$AAr?$AAd?$AAe?$AAr?$AAi?$AAn?$AAg?$AAC?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AA?5@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN79@HandleSock:

; 629  : #endif
; 630  : 
; 631  : 				if ( internalPacket->orderingChannel >= NUMBER_OF_ORDERED_STREAMS )

	mov	eax, DWORD PTR _internalPacket$[ebp]
	movzx	ecx, BYTE PTR [eax+14]
	cmp	ecx, 32					; 00000020H
	jl	SHORT $LN14@HandleSock

; 632  : 				{
; 633  : #ifdef _DEBUG
; 634  : 					printf("Got invalid ordering channel %i from packet %i\n", internalPacket->orderingChannel, internalPacket->messageNumber);

	mov	eax, DWORD PTR _internalPacket$[ebp]
	movzx	ecx, WORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _internalPacket$[ebp]
	movzx	eax, BYTE PTR [edx+14]
	push	eax
	push	OFFSET ??_C@_0DA@MOADJCKG@Got?5invalid?5ordering?5channel?5?$CFi?5@
	call	_printf
	add	esp, 12					; 0000000cH

; 635  : #endif
; 636  : 					// Invalid packet
; 637  : 					delete [] internalPacket->data;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	ecx, DWORD PTR [eax+47]
	mov	DWORD PTR $T11[ebp], ecx
	mov	edx, DWORD PTR $T11[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 638  : 					internalPacketPool.ReleasePointer( internalPacket );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	call	?ReleasePointer@InternalPacketPool@@QAEXPAUInternalPacket@@@Z ; InternalPacketPool::ReleasePointer

; 639  : 					goto CONTINUE_SOCKET_DATA_PARSE_LOOP;

	jmp	$CONTINUE_SOCKET_DATA_PARSE_LOOP$93
$LN14@HandleSock:

; 640  : 				}
; 641  : 
; 642  : 				if ( waitingForOrderedPacketReadIndex[ internalPacket->orderingChannel ] == internalPacket->orderingIndex )

	mov	eax, DWORD PTR _internalPacket$[ebp]
	movzx	ecx, BYTE PTR [eax+14]
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, WORD PTR [edx+ecx*2+587]
	mov	ecx, DWORD PTR _internalPacket$[ebp]
	movzx	edx, WORD PTR [ecx+15]
	cmp	eax, edx
	jne	$LN12@HandleSock

; 643  : 				{
; 644  : 					// Get the list to hold ordered packets for this stream
; 645  : 					DataStructures::LinkedList<InternalPacket*> *orderingListAtOrderingStream;
; 646  : 					unsigned char orderingChannelCopy = internalPacket->orderingChannel;

	mov	eax, DWORD PTR _internalPacket$[ebp]
	mov	cl, BYTE PTR [eax+14]
	mov	BYTE PTR _orderingChannelCopy$14[ebp], cl

; 647  : 
; 648  : 					statistics.orderedMessagesInOrder++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+867]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+867], ecx

; 649  : 
; 650  : 					// Show ordering index increment
; 651  : 					//printf("Pushing immediate packet %i with ordering index %i\n", internalPacket->messageNumber, internalPacket->orderingIndex );
; 652  : 
; 653  : 					// Push the packet for the user to read
; 654  : 					outputQueue.Push( internalPacket );

	lea	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?Push@?$Queue@PAUInternalPacket@@@DataStructures@@QAEXABQAUInternalPacket@@@Z ; DataStructures::Queue<InternalPacket *>::Push

; 655  : 					internalPacket = 0; // Don't reference this any longer since other threads access it

	mov	DWORD PTR _internalPacket$[ebp], 0

; 656  : 
; 657  : 					// Wait for the next ordered packet in sequence
; 658  : 					waitingForOrderedPacketReadIndex[ orderingChannelCopy ] ++; // This wraps

	movzx	eax, BYTE PTR _orderingChannelCopy$14[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+eax*2+587]
	add	dx, 1
	movzx	eax, BYTE PTR _orderingChannelCopy$14[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+eax*2+587], dx

; 659  : 
; 660  : 					orderingListAtOrderingStream = GetOrderingListAtOrderingStream( orderingChannelCopy );

	movzx	eax, BYTE PTR _orderingChannelCopy$14[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOrderingListAtOrderingStream@ReliabilityLayer@@AAEPAV?$LinkedList@PAUInternalPacket@@@DataStructures@@E@Z ; ReliabilityLayer::GetOrderingListAtOrderingStream
	mov	DWORD PTR _orderingListAtOrderingStream$15[ebp], eax

; 661  : 
; 662  : 					if ( orderingListAtOrderingStream != 0)

	cmp	DWORD PTR _orderingListAtOrderingStream$15[ebp], 0
	je	$LN11@HandleSock
$LN10@HandleSock:

; 663  : 					{
; 664  : 						while ( orderingListAtOrderingStream->Size() > 0 )

	mov	ecx, DWORD PTR _orderingListAtOrderingStream$15[ebp]
	call	?Size@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEIXZ ; DataStructures::CircularLinkedList<InternalPacket *>::Size
	test	eax, eax
	jbe	$LN11@HandleSock

; 665  : 						{
; 666  : 							// Cycle through the list until nothing is found
; 667  : 							orderingListAtOrderingStream->Beginning();

	mov	ecx, DWORD PTR _orderingListAtOrderingStream$15[ebp]
	call	?Beginning@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEXXZ ; DataStructures::CircularLinkedList<InternalPacket *>::Beginning

; 668  : 							indexFound=false;

	mov	BYTE PTR _indexFound$[ebp], 0

; 669  : 							size=orderingListAtOrderingStream->Size();

	mov	ecx, DWORD PTR _orderingListAtOrderingStream$15[ebp]
	call	?Size@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEIXZ ; DataStructures::CircularLinkedList<InternalPacket *>::Size
	mov	DWORD PTR _size$[ebp], eax

; 670  : 							count=0;

	mov	DWORD PTR _count$[ebp], 0
$LN8@HandleSock:

; 671  : 
; 672  : 							while (count++ < size)

	mov	eax, DWORD PTR _count$[ebp]
	mov	DWORD PTR tv582[ebp], eax
	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR tv583[ebp], ecx
	mov	edx, DWORD PTR _count$[ebp]
	add	edx, 1
	mov	DWORD PTR _count$[ebp], edx
	mov	eax, DWORD PTR tv582[ebp]
	cmp	eax, DWORD PTR tv583[ebp]
	jge	SHORT $LN80@HandleSock
	mov	DWORD PTR tv584[ebp], 1
	jmp	SHORT $LN81@HandleSock
$LN80@HandleSock:
	mov	DWORD PTR tv584[ebp], 0
$LN81@HandleSock:
	cmp	DWORD PTR tv584[ebp], 0
	je	$LN7@HandleSock

; 673  : 							{
; 674  : 								if ( orderingListAtOrderingStream->Peek()->orderingIndex == waitingForOrderedPacketReadIndex[ orderingChannelCopy ] )

	mov	ecx, DWORD PTR _orderingListAtOrderingStream$15[ebp]
	call	?Peek@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEAAPAUInternalPacket@@XZ ; DataStructures::CircularLinkedList<InternalPacket *>::Peek
	mov	eax, DWORD PTR [eax]
	movzx	ecx, WORD PTR [eax+15]
	movzx	edx, BYTE PTR _orderingChannelCopy$14[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [eax+edx*2+587]
	cmp	ecx, edx
	jne	SHORT $LN6@HandleSock

; 675  : 								{
; 676  : 									/*
; 677  : 									RakNet::BitStream temp(orderingListAtOrderingStream->Peek()->data, BITS_TO_BYTES(orderingListAtOrderingStream->Peek()->dataBitLength), false);
; 678  : 									temp.IgnoreBits(8);
; 679  : 									unsigned int receivedPacketNumber=0;
; 680  : 									temp.Read(receivedPacketNumber);
; 681  : 									printf("Receive: receivedPacketNumber=%i orderingIndex=%i waitingFor=%i\n", receivedPacketNumber, orderingListAtOrderingStream->Peek()->orderingIndex, waitingForOrderedPacketReadIndex[ orderingChannelCopy ]);
; 682  : 									*/
; 683  : 
; 684  : 									//printf("Pushing delayed packet %i with ordering index %i. outputQueue.Size()==%i\n", orderingListAtOrderingStream->Peek()->messageNumber, orderingListAtOrderingStream->Peek()->orderingIndex, outputQueue.Size() );
; 685  : 									outputQueue.Push( orderingListAtOrderingStream->Pop() );

	mov	ecx, DWORD PTR _orderingListAtOrderingStream$15[ebp]
	call	?Pop@?$CircularLinkedList@PAUInternalPacket@@@DataStructures@@QAEPAUInternalPacket@@XZ ; DataStructures::CircularLinkedList<InternalPacket *>::Pop
	mov	DWORD PTR $T12[ebp], eax
	lea	eax, DWORD PTR $T12[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?Push@?$Queue@PAUInternalPacket@@@DataStructures@@QAEXABQAUInternalPacket@@@Z ; DataStructures::Queue<InternalPacket *>::Push

; 686  : 									waitingForOrderedPacketReadIndex[ orderingChannelCopy ]++; // This wraps at 255

	movzx	eax, BYTE PTR _orderingChannelCopy$14[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+eax*2+587]
	add	dx, 1
	movzx	eax, BYTE PTR _orderingChannelCopy$14[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+eax*2+587], dx

; 687  : 									indexFound=true;

	mov	BYTE PTR _indexFound$[ebp], 1

; 688  : 								}
; 689  : 								else

	jmp	SHORT $LN5@HandleSock
$LN6@HandleSock:

; 690  : 									(*orderingListAtOrderingStream)++;

	push	0
	mov	ecx, DWORD PTR _orderingListAtOrderingStream$15[ebp]
	call	??E?$LinkedList@PAUInternalPacket@@@DataStructures@@QAEAAV01@H@Z ; DataStructures::LinkedList<InternalPacket *>::operator++
$LN5@HandleSock:

; 691  : 							}

	jmp	$LN8@HandleSock
$LN7@HandleSock:

; 692  : 
; 693  : 							if (indexFound==false)

	movzx	eax, BYTE PTR _indexFound$[ebp]
	test	eax, eax
	jne	SHORT $LN4@HandleSock

; 694  : 								break;

	jmp	SHORT $LN11@HandleSock
$LN4@HandleSock:

; 695  : 						}

	jmp	$LN10@HandleSock
$LN11@HandleSock:

; 696  : 					}
; 697  : 
; 698  : 					internalPacket = 0;

	mov	DWORD PTR _internalPacket$[ebp], 0

; 699  : 				}
; 700  : 				else

	jmp	SHORT __unwind$?HandleSocketReceiveFromConnectedPlayer@ReliabilityLayer@@QAE_NPBDHUPlayerID@@AAV?$List@PAVPluginInterface@@@DataStructures@@H@Z$6
$LN12@HandleSock:

; 701  : 				{
; 702  : 				//	assert(waitingForOrderedPacketReadIndex[ internalPacket->orderingChannel ] < internalPacket->orderingIndex);
; 703  : 					statistics.orderedMessagesOutOfOrder++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+863]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+863], ecx

; 704  : 
; 705  : 					// This is a newer ordered packet than we are waiting for. Store it for future use
; 706  : 					AddToOrderingList( internalPacket );

	mov	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddToOrderingList@ReliabilityLayer@@AAEXPAUInternalPacket@@@Z ; ReliabilityLayer::AddToOrderingList
__unwind$?HandleSocketReceiveFromConnectedPlayer@ReliabilityLayer@@QAE_NPBDHUPlayerID@@AAV?$List@PAVPluginInterface@@@DataStructures@@H@Z$6:

; 707  : 				}
; 708  : 
; 709  : 				goto CONTINUE_SOCKET_DATA_PARSE_LOOP;

	jmp	SHORT $CONTINUE_SOCKET_DATA_PARSE_LOOP$93
$LN15@HandleSock:

; 710  : 			}
; 711  : 
; 712  : 			// Nothing special about this packet.  Add it to the output queue
; 713  : 			outputQueue.Push( internalPacket );

	lea	eax, DWORD PTR _internalPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?Push@?$Queue@PAUInternalPacket@@@DataStructures@@QAEXABQAUInternalPacket@@@Z ; DataStructures::Queue<InternalPacket *>::Push

; 714  : 
; 715  : 			internalPacket = 0;

	mov	DWORD PTR _internalPacket$[ebp], 0
$CONTINUE_SOCKET_DATA_PARSE_LOOP$93:

; 716  : 		}
; 717  : 
; 718  : 		// Used for a goto to jump to the next packet immediately
; 719  : 
; 720  : 	CONTINUE_SOCKET_DATA_PARSE_LOOP:
; 721  : 		// Parse the bitstream to create an internal packet
; 722  : 		internalPacket = CreateInternalPacketFromBitStream( &socketData, time );

	mov	eax, DWORD PTR _time$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _time$[ebp]
	push	ecx
	lea	edx, DWORD PTR _socketData$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CreateInternalPacketFromBitStream@ReliabilityLayer@@AAEPAUInternalPacket@@PAVBitStream@RakNet@@_J@Z ; ReliabilityLayer::CreateInternalPacketFromBitStream
	mov	DWORD PTR _internalPacket$[ebp], eax

; 723  : 	}

	jmp	$LN54@HandleSock
$LN53@HandleSock:

; 724  : 
; 725  : 	/*
; 726  : 	if (numberOfAcksInFrame > 0)
; 727  : //		if (time > lastWindowAdjustTime+ping)
; 728  : 	{
; 729  : 	//	printf("Window size up\n");
; 730  : 		windowSize+=1 + numberOfAcksInFrame/windowSize;
; 731  : 		if ( windowSize > MAXIMUM_WINDOW_SIZE )
; 732  : 			windowSize = MAXIMUM_WINDOW_SIZE;
; 733  : 		//lastWindowAdjustTime=time;
; 734  : 	}
; 735  : 	//else
; 736  : 	//	printf("No acks in frame\n");
; 737  : */
; 738  : 	/*
; 739  : 	// numberOfAcksInFrame>=windowSize means that all the packets we last sent from the resendList are cleared out
; 740  : 	// 11/17/05 - the problem with numberOfAcksInFrame >= windowSize is that if the entire frame is filled with resends but not all resends filled the frame
; 741  : 	// then the sender is limited by how many resends can fit in one frame
; 742  : 	if ( numberOfAcksInFrame >= windowSize && ( sendPacketSet[ SYSTEM_PRIORITY ].Size() > 0 || sendPacketSet[ HIGH_PRIORITY ].Size() > 0 || sendPacketSet[ MEDIUM_PRIORITY ].Size() > 0 ) )
; 743  : 	{
; 744  : 		// reliabilityLayerMutexes[windowSize_MUTEX].Lock();
; 745  : 		//printf("windowSize=%i lossyWindowSize=%i\n", windowSize, lossyWindowSize);
; 746  : 
; 747  : 		if ( windowSize < lossyWindowSize || (time>lastWindowIncreaseSizeTime && time-lastWindowIncreaseSizeTime>lostPacketResendDelay*2) )   // Increases the window size slowly, testing for packetloss
; 748  : 		{
; 749  : 			// If we get a frame which clears out the resend queue after handling one or more acks, and we have packets waiting to go out,
; 750  : 			// and we didn't recently lose a packet then increase the window size by 1
; 751  : 			windowSize++;
; 752  : 
; 753  : 			if ( (time>lastWindowIncreaseSizeTime && time-lastWindowIncreaseSizeTime>lostPacketResendDelay*2) )   // The increase is to test for packetloss
; 754  : 				lastWindowIncreaseSizeTime = time;
; 755  : 
; 756  : 			// If the window is so large that we couldn't possibly fit any more packets into the frame, then just leave it alone
; 757  : 			if ( windowSize > MAXIMUM_WINDOW_SIZE )
; 758  : 				windowSize = MAXIMUM_WINDOW_SIZE;
; 759  : 
; 760  : 			// SHOW - WINDOWING
; 761  : 			//else
; 762  : 			//	printf("Increasing windowSize to %i.  Lossy window size = %i\n", windowSize, lossyWindowSize);
; 763  : 
; 764  : 			// If we are more than 5 over the lossy window size, increase the lossy window size by 1
; 765  : 			if ( windowSize == MAXIMUM_WINDOW_SIZE || windowSize - lossyWindowSize > 5 )
; 766  : 				lossyWindowSize++;
; 767  : 		}
; 768  : 		// reliabilityLayerMutexes[windowSize_MUTEX].Unlock();
; 769  : 	}
; 770  : 	*/
; 771  : 
; 772  : 	if (hasAcks)

	movzx	eax, BYTE PTR _hasAcks$[ebp]
	test	eax, eax
	je	SHORT $LN1@HandleSock

; 773  : 	{
; 774  : 		UpdateWindowFromAck(time);

	mov	eax, DWORD PTR _time$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _time$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateWindowFromAck@ReliabilityLayer@@AAEX_J@Z ; ReliabilityLayer::UpdateWindowFromAck
$LN1@HandleSock:

; 775  : 	}
; 776  : 
; 777  : 	receivePacketCount++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1633]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1633], ecx

; 778  : 
; 779  : 	return true;

	mov	BYTE PTR $T13[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _incomingAcks$[ebp]
	call	??1?$RangeList@G@DataStructures@@QAE@XZ	; DataStructures::RangeList<unsigned short>::~RangeList<unsigned short>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _socketData$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	al, BYTE PTR $T13[ebp]
$LN72@HandleSock:

; 780  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN92@HandleSock
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 848				; 00000350H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
	npad	2
$LN92@HandleSock:
	DD	4
	DD	$LN91@HandleSock
$LN91@HandleSock:
	DD	-121					; ffffff87H
	DD	1
	DD	$LN86@HandleSock
	DD	-408					; fffffe68H
	DD	273					; 00000111H
	DD	$LN87@HandleSock
	DD	-428					; fffffe54H
	DD	12					; 0000000cH
	DD	$LN88@HandleSock
	DD	-452					; fffffe3cH
	DD	4
	DD	$LN89@HandleSock
$LN89@HandleSock:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	0
$LN88@HandleSock:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	109					; 0000006dH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	65					; 00000041H
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	115					; 00000073H
	DB	0
$LN87@HandleSock:
	DB	115					; 00000073H
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
$LN86@HandleSock:
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	65					; 00000041H
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	115					; 00000073H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?HandleSocketReceiveFromConnectedPlayer@ReliabilityLayer@@QAE_NPBDHUPlayerID@@AAV?$List@PAVPluginInterface@@@DataStructures@@H@Z$7:
	lea	ecx, DWORD PTR _socketData$[ebp]
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__unwindfunclet$?HandleSocketReceiveFromConnectedPlayer@ReliabilityLayer@@QAE_NPBDHUPlayerID@@AAV?$List@PAVPluginInterface@@@DataStructures@@H@Z$8:
	lea	ecx, DWORD PTR _incomingAcks$[ebp]
	jmp	??1?$RangeList@G@DataStructures@@QAE@XZ	; DataStructures::RangeList<unsigned short>::~RangeList<unsigned short>
__ehhandler$?HandleSocketReceiveFromConnectedPlayer@ReliabilityLayer@@QAE_NPBDHUPlayerID@@AAV?$List@PAVPluginInterface@@@DataStructures@@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-852]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?HandleSocketReceiveFromConnectedPlayer@ReliabilityLayer@@QAE_NPBDHUPlayerID@@AAV?$List@PAVPluginInterface@@@DataStructures@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?HandleSocketReceiveFromConnectedPlayer@ReliabilityLayer@@QAE_NPBDHUPlayerID@@AAV?$List@PAVPluginInterface@@@DataStructures@@H@Z ENDP ; ReliabilityLayer::HandleSocketReceiveFromConnectedPlayer
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?GetTimeoutTime@ReliabilityLayer@@QAEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetTimeoutTime@ReliabilityLayer@@QAEIXZ PROC		; ReliabilityLayer::GetTimeoutTime, COMDAT
; _this$ = ecx

; 171  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 172  : 	return timeoutTime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+723]

; 173  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTimeoutTime@ReliabilityLayer@@QAEIXZ ENDP		; ReliabilityLayer::GetTimeoutTime
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?SetTimeoutTime@ReliabilityLayer@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_time$ = 8						; size = 4
?SetTimeoutTime@ReliabilityLayer@@QAEXI@Z PROC		; ReliabilityLayer::SetTimeoutTime, COMDAT
; _this$ = ecx

; 163  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 164  : 	timeoutTime=time;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _time$[ebp]
	mov	DWORD PTR [eax+723], ecx

; 165  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetTimeoutTime@ReliabilityLayer@@QAEXI@Z ENDP		; ReliabilityLayer::SetTimeoutTime
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?GetSocket@ReliabilityLayer@@QAEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetSocket@ReliabilityLayer@@QAEIXZ PROC		; ReliabilityLayer::GetSocket, COMDAT
; _this$ = ecx

; 150  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 151  : #ifdef __USE_IO_COMPLETION_PORTS
; 152  : 	return readWriteSocket;
; 153  : #else
; 154  : 
; 155  : 	return INVALID_SOCKET;

	or	eax, -1

; 156  : #endif
; 157  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSocket@ReliabilityLayer@@QAEIXZ ENDP		; ReliabilityLayer::GetSocket
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?SetSocket@ReliabilityLayer@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_s$ = 8							; size = 4
?SetSocket@ReliabilityLayer@@QAEXI@Z PROC		; ReliabilityLayer::SetSocket, COMDAT
; _this$ = ecx

; 138  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 139  : #ifdef __USE_IO_COMPLETION_PORTS
; 140  : 	// If this hits I am probably using sequential ports while doing IO completion ports
; 141  : 	assert( s != INVALID_SOCKET );
; 142  : 	readWriteSocket = s;
; 143  : #endif
; 144  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSocket@ReliabilityLayer@@QAEXI@Z ENDP		; ReliabilityLayer::SetSocket
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?SetEncryptionKey@ReliabilityLayer@@QAEXPBE@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_key$ = 8						; size = 4
?SetEncryptionKey@ReliabilityLayer@@QAEXPBE@Z PROC	; ReliabilityLayer::SetEncryptionKey, COMDAT
; _this$ = ecx

; 124  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 125  : 	if ( key )

	cmp	DWORD PTR _key$[ebp], 0
	je	SHORT $LN2@SetEncrypt

; 126  : 		encryptor.SetKey( key );

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1019				; 000003fbH
	call	?SetKey@TEABlockEncryptor@@QAEXQBE@Z	; TEABlockEncryptor::SetKey

; 127  : 	else

	jmp	SHORT $LN3@SetEncrypt
$LN2@SetEncrypt:

; 128  : 		encryptor.UnsetKey();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1019				; 000003fbH
	call	?UnsetKey@TEABlockEncryptor@@QAEXXZ	; TEABlockEncryptor::UnsetKey
$LN3@SetEncrypt:

; 129  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetEncryptionKey@ReliabilityLayer@@QAEXPBE@Z ENDP	; ReliabilityLayer::SetEncryptionKey
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?Reset@ReliabilityLayer@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_resetVariables$ = 8					; size = 1
?Reset@ReliabilityLayer@@QAEX_N@Z PROC			; ReliabilityLayer::Reset, COMDAT
; _this$ = ecx

; 114  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 115  : 	FreeMemory( true ); // true because making a memory reset pending in the update cycle causes resets after reconnects.  Instead, just call Reset from a single thread

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeMemory@ReliabilityLayer@@AAEX_N@Z	; ReliabilityLayer::FreeMemory

; 116  : 	if (resetVariables)

	movzx	eax, BYTE PTR _resetVariables$[ebp]
	test	eax, eax
	je	SHORT $LN2@Reset

; 117  : 		InitializeVariables();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitializeVariables@ReliabilityLayer@@AAEXXZ ; ReliabilityLayer::InitializeVariables
$LN2@Reset:

; 118  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Reset@ReliabilityLayer@@QAEX_N@Z ENDP			; ReliabilityLayer::Reset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ??1ReliabilityLayer@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1ReliabilityLayer@@QAE@XZ PROC			; ReliabilityLayer::~ReliabilityLayer, COMDAT
; _this$ = ecx

; 102  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1ReliabilityLayer@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 11		; 0000000bH

; 103  : 	FreeMemory( true ); // Free all memory immediately

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeMemory@ReliabilityLayer@@AAEX_N@Z	; ReliabilityLayer::FreeMemory

; 104  : #ifdef __USE_IO_COMPLETION_PORTS
; 105  : 	if ( readWriteSocket != INVALID_SOCKET )
; 106  : 		closesocket( readWriteSocket );
; 107  : #endif
; 108  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	call	??1InternalPacketPool@@QAE@XZ		; InternalPacketPool::~InternalPacketPool
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1646				; 0000066eH
	call	??1?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QAE@XZ ; DataStructures::List<ReliabilityLayer::DataAndTime *>::~List<ReliabilityLayer::DataAndTime *>
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1019				; 000003fbH
	call	??1TEABlockEncryptor@@QAE@XZ		; TEABlockEncryptor::~TEABlockEncryptor
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 927				; 0000039fH
	call	??1?$Queue@_J@DataStructures@@QAE@XZ	; DataStructures::Queue<__int64>::~Queue<__int64>
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 186				; 000000baH
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??1?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::~OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	push	OFFSET ??1?$Queue@PAUInternalPacket@@@DataStructures@@QAE@XZ ; DataStructures::Queue<InternalPacket *>::~Queue<InternalPacket *>
	push	4
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	??1?$Queue@PAUInternalPacket@@@DataStructures@@QAE@XZ ; DataStructures::Queue<InternalPacket *>::~Queue<InternalPacket *>
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??1?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QAE@XZ ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::~BPlusTree<unsigned short,InternalPacket *,32>
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	??1?$RangeList@G@DataStructures@@QAE@XZ	; DataStructures::RangeList<unsigned short>::~RangeList<unsigned short>
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??1?$Queue@PAUInternalPacket@@@DataStructures@@QAE@XZ ; DataStructures::Queue<InternalPacket *>::~Queue<InternalPacket *>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::List<DataStructures::LinkedList<InternalPacket *> *>::~List<DataStructures::LinkedList<InternalPacket *> *>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1ReliabilityLayer@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::List<DataStructures::LinkedList<InternalPacket *> *>::~List<DataStructures::LinkedList<InternalPacket *> *>
__unwindfunclet$??1ReliabilityLayer@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	??1?$Queue@PAUInternalPacket@@@DataStructures@@QAE@XZ ; DataStructures::Queue<InternalPacket *>::~Queue<InternalPacket *>
__unwindfunclet$??1ReliabilityLayer@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	jmp	??1?$RangeList@G@DataStructures@@QAE@XZ	; DataStructures::RangeList<unsigned short>::~RangeList<unsigned short>
__unwindfunclet$??1ReliabilityLayer@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	jmp	??1?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QAE@XZ ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::~BPlusTree<unsigned short,InternalPacket *,32>
__unwindfunclet$??1ReliabilityLayer@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	jmp	??1?$Queue@PAUInternalPacket@@@DataStructures@@QAE@XZ ; DataStructures::Queue<InternalPacket *>::~Queue<InternalPacket *>
__unwindfunclet$??1ReliabilityLayer@@QAE@XZ$5:
	push	OFFSET ??1?$Queue@PAUInternalPacket@@@DataStructures@@QAE@XZ ; DataStructures::Queue<InternalPacket *>::~Queue<InternalPacket *>
	push	4
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	ret	0
__unwindfunclet$??1ReliabilityLayer@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	jmp	??1?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::~OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>
__unwindfunclet$??1ReliabilityLayer@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 186				; 000000baH
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__unwindfunclet$??1ReliabilityLayer@@QAE@XZ$8:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 927				; 0000039fH
	jmp	??1?$Queue@_J@DataStructures@@QAE@XZ	; DataStructures::Queue<__int64>::~Queue<__int64>
__unwindfunclet$??1ReliabilityLayer@@QAE@XZ$9:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1019				; 000003fbH
	jmp	??1TEABlockEncryptor@@QAE@XZ		; TEABlockEncryptor::~TEABlockEncryptor
__unwindfunclet$??1ReliabilityLayer@@QAE@XZ$10:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1646				; 0000066eH
	jmp	??1?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QAE@XZ ; DataStructures::List<ReliabilityLayer::DataAndTime *>::~List<ReliabilityLayer::DataAndTime *>
__unwindfunclet$??1ReliabilityLayer@@QAE@XZ$11:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	jmp	??1InternalPacketPool@@QAE@XZ		; InternalPacketPool::~InternalPacketPool
__ehhandler$??1ReliabilityLayer@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1ReliabilityLayer@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1ReliabilityLayer@@QAE@XZ ENDP			; ReliabilityLayer::~ReliabilityLayer
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ??0ReliabilityLayer@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0ReliabilityLayer@@QAE@XZ PROC			; ReliabilityLayer::ReliabilityLayer, COMDAT
; _this$ = ecx

; 78   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0ReliabilityLayer@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::List<DataStructures::LinkedList<InternalPacket *> *>::List<DataStructures::LinkedList<InternalPacket *> *>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0?$Queue@PAUInternalPacket@@@DataStructures@@QAE@XZ ; DataStructures::Queue<InternalPacket *>::Queue<InternalPacket *>
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	??0?$RangeList@G@DataStructures@@QAE@XZ	; DataStructures::RangeList<unsigned short>::RangeList<unsigned short>
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??0?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QAE@XZ ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::BPlusTree<unsigned short,InternalPacket *,32>
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	??0?$Queue@PAUInternalPacket@@@DataStructures@@QAE@XZ ; DataStructures::Queue<InternalPacket *>::Queue<InternalPacket *>
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	push	OFFSET ??1?$Queue@PAUInternalPacket@@@DataStructures@@QAE@XZ ; DataStructures::Queue<InternalPacket *>::~Queue<InternalPacket *>
	push	OFFSET ??0?$Queue@PAUInternalPacket@@@DataStructures@@QAE@XZ ; DataStructures::Queue<InternalPacket *>::Queue<InternalPacket *>
	push	4
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	call	??0?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	push	576					; 00000240H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 186				; 000000baH
	call	??0BitStream@RakNet@@QAE@H@Z		; RakNet::BitStream::BitStream
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 927				; 0000039fH
	call	??0?$Queue@_J@DataStructures@@QAE@XZ	; DataStructures::Queue<__int64>::Queue<__int64>
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1019				; 000003fbH
	call	??0TEABlockEncryptor@@QAE@XZ		; TEABlockEncryptor::TEABlockEncryptor
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1646				; 0000066eH
	call	??0?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QAE@XZ ; DataStructures::List<ReliabilityLayer::DataAndTime *>::List<ReliabilityLayer::DataAndTime *>
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	call	??0InternalPacketPool@@QAE@XZ		; InternalPacketPool::InternalPacketPool
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH

; 79   : #ifdef __USE_IO_COMPLETION_PORTS
; 80   : 	readWriteSocket = INVALID_SOCKET;
; 81   : #endif
; 82   : 
; 83   : 	freeThreadedMemoryOnNextUpdate = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1645], 0

; 84   : #ifdef _DEBUG
; 85   : 	// Wait longer to disconnect in debug so I don't get disconnected while tracing
; 86   : 	timeoutTime=20000;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+723], 20000		; 00004e20H

; 87   : #else
; 88   : 	timeoutTime=10000;
; 89   : #endif
; 90   : 
; 91   : #ifndef _RELEASE
; 92   : 	maxSendBPS=minExtraPing=extraPingVariance=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1670], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1666], 0
	mov	edx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR [edx+1658], xmm0

; 93   : #endif
; 94   : 
; 95   : 	InitializeVariables();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitializeVariables@ReliabilityLayer@@AAEXXZ ; ReliabilityLayer::InitializeVariables

; 96   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ReliabilityLayer@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$List@PAV?$LinkedList@PAUInternalPacket@@@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::List<DataStructures::LinkedList<InternalPacket *> *>::~List<DataStructures::LinkedList<InternalPacket *> *>
__unwindfunclet$??0ReliabilityLayer@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	??1?$Queue@PAUInternalPacket@@@DataStructures@@QAE@XZ ; DataStructures::Queue<InternalPacket *>::~Queue<InternalPacket *>
__unwindfunclet$??0ReliabilityLayer@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	jmp	??1?$RangeList@G@DataStructures@@QAE@XZ	; DataStructures::RangeList<unsigned short>::~RangeList<unsigned short>
__unwindfunclet$??0ReliabilityLayer@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	jmp	??1?$BPlusTree@GPAUInternalPacket@@$0CA@@DataStructures@@QAE@XZ ; DataStructures::BPlusTree<unsigned short,InternalPacket *,32>::~BPlusTree<unsigned short,InternalPacket *,32>
__unwindfunclet$??0ReliabilityLayer@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	jmp	??1?$Queue@PAUInternalPacket@@@DataStructures@@QAE@XZ ; DataStructures::Queue<InternalPacket *>::~Queue<InternalPacket *>
__unwindfunclet$??0ReliabilityLayer@@QAE@XZ$5:
	push	OFFSET ??1?$Queue@PAUInternalPacket@@@DataStructures@@QAE@XZ ; DataStructures::Queue<InternalPacket *>::~Queue<InternalPacket *>
	push	4
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	ret	0
__unwindfunclet$??0ReliabilityLayer@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	jmp	??1?$OrderedList@GPAUSplitPacketChannel@@$1?SplitPacketChannelComp@@YAHABGABQAU1@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>::~OrderedList<unsigned short,SplitPacketChannel *,&SplitPacketChannelComp>
__unwindfunclet$??0ReliabilityLayer@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 186				; 000000baH
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__unwindfunclet$??0ReliabilityLayer@@QAE@XZ$8:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 927				; 0000039fH
	jmp	??1?$Queue@_J@DataStructures@@QAE@XZ	; DataStructures::Queue<__int64>::~Queue<__int64>
__unwindfunclet$??0ReliabilityLayer@@QAE@XZ$9:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1019				; 000003fbH
	jmp	??1TEABlockEncryptor@@QAE@XZ		; TEABlockEncryptor::~TEABlockEncryptor
__unwindfunclet$??0ReliabilityLayer@@QAE@XZ$10:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1646				; 0000066eH
	jmp	??1?$List@PAUDataAndTime@ReliabilityLayer@@@DataStructures@@QAE@XZ ; DataStructures::List<ReliabilityLayer::DataAndTime *>::~List<ReliabilityLayer::DataAndTime *>
__unwindfunclet$??0ReliabilityLayer@@QAE@XZ$11:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1674				; 0000068aH
	jmp	??1InternalPacketPool@@QAE@XZ		; InternalPacketPool::~InternalPacketPool
__ehhandler$??0ReliabilityLayer@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0ReliabilityLayer@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0ReliabilityLayer@@QAE@XZ ENDP			; ReliabilityLayer::ReliabilityLayer
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?SplitPacketChannelComp@@YAHABGABQAUSplitPacketChannel@@@Z
_TEXT	SEGMENT
_key$ = 8						; size = 4
_data$ = 12						; size = 4
?SplitPacketChannelComp@@YAHABGABQAUSplitPacketChannel@@@Z PROC ; SplitPacketChannelComp, COMDAT

; 56   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 57   : 	if (key < data->splitPacketList[0]->splitPacketId)

	mov	eax, DWORD PTR _key$[ebp]
	movzx	esi, WORD PTR [eax]
	push	0
	mov	ecx, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [ecx]
	add	ecx, 8
	call	??A?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEAAPAUInternalPacket@@I@Z ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::operator[]
	mov	edx, DWORD PTR [eax]
	movzx	eax, WORD PTR [edx+17]
	cmp	esi, eax
	jge	SHORT $LN2@SplitPacke

; 58   : 		return -1;

	or	eax, -1
	jmp	SHORT $LN3@SplitPacke
$LN2@SplitPacke:

; 59   : 	if (key == data->splitPacketList[0]->splitPacketId)

	mov	eax, DWORD PTR _key$[ebp]
	movzx	esi, WORD PTR [eax]
	push	0
	mov	ecx, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [ecx]
	add	ecx, 8
	call	??A?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEAAPAUInternalPacket@@I@Z ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::operator[]
	mov	edx, DWORD PTR [eax]
	movzx	eax, WORD PTR [edx+17]
	cmp	esi, eax
	jne	SHORT $LN1@SplitPacke

; 60   : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN3@SplitPacke
$LN1@SplitPacke:

; 61   : 	return 1;

	mov	eax, 1
$LN3@SplitPacke:

; 62   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?SplitPacketChannelComp@@YAHABGABQAUSplitPacketChannel@@@Z ENDP ; SplitPacketChannelComp
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GSplitPacketChannel@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GSplitPacketChannel@@QAEPAXI@Z PROC			; SplitPacketChannel::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SplitPacketChannel@@QAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GSplitPacketChannel@@QAEPAXI@Z ENDP			; SplitPacketChannel::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1SplitPacketChannel@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1SplitPacketChannel@@QAE@XZ PROC			; SplitPacketChannel::~SplitPacketChannel, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::~OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1SplitPacketChannel@@QAE@XZ ENDP			; SplitPacketChannel::~SplitPacketChannel
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0SplitPacketChannel@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0SplitPacketChannel@@QAE@XZ PROC			; SplitPacketChannel::SplitPacketChannel, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0SplitPacketChannel@@QAE@XZ ENDP			; SplitPacketChannel::SplitPacketChannel
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Clear@?$List@PAUInternalPacket@@@DataStructures@@QAEX_N@Z
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
_doNotDeallocate$ = 8					; size = 1
?Clear@?$List@PAUInternalPacket@@@DataStructures@@QAEX_N@Z PROC ; DataStructures::List<InternalPacket *>::Clear, COMDAT
; _this$ = ecx

; 379  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  : 		if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Clear

; 381  : 			return;

	jmp	SHORT $LN3@Clear
$LN2@Clear:

; 382  : 
; 383  : 		if (allocation_size>512 && doNotDeallocate==false)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 512			; 00000200H
	jbe	SHORT $LN1@Clear
	movzx	eax, BYTE PTR _doNotDeallocate$[ebp]
	test	eax, eax
	jne	SHORT $LN1@Clear

; 384  : 		{
; 385  : 			delete [] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 386  : 			allocation_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 387  : 			listArray = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN1@Clear:

; 388  : 		}
; 389  : 		list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
$LN3@Clear:

; 390  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Clear@?$List@PAUInternalPacket@@@DataStructures@@QAEX_N@Z ENDP ; DataStructures::List<InternalPacket *>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Size@?$List@PAUInternalPacket@@@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$List@PAUInternalPacket@@@DataStructures@@QBEIXZ PROC ; DataStructures::List<InternalPacket *>::Size, COMDAT
; _this$ = ecx

; 373  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 374  : 		return list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 375  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$List@PAUInternalPacket@@@DataStructures@@QBEIXZ ENDP ; DataStructures::List<InternalPacket *>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Del@?$List@PAUInternalPacket@@@DataStructures@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_num$ = 8						; size = 4
?Del@?$List@PAUInternalPacket@@@DataStructures@@QAEXI@Z PROC ; DataStructures::List<InternalPacket *>::Del, COMDAT
; _this$ = ecx

; 353  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 354  : 		// Delete the last elements on the list.  No compression needed
; 355  : #ifdef _DEBUG
; 356  : 		assert(list_size>=num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _num$[ebp]
	jae	SHORT $LN3@Del
	push	356					; 00000164H
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1BO@JBFMBKMD@?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$DO?$AA?$DN?$AAn?$AAu?$AAm?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@Del:

; 357  : #endif
; 358  : 		list_size-=num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _num$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 359  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Del@?$List@PAUInternalPacket@@@DataStructures@@QAEXI@Z ENDP ; DataStructures::List<InternalPacket *>::Del
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?RemoveAtIndex@?$List@PAUInternalPacket@@@DataStructures@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
?RemoveAtIndex@?$List@PAUInternalPacket@@@DataStructures@@QAEXI@Z PROC ; DataStructures::List<InternalPacket *>::RemoveAtIndex, COMDAT
; _this$ = ecx

; 333  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 334  : #ifdef _DEBUG
; 335  : 		assert( position < list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN4@RemoveAtIn
	push	335					; 0000014fH
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@RemoveAtIn:

; 336  : #endif
; 337  : 
; 338  : 		if ( position < list_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN2@RemoveAtIn

; 339  : 		{
; 340  : 			// Compress the array
; 341  : 			/*
; 342  : 			for ( unsigned int counter = position; counter < list_size - 1 ; ++counter )
; 343  : 			listArray[ counter ] = listArray[ counter + 1 ];
; 344  : 			*/
; 345  : 			memmove(listArray+position, listArray+position+1, (list_size-1-position) * sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	sub	ecx, DWORD PTR _position$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _position$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _position$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 346  : 
; 347  : 			Del();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Del@?$List@PAUInternalPacket@@@DataStructures@@QAEXI@Z ; DataStructures::List<InternalPacket *>::Del
$LN2@RemoveAtIn:

; 348  : 		}
; 349  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveAtIndex@?$List@PAUInternalPacket@@@DataStructures@@QAEXI@Z ENDP ; DataStructures::List<InternalPacket *>::RemoveAtIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Insert@?$List@PAUInternalPacket@@@DataStructures@@QAEXQAUInternalPacket@@@Z
_TEXT	SEGMENT
$T1 = -236						; size = 4
$T2 = -224						; size = 4
_new_array$3 = -20					; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
?Insert@?$List@PAUInternalPacket@@@DataStructures@@QAEXQAUInternalPacket@@@Z PROC ; DataStructures::List<InternalPacket *>::Insert, COMDAT
; _this$ = ecx

; 242  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 243  : 		// Reallocate list if necessary
; 244  : 
; 245  : 		if ( list_size == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	$LN3@Insert

; 246  : 		{
; 247  : 			// allocate twice the currently allocated memory
; 248  : 			list_type * new_array;
; 249  : 
; 250  : 			if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Insert

; 251  : 				allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 16			; 00000010H

; 252  : 			else

	jmp	SHORT $LN1@Insert
$LN2@Insert:

; 253  : 				allocation_size *= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN1@Insert:

; 254  : 
; 255  : 			new_array = new list_type [ allocation_size ];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _new_array$3[ebp], eax

; 256  : 
; 257  : 			// copy old array over
; 258  : 			//	for ( unsigned int counter = 0; counter < list_size; ++counter )
; 259  : 			//		new_array[ counter ] = listArray[ counter ];
; 260  : 
; 261  : 			// Don't call constructors, assignment operators, etc.
; 262  : 			memcpy(new_array, listArray, list_size*sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _new_array$3[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 263  : 
; 264  : 			// set old array to point to the newly allocated and twice as large array
; 265  : 			delete[] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 266  : 
; 267  : 			listArray = new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$3[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Insert:

; 268  : 		}
; 269  : 
; 270  : 		// Insert the new item at the correct spot
; 271  : 		listArray[ list_size ] = input;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _input$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 272  : 
; 273  : 		++list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 274  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Insert@?$List@PAUInternalPacket@@@DataStructures@@QAEXQAUInternalPacket@@@Z ENDP ; DataStructures::List<InternalPacket *>::Insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Insert@?$List@PAUInternalPacket@@@DataStructures@@QAEXQAUInternalPacket@@I@Z
_TEXT	SEGMENT
$T1 = -236						; size = 4
$T2 = -224						; size = 4
_new_array$3 = -20					; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
_position$ = 12						; size = 4
?Insert@?$List@PAUInternalPacket@@@DataStructures@@QAEXQAUInternalPacket@@I@Z PROC ; DataStructures::List<InternalPacket *>::Insert, COMDAT
; _this$ = ecx

; 194  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 195  : #ifdef _DEBUG
; 196  : 		assert( position <= list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jbe	SHORT $LN6@Insert
	push	196					; 000000c4H
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CM@FMCFHBCK@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN6@Insert:

; 197  : #endif
; 198  : 
; 199  : 		// Reallocate list if necessary
; 200  : 		if ( list_size == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	$LN3@Insert

; 201  : 		{
; 202  : 			// allocate twice the currently allocated memory
; 203  : 			list_type * new_array;
; 204  : 
; 205  : 			if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Insert

; 206  : 				allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 16			; 00000010H

; 207  : 			else

	jmp	SHORT $LN1@Insert
$LN2@Insert:

; 208  : 				allocation_size *= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN1@Insert:

; 209  : 
; 210  : 			new_array = new list_type [ allocation_size ];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _new_array$3[ebp], eax

; 211  : 
; 212  : 			// copy old array over
; 213  : 			//for ( unsigned int counter = 0; counter < list_size; ++counter )
; 214  : 			//	new_array[ counter ] = listArray[ counter ];
; 215  : 
; 216  : 			// Don't call constructors, assignment operators, etc.
; 217  : 			memcpy(new_array, listArray, list_size*sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _new_array$3[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 218  : 
; 219  : 			// set old array to point to the newly allocated and twice as large array
; 220  : 			delete[] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 221  : 
; 222  : 			listArray = new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$3[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Insert:

; 223  : 		}
; 224  : 
; 225  : 		// Move the elements in the list to make room
; 226  : 		//for ( unsigned int counter = list_size; counter != position; counter-- )
; 227  : 		//	listArray[ counter ] = listArray[ counter - 1 ];
; 228  : 
; 229  : 		// Don't call constructors, assignment operators, etc.
; 230  : 		memmove(listArray+position+1, listArray+position, (list_size-position)*sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _position$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _position$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _position$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4+4]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 231  : 
; 232  : 		// Insert the new item at the correct spot
; 233  : 		listArray[ position ] = input;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _position$[ebp]
	mov	eax, DWORD PTR _input$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 234  : 
; 235  : 		++list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 236  : 
; 237  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?Insert@?$List@PAUInternalPacket@@@DataStructures@@QAEXQAUInternalPacket@@I@Z ENDP ; DataStructures::List<InternalPacket *>::Insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??A?$List@PAUInternalPacket@@@DataStructures@@QBEAAPAUInternalPacket@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
??A?$List@PAUInternalPacket@@@DataStructures@@QBEAAPAUInternalPacket@@I@Z PROC ; DataStructures::List<InternalPacket *>::operator[], COMDAT
; _this$ = ecx

; 185  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 186  : #ifdef _DEBUG
; 187  : 		assert ( position < list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN3@operator
	push	187					; 000000bbH
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@operator:

; 188  : #endif
; 189  : 		return listArray[ position ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _position$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 190  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@PAUInternalPacket@@@DataStructures@@QBEAAPAUInternalPacket@@I@Z ENDP ; DataStructures::List<InternalPacket *>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??1?$List@PAUInternalPacket@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
??1?$List@PAUInternalPacket@@@DataStructures@@QAE@XZ PROC ; DataStructures::List<InternalPacket *>::~List<InternalPacket *>, COMDAT
; _this$ = ecx

; 121  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 122  : 		if (allocation_size>0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jbe	SHORT $LN2@List

; 123  : 			delete [] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@List:

; 124  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@PAUInternalPacket@@@DataStructures@@QAE@XZ ENDP ; DataStructures::List<InternalPacket *>::~List<InternalPacket *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??0?$List@PAUInternalPacket@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$List@PAUInternalPacket@@@DataStructures@@QAE@XZ PROC ; DataStructures::List<InternalPacket *>::List<InternalPacket *>, COMDAT
; _this$ = ecx

; 113  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 114  : 		allocation_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 115  : 		listArray = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 116  : 		list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 117  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@PAUInternalPacket@@@DataStructures@@QAE@XZ ENDP ; DataStructures::List<InternalPacket *>::List<InternalPacket *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?Size@?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEIXZ PROC ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::Size, COMDAT
; _this$ = ecx

; 231  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 232  : 		return orderedList.Size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@PAUInternalPacket@@@DataStructures@@QBEIXZ ; DataStructures::List<InternalPacket *>::Size

; 233  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEIXZ ENDP ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?Clear@?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Clear@?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QAEXXZ PROC ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::Clear, COMDAT
; _this$ = ecx

; 219  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 220  : 		orderedList.Clear();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@PAUInternalPacket@@@DataStructures@@QAEX_N@Z ; DataStructures::List<InternalPacket *>::Clear

; 221  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QAEXXZ ENDP ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ??A?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEAAPAUInternalPacket@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
??A?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEAAPAUInternalPacket@@I@Z PROC ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::operator[], COMDAT
; _this$ = ecx

; 225  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 226  : 		return orderedList[position];

	mov	eax, DWORD PTR _position$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@PAUInternalPacket@@@DataStructures@@QBEAAPAUInternalPacket@@I@Z ; DataStructures::List<InternalPacket *>::operator[]

; 227  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEAAPAUInternalPacket@@I@Z ENDP ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?Insert@?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QAEIABIABQAUInternalPacket@@@Z
_TEXT	SEGMENT
_index$ = -32						; size = 4
_objectExists$ = -17					; size = 1
_this$ = -8						; size = 4
_key$ = 8						; size = 4
_data$ = 12						; size = 4
?Insert@?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QAEIABIABQAUInternalPacket@@@Z PROC ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::Insert, COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		bool objectExists;
; 158  : 		unsigned index;
; 159  : 		index = GetIndexFromKey(key, &objectExists);

	lea	eax, DWORD PTR _objectExists$[ebp]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexFromKey@?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEIABIPA_N@Z ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::GetIndexFromKey
	mov	DWORD PTR _index$[ebp], eax

; 160  : 
; 161  : 		// Don't allow duplicate insertion.
; 162  : 		if (objectExists)

	movzx	eax, BYTE PTR _objectExists$[ebp]
	test	eax, eax
	je	SHORT $LN3@Insert

; 163  : 			return (unsigned)-1;

	or	eax, -1
	jmp	SHORT $LN4@Insert
$LN3@Insert:

; 164  : 
; 165  : 		if (index>=orderedList.Size())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@PAUInternalPacket@@@DataStructures@@QBEIXZ ; DataStructures::List<InternalPacket *>::Size
	cmp	DWORD PTR _index$[ebp], eax
	jb	SHORT $LN2@Insert

; 166  : 		{
; 167  : 			orderedList.Insert(data);

	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Insert@?$List@PAUInternalPacket@@@DataStructures@@QAEXQAUInternalPacket@@@Z ; DataStructures::List<InternalPacket *>::Insert

; 168  : 			return orderedList.Size()-1;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@PAUInternalPacket@@@DataStructures@@QBEIXZ ; DataStructures::List<InternalPacket *>::Size
	sub	eax, 1
	jmp	SHORT $LN4@Insert

; 169  : 		}
; 170  : 		else

	jmp	SHORT $LN4@Insert
$LN2@Insert:

; 171  : 		{
; 172  : 			orderedList.Insert(data,index);

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Insert@?$List@PAUInternalPacket@@@DataStructures@@QAEXQAUInternalPacket@@I@Z ; DataStructures::List<InternalPacket *>::Insert

; 173  : 			return index;

	mov	eax, DWORD PTR _index$[ebp]
$LN4@Insert:

; 174  : 		}		
; 175  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@Insert
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN8@Insert:
	DD	1
	DD	$LN7@Insert
$LN7@Insert:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN6@Insert
$LN6@Insert:
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
?Insert@?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QAEIABIABQAUInternalPacket@@@Z ENDP ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::Insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?GetIndexFromKey@?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEIABIPA_N@Z
_TEXT	SEGMENT
_res$ = -56						; size = 4
_lowerBound$ = -44					; size = 4
_upperBound$ = -32					; size = 4
_index$ = -20						; size = 4
_this$ = -8						; size = 4
_key$ = 8						; size = 4
_objectExists$ = 12					; size = 4
?GetIndexFromKey@?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEIABIPA_N@Z PROC ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::GetIndexFromKey, COMDAT
; _this$ = ecx

; 110  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 111  : 		int index, upperBound, lowerBound;
; 112  : 		int res;
; 113  : 
; 114  : 		if (orderedList.Size()==0)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@PAUInternalPacket@@@DataStructures@@QBEIXZ ; DataStructures::List<InternalPacket *>::Size
	test	eax, eax
	jne	SHORT $LN8@GetIndexFr

; 115  : 		{
; 116  : 			*objectExists=false;

	mov	eax, DWORD PTR _objectExists$[ebp]
	mov	BYTE PTR [eax], 0

; 117  : 			return 0;

	xor	eax, eax
	jmp	$LN9@GetIndexFr
$LN8@GetIndexFr:

; 118  : 		}
; 119  : 
; 120  : 		upperBound=(int)orderedList.Size()-1;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@PAUInternalPacket@@@DataStructures@@QBEIXZ ; DataStructures::List<InternalPacket *>::Size
	sub	eax, 1
	mov	DWORD PTR _upperBound$[ebp], eax

; 121  : 		lowerBound=0;

	mov	DWORD PTR _lowerBound$[ebp], 0

; 122  : 		index = (int)orderedList.Size()/2;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@PAUInternalPacket@@@DataStructures@@QBEIXZ ; DataStructures::List<InternalPacket *>::Size
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _index$[ebp], eax
$LN7@GetIndexFr:

; 123  : 
; 124  : #ifdef _MSC_VER
; 125  : 	#pragma warning( disable : 4127 ) // warning C4127: conditional expression is constant
; 126  : #endif
; 127  : 		while (1)

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN9@GetIndexFr

; 128  : 		{
; 129  : 			res = comparison_function(key,orderedList[index]);

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@PAUInternalPacket@@@DataStructures@@QBEAAPAUInternalPacket@@I@Z ; DataStructures::List<InternalPacket *>::operator[]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	call	?SplitPacketIndexComp@@YAHABIABQAUInternalPacket@@@Z ; SplitPacketIndexComp
	add	esp, 8
	mov	DWORD PTR _res$[ebp], eax

; 130  : 			if (res==0)

	cmp	DWORD PTR _res$[ebp], 0
	jne	SHORT $LN5@GetIndexFr

; 131  : 			{
; 132  : 				*objectExists=true;

	mov	eax, DWORD PTR _objectExists$[ebp]
	mov	BYTE PTR [eax], 1

; 133  : 				return index;

	mov	eax, DWORD PTR _index$[ebp]
	jmp	SHORT $LN9@GetIndexFr
	jmp	SHORT $LN4@GetIndexFr
$LN5@GetIndexFr:

; 134  : 			}
; 135  : 			else if (res<0)

	cmp	DWORD PTR _res$[ebp], 0
	jge	SHORT $LN3@GetIndexFr

; 136  : 			{
; 137  : 				upperBound=index-1;

	mov	eax, DWORD PTR _index$[ebp]
	sub	eax, 1
	mov	DWORD PTR _upperBound$[ebp], eax

; 138  : 			}
; 139  : 			else// if (res>0)

	jmp	SHORT $LN4@GetIndexFr
$LN3@GetIndexFr:

; 140  : 			{
; 141  : 				lowerBound=index+1;

	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 1
	mov	DWORD PTR _lowerBound$[ebp], eax
$LN4@GetIndexFr:

; 142  : 			}
; 143  : 
; 144  : 			index=lowerBound+(upperBound-lowerBound)/2;

	mov	eax, DWORD PTR _upperBound$[ebp]
	sub	eax, DWORD PTR _lowerBound$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _lowerBound$[ebp]
	mov	DWORD PTR _index$[ebp], eax

; 145  : 
; 146  : 			if (lowerBound>upperBound)

	mov	eax, DWORD PTR _lowerBound$[ebp]
	cmp	eax, DWORD PTR _upperBound$[ebp]
	jle	SHORT $LN1@GetIndexFr

; 147  : 			{
; 148  : 				*objectExists=false;

	mov	eax, DWORD PTR _objectExists$[ebp]
	mov	BYTE PTR [eax], 0

; 149  : 				return lowerBound; // No match

	mov	eax, DWORD PTR _lowerBound$[ebp]
	jmp	SHORT $LN9@GetIndexFr
$LN1@GetIndexFr:

; 150  : 			}
; 151  : 		}

	jmp	SHORT $LN7@GetIndexFr
$LN9@GetIndexFr:

; 152  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?GetIndexFromKey@?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QBEIABIPA_N@Z ENDP ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::GetIndexFromKey
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ??1?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QAE@XZ PROC ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::~OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>, COMDAT
; _this$ = ecx

; 72   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 73   : 		Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QAEXXZ ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::Clear

; 74   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$List@PAUInternalPacket@@@DataStructures@@QAE@XZ ; DataStructures::List<InternalPacket *>::~List<InternalPacket *>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$List@PAUInternalPacket@@@DataStructures@@QAE@XZ ; DataStructures::List<InternalPacket *>::~List<InternalPacket *>
__ehhandler$??1?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QAE@XZ ENDP ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::~OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ??0?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QAE@XZ PROC ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>, COMDAT
; _this$ = ecx

; 67   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$List@PAUInternalPacket@@@DataStructures@@QAE@XZ ; DataStructures::List<InternalPacket *>::List<InternalPacket *>

; 68   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$OrderedList@IPAUInternalPacket@@$1?SplitPacketIndexComp@@YAHABIABQAU1@@Z@DataStructures@@QAE@XZ ENDP ; DataStructures::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>::OrderedList<unsigned int,InternalPacket *,&SplitPacketIndexComp>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\reliabilitylayer.cpp
;	COMDAT ?SplitPacketIndexComp@@YAHABIABQAUInternalPacket@@@Z
_TEXT	SEGMENT
_key$ = 8						; size = 4
_data$ = 12						; size = 4
?SplitPacketIndexComp@@YAHABIABQAUInternalPacket@@@Z PROC ; SplitPacketIndexComp, COMDAT

; 65   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 66   : 	if (key < data->splitPacketIndex)

	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _key$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR [ecx+19]
	jae	SHORT $LN2@SplitPacke

; 67   : 		return -1;

	or	eax, -1
	jmp	SHORT $LN3@SplitPacke
$LN2@SplitPacke:

; 68   : 	if (key == data->splitPacketIndex)

	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _key$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR [ecx+19]
	jne	SHORT $LN1@SplitPacke

; 69   : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN3@SplitPacke
$LN1@SplitPacke:

; 70   : 	return 1;

	mov	eax, 1
$LN3@SplitPacke:

; 71   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SplitPacketIndexComp@@YAHABIABQAUInternalPacket@@@Z ENDP ; SplitPacketIndexComp
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ?ClearAndForceAllocation@?$Queue@PAUInternalPacket@@@DataStructures@@QAEXH@Z
_TEXT	SEGMENT
$T1 = -224						; size = 4
$T2 = -212						; size = 4
_this$ = -8						; size = 4
_size$ = 8						; size = 4
?ClearAndForceAllocation@?$Queue@PAUInternalPacket@@@DataStructures@@QAEXH@Z PROC ; DataStructures::Queue<InternalPacket *>::ClearAndForceAllocation, COMDAT
; _this$ = ecx

; 346  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 347  : 		delete [] array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 348  : 		array = new queue_type[ size ];

	xor	ecx, ecx
	mov	eax, DWORD PTR _size$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [eax], ecx

; 349  : 		allocation_size = size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 350  : 		head = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 351  : 		tail = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 352  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?ClearAndForceAllocation@?$Queue@PAUInternalPacket@@@DataStructures@@QAEXH@Z ENDP ; DataStructures::Queue<InternalPacket *>::ClearAndForceAllocation
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ?Size@?$Queue@PAUInternalPacket@@@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$Queue@PAUInternalPacket@@@DataStructures@@QBEIXZ PROC ; DataStructures::Queue<InternalPacket *>::Size, COMDAT
; _this$ = ecx

; 62   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 63   : 		if ( head <= tail )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	ja	SHORT $LN2@Size

; 64   : 			return tail -head;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	jmp	SHORT $LN3@Size

; 65   : 		else

	jmp	SHORT $LN3@Size
$LN2@Size:

; 66   : 			return allocation_size -head + tail;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx+8]
$LN3@Size:

; 67   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$Queue@PAUInternalPacket@@@DataStructures@@QBEIXZ ENDP ; DataStructures::Queue<InternalPacket *>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ?Pop@?$Queue@PAUInternalPacket@@@DataStructures@@QAEPAUInternalPacket@@XZ
_TEXT	SEGMENT
tv78 = -208						; size = 4
_this$ = -8						; size = 4
?Pop@?$Queue@PAUInternalPacket@@@DataStructures@@QAEPAUInternalPacket@@XZ PROC ; DataStructures::Queue<InternalPacket *>::Pop, COMDAT
; _this$ = ecx

; 99   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 100  : #ifdef _DEBUG
; 101  : 		assert( allocation_size > 0 && Size() >= 0 && head != tail);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jbe	SHORT $LN5@Pop
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$Queue@PAUInternalPacket@@@DataStructures@@QBEIXZ ; DataStructures::Queue<InternalPacket *>::Size
	test	eax, eax
	jb	SHORT $LN5@Pop
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN6@Pop
$LN5@Pop:
	push	101					; 00000065H
	push	OFFSET ??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@
	push	OFFSET ??_C@_1GG@JDEIIJCO@?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN6@Pop:

; 102  : #endif
; 103  : 		//head=(head+1) % allocation_size;
; 104  : 
; 105  : 		if ( ++head == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	DWORD PTR tv78[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv78[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv78[ebp]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN2@Pop

; 106  : 			head = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
$LN2@Pop:

; 107  : 
; 108  : 		if ( head == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN1@Pop

; 109  : 			return ( queue_type ) array[ allocation_size -1 ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+ecx*4-4]
	jmp	SHORT $LN3@Pop
$LN1@Pop:

; 110  : 
; 111  : 		return ( queue_type ) array[ head -1 ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+ecx*4-4]
$LN3@Pop:

; 112  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Pop@?$Queue@PAUInternalPacket@@@DataStructures@@QAEPAUInternalPacket@@XZ ENDP ; DataStructures::Queue<InternalPacket *>::Pop
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ?Peek@?$Queue@PAUInternalPacket@@@DataStructures@@QBEPAUInternalPacket@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Peek@?$Queue@PAUInternalPacket@@@DataStructures@@QBEPAUInternalPacket@@XZ PROC ; DataStructures::Queue<InternalPacket *>::Peek, COMDAT
; _this$ = ecx

; 171  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 172  : #ifdef _DEBUG
; 173  : 		assert( head != tail );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN3@Peek
	push	173					; 000000adH
	push	OFFSET ??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@
	push	OFFSET ??_C@_1BK@BHOIKEPB@?$AAh?$AAe?$AAa?$AAd?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAt?$AAa?$AAi?$AAl?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@Peek:

; 174  : 		assert( allocation_size > 0 && Size() >= 0 );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jbe	SHORT $LN4@Peek
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$Queue@PAUInternalPacket@@@DataStructures@@QBEIXZ ; DataStructures::Queue<InternalPacket *>::Size
	test	eax, eax
	jae	SHORT $LN5@Peek
$LN4@Peek:
	push	174					; 000000aeH
	push	OFFSET ??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@
	push	OFFSET ??_C@_1EG@MGMFGCAG@?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN5@Peek:

; 175  : #endif
; 176  : 
; 177  : 		return ( queue_type ) array[ head ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+ecx*4]

; 178  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Peek@?$Queue@PAUInternalPacket@@@DataStructures@@QBEPAUInternalPacket@@XZ ENDP ; DataStructures::Queue<InternalPacket *>::Peek
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ?Del@?$Queue@PAUInternalPacket@@@DataStructures@@QAEXI@Z
_TEXT	SEGMENT
_next$ = -32						; size = 4
_index$ = -20						; size = 4
_this$ = -8						; size = 4
_position$ = 8						; size = 4
?Del@?$Queue@PAUInternalPacket@@@DataStructures@@QAEXI@Z PROC ; DataStructures::Queue<InternalPacket *>::Del, COMDAT
; _this$ = ecx

; 370  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 371  : #ifdef _DEBUG
; 372  : 		assert( position < Size() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$Queue@PAUInternalPacket@@@DataStructures@@QBEIXZ ; DataStructures::Queue<InternalPacket *>::Size
	cmp	DWORD PTR _position$[ebp], eax
	jb	SHORT $LN13@Del
	push	372					; 00000174H
	push	OFFSET ??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@
	push	OFFSET ??_C@_1CE@CLDOPLDF@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN13@Del:

; 373  : 		assert( head != tail );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN14@Del
	push	373					; 00000175H
	push	OFFSET ??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@
	push	OFFSET ??_C@_1BK@BHOIKEPB@?$AAh?$AAe?$AAa?$AAd?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAt?$AAa?$AAi?$AAl?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN14@Del:

; 374  : #endif
; 375  : 
; 376  : 		if ( head == tail || position >= Size() )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN9@Del
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$Queue@PAUInternalPacket@@@DataStructures@@QBEIXZ ; DataStructures::Queue<InternalPacket *>::Size
	cmp	DWORD PTR _position$[ebp], eax
	jb	SHORT $LN10@Del
$LN9@Del:

; 377  : 			return ;

	jmp	$LN11@Del
$LN10@Del:

; 378  : 
; 379  : 		unsigned int index;
; 380  : 
; 381  : 		unsigned int next;
; 382  : 
; 383  : 		//index  = (head + position) % allocation_size;
; 384  : 		if ( head + position >= allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _position$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [edx+12]
	jb	SHORT $LN8@Del

; 385  : 			index = head + position - allocation_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _position$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	sub	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR _index$[ebp], ecx

; 386  : 		else

	jmp	SHORT $LN7@Del
$LN8@Del:

; 387  : 			index = head + position;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _position$[ebp]
	mov	DWORD PTR _index$[ebp], ecx
$LN7@Del:

; 388  : 
; 389  : 		//next = (index + 1) % allocation_size;
; 390  : 		next = index + 1;

	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 1
	mov	DWORD PTR _next$[ebp], eax

; 391  : 
; 392  : 		if ( next == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _next$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jne	SHORT $LN5@Del

; 393  : 			next = 0;

	mov	DWORD PTR _next$[ebp], 0
$LN5@Del:

; 394  : 
; 395  : 		while ( next != tail )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _next$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	je	SHORT $LN4@Del

; 396  : 		{
; 397  : 			// Overwrite the previous element
; 398  : 			array[ index ] = array[ next ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _index$[ebp]
	mov	esi, DWORD PTR _next$[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR [eax+edx*4], ecx

; 399  : 			index = next;

	mov	eax, DWORD PTR _next$[ebp]
	mov	DWORD PTR _index$[ebp], eax

; 400  : 			//next = (next + 1) % allocation_size;
; 401  : 
; 402  : 			if ( ++next == allocation_size )

	mov	eax, DWORD PTR _next$[ebp]
	add	eax, 1
	mov	DWORD PTR _next$[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _next$[ebp]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN3@Del

; 403  : 				next = 0;

	mov	DWORD PTR _next$[ebp], 0
$LN3@Del:

; 404  : 		}

	jmp	SHORT $LN5@Del
$LN4@Del:

; 405  : 
; 406  : 		// Move the tail back
; 407  : 		if ( tail == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Del

; 408  : 			tail = allocation_size - 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 409  : 		else

	jmp	SHORT $LN11@Del
$LN2@Del:

; 410  : 			--tail;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN11@Del:

; 411  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Del@?$Queue@PAUInternalPacket@@@DataStructures@@QAEXI@Z ENDP ; DataStructures::Queue<InternalPacket *>::Del
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ??A?$Queue@PAUInternalPacket@@@DataStructures@@QBEAAPAUInternalPacket@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
??A?$Queue@PAUInternalPacket@@@DataStructures@@QBEAAPAUInternalPacket@@I@Z PROC ; DataStructures::Queue<InternalPacket *>::operator[], COMDAT
; _this$ = ecx

; 356  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 357  : #ifdef _DEBUG
; 358  : 		assert( position < Size() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$Queue@PAUInternalPacket@@@DataStructures@@QBEIXZ ; DataStructures::Queue<InternalPacket *>::Size
	cmp	DWORD PTR _position$[ebp], eax
	jb	SHORT $LN5@operator
	push	358					; 00000166H
	push	OFFSET ??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@
	push	OFFSET ??_C@_1CE@CLDOPLDF@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN5@operator:

; 359  : #endif
; 360  : 		//return array[(head + position) % allocation_size];
; 361  : 
; 362  : 		if ( head + position >= allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _position$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [edx+12]
	jb	SHORT $LN2@operator

; 363  : 			return array[ head + position - allocation_size ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _position$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	sub	ecx, DWORD PTR [edx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	lea	eax, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN3@operator

; 364  : 		else

	jmp	SHORT $LN3@operator
$LN2@operator:

; 365  : 			return array[ head + position ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _position$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	eax, DWORD PTR [eax+ecx*4]
$LN3@operator:

; 366  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$Queue@PAUInternalPacket@@@DataStructures@@QBEAAPAUInternalPacket@@I@Z ENDP ; DataStructures::Queue<InternalPacket *>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ?PushAtHead@?$Queue@PAUInternalPacket@@@DataStructures@@QAEXABQAUInternalPacket@@I@Z
_TEXT	SEGMENT
$T1 = -272						; size = 4
$T2 = -260						; size = 4
$T3 = -248						; size = 4
_counter$4 = -44					; size = 4
_new_array$5 = -32					; size = 4
_count$ = -20						; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
_index$ = 12						; size = 4
?PushAtHead@?$Queue@PAUInternalPacket@@@DataStructures@@QAEXABQAUInternalPacket@@I@Z PROC ; DataStructures::Queue<InternalPacket *>::PushAtHead, COMDAT
; _this$ = ecx

; 116  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-276]
	mov	ecx, 69					; 00000045H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 117  : 		if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN9@PushAtHead

; 118  : 		{
; 119  : 			array = new queue_type[ 16 ];

	push	64					; 00000040H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax], ecx

; 120  : 			head = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 121  : 			tail = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 1

; 122  : 			array[ 0 ] = input;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+eax], edx

; 123  : 			allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 16			; 00000010H

; 124  : 			return ;

	jmp	$LN10@PushAtHead
$LN9@PushAtHead:

; 125  : 		}
; 126  : 
; 127  : 		if ( head == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN8@PushAtHead

; 128  : 			head = allocation_size - 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 129  : 		else

	jmp	SHORT $LN7@PushAtHead
$LN8@PushAtHead:

; 130  : 			--head;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
$LN7@PushAtHead:

; 131  : 
; 132  : 		unsigned count=0;

	mov	DWORD PTR _count$[ebp], 0
$LN6@PushAtHead:

; 133  : 		while (count < index)

	mov	eax, DWORD PTR _count$[ebp]
	cmp	eax, DWORD PTR _index$[ebp]
	jae	SHORT $LN5@PushAtHead

; 134  : 		{
; 135  : 			array[head+count]=array[head+count+1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _count$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+4]
	add	edx, DWORD PTR _count$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+ecx*4+4]
	mov	DWORD PTR [esi+edx*4], eax

; 136  : 			count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 137  : 		}

	jmp	SHORT $LN6@PushAtHead
$LN5@PushAtHead:

; 138  : 		array[ head+count ] = input;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _count$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [eax+ecx*4], edx

; 139  : 
; 140  : 		if ( tail == head )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+4]
	jne	$LN10@PushAtHead

; 141  : 		{
; 142  : 			//  unsigned int index=tail;
; 143  : 
; 144  : 			// Need to allocate more memory.
; 145  : 			queue_type * new_array;
; 146  : 			new_array = new queue_type[ allocation_size * 2 ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	shl	eax, 1
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _new_array$5[ebp], eax

; 147  : #ifdef _DEBUG
; 148  : 
; 149  : 			assert( new_array );

	cmp	DWORD PTR _new_array$5[ebp], 0
	jne	SHORT $LN12@PushAtHead
	push	149					; 00000095H
	push	OFFSET ??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@
	push	OFFSET ??_C@_1BE@OMEGJCHO@?$AAn?$AAe?$AAw?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN12@PushAtHead:

; 150  : #endif
; 151  : 
; 152  : 			for ( unsigned int counter = 0; counter < allocation_size; ++counter )

	mov	DWORD PTR _counter$4[ebp], 0
	jmp	SHORT $LN3@PushAtHead
$LN2@PushAtHead:
	mov	eax, DWORD PTR _counter$4[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$4[ebp], eax
$LN3@PushAtHead:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _counter$4[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN1@PushAtHead

; 153  : 				new_array[ counter ] = array[ ( head + counter ) % ( allocation_size ) ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, DWORD PTR _counter$4[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _counter$4[ebp]
	mov	esi, DWORD PTR _new_array$5[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [esi+eax*4], ecx
	jmp	SHORT $LN2@PushAtHead
$LN1@PushAtHead:

; 154  : 
; 155  : 			head = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 156  : 
; 157  : 			tail = allocation_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+8], edx

; 158  : 
; 159  : 			allocation_size *= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 160  : 
; 161  : 			// Delete the old array and move the pointer to the new array
; 162  : 			delete [] array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T3[ebp], ecx
	mov	edx, DWORD PTR $T3[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 163  : 
; 164  : 			array = new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$5[ebp]
	mov	DWORD PTR [eax], ecx
$LN10@PushAtHead:

; 165  : 		}
; 166  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?PushAtHead@?$Queue@PAUInternalPacket@@@DataStructures@@QAEXABQAUInternalPacket@@I@Z ENDP ; DataStructures::Queue<InternalPacket *>::PushAtHead
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ?Push@?$Queue@PAUInternalPacket@@@DataStructures@@QAEXABQAUInternalPacket@@@Z
_TEXT	SEGMENT
$T1 = -260						; size = 4
$T2 = -248						; size = 4
$T3 = -236						; size = 4
_counter$4 = -32					; size = 4
_new_array$5 = -20					; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
?Push@?$Queue@PAUInternalPacket@@@DataStructures@@QAEXABQAUInternalPacket@@@Z PROC ; DataStructures::Queue<InternalPacket *>::Push, COMDAT
; _this$ = ecx

; 182  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 183  : 		if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN6@Push

; 184  : 		{
; 185  : 			array = new queue_type[ 16 ];

	push	64					; 00000040H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax], ecx

; 186  : 			head = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 187  : 			tail = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 1

; 188  : 			array[ 0 ] = input;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+eax], edx

; 189  : 			allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 16			; 00000010H

; 190  : 			return ;

	jmp	$LN7@Push
$LN6@Push:

; 191  : 		}
; 192  : 
; 193  : 		array[ tail++ ] = input;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [eax+ecx*4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 194  : 
; 195  : 		if ( tail == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN5@Push

; 196  : 			tail = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
$LN5@Push:

; 197  : 
; 198  : 		if ( tail == head )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+4]
	jne	$LN7@Push

; 199  : 		{
; 200  : 			//  unsigned int index=tail;
; 201  : 
; 202  : 			// Need to allocate more memory.
; 203  : 			queue_type * new_array;
; 204  : 			new_array = new queue_type[ allocation_size * 2 ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	shl	eax, 1
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _new_array$5[ebp], eax

; 205  : #ifdef _DEBUG
; 206  : 
; 207  : 			assert( new_array );

	cmp	DWORD PTR _new_array$5[ebp], 0
	jne	SHORT $LN9@Push
	push	207					; 000000cfH
	push	OFFSET ??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@
	push	OFFSET ??_C@_1BE@OMEGJCHO@?$AAn?$AAe?$AAw?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN9@Push:

; 208  : #endif
; 209  : 
; 210  : 			for ( unsigned int counter = 0; counter < allocation_size; ++counter )

	mov	DWORD PTR _counter$4[ebp], 0
	jmp	SHORT $LN3@Push
$LN2@Push:
	mov	eax, DWORD PTR _counter$4[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$4[ebp], eax
$LN3@Push:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _counter$4[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN1@Push

; 211  : 				new_array[ counter ] = array[ ( head + counter ) % ( allocation_size ) ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, DWORD PTR _counter$4[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _counter$4[ebp]
	mov	esi, DWORD PTR _new_array$5[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [esi+eax*4], ecx
	jmp	SHORT $LN2@Push
$LN1@Push:

; 212  : 
; 213  : 			head = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 214  : 
; 215  : 			tail = allocation_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+8], edx

; 216  : 
; 217  : 			allocation_size *= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 218  : 
; 219  : 			// Delete the old array and move the pointer to the new array
; 220  : 			delete [] array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T3[ebp], ecx
	mov	edx, DWORD PTR $T3[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 221  : 
; 222  : 			array = new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$5[ebp]
	mov	DWORD PTR [eax], ecx
$LN7@Push:

; 223  : 		}
; 224  : 
; 225  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Push@?$Queue@PAUInternalPacket@@@DataStructures@@QAEXABQAUInternalPacket@@@Z ENDP ; DataStructures::Queue<InternalPacket *>::Push
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ??1?$Queue@PAUInternalPacket@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
??1?$Queue@PAUInternalPacket@@@DataStructures@@QAE@XZ PROC ; DataStructures::Queue<InternalPacket *>::~Queue<InternalPacket *>, COMDAT
; _this$ = ecx

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		if (allocation_size>0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jbe	SHORT $LN2@Queue

; 94   : 			delete [] array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@Queue:

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$Queue@PAUInternalPacket@@@DataStructures@@QAE@XZ ENDP ; DataStructures::Queue<InternalPacket *>::~Queue<InternalPacket *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ??0?$Queue@PAUInternalPacket@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
??0?$Queue@PAUInternalPacket@@@DataStructures@@QAE@XZ PROC ; DataStructures::Queue<InternalPacket *>::Queue<InternalPacket *>, COMDAT
; _this$ = ecx

; 83   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 84   : 		allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 16			; 00000010H

; 85   : 		array = new queue_type[ allocation_size ];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax], ecx

; 86   : 		head = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 87   : 		tail = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 88   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$Queue@PAUInternalPacket@@@DataStructures@@QAE@XZ ENDP ; DataStructures::Queue<InternalPacket *>::Queue<InternalPacket *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\internalpacketpool.h
;	COMDAT ?GetPointer@InternalPacketPool@@QAEPAUInternalPacket@@XZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
?GetPointer@InternalPacketPool@@QAEPAUInternalPacket@@XZ PROC ; InternalPacketPool::GetPointer, COMDAT
; _this$ = ecx

; 38   : 	{if ( pool.Size() )

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$Queue@PAUInternalPacket@@@DataStructures@@QBEIXZ ; DataStructures::Queue<InternalPacket *>::Size
	test	eax, eax
	je	SHORT $LN1@GetPointer

; 39   : 		return pool.Pop();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Pop@?$Queue@PAUInternalPacket@@@DataStructures@@QAEPAUInternalPacket@@XZ ; DataStructures::Queue<InternalPacket *>::Pop
	jmp	SHORT $LN2@GetPointer
$LN1@GetPointer:

; 40   : 	return new InternalPacket;}

	push	55					; 00000037H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
$LN2@GetPointer:
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPointer@InternalPacketPool@@QAEPAUInternalPacket@@XZ ENDP ; InternalPacketPool::GetPointer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Read@G@BitStream@RakNet@@QAE_NAAG@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 4
??$Read@G@BitStream@RakNet@@QAE_NAAG@Z PROC		; RakNet::BitStream::Read<unsigned short>, COMDAT
; _this$ = ecx

; 987  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 988  : #ifdef _MSC_VER
; 989  : #pragma warning(disable:4127)   // conditional expression is constant
; 990  : #endif
; 991  : 		if (sizeof(var)==1)

	xor	eax, eax
	je	SHORT $LN2@Read

; 992  : 			return ReadBits( ( unsigned char* ) &var, sizeof(templateType) * 8, true );

	push	1
	push	16					; 00000010H
	mov	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadBits@BitStream@RakNet@@QAE_NPAEH_N@Z ; RakNet::BitStream::ReadBits
	jmp	SHORT $LN3@Read

; 993  : 		else

	jmp	SHORT $LN3@Read
$LN2@Read:

; 994  : 		{
; 995  : #ifndef __BITSTREAM_NATIVE_END
; 996  : #ifdef _MSC_VER
; 997  : #pragma warning(disable:4244)   // '=' : conversion from 'unsigned long' to 'unsigned short', possible loss of data
; 998  : #endif
; 999  : 			if (DoEndianSwap())
; 1000 : 			{
; 1001 : 				unsigned char output[sizeof(templateType)];
; 1002 : 				if (ReadBits( ( unsigned char* ) output, sizeof(templateType) * 8, true ))
; 1003 : 				{
; 1004 : 					ReverseBytes(output, (unsigned char*)&var, sizeof(templateType));
; 1005 : 					return true;
; 1006 : 				}
; 1007 : 				return false;
; 1008 : 			}
; 1009 : 			else
; 1010 : #endif
; 1011 : 				return ReadBits( ( unsigned char* ) & var, sizeof(templateType) * 8, true );

	push	1
	push	16					; 00000010H
	mov	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadBits@BitStream@RakNet@@QAE_NPAEH_N@Z ; RakNet::BitStream::ReadBits
$LN3@Read:

; 1012 : 		}
; 1013 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$Read@G@BitStream@RakNet@@QAE_NAAG@Z ENDP		; RakNet::BitStream::Read<unsigned short>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z
_TEXT	SEGMENT
tv82 = -208						; size = 4
_this$ = -8						; size = 4
_var$ = 8						; size = 4
??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z PROC		; RakNet::BitStream::Read<bool>, COMDAT
; _this$ = ecx

; 1019 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1020 : 		if ( readOffset + 1 > numberOfBitsUsed )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [edx]
	jle	SHORT $LN3@Read

; 1021 : 			return false;

	xor	al, al
	jmp	SHORT $LN4@Read
$LN3@Read:

; 1022 : 
; 1023 : 		if ( data[ readOffset >> 3 ] & ( 0x80 >> ( readOffset++ % 8 ) ) )   // Is it faster to just write it out here?

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sar	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	movzx	edx, BYTE PTR [eax+ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -2147483641			; 80000007H
	jns	SHORT $LN6@Read
	dec	ecx
	or	ecx, -8					; fffffff8H
	inc	ecx
$LN6@Read:
	mov	eax, 128				; 00000080H
	sar	eax, cl
	and	edx, eax
	mov	DWORD PTR tv82[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx
	cmp	DWORD PTR tv82[ebp], 0
	je	SHORT $LN2@Read

; 1024 : 			var = true;

	mov	eax, DWORD PTR _var$[ebp]
	mov	BYTE PTR [eax], 1

; 1025 : 		else

	jmp	SHORT $LN1@Read
$LN2@Read:

; 1026 : 			var = false;

	mov	eax, DWORD PTR _var$[ebp]
	mov	BYTE PTR [eax], 0
$LN1@Read:

; 1027 : 
; 1028 : 		return true;

	mov	al, 1
$LN4@Read:

; 1029 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z ENDP		; RakNet::BitStream::Read<bool>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Write@G@BitStream@RakNet@@QAEXG@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 2
??$Write@G@BitStream@RakNet@@QAEXG@Z PROC		; RakNet::BitStream::Write<unsigned short>, COMDAT
; _this$ = ecx

; 729  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 730  : #ifdef _MSC_VER
; 731  : #pragma warning(disable:4127)   // conditional expression is constant
; 732  : #endif
; 733  : 		if (sizeof(var)==1)

	xor	eax, eax
	je	SHORT $LN2@Write

; 734  : 			WriteBits( ( unsigned char* ) & var, sizeof( templateType ) * 8, true );

	push	1
	push	16					; 00000010H
	lea	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z ; RakNet::BitStream::WriteBits

; 735  : 		else

	jmp	SHORT $LN3@Write
$LN2@Write:

; 736  : 		{
; 737  : #ifndef __BITSTREAM_NATIVE_END
; 738  : 			if (DoEndianSwap())
; 739  : 			{
; 740  : 				unsigned char output[sizeof(templateType)];
; 741  : 				ReverseBytes((unsigned char*)&var, output, sizeof(templateType));
; 742  : 				WriteBits( ( unsigned char* ) output, sizeof(templateType) * 8, true );
; 743  : 			}
; 744  : 			else
; 745  : #endif
; 746  : 				WriteBits( ( unsigned char* ) & var, sizeof(templateType) * 8, true );

	push	1
	push	16					; 00000010H
	lea	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z ; RakNet::BitStream::WriteBits
$LN3@Write:

; 747  : 		}
; 748  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$Write@G@BitStream@RakNet@@QAEXG@Z ENDP		; RakNet::BitStream::Write<unsigned short>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Write@_N@BitStream@RakNet@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 1
??$Write@_N@BitStream@RakNet@@QAEX_N@Z PROC		; RakNet::BitStream::Write<bool>, COMDAT
; _this$ = ecx

; 754  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 755  : 		if ( var )

	movzx	eax, BYTE PTR _var$[ebp]
	test	eax, eax
	je	SHORT $LN2@Write

; 756  : 			Write1();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Write1@BitStream@RakNet@@QAEXXZ	; RakNet::BitStream::Write1

; 757  : 		else

	jmp	SHORT $LN3@Write
$LN2@Write:

; 758  : 			Write0();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Write0@BitStream@RakNet@@QAEXXZ	; RakNet::BitStream::Write0
$LN3@Write:

; 759  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$Write@_N@BitStream@RakNet@@QAEX_N@Z ENDP		; RakNet::BitStream::Write<bool>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ?GetData@BitStream@RakNet@@QBEPAEXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetData@BitStream@RakNet@@QBEPAEXZ PROC		; RakNet::BitStream::GetData, COMDAT
; _this$ = ecx

; 397  : 		inline unsigned char* GetData( void ) const {return data;}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetData@BitStream@RakNet@@QBEPAEXZ ENDP		; RakNet::BitStream::GetData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ?GetNumberOfUnreadBits@BitStream@RakNet@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetNumberOfUnreadBits@BitStream@RakNet@@QBEHXZ PROC	; RakNet::BitStream::GetNumberOfUnreadBits, COMDAT
; _this$ = ecx

; 382  : 		inline int GetNumberOfUnreadBits( void ) const {return numberOfBitsUsed - readOffset;}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR [ecx+8]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumberOfUnreadBits@BitStream@RakNet@@QBEHXZ ENDP	; RakNet::BitStream::GetNumberOfUnreadBits
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ?GetNumberOfBytesUsed@BitStream@RakNet@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetNumberOfBytesUsed@BitStream@RakNet@@QBEHXZ PROC	; RakNet::BitStream::GetNumberOfBytesUsed, COMDAT
; _this$ = ecx

; 373  : 		inline int GetNumberOfBytesUsed( void ) const {return BITS_TO_BYTES( numberOfBitsUsed );}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	add	eax, 7
	sar	eax, 3
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumberOfBytesUsed@BitStream@RakNet@@QBEHXZ ENDP	; RakNet::BitStream::GetNumberOfBytesUsed
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ?GetWriteOffset@BitStream@RakNet@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetWriteOffset@BitStream@RakNet@@QBEHXZ PROC		; RakNet::BitStream::GetWriteOffset, COMDAT
; _this$ = ecx

; 370  : 		inline int GetWriteOffset( void ) const {return numberOfBitsUsed;}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWriteOffset@BitStream@RakNet@@QBEHXZ ENDP		; RakNet::BitStream::GetWriteOffset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ PROC	; RakNet::BitStream::GetNumberOfBitsUsed, COMDAT
; _this$ = ecx

; 369  : 		inline int GetNumberOfBitsUsed( void ) const {return GetWriteOffset();}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetWriteOffset@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetWriteOffset
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ ENDP	; RakNet::BitStream::GetNumberOfBitsUsed
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\socketlayer.h
;	COMDAT ?Instance@SocketLayer@@SAPAV1@XZ
_TEXT	SEGMENT
?Instance@SocketLayer@@SAPAV1@XZ PROC			; SocketLayer::Instance, COMDAT

; 60   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 61   : 		return & I;

	mov	eax, OFFSET ?I@SocketLayer@@0V1@A	; SocketLayer::I

; 62   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Instance@SocketLayer@@SAPAV1@XZ ENDP			; SocketLayer::Instance
_TEXT	ENDS
END
