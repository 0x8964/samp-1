; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.31101.0 

	TITLE	Z:\sampsrc\02Xu1\raknet\DS_Table.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	??0Cell@Table@DataStructures@@QAE@XZ		; DataStructures::Table::Cell::Cell
PUBLIC	??1Cell@Table@DataStructures@@QAE@XZ		; DataStructures::Table::Cell::~Cell
PUBLIC	??0Cell@Table@DataStructures@@QAE@HPADW4ColumnType@12@@Z ; DataStructures::Table::Cell::Cell
PUBLIC	?Clear@Cell@Table@DataStructures@@QAEXXZ	; DataStructures::Table::Cell::Clear
PUBLIC	?Set@Cell@Table@DataStructures@@QAEXH@Z		; DataStructures::Table::Cell::Set
PUBLIC	?Set@Cell@Table@DataStructures@@QAEXPAD@Z	; DataStructures::Table::Cell::Set
PUBLIC	?Set@Cell@Table@DataStructures@@QAEXPADH@Z	; DataStructures::Table::Cell::Set
PUBLIC	?Get@Cell@Table@DataStructures@@QAEXPAH@Z	; DataStructures::Table::Cell::Get
PUBLIC	?Get@Cell@Table@DataStructures@@QAEXPAD@Z	; DataStructures::Table::Cell::Get
PUBLIC	?Get@Cell@Table@DataStructures@@QAEXPADPAH@Z	; DataStructures::Table::Cell::Get
PUBLIC	??4Cell@Table@DataStructures@@QAEAAU012@ABU012@@Z ; DataStructures::Table::Cell::operator=
PUBLIC	??0Cell@Table@DataStructures@@QAE@ABU012@@Z	; DataStructures::Table::Cell::Cell
PUBLIC	??_GCell@Table@DataStructures@@QAEPAXI@Z	; DataStructures::Table::Cell::`scalar deleting destructor'
PUBLIC	??0ColumnDescriptor@Table@DataStructures@@QAE@XZ ; DataStructures::Table::ColumnDescriptor::ColumnDescriptor
PUBLIC	??1ColumnDescriptor@Table@DataStructures@@QAE@XZ ; DataStructures::Table::ColumnDescriptor::~ColumnDescriptor
PUBLIC	??0ColumnDescriptor@Table@DataStructures@@QAE@QADW4ColumnType@12@@Z ; DataStructures::Table::ColumnDescriptor::ColumnDescriptor
PUBLIC	??_EColumnDescriptor@Table@DataStructures@@QAEPAXI@Z ; DataStructures::Table::ColumnDescriptor::`vector deleting destructor'
PUBLIC	??0?$List@PAUCell@Table@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::List<DataStructures::Table::Cell *>::List<DataStructures::Table::Cell *>
PUBLIC	??1?$List@PAUCell@Table@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::List<DataStructures::Table::Cell *>::~List<DataStructures::Table::Cell *>
PUBLIC	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
PUBLIC	?Insert@?$List@PAUCell@Table@DataStructures@@@DataStructures@@QAEXQAUCell@Table@2@@Z ; DataStructures::List<DataStructures::Table::Cell *>::Insert
PUBLIC	?RemoveAtIndex@?$List@PAUCell@Table@DataStructures@@@DataStructures@@QAEXI@Z ; DataStructures::List<DataStructures::Table::Cell *>::RemoveAtIndex
PUBLIC	?Del@?$List@PAUCell@Table@DataStructures@@@DataStructures@@QAEXI@Z ; DataStructures::List<DataStructures::Table::Cell *>::Del
PUBLIC	?Size@?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Table::Cell *>::Size
PUBLIC	?UpdateCell@Row@Table@DataStructures@@QAEXIH@Z	; DataStructures::Table::Row::UpdateCell
PUBLIC	?UpdateCell@Row@Table@DataStructures@@QAEXIPAD@Z ; DataStructures::Table::Row::UpdateCell
PUBLIC	?UpdateCell@Row@Table@DataStructures@@QAEXIHPAD@Z ; DataStructures::Table::Row::UpdateCell
PUBLIC	??0Row@Table@DataStructures@@QAE@XZ		; DataStructures::Table::Row::Row
PUBLIC	??1Row@Table@DataStructures@@QAE@XZ		; DataStructures::Table::Row::~Row
PUBLIC	??_GRow@Table@DataStructures@@QAEPAXI@Z		; DataStructures::Table::Row::`scalar deleting destructor'
PUBLIC	??0FilterQuery@Table@DataStructures@@QAE@XZ	; DataStructures::Table::FilterQuery::FilterQuery
PUBLIC	??1FilterQuery@Table@DataStructures@@QAE@XZ	; DataStructures::Table::FilterQuery::~FilterQuery
PUBLIC	??0FilterQuery@Table@DataStructures@@QAE@IPAUCell@12@W4FilterQueryType@12@@Z ; DataStructures::Table::FilterQuery::FilterQuery
PUBLIC	??0Table@DataStructures@@QAE@XZ			; DataStructures::Table::Table
PUBLIC	??1Table@DataStructures@@QAE@XZ			; DataStructures::Table::~Table
PUBLIC	?AddColumn@Table@DataStructures@@QAEIQADW4ColumnType@12@@Z ; DataStructures::Table::AddColumn
PUBLIC	?RemoveColumn@Table@DataStructures@@QAEXI@Z	; DataStructures::Table::RemoveColumn
PUBLIC	?ColumnIndex@Table@DataStructures@@QAEIQAD@Z	; DataStructures::Table::ColumnIndex
PUBLIC	?ColumnName@Table@DataStructures@@QAEPADI@Z	; DataStructures::Table::ColumnName
PUBLIC	?GetColumnType@Table@DataStructures@@QAE?AW4ColumnType@12@I@Z ; DataStructures::Table::GetColumnType
PUBLIC	?GetColumnCount@Table@DataStructures@@QBEIXZ	; DataStructures::Table::GetColumnCount
PUBLIC	?GetRowCount@Table@DataStructures@@QBEIXZ	; DataStructures::Table::GetRowCount
PUBLIC	?AddRow@Table@DataStructures@@QAEPAURow@12@I@Z	; DataStructures::Table::AddRow
PUBLIC	?AddRow@Table@DataStructures@@QAEPAURow@12@IAAV?$List@UCell@Table@DataStructures@@@2@@Z ; DataStructures::Table::AddRow
PUBLIC	?RemoveRow@Table@DataStructures@@QAEXI@Z	; DataStructures::Table::RemoveRow
PUBLIC	?RemoveRows@Table@DataStructures@@QAEXPAV12@@Z	; DataStructures::Table::RemoveRows
PUBLIC	?UpdateCell@Table@DataStructures@@QAE_NIIH@Z	; DataStructures::Table::UpdateCell
PUBLIC	?UpdateCell@Table@DataStructures@@QAE_NIIPAD@Z	; DataStructures::Table::UpdateCell
PUBLIC	?UpdateCell@Table@DataStructures@@QAE_NIIHPAD@Z	; DataStructures::Table::UpdateCell
PUBLIC	?GetRowByID@Table@DataStructures@@QAEPAURow@12@I@Z ; DataStructures::Table::GetRowByID
PUBLIC	?GetRowByIndex@Table@DataStructures@@QAEPAURow@12@I@Z ; DataStructures::Table::GetRowByIndex
PUBLIC	?QueryTable@Table@DataStructures@@QAEXPAIIPAUFilterQuery@12@I0IPAV12@@Z ; DataStructures::Table::QueryTable
PUBLIC	?SortTable@Table@DataStructures@@QAEXPAUSortQuery@12@IPAPAURow@12@@Z ; DataStructures::Table::SortTable
PUBLIC	?Clear@Table@DataStructures@@QAEXXZ		; DataStructures::Table::Clear
PUBLIC	?PrintRow@Table@DataStructures@@QAEXPADHD_NPAURow@12@@Z ; DataStructures::Table::PrintRow
PUBLIC	?GetColumns@Table@DataStructures@@QAEAAV?$List@UColumnDescriptor@Table@DataStructures@@@2@XZ ; DataStructures::Table::GetColumns
PUBLIC	?GetRows@Table@DataStructures@@QAEAAV?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@2@XZ ; DataStructures::Table::GetRows
PUBLIC	?GetListHead@Table@DataStructures@@QAEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@XZ ; DataStructures::Table::GetListHead
PUBLIC	?AddRowColumns@Table@DataStructures@@IAEPAURow@12@IPAU312@V?$List@I@2@@Z ; DataStructures::Table::AddRowColumns
PUBLIC	?DeleteRow@Table@DataStructures@@IAEXPAURow@12@@Z ; DataStructures::Table::DeleteRow
PUBLIC	?QueryRow@Table@DataStructures@@IAEXAAV?$List@I@2@0IPAURow@12@PAUFilterQuery@12@PAV12@@Z ; DataStructures::Table::QueryRow
PUBLIC	??0?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAE@XZ ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::BPlusTree<unsigned int,DataStructures::Table::Row *,16>
PUBLIC	??1?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAE@XZ ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::~BPlusTree<unsigned int,DataStructures::Table::Row *,16>
PUBLIC	?Get@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QBE_NIAAPAURow@Table@2@@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::Get
PUBLIC	?Delete@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAE_NI@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::Delete
PUBLIC	?Delete@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAE_NIAAPAURow@Table@2@@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::Delete
PUBLIC	?Insert@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAE_NIABQAURow@Table@2@@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::Insert
PUBLIC	?Clear@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAEXXZ ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::Clear
PUBLIC	?Size@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QBEIXZ ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::Size
PUBLIC	?GetListHead@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QBEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@XZ ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::GetListHead
PUBLIC	?ForEachData@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAEXP6AXPAURow@Table@2@H@Z@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::ForEachData
PUBLIC	?DeleteFromPageAtIndex@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEXHPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::DeleteFromPageAtIndex
PUBLIC	?FreePages@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEXXZ ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::FreePages
PUBLIC	?GetIndexOf@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IBE_NIPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@PAH@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::GetIndexOf
PUBLIC	?CanRotateLeft@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAE_NPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@H@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::CanRotateLeft
PUBLIC	?CanRotateRight@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAE_NPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@H@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::CanRotateRight
PUBLIC	?RotateRight@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEXPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@HPAUReturnAction@12@@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::RotateRight
PUBLIC	?RotateLeft@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEXPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@HPAUReturnAction@12@@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::RotateLeft
PUBLIC	?InsertIntoNode@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@IABQAURow@Table@2@HPAU32@1PAUReturnAction@12@@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::InsertIntoNode
PUBLIC	?InsertBranchDown@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@IABQAURow@Table@2@PAU32@PAUReturnAction@12@PA_N@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::InsertBranchDown
PUBLIC	?GetLeafFromKey@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IBEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@I@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::GetLeafFromKey
PUBLIC	?FindDeleteRebalance@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAE_NIPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@PA_NIPAUReturnAction@12@AAPAURow@Table@2@@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::FindDeleteRebalance
PUBLIC	?FixUnderflow@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAE_NHPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@IPAUReturnAction@12@@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::FixUnderflow
PUBLIC	?ShiftNodeLeft@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEXPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::ShiftNodeLeft
PUBLIC	?ShiftNodeRight@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEXPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::ShiftNodeRight
PUBLIC	??0?$MemoryPool@U?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::MemoryPool<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> >::MemoryPool<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> >
PUBLIC	??1?$MemoryPool@U?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::MemoryPool<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> >::~MemoryPool<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> >
PUBLIC	?Allocate@?$MemoryPool@U?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@XZ ; DataStructures::MemoryPool<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> >::Allocate
PUBLIC	?Release@?$MemoryPool@U?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAEXPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@@Z ; DataStructures::MemoryPool<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> >::Release
PUBLIC	??0?$List@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::List<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::List<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>
PUBLIC	??1?$List@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::List<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::~List<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>
PUBLIC	??A?$List@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QBEAAPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@1@I@Z ; DataStructures::List<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::operator[]
PUBLIC	?Insert@?$List@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAEXQAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@@Z ; DataStructures::List<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::Insert
PUBLIC	?Del@?$List@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAEXI@Z ; DataStructures::List<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::Del
PUBLIC	?Size@?$List@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::Size
PUBLIC	??0?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::List<DataStructures::Table::ColumnDescriptor>
PUBLIC	??1?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::~List<DataStructures::Table::ColumnDescriptor>
PUBLIC	??A?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEAAUColumnDescriptor@Table@1@I@Z ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::operator[]
PUBLIC	?Insert@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QAEXUColumnDescriptor@Table@2@@Z ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::Insert
PUBLIC	?RemoveAtIndex@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QAEXI@Z ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::RemoveAtIndex
PUBLIC	?Del@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QAEXI@Z ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::Del
PUBLIC	?Size@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::Size
PUBLIC	?Clear@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QAEX_N@Z ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::Clear
PUBLIC	?ExtendRows@@YAXPAURow@Table@DataStructures@@H@Z ; ExtendRows
PUBLIC	?FreeRow@@YAXPAURow@Table@DataStructures@@H@Z	; FreeRow
PUBLIC	??A?$List@UCell@Table@DataStructures@@@DataStructures@@QBEAAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell>::operator[]
PUBLIC	?Size@?$List@UCell@Table@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Table::Cell>::Size
PUBLIC	??0?$List@I@DataStructures@@QAE@XZ		; DataStructures::List<unsigned int>::List<unsigned int>
PUBLIC	??1?$List@I@DataStructures@@QAE@XZ		; DataStructures::List<unsigned int>::~List<unsigned int>
PUBLIC	??0?$List@I@DataStructures@@QAE@ABV01@@Z	; DataStructures::List<unsigned int>::List<unsigned int>
PUBLIC	??A?$List@I@DataStructures@@QBEAAII@Z		; DataStructures::List<unsigned int>::operator[]
PUBLIC	?Insert@?$List@I@DataStructures@@QAEXI@Z	; DataStructures::List<unsigned int>::Insert
PUBLIC	?Size@?$List@I@DataStructures@@QBEIXZ		; DataStructures::List<unsigned int>::Size
PUBLIC	?RowSort@@YAHABQAURow@Table@DataStructures@@0@Z	; RowSort
PUBLIC	??0?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<DataStructures::Table::Row *,DataStructures::Table::Row *,&RowSort>::OrderedList<DataStructures::Table::Row *,DataStructures::Table::Row *,&RowSort>
PUBLIC	??1?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<DataStructures::Table::Row *,DataStructures::Table::Row *,&RowSort>::~OrderedList<DataStructures::Table::Row *,DataStructures::Table::Row *,&RowSort>
PUBLIC	?GetIndexFromKey@?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QBEIABQAURow@Table@2@PA_N@Z ; DataStructures::OrderedList<DataStructures::Table::Row *,DataStructures::Table::Row *,&RowSort>::GetIndexFromKey
PUBLIC	?Insert@?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QAEIABQAURow@Table@2@0@Z ; DataStructures::OrderedList<DataStructures::Table::Row *,DataStructures::Table::Row *,&RowSort>::Insert
PUBLIC	??A?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QBEAAPAURow@Table@1@I@Z ; DataStructures::OrderedList<DataStructures::Table::Row *,DataStructures::Table::Row *,&RowSort>::operator[]
PUBLIC	?Clear@?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QAEXXZ ; DataStructures::OrderedList<DataStructures::Table::Row *,DataStructures::Table::Row *,&RowSort>::Clear
PUBLIC	?Size@?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<DataStructures::Table::Row *,DataStructures::Table::Row *,&RowSort>::Size
PUBLIC	??0?$List@PAURow@Table@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::List<DataStructures::Table::Row *>::List<DataStructures::Table::Row *>
PUBLIC	??1?$List@PAURow@Table@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::List<DataStructures::Table::Row *>::~List<DataStructures::Table::Row *>
PUBLIC	??A?$List@PAURow@Table@DataStructures@@@DataStructures@@QBEAAPAURow@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Row *>::operator[]
PUBLIC	?Insert@?$List@PAURow@Table@DataStructures@@@DataStructures@@QAEXQAURow@Table@2@I@Z ; DataStructures::List<DataStructures::Table::Row *>::Insert
PUBLIC	?Insert@?$List@PAURow@Table@DataStructures@@@DataStructures@@QAEXQAURow@Table@2@@Z ; DataStructures::List<DataStructures::Table::Row *>::Insert
PUBLIC	?Size@?$List@PAURow@Table@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Table::Row *>::Size
PUBLIC	?Clear@?$List@PAURow@Table@DataStructures@@@DataStructures@@QAEX_N@Z ; DataStructures::List<DataStructures::Table::Row *>::Clear
PUBLIC	??0?$Queue@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::Queue<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::Queue<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>
PUBLIC	??1?$Queue@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::Queue<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::~Queue<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>
PUBLIC	?Push@?$Queue@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAEXABQAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@@Z ; DataStructures::Queue<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::Push
PUBLIC	?Pop@?$Queue@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@XZ ; DataStructures::Queue<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::Pop
PUBLIC	?Size@?$Queue@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::Queue<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::Size
PUBLIC	?__LINE__Var@?1??Set@Cell@Table@DataStructures@@QAEXH@Z@4JA ; `DataStructures::Table::Cell::Set'::`2'::__LINE__Var
PUBLIC	??_C@_1EK@GEFGNEFE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAt?$AAa?$AAb?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1BA@MHHNNPBM@?$AAi?$AAs?$AAE?$AAm?$AAp?$AAt?$AAy?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??Set@Cell@Table@DataStructures@@QAEXPAD@Z@4JA ; `DataStructures::Table::Cell::Set'::`2'::__LINE__Var
PUBLIC	?__LINE__Var@?1??Set@Cell@Table@DataStructures@@QAEXPADH@Z@4JA ; `DataStructures::Table::Cell::Set'::`2'::__LINE__Var
PUBLIC	?__LINE__Var@?1??Get@Cell@Table@DataStructures@@QAEXPAH@Z@4JA ; `DataStructures::Table::Cell::Get'::`2'::__LINE__Var
PUBLIC	??_C@_1BO@OLJOILKC@?$AAi?$AAs?$AAE?$AAm?$AAp?$AAt?$AAy?$AA?$DN?$AA?$DN?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??Get@Cell@Table@DataStructures@@QAEXPAD@Z@4JA ; `DataStructures::Table::Cell::Get'::`2'::__LINE__Var
PUBLIC	?__LINE__Var@?1??Get@Cell@Table@DataStructures@@QAEXPADPAH@Z@4JA ; `DataStructures::Table::Cell::Get'::`2'::__LINE__Var
PUBLIC	?__LINE__Var@?1??UpdateCell@Table@DataStructures@@QAE_NIIH@Z@4JA ; `DataStructures::Table::UpdateCell'::`2'::__LINE__Var
PUBLIC	??_C@_1FC@CHFBNAKC@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?$FL?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?$FN?$AA?4?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAT?$AAy?$AAp?$AAe?$AA?$DN@ ; `string'
PUBLIC	?__LINE__Var@?1??UpdateCell@Table@DataStructures@@QAE_NIIPAD@Z@4JA ; `DataStructures::Table::UpdateCell'::`2'::__LINE__Var
PUBLIC	??_C@_1FA@KGODCHJF@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?$FL?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?$FN?$AA?4?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAT?$AAy?$AAp?$AAe?$AA?$DN@ ; `string'
PUBLIC	?__LINE__Var@?1??UpdateCell@Table@DataStructures@@QAE_NIIHPAD@Z@4JA ; `DataStructures::Table::UpdateCell'::`2'::__LINE__Var
PUBLIC	??_C@_1FA@OFEMIOAC@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?$FL?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?$FN?$AA?4?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAT?$AAy?$AAp?$AAe?$AA?$DN@ ; `string'
PUBLIC	??_C@_0CJ@PKINFIOI@Cell?5width?5does?5not?5match?5column@ ; `string'
PUBLIC	??_C@_02IKAHHCAI@?$CFi?$AA@			; `string'
PUBLIC	??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@ ; `string'
PUBLIC	??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EO@DHNPHPFC@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAb?$AAp?$AAl?$AAu?$AAs@ ; `string'
PUBLIC	??_C@_1GM@PECFPFGO@?$AAr?$AAe?$AAt?$AAu?$AAr?$AAn?$AAA?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?4?$AAa?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$DN?$AA?$DN?$AAR?$AAe?$AAt?$AAu?$AAr?$AAn?$AAA?$AAc?$AAt?$AAi?$AAo@ ; `string'
PUBLIC	??_C@_1BO@JBFMBKMD@?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$DO?$AA?$DN?$AAn?$AAu?$AAm?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BK@CAFOCCOP@?$AAp?$AAa?$AAg?$AAe?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$DO?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1GO@DFNPOHCN@?$AAr?$AAe?$AAt?$AAu?$AAr?$AAn?$AAA?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?9?$AA?$DO?$AAa?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$DN?$AA?$DN?$AAR?$AAe?$AAt?$AAu?$AAr?$AAn?$AAA?$AAc?$AAt?$AAi@ ; `string'
PUBLIC	??_C@_1FA@EECGGCBA@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAm?$AAe?$AAm?$AAo?$AAr@ ; `string'
PUBLIC	??_C@_1BK@JNGCOJCH@?$AAb?$AAl?$AAo?$AAc?$AAk?$AAs?$AAO?$AAu?$AAt?$AA?$DN?$AA?$DN?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BI@OFKIDLPK@?$AAb?$AAl?$AAo?$AAc?$AAk?$AAs?$AAO?$AAu?$AAt?$AA?$DO?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CM@FMCFHBCK@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@GBMFMLDI@?$AAb?$AA?$DN?$AA?$DN?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@ ; `string'
PUBLIC	??_C@_1BE@OMEGJCHO@?$AAn?$AAe?$AAw?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?$AA@ ; `string'
PUBLIC	??_C@_1GG@JDEIIJCO@?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN@ ; `string'
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__wassert:PROC
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strcpy:PROC
EXTRN	_strcmp:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	_strncpy:PROC
EXTRN	_sprintf:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_UninitUse:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
__sortQueries DD 01H DUP (?)
__numSortQueries DD 01H DUP (?)
__columnIndices DD 01H DUP (?)
__columns DD	01H DUP (?)
_BSS	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_1GG@JDEIIJCO@?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN@
CONST	SEGMENT
??_C@_1GG@JDEIIJCO@?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN@ DB 'a'
	DB	00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H
	DB	'i', 00H, 'o', 00H, 'n', 00H, '_', 00H, 's', 00H, 'i', 00H, 'z'
	DB	00H, 'e', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e'
	DB	00H, '(', 00H, ')', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H
	DB	'0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'h', 00H, 'e'
	DB	00H, 'a', 00H, 'd', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H
	DB	't', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@OMEGJCHO@?$AAn?$AAe?$AAw?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@OMEGJCHO@?$AAn?$AAe?$AAw?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?$AA@ DB 'n'
	DB	00H, 'e', 00H, 'w', 00H, '_', 00H, 'a', 00H, 'r', 00H, 'r', 00H
	DB	'a', 00H, 'y', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@
CONST	SEGMENT
??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@ DB 'z'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H
	DB	's', 00H, 'r', 00H, 'c', 00H, '\', 00H, '0', 00H, '2', 00H, 'x'
	DB	00H, 'u', 00H, '1', 00H, '\', 00H, 'r', 00H, 'a', 00H, 'k', 00H
	DB	'n', 00H, 'e', 00H, 't', 00H, '\', 00H, 'd', 00H, 's', 00H, '_'
	DB	00H, 'q', 00H, 'u', 00H, 'e', 00H, 'u', 00H, 'e', 00H, '.', 00H
	DB	'h', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@GBMFMLDI@?$AAb?$AA?$DN?$AA?$DN?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@GBMFMLDI@?$AAb?$AA?$DN?$AA?$DN?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@ DB 'b'
	DB	00H, '=', 00H, '=', 00H, 'f', 00H, 'a', 00H, 'l', 00H, 's', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CM@FMCFHBCK@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@FMCFHBCK@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ DB 'p'
	DB	00H, 'o', 00H, 's', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'o', 00H
	DB	'n', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'l', 00H, 'i'
	DB	00H, 's', 00H, 't', 00H, '_', 00H, 's', 00H, 'i', 00H, 'z', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@OFKIDLPK@?$AAb?$AAl?$AAo?$AAc?$AAk?$AAs?$AAO?$AAu?$AAt?$AA?$DO?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@OFKIDLPK@?$AAb?$AAl?$AAo?$AAc?$AAk?$AAs?$AAO?$AAu?$AAt?$AA?$DO?$AA0?$AA?$AA@ DB 'b'
	DB	00H, 'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, 's', 00H, 'O', 00H
	DB	'u', 00H, 't', 00H, '>', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@JNGCOJCH@?$AAb?$AAl?$AAo?$AAc?$AAk?$AAs?$AAO?$AAu?$AAt?$AA?$DN?$AA?$DN?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@JNGCOJCH@?$AAb?$AAl?$AAo?$AAc?$AAk?$AAs?$AAO?$AAu?$AAt?$AA?$DN?$AA?$DN?$AA0?$AA?$AA@ DB 'b'
	DB	00H, 'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, 's', 00H, 'O', 00H
	DB	'u', 00H, 't', 00H, '=', 00H, '=', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FA@EECGGCBA@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAm?$AAe?$AAm?$AAo?$AAr@
CONST	SEGMENT
??_C@_1FA@EECGGCBA@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAm?$AAe?$AAm?$AAo?$AAr@ DB 'z'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H
	DB	's', 00H, 'r', 00H, 'c', 00H, '\', 00H, '0', 00H, '2', 00H, 'x'
	DB	00H, 'u', 00H, '1', 00H, '\', 00H, 'r', 00H, 'a', 00H, 'k', 00H
	DB	'n', 00H, 'e', 00H, 't', 00H, '\', 00H, 'd', 00H, 's', 00H, '_'
	DB	00H, 'm', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H
	DB	'p', 00H, 'o', 00H, 'o', 00H, 'l', 00H, '.', 00H, 'h', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1GO@DFNPOHCN@?$AAr?$AAe?$AAt?$AAu?$AAr?$AAn?$AAA?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?9?$AA?$DO?$AAa?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$DN?$AA?$DN?$AAR?$AAe?$AAt?$AAu?$AAr?$AAn?$AAA?$AAc?$AAt?$AAi@
CONST	SEGMENT
??_C@_1GO@DFNPOHCN@?$AAr?$AAe?$AAt?$AAu?$AAr?$AAn?$AAA?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?9?$AA?$DO?$AAa?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$DN?$AA?$DN?$AAR?$AAe?$AAt?$AAu?$AAr?$AAn?$AAA?$AAc?$AAt?$AAi@ DB 'r'
	DB	00H, 'e', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'n', 00H, 'A', 00H
	DB	'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, '-', 00H, '>'
	DB	00H, 'a', 00H, 'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H
	DB	'=', 00H, '=', 00H, 'R', 00H, 'e', 00H, 't', 00H, 'u', 00H, 'r'
	DB	00H, 'n', 00H, 'A', 00H, 'c', 00H, 't', 00H, 'i', 00H, 'o', 00H
	DB	'n', 00H, ':', 00H, ':', 00H, 'P', 00H, 'U', 00H, 'S', 00H, 'H'
	DB	00H, '_', 00H, 'K', 00H, 'E', 00H, 'Y', 00H, '_', 00H, 'T', 00H
	DB	'O', 00H, '_', 00H, 'P', 00H, 'A', 00H, 'R', 00H, 'E', 00H, 'N'
	DB	00H, 'T', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@CAFOCCOP@?$AAp?$AAa?$AAg?$AAe?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$DO?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@CAFOCCOP@?$AAp?$AAa?$AAg?$AAe?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$DO?$AA0?$AA?$AA@ DB 'p'
	DB	00H, 'a', 00H, 'g', 00H, 'e', 00H, '-', 00H, '>', 00H, 's', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, '>', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@JBFMBKMD@?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$DO?$AA?$DN?$AAn?$AAu?$AAm?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@JBFMBKMD@?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$DO?$AA?$DN?$AAn?$AAu?$AAm?$AA?$AA@ DB 'l'
	DB	00H, 'i', 00H, 's', 00H, 't', 00H, '_', 00H, 's', 00H, 'i', 00H
	DB	'z', 00H, 'e', 00H, '>', 00H, '=', 00H, 'n', 00H, 'u', 00H, 'm'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1GM@PECFPFGO@?$AAr?$AAe?$AAt?$AAu?$AAr?$AAn?$AAA?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?4?$AAa?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$DN?$AA?$DN?$AAR?$AAe?$AAt?$AAu?$AAr?$AAn?$AAA?$AAc?$AAt?$AAi?$AAo@
CONST	SEGMENT
??_C@_1GM@PECFPFGO@?$AAr?$AAe?$AAt?$AAu?$AAr?$AAn?$AAA?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?4?$AAa?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$DN?$AA?$DN?$AAR?$AAe?$AAt?$AAu?$AAr?$AAn?$AAA?$AAc?$AAt?$AAi?$AAo@ DB 'r'
	DB	00H, 'e', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'n', 00H, 'A', 00H
	DB	'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, '.', 00H, 'a'
	DB	00H, 'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, '=', 00H
	DB	'=', 00H, 'R', 00H, 'e', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'n'
	DB	00H, 'A', 00H, 'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H
	DB	':', 00H, ':', 00H, 'P', 00H, 'U', 00H, 'S', 00H, 'H', 00H, '_'
	DB	00H, 'K', 00H, 'E', 00H, 'Y', 00H, '_', 00H, 'T', 00H, 'O', 00H
	DB	'_', 00H, 'P', 00H, 'A', 00H, 'R', 00H, 'E', 00H, 'N', 00H, 'T'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1EO@DHNPHPFC@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAb?$AAp?$AAl?$AAu?$AAs@
CONST	SEGMENT
??_C@_1EO@DHNPHPFC@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAb?$AAp?$AAl?$AAu?$AAs@ DB 'z'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H
	DB	's', 00H, 'r', 00H, 'c', 00H, '\', 00H, '0', 00H, '2', 00H, 'x'
	DB	00H, 'u', 00H, '1', 00H, '\', 00H, 'r', 00H, 'a', 00H, 'k', 00H
	DB	'n', 00H, 'e', 00H, 't', 00H, '\', 00H, 'd', 00H, 's', 00H, '_'
	DB	00H, 'b', 00H, 'p', 00H, 'l', 00H, 'u', 00H, 's', 00H, 't', 00H
	DB	'r', 00H, 'e', 00H, 'e', 00H, '.', 00H, 'h', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ DB 'p'
	DB	00H, 'o', 00H, 's', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'o', 00H
	DB	'n', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'l', 00H, 'i', 00H, 's'
	DB	00H, 't', 00H, '_', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
CONST	SEGMENT
??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@ DB 'z'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H
	DB	's', 00H, 'r', 00H, 'c', 00H, '\', 00H, '0', 00H, '2', 00H, 'x'
	DB	00H, 'u', 00H, '1', 00H, '\', 00H, 'r', 00H, 'a', 00H, 'k', 00H
	DB	'n', 00H, 'e', 00H, 't', 00H, '\', 00H, 'd', 00H, 's', 00H, '_'
	DB	00H, 'l', 00H, 'i', 00H, 's', 00H, 't', 00H, '.', 00H, 'h', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_02IKAHHCAI@?$CFi?$AA@
CONST	SEGMENT
??_C@_02IKAHHCAI@?$CFi?$AA@ DB '%i', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@PKINFIOI@Cell?5width?5does?5not?5match?5column@
CONST	SEGMENT
??_C@_0CJ@PKINFIOI@Cell?5width?5does?5not?5match?5column@ DB 'Cell width '
	DB	'does not match column width.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1FA@OFEMIOAC@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?$FL?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?$FN?$AA?4?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAT?$AAy?$AAp?$AAe?$AA?$DN@
CONST	SEGMENT
??_C@_1FA@OFEMIOAC@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?$FL?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?$FN?$AA?4?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAT?$AAy?$AAp?$AAe?$AA?$DN@ DB 'c'
	DB	00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, 's', 00H
	DB	'[', 00H, 'c', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n'
	DB	00H, 'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, ']', 00H
	DB	'.', 00H, 'c', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n'
	DB	00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H, '=', 00H, '=', 00H
	DB	'B', 00H, 'I', 00H, 'N', 00H, 'A', 00H, 'R', 00H, 'Y', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??UpdateCell@Table@DataStructures@@QAE_NIIHPAD@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??UpdateCell@Table@DataStructures@@QAE_NIIHPAD@Z@4JA DD 0154H ; `DataStructures::Table::UpdateCell'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1FA@KGODCHJF@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?$FL?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?$FN?$AA?4?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAT?$AAy?$AAp?$AAe?$AA?$DN@
CONST	SEGMENT
??_C@_1FA@KGODCHJF@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?$FL?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?$FN?$AA?4?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAT?$AAy?$AAp?$AAe?$AA?$DN@ DB 'c'
	DB	00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, 's', 00H
	DB	'[', 00H, 'c', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n'
	DB	00H, 'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, ']', 00H
	DB	'.', 00H, 'c', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n'
	DB	00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H, '=', 00H, '=', 00H
	DB	'S', 00H, 'T', 00H, 'R', 00H, 'I', 00H, 'N', 00H, 'G', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??UpdateCell@Table@DataStructures@@QAE_NIIPAD@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??UpdateCell@Table@DataStructures@@QAE_NIIPAD@Z@4JA DD 0148H ; `DataStructures::Table::UpdateCell'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1FC@CHFBNAKC@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?$FL?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?$FN?$AA?4?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAT?$AAy?$AAp?$AAe?$AA?$DN@
CONST	SEGMENT
??_C@_1FC@CHFBNAKC@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?$FL?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?$FN?$AA?4?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAT?$AAy?$AAp?$AAe?$AA?$DN@ DB 'c'
	DB	00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n', 00H, 's', 00H
	DB	'[', 00H, 'c', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n'
	DB	00H, 'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, ']', 00H
	DB	'.', 00H, 'c', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'n'
	DB	00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H, '=', 00H, '=', 00H
	DB	'N', 00H, 'U', 00H, 'M', 00H, 'E', 00H, 'R', 00H, 'I', 00H, 'C'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??UpdateCell@Table@DataStructures@@QAE_NIIH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??UpdateCell@Table@DataStructures@@QAE_NIIH@Z@4JA DD 013cH ; `DataStructures::Table::UpdateCell'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??Get@Cell@Table@DataStructures@@QAEXPADPAH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??Get@Cell@Table@DataStructures@@QAEXPADPAH@Z@4JA DD 071H ; `DataStructures::Table::Cell::Get'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??Get@Cell@Table@DataStructures@@QAEXPAD@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??Get@Cell@Table@DataStructures@@QAEXPAD@Z@4JA DD 06cH ; `DataStructures::Table::Cell::Get'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1BO@OLJOILKC@?$AAi?$AAs?$AAE?$AAm?$AAp?$AAt?$AAy?$AA?$DN?$AA?$DN?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@OLJOILKC@?$AAi?$AAs?$AAE?$AAm?$AAp?$AAt?$AAy?$AA?$DN?$AA?$DN?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@ DB 'i'
	DB	00H, 's', 00H, 'E', 00H, 'm', 00H, 'p', 00H, 't', 00H, 'y', 00H
	DB	'=', 00H, '=', 00H, 'f', 00H, 'a', 00H, 'l', 00H, 's', 00H, 'e'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??Get@Cell@Table@DataStructures@@QAEXPAH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??Get@Cell@Table@DataStructures@@QAEXPAH@Z@4JA DD 067H ; `DataStructures::Table::Cell::Get'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??Set@Cell@Table@DataStructures@@QAEXPADH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??Set@Cell@Table@DataStructures@@QAEXPADH@Z@4JA DD 057H ; `DataStructures::Table::Cell::Set'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??Set@Cell@Table@DataStructures@@QAEXPAD@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??Set@Cell@Table@DataStructures@@QAEXPAD@Z@4JA DD 049H ; `DataStructures::Table::Cell::Set'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1BA@MHHNNPBM@?$AAi?$AAs?$AAE?$AAm?$AAp?$AAt?$AAy?$AA?$AA@
CONST	SEGMENT
??_C@_1BA@MHHNNPBM@?$AAi?$AAs?$AAE?$AAm?$AAp?$AAt?$AAy?$AA?$AA@ DB 'i', 00H
	DB	's', 00H, 'E', 00H, 'm', 00H, 'p', 00H, 't', 00H, 'y', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1EK@GEFGNEFE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAt?$AAa?$AAb?$AAl?$AAe@
CONST	SEGMENT
??_C@_1EK@GEFGNEFE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAt?$AAa?$AAb?$AAl?$AAe@ DB 'z'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H
	DB	's', 00H, 'r', 00H, 'c', 00H, '\', 00H, '0', 00H, '2', 00H, 'x'
	DB	00H, 'u', 00H, '1', 00H, '\', 00H, 'r', 00H, 'a', 00H, 'k', 00H
	DB	'n', 00H, 'e', 00H, 't', 00H, '\', 00H, 'd', 00H, 's', 00H, '_'
	DB	00H, 't', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '.', 00H
	DB	'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??Set@Cell@Table@DataStructures@@QAEXH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??Set@Cell@Table@DataStructures@@QAEXH@Z@4JA DD 042H ; `DataStructures::Table::Cell::Set'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QAE@XZ$0
__ehfuncinfo$??1?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ExtendRows@@YAXPAURow@Table@DataStructures@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ExtendRows@@YAXPAURow@Table@DataStructures@@H@Z$0
__ehfuncinfo$?ExtendRows@@YAXPAURow@Table@DataStructures@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ExtendRows@@YAXPAURow@Table@DataStructures@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Insert@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QAEXUColumnDescriptor@Table@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Insert@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QAEXUColumnDescriptor@Table@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Insert@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QAEXUColumnDescriptor@Table@2@@Z$1
__ehfuncinfo$?Insert@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QAEXUColumnDescriptor@Table@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Insert@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QAEXUColumnDescriptor@Table@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$MemoryPool@U?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$MemoryPool@U?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAE@XZ$0
__ehfuncinfo$??1?$MemoryPool@U?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$MemoryPool@U?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?FreePages@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FreePages@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEXXZ$0
__ehfuncinfo$?FreePages@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FreePages@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAE@XZ$0
__ehfuncinfo$??1?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?AddRowColumns@Table@DataStructures@@IAEPAURow@12@IPAU312@V?$List@I@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddRowColumns@Table@DataStructures@@IAEPAURow@12@IPAU312@V?$List@I@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?AddRowColumns@Table@DataStructures@@IAEPAURow@12@IPAU312@V?$List@I@2@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?AddRowColumns@Table@DataStructures@@IAEPAURow@12@IPAU312@V?$List@I@2@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?AddRowColumns@Table@DataStructures@@IAEPAURow@12@IPAU312@V?$List@I@2@@Z$3
__ehfuncinfo$?AddRowColumns@Table@DataStructures@@IAEPAURow@12@IPAU312@V?$List@I@2@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?AddRowColumns@Table@DataStructures@@IAEPAURow@12@IPAU312@V?$List@I@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SortTable@Table@DataStructures@@QAEXPAUSortQuery@12@IPAPAURow@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SortTable@Table@DataStructures@@QAEXPAUSortQuery@12@IPAPAURow@12@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SortTable@Table@DataStructures@@QAEXPAUSortQuery@12@IPAPAURow@12@@Z$1
__ehfuncinfo$?SortTable@Table@DataStructures@@QAEXPAUSortQuery@12@IPAPAURow@12@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?SortTable@Table@DataStructures@@QAEXPAUSortQuery@12@IPAPAURow@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?QueryTable@Table@DataStructures@@QAEXPAIIPAUFilterQuery@12@I0IPAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?QueryTable@Table@DataStructures@@QAEXPAIIPAUFilterQuery@12@I0IPAV12@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?QueryTable@Table@DataStructures@@QAEXPAIIPAUFilterQuery@12@I0IPAV12@@Z$1
__ehfuncinfo$?QueryTable@Table@DataStructures@@QAEXPAIIPAUFilterQuery@12@I0IPAV12@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?QueryTable@Table@DataStructures@@QAEXPAIIPAUFilterQuery@12@I0IPAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?AddRow@Table@DataStructures@@QAEPAURow@12@IAAV?$List@UCell@Table@DataStructures@@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddRow@Table@DataStructures@@QAEPAURow@12@IAAV?$List@UCell@Table@DataStructures@@@2@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddRow@Table@DataStructures@@QAEPAURow@12@IAAV?$List@UCell@Table@DataStructures@@@2@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddRow@Table@DataStructures@@QAEPAURow@12@IAAV?$List@UCell@Table@DataStructures@@@2@@Z$2
__ehfuncinfo$?AddRow@Table@DataStructures@@QAEPAURow@12@IAAV?$List@UCell@Table@DataStructures@@@2@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?AddRow@Table@DataStructures@@QAEPAURow@12@IAAV?$List@UCell@Table@DataStructures@@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?AddRow@Table@DataStructures@@QAEPAURow@12@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddRow@Table@DataStructures@@QAEPAURow@12@I@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddRow@Table@DataStructures@@QAEPAURow@12@I@Z$1
__ehfuncinfo$?AddRow@Table@DataStructures@@QAEPAURow@12@I@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AddRow@Table@DataStructures@@QAEPAURow@12@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?AddColumn@Table@DataStructures@@QAEIQADW4ColumnType@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddColumn@Table@DataStructures@@QAEIQADW4ColumnType@12@@Z$0
__ehfuncinfo$?AddColumn@Table@DataStructures@@QAEIQADW4ColumnType@12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddColumn@Table@DataStructures@@QAEIQADW4ColumnType@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1Table@DataStructures@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1Table@DataStructures@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1Table@DataStructures@@QAE@XZ$1
__ehfuncinfo$??1Table@DataStructures@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1Table@DataStructures@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Table@DataStructures@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Table@DataStructures@@QAE@XZ$0
__ehfuncinfo$??0Table@DataStructures@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0Table@DataStructures@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ?Size@?$Queue@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$Queue@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QBEIXZ PROC ; DataStructures::Queue<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::Size, COMDAT
; _this$ = ecx

; 62   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 63   : 		if ( head <= tail )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	ja	SHORT $LN2@Size

; 64   : 			return tail -head;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	jmp	SHORT $LN3@Size

; 65   : 		else

	jmp	SHORT $LN3@Size
$LN2@Size:

; 66   : 			return allocation_size -head + tail;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx+8]
$LN3@Size:

; 67   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$Queue@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QBEIXZ ENDP ; DataStructures::Queue<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ?Pop@?$Queue@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@XZ
_TEXT	SEGMENT
tv78 = -208						; size = 4
_this$ = -8						; size = 4
?Pop@?$Queue@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@XZ PROC ; DataStructures::Queue<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::Pop, COMDAT
; _this$ = ecx

; 99   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 100  : #ifdef _DEBUG
; 101  : 		assert( allocation_size > 0 && Size() >= 0 && head != tail);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jbe	SHORT $LN5@Pop
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$Queue@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::Queue<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::Size
	test	eax, eax
	jb	SHORT $LN5@Pop
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN6@Pop
$LN5@Pop:
	push	101					; 00000065H
	push	OFFSET ??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@
	push	OFFSET ??_C@_1GG@JDEIIJCO@?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN6@Pop:

; 102  : #endif
; 103  : 		//head=(head+1) % allocation_size;
; 104  : 
; 105  : 		if ( ++head == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	DWORD PTR tv78[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv78[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv78[ebp]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN2@Pop

; 106  : 			head = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
$LN2@Pop:

; 107  : 
; 108  : 		if ( head == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN1@Pop

; 109  : 			return ( queue_type ) array[ allocation_size -1 ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+ecx*4-4]
	jmp	SHORT $LN3@Pop
$LN1@Pop:

; 110  : 
; 111  : 		return ( queue_type ) array[ head -1 ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+ecx*4-4]
$LN3@Pop:

; 112  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Pop@?$Queue@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@XZ ENDP ; DataStructures::Queue<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::Pop
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ?Push@?$Queue@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAEXABQAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@@Z
_TEXT	SEGMENT
$T1 = -260						; size = 4
$T2 = -248						; size = 4
$T3 = -236						; size = 4
_counter$4 = -32					; size = 4
_new_array$5 = -20					; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
?Push@?$Queue@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAEXABQAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@@Z PROC ; DataStructures::Queue<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::Push, COMDAT
; _this$ = ecx

; 182  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 183  : 		if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN6@Push

; 184  : 		{
; 185  : 			array = new queue_type[ 16 ];

	push	64					; 00000040H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax], ecx

; 186  : 			head = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 187  : 			tail = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 1

; 188  : 			array[ 0 ] = input;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+eax], edx

; 189  : 			allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 16			; 00000010H

; 190  : 			return ;

	jmp	$LN7@Push
$LN6@Push:

; 191  : 		}
; 192  : 
; 193  : 		array[ tail++ ] = input;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [eax+ecx*4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 194  : 
; 195  : 		if ( tail == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN5@Push

; 196  : 			tail = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
$LN5@Push:

; 197  : 
; 198  : 		if ( tail == head )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+4]
	jne	$LN7@Push

; 199  : 		{
; 200  : 			//  unsigned int index=tail;
; 201  : 
; 202  : 			// Need to allocate more memory.
; 203  : 			queue_type * new_array;
; 204  : 			new_array = new queue_type[ allocation_size * 2 ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	shl	eax, 1
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _new_array$5[ebp], eax

; 205  : #ifdef _DEBUG
; 206  : 
; 207  : 			assert( new_array );

	cmp	DWORD PTR _new_array$5[ebp], 0
	jne	SHORT $LN9@Push
	push	207					; 000000cfH
	push	OFFSET ??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@
	push	OFFSET ??_C@_1BE@OMEGJCHO@?$AAn?$AAe?$AAw?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN9@Push:

; 208  : #endif
; 209  : 
; 210  : 			for ( unsigned int counter = 0; counter < allocation_size; ++counter )

	mov	DWORD PTR _counter$4[ebp], 0
	jmp	SHORT $LN3@Push
$LN2@Push:
	mov	eax, DWORD PTR _counter$4[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$4[ebp], eax
$LN3@Push:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _counter$4[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN1@Push

; 211  : 				new_array[ counter ] = array[ ( head + counter ) % ( allocation_size ) ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, DWORD PTR _counter$4[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _counter$4[ebp]
	mov	esi, DWORD PTR _new_array$5[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [esi+eax*4], ecx
	jmp	SHORT $LN2@Push
$LN1@Push:

; 212  : 
; 213  : 			head = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 214  : 
; 215  : 			tail = allocation_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+8], edx

; 216  : 
; 217  : 			allocation_size *= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 218  : 
; 219  : 			// Delete the old array and move the pointer to the new array
; 220  : 			delete [] array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T3[ebp], ecx
	mov	edx, DWORD PTR $T3[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 221  : 
; 222  : 			array = new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$5[ebp]
	mov	DWORD PTR [eax], ecx
$LN7@Push:

; 223  : 		}
; 224  : 
; 225  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Push@?$Queue@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAEXABQAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@@Z ENDP ; DataStructures::Queue<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::Push
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ??1?$Queue@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
??1?$Queue@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAE@XZ PROC ; DataStructures::Queue<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::~Queue<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>, COMDAT
; _this$ = ecx

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		if (allocation_size>0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jbe	SHORT $LN2@Queue

; 94   : 			delete [] array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@Queue:

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$Queue@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAE@XZ ENDP ; DataStructures::Queue<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::~Queue<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ??0?$Queue@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
??0?$Queue@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAE@XZ PROC ; DataStructures::Queue<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::Queue<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>, COMDAT
; _this$ = ecx

; 83   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 84   : 		allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 16			; 00000010H

; 85   : 		array = new queue_type[ allocation_size ];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax], ecx

; 86   : 		head = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 87   : 		tail = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 88   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$Queue@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAE@XZ ENDP ; DataStructures::Queue<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::Queue<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Clear@?$List@PAURow@Table@DataStructures@@@DataStructures@@QAEX_N@Z
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
_doNotDeallocate$ = 8					; size = 1
?Clear@?$List@PAURow@Table@DataStructures@@@DataStructures@@QAEX_N@Z PROC ; DataStructures::List<DataStructures::Table::Row *>::Clear, COMDAT
; _this$ = ecx

; 379  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  : 		if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Clear

; 381  : 			return;

	jmp	SHORT $LN3@Clear
$LN2@Clear:

; 382  : 
; 383  : 		if (allocation_size>512 && doNotDeallocate==false)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 512			; 00000200H
	jbe	SHORT $LN1@Clear
	movzx	eax, BYTE PTR _doNotDeallocate$[ebp]
	test	eax, eax
	jne	SHORT $LN1@Clear

; 384  : 		{
; 385  : 			delete [] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 386  : 			allocation_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 387  : 			listArray = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN1@Clear:

; 388  : 		}
; 389  : 		list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
$LN3@Clear:

; 390  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Clear@?$List@PAURow@Table@DataStructures@@@DataStructures@@QAEX_N@Z ENDP ; DataStructures::List<DataStructures::Table::Row *>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Size@?$List@PAURow@Table@DataStructures@@@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$List@PAURow@Table@DataStructures@@@DataStructures@@QBEIXZ PROC ; DataStructures::List<DataStructures::Table::Row *>::Size, COMDAT
; _this$ = ecx

; 373  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 374  : 		return list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 375  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$List@PAURow@Table@DataStructures@@@DataStructures@@QBEIXZ ENDP ; DataStructures::List<DataStructures::Table::Row *>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Insert@?$List@PAURow@Table@DataStructures@@@DataStructures@@QAEXQAURow@Table@2@@Z
_TEXT	SEGMENT
$T1 = -236						; size = 4
$T2 = -224						; size = 4
_new_array$3 = -20					; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
?Insert@?$List@PAURow@Table@DataStructures@@@DataStructures@@QAEXQAURow@Table@2@@Z PROC ; DataStructures::List<DataStructures::Table::Row *>::Insert, COMDAT
; _this$ = ecx

; 242  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 243  : 		// Reallocate list if necessary
; 244  : 
; 245  : 		if ( list_size == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	$LN3@Insert

; 246  : 		{
; 247  : 			// allocate twice the currently allocated memory
; 248  : 			list_type * new_array;
; 249  : 
; 250  : 			if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Insert

; 251  : 				allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 16			; 00000010H

; 252  : 			else

	jmp	SHORT $LN1@Insert
$LN2@Insert:

; 253  : 				allocation_size *= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN1@Insert:

; 254  : 
; 255  : 			new_array = new list_type [ allocation_size ];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _new_array$3[ebp], eax

; 256  : 
; 257  : 			// copy old array over
; 258  : 			//	for ( unsigned int counter = 0; counter < list_size; ++counter )
; 259  : 			//		new_array[ counter ] = listArray[ counter ];
; 260  : 
; 261  : 			// Don't call constructors, assignment operators, etc.
; 262  : 			memcpy(new_array, listArray, list_size*sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _new_array$3[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 263  : 
; 264  : 			// set old array to point to the newly allocated and twice as large array
; 265  : 			delete[] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 266  : 
; 267  : 			listArray = new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$3[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Insert:

; 268  : 		}
; 269  : 
; 270  : 		// Insert the new item at the correct spot
; 271  : 		listArray[ list_size ] = input;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _input$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 272  : 
; 273  : 		++list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 274  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Insert@?$List@PAURow@Table@DataStructures@@@DataStructures@@QAEXQAURow@Table@2@@Z ENDP ; DataStructures::List<DataStructures::Table::Row *>::Insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Insert@?$List@PAURow@Table@DataStructures@@@DataStructures@@QAEXQAURow@Table@2@I@Z
_TEXT	SEGMENT
$T1 = -236						; size = 4
$T2 = -224						; size = 4
_new_array$3 = -20					; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
_position$ = 12						; size = 4
?Insert@?$List@PAURow@Table@DataStructures@@@DataStructures@@QAEXQAURow@Table@2@I@Z PROC ; DataStructures::List<DataStructures::Table::Row *>::Insert, COMDAT
; _this$ = ecx

; 194  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 195  : #ifdef _DEBUG
; 196  : 		assert( position <= list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jbe	SHORT $LN6@Insert
	push	196					; 000000c4H
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CM@FMCFHBCK@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN6@Insert:

; 197  : #endif
; 198  : 
; 199  : 		// Reallocate list if necessary
; 200  : 		if ( list_size == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	$LN3@Insert

; 201  : 		{
; 202  : 			// allocate twice the currently allocated memory
; 203  : 			list_type * new_array;
; 204  : 
; 205  : 			if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Insert

; 206  : 				allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 16			; 00000010H

; 207  : 			else

	jmp	SHORT $LN1@Insert
$LN2@Insert:

; 208  : 				allocation_size *= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN1@Insert:

; 209  : 
; 210  : 			new_array = new list_type [ allocation_size ];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _new_array$3[ebp], eax

; 211  : 
; 212  : 			// copy old array over
; 213  : 			//for ( unsigned int counter = 0; counter < list_size; ++counter )
; 214  : 			//	new_array[ counter ] = listArray[ counter ];
; 215  : 
; 216  : 			// Don't call constructors, assignment operators, etc.
; 217  : 			memcpy(new_array, listArray, list_size*sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _new_array$3[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 218  : 
; 219  : 			// set old array to point to the newly allocated and twice as large array
; 220  : 			delete[] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 221  : 
; 222  : 			listArray = new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$3[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Insert:

; 223  : 		}
; 224  : 
; 225  : 		// Move the elements in the list to make room
; 226  : 		//for ( unsigned int counter = list_size; counter != position; counter-- )
; 227  : 		//	listArray[ counter ] = listArray[ counter - 1 ];
; 228  : 
; 229  : 		// Don't call constructors, assignment operators, etc.
; 230  : 		memmove(listArray+position+1, listArray+position, (list_size-position)*sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _position$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _position$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _position$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4+4]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 231  : 
; 232  : 		// Insert the new item at the correct spot
; 233  : 		listArray[ position ] = input;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _position$[ebp]
	mov	eax, DWORD PTR _input$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 234  : 
; 235  : 		++list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 236  : 
; 237  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?Insert@?$List@PAURow@Table@DataStructures@@@DataStructures@@QAEXQAURow@Table@2@I@Z ENDP ; DataStructures::List<DataStructures::Table::Row *>::Insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??A?$List@PAURow@Table@DataStructures@@@DataStructures@@QBEAAPAURow@Table@1@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
??A?$List@PAURow@Table@DataStructures@@@DataStructures@@QBEAAPAURow@Table@1@I@Z PROC ; DataStructures::List<DataStructures::Table::Row *>::operator[], COMDAT
; _this$ = ecx

; 185  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 186  : #ifdef _DEBUG
; 187  : 		assert ( position < list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN3@operator
	push	187					; 000000bbH
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@operator:

; 188  : #endif
; 189  : 		return listArray[ position ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _position$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 190  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@PAURow@Table@DataStructures@@@DataStructures@@QBEAAPAURow@Table@1@I@Z ENDP ; DataStructures::List<DataStructures::Table::Row *>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??1?$List@PAURow@Table@DataStructures@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
??1?$List@PAURow@Table@DataStructures@@@DataStructures@@QAE@XZ PROC ; DataStructures::List<DataStructures::Table::Row *>::~List<DataStructures::Table::Row *>, COMDAT
; _this$ = ecx

; 121  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 122  : 		if (allocation_size>0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jbe	SHORT $LN2@List

; 123  : 			delete [] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@List:

; 124  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@PAURow@Table@DataStructures@@@DataStructures@@QAE@XZ ENDP ; DataStructures::List<DataStructures::Table::Row *>::~List<DataStructures::Table::Row *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??0?$List@PAURow@Table@DataStructures@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$List@PAURow@Table@DataStructures@@@DataStructures@@QAE@XZ PROC ; DataStructures::List<DataStructures::Table::Row *>::List<DataStructures::Table::Row *>, COMDAT
; _this$ = ecx

; 113  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 114  : 		allocation_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 115  : 		listArray = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 116  : 		list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 117  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@PAURow@Table@DataStructures@@@DataStructures@@QAE@XZ ENDP ; DataStructures::List<DataStructures::Table::Row *>::List<DataStructures::Table::Row *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?Size@?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QBEIXZ PROC ; DataStructures::OrderedList<DataStructures::Table::Row *,DataStructures::Table::Row *,&RowSort>::Size, COMDAT
; _this$ = ecx

; 231  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 232  : 		return orderedList.Size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@PAURow@Table@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Table::Row *>::Size

; 233  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QBEIXZ ENDP ; DataStructures::OrderedList<DataStructures::Table::Row *,DataStructures::Table::Row *,&RowSort>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?Clear@?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Clear@?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QAEXXZ PROC ; DataStructures::OrderedList<DataStructures::Table::Row *,DataStructures::Table::Row *,&RowSort>::Clear, COMDAT
; _this$ = ecx

; 219  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 220  : 		orderedList.Clear();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@PAURow@Table@DataStructures@@@DataStructures@@QAEX_N@Z ; DataStructures::List<DataStructures::Table::Row *>::Clear

; 221  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QAEXXZ ENDP ; DataStructures::OrderedList<DataStructures::Table::Row *,DataStructures::Table::Row *,&RowSort>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ??A?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QBEAAPAURow@Table@1@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
??A?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QBEAAPAURow@Table@1@I@Z PROC ; DataStructures::OrderedList<DataStructures::Table::Row *,DataStructures::Table::Row *,&RowSort>::operator[], COMDAT
; _this$ = ecx

; 225  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 226  : 		return orderedList[position];

	mov	eax, DWORD PTR _position$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@PAURow@Table@DataStructures@@@DataStructures@@QBEAAPAURow@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Row *>::operator[]

; 227  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QBEAAPAURow@Table@1@I@Z ENDP ; DataStructures::OrderedList<DataStructures::Table::Row *,DataStructures::Table::Row *,&RowSort>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?Insert@?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QAEIABQAURow@Table@2@0@Z
_TEXT	SEGMENT
_index$ = -32						; size = 4
_objectExists$ = -17					; size = 1
_this$ = -8						; size = 4
_key$ = 8						; size = 4
_data$ = 12						; size = 4
?Insert@?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QAEIABQAURow@Table@2@0@Z PROC ; DataStructures::OrderedList<DataStructures::Table::Row *,DataStructures::Table::Row *,&RowSort>::Insert, COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		bool objectExists;
; 158  : 		unsigned index;
; 159  : 		index = GetIndexFromKey(key, &objectExists);

	lea	eax, DWORD PTR _objectExists$[ebp]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexFromKey@?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QBEIABQAURow@Table@2@PA_N@Z ; DataStructures::OrderedList<DataStructures::Table::Row *,DataStructures::Table::Row *,&RowSort>::GetIndexFromKey
	mov	DWORD PTR _index$[ebp], eax

; 160  : 
; 161  : 		// Don't allow duplicate insertion.
; 162  : 		if (objectExists)

	movzx	eax, BYTE PTR _objectExists$[ebp]
	test	eax, eax
	je	SHORT $LN3@Insert

; 163  : 			return (unsigned)-1;

	or	eax, -1
	jmp	SHORT $LN4@Insert
$LN3@Insert:

; 164  : 
; 165  : 		if (index>=orderedList.Size())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@PAURow@Table@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Table::Row *>::Size
	cmp	DWORD PTR _index$[ebp], eax
	jb	SHORT $LN2@Insert

; 166  : 		{
; 167  : 			orderedList.Insert(data);

	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Insert@?$List@PAURow@Table@DataStructures@@@DataStructures@@QAEXQAURow@Table@2@@Z ; DataStructures::List<DataStructures::Table::Row *>::Insert

; 168  : 			return orderedList.Size()-1;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@PAURow@Table@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Table::Row *>::Size
	sub	eax, 1
	jmp	SHORT $LN4@Insert

; 169  : 		}
; 170  : 		else

	jmp	SHORT $LN4@Insert
$LN2@Insert:

; 171  : 		{
; 172  : 			orderedList.Insert(data,index);

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Insert@?$List@PAURow@Table@DataStructures@@@DataStructures@@QAEXQAURow@Table@2@I@Z ; DataStructures::List<DataStructures::Table::Row *>::Insert

; 173  : 			return index;

	mov	eax, DWORD PTR _index$[ebp]
$LN4@Insert:

; 174  : 		}		
; 175  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@Insert
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN8@Insert:
	DD	1
	DD	$LN7@Insert
$LN7@Insert:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN6@Insert
$LN6@Insert:
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
?Insert@?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QAEIABQAURow@Table@2@0@Z ENDP ; DataStructures::OrderedList<DataStructures::Table::Row *,DataStructures::Table::Row *,&RowSort>::Insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?GetIndexFromKey@?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QBEIABQAURow@Table@2@PA_N@Z
_TEXT	SEGMENT
_res$ = -56						; size = 4
_lowerBound$ = -44					; size = 4
_upperBound$ = -32					; size = 4
_index$ = -20						; size = 4
_this$ = -8						; size = 4
_key$ = 8						; size = 4
_objectExists$ = 12					; size = 4
?GetIndexFromKey@?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QBEIABQAURow@Table@2@PA_N@Z PROC ; DataStructures::OrderedList<DataStructures::Table::Row *,DataStructures::Table::Row *,&RowSort>::GetIndexFromKey, COMDAT
; _this$ = ecx

; 110  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 111  : 		int index, upperBound, lowerBound;
; 112  : 		int res;
; 113  : 
; 114  : 		if (orderedList.Size()==0)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@PAURow@Table@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Table::Row *>::Size
	test	eax, eax
	jne	SHORT $LN8@GetIndexFr

; 115  : 		{
; 116  : 			*objectExists=false;

	mov	eax, DWORD PTR _objectExists$[ebp]
	mov	BYTE PTR [eax], 0

; 117  : 			return 0;

	xor	eax, eax
	jmp	$LN9@GetIndexFr
$LN8@GetIndexFr:

; 118  : 		}
; 119  : 
; 120  : 		upperBound=(int)orderedList.Size()-1;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@PAURow@Table@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Table::Row *>::Size
	sub	eax, 1
	mov	DWORD PTR _upperBound$[ebp], eax

; 121  : 		lowerBound=0;

	mov	DWORD PTR _lowerBound$[ebp], 0

; 122  : 		index = (int)orderedList.Size()/2;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@PAURow@Table@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Table::Row *>::Size
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _index$[ebp], eax
$LN7@GetIndexFr:

; 123  : 
; 124  : #ifdef _MSC_VER
; 125  : 	#pragma warning( disable : 4127 ) // warning C4127: conditional expression is constant
; 126  : #endif
; 127  : 		while (1)

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN9@GetIndexFr

; 128  : 		{
; 129  : 			res = comparison_function(key,orderedList[index]);

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@PAURow@Table@DataStructures@@@DataStructures@@QBEAAPAURow@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Row *>::operator[]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	call	?RowSort@@YAHABQAURow@Table@DataStructures@@0@Z ; RowSort
	add	esp, 8
	mov	DWORD PTR _res$[ebp], eax

; 130  : 			if (res==0)

	cmp	DWORD PTR _res$[ebp], 0
	jne	SHORT $LN5@GetIndexFr

; 131  : 			{
; 132  : 				*objectExists=true;

	mov	eax, DWORD PTR _objectExists$[ebp]
	mov	BYTE PTR [eax], 1

; 133  : 				return index;

	mov	eax, DWORD PTR _index$[ebp]
	jmp	SHORT $LN9@GetIndexFr
	jmp	SHORT $LN4@GetIndexFr
$LN5@GetIndexFr:

; 134  : 			}
; 135  : 			else if (res<0)

	cmp	DWORD PTR _res$[ebp], 0
	jge	SHORT $LN3@GetIndexFr

; 136  : 			{
; 137  : 				upperBound=index-1;

	mov	eax, DWORD PTR _index$[ebp]
	sub	eax, 1
	mov	DWORD PTR _upperBound$[ebp], eax

; 138  : 			}
; 139  : 			else// if (res>0)

	jmp	SHORT $LN4@GetIndexFr
$LN3@GetIndexFr:

; 140  : 			{
; 141  : 				lowerBound=index+1;

	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 1
	mov	DWORD PTR _lowerBound$[ebp], eax
$LN4@GetIndexFr:

; 142  : 			}
; 143  : 
; 144  : 			index=lowerBound+(upperBound-lowerBound)/2;

	mov	eax, DWORD PTR _upperBound$[ebp]
	sub	eax, DWORD PTR _lowerBound$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _lowerBound$[ebp]
	mov	DWORD PTR _index$[ebp], eax

; 145  : 
; 146  : 			if (lowerBound>upperBound)

	mov	eax, DWORD PTR _lowerBound$[ebp]
	cmp	eax, DWORD PTR _upperBound$[ebp]
	jle	SHORT $LN1@GetIndexFr

; 147  : 			{
; 148  : 				*objectExists=false;

	mov	eax, DWORD PTR _objectExists$[ebp]
	mov	BYTE PTR [eax], 0

; 149  : 				return lowerBound; // No match

	mov	eax, DWORD PTR _lowerBound$[ebp]
	jmp	SHORT $LN9@GetIndexFr
$LN1@GetIndexFr:

; 150  : 			}
; 151  : 		}

	jmp	SHORT $LN7@GetIndexFr
$LN9@GetIndexFr:

; 152  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?GetIndexFromKey@?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QBEIABQAURow@Table@2@PA_N@Z ENDP ; DataStructures::OrderedList<DataStructures::Table::Row *,DataStructures::Table::Row *,&RowSort>::GetIndexFromKey
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ??1?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QAE@XZ PROC ; DataStructures::OrderedList<DataStructures::Table::Row *,DataStructures::Table::Row *,&RowSort>::~OrderedList<DataStructures::Table::Row *,DataStructures::Table::Row *,&RowSort>, COMDAT
; _this$ = ecx

; 72   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 73   : 		Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QAEXXZ ; DataStructures::OrderedList<DataStructures::Table::Row *,DataStructures::Table::Row *,&RowSort>::Clear

; 74   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$List@PAURow@Table@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::List<DataStructures::Table::Row *>::~List<DataStructures::Table::Row *>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$List@PAURow@Table@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::List<DataStructures::Table::Row *>::~List<DataStructures::Table::Row *>
__ehhandler$??1?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QAE@XZ ENDP ; DataStructures::OrderedList<DataStructures::Table::Row *,DataStructures::Table::Row *,&RowSort>::~OrderedList<DataStructures::Table::Row *,DataStructures::Table::Row *,&RowSort>
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ??0?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QAE@XZ PROC ; DataStructures::OrderedList<DataStructures::Table::Row *,DataStructures::Table::Row *,&RowSort>::OrderedList<DataStructures::Table::Row *,DataStructures::Table::Row *,&RowSort>, COMDAT
; _this$ = ecx

; 67   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$List@PAURow@Table@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::List<DataStructures::Table::Row *>::List<DataStructures::Table::Row *>

; 68   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QAE@XZ ENDP ; DataStructures::OrderedList<DataStructures::Table::Row *,DataStructures::Table::Row *,&RowSort>::OrderedList<DataStructures::Table::Row *,DataStructures::Table::Row *,&RowSort>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ?RowSort@@YAHABQAURow@Table@DataStructures@@0@Z
_TEXT	SEGMENT
_columnIndex$ = -20					; size = 4
_i$ = -8						; size = 4
_first$ = 8						; size = 4
_second$ = 12						; size = 4
?RowSort@@YAHABQAURow@Table@DataStructures@@0@Z PROC	; RowSort, COMDAT

; 564  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 565  : 	unsigned i, columnIndex;
; 566  : 	for (i=0; i<_numSortQueries; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN20@RowSort
$LN19@RowSort:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN20@RowSort:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR __numSortQueries
	jae	$LN18@RowSort

; 567  : 	{
; 568  : 		columnIndex=(*_columnIndices)[i];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR __columnIndices
	call	??A?$List@I@DataStructures@@QBEAAII@Z	; DataStructures::List<unsigned int>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _columnIndex$[ebp], ecx

; 569  : 		if (columnIndex==(unsigned)-1)

	cmp	DWORD PTR _columnIndex$[ebp], -1
	jne	SHORT $LN17@RowSort

; 570  : 			continue;

	jmp	SHORT $LN19@RowSort
$LN17@RowSort:

; 571  : 
; 572  : 		if (first->cells[columnIndex]->isEmpty==true && second->cells[columnIndex]->isEmpty==false)

	mov	eax, DWORD PTR _columnIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _first$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	edx, DWORD PTR [eax]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 1
	jne	SHORT $LN16@RowSort
	mov	eax, DWORD PTR _columnIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _second$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	edx, DWORD PTR [eax]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN16@RowSort

; 573  : 			return 1; // Empty cells always go at the end

	mov	eax, 1
	jmp	$LN21@RowSort
$LN16@RowSort:

; 574  : 
; 575  : 		if (first->cells[columnIndex]->isEmpty==false && second->cells[columnIndex]->isEmpty==true)

	mov	eax, DWORD PTR _columnIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _first$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	edx, DWORD PTR [eax]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN15@RowSort
	mov	eax, DWORD PTR _columnIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _second$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	edx, DWORD PTR [eax]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 1
	jne	SHORT $LN15@RowSort

; 576  : 			return -1; // Empty cells always go at the end

	or	eax, -1
	jmp	$LN21@RowSort
$LN15@RowSort:

; 577  : 
; 578  : 		if (_sortQueries[i].operation==Table::QS_INCREASING_ORDER)

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR __sortQueries
	cmp	DWORD PTR [ecx+eax*8+4], 0
	jne	$LN14@RowSort

; 579  : 		{
; 580  : 			if ((*_columns)[columnIndex].columnType==Table::NUMERIC)

	mov	eax, DWORD PTR _columnIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR __columns
	call	??A?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEAAUColumnDescriptor@Table@1@I@Z ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::operator[]
	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $LN13@RowSort

; 581  : 			{
; 582  : 				if (first->cells[columnIndex]->i>second->cells[columnIndex]->i)

	mov	eax, DWORD PTR _columnIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _first$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	esi, DWORD PTR [eax]
	mov	edx, DWORD PTR _columnIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _second$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [esi+1]
	cmp	edx, DWORD PTR [ecx+1]
	jle	SHORT $LN12@RowSort

; 583  : 					return 1;

	mov	eax, 1
	jmp	$LN21@RowSort
$LN12@RowSort:

; 584  : 				if (first->cells[columnIndex]->i<second->cells[columnIndex]->i)

	mov	eax, DWORD PTR _columnIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _first$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	esi, DWORD PTR [eax]
	mov	edx, DWORD PTR _columnIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _second$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [esi+1]
	cmp	edx, DWORD PTR [ecx+1]
	jge	SHORT $LN11@RowSort

; 585  : 					return -1;

	or	eax, -1
	jmp	$LN21@RowSort
$LN11@RowSort:

; 586  : 			}
; 587  : 			else

	jmp	SHORT $LN10@RowSort
$LN13@RowSort:

; 588  : 			{
; 589  : 				// String
; 590  : 				if (strcmp(first->cells[columnIndex]->c,second->cells[columnIndex]->c)>0)

	mov	eax, DWORD PTR _columnIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _second$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+5]
	push	eax
	mov	ecx, DWORD PTR _columnIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _first$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+5]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jle	SHORT $LN9@RowSort

; 591  : 					return 1;

	mov	eax, 1
	jmp	$LN21@RowSort
$LN9@RowSort:

; 592  : 				if (strcmp(first->cells[columnIndex]->c,second->cells[columnIndex]->c)<0)

	mov	eax, DWORD PTR _columnIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _second$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+5]
	push	eax
	mov	ecx, DWORD PTR _columnIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _first$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+5]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jge	SHORT $LN10@RowSort

; 593  : 					return -1;

	or	eax, -1
	jmp	$LN21@RowSort
$LN10@RowSort:

; 594  : 			}
; 595  : 		}
; 596  : 		else

	jmp	$LN7@RowSort
$LN14@RowSort:

; 597  : 		{
; 598  : 			if ((*_columns)[columnIndex].columnType==Table::NUMERIC)

	mov	eax, DWORD PTR _columnIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR __columns
	call	??A?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEAAUColumnDescriptor@Table@1@I@Z ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::operator[]
	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $LN6@RowSort

; 599  : 			{
; 600  : 				if (first->cells[columnIndex]->i<second->cells[columnIndex]->i)

	mov	eax, DWORD PTR _columnIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _first$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	esi, DWORD PTR [eax]
	mov	edx, DWORD PTR _columnIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _second$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [esi+1]
	cmp	edx, DWORD PTR [ecx+1]
	jge	SHORT $LN5@RowSort

; 601  : 					return 1;

	mov	eax, 1
	jmp	$LN21@RowSort
$LN5@RowSort:

; 602  : 				if (first->cells[columnIndex]->i>second->cells[columnIndex]->i)

	mov	eax, DWORD PTR _columnIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _first$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	esi, DWORD PTR [eax]
	mov	edx, DWORD PTR _columnIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _second$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [esi+1]
	cmp	edx, DWORD PTR [ecx+1]
	jle	SHORT $LN4@RowSort

; 603  : 					return -1;

	or	eax, -1
	jmp	SHORT $LN21@RowSort
$LN4@RowSort:

; 604  : 			}
; 605  : 			else

	jmp	SHORT $LN7@RowSort
$LN6@RowSort:

; 606  : 			{
; 607  : 				// String
; 608  : 				if (strcmp(first->cells[columnIndex]->c,second->cells[columnIndex]->c)<0)

	mov	eax, DWORD PTR _columnIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _second$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+5]
	push	eax
	mov	ecx, DWORD PTR _columnIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _first$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+5]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jge	SHORT $LN2@RowSort

; 609  : 					return 1;

	mov	eax, 1
	jmp	SHORT $LN21@RowSort
$LN2@RowSort:

; 610  : 				if (strcmp(first->cells[columnIndex]->c,second->cells[columnIndex]->c)>0)

	mov	eax, DWORD PTR _columnIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _second$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+5]
	push	eax
	mov	ecx, DWORD PTR _columnIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _first$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+5]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jle	SHORT $LN7@RowSort

; 611  : 					return -1;

	or	eax, -1
	jmp	SHORT $LN21@RowSort
$LN7@RowSort:

; 612  : 			}
; 613  : 		}
; 614  : 	}

	jmp	$LN19@RowSort
$LN18@RowSort:

; 615  : 
; 616  : 	return 0;

	xor	eax, eax
$LN21@RowSort:

; 617  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?RowSort@@YAHABQAURow@Table@DataStructures@@0@Z ENDP	; RowSort
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Size@?$List@I@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$List@I@DataStructures@@QBEIXZ PROC		; DataStructures::List<unsigned int>::Size, COMDAT
; _this$ = ecx

; 373  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 374  : 		return list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 375  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$List@I@DataStructures@@QBEIXZ ENDP		; DataStructures::List<unsigned int>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Insert@?$List@I@DataStructures@@QAEXI@Z
_TEXT	SEGMENT
$T1 = -236						; size = 4
$T2 = -224						; size = 4
_new_array$3 = -20					; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
?Insert@?$List@I@DataStructures@@QAEXI@Z PROC		; DataStructures::List<unsigned int>::Insert, COMDAT
; _this$ = ecx

; 242  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 243  : 		// Reallocate list if necessary
; 244  : 
; 245  : 		if ( list_size == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	$LN3@Insert

; 246  : 		{
; 247  : 			// allocate twice the currently allocated memory
; 248  : 			list_type * new_array;
; 249  : 
; 250  : 			if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Insert

; 251  : 				allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 16			; 00000010H

; 252  : 			else

	jmp	SHORT $LN1@Insert
$LN2@Insert:

; 253  : 				allocation_size *= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN1@Insert:

; 254  : 
; 255  : 			new_array = new list_type [ allocation_size ];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _new_array$3[ebp], eax

; 256  : 
; 257  : 			// copy old array over
; 258  : 			//	for ( unsigned int counter = 0; counter < list_size; ++counter )
; 259  : 			//		new_array[ counter ] = listArray[ counter ];
; 260  : 
; 261  : 			// Don't call constructors, assignment operators, etc.
; 262  : 			memcpy(new_array, listArray, list_size*sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _new_array$3[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 263  : 
; 264  : 			// set old array to point to the newly allocated and twice as large array
; 265  : 			delete[] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 266  : 
; 267  : 			listArray = new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$3[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Insert:

; 268  : 		}
; 269  : 
; 270  : 		// Insert the new item at the correct spot
; 271  : 		listArray[ list_size ] = input;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _input$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 272  : 
; 273  : 		++list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 274  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Insert@?$List@I@DataStructures@@QAEXI@Z ENDP		; DataStructures::List<unsigned int>::Insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??A?$List@I@DataStructures@@QBEAAII@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
??A?$List@I@DataStructures@@QBEAAII@Z PROC		; DataStructures::List<unsigned int>::operator[], COMDAT
; _this$ = ecx

; 185  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 186  : #ifdef _DEBUG
; 187  : 		assert ( position < list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN3@operator
	push	187					; 000000bbH
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@operator:

; 188  : #endif
; 189  : 		return listArray[ position ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _position$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 190  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@I@DataStructures@@QBEAAII@Z ENDP		; DataStructures::List<unsigned int>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??0?$List@I@DataStructures@@QAE@ABV01@@Z
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
_original_copy$ = 8					; size = 4
??0?$List@I@DataStructures@@QAE@ABV01@@Z PROC		; DataStructures::List<unsigned int>::List<unsigned int>, COMDAT
; _this$ = ecx

; 129  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 130  : 		// Allocate memory for copy
; 131  : 
; 132  : 		if ( original_copy.list_size == 0 )

	mov	eax, DWORD PTR _original_copy$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN2@List

; 133  : 		{
; 134  : 			list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 135  : 			allocation_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 136  : 		}
; 137  : 		else

	jmp	SHORT $LN3@List
$LN2@List:

; 138  : 		{
; 139  : 			listArray = new list_type [ original_copy.list_size ];

	xor	ecx, ecx
	mov	edx, DWORD PTR _original_copy$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax], ecx

; 140  : 
; 141  : 			//for ( unsigned int counter = 0; counter < original_copy.list_size; ++counter )
; 142  : 			//	listArray[ counter ] = original_copy.listArray[ counter ];
; 143  : 
; 144  : 			// Don't call constructors, assignment operators, etc.
; 145  : 			memcpy(listArray, original_copy.listArray, original_copy.list_size*sizeof(list_type));

	mov	eax, DWORD PTR _original_copy$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _original_copy$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 146  : 
; 147  : 			list_size = allocation_size = original_copy.list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _original_copy$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+4], edx
$LN3@List:

; 148  : 		}
; 149  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$List@I@DataStructures@@QAE@ABV01@@Z ENDP		; DataStructures::List<unsigned int>::List<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??1?$List@I@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
??1?$List@I@DataStructures@@QAE@XZ PROC			; DataStructures::List<unsigned int>::~List<unsigned int>, COMDAT
; _this$ = ecx

; 121  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 122  : 		if (allocation_size>0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jbe	SHORT $LN2@List

; 123  : 			delete [] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@List:

; 124  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@I@DataStructures@@QAE@XZ ENDP			; DataStructures::List<unsigned int>::~List<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??0?$List@I@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$List@I@DataStructures@@QAE@XZ PROC			; DataStructures::List<unsigned int>::List<unsigned int>, COMDAT
; _this$ = ecx

; 113  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 114  : 		allocation_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 115  : 		listArray = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 116  : 		list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 117  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@I@DataStructures@@QAE@XZ ENDP			; DataStructures::List<unsigned int>::List<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Size@?$List@UCell@Table@DataStructures@@@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$List@UCell@Table@DataStructures@@@DataStructures@@QBEIXZ PROC ; DataStructures::List<DataStructures::Table::Cell>::Size, COMDAT
; _this$ = ecx

; 373  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 374  : 		return list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 375  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$List@UCell@Table@DataStructures@@@DataStructures@@QBEIXZ ENDP ; DataStructures::List<DataStructures::Table::Cell>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??A?$List@UCell@Table@DataStructures@@@DataStructures@@QBEAAUCell@Table@1@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
??A?$List@UCell@Table@DataStructures@@@DataStructures@@QBEAAUCell@Table@1@I@Z PROC ; DataStructures::List<DataStructures::Table::Cell>::operator[], COMDAT
; _this$ = ecx

; 185  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 186  : #ifdef _DEBUG
; 187  : 		assert ( position < list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN3@operator
	push	187					; 000000bbH
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@operator:

; 188  : #endif
; 189  : 		return listArray[ position ];

	imul	eax, DWORD PTR _position$[ebp], 9
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]

; 190  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@UCell@Table@DataStructures@@@DataStructures@@QBEAAUCell@Table@1@I@Z ENDP ; DataStructures::List<DataStructures::Table::Cell>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ?FreeRow@@YAXPAURow@Table@DataStructures@@H@Z
_TEXT	SEGMENT
tv82 = -256						; size = 4
tv77 = -256						; size = 4
$T1 = -248						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
$T4 = -212						; size = 4
_i$ = -8						; size = 4
_input$ = 8						; size = 4
_index$ = 12						; size = 4
?FreeRow@@YAXPAURow@Table@DataStructures@@H@Z PROC	; FreeRow, COMDAT

; 24   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 25   : 	unsigned i;
; 26   : 	for (i=0; i < input->cells.Size(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@FreeRow
$LN2@FreeRow:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@FreeRow:
	mov	ecx, DWORD PTR _input$[ebp]
	call	?Size@?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Table::Cell *>::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN1@FreeRow

; 27   : 	{
; 28   : 		delete input->cells[i];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _input$[ebp]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T1[ebp], edx
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN6@FreeRow
	push	1
	mov	ecx, DWORD PTR $T1[ebp]
	call	??_GCell@Table@DataStructures@@QAEPAXI@Z
	mov	DWORD PTR tv77[ebp], eax
	jmp	SHORT $LN7@FreeRow
$LN6@FreeRow:
	mov	DWORD PTR tv77[ebp], 0
$LN7@FreeRow:

; 29   : 	}

	jmp	SHORT $LN2@FreeRow
$LN1@FreeRow:

; 30   : 	delete input;

	mov	eax, DWORD PTR _input$[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	ecx, DWORD PTR $T4[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN8@FreeRow
	push	1
	mov	ecx, DWORD PTR $T3[ebp]
	call	??_GRow@Table@DataStructures@@QAEPAXI@Z
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $LN4@FreeRow
$LN8@FreeRow:
	mov	DWORD PTR tv82[ebp], 0
$LN4@FreeRow:

; 31   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeRow@@YAXPAURow@Table@DataStructures@@H@Z ENDP	; FreeRow
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ?ExtendRows@@YAXPAURow@Table@DataStructures@@H@Z
_TEXT	SEGMENT
tv73 = -232						; size = 4
$T2 = -224						; size = 4
$T3 = -212						; size = 4
__$EHRec$ = -12						; size = 12
_input$ = 8						; size = 4
_index$ = 12						; size = 4
?ExtendRows@@YAXPAURow@Table@DataStructures@@H@Z PROC	; ExtendRows, COMDAT

; 16   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ExtendRows@@YAXPAURow@Table@DataStructures@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 17   : 	input->cells.Insert(new Table::Cell );

	push	9
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@ExtendRows
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0Cell@Table@DataStructures@@QAE@XZ	; DataStructures::Table::Cell::Cell
	mov	DWORD PTR tv73[ebp], eax
	jmp	SHORT $LN4@ExtendRows
$LN3@ExtendRows:
	mov	DWORD PTR tv73[ebp], 0
$LN4@ExtendRows:
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _input$[ebp]
	call	?Insert@?$List@PAUCell@Table@DataStructures@@@DataStructures@@QAEXQAUCell@Table@2@@Z ; DataStructures::List<DataStructures::Table::Cell *>::Insert

; 18   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ExtendRows@@YAXPAURow@Table@DataStructures@@H@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?ExtendRows@@YAXPAURow@Table@DataStructures@@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-236]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ExtendRows@@YAXPAURow@Table@DataStructures@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ExtendRows@@YAXPAURow@Table@DataStructures@@H@Z ENDP	; ExtendRows
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Clear@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QAEX_N@Z
_TEXT	SEGMENT
tv75 = -232						; size = 4
$T1 = -224						; size = 4
$T2 = -212						; size = 4
_this$ = -8						; size = 4
_doNotDeallocate$ = 8					; size = 1
?Clear@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QAEX_N@Z PROC ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::Clear, COMDAT
; _this$ = ecx

; 379  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  : 		if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Clear

; 381  : 			return;

	jmp	SHORT $LN3@Clear
$LN2@Clear:

; 382  : 
; 383  : 		if (allocation_size>512 && doNotDeallocate==false)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 512			; 00000200H
	jbe	SHORT $LN1@Clear
	movzx	eax, BYTE PTR _doNotDeallocate$[ebp]
	test	eax, eax
	jne	SHORT $LN1@Clear

; 384  : 		{
; 385  : 			delete [] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T1[ebp], edx
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN5@Clear
	push	3
	mov	ecx, DWORD PTR $T1[ebp]
	call	??_EColumnDescriptor@Table@DataStructures@@QAEPAXI@Z
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN6@Clear
$LN5@Clear:
	mov	DWORD PTR tv75[ebp], 0
$LN6@Clear:

; 386  : 			allocation_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 387  : 			listArray = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN1@Clear:

; 388  : 		}
; 389  : 		list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
$LN3@Clear:

; 390  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Clear@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QAEX_N@Z ENDP ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Size@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEIXZ PROC ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::Size, COMDAT
; _this$ = ecx

; 373  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 374  : 		return list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 375  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEIXZ ENDP ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Del@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_num$ = 8						; size = 4
?Del@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QAEXI@Z PROC ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::Del, COMDAT
; _this$ = ecx

; 353  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 354  : 		// Delete the last elements on the list.  No compression needed
; 355  : #ifdef _DEBUG
; 356  : 		assert(list_size>=num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _num$[ebp]
	jae	SHORT $LN3@Del
	push	356					; 00000164H
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1BO@JBFMBKMD@?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$DO?$AA?$DN?$AAn?$AAu?$AAm?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@Del:

; 357  : #endif
; 358  : 		list_size-=num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _num$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 359  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Del@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QAEXI@Z ENDP ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::Del
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?RemoveAtIndex@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
?RemoveAtIndex@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QAEXI@Z PROC ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::RemoveAtIndex, COMDAT
; _this$ = ecx

; 333  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 334  : #ifdef _DEBUG
; 335  : 		assert( position < list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN4@RemoveAtIn
	push	335					; 0000014fH
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@RemoveAtIn:

; 336  : #endif
; 337  : 
; 338  : 		if ( position < list_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN2@RemoveAtIn

; 339  : 		{
; 340  : 			// Compress the array
; 341  : 			/*
; 342  : 			for ( unsigned int counter = position; counter < list_size - 1 ; ++counter )
; 343  : 			listArray[ counter ] = listArray[ counter + 1 ];
; 344  : 			*/
; 345  : 			memmove(listArray+position, listArray+position+1, (list_size-1-position) * sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	sub	ecx, DWORD PTR _position$[ebp]
	imul	edx, ecx, 36
	push	edx
	imul	eax, DWORD PTR _position$[ebp], 36
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax+36]
	push	eax
	imul	ecx, DWORD PTR _position$[ebp], 36
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	call	_memmove
	add	esp, 12					; 0000000cH

; 346  : 
; 347  : 			Del();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Del@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QAEXI@Z ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::Del
$LN2@RemoveAtIn:

; 348  : 		}
; 349  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveAtIndex@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QAEXI@Z ENDP ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::RemoveAtIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Insert@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QAEXUColumnDescriptor@Table@2@@Z
_TEXT	SEGMENT
tv140 = -292						; size = 4
tv129 = -292						; size = 4
$T2 = -284						; size = 4
$T3 = -272						; size = 4
$T4 = -260						; size = 4
$T5 = -248						; size = 4
$T6 = -236						; size = 4
_new_array$7 = -32					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_input$ = 8						; size = 36
?Insert@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QAEXUColumnDescriptor@Table@2@@Z PROC ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::Insert, COMDAT
; _this$ = ecx

; 242  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Insert@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QAEXUColumnDescriptor@Table@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 280				; 00000118H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-292]
	mov	ecx, 70					; 00000046H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 243  : 		// Reallocate list if necessary
; 244  : 
; 245  : 		if ( list_size == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	$LN3@Insert

; 246  : 		{
; 247  : 			// allocate twice the currently allocated memory
; 248  : 			list_type * new_array;
; 249  : 
; 250  : 			if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Insert

; 251  : 				allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 16			; 00000010H

; 252  : 			else

	jmp	SHORT $LN1@Insert
$LN2@Insert:

; 253  : 				allocation_size *= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN1@Insert:

; 254  : 
; 255  : 			new_array = new list_type [ allocation_size ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T2[ebp], ecx
	xor	ecx, ecx
	mov	eax, DWORD PTR $T2[ebp]
	mov	edx, 36					; 00000024H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN6@Insert
	mov	ecx, DWORD PTR $T4[ebp]
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [ecx], edx
	push	OFFSET ??1ColumnDescriptor@Table@DataStructures@@QAE@XZ ; DataStructures::Table::ColumnDescriptor::~ColumnDescriptor
	push	OFFSET ??0ColumnDescriptor@Table@DataStructures@@QAE@XZ ; DataStructures::Table::ColumnDescriptor::ColumnDescriptor
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	push	36					; 00000024H
	mov	ecx, DWORD PTR $T4[ebp]
	add	ecx, 4
	push	ecx
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	edx, DWORD PTR $T4[ebp]
	add	edx, 4
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN7@Insert
$LN6@Insert:
	mov	DWORD PTR tv129[ebp], 0
$LN7@Insert:
	mov	eax, DWORD PTR tv129[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR _new_array$7[ebp], ecx

; 256  : 
; 257  : 			// copy old array over
; 258  : 			//	for ( unsigned int counter = 0; counter < list_size; ++counter )
; 259  : 			//		new_array[ counter ] = listArray[ counter ];
; 260  : 
; 261  : 			// Don't call constructors, assignment operators, etc.
; 262  : 			memcpy(new_array, listArray, list_size*sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [eax+4], 36
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _new_array$7[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 263  : 
; 264  : 			// set old array to point to the newly allocated and twice as large array
; 265  : 			delete[] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T6[ebp], ecx
	mov	edx, DWORD PTR $T6[ebp]
	mov	DWORD PTR $T5[ebp], edx
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN8@Insert
	push	3
	mov	ecx, DWORD PTR $T5[ebp]
	call	??_EColumnDescriptor@Table@DataStructures@@QAEPAXI@Z
	mov	DWORD PTR tv140[ebp], eax
	jmp	SHORT $LN9@Insert
$LN8@Insert:
	mov	DWORD PTR tv140[ebp], 0
$LN9@Insert:

; 266  : 
; 267  : 			listArray = new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$7[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Insert:

; 268  : 		}
; 269  : 
; 270  : 		// Insert the new item at the correct spot
; 271  : 		listArray[ list_size ] = input;

	mov	eax, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [eax+4], 36
	mov	edx, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR [edx]
	add	edi, ecx
	mov	ecx, 9
	lea	esi, DWORD PTR _input$[ebp]
	rep movsd

; 272  : 
; 273  : 		++list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 274  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _input$[ebp]
	call	??1ColumnDescriptor@Table@DataStructures@@QAE@XZ ; DataStructures::Table::ColumnDescriptor::~ColumnDescriptor
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 292				; 00000124H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Insert@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QAEXUColumnDescriptor@Table@2@@Z$0:
	lea	ecx, DWORD PTR _input$[ebp]
	jmp	??1ColumnDescriptor@Table@DataStructures@@QAE@XZ ; DataStructures::Table::ColumnDescriptor::~ColumnDescriptor
__unwindfunclet$?Insert@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QAEXUColumnDescriptor@Table@2@@Z$1:
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?Insert@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QAEXUColumnDescriptor@Table@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-296]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Insert@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QAEXUColumnDescriptor@Table@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Insert@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QAEXUColumnDescriptor@Table@2@@Z ENDP ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::Insert
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??A?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEAAUColumnDescriptor@Table@1@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
??A?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEAAUColumnDescriptor@Table@1@I@Z PROC ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::operator[], COMDAT
; _this$ = ecx

; 185  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 186  : #ifdef _DEBUG
; 187  : 		assert ( position < list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN3@operator
	push	187					; 000000bbH
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@operator:

; 188  : #endif
; 189  : 		return listArray[ position ];

	imul	eax, DWORD PTR _position$[ebp], 36
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]

; 190  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEAAUColumnDescriptor@Table@1@I@Z ENDP ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??1?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
tv71 = -232						; size = 4
$T1 = -224						; size = 4
$T2 = -212						; size = 4
_this$ = -8						; size = 4
??1?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QAE@XZ PROC ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::~List<DataStructures::Table::ColumnDescriptor>, COMDAT
; _this$ = ecx

; 121  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 122  : 		if (allocation_size>0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jbe	SHORT $LN2@List

; 123  : 			delete [] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T1[ebp], edx
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN4@List
	push	3
	mov	ecx, DWORD PTR $T1[ebp]
	call	??_EColumnDescriptor@Table@DataStructures@@QAEPAXI@Z
	mov	DWORD PTR tv71[ebp], eax
	jmp	SHORT $LN2@List
$LN4@List:
	mov	DWORD PTR tv71[ebp], 0
$LN2@List:

; 124  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QAE@XZ ENDP ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::~List<DataStructures::Table::ColumnDescriptor>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??0?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QAE@XZ PROC ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::List<DataStructures::Table::ColumnDescriptor>, COMDAT
; _this$ = ecx

; 113  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 114  : 		allocation_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 115  : 		listArray = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 116  : 		list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 117  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QAE@XZ ENDP ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::List<DataStructures::Table::ColumnDescriptor>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Size@?$List@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$List@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QBEIXZ PROC ; DataStructures::List<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::Size, COMDAT
; _this$ = ecx

; 373  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 374  : 		return list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 375  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$List@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QBEIXZ ENDP ; DataStructures::List<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Del@?$List@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_num$ = 8						; size = 4
?Del@?$List@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAEXI@Z PROC ; DataStructures::List<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::Del, COMDAT
; _this$ = ecx

; 353  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 354  : 		// Delete the last elements on the list.  No compression needed
; 355  : #ifdef _DEBUG
; 356  : 		assert(list_size>=num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _num$[ebp]
	jae	SHORT $LN3@Del
	push	356					; 00000164H
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1BO@JBFMBKMD@?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$DO?$AA?$DN?$AAn?$AAu?$AAm?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@Del:

; 357  : #endif
; 358  : 		list_size-=num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _num$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 359  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Del@?$List@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAEXI@Z ENDP ; DataStructures::List<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::Del
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Insert@?$List@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAEXQAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@@Z
_TEXT	SEGMENT
$T1 = -236						; size = 4
$T2 = -224						; size = 4
_new_array$3 = -20					; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
?Insert@?$List@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAEXQAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@@Z PROC ; DataStructures::List<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::Insert, COMDAT
; _this$ = ecx

; 242  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 243  : 		// Reallocate list if necessary
; 244  : 
; 245  : 		if ( list_size == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	$LN3@Insert

; 246  : 		{
; 247  : 			// allocate twice the currently allocated memory
; 248  : 			list_type * new_array;
; 249  : 
; 250  : 			if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Insert

; 251  : 				allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 16			; 00000010H

; 252  : 			else

	jmp	SHORT $LN1@Insert
$LN2@Insert:

; 253  : 				allocation_size *= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN1@Insert:

; 254  : 
; 255  : 			new_array = new list_type [ allocation_size ];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _new_array$3[ebp], eax

; 256  : 
; 257  : 			// copy old array over
; 258  : 			//	for ( unsigned int counter = 0; counter < list_size; ++counter )
; 259  : 			//		new_array[ counter ] = listArray[ counter ];
; 260  : 
; 261  : 			// Don't call constructors, assignment operators, etc.
; 262  : 			memcpy(new_array, listArray, list_size*sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _new_array$3[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 263  : 
; 264  : 			// set old array to point to the newly allocated and twice as large array
; 265  : 			delete[] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 266  : 
; 267  : 			listArray = new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$3[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Insert:

; 268  : 		}
; 269  : 
; 270  : 		// Insert the new item at the correct spot
; 271  : 		listArray[ list_size ] = input;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _input$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 272  : 
; 273  : 		++list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 274  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Insert@?$List@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAEXQAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@@Z ENDP ; DataStructures::List<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::Insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??A?$List@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QBEAAPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@1@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
??A?$List@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QBEAAPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@1@I@Z PROC ; DataStructures::List<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::operator[], COMDAT
; _this$ = ecx

; 185  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 186  : #ifdef _DEBUG
; 187  : 		assert ( position < list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN3@operator
	push	187					; 000000bbH
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@operator:

; 188  : #endif
; 189  : 		return listArray[ position ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _position$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 190  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QBEAAPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@1@I@Z ENDP ; DataStructures::List<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??1?$List@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
??1?$List@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAE@XZ PROC ; DataStructures::List<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::~List<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>, COMDAT
; _this$ = ecx

; 121  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 122  : 		if (allocation_size>0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jbe	SHORT $LN2@List

; 123  : 			delete [] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@List:

; 124  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAE@XZ ENDP ; DataStructures::List<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::~List<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??0?$List@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$List@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAE@XZ PROC ; DataStructures::List<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::List<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>, COMDAT
; _this$ = ecx

; 113  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 114  : 		allocation_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 115  : 		listArray = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 116  : 		list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 117  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAE@XZ ENDP ; DataStructures::List<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::List<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_memorypool.h
;	COMDAT ?Release@?$MemoryPool@U?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAEXPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_m$ = 8							; size = 4
?Release@?$MemoryPool@U?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAEXPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@@Z PROC ; DataStructures::MemoryPool<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> >::Release, COMDAT
; _this$ = ecx

; 70   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 71   : 		pool.Insert(m);

	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Insert@?$List@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAEXQAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@@Z ; DataStructures::List<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::Insert

; 72   : #ifdef _DEBUG
; 73   : 		assert(blocksOut>0);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jg	SHORT $LN3@Release
	push	73					; 00000049H
	push	OFFSET ??_C@_1FA@EECGGCBA@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAm?$AAe?$AAm?$AAo?$AAr@
	push	OFFSET ??_C@_1BI@OFKIDLPK@?$AAb?$AAl?$AAo?$AAc?$AAk?$AAs?$AAO?$AAu?$AAt?$AA?$DO?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@Release:

; 74   : 		blocksOut--;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 75   : #endif
; 76   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Release@?$MemoryPool@U?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAEXPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@@Z ENDP ; DataStructures::MemoryPool<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> >::Release
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_memorypool.h
;	COMDAT ?Allocate@?$MemoryPool@U?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@XZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_out$2 = -20						; size = 4
_this$ = -8						; size = 4
?Allocate@?$MemoryPool@U?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@XZ PROC ; DataStructures::MemoryPool<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> >::Allocate, COMDAT
; _this$ = ecx

; 54   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 55   : #ifdef _DEBUG
; 56   : 		blocksOut++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 57   : #endif
; 58   : 		if (pool.Size()==0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Size@?$List@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::Size
	test	eax, eax
	jne	SHORT $LN2@Allocate

; 59   : 			return new MemoryBlockType;

	push	209					; 000000d1H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	jmp	SHORT $LN3@Allocate

; 60   : 		else

	jmp	SHORT $LN3@Allocate
$LN2@Allocate:

; 61   : 		{
; 62   : 			MemoryBlockType* out;
; 63   : 			out=pool[pool.Size()-1];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Size@?$List@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::Size
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$List@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QBEAAPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@1@I@Z ; DataStructures::List<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::operator[]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _out$2[ebp], eax

; 64   : 			pool.Del();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Del@?$List@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAEXI@Z ; DataStructures::List<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::Del

; 65   : 			return out;

	mov	eax, DWORD PTR _out$2[ebp]
$LN3@Allocate:

; 66   : 		}
; 67   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Allocate@?$MemoryPool@U?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@XZ ENDP ; DataStructures::MemoryPool<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> >::Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_memorypool.h
;	COMDAT ??1?$MemoryPool@U?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T2 = -236						; size = 4
_i$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$MemoryPool@U?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAE@XZ PROC ; DataStructures::MemoryPool<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> >::~MemoryPool<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> >, COMDAT
; _this$ = ecx

; 33   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$MemoryPool@U?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 34   : #ifdef _DEBUG
; 35   : 		assert(blocksOut==0);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN6@MemoryPool
	push	35					; 00000023H
	push	OFFSET ??_C@_1FA@EECGGCBA@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAm?$AAe?$AAm?$AAo?$AAr@
	push	OFFSET ??_C@_1BK@JNGCOJCH@?$AAb?$AAl?$AAo?$AAc?$AAk?$AAs?$AAO?$AAu?$AAt?$AA?$DN?$AA?$DN?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN6@MemoryPool:

; 36   : #endif
; 37   : 		unsigned i;
; 38   : 		for (i=0; i < pool.Size(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@MemoryPool
$LN2@MemoryPool:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@MemoryPool:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Size@?$List@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN4@MemoryPool

; 39   : 			delete pool[i];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$List@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QBEAAPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@1@I@Z ; DataStructures::List<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	jmp	SHORT $LN2@MemoryPool
$LN4@MemoryPool:

; 40   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1?$List@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::List<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::~List<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$MemoryPool@U?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$List@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::List<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::~List<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>
__ehhandler$??1?$MemoryPool@U?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-244]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$MemoryPool@U?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$MemoryPool@U?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAE@XZ ENDP ; DataStructures::MemoryPool<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> >::~MemoryPool<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> >
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_memorypool.h
;	COMDAT ??0?$MemoryPool@U?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$MemoryPool@U?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAE@XZ PROC ; DataStructures::MemoryPool<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> >::MemoryPool<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> >, COMDAT
; _this$ = ecx

; 26   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0?$List@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::List<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::List<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>

; 27   : #ifdef _DEBUG
; 28   : 		blocksOut=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 29   : #endif
; 30   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$MemoryPool@U?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAE@XZ ENDP ; DataStructures::MemoryPool<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> >::MemoryPool<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?ShiftNodeRight@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEXPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@@Z
_TEXT	SEGMENT
_i$ = -20						; size = 4
_this$ = -8						; size = 4
_cur$ = 8						; size = 4
?ShiftNodeRight@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEXPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@@Z PROC ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::ShiftNodeRight, COMDAT
; _this$ = ecx

; 459  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 460  : 		int i;
; 461  : 		for (i=cur->size; i>0; i--)

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN11@ShiftNodeR
$LN10@ShiftNodeR:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN11@ShiftNodeR:
	cmp	DWORD PTR _i$[ebp], 0
	jle	SHORT $LN9@ShiftNodeR

; 462  : 			cur->keys[i]=cur->keys[i-1];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+1]
	mov	DWORD PTR [ecx+eax*4+5], edx
	jmp	SHORT $LN10@ShiftNodeR
$LN9@ShiftNodeR:

; 463  : 		if (cur->isLeaf)

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN8@ShiftNodeR

; 464  : 		{
; 465  : 			for (i=cur->size; i>0; i--)

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN7@ShiftNodeR
$LN6@ShiftNodeR:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@ShiftNodeR:
	cmp	DWORD PTR _i$[ebp], 0
	jle	SHORT $LN5@ShiftNodeR

; 466  : 				cur->data[i]=cur->data[i-1];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+65]
	mov	DWORD PTR [ecx+eax*4+69], edx
	jmp	SHORT $LN6@ShiftNodeR
$LN5@ShiftNodeR:

; 467  : 		}
; 468  : 		else

	jmp	SHORT $LN4@ShiftNodeR
$LN8@ShiftNodeR:

; 469  : 		{
; 470  : 			for (i=cur->size+1; i>0; i--)

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN3@ShiftNodeR
$LN2@ShiftNodeR:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@ShiftNodeR:
	cmp	DWORD PTR _i$[ebp], 0
	jle	SHORT $LN4@ShiftNodeR

; 471  : 				cur->children[i]=cur->children[i-1];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+137]
	mov	DWORD PTR [ecx+eax*4+141], edx
	jmp	SHORT $LN2@ShiftNodeR
$LN4@ShiftNodeR:

; 472  : 		}
; 473  : 
; 474  : 		cur->size++;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	add	ecx, 1
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx+1], ecx

; 475  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ShiftNodeRight@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEXPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@@Z ENDP ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::ShiftNodeRight
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?ShiftNodeLeft@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEXPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@@Z
_TEXT	SEGMENT
_i$ = -20						; size = 4
_this$ = -8						; size = 4
_cur$ = 8						; size = 4
?ShiftNodeLeft@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEXPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@@Z PROC ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::ShiftNodeLeft, COMDAT
; _this$ = ecx

; 478  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 479  : 		int i;
; 480  : 		for (i=0; i < cur->size-1; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN11@ShiftNodeL
$LN10@ShiftNodeL:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN11@ShiftNodeL:
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	sub	ecx, 1
	cmp	DWORD PTR _i$[ebp], ecx
	jge	SHORT $LN9@ShiftNodeL

; 481  : 			cur->keys[i]=cur->keys[i+1];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+9]
	mov	DWORD PTR [ecx+eax*4+5], edx
	jmp	SHORT $LN10@ShiftNodeL
$LN9@ShiftNodeL:

; 482  : 		if (cur->isLeaf)

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN8@ShiftNodeL

; 483  : 		{
; 484  : 			for (i=0; i < cur->size; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@ShiftNodeL
$LN6@ShiftNodeL:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@ShiftNodeL:
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+1]
	jge	SHORT $LN5@ShiftNodeL

; 485  : 				cur->data[i]=cur->data[i+1];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+73]
	mov	DWORD PTR [ecx+eax*4+69], edx
	jmp	SHORT $LN6@ShiftNodeL
$LN5@ShiftNodeL:

; 486  : 		}
; 487  : 		else

	jmp	SHORT $LN4@ShiftNodeL
$LN8@ShiftNodeL:

; 488  : 		{
; 489  : 			for (i=0; i < cur->size; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@ShiftNodeL
$LN2@ShiftNodeL:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@ShiftNodeL:
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+1]
	jge	SHORT $LN4@ShiftNodeL

; 490  : 				cur->children[i]=cur->children[i+1];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+145]
	mov	DWORD PTR [ecx+eax*4+141], edx
	jmp	SHORT $LN2@ShiftNodeL
$LN4@ShiftNodeL:

; 491  : 		}
; 492  : 		cur->size--;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	sub	ecx, 1
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx+1], ecx

; 493  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ShiftNodeLeft@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEXPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@@Z ENDP ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::ShiftNodeLeft
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?FixUnderflow@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAE_NHPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@IPAUReturnAction@12@@Z
_TEXT	SEGMENT
tv375 = -244						; size = 4
_sourceIndex$1 = -44					; size = 4
_dest$ = -32						; size = 4
_source$ = -20						; size = 4
_this$ = -8						; size = 4
_branchIndex$ = 8					; size = 4
_cur$ = 12						; size = 4
_rightRootKey$ = 16					; size = 4
_returnAction$ = 20					; size = 4
?FixUnderflow@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAE_NHPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@IPAUReturnAction@12@@Z PROC ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::FixUnderflow, COMDAT
; _this$ = ecx

; 279  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 280  : 		// Borrow from a neighbor that has excess.
; 281  : 		Page<KeyType, DataType, order> *source;
; 282  : 		Page<KeyType, DataType, order> *dest;
; 283  : 
; 284  : 		if (branchIndex>0 && cur->children[branchIndex-1]->size > order/2)

	cmp	DWORD PTR _branchIndex$[ebp], 0
	jle	$LN31@FixUnderfl
	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+137]
	cmp	DWORD PTR [edx+1], 8
	jle	$LN31@FixUnderfl

; 285  : 		{
; 286  : 			dest=cur->children[branchIndex];

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+141]
	mov	DWORD PTR _dest$[ebp], edx

; 287  : 			source=cur->children[branchIndex-1];

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+137]
	mov	DWORD PTR _source$[ebp], edx

; 288  : 
; 289  : 			// Left has excess
; 290  : 			ShiftNodeRight(dest);

	mov	eax, DWORD PTR _dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShiftNodeRight@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEXPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::ShiftNodeRight

; 291  : 			if (dest->isLeaf)

	mov	eax, DWORD PTR _dest$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN30@FixUnderfl

; 292  : 			{
; 293  : 				dest->keys[0]=source->keys[source->size-1];

	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dest$[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4+1]
	mov	DWORD PTR [edx+eax+5], ecx

; 294  : 				dest->data[0]=source->data[source->size-1];

	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dest$[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4+65]
	mov	DWORD PTR [edx+eax+69], ecx

; 295  : 			}
; 296  : 			else

	jmp	SHORT $LN29@FixUnderfl
$LN30@FixUnderfl:

; 297  : 			{
; 298  : 				dest->children[0]=source->children[source->size];

	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dest$[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4+141]
	mov	DWORD PTR [edx+eax+141], ecx

; 299  : 				dest->keys[0]=cur->keys[branchIndex-1];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [esi+eax*4+1]
	mov	DWORD PTR [edx+ecx+5], eax
$LN29@FixUnderfl:

; 300  : 			}
; 301  : 			// Update the parent key for the child (middle)
; 302  : 			cur->keys[branchIndex-1]=source->keys[source->size-1];

	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	mov	edx, DWORD PTR _branchIndex$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4+1]
	mov	DWORD PTR [eax+edx*4+1], ecx

; 303  : 			source->size--;

	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	sub	ecx, 1
	mov	edx, DWORD PTR _source$[ebp]
	mov	DWORD PTR [edx+1], ecx

; 304  : 
; 305  : 	//		if (branchIndex==0)
; 306  : 	//		{
; 307  : 	//			returnAction->action=ReturnAction::SET_BRANCH_KEY;
; 308  : 	//			returnAction->key1=dest->keys[0];
; 309  : 	//		}
; 310  : 
; 311  : 			// No underflow
; 312  : 			return false;

	xor	al, al
	jmp	$LN32@FixUnderfl
	jmp	$LN32@FixUnderfl
$LN31@FixUnderfl:

; 313  : 		}
; 314  : 		else if (branchIndex<cur->size && cur->children[branchIndex+1]->size > order/2)

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _branchIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+1]
	jge	$LN27@FixUnderfl
	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+145]
	cmp	DWORD PTR [edx+1], 8
	jle	$LN27@FixUnderfl

; 315  : 		{
; 316  : 			dest=cur->children[branchIndex];

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+141]
	mov	DWORD PTR _dest$[ebp], edx

; 317  : 			source=cur->children[branchIndex+1];

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+145]
	mov	DWORD PTR _source$[ebp], edx

; 318  : 
; 319  : 			// Right has excess
; 320  : 			if (dest->isLeaf)

	mov	eax, DWORD PTR _dest$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN26@FixUnderfl

; 321  : 			{
; 322  : 				dest->keys[dest->size]=source->keys[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR [edx+1]
	mov	edx, DWORD PTR _dest$[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+5]
	mov	DWORD PTR [edx+eax*4+5], ecx

; 323  : 				dest->data[dest->size]=source->data[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR [edx+1]
	mov	edx, DWORD PTR _dest$[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+69]
	mov	DWORD PTR [edx+eax*4+69], ecx

; 324  : 
; 325  : 				// The first key in the leaf after shifting is the parent key for the right branch
; 326  : 				cur->keys[branchIndex]=source->keys[1];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _branchIndex$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	eax, DWORD PTR [esi+eax+5]
	mov	DWORD PTR [edx+ecx*4+5], eax

; 327  : 
; 328  : #ifdef _MSC_VER
; 329  : #pragma warning( disable : 4127 ) // warning C4127: conditional expression is constant
; 330  : #endif
; 331  : 				if (order<=3 && dest->size==0)

	xor	eax, eax
	je	SHORT $LN25@FixUnderfl

; 332  : 				{
; 333  : 					if (branchIndex==0)

	cmp	DWORD PTR _branchIndex$[ebp], 0
	jne	SHORT $LN24@FixUnderfl

; 334  : 					{
; 335  : 						returnAction->action=ReturnAction::SET_BRANCH_KEY;

	mov	eax, DWORD PTR _returnAction$[ebp]
	mov	DWORD PTR [eax+8], 3

; 336  : 						returnAction->key1=dest->keys[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _returnAction$[ebp]
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+5]
	mov	DWORD PTR [edx], ecx

; 337  : 					}
; 338  : 					else

	jmp	SHORT $LN25@FixUnderfl
$LN24@FixUnderfl:

; 339  : 						cur->keys[branchIndex-1]=cur->children[branchIndex]->keys[0];

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+141]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+5]
	mov	DWORD PTR [esi+eax*4+1], ecx
$LN25@FixUnderfl:

; 340  : 				}
; 341  : 			}
; 342  : 			else

	jmp	SHORT $LN22@FixUnderfl
$LN26@FixUnderfl:

; 343  : 			{
; 344  : 				if (returnAction->action==ReturnAction::NO_ACTION)

	mov	eax, DWORD PTR _returnAction$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN21@FixUnderfl

; 345  : 				{
; 346  : 					returnAction->action=ReturnAction::SET_BRANCH_KEY;

	mov	eax, DWORD PTR _returnAction$[ebp]
	mov	DWORD PTR [eax+8], 3

; 347  : 					returnAction->key1=dest->keys[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _returnAction$[ebp]
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+5]
	mov	DWORD PTR [edx], ecx
$LN21@FixUnderfl:

; 348  : 				}
; 349  : 				
; 350  : 				dest->keys[dest->size]=rightRootKey;

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR _rightRootKey$[ebp]
	mov	DWORD PTR [edx+ecx*4+5], eax

; 351  : 				dest->children[dest->size+1]=source->children[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR [edx+1]
	mov	edx, DWORD PTR _dest$[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+141]
	mov	DWORD PTR [edx+eax*4+145], ecx

; 352  : 
; 353  : 				// The shifted off key is the leftmost key for a node
; 354  : 				cur->keys[branchIndex]=source->keys[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _branchIndex$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+5]
	mov	DWORD PTR [eax+edx*4+5], ecx
$LN22@FixUnderfl:

; 355  : 			}
; 356  : 
; 357  : 
; 358  : 			dest->size++;

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	add	ecx, 1
	mov	edx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR [edx+1], ecx

; 359  : 			ShiftNodeLeft(source);

	mov	eax, DWORD PTR _source$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShiftNodeLeft@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEXPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::ShiftNodeLeft

; 360  : 
; 361  : 			//cur->keys[branchIndex]=source->keys[0];
; 362  : 
; 363  : //			returnAction->action=ReturnAction::SET_BRANCH_KEY;
; 364  : //			returnAction->key1=dest->keys[dest->size-1];
; 365  : 
; 366  : 			// No underflow
; 367  : 			return false;

	xor	al, al
	jmp	$LN32@FixUnderfl

; 368  : 		}
; 369  : 		else

	jmp	$LN32@FixUnderfl
$LN27@FixUnderfl:

; 370  : 		{
; 371  : 			int sourceIndex;
; 372  : 
; 373  : 			// If no neighbors have excess, merge two branches.
; 374  : 			//
; 375  : 			// To merge two leaves, just copy the data and keys over.
; 376  : 			//
; 377  : 			// To merge two branches, copy the pointers and keys over, using rightRootKey as the key for the extra pointer
; 378  : 			if (branchIndex<cur->size)

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _branchIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+1]
	jge	SHORT $LN19@FixUnderfl

; 379  : 			{
; 380  : 				// Merge right child to current child and delete right child.
; 381  : 				dest=cur->children[branchIndex];

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+141]
	mov	DWORD PTR _dest$[ebp], edx

; 382  : 				source=cur->children[branchIndex+1];

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+145]
	mov	DWORD PTR _source$[ebp], edx

; 383  : 			}
; 384  : 			else

	jmp	SHORT $LN18@FixUnderfl
$LN19@FixUnderfl:

; 385  : 			{
; 386  : 				// Move current child to left and delete current child
; 387  : 				dest=cur->children[branchIndex-1];

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+137]
	mov	DWORD PTR _dest$[ebp], edx

; 388  : 				source=cur->children[branchIndex];

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+141]
	mov	DWORD PTR _source$[ebp], edx
$LN18@FixUnderfl:

; 389  : 			}
; 390  : 
; 391  : 			// Merge
; 392  : 			if (dest->isLeaf)

	mov	eax, DWORD PTR _dest$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN17@FixUnderfl

; 393  : 			{
; 394  : 				for (sourceIndex=0; sourceIndex<source->size; sourceIndex++)

	mov	DWORD PTR _sourceIndex$1[ebp], 0
	jmp	SHORT $LN16@FixUnderfl
$LN15@FixUnderfl:
	mov	eax, DWORD PTR _sourceIndex$1[ebp]
	add	eax, 1
	mov	DWORD PTR _sourceIndex$1[ebp], eax
$LN16@FixUnderfl:
	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR _sourceIndex$1[ebp]
	cmp	ecx, DWORD PTR [eax+1]
	jge	SHORT $LN14@FixUnderfl

; 395  : 				{
; 396  : 					dest->keys[dest->size]=source->keys[sourceIndex];

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR _sourceIndex$1[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	eax, DWORD PTR [esi+eax*4+5]
	mov	DWORD PTR [edx+ecx*4+5], eax

; 397  : 					dest->data[dest->size++]=source->data[sourceIndex];

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR _sourceIndex$1[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	eax, DWORD PTR [esi+eax*4+69]
	mov	DWORD PTR [edx+ecx*4+69], eax
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR [ecx+1]
	add	edx, 1
	mov	eax, DWORD PTR _dest$[ebp]
	mov	DWORD PTR [eax+1], edx

; 398  : 				}

	jmp	SHORT $LN15@FixUnderfl
$LN14@FixUnderfl:

; 399  : 			}
; 400  : 			else

	jmp	$LN13@FixUnderfl
$LN17@FixUnderfl:

; 401  : 			{
; 402  : 				// We want the tree root key of the source, not the current.
; 403  : 				dest->keys[dest->size]=rightRootKey;

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR _rightRootKey$[ebp]
	mov	DWORD PTR [edx+ecx*4+5], eax

; 404  : 				dest->children[dest->size++ + 1]=source->children[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR [edx+1]
	mov	edx, DWORD PTR _dest$[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+141]
	mov	DWORD PTR [edx+eax*4+145], ecx
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR [edx+1]
	add	eax, 1
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR [ecx+1], eax

; 405  : 				for (sourceIndex=0; sourceIndex<source->size; sourceIndex++)

	mov	DWORD PTR _sourceIndex$1[ebp], 0
	jmp	SHORT $LN12@FixUnderfl
$LN11@FixUnderfl:
	mov	eax, DWORD PTR _sourceIndex$1[ebp]
	add	eax, 1
	mov	DWORD PTR _sourceIndex$1[ebp], eax
$LN12@FixUnderfl:
	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR _sourceIndex$1[ebp]
	cmp	ecx, DWORD PTR [eax+1]
	jge	SHORT $LN13@FixUnderfl

; 406  : 				{
; 407  : 					dest->keys[dest->size]=source->keys[sourceIndex];

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR _sourceIndex$1[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	eax, DWORD PTR [esi+eax*4+5]
	mov	DWORD PTR [edx+ecx*4+5], eax

; 408  : 					dest->children[dest->size++ + 1]=source->children[sourceIndex + 1];

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR _sourceIndex$1[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	eax, DWORD PTR [esi+eax*4+145]
	mov	DWORD PTR [edx+ecx*4+145], eax
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR [ecx+1]
	add	edx, 1
	mov	eax, DWORD PTR _dest$[ebp]
	mov	DWORD PTR [eax+1], edx

; 409  : 				}

	jmp	SHORT $LN11@FixUnderfl
$LN13@FixUnderfl:

; 410  : 			}
; 411  : 
; 412  : #ifdef _MSC_VER
; 413  : #pragma warning( disable : 4127 ) // warning C4127: conditional expression is constant
; 414  : #endif
; 415  : 			if (order<=3 && branchIndex>0 && cur->children[branchIndex]->isLeaf) // With order==2 it is possible to delete data[0], which is not possible with higher orders.

	xor	eax, eax
	je	SHORT $LN9@FixUnderfl

; 416  : 				cur->keys[branchIndex-1]=cur->children[branchIndex]->keys[0];

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+141]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+5]
	mov	DWORD PTR [esi+eax*4+1], ecx
$LN9@FixUnderfl:

; 417  : 
; 418  : 			if (branchIndex<cur->size)

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _branchIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+1]
	jge	SHORT $LN8@FixUnderfl

; 419  : 			{
; 420  : 				// Update the parent key, removing the source (right)
; 421  : 				DeleteFromPageAtIndex(branchIndex, cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _branchIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DeleteFromPageAtIndex@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEXHPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::DeleteFromPageAtIndex

; 422  : 			}
; 423  : 			else

	jmp	SHORT $LN7@FixUnderfl
$LN8@FixUnderfl:

; 424  : 			{
; 425  : 				if (branchIndex>0)

	cmp	DWORD PTR _branchIndex$[ebp], 0
	jle	SHORT $LN7@FixUnderfl

; 426  : 				{
; 427  : 					// Update parent key, removing the source (current)
; 428  : 					DeleteFromPageAtIndex(branchIndex-1, cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _branchIndex$[ebp]
	sub	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DeleteFromPageAtIndex@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEXHPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::DeleteFromPageAtIndex
$LN7@FixUnderfl:

; 429  : 				}
; 430  : 			}
; 431  : 
; 432  : 			if (branchIndex==0 && dest->isLeaf)

	cmp	DWORD PTR _branchIndex$[ebp], 0
	jne	SHORT $LN5@FixUnderfl
	mov	eax, DWORD PTR _dest$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN5@FixUnderfl

; 433  : 			{
; 434  : 				returnAction->action=ReturnAction::SET_BRANCH_KEY;

	mov	eax, DWORD PTR _returnAction$[ebp]
	mov	DWORD PTR [eax+8], 3

; 435  : 				returnAction->key1=dest->keys[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _returnAction$[ebp]
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+5]
	mov	DWORD PTR [edx], ecx
$LN5@FixUnderfl:

; 436  : 			}
; 437  : 
; 438  : 			if (source==leftmostLeaf)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _source$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	jne	SHORT $LN4@FixUnderfl

; 439  : 				leftmostLeaf=source->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _source$[ebp]
	mov	edx, DWORD PTR [ecx+133]
	mov	DWORD PTR [eax+20], edx
$LN4@FixUnderfl:

; 440  : 
; 441  : 			if (source->isLeaf)

	mov	eax, DWORD PTR _source$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@FixUnderfl

; 442  : 			{
; 443  : 				if (source->previous)

	mov	eax, DWORD PTR _source$[ebp]
	cmp	DWORD PTR [eax+137], 0
	je	SHORT $LN2@FixUnderfl

; 444  : 					source->previous->next=source->next;

	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+137]
	mov	edx, DWORD PTR _source$[ebp]
	mov	eax, DWORD PTR [edx+133]
	mov	DWORD PTR [ecx+133], eax
$LN2@FixUnderfl:

; 445  : 				if (source->next)

	mov	eax, DWORD PTR _source$[ebp]
	cmp	DWORD PTR [eax+133], 0
	je	SHORT $LN3@FixUnderfl

; 446  : 					source->next->previous=source->previous;

	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+133]
	mov	edx, DWORD PTR _source$[ebp]
	mov	eax, DWORD PTR [edx+137]
	mov	DWORD PTR [ecx+137], eax
$LN3@FixUnderfl:

; 447  : 			}			
; 448  : 
; 449  : 			// Free the source node
; 450  : 			pagePool.Release(source);

	mov	eax, DWORD PTR _source$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Release@?$MemoryPool@U?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAEXPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@@Z ; DataStructures::MemoryPool<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> >::Release

; 451  : 			memset(source,0,sizeof(root));

	push	4
	push	0
	mov	eax, DWORD PTR _source$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 452  : 
; 453  : 			// Return underflow or not of parent.
; 454  : 			return cur->size < order/2;

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+1], 8
	jge	SHORT $LN34@FixUnderfl
	mov	DWORD PTR tv375[ebp], 1
	jmp	SHORT $LN35@FixUnderfl
$LN34@FixUnderfl:
	mov	DWORD PTR tv375[ebp], 0
$LN35@FixUnderfl:
	mov	al, BYTE PTR tv375[ebp]
$LN32@FixUnderfl:

; 455  : 		}
; 456  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?FixUnderflow@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAE_NHPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@IPAUReturnAction@12@@Z ENDP ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::FixUnderflow
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?FindDeleteRebalance@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAE_NIPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@PA_NIPAUReturnAction@12@AAPAURow@Table@2@@Z
_TEXT	SEGMENT
_childIndex$ = -32					; size = 4
_branchIndex$ = -20					; size = 4
_this$ = -8						; size = 4
_key$ = 8						; size = 4
_cur$ = 12						; size = 4
_underflow$ = 16					; size = 4
_rightRootKey$ = 20					; size = 4
_returnAction$ = 24					; size = 4
_out$ = 28						; size = 4
?FindDeleteRebalance@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAE_NIPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@PA_NIPAUReturnAction@12@AAPAURow@Table@2@@Z PROC ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::FindDeleteRebalance, COMDAT
; _this$ = ecx

; 204  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 205  : 		// Get index of child to follow.
; 206  : 		int branchIndex, childIndex;
; 207  : 		if (GetIndexOf(key, cur, &childIndex))

	lea	eax, DWORD PTR _childIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexOf@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IBE_NIPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@PAH@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::GetIndexOf
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN19@FindDelete

; 208  : 			branchIndex=childIndex+1;

	mov	eax, DWORD PTR _childIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _branchIndex$[ebp], eax

; 209  : 		else

	jmp	SHORT $LN18@FindDelete
$LN19@FindDelete:

; 210  : 			branchIndex=childIndex;

	mov	eax, DWORD PTR _childIndex$[ebp]
	mov	DWORD PTR _branchIndex$[ebp], eax
$LN18@FindDelete:

; 211  : 
; 212  : 		// If child is not a leaf, call recursively
; 213  : 		if (cur->children[branchIndex]->isLeaf==false)

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+141]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	$LN17@FindDelete

; 214  : 		{
; 215  : 			if (branchIndex<cur->size)

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _branchIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+1]
	jge	SHORT $LN16@FindDelete

; 216  : 				rightRootKey=cur->keys[branchIndex]; // Shift right to left

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+5]
	mov	DWORD PTR _rightRootKey$[ebp], edx

; 217  : 			else

	jmp	SHORT $LN15@FindDelete
$LN16@FindDelete:

; 218  : 				rightRootKey=cur->keys[branchIndex-1]; // Shift center to left

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+1]
	mov	DWORD PTR _rightRootKey$[ebp], edx
$LN15@FindDelete:

; 219  : 
; 220  : 			if (FindDeleteRebalance(key, cur->children[branchIndex], underflow, rightRootKey, returnAction, out)==false)

	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	mov	ecx, DWORD PTR _returnAction$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rightRootKey$[ebp]
	push	edx
	mov	eax, DWORD PTR _underflow$[ebp]
	push	eax
	mov	ecx, DWORD PTR _branchIndex$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+141]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindDeleteRebalance@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAE_NIPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@PA_NIPAUReturnAction@12@AAPAURow@Table@2@@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::FindDeleteRebalance
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN14@FindDelete

; 221  : 				return false;

	xor	al, al
	jmp	$LN20@FindDelete
$LN14@FindDelete:

; 222  : 
; 223  : 			// Call again in case the root key changed
; 224  : 			if (branchIndex<cur->size)

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _branchIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+1]
	jge	SHORT $LN13@FindDelete

; 225  : 				rightRootKey=cur->keys[branchIndex]; // Shift right to left

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+5]
	mov	DWORD PTR _rightRootKey$[ebp], edx

; 226  : 			else

	jmp	SHORT $LN12@FindDelete
$LN13@FindDelete:

; 227  : 				rightRootKey=cur->keys[branchIndex-1]; // Shift center to left

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+1]
	mov	DWORD PTR _rightRootKey$[ebp], edx
$LN12@FindDelete:

; 228  : 
; 229  : 			if (returnAction->action==ReturnAction::SET_BRANCH_KEY && branchIndex!=childIndex)

	mov	eax, DWORD PTR _returnAction$[ebp]
	cmp	DWORD PTR [eax+8], 3
	jne	SHORT $LN11@FindDelete
	mov	eax, DWORD PTR _branchIndex$[ebp]
	cmp	eax, DWORD PTR _childIndex$[ebp]
	je	SHORT $LN11@FindDelete

; 230  : 			{
; 231  : 				returnAction->action=ReturnAction::NO_ACTION;

	mov	eax, DWORD PTR _returnAction$[ebp]
	mov	DWORD PTR [eax+8], 0

; 232  : 				cur->keys[childIndex]=returnAction->key1;

	mov	eax, DWORD PTR _childIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _returnAction$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+eax*4+5], edx

; 233  : 
; 234  : 				if (branchIndex<cur->size)

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _branchIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+1]
	jge	SHORT $LN10@FindDelete

; 235  : 					rightRootKey=cur->keys[branchIndex]; // Shift right to left

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+5]
	mov	DWORD PTR _rightRootKey$[ebp], edx

; 236  : 				else

	jmp	SHORT $LN11@FindDelete
$LN10@FindDelete:

; 237  : 					rightRootKey=cur->keys[branchIndex-1]; // Shift center to left

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+1]
	mov	DWORD PTR _rightRootKey$[ebp], edx
$LN11@FindDelete:

; 238  : 			}
; 239  : 		}
; 240  : 		else

	jmp	$LN8@FindDelete
$LN17@FindDelete:

; 241  : 		{
; 242  : 			// If child is a leaf, get the index of the key.  If the item is not found, cancel delete.
; 243  : 			if (GetIndexOf(key, cur->children[branchIndex], &childIndex)==false)

	lea	eax, DWORD PTR _childIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _branchIndex$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+141]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexOf@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IBE_NIPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@PAH@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::GetIndexOf
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN7@FindDelete

; 244  : 				return false;

	xor	al, al
	jmp	$LN20@FindDelete
$LN7@FindDelete:

; 245  : 
; 246  : 			// Delete:
; 247  : 			// Remove childIndex from the child at branchIndex
; 248  : 			out=cur->children[branchIndex]->data[childIndex];

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+141]
	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _childIndex$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4+69]
	mov	DWORD PTR [eax], edx

; 249  : 			DeleteFromPageAtIndex(childIndex, cur->children[branchIndex]);

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+141]
	push	edx
	mov	eax, DWORD PTR _childIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DeleteFromPageAtIndex@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEXHPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::DeleteFromPageAtIndex

; 250  : 
; 251  : 			if (childIndex==0)

	cmp	DWORD PTR _childIndex$[ebp], 0
	jne	SHORT $LN6@FindDelete

; 252  : 			{
; 253  : 				if (branchIndex>0)

	cmp	DWORD PTR _branchIndex$[ebp], 0
	jle	SHORT $LN5@FindDelete

; 254  : 					cur->keys[branchIndex-1]=cur->children[branchIndex]->keys[0];

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+141]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+5]
	mov	DWORD PTR [esi+eax*4+1], ecx
$LN5@FindDelete:

; 255  : 
; 256  : 				if (branchIndex==0)

	cmp	DWORD PTR _branchIndex$[ebp], 0
	jne	SHORT $LN6@FindDelete

; 257  : 				{
; 258  : 					returnAction->action=ReturnAction::SET_BRANCH_KEY;

	mov	eax, DWORD PTR _returnAction$[ebp]
	mov	DWORD PTR [eax+8], 3

; 259  : 					returnAction->key1=cur->children[0]->keys[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+ecx+141]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _returnAction$[ebp]
	mov	edx, DWORD PTR [eax+edx+5]
	mov	DWORD PTR [ecx], edx
$LN6@FindDelete:

; 260  : 				}				
; 261  : 			}
; 262  : 
; 263  : 			if (cur->children[branchIndex]->size < order/2)

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+141]
	cmp	DWORD PTR [edx+1], 8
	jge	SHORT $LN3@FindDelete

; 264  : 				*underflow=true;

	mov	eax, DWORD PTR _underflow$[ebp]
	mov	BYTE PTR [eax], 1

; 265  : 			else

	jmp	SHORT $LN8@FindDelete
$LN3@FindDelete:

; 266  : 				*underflow=false;

	mov	eax, DWORD PTR _underflow$[ebp]
	mov	BYTE PTR [eax], 0
$LN8@FindDelete:

; 267  : 		}
; 268  : 
; 269  : 		// Fix underflow:
; 270  : 		if (*underflow)

	mov	eax, DWORD PTR _underflow$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN1@FindDelete

; 271  : 		{
; 272  : 			*underflow=FixUnderflow(branchIndex, cur, rightRootKey, returnAction);

	mov	eax, DWORD PTR _returnAction$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rightRootKey$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _branchIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FixUnderflow@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAE_NHPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@IPAUReturnAction@12@@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::FixUnderflow
	mov	ecx, DWORD PTR _underflow$[ebp]
	mov	BYTE PTR [ecx], al
$LN1@FindDelete:

; 273  : 		}
; 274  : 
; 275  : 		return true;

	mov	al, 1
$LN20@FindDelete:

; 276  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN24@FindDelete
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
	npad	3
$LN24@FindDelete:
	DD	1
	DD	$LN23@FindDelete
$LN23@FindDelete:
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN22@FindDelete
$LN22@FindDelete:
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	100					; 00000064H
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	0
?FindDeleteRebalance@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAE_NIPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@PA_NIPAUReturnAction@12@AAPAURow@Table@2@@Z ENDP ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::FindDeleteRebalance
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?GetLeafFromKey@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IBEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@I@Z
_TEXT	SEGMENT
_childIndex$ = -32					; size = 4
_cur$ = -20						; size = 4
_this$ = -8						; size = 4
_key$ = 8						; size = 4
?GetLeafFromKey@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IBEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@I@Z PROC ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::GetLeafFromKey, COMDAT
; _this$ = ecx

; 685  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 686  : 		Page<KeyType, DataType, order>* cur = root;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _cur$[ebp], ecx
$LN3@GetLeafFro:

; 687  : 		int childIndex;
; 688  : 		while (cur->isLeaf==false)

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@GetLeafFro

; 689  : 		{
; 690  : 			// When searching, if we match the exact key we go down the pointer after that index
; 691  : 			if (GetIndexOf(key, cur, &childIndex))

	lea	eax, DWORD PTR _childIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexOf@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IBE_NIPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@PAH@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::GetIndexOf
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@GetLeafFro

; 692  : 				childIndex++;

	mov	eax, DWORD PTR _childIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _childIndex$[ebp], eax
$LN1@GetLeafFro:

; 693  : 			cur = cur->children[childIndex];

	mov	eax, DWORD PTR _childIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+141]
	mov	DWORD PTR _cur$[ebp], edx

; 694  : 		}

	jmp	SHORT $LN3@GetLeafFro
$LN2@GetLeafFro:

; 695  : 		return cur;

	mov	eax, DWORD PTR _cur$[ebp]

; 696  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@GetLeafFro
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN8@GetLeafFro:
	DD	1
	DD	$LN7@GetLeafFro
$LN7@GetLeafFro:
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN6@GetLeafFro
$LN6@GetLeafFro:
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	100					; 00000064H
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	0
?GetLeafFromKey@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IBEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@I@Z ENDP ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::GetLeafFromKey
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?InsertBranchDown@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@IABQAURow@Table@2@PAU32@PAUReturnAction@12@PA_N@Z
_TEXT	SEGMENT
_insertionIndex$1 = -92					; size = 4
_source$2 = -80						; size = 4
_dest$3 = -68						; size = 4
_insertionIndex$4 = -56					; size = 4
_newPage$ = -44						; size = 4
_branchIndex$ = -32					; size = 4
_childIndex$ = -20					; size = 4
_this$ = -8						; size = 4
_key$ = 8						; size = 4
_data$ = 12						; size = 4
_cur$ = 16						; size = 4
_returnAction$ = 20					; size = 4
_success$ = 24						; size = 4
?InsertBranchDown@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@IABQAURow@Table@2@PAU32@PAUReturnAction@12@PA_N@Z PROC ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::InsertBranchDown, COMDAT
; _this$ = ecx

; 700  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 288				; 00000120H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-288]
	mov	ecx, 72					; 00000048H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 701  : 		int childIndex;
; 702  : 		int branchIndex;
; 703  : 		if (GetIndexOf(key, cur, &childIndex))

	lea	eax, DWORD PTR _childIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexOf@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IBE_NIPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@PAH@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::GetIndexOf
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN20@InsertBran

; 704  : 			branchIndex=childIndex+1;

	mov	eax, DWORD PTR _childIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _branchIndex$[ebp], eax

; 705  : 		else

	jmp	SHORT $LN19@InsertBran
$LN20@InsertBran:

; 706  : 			branchIndex=childIndex;

	mov	eax, DWORD PTR _childIndex$[ebp]
	mov	DWORD PTR _branchIndex$[ebp], eax
$LN19@InsertBran:

; 707  : 		Page<KeyType, DataType, order>* newPage;
; 708  : 		if (cur->isLeaf==false)

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	$LN18@InsertBran

; 709  : 		{
; 710  : 			if (cur->children[branchIndex]->isLeaf==true && cur->children[branchIndex]->size==order)

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+141]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 1
	jne	$LN17@InsertBran
	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+141]
	cmp	DWORD PTR [edx+1], 16			; 00000010H
	jne	$LN17@InsertBran

; 711  : 			{
; 712  : 				if (branchIndex==childIndex+1)

	mov	eax, DWORD PTR _childIndex$[ebp]
	add	eax, 1
	cmp	DWORD PTR _branchIndex$[ebp], eax
	jne	SHORT $LN16@InsertBran

; 713  : 				{
; 714  : 					*success=false;

	mov	eax, DWORD PTR _success$[ebp]
	mov	BYTE PTR [eax], 0

; 715  : 					return 0; // Already exists

	xor	eax, eax
	jmp	$LN21@InsertBran
$LN16@InsertBran:

; 716  : 				}
; 717  : 
; 718  : 				if (CanRotateLeft(cur, branchIndex))

	mov	eax, DWORD PTR _branchIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CanRotateLeft@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAE_NPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@H@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::CanRotateLeft
	movzx	edx, al
	test	edx, edx
	je	$LN15@InsertBran

; 719  : 				{
; 720  : 					returnAction->action=ReturnAction::REPLACE_KEY1_WITH_KEY2;

	mov	eax, DWORD PTR _returnAction$[ebp]
	mov	DWORD PTR [eax+8], 1

; 721  : 					if (key > cur->children[branchIndex]->keys[0])

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+141]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _key$[ebp]
	cmp	eax, DWORD PTR [edx+ecx+5]
	jbe	SHORT $LN14@InsertBran

; 722  : 					{						
; 723  : 						RotateLeft(cur, branchIndex, returnAction);

	mov	eax, DWORD PTR _returnAction$[ebp]
	push	eax
	mov	ecx, DWORD PTR _branchIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RotateLeft@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEXPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@HPAUReturnAction@12@@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::RotateLeft

; 724  : 
; 725  : 						int insertionIndex;
; 726  : 						GetIndexOf(key, cur->children[branchIndex], &insertionIndex);

	lea	eax, DWORD PTR _insertionIndex$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _branchIndex$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+141]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexOf@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IBE_NIPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@PAH@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::GetIndexOf

; 727  : 						InsertIntoNode(key, data, insertionIndex, 0, cur->children[branchIndex], 0);

	push	0
	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+141]
	push	edx
	push	0
	mov	eax, DWORD PTR _insertionIndex$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertIntoNode@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@IABQAURow@Table@2@HPAU32@1PAUReturnAction@12@@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::InsertIntoNode

; 728  : 					}
; 729  : 					else

	jmp	$LN13@InsertBran
$LN14@InsertBran:

; 730  : 					{
; 731  : 						// Move head element to left and replace it with key,data
; 732  : 						Page<KeyType, DataType, order>* dest=cur->children[branchIndex-1];

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+137]
	mov	DWORD PTR _dest$3[ebp], edx

; 733  : 						Page<KeyType, DataType, order>* source=cur->children[branchIndex];

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+141]
	mov	DWORD PTR _source$2[ebp], edx

; 734  : 						returnAction->key1=source->keys[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _returnAction$[ebp]
	mov	eax, DWORD PTR _source$2[ebp]
	mov	ecx, DWORD PTR [eax+ecx+5]
	mov	DWORD PTR [edx], ecx

; 735  : 						returnAction->key2=key;

	mov	eax, DWORD PTR _returnAction$[ebp]
	mov	ecx, DWORD PTR _key$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 736  : 						dest->keys[dest->size]=source->keys[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _dest$3[ebp]
	mov	eax, DWORD PTR [edx+1]
	mov	edx, DWORD PTR _dest$3[ebp]
	mov	esi, DWORD PTR _source$2[ebp]
	mov	ecx, DWORD PTR [esi+ecx+5]
	mov	DWORD PTR [edx+eax*4+5], ecx

; 737  : 						dest->data[dest->size]=source->data[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _dest$3[ebp]
	mov	eax, DWORD PTR [edx+1]
	mov	edx, DWORD PTR _dest$3[ebp]
	mov	esi, DWORD PTR _source$2[ebp]
	mov	ecx, DWORD PTR [esi+ecx+69]
	mov	DWORD PTR [edx+eax*4+69], ecx

; 738  : 						dest->size++;

	mov	eax, DWORD PTR _dest$3[ebp]
	mov	ecx, DWORD PTR [eax+1]
	add	ecx, 1
	mov	edx, DWORD PTR _dest$3[ebp]
	mov	DWORD PTR [edx+1], ecx

; 739  : 						source->keys[0]=key;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _source$2[ebp]
	mov	eax, DWORD PTR _key$[ebp]
	mov	DWORD PTR [edx+ecx+5], eax

; 740  : 						source->data[0]=data;	

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _source$2[ebp]
	mov	eax, DWORD PTR _data$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx+ecx+69], eax
$LN13@InsertBran:

; 741  : 					}
; 742  : 					cur->keys[branchIndex-1]=cur->children[branchIndex]->keys[0];

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+141]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+5]
	mov	DWORD PTR [esi+eax*4+1], ecx

; 743  : 					
; 744  : 					return 0;

	xor	eax, eax
	jmp	$LN21@InsertBran
	jmp	$LN17@InsertBran
$LN15@InsertBran:

; 745  : 				}
; 746  : 				else if (CanRotateRight(cur, branchIndex))

	mov	eax, DWORD PTR _branchIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CanRotateRight@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAE_NPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@H@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::CanRotateRight
	movzx	edx, al
	test	edx, edx
	je	$LN17@InsertBran

; 747  : 				{
; 748  : 					returnAction->action=ReturnAction::REPLACE_KEY1_WITH_KEY2;

	mov	eax, DWORD PTR _returnAction$[ebp]
	mov	DWORD PTR [eax+8], 1

; 749  : 					
; 750  : 					if (key < cur->children[branchIndex]->keys[cur->children[branchIndex]->size-1])

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+141]
	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+141]
	mov	ecx, DWORD PTR [eax+1]
	mov	eax, DWORD PTR _key$[ebp]
	cmp	eax, DWORD PTR [edx+ecx*4+1]
	jae	SHORT $LN10@InsertBran

; 751  : 					{
; 752  : 						RotateRight(cur, branchIndex, returnAction);

	mov	eax, DWORD PTR _returnAction$[ebp]
	push	eax
	mov	ecx, DWORD PTR _branchIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RotateRight@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEXPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@HPAUReturnAction@12@@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::RotateRight

; 753  : 
; 754  : 						int insertionIndex;
; 755  : 						GetIndexOf(key, cur->children[branchIndex], &insertionIndex);

	lea	eax, DWORD PTR _insertionIndex$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _branchIndex$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+141]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexOf@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IBE_NIPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@PAH@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::GetIndexOf

; 756  : 						InsertIntoNode(key, data, insertionIndex, 0, cur->children[branchIndex], 0);

	push	0
	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+141]
	push	edx
	push	0
	mov	eax, DWORD PTR _insertionIndex$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertIntoNode@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@IABQAURow@Table@2@HPAU32@1PAUReturnAction@12@@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::InsertIntoNode

; 757  : 						
; 758  : 					}
; 759  : 					else

	jmp	SHORT $LN9@InsertBran
$LN10@InsertBran:

; 760  : 					{
; 761  : 						// Insert to the head of the right leaf instead and change our key
; 762  : 						returnAction->key1=cur->children[branchIndex+1]->keys[0];

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+145]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _returnAction$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+5]
	mov	DWORD PTR [eax], ecx

; 763  : 						InsertIntoNode(key, data, 0, 0, cur->children[branchIndex+1], 0);						

	push	0
	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+145]
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertIntoNode@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@IABQAURow@Table@2@HPAU32@1PAUReturnAction@12@@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::InsertIntoNode

; 764  : 						returnAction->key2=key;

	mov	eax, DWORD PTR _returnAction$[ebp]
	mov	ecx, DWORD PTR _key$[ebp]
	mov	DWORD PTR [eax+4], ecx
$LN9@InsertBran:

; 765  : 					}
; 766  : 					cur->keys[branchIndex]=cur->children[branchIndex+1]->keys[0];

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+145]
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+5]
	mov	DWORD PTR [esi+eax*4+5], ecx

; 767  : 					return 0;					

	xor	eax, eax
	jmp	$LN21@InsertBran
$LN17@InsertBran:

; 768  : 				}
; 769  : 			}
; 770  : 
; 771  : 			newPage=InsertBranchDown(key,data,cur->children[branchIndex], returnAction, success);

	mov	eax, DWORD PTR _success$[ebp]
	push	eax
	mov	ecx, DWORD PTR _returnAction$[ebp]
	push	ecx
	mov	edx, DWORD PTR _branchIndex$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+141]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	push	edx
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertBranchDown@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@IABQAURow@Table@2@PAU32@PAUReturnAction@12@PA_N@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::InsertBranchDown
	mov	DWORD PTR _newPage$[ebp], eax

; 772  : 			if (returnAction->action==ReturnAction::REPLACE_KEY1_WITH_KEY2)

	mov	eax, DWORD PTR _returnAction$[ebp]
	cmp	DWORD PTR [eax+8], 1
	jne	SHORT $LN8@InsertBran

; 773  : 			{
; 774  : 				if (branchIndex>0 && cur->keys[branchIndex-1]==returnAction->key1)

	cmp	DWORD PTR _branchIndex$[ebp], 0
	jle	SHORT $LN8@InsertBran
	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _returnAction$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+1]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN8@InsertBran

; 775  : 					cur->keys[branchIndex-1]=returnAction->key2;

	mov	eax, DWORD PTR _branchIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _returnAction$[ebp]
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+eax*4+1], edx
$LN8@InsertBran:

; 776  : 			}
; 777  : 			if (newPage)

	cmp	DWORD PTR _newPage$[ebp], 0
	je	$LN6@InsertBran

; 778  : 			{
; 779  : 				if (newPage->isLeaf==false)

	mov	eax, DWORD PTR _newPage$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@InsertBran

; 780  : 				{
; 781  : 					assert(returnAction->action==ReturnAction::PUSH_KEY_TO_PARENT);

	mov	eax, DWORD PTR _returnAction$[ebp]
	cmp	DWORD PTR [eax+8], 2
	je	SHORT $LN23@InsertBran
	push	781					; 0000030dH
	push	OFFSET ??_C@_1EO@DHNPHPFC@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAb?$AAp?$AAl?$AAu?$AAs@
	push	OFFSET ??_C@_1GO@DFNPOHCN@?$AAr?$AAe?$AAt?$AAu?$AAr?$AAn?$AAA?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?9?$AA?$DO?$AAa?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$DN?$AA?$DN?$AAR?$AAe?$AAt?$AAu?$AAr?$AAn?$AAA?$AAc?$AAt?$AAi@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN23@InsertBran:

; 782  : 					newPage->size--; 

	mov	eax, DWORD PTR _newPage$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	sub	ecx, 1
	mov	edx, DWORD PTR _newPage$[ebp]
	mov	DWORD PTR [edx+1], ecx

; 783  : 					return InsertIntoNode(returnAction->key1, data, branchIndex, newPage, cur, returnAction);

	mov	eax, DWORD PTR _returnAction$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _newPage$[ebp]
	push	edx
	mov	eax, DWORD PTR _branchIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _returnAction$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertIntoNode@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@IABQAURow@Table@2@HPAU32@1PAUReturnAction@12@@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::InsertIntoNode
	jmp	SHORT $LN21@InsertBran

; 784  : 				}
; 785  : 				else

	jmp	SHORT $LN6@InsertBran
$LN5@InsertBran:

; 786  : 				{
; 787  : 					return InsertIntoNode(newPage->keys[0], data, branchIndex, newPage, cur, returnAction);

	mov	eax, DWORD PTR _returnAction$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _newPage$[ebp]
	push	edx
	mov	eax, DWORD PTR _branchIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _newPage$[ebp]
	mov	edx, DWORD PTR [ecx+eax+5]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertIntoNode@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@IABQAURow@Table@2@HPAU32@1PAUReturnAction@12@@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::InsertIntoNode
	jmp	SHORT $LN21@InsertBran
$LN6@InsertBran:

; 788  : 				}				
; 789  : 			}
; 790  : 		}
; 791  : 		else

	jmp	SHORT $LN3@InsertBran
$LN18@InsertBran:

; 792  : 		{
; 793  : 			if (branchIndex==childIndex+1)

	mov	eax, DWORD PTR _childIndex$[ebp]
	add	eax, 1
	cmp	DWORD PTR _branchIndex$[ebp], eax
	jne	SHORT $LN2@InsertBran

; 794  : 			{
; 795  : 				*success=false;

	mov	eax, DWORD PTR _success$[ebp]
	mov	BYTE PTR [eax], 0

; 796  : 				return 0; // Already exists				

	xor	eax, eax
	jmp	SHORT $LN21@InsertBran

; 797  : 			}
; 798  : 			else

	jmp	SHORT $LN3@InsertBran
$LN2@InsertBran:

; 799  : 			{
; 800  : 				return InsertIntoNode(key, data, branchIndex, 0, cur, returnAction);

	mov	eax, DWORD PTR _returnAction$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _branchIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertIntoNode@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@IABQAURow@Table@2@HPAU32@1PAUReturnAction@12@@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::InsertIntoNode
	jmp	SHORT $LN21@InsertBran
$LN3@InsertBran:

; 801  : 			}
; 802  : 		}
; 803  : 		
; 804  : 		return 0;

	xor	eax, eax
$LN21@InsertBran:

; 805  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN28@InsertBran
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 288				; 00000120H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
	npad	2
$LN28@InsertBran:
	DD	3
	DD	$LN27@InsertBran
$LN27@InsertBran:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN24@InsertBran
	DD	-56					; ffffffc8H
	DD	4
	DD	$LN25@InsertBran
	DD	-92					; ffffffa4H
	DD	4
	DD	$LN26@InsertBran
$LN26@InsertBran:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	0
$LN25@InsertBran:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	0
$LN24@InsertBran:
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	100					; 00000064H
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	0
?InsertBranchDown@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@IABQAURow@Table@2@PAU32@PAUReturnAction@12@PA_N@Z ENDP ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::InsertBranchDown
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?InsertIntoNode@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@IABQAURow@Table@2@HPAU32@1PAUReturnAction@12@@Z
_TEXT	SEGMENT
_b$1 = -89						; size = 1
_i$2 = -80						; size = 4
_i$3 = -68						; size = 4
_sourceIndex$4 = -56					; size = 4
_destIndex$5 = -44					; size = 4
_newPage$6 = -32					; size = 4
_i$ = -20						; size = 4
_this$ = -8						; size = 4
_key$ = 8						; size = 4
_leafData$ = 12						; size = 4
_insertionIndex$ = 16					; size = 4
_nodeData$ = 20						; size = 4
_cur$ = 24						; size = 4
_returnAction$ = 28					; size = 4
?InsertIntoNode@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@IABQAURow@Table@2@HPAU32@1PAUReturnAction@12@@Z PROC ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::InsertIntoNode, COMDAT
; _this$ = ecx

; 496  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 288				; 00000120H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-288]
	mov	ecx, 72					; 00000048H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		int i;
; 498  : 		if (cur->size < order)

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+1], 16			; 00000010H
	jge	$LN58@InsertInto

; 499  : 		{
; 500  : 			for (i=cur->size; i > insertionIndex; i--)

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN57@InsertInto
$LN56@InsertInto:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN57@InsertInto:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _insertionIndex$[ebp]
	jle	SHORT $LN55@InsertInto

; 501  : 				cur->keys[i]=cur->keys[i-1];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+1]
	mov	DWORD PTR [ecx+eax*4+5], edx
	jmp	SHORT $LN56@InsertInto
$LN55@InsertInto:

; 502  : 			if (cur->isLeaf)

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN54@InsertInto

; 503  : 			{
; 504  : 				for (i=cur->size; i > insertionIndex; i--)

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN53@InsertInto
$LN52@InsertInto:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN53@InsertInto:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _insertionIndex$[ebp]
	jle	SHORT $LN51@InsertInto

; 505  : 					cur->data[i]=cur->data[i-1];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+65]
	mov	DWORD PTR [ecx+eax*4+69], edx
	jmp	SHORT $LN52@InsertInto
$LN51@InsertInto:

; 506  : 			}
; 507  : 			else

	jmp	SHORT $LN50@InsertInto
$LN54@InsertInto:

; 508  : 			{
; 509  : 				for (i=cur->size+1; i > insertionIndex+1; i--)

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN49@InsertInto
$LN48@InsertInto:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN49@InsertInto:
	mov	eax, DWORD PTR _insertionIndex$[ebp]
	add	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	jle	SHORT $LN50@InsertInto

; 510  : 					cur->children[i]=cur->children[i-1];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+137]
	mov	DWORD PTR [ecx+eax*4+141], edx
	jmp	SHORT $LN48@InsertInto
$LN50@InsertInto:

; 511  : 			}
; 512  : 			cur->keys[insertionIndex]=key;

	mov	eax, DWORD PTR _insertionIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _key$[ebp]
	mov	DWORD PTR [ecx+eax*4+5], edx

; 513  : 			if (cur->isLeaf)

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN46@InsertInto

; 514  : 				cur->data[insertionIndex]=leafData;

	mov	eax, DWORD PTR _insertionIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _leafData$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+eax*4+69], edx

; 515  : 			else

	jmp	SHORT $LN45@InsertInto
$LN46@InsertInto:

; 516  : 				cur->children[insertionIndex+1]=nodeData;

	mov	eax, DWORD PTR _insertionIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _nodeData$[ebp]
	mov	DWORD PTR [ecx+eax*4+145], edx
$LN45@InsertInto:

; 517  : 
; 518  : 			cur->size++;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	add	ecx, 1
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx+1], ecx

; 519  : 		}
; 520  : 		else

	jmp	$LN44@InsertInto
$LN58@InsertInto:

; 521  : 		{
; 522  : 			Page<KeyType, DataType, order>* newPage = pagePool.Allocate();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Allocate@?$MemoryPool@U?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@XZ ; DataStructures::MemoryPool<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> >::Allocate
	mov	DWORD PTR _newPage$6[ebp], eax

; 523  : 			newPage->isLeaf=cur->isLeaf;

	mov	eax, DWORD PTR _newPage$6[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 524  : 			if (cur->isLeaf)

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN43@InsertInto

; 525  : 			{
; 526  : 				newPage->next=cur->next;

	mov	eax, DWORD PTR _newPage$6[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+133]
	mov	DWORD PTR [eax+133], edx

; 527  : 				if (cur->next)

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+133], 0
	je	SHORT $LN42@InsertInto

; 528  : 					cur->next->previous=newPage;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+133]
	mov	edx, DWORD PTR _newPage$6[ebp]
	mov	DWORD PTR [ecx+137], edx
$LN42@InsertInto:

; 529  : 				newPage->previous=cur;

	mov	eax, DWORD PTR _newPage$6[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax+137], ecx

; 530  : 				cur->next=newPage;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _newPage$6[ebp]
	mov	DWORD PTR [eax+133], ecx
$LN43@InsertInto:

; 531  : 			}
; 532  : 
; 533  : 			int destIndex, sourceIndex;
; 534  : 
; 535  : 			if (insertionIndex>=(order+1)/2)

	cmp	DWORD PTR _insertionIndex$[ebp], 8
	jl	$LN41@InsertInto

; 536  : 			{
; 537  : 				destIndex=0;

	mov	DWORD PTR _destIndex$5[ebp], 0

; 538  : 				sourceIndex=order/2;

	mov	DWORD PTR _sourceIndex$4[ebp], 8

; 539  : 
; 540  : 				for (; sourceIndex < insertionIndex; sourceIndex++, destIndex++)

	jmp	SHORT $LN40@InsertInto
$LN39@InsertInto:
	mov	eax, DWORD PTR _sourceIndex$4[ebp]
	add	eax, 1
	mov	DWORD PTR _sourceIndex$4[ebp], eax
	mov	ecx, DWORD PTR _destIndex$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _destIndex$5[ebp], ecx
$LN40@InsertInto:
	mov	eax, DWORD PTR _sourceIndex$4[ebp]
	cmp	eax, DWORD PTR _insertionIndex$[ebp]
	jge	SHORT $LN38@InsertInto

; 541  : 				{
; 542  : 					newPage->keys[destIndex]=cur->keys[sourceIndex];

	mov	eax, DWORD PTR _destIndex$5[ebp]
	mov	ecx, DWORD PTR _newPage$6[ebp]
	mov	edx, DWORD PTR _sourceIndex$4[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+5]
	mov	DWORD PTR [ecx+eax*4+5], edx

; 543  : 				}

	jmp	SHORT $LN39@InsertInto
$LN38@InsertInto:

; 544  : 				newPage->keys[destIndex++]=key;

	mov	eax, DWORD PTR _destIndex$5[ebp]
	mov	ecx, DWORD PTR _newPage$6[ebp]
	mov	edx, DWORD PTR _key$[ebp]
	mov	DWORD PTR [ecx+eax*4+5], edx
	mov	eax, DWORD PTR _destIndex$5[ebp]
	add	eax, 1
	mov	DWORD PTR _destIndex$5[ebp], eax

; 545  : 				for (; sourceIndex < order; sourceIndex++, destIndex++)

	jmp	SHORT $LN37@InsertInto
$LN36@InsertInto:
	mov	eax, DWORD PTR _sourceIndex$4[ebp]
	add	eax, 1
	mov	DWORD PTR _sourceIndex$4[ebp], eax
	mov	ecx, DWORD PTR _destIndex$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _destIndex$5[ebp], ecx
$LN37@InsertInto:
	cmp	DWORD PTR _sourceIndex$4[ebp], 16	; 00000010H
	jge	SHORT $LN35@InsertInto

; 546  : 				{
; 547  : 					newPage->keys[destIndex]=cur->keys[sourceIndex];

	mov	eax, DWORD PTR _destIndex$5[ebp]
	mov	ecx, DWORD PTR _newPage$6[ebp]
	mov	edx, DWORD PTR _sourceIndex$4[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+5]
	mov	DWORD PTR [ecx+eax*4+5], edx

; 548  : 				}

	jmp	SHORT $LN36@InsertInto
$LN35@InsertInto:

; 549  : 
; 550  : 				destIndex=0;

	mov	DWORD PTR _destIndex$5[ebp], 0

; 551  : 				sourceIndex=order/2;

	mov	DWORD PTR _sourceIndex$4[ebp], 8

; 552  : 				if (cur->isLeaf)

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN34@InsertInto

; 553  : 				{
; 554  : 					for (; sourceIndex < insertionIndex; sourceIndex++, destIndex++)

	jmp	SHORT $LN33@InsertInto
$LN32@InsertInto:
	mov	eax, DWORD PTR _sourceIndex$4[ebp]
	add	eax, 1
	mov	DWORD PTR _sourceIndex$4[ebp], eax
	mov	ecx, DWORD PTR _destIndex$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _destIndex$5[ebp], ecx
$LN33@InsertInto:
	mov	eax, DWORD PTR _sourceIndex$4[ebp]
	cmp	eax, DWORD PTR _insertionIndex$[ebp]
	jge	SHORT $LN31@InsertInto

; 555  : 					{
; 556  : 						newPage->data[destIndex]=cur->data[sourceIndex];

	mov	eax, DWORD PTR _destIndex$5[ebp]
	mov	ecx, DWORD PTR _newPage$6[ebp]
	mov	edx, DWORD PTR _sourceIndex$4[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+69]
	mov	DWORD PTR [ecx+eax*4+69], edx

; 557  : 					}

	jmp	SHORT $LN32@InsertInto
$LN31@InsertInto:

; 558  : 					newPage->data[destIndex++]=leafData;

	mov	eax, DWORD PTR _destIndex$5[ebp]
	mov	ecx, DWORD PTR _newPage$6[ebp]
	mov	edx, DWORD PTR _leafData$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+eax*4+69], edx
	mov	eax, DWORD PTR _destIndex$5[ebp]
	add	eax, 1
	mov	DWORD PTR _destIndex$5[ebp], eax

; 559  : 					for (; sourceIndex < order; sourceIndex++, destIndex++)

	jmp	SHORT $LN30@InsertInto
$LN29@InsertInto:
	mov	eax, DWORD PTR _sourceIndex$4[ebp]
	add	eax, 1
	mov	DWORD PTR _sourceIndex$4[ebp], eax
	mov	ecx, DWORD PTR _destIndex$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _destIndex$5[ebp], ecx
$LN30@InsertInto:
	cmp	DWORD PTR _sourceIndex$4[ebp], 16	; 00000010H
	jge	SHORT $LN28@InsertInto

; 560  : 					{
; 561  : 						newPage->data[destIndex]=cur->data[sourceIndex];

	mov	eax, DWORD PTR _destIndex$5[ebp]
	mov	ecx, DWORD PTR _newPage$6[ebp]
	mov	edx, DWORD PTR _sourceIndex$4[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+69]
	mov	DWORD PTR [ecx+eax*4+69], edx

; 562  : 					}

	jmp	SHORT $LN29@InsertInto
$LN28@InsertInto:

; 563  : 				}
; 564  : 				else

	jmp	$LN27@InsertInto
$LN34@InsertInto:

; 565  : 				{
; 566  : 					
; 567  : 					for (; sourceIndex < insertionIndex; sourceIndex++, destIndex++)

	jmp	SHORT $LN26@InsertInto
$LN25@InsertInto:
	mov	eax, DWORD PTR _sourceIndex$4[ebp]
	add	eax, 1
	mov	DWORD PTR _sourceIndex$4[ebp], eax
	mov	ecx, DWORD PTR _destIndex$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _destIndex$5[ebp], ecx
$LN26@InsertInto:
	mov	eax, DWORD PTR _sourceIndex$4[ebp]
	cmp	eax, DWORD PTR _insertionIndex$[ebp]
	jge	SHORT $LN24@InsertInto

; 568  : 					{
; 569  : 						newPage->children[destIndex]=cur->children[sourceIndex+1];

	mov	eax, DWORD PTR _destIndex$5[ebp]
	mov	ecx, DWORD PTR _newPage$6[ebp]
	mov	edx, DWORD PTR _sourceIndex$4[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+145]
	mov	DWORD PTR [ecx+eax*4+141], edx

; 570  : 					}

	jmp	SHORT $LN25@InsertInto
$LN24@InsertInto:

; 571  : 					newPage->children[destIndex++]=nodeData;

	mov	eax, DWORD PTR _destIndex$5[ebp]
	mov	ecx, DWORD PTR _newPage$6[ebp]
	mov	edx, DWORD PTR _nodeData$[ebp]
	mov	DWORD PTR [ecx+eax*4+141], edx
	mov	eax, DWORD PTR _destIndex$5[ebp]
	add	eax, 1
	mov	DWORD PTR _destIndex$5[ebp], eax

; 572  : 
; 573  : 					// sourceIndex+1 is sort of a hack but it works - because there is one extra child than keys
; 574  : 					// skip past the last child for cur
; 575  : 					for (; sourceIndex+1 < cur->size+1; sourceIndex++, destIndex++)

	jmp	SHORT $LN23@InsertInto
$LN22@InsertInto:
	mov	eax, DWORD PTR _sourceIndex$4[ebp]
	add	eax, 1
	mov	DWORD PTR _sourceIndex$4[ebp], eax
	mov	ecx, DWORD PTR _destIndex$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _destIndex$5[ebp], ecx
$LN23@InsertInto:
	mov	eax, DWORD PTR _sourceIndex$4[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+1]
	add	edx, 1
	cmp	eax, edx
	jge	SHORT $LN21@InsertInto

; 576  : 					{
; 577  : 						newPage->children[destIndex]=cur->children[sourceIndex+1];

	mov	eax, DWORD PTR _destIndex$5[ebp]
	mov	ecx, DWORD PTR _newPage$6[ebp]
	mov	edx, DWORD PTR _sourceIndex$4[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+145]
	mov	DWORD PTR [ecx+eax*4+141], edx

; 578  : 					}

	jmp	SHORT $LN22@InsertInto
$LN21@InsertInto:

; 579  : 
; 580  : 					// the first key is the middle key.  Remove it from the page and push it to the parent
; 581  : 					returnAction->action=ReturnAction::PUSH_KEY_TO_PARENT;

	mov	eax, DWORD PTR _returnAction$[ebp]
	mov	DWORD PTR [eax+8], 2

; 582  : 					returnAction->key1=newPage->keys[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _returnAction$[ebp]
	mov	eax, DWORD PTR _newPage$6[ebp]
	mov	ecx, DWORD PTR [eax+ecx+5]
	mov	DWORD PTR [edx], ecx

; 583  : 					for (int i=0; i < destIndex-1; i++)

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN20@InsertInto
$LN19@InsertInto:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN20@InsertInto:
	mov	eax, DWORD PTR _destIndex$5[ebp]
	sub	eax, 1
	cmp	DWORD PTR _i$3[ebp], eax
	jge	SHORT $LN27@InsertInto

; 584  : 						newPage->keys[i]=newPage->keys[i+1];

	mov	eax, DWORD PTR _i$3[ebp]
	mov	ecx, DWORD PTR _newPage$6[ebp]
	mov	edx, DWORD PTR _i$3[ebp]
	mov	esi, DWORD PTR _newPage$6[ebp]
	mov	edx, DWORD PTR [esi+edx*4+9]
	mov	DWORD PTR [ecx+eax*4+5], edx
	jmp	SHORT $LN19@InsertInto
$LN27@InsertInto:

; 585  : 					
; 586  : 				}
; 587  : 				cur->size=order/2;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax+1], 8

; 588  : 			}
; 589  : 			else

	jmp	$LN17@InsertInto
$LN41@InsertInto:

; 590  : 			{
; 591  : 				destIndex=0;

	mov	DWORD PTR _destIndex$5[ebp], 0

; 592  : 				sourceIndex=(order+1)/2-1;

	mov	DWORD PTR _sourceIndex$4[ebp], 7

; 593  : 				for (; sourceIndex < order; sourceIndex++, destIndex++)

	jmp	SHORT $LN16@InsertInto
$LN15@InsertInto:
	mov	eax, DWORD PTR _sourceIndex$4[ebp]
	add	eax, 1
	mov	DWORD PTR _sourceIndex$4[ebp], eax
	mov	ecx, DWORD PTR _destIndex$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _destIndex$5[ebp], ecx
$LN16@InsertInto:
	cmp	DWORD PTR _sourceIndex$4[ebp], 16	; 00000010H
	jge	SHORT $LN14@InsertInto

; 594  : 					newPage->keys[destIndex]=cur->keys[sourceIndex];

	mov	eax, DWORD PTR _destIndex$5[ebp]
	mov	ecx, DWORD PTR _newPage$6[ebp]
	mov	edx, DWORD PTR _sourceIndex$4[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+5]
	mov	DWORD PTR [ecx+eax*4+5], edx
	jmp	SHORT $LN15@InsertInto
$LN14@InsertInto:

; 595  : 				destIndex=0;

	mov	DWORD PTR _destIndex$5[ebp], 0

; 596  : 				if (cur->isLeaf)

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN13@InsertInto

; 597  : 				{
; 598  : 					sourceIndex=(order+1)/2-1;

	mov	DWORD PTR _sourceIndex$4[ebp], 7

; 599  : 					for (; sourceIndex < order; sourceIndex++, destIndex++)

	jmp	SHORT $LN12@InsertInto
$LN11@InsertInto:
	mov	eax, DWORD PTR _sourceIndex$4[ebp]
	add	eax, 1
	mov	DWORD PTR _sourceIndex$4[ebp], eax
	mov	ecx, DWORD PTR _destIndex$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _destIndex$5[ebp], ecx
$LN12@InsertInto:
	cmp	DWORD PTR _sourceIndex$4[ebp], 16	; 00000010H
	jge	SHORT $LN10@InsertInto

; 600  : 						newPage->data[destIndex]=cur->data[sourceIndex];

	mov	eax, DWORD PTR _destIndex$5[ebp]
	mov	ecx, DWORD PTR _newPage$6[ebp]
	mov	edx, DWORD PTR _sourceIndex$4[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+69]
	mov	DWORD PTR [ecx+eax*4+69], edx
	jmp	SHORT $LN11@InsertInto
$LN10@InsertInto:

; 601  : 				}
; 602  : 				else

	jmp	$LN9@InsertInto
$LN13@InsertInto:

; 603  : 				{
; 604  : 					sourceIndex=(order+1)/2;

	mov	DWORD PTR _sourceIndex$4[ebp], 8

; 605  : 					for (; sourceIndex < order+1; sourceIndex++, destIndex++)

	jmp	SHORT $LN8@InsertInto
$LN7@InsertInto:
	mov	eax, DWORD PTR _sourceIndex$4[ebp]
	add	eax, 1
	mov	DWORD PTR _sourceIndex$4[ebp], eax
	mov	ecx, DWORD PTR _destIndex$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _destIndex$5[ebp], ecx
$LN8@InsertInto:
	cmp	DWORD PTR _sourceIndex$4[ebp], 17	; 00000011H
	jge	SHORT $LN6@InsertInto

; 606  : 						newPage->children[destIndex]=cur->children[sourceIndex];

	mov	eax, DWORD PTR _destIndex$5[ebp]
	mov	ecx, DWORD PTR _newPage$6[ebp]
	mov	edx, DWORD PTR _sourceIndex$4[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+141]
	mov	DWORD PTR [ecx+eax*4+141], edx
	jmp	SHORT $LN7@InsertInto
$LN6@InsertInto:

; 607  : 
; 608  : 					// the first key is the middle key.  Remove it from the page and push it to the parent
; 609  : 					returnAction->action=ReturnAction::PUSH_KEY_TO_PARENT;

	mov	eax, DWORD PTR _returnAction$[ebp]
	mov	DWORD PTR [eax+8], 2

; 610  : 					returnAction->key1=newPage->keys[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _returnAction$[ebp]
	mov	eax, DWORD PTR _newPage$6[ebp]
	mov	ecx, DWORD PTR [eax+ecx+5]
	mov	DWORD PTR [edx], ecx

; 611  : 					for (int i=0; i < destIndex-1; i++)

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN5@InsertInto
$LN4@InsertInto:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN5@InsertInto:
	mov	eax, DWORD PTR _destIndex$5[ebp]
	sub	eax, 1
	cmp	DWORD PTR _i$2[ebp], eax
	jge	SHORT $LN9@InsertInto

; 612  : 						newPage->keys[i]=newPage->keys[i+1];

	mov	eax, DWORD PTR _i$2[ebp]
	mov	ecx, DWORD PTR _newPage$6[ebp]
	mov	edx, DWORD PTR _i$2[ebp]
	mov	esi, DWORD PTR _newPage$6[ebp]
	mov	edx, DWORD PTR [esi+edx*4+9]
	mov	DWORD PTR [ecx+eax*4+5], edx
	jmp	SHORT $LN4@InsertInto
$LN9@InsertInto:

; 613  : 				}
; 614  : 				cur->size=(order+1)/2-1;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax+1], 7

; 615  : 				if (cur->size)

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+1], 0
	je	SHORT $LN2@InsertInto

; 616  : 				{
; 617  : 					bool b = GetIndexOf(key, cur, &insertionIndex);

	lea	eax, DWORD PTR _insertionIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexOf@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IBE_NIPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@PAH@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::GetIndexOf
	mov	BYTE PTR _b$1[ebp], al

; 618  : 					assert(b==false);

	movzx	eax, BYTE PTR _b$1[ebp]
	test	eax, eax
	je	SHORT $LN61@InsertInto
	push	618					; 0000026aH
	push	OFFSET ??_C@_1EO@DHNPHPFC@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAb?$AAp?$AAl?$AAu?$AAs@
	push	OFFSET ??_C@_1BC@GBMFMLDI@?$AAb?$AA?$DN?$AA?$DN?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN61@InsertInto:

; 619  : 				}
; 620  : 				else

	jmp	SHORT $LN1@InsertInto
$LN2@InsertInto:

; 621  : 					insertionIndex=0;

	mov	DWORD PTR _insertionIndex$[ebp], 0
$LN1@InsertInto:

; 622  : 				InsertIntoNode(key, leafData, insertionIndex, nodeData, cur, returnAction);

	mov	eax, DWORD PTR _returnAction$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nodeData$[ebp]
	push	edx
	mov	eax, DWORD PTR _insertionIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _leafData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertIntoNode@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@IABQAURow@Table@2@HPAU32@1PAUReturnAction@12@@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::InsertIntoNode
$LN17@InsertInto:

; 623  : 			}
; 624  : 
; 625  : 			newPage->size=destIndex;

	mov	eax, DWORD PTR _newPage$6[ebp]
	mov	ecx, DWORD PTR _destIndex$5[ebp]
	mov	DWORD PTR [eax+1], ecx

; 626  : 
; 627  : 			return newPage;

	mov	eax, DWORD PTR _newPage$6[ebp]
	jmp	SHORT $LN59@InsertInto
$LN44@InsertInto:

; 628  : 		}
; 629  : 
; 630  : 		return 0;

	xor	eax, eax
$LN59@InsertInto:

; 631  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 288				; 00000120H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?InsertIntoNode@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@IABQAURow@Table@2@HPAU32@1PAUReturnAction@12@@Z ENDP ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::InsertIntoNode
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?RotateLeft@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEXPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@HPAUReturnAction@12@@Z
_TEXT	SEGMENT
_i$1 = -44						; size = 4
_source$ = -32						; size = 4
_dest$ = -20						; size = 4
_this$ = -8						; size = 4
_cur$ = 8						; size = 4
_childIndex$ = 12					; size = 4
_returnAction$ = 16					; size = 4
?RotateLeft@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEXPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@HPAUReturnAction@12@@Z PROC ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::RotateLeft, COMDAT
; _this$ = ecx

; 641  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		Page<KeyType, DataType, order> *dest = cur->children[childIndex-1];

	mov	eax, DWORD PTR _childIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+137]
	mov	DWORD PTR _dest$[ebp], edx

; 643  : 		Page<KeyType, DataType, order> *source = cur->children[childIndex];

	mov	eax, DWORD PTR _childIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+141]
	mov	DWORD PTR _source$[ebp], edx

; 644  : 		returnAction->key1=source->keys[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _returnAction$[ebp]
	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+5]
	mov	DWORD PTR [edx], ecx

; 645  : 		dest->keys[dest->size]=source->keys[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR [edx+1]
	mov	edx, DWORD PTR _dest$[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+5]
	mov	DWORD PTR [edx+eax*4+5], ecx

; 646  : 		dest->data[dest->size]=source->data[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _dest$[ebp]
	mov	eax, DWORD PTR [edx+1]
	mov	edx, DWORD PTR _dest$[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+69]
	mov	DWORD PTR [edx+eax*4+69], ecx

; 647  : 		dest->size++;

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	add	ecx, 1
	mov	edx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR [edx+1], ecx

; 648  : 		for (int i=0; i < source->size-1; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN3@RotateLeft
$LN2@RotateLeft:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN3@RotateLeft:
	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	sub	ecx, 1
	cmp	DWORD PTR _i$1[ebp], ecx
	jge	SHORT $LN1@RotateLeft

; 649  : 		{
; 650  : 			source->keys[i]=source->keys[i+1];

	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _source$[ebp]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+9]
	mov	DWORD PTR [ecx+eax*4+5], edx

; 651  : 			source->data[i]=source->data[i+1];

	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _source$[ebp]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+73]
	mov	DWORD PTR [ecx+eax*4+69], edx

; 652  : 		}

	jmp	SHORT $LN2@RotateLeft
$LN1@RotateLeft:

; 653  : 		source->size--;

	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	sub	ecx, 1
	mov	edx, DWORD PTR _source$[ebp]
	mov	DWORD PTR [edx+1], ecx

; 654  : 		cur->keys[childIndex-1]=source->keys[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _childIndex$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+5]
	mov	DWORD PTR [eax+edx*4+1], ecx

; 655  : 		returnAction->key2=source->keys[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _returnAction$[ebp]
	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+5]
	mov	DWORD PTR [edx+4], ecx

; 656  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?RotateLeft@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEXPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@HPAUReturnAction@12@@Z ENDP ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::RotateLeft
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?RotateRight@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEXPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@HPAUReturnAction@12@@Z
_TEXT	SEGMENT
_i$1 = -44						; size = 4
_source$ = -32						; size = 4
_dest$ = -20						; size = 4
_this$ = -8						; size = 4
_cur$ = 8						; size = 4
_childIndex$ = 12					; size = 4
_returnAction$ = 16					; size = 4
?RotateRight@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEXPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@HPAUReturnAction@12@@Z PROC ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::RotateRight, COMDAT
; _this$ = ecx

; 666  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 667  : 		Page<KeyType, DataType, order> *dest = cur->children[childIndex+1];

	mov	eax, DWORD PTR _childIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+145]
	mov	DWORD PTR _dest$[ebp], edx

; 668  : 		Page<KeyType, DataType, order> *source = cur->children[childIndex];

	mov	eax, DWORD PTR _childIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+141]
	mov	DWORD PTR _source$[ebp], edx

; 669  : 		returnAction->key1=dest->keys[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _returnAction$[ebp]
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+5]
	mov	DWORD PTR [edx], ecx

; 670  : 		for (int i= dest->size; i > 0; i--)

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR _i$1[ebp], ecx
	jmp	SHORT $LN3@RotateRigh
$LN2@RotateRigh:
	mov	eax, DWORD PTR _i$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN3@RotateRigh:
	cmp	DWORD PTR _i$1[ebp], 0
	jle	SHORT $LN1@RotateRigh

; 671  : 		{
; 672  : 			dest->keys[i]=dest->keys[i-1];

	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+1]
	mov	DWORD PTR [ecx+eax*4+5], edx

; 673  : 			dest->data[i]=dest->data[i-1];

	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	esi, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+65]
	mov	DWORD PTR [ecx+eax*4+69], edx

; 674  : 		}

	jmp	SHORT $LN2@RotateRigh
$LN1@RotateRigh:

; 675  : 		dest->keys[0]=source->keys[source->size-1];

	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dest$[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4+1]
	mov	DWORD PTR [edx+eax+5], ecx

; 676  : 		dest->data[0]=source->data[source->size-1];

	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _dest$[ebp]
	mov	esi, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4+65]
	mov	DWORD PTR [edx+eax+69], ecx

; 677  : 		dest->size++;

	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	add	ecx, 1
	mov	edx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR [edx+1], ecx

; 678  : 		source->size--;

	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	sub	ecx, 1
	mov	edx, DWORD PTR _source$[ebp]
	mov	DWORD PTR [edx+1], ecx

; 679  : 
; 680  : 		cur->keys[childIndex]=dest->keys[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _childIndex$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	esi, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+5]
	mov	DWORD PTR [eax+edx*4+5], ecx

; 681  : 		returnAction->key2=dest->keys[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _returnAction$[ebp]
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+5]
	mov	DWORD PTR [edx+4], ecx

; 682  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?RotateRight@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEXPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@HPAUReturnAction@12@@Z ENDP ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::RotateRight
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?CanRotateRight@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAE_NPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@H@Z
_TEXT	SEGMENT
tv72 = -208						; size = 4
_this$ = -8						; size = 4
_cur$ = 8						; size = 4
_childIndex$ = 12					; size = 4
?CanRotateRight@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAE_NPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@H@Z PROC ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::CanRotateRight, COMDAT
; _this$ = ecx

; 660  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return childIndex < cur->size && cur->children[childIndex+1]->size<order;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _childIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+1]
	jge	SHORT $LN3@CanRotateR
	mov	edx, DWORD PTR _childIndex$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+145]
	cmp	DWORD PTR [ecx+1], 16			; 00000010H
	jge	SHORT $LN3@CanRotateR
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN4@CanRotateR
$LN3@CanRotateR:
	mov	DWORD PTR tv72[ebp], 0
$LN4@CanRotateR:
	mov	al, BYTE PTR tv72[ebp]

; 662  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?CanRotateRight@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAE_NPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@H@Z ENDP ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::CanRotateRight
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?CanRotateLeft@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAE_NPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@H@Z
_TEXT	SEGMENT
tv71 = -208						; size = 4
_this$ = -8						; size = 4
_cur$ = 8						; size = 4
_childIndex$ = 12					; size = 4
?CanRotateLeft@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAE_NPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@H@Z PROC ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::CanRotateLeft, COMDAT
; _this$ = ecx

; 635  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 636  : 		return childIndex>0 && cur->children[childIndex-1]->size<order;

	cmp	DWORD PTR _childIndex$[ebp], 0
	jle	SHORT $LN3@CanRotateL
	mov	eax, DWORD PTR _childIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+137]
	cmp	DWORD PTR [edx+1], 16			; 00000010H
	jge	SHORT $LN3@CanRotateL
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN4@CanRotateL
$LN3@CanRotateL:
	mov	DWORD PTR tv71[ebp], 0
$LN4@CanRotateL:
	mov	al, BYTE PTR tv71[ebp]

; 637  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?CanRotateLeft@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAE_NPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@H@Z ENDP ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::CanRotateLeft
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?GetIndexOf@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IBE_NIPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@PAH@Z
_TEXT	SEGMENT
_lowerBound$ = -44					; size = 4
_upperBound$ = -32					; size = 4
_index$ = -20						; size = 4
_this$ = -8						; size = 4
_key$ = 8						; size = 4
_page$ = 12						; size = 4
_out$ = 16						; size = 4
?GetIndexOf@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IBE_NIPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@PAH@Z PROC ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::GetIndexOf, COMDAT
; _this$ = ecx

; 895  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 896  : 		assert(page->size>0);

	mov	eax, DWORD PTR _page$[ebp]
	cmp	DWORD PTR [eax+1], 0
	jg	SHORT $LN10@GetIndexOf
	push	896					; 00000380H
	push	OFFSET ??_C@_1EO@DHNPHPFC@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAb?$AAp?$AAl?$AAu?$AAs@
	push	OFFSET ??_C@_1BK@CAFOCCOP@?$AAp?$AAa?$AAg?$AAe?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$DO?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN10@GetIndexOf:

; 897  : 		int index, upperBound, lowerBound;
; 898  : 		upperBound=page->size-1;

	mov	eax, DWORD PTR _page$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	sub	ecx, 1
	mov	DWORD PTR _upperBound$[ebp], ecx

; 899  : 		lowerBound=0;

	mov	DWORD PTR _lowerBound$[ebp], 0

; 900  : 		index = page->size/2;

	mov	eax, DWORD PTR _page$[ebp]
	mov	eax, DWORD PTR [eax+1]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _index$[ebp], eax
$LN7@GetIndexOf:

; 901  : 
; 902  : #ifdef _MSC_VER
; 903  : #pragma warning( disable : 4127 ) // warning C4127: conditional expression is constant
; 904  : #endif
; 905  : 		while (1)

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN8@GetIndexOf

; 906  : 		{
; 907  : 			if (key==page->keys[index])

	mov	eax, DWORD PTR _index$[ebp]
	mov	ecx, DWORD PTR _page$[ebp]
	mov	edx, DWORD PTR _key$[ebp]
	cmp	edx, DWORD PTR [ecx+eax*4+5]
	jne	SHORT $LN5@GetIndexOf

; 908  : 			{
; 909  : 				*out=index;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	mov	DWORD PTR [eax], ecx

; 910  : 				return true;

	mov	al, 1
	jmp	SHORT $LN8@GetIndexOf
	jmp	SHORT $LN4@GetIndexOf
$LN5@GetIndexOf:

; 911  : 			}
; 912  : 			else if (key<page->keys[index])

	mov	eax, DWORD PTR _index$[ebp]
	mov	ecx, DWORD PTR _page$[ebp]
	mov	edx, DWORD PTR _key$[ebp]
	cmp	edx, DWORD PTR [ecx+eax*4+5]
	jae	SHORT $LN3@GetIndexOf

; 913  : 				upperBound=index-1;

	mov	eax, DWORD PTR _index$[ebp]
	sub	eax, 1
	mov	DWORD PTR _upperBound$[ebp], eax

; 914  : 			else

	jmp	SHORT $LN4@GetIndexOf
$LN3@GetIndexOf:

; 915  : 				lowerBound=index+1;

	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 1
	mov	DWORD PTR _lowerBound$[ebp], eax
$LN4@GetIndexOf:

; 916  : 
; 917  : 			index=lowerBound+(upperBound-lowerBound)/2;

	mov	eax, DWORD PTR _upperBound$[ebp]
	sub	eax, DWORD PTR _lowerBound$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _lowerBound$[ebp]
	mov	DWORD PTR _index$[ebp], eax

; 918  : 
; 919  : 			if (lowerBound>upperBound)

	mov	eax, DWORD PTR _lowerBound$[ebp]
	cmp	eax, DWORD PTR _upperBound$[ebp]
	jle	SHORT $LN1@GetIndexOf

; 920  : 			{
; 921  : 				*out=lowerBound;

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _lowerBound$[ebp]
	mov	DWORD PTR [eax], ecx

; 922  : 				return false; // No match

	xor	al, al
	jmp	SHORT $LN8@GetIndexOf
$LN1@GetIndexOf:

; 923  : 			}
; 924  : 		}

	jmp	SHORT $LN7@GetIndexOf
$LN8@GetIndexOf:

; 925  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetIndexOf@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IBE_NIPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@PAH@Z ENDP ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::GetIndexOf
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?FreePages@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEXXZ
_TEXT	SEGMENT
_i$ = -68						; size = 4
_ptr$ = -56						; size = 4
_queue$ = -44						; size = 16
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?FreePages@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEXXZ PROC ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::FreePages, COMDAT
; _this$ = ecx

; 928  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?FreePages@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 929  : 		DataStructures::Queue<DataStructures::Page<KeyType, DataType, order> *> queue;

	lea	ecx, DWORD PTR _queue$[ebp]
	call	??0?$Queue@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::Queue<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::Queue<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 930  : 		DataStructures::Page<KeyType, DataType, order> *ptr;
; 931  : 		int i;
; 932  : 		queue.Push(root);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR _queue$[ebp]
	call	?Push@?$Queue@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAEXABQAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@@Z ; DataStructures::Queue<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::Push
$LN6@FreePages:

; 933  : 		while (queue.Size())

	lea	ecx, DWORD PTR _queue$[ebp]
	call	?Size@?$Queue@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::Queue<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::Size
	test	eax, eax
	je	SHORT $LN5@FreePages

; 934  : 		{
; 935  : 			ptr=queue.Pop();

	lea	ecx, DWORD PTR _queue$[ebp]
	call	?Pop@?$Queue@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@XZ ; DataStructures::Queue<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::Pop
	mov	DWORD PTR _ptr$[ebp], eax

; 936  : 			if (ptr->isLeaf==false)

	mov	eax, DWORD PTR _ptr$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN4@FreePages

; 937  : 			{
; 938  : 				for (i=0; i < ptr->size+1; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@FreePages
$LN2@FreePages:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@FreePages:
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	add	ecx, 1
	cmp	DWORD PTR _i$[ebp], ecx
	jge	SHORT $LN4@FreePages

; 939  : 					queue.Push(ptr->children[i]);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _ptr$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4+141]
	push	edx
	lea	ecx, DWORD PTR _queue$[ebp]
	call	?Push@?$Queue@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAEXABQAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@@Z ; DataStructures::Queue<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::Push
	jmp	SHORT $LN2@FreePages
$LN4@FreePages:

; 940  : 			}			
; 941  : 			pagePool.Release(ptr);

	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Release@?$MemoryPool@U?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAEXPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@@Z ; DataStructures::MemoryPool<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> >::Release

; 942  : 			memset(ptr,0,sizeof(root));

	push	4
	push	0
	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 943  : 		};

	jmp	SHORT $LN6@FreePages
$LN5@FreePages:

; 944  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _queue$[ebp]
	call	??1?$Queue@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::Queue<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::~Queue<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN13@FreePages
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN13@FreePages:
	DD	1
	DD	$LN12@FreePages
$LN12@FreePages:
	DD	-44					; ffffffd4H
	DD	16					; 00000010H
	DD	$LN10@FreePages
$LN10@FreePages:
	DB	113					; 00000071H
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FreePages@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEXXZ$0:
	lea	ecx, DWORD PTR _queue$[ebp]
	jmp	??1?$Queue@PAU?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::Queue<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>::~Queue<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> *>
__ehhandler$?FreePages@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-268]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?FreePages@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?FreePages@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEXXZ ENDP ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::FreePages
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?DeleteFromPageAtIndex@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEXHPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@@Z
_TEXT	SEGMENT
_i$ = -20						; size = 4
_this$ = -8						; size = 4
_index$ = 8						; size = 4
_cur$ = 12						; size = 4
?DeleteFromPageAtIndex@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEXHPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@@Z PROC ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::DeleteFromPageAtIndex, COMDAT
; _this$ = ecx

; 139  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		int i;
; 141  : 		for (i=index; i < cur->size-1; i++)

	mov	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN11@DeleteFrom
$LN10@DeleteFrom:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN11@DeleteFrom:
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	sub	ecx, 1
	cmp	DWORD PTR _i$[ebp], ecx
	jge	SHORT $LN9@DeleteFrom

; 142  : 			cur->keys[i]=cur->keys[i+1];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+9]
	mov	DWORD PTR [ecx+eax*4+5], edx
	jmp	SHORT $LN10@DeleteFrom
$LN9@DeleteFrom:

; 143  : 		if (cur->isLeaf)

	mov	eax, DWORD PTR _cur$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN8@DeleteFrom

; 144  : 		{
; 145  : 			for (i=index; i < cur->size-1; i++)

	mov	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN7@DeleteFrom
$LN6@DeleteFrom:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@DeleteFrom:
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	sub	ecx, 1
	cmp	DWORD PTR _i$[ebp], ecx
	jge	SHORT $LN5@DeleteFrom

; 146  : 				cur->data[i]=cur->data[i+1];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+73]
	mov	DWORD PTR [ecx+eax*4+69], edx
	jmp	SHORT $LN6@DeleteFrom
$LN5@DeleteFrom:

; 147  : 		}
; 148  : 		else

	jmp	SHORT $LN4@DeleteFrom
$LN8@DeleteFrom:

; 149  : 		{
; 150  : 			for (i=index; i < cur->size-1; i++)

	mov	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN3@DeleteFrom
$LN2@DeleteFrom:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@DeleteFrom:
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	sub	ecx, 1
	cmp	DWORD PTR _i$[ebp], ecx
	jge	SHORT $LN4@DeleteFrom

; 151  : 				cur->children[i+1]=cur->children[i+2];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+149]
	mov	DWORD PTR [ecx+eax*4+145], edx
	jmp	SHORT $LN2@DeleteFrom
$LN4@DeleteFrom:

; 152  : 		}
; 153  : 		cur->size--;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	sub	ecx, 1
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx+1], ecx

; 154  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?DeleteFromPageAtIndex@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEXHPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@@Z ENDP ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::DeleteFromPageAtIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?ForEachData@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAEXP6AXPAURow@Table@2@H@Z@Z
_TEXT	SEGMENT
tv71 = -244						; size = 4
_cur$ = -44						; size = 4
_i$ = -32						; size = 4
_count$ = -20						; size = 4
_this$ = -8						; size = 4
_func$ = 8						; size = 4
?ForEachData@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAEXP6AXPAURow@Table@2@H@Z@Z PROC ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::ForEachData, COMDAT
; _this$ = ecx

; 968  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 969  : 		int count=0,i;

	mov	DWORD PTR _count$[ebp], 0

; 970  : 		DataStructures::Page<KeyType, DataType, order> *cur = GetListHead();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetListHead@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QBEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@XZ ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::GetListHead
	mov	DWORD PTR _cur$[ebp], eax
$LN5@ForEachDat:

; 971  : 		while (cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN6@ForEachDat

; 972  : 		{
; 973  : 			for (i=0; i < cur->size; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@ForEachDat
$LN2@ForEachDat:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@ForEachDat:
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+1]
	jge	SHORT $LN1@ForEachDat

; 974  : 				func(cur->data[i], count++);

	mov	eax, DWORD PTR _count$[ebp]
	mov	DWORD PTR tv71[ebp], eax
	mov	ecx, DWORD PTR _count$[ebp]
	add	ecx, 1
	mov	DWORD PTR _count$[ebp], ecx
	mov	esi, esp
	mov	edx, DWORD PTR tv71[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+69]
	push	edx
	call	DWORD PTR _func$[ebp]
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN2@ForEachDat
$LN1@ForEachDat:

; 975  : 			cur=cur->next;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+133]
	mov	DWORD PTR _cur$[ebp], ecx

; 976  : 		}

	jmp	SHORT $LN5@ForEachDat
$LN6@ForEachDat:

; 977  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?ForEachData@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAEXP6AXPAURow@Table@2@H@Z@Z ENDP ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::ForEachData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?GetListHead@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QBEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetListHead@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QBEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@XZ PROC ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::GetListHead, COMDAT
; _this$ = ecx

; 947  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 948  : 		return leftmostLeaf;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]

; 949  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetListHead@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QBEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@XZ ENDP ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::GetListHead
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?Size@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_cur$ = -32						; size = 4
_count$ = -20						; size = 4
_this$ = -8						; size = 4
?Size@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QBEIXZ PROC ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::Size, COMDAT
; _this$ = ecx

; 878  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 879  : 		int count=0;

	mov	DWORD PTR _count$[ebp], 0

; 880  : 		DataStructures::Page<KeyType, DataType, order> *cur = GetListHead();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetListHead@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QBEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@XZ ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::GetListHead
	mov	DWORD PTR _cur$[ebp], eax
$LN2@Size:

; 881  : 		while (cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN1@Size

; 882  : 		{
; 883  : 			count+=cur->size;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	add	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR _count$[ebp], ecx

; 884  : 			cur=cur->next;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+133]
	mov	DWORD PTR _cur$[ebp], ecx

; 885  : 		}

	jmp	SHORT $LN2@Size
$LN1@Size:

; 886  : 		return count;

	mov	eax, DWORD PTR _count$[ebp]

; 887  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QBEIXZ ENDP ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?Clear@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Clear@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAEXXZ PROC ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::Clear, COMDAT
; _this$ = ecx

; 868  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 869  : 		if (root)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN2@Clear

; 870  : 		{
; 871  : 			FreePages();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreePages@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEXXZ ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::FreePages

; 872  : 			leftmostLeaf=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 873  : 			root=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0
$LN2@Clear:

; 874  : 		}
; 875  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAEXXZ ENDP ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?Insert@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAE_NIABQAURow@Table@2@@Z
_TEXT	SEGMENT
_newRoot$1 = -80					; size = 4
_newKey$2 = -68						; size = 4
_newPage$3 = -56					; size = 4
_returnAction$4 = -44					; size = 12
_success$5 = -21					; size = 1
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_key$ = 8						; size = 4
_data$ = 12						; size = 4
?Insert@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAE_NIABQAURow@Table@2@@Z PROC ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::Insert, COMDAT
; _this$ = ecx

; 808  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-276]
	mov	ecx, 69					; 00000045H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 809  : 		if (root==0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	$LN6@Insert

; 810  : 		{
; 811  : 			// Allocate root and make root a leaf
; 812  : 			root = pagePool.Allocate();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Allocate@?$MemoryPool@U?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@XZ ; DataStructures::MemoryPool<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> >::Allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 813  : 			root->isLeaf=true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	BYTE PTR [ecx], 1

; 814  : 			leftmostLeaf=root;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+20], edx

; 815  : 			root->size=1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+1], 1

; 816  : 			root->keys[0]=key;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _key$[ebp]
	mov	DWORD PTR [ecx+eax+5], edx

; 817  : 			root->data[0]=data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _data$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+eax+69], edx

; 818  : 			root->next=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+133], 0

; 819  : 			root->previous=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+137], 0

; 820  : 		}
; 821  : 		else

	jmp	$LN5@Insert
$LN6@Insert:

; 822  : 		{
; 823  : 			bool success=true;

	mov	BYTE PTR _success$5[ebp], 1

; 824  : 			ReturnAction returnAction;
; 825  : 			returnAction.action=ReturnAction::NO_ACTION;

	mov	DWORD PTR _returnAction$4[ebp+8], 0

; 826  : 			Page<KeyType, DataType, order>* newPage = InsertBranchDown(key, data, root, &returnAction, &success);

	lea	eax, DWORD PTR _success$5[ebp]
	push	eax
	lea	ecx, DWORD PTR _returnAction$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertBranchDown@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@IABQAURow@Table@2@PAU32@PAUReturnAction@12@PA_N@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::InsertBranchDown
	mov	DWORD PTR _newPage$3[ebp], eax

; 827  : 			if (success==false)

	movzx	eax, BYTE PTR _success$5[ebp]
	test	eax, eax
	jne	SHORT $LN4@Insert

; 828  : 				return false;

	xor	al, al
	jmp	$LN7@Insert
$LN4@Insert:

; 829  : 			if (newPage)

	cmp	DWORD PTR _newPage$3[ebp], 0
	je	$LN5@Insert

; 830  : 			{
; 831  : 				KeyType newKey;
; 832  : 				if (newPage->isLeaf==false)

	mov	eax, DWORD PTR _newPage$3[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@Insert

; 833  : 				{
; 834  : 					// One key is pushed up through the stack.  I store that at keys[0] but it has to be removed for the page to be correct
; 835  : 					assert(returnAction.action==ReturnAction::PUSH_KEY_TO_PARENT);

	cmp	DWORD PTR _returnAction$4[ebp+8], 2
	je	SHORT $LN9@Insert
	push	835					; 00000343H
	push	OFFSET ??_C@_1EO@DHNPHPFC@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAb?$AAp?$AAl?$AAu?$AAs@
	push	OFFSET ??_C@_1GM@PECFPFGO@?$AAr?$AAe?$AAt?$AAu?$AAr?$AAn?$AAA?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?4?$AAa?$AAc?$AAt?$AAi?$AAo?$AAn?$AA?$DN?$AA?$DN?$AAR?$AAe?$AAt?$AAu?$AAr?$AAn?$AAA?$AAc?$AAt?$AAi?$AAo@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN9@Insert:

; 836  : 					newKey=returnAction.key1;

	mov	eax, DWORD PTR _returnAction$4[ebp]
	mov	DWORD PTR _newKey$2[ebp], eax

; 837  : 					newPage->size--;

	mov	eax, DWORD PTR _newPage$3[ebp]
	mov	ecx, DWORD PTR [eax+1]
	sub	ecx, 1
	mov	edx, DWORD PTR _newPage$3[ebp]
	mov	DWORD PTR [edx+1], ecx

; 838  : 				}
; 839  : 				else

	jmp	SHORT $LN1@Insert
$LN2@Insert:

; 840  : 					 newKey = newPage->keys[0];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _newPage$3[ebp]
	mov	eax, DWORD PTR [edx+ecx+5]
	mov	DWORD PTR _newKey$2[ebp], eax
$LN1@Insert:

; 841  : 				// propagate the root
; 842  : 				Page<KeyType, DataType, order>* newRoot = pagePool.Allocate();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Allocate@?$MemoryPool@U?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@XZ ; DataStructures::MemoryPool<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> >::Allocate
	mov	DWORD PTR _newRoot$1[ebp], eax

; 843  : 				newRoot->isLeaf=false;

	mov	eax, DWORD PTR _newRoot$1[ebp]
	mov	BYTE PTR [eax], 0

; 844  : 				newRoot->size=1;

	mov	eax, DWORD PTR _newRoot$1[ebp]
	mov	DWORD PTR [eax+1], 1

; 845  : 				newRoot->keys[0]=newKey;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _newRoot$1[ebp]
	mov	eax, DWORD PTR _newKey$2[ebp]
	mov	DWORD PTR [edx+ecx+5], eax

; 846  : 				newRoot->children[0]=root;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _newRoot$1[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+ecx+141], eax

; 847  : 				newRoot->children[1]=newPage;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _newRoot$1[ebp]
	mov	edx, DWORD PTR _newPage$3[ebp]
	mov	DWORD PTR [ecx+eax+141], edx

; 848  : 				root=newRoot;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newRoot$1[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN5@Insert:

; 849  : 			}
; 850  : 		}
; 851  : 
; 852  : 		return true;

	mov	al, 1
$LN7@Insert:

; 853  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN13@Insert
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN13@Insert:
	DD	2
	DD	$LN12@Insert
$LN12@Insert:
	DD	-21					; ffffffebH
	DD	1
	DD	$LN10@Insert
	DD	-44					; ffffffd4H
	DD	12					; 0000000cH
	DD	$LN11@Insert
$LN11@Insert:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	110					; 0000006eH
	DB	65					; 00000041H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
$LN10@Insert:
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	99					; 00000063H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	115					; 00000073H
	DB	0
?Insert@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAE_NIABQAURow@Table@2@@Z ENDP ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::Insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?Delete@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAE_NIAAPAURow@Table@2@@Z
_TEXT	SEGMENT
_oldRoot$1 = -68					; size = 4
_underflow$ = -53					; size = 1
_childIndex$ = -44					; size = 4
_returnAction$ = -32					; size = 12
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_key$ = 8						; size = 4
_out$ = 12						; size = 4
?Delete@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAE_NIAAPAURow@Table@2@@Z PROC ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::Delete, COMDAT
; _this$ = ecx

; 163  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 164  : 		if (root==0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN7@Delete

; 165  : 			return false;

	xor	al, al
	jmp	$LN8@Delete
$LN7@Delete:

; 166  : 
; 167  : 		ReturnAction returnAction;
; 168  : 		returnAction.action=ReturnAction::NO_ACTION;

	mov	DWORD PTR _returnAction$[ebp+8], 0

; 169  : 		int childIndex;
; 170  : 		bool underflow=false;

	mov	BYTE PTR _underflow$[ebp], 0

; 171  : 		if (root==leftmostLeaf)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+16]
	cmp	edx, DWORD PTR [ecx+20]
	jne	$LN6@Delete

; 172  : 		{
; 173  : 			if (GetIndexOf(key, root, &childIndex)==false)

	lea	eax, DWORD PTR _childIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexOf@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IBE_NIPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@PAH@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::GetIndexOf
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN5@Delete

; 174  : 				return false;

	xor	al, al
	jmp	$LN8@Delete
$LN5@Delete:

; 175  : 			out=root->data[childIndex];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR _childIndex$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+69]
	mov	DWORD PTR [edx], ecx

; 176  : 			DeleteFromPageAtIndex(childIndex,root);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _childIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DeleteFromPageAtIndex@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAEXHPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::DeleteFromPageAtIndex

; 177  : 			if (root->size==0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx+1], 0
	jne	SHORT $LN4@Delete

; 178  : 			{
; 179  : 				pagePool.Release(root);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Release@?$MemoryPool@U?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAEXPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@@Z ; DataStructures::MemoryPool<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> >::Release

; 180  : 				memset(root,0,sizeof(root));

	push	4
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 181  : 				root=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 182  : 				leftmostLeaf=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0
$LN4@Delete:

; 183  : 			}
; 184  : 			return true;

	mov	al, 1
	jmp	$LN8@Delete
	jmp	SHORT $LN3@Delete
$LN6@Delete:

; 185  : 		}
; 186  : 		else if (FindDeleteRebalance(key, root, &underflow,root->keys[0], &returnAction, out)==false)

	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	lea	ecx, DWORD PTR _returnAction$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR [eax+edx+5]
	push	eax
	lea	ecx, DWORD PTR _underflow$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindDeleteRebalance@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IAE_NIPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@PA_NIPAUReturnAction@12@AAPAURow@Table@2@@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::FindDeleteRebalance
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@Delete

; 187  : 			return false;

	xor	al, al
	jmp	SHORT $LN8@Delete
$LN3@Delete:

; 188  : 
; 189  : //		assert(returnAction.action==ReturnAction::NO_ACTION);
; 190  : 
; 191  : 		if (underflow && root->size==0)

	movzx	eax, BYTE PTR _underflow$[ebp]
	test	eax, eax
	je	SHORT $LN1@Delete
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx+1], 0
	jne	SHORT $LN1@Delete

; 192  : 		{
; 193  : 			// Move the root down.
; 194  : 			Page<KeyType, DataType, order> *oldRoot=root;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _oldRoot$1[ebp], ecx

; 195  : 			root=root->children[0];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, 4
	imul	eax, edx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax+141]
	mov	DWORD PTR [edx+16], eax

; 196  : 			pagePool.Release(oldRoot);

	mov	eax, DWORD PTR _oldRoot$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Release@?$MemoryPool@U?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAEXPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@@Z ; DataStructures::MemoryPool<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> >::Release

; 197  : 			memset(oldRoot,0,sizeof(root));

	push	4
	push	0
	mov	eax, DWORD PTR _oldRoot$1[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN1@Delete:

; 198  : 		}		
; 199  : 	
; 200  : 		return true;

	mov	al, 1
$LN8@Delete:

; 201  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN14@Delete
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN14@Delete:
	DD	3
	DD	$LN13@Delete
$LN13@Delete:
	DD	-32					; ffffffe0H
	DD	12					; 0000000cH
	DD	$LN10@Delete
	DD	-44					; ffffffd4H
	DD	4
	DD	$LN11@Delete
	DD	-53					; ffffffcbH
	DD	1
	DD	$LN12@Delete
$LN12@Delete:
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	102					; 00000066H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	119					; 00000077H
	DB	0
$LN11@Delete:
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	100					; 00000064H
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	0
$LN10@Delete:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	110					; 0000006eH
	DB	65					; 00000041H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
?Delete@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAE_NIAAPAURow@Table@2@@Z ENDP ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::Delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?Delete@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAE_NI@Z
_TEXT	SEGMENT
_temp$ = -20						; size = 4
_this$ = -8						; size = 4
_key$ = 8						; size = 4
?Delete@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAE_NI@Z PROC ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::Delete, COMDAT
; _this$ = ecx

; 157  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 158  : 		DataType temp;
; 159  : 		return Delete(key, temp);

	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Delete@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAE_NIAAPAURow@Table@2@@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::Delete

; 160  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Delete
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN5@Delete:
	DD	1
	DD	$LN4@Delete
$LN4@Delete:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN3@Delete
$LN3@Delete:
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
?Delete@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAE_NI@Z ENDP ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::Delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ?Get@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QBE_NIAAPAURow@Table@2@@Z
_TEXT	SEGMENT
_childIndex$ = -32					; size = 4
_leaf$ = -20						; size = 4
_this$ = -8						; size = 4
_key$ = 8						; size = 4
_out$ = 12						; size = 4
?Get@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QBE_NIAAPAURow@Table@2@@Z PROC ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::Get, COMDAT
; _this$ = ecx

; 123  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		if (root==0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN2@Get

; 125  : 			return false;

	xor	al, al
	jmp	SHORT $LN3@Get
$LN2@Get:

; 126  : 
; 127  : 		Page<KeyType, DataType, order>* leaf = GetLeafFromKey(key);

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLeafFromKey@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IBEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@I@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::GetLeafFromKey
	mov	DWORD PTR _leaf$[ebp], eax

; 128  : 		int childIndex;
; 129  : 		
; 130  : 		if (GetIndexOf(key, leaf, &childIndex))

	lea	eax, DWORD PTR _childIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _leaf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexOf@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@IBE_NIPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@PAH@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::GetIndexOf
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@Get

; 131  : 		{
; 132  : 			out=leaf->data[childIndex];

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _childIndex$[ebp]
	mov	edx, DWORD PTR _leaf$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+69]
	mov	DWORD PTR [eax], ecx

; 133  : 			return true;

	mov	al, 1
	jmp	SHORT $LN3@Get
$LN1@Get:

; 134  : 		}
; 135  : 		return false;

	xor	al, al
$LN3@Get:

; 136  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@Get
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN7@Get:
	DD	1
	DD	$LN6@Get
$LN6@Get:
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN5@Get
$LN5@Get:
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	100					; 00000064H
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	0
?Get@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QBE_NIAAPAURow@Table@2@@Z ENDP ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::Get
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ??1?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAE@XZ PROC ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::~BPlusTree<unsigned int,DataStructures::Table::Row *,16>, COMDAT
; _this$ = ecx

; 118  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 119  : 		Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAEXXZ ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::Clear

; 120  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$MemoryPool@U?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::MemoryPool<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> >::~MemoryPool<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$MemoryPool@U?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::MemoryPool<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> >::~MemoryPool<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> >
__ehhandler$??1?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAE@XZ ENDP ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::~BPlusTree<unsigned int,DataStructures::Table::Row *,16>
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_bplustree.h
;	COMDAT ??0?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAE@XZ PROC ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::BPlusTree<unsigned int,DataStructures::Table::Row *,16>, COMDAT
; _this$ = ecx

; 111  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$MemoryPool@U?$Page@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::MemoryPool<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> >::MemoryPool<DataStructures::Page<unsigned int,DataStructures::Table::Row *,16> >

; 112  : 		assert(order>1);
; 113  : 		root=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 114  : 		leftmostLeaf=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 115  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAE@XZ ENDP ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::BPlusTree<unsigned int,DataStructures::Table::Row *,16>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ?QueryRow@Table@DataStructures@@IAEXAAV?$List@I@2@0IPAURow@12@PAUFilterQuery@12@PAV12@@Z
_TEXT	SEGMENT
tv380 = -280						; size = 4
tv378 = -280						; size = 4
tv347 = -280						; size = 4
tv332 = -280						; size = 4
tv321 = -280						; size = 4
tv309 = -280						; size = 4
tv294 = -280						; size = 4
tv283 = -280						; size = 4
tv270 = -280						; size = 4
tv239 = -280						; size = 4
tv224 = -280						; size = 4
tv213 = -280						; size = 4
tv200 = -280						; size = 4
tv169 = -280						; size = 4
tv154 = -280						; size = 4
tv143 = -280						; size = 4
tv134 = -280						; size = 4
$T1 = -272						; size = 4
$T2 = -260						; size = 4
$T3 = -245						; size = 1
_j$ = -44						; size = 4
_columnIndex$ = -32					; size = 4
_pass$ = -17						; size = 1
_this$ = -8						; size = 4
_inclusionFilterColumnIndices$ = 8			; size = 4
_columnIndicesToReturn$ = 12				; size = 4
_key$ = 16						; size = 4
_row$ = 20						; size = 4
_inclusionFilters$ = 24					; size = 4
_result$ = 28						; size = 4
?QueryRow@Table@DataStructures@@IAEXAAV?$List@I@2@0IPAURow@12@PAUFilterQuery@12@PAV12@@Z PROC ; DataStructures::Table::QueryRow, COMDAT
; _this$ = ecx

; 460  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 280				; 00000118H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-280]
	mov	ecx, 70					; 00000046H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	BYTE PTR $T3[ebp], 0

; 461  : 	bool pass;
; 462  : 	unsigned columnIndex;
; 463  : 	unsigned j;
; 464  : 
; 465  : 	// If no inclusion filters, just add the row
; 466  : 	if (inclusionFilterColumnIndices.Size()==0)

	mov	ecx, DWORD PTR _inclusionFilterColumnIndices$[ebp]
	call	?Size@?$List@I@DataStructures@@QBEIXZ	; DataStructures::List<unsigned int>::Size
	test	eax, eax
	jne	SHORT $LN37@QueryRow

; 467  : 	{
; 468  : 		result->AddRowColumns(key, row, columnIndicesToReturn);

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T1[ebp], esp
	mov	eax, DWORD PTR _columnIndicesToReturn$[ebp]
	push	eax
	call	??0?$List@I@DataStructures@@QAE@ABV01@@Z ; DataStructures::List<unsigned int>::List<unsigned int>
	mov	DWORD PTR tv378[ebp], eax
	mov	ecx, DWORD PTR _row$[ebp]
	push	ecx
	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	mov	ecx, DWORD PTR _result$[ebp]
	call	?AddRowColumns@Table@DataStructures@@IAEPAURow@12@IPAU312@V?$List@I@2@@Z ; DataStructures::Table::AddRowColumns

; 469  : 	}
; 470  : 	else

	jmp	$LN38@QueryRow
$LN37@QueryRow:

; 471  : 	{
; 472  : 		// Go through all inclusion filters.  Only add this row if all filters pass.
; 473  : 		for (j=0; j<inclusionFilterColumnIndices.Size(); j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN35@QueryRow
$LN34@QueryRow:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN35@QueryRow:
	mov	ecx, DWORD PTR _inclusionFilterColumnIndices$[ebp]
	call	?Size@?$List@I@DataStructures@@QBEIXZ	; DataStructures::List<unsigned int>::Size
	cmp	DWORD PTR _j$[ebp], eax
	jae	$LN33@QueryRow

; 474  : 		{
; 475  : 			columnIndex=inclusionFilterColumnIndices[j];

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inclusionFilterColumnIndices$[ebp]
	call	??A?$List@I@DataStructures@@QBEAAII@Z	; DataStructures::List<unsigned int>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _columnIndex$[ebp], ecx

; 476  : 			if (row->cells[columnIndex]->isEmpty==false && columnIndex!=(unsigned)-1)

	mov	eax, DWORD PTR _columnIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _row$[ebp]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	$LN32@QueryRow
	cmp	DWORD PTR _columnIndex$[ebp], -1
	je	$LN32@QueryRow

; 477  : 			{
; 478  : 				switch (inclusionFilters[j].operation)

	imul	eax, DWORD PTR _j$[ebp], 12
	mov	ecx, DWORD PTR _inclusionFilters$[ebp]
	mov	edx, DWORD PTR [ecx+eax+8]
	mov	DWORD PTR tv134[ebp], edx
	cmp	DWORD PTR tv134[ebp], 5
	ja	$LN30@QueryRow
	mov	eax, DWORD PTR tv134[ebp]
	jmp	DWORD PTR $LN66@QueryRow[eax*4]
$LN29@QueryRow:

; 479  : 				{
; 480  : 				case QF_EQUAL:
; 481  : 					switch(columns[inclusionFilterColumnIndices[j]].columnType)

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inclusionFilterColumnIndices$[ebp]
	call	??A?$List@I@DataStructures@@QBEAAII@Z	; DataStructures::List<unsigned int>::operator[]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??A?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEAAUColumnDescriptor@Table@1@I@Z ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::operator[]
	mov	edx, DWORD PTR [eax+32]
	mov	DWORD PTR tv143[ebp], edx
	cmp	DWORD PTR tv143[ebp], 0
	je	SHORT $LN26@QueryRow
	cmp	DWORD PTR tv143[ebp], 1
	je	SHORT $LN25@QueryRow
	cmp	DWORD PTR tv143[ebp], 2
	je	$LN24@QueryRow
	jmp	$LN27@QueryRow
$LN26@QueryRow:

; 482  : 					{
; 483  : 					case NUMERIC:
; 484  : 						pass=row->cells[columnIndex]->i==inclusionFilters[j].cellValue->i;

	mov	eax, DWORD PTR _columnIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _row$[ebp]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	ecx, DWORD PTR [eax]
	imul	edx, DWORD PTR _j$[ebp], 12
	mov	eax, DWORD PTR _inclusionFilters$[ebp]
	mov	edx, DWORD PTR [eax+edx+4]
	mov	eax, DWORD PTR [ecx+1]
	cmp	eax, DWORD PTR [edx+1]
	jne	SHORT $LN40@QueryRow
	mov	DWORD PTR tv154[ebp], 1
	jmp	SHORT $LN41@QueryRow
$LN40@QueryRow:
	mov	DWORD PTR tv154[ebp], 0
$LN41@QueryRow:
	mov	BYTE PTR $T3[ebp], 1
	mov	cl, BYTE PTR tv154[ebp]
	mov	BYTE PTR _pass$[ebp], cl

; 485  : 						break;

	jmp	$LN27@QueryRow
$LN25@QueryRow:

; 486  : 					case STRING:
; 487  : 						pass=strcmp(row->cells[columnIndex]->c,inclusionFilters[j].cellValue->c)==0;

	imul	eax, DWORD PTR _j$[ebp], 12
	mov	ecx, DWORD PTR _inclusionFilters$[ebp]
	mov	edx, DWORD PTR [ecx+eax+4]
	mov	eax, DWORD PTR [edx+5]
	push	eax
	mov	ecx, DWORD PTR _columnIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _row$[ebp]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+5]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN42@QueryRow
	mov	DWORD PTR tv169[ebp], 1
	jmp	SHORT $LN43@QueryRow
$LN42@QueryRow:
	mov	DWORD PTR tv169[ebp], 0
$LN43@QueryRow:
	mov	BYTE PTR $T3[ebp], 1
	mov	cl, BYTE PTR tv169[ebp]
	mov	BYTE PTR _pass$[ebp], cl

; 488  : 						break;

	jmp	$LN27@QueryRow
$LN24@QueryRow:

; 489  : 					case BINARY:
; 490  : 						pass=row->cells[columnIndex]->i==inclusionFilters[j].cellValue->i &&
; 491  : 							memcmp(row->cells[columnIndex]->c,inclusionFilters[j].cellValue->c, row->cells[columnIndex]->i)==0;

	mov	eax, DWORD PTR _columnIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _row$[ebp]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	ecx, DWORD PTR [eax]
	imul	edx, DWORD PTR _j$[ebp], 12
	mov	eax, DWORD PTR _inclusionFilters$[ebp]
	mov	edx, DWORD PTR [eax+edx+4]
	mov	eax, DWORD PTR [ecx+1]
	cmp	eax, DWORD PTR [edx+1]
	jne	SHORT $LN44@QueryRow
	mov	ecx, DWORD PTR _columnIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _row$[ebp]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+1]
	push	eax
	imul	ecx, DWORD PTR _j$[ebp], 12
	mov	edx, DWORD PTR _inclusionFilters$[ebp]
	mov	eax, DWORD PTR [edx+ecx+4]
	mov	ecx, DWORD PTR [eax+5]
	push	ecx
	mov	edx, DWORD PTR _columnIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _row$[ebp]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+5]
	push	ecx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN44@QueryRow
	mov	DWORD PTR tv200[ebp], 1
	jmp	SHORT $LN45@QueryRow
$LN44@QueryRow:
	mov	DWORD PTR tv200[ebp], 0
$LN45@QueryRow:
	mov	BYTE PTR $T3[ebp], 1
	mov	dl, BYTE PTR tv200[ebp]
	mov	BYTE PTR _pass$[ebp], dl
$LN27@QueryRow:

; 492  : 						break;
; 493  : 					}
; 494  : 					break;

	jmp	$LN30@QueryRow
$LN23@QueryRow:

; 495  : 				case QF_NOT_EQUAL:
; 496  : 					switch(columns[inclusionFilterColumnIndices[j]].columnType)

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inclusionFilterColumnIndices$[ebp]
	call	??A?$List@I@DataStructures@@QBEAAII@Z	; DataStructures::List<unsigned int>::operator[]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??A?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEAAUColumnDescriptor@Table@1@I@Z ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::operator[]
	mov	edx, DWORD PTR [eax+32]
	mov	DWORD PTR tv213[ebp], edx
	cmp	DWORD PTR tv213[ebp], 0
	je	SHORT $LN20@QueryRow
	cmp	DWORD PTR tv213[ebp], 1
	je	SHORT $LN19@QueryRow
	cmp	DWORD PTR tv213[ebp], 2
	je	$LN18@QueryRow
	jmp	$LN21@QueryRow
$LN20@QueryRow:

; 497  : 					{
; 498  : 					case NUMERIC:
; 499  : 						pass=row->cells[columnIndex]->i!=inclusionFilters[j].cellValue->i;

	mov	eax, DWORD PTR _columnIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _row$[ebp]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	ecx, DWORD PTR [eax]
	imul	edx, DWORD PTR _j$[ebp], 12
	mov	eax, DWORD PTR _inclusionFilters$[ebp]
	mov	edx, DWORD PTR [eax+edx+4]
	mov	eax, DWORD PTR [ecx+1]
	cmp	eax, DWORD PTR [edx+1]
	je	SHORT $LN46@QueryRow
	mov	DWORD PTR tv224[ebp], 1
	jmp	SHORT $LN47@QueryRow
$LN46@QueryRow:
	mov	DWORD PTR tv224[ebp], 0
$LN47@QueryRow:
	mov	BYTE PTR $T3[ebp], 1
	mov	cl, BYTE PTR tv224[ebp]
	mov	BYTE PTR _pass$[ebp], cl

; 500  : 						break;

	jmp	$LN21@QueryRow
$LN19@QueryRow:

; 501  : 					case STRING:
; 502  : 						pass=strcmp(row->cells[columnIndex]->c,inclusionFilters[j].cellValue->c)!=0;

	imul	eax, DWORD PTR _j$[ebp], 12
	mov	ecx, DWORD PTR _inclusionFilters$[ebp]
	mov	edx, DWORD PTR [ecx+eax+4]
	mov	eax, DWORD PTR [edx+5]
	push	eax
	mov	ecx, DWORD PTR _columnIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _row$[ebp]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+5]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN48@QueryRow
	mov	DWORD PTR tv239[ebp], 1
	jmp	SHORT $LN49@QueryRow
$LN48@QueryRow:
	mov	DWORD PTR tv239[ebp], 0
$LN49@QueryRow:
	mov	BYTE PTR $T3[ebp], 1
	mov	cl, BYTE PTR tv239[ebp]
	mov	BYTE PTR _pass$[ebp], cl

; 503  : 						break;

	jmp	$LN21@QueryRow
$LN18@QueryRow:

; 504  : 					case BINARY:
; 505  : 						pass=row->cells[columnIndex]->i==inclusionFilters[j].cellValue->i &&
; 506  : 							memcmp(row->cells[columnIndex]->c,inclusionFilters[j].cellValue->c, row->cells[columnIndex]->i)==0;

	mov	eax, DWORD PTR _columnIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _row$[ebp]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	ecx, DWORD PTR [eax]
	imul	edx, DWORD PTR _j$[ebp], 12
	mov	eax, DWORD PTR _inclusionFilters$[ebp]
	mov	edx, DWORD PTR [eax+edx+4]
	mov	eax, DWORD PTR [ecx+1]
	cmp	eax, DWORD PTR [edx+1]
	jne	SHORT $LN50@QueryRow
	mov	ecx, DWORD PTR _columnIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _row$[ebp]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+1]
	push	eax
	imul	ecx, DWORD PTR _j$[ebp], 12
	mov	edx, DWORD PTR _inclusionFilters$[ebp]
	mov	eax, DWORD PTR [edx+ecx+4]
	mov	ecx, DWORD PTR [eax+5]
	push	ecx
	mov	edx, DWORD PTR _columnIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _row$[ebp]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+5]
	push	ecx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN50@QueryRow
	mov	DWORD PTR tv270[ebp], 1
	jmp	SHORT $LN51@QueryRow
$LN50@QueryRow:
	mov	DWORD PTR tv270[ebp], 0
$LN51@QueryRow:
	mov	BYTE PTR $T3[ebp], 1
	mov	dl, BYTE PTR tv270[ebp]
	mov	BYTE PTR _pass$[ebp], dl
$LN21@QueryRow:

; 507  : 						break;
; 508  : 					}
; 509  : 					break;

	jmp	$LN30@QueryRow
$LN17@QueryRow:

; 510  : 				case QF_GREATER_THAN:
; 511  : 					switch(columns[inclusionFilterColumnIndices[j]].columnType)

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inclusionFilterColumnIndices$[ebp]
	call	??A?$List@I@DataStructures@@QBEAAII@Z	; DataStructures::List<unsigned int>::operator[]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??A?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEAAUColumnDescriptor@Table@1@I@Z ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::operator[]
	mov	edx, DWORD PTR [eax+32]
	mov	DWORD PTR tv283[ebp], edx
	cmp	DWORD PTR tv283[ebp], 0
	je	SHORT $LN14@QueryRow
	cmp	DWORD PTR tv283[ebp], 1
	je	SHORT $LN13@QueryRow
	jmp	$LN15@QueryRow
$LN14@QueryRow:

; 512  : 					{
; 513  : 					case NUMERIC:
; 514  : 						pass=row->cells[columnIndex]->i>inclusionFilters[j].cellValue->i;

	mov	eax, DWORD PTR _columnIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _row$[ebp]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	ecx, DWORD PTR [eax]
	imul	edx, DWORD PTR _j$[ebp], 12
	mov	eax, DWORD PTR _inclusionFilters$[ebp]
	mov	edx, DWORD PTR [eax+edx+4]
	mov	eax, DWORD PTR [ecx+1]
	cmp	eax, DWORD PTR [edx+1]
	jle	SHORT $LN52@QueryRow
	mov	DWORD PTR tv294[ebp], 1
	jmp	SHORT $LN53@QueryRow
$LN52@QueryRow:
	mov	DWORD PTR tv294[ebp], 0
$LN53@QueryRow:
	mov	BYTE PTR $T3[ebp], 1
	mov	cl, BYTE PTR tv294[ebp]
	mov	BYTE PTR _pass$[ebp], cl

; 515  : 						break;

	jmp	SHORT $LN15@QueryRow
$LN13@QueryRow:

; 516  : 					case STRING:
; 517  : 						pass=strcmp(row->cells[columnIndex]->c,inclusionFilters[j].cellValue->c)>0;

	imul	eax, DWORD PTR _j$[ebp], 12
	mov	ecx, DWORD PTR _inclusionFilters$[ebp]
	mov	edx, DWORD PTR [ecx+eax+4]
	mov	eax, DWORD PTR [edx+5]
	push	eax
	mov	ecx, DWORD PTR _columnIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _row$[ebp]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+5]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jle	SHORT $LN54@QueryRow
	mov	DWORD PTR tv309[ebp], 1
	jmp	SHORT $LN55@QueryRow
$LN54@QueryRow:
	mov	DWORD PTR tv309[ebp], 0
$LN55@QueryRow:
	mov	BYTE PTR $T3[ebp], 1
	mov	cl, BYTE PTR tv309[ebp]
	mov	BYTE PTR _pass$[ebp], cl
$LN15@QueryRow:

; 518  : 						break;
; 519  : 					}
; 520  : 					break;

	jmp	$LN30@QueryRow
$LN12@QueryRow:

; 521  : 				case QF_LESS_THAN:
; 522  : 					switch(columns[inclusionFilterColumnIndices[j]].columnType)

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inclusionFilterColumnIndices$[ebp]
	call	??A?$List@I@DataStructures@@QBEAAII@Z	; DataStructures::List<unsigned int>::operator[]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??A?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEAAUColumnDescriptor@Table@1@I@Z ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::operator[]
	mov	edx, DWORD PTR [eax+32]
	mov	DWORD PTR tv321[ebp], edx
	cmp	DWORD PTR tv321[ebp], 0
	je	SHORT $LN9@QueryRow
	cmp	DWORD PTR tv321[ebp], 1
	je	SHORT $LN8@QueryRow
	jmp	$LN10@QueryRow
$LN9@QueryRow:

; 523  : 					{
; 524  : 					case NUMERIC:
; 525  : 						pass=row->cells[columnIndex]->i<inclusionFilters[j].cellValue->i;

	mov	eax, DWORD PTR _columnIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _row$[ebp]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	ecx, DWORD PTR [eax]
	imul	edx, DWORD PTR _j$[ebp], 12
	mov	eax, DWORD PTR _inclusionFilters$[ebp]
	mov	edx, DWORD PTR [eax+edx+4]
	mov	eax, DWORD PTR [ecx+1]
	cmp	eax, DWORD PTR [edx+1]
	jge	SHORT $LN56@QueryRow
	mov	DWORD PTR tv332[ebp], 1
	jmp	SHORT $LN57@QueryRow
$LN56@QueryRow:
	mov	DWORD PTR tv332[ebp], 0
$LN57@QueryRow:
	mov	BYTE PTR $T3[ebp], 1
	mov	cl, BYTE PTR tv332[ebp]
	mov	BYTE PTR _pass$[ebp], cl

; 526  : 						break;

	jmp	SHORT $LN10@QueryRow
$LN8@QueryRow:

; 527  : 					case STRING:
; 528  : 						pass=strcmp(row->cells[columnIndex]->c,inclusionFilters[j].cellValue->c)<0;

	imul	eax, DWORD PTR _j$[ebp], 12
	mov	ecx, DWORD PTR _inclusionFilters$[ebp]
	mov	edx, DWORD PTR [ecx+eax+4]
	mov	eax, DWORD PTR [edx+5]
	push	eax
	mov	ecx, DWORD PTR _columnIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _row$[ebp]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+5]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jge	SHORT $LN58@QueryRow
	mov	DWORD PTR tv347[ebp], 1
	jmp	SHORT $LN59@QueryRow
$LN58@QueryRow:
	mov	DWORD PTR tv347[ebp], 0
$LN59@QueryRow:
	mov	BYTE PTR $T3[ebp], 1
	mov	cl, BYTE PTR tv347[ebp]
	mov	BYTE PTR _pass$[ebp], cl
$LN10@QueryRow:

; 529  : 						break;
; 530  : 					}
; 531  : 					break;

	jmp	SHORT $LN30@QueryRow
$LN7@QueryRow:

; 532  : 				case QF_IS_EMPTY:
; 533  : 					pass=false;

	mov	BYTE PTR $T3[ebp], 1
	mov	BYTE PTR _pass$[ebp], 0

; 534  : 					break;

	jmp	SHORT $LN30@QueryRow
$LN6@QueryRow:

; 535  : 				case QF_NOT_EMPTY:
; 536  : 					pass=true;

	mov	BYTE PTR $T3[ebp], 1
	mov	BYTE PTR _pass$[ebp], 1
$LN30@QueryRow:

; 537  : 					break;
; 538  : 				}
; 539  : 			}
; 540  : 			else

	jmp	SHORT $LN5@QueryRow
$LN32@QueryRow:

; 541  : 			{
; 542  : 				if (inclusionFilters[j].operation==QF_IS_EMPTY)

	imul	eax, DWORD PTR _j$[ebp], 12
	mov	ecx, DWORD PTR _inclusionFilters$[ebp]
	cmp	DWORD PTR [ecx+eax+8], 4
	jne	SHORT $LN4@QueryRow

; 543  : 					pass=true;

	mov	BYTE PTR $T3[ebp], 1
	mov	BYTE PTR _pass$[ebp], 1

; 544  : 				else

	jmp	SHORT $LN5@QueryRow
$LN4@QueryRow:

; 545  : 					pass=false; // No value for this cell

	mov	BYTE PTR $T3[ebp], 1
	mov	BYTE PTR _pass$[ebp], 0
$LN5@QueryRow:

; 546  : 			}
; 547  : 
; 548  : 			if (pass==false)

	cmp	BYTE PTR $T3[ebp], 0
	jne	SHORT $LN62@QueryRow
	push	OFFSET $LN63@QueryRow
	call	__RTC_UninitUse
	add	esp, 4
$LN62@QueryRow:
	movzx	eax, BYTE PTR _pass$[ebp]
	test	eax, eax
	jne	SHORT $LN2@QueryRow

; 549  : 				break;

	jmp	SHORT $LN33@QueryRow
$LN2@QueryRow:

; 550  : 		}

	jmp	$LN34@QueryRow
$LN33@QueryRow:

; 551  : 
; 552  : 		if (pass)

	cmp	BYTE PTR $T3[ebp], 0
	jne	SHORT $LN64@QueryRow
	push	OFFSET $LN63@QueryRow
	call	__RTC_UninitUse
	add	esp, 4
$LN64@QueryRow:
	movzx	eax, BYTE PTR _pass$[ebp]
	test	eax, eax
	je	SHORT $LN38@QueryRow

; 553  : 		{
; 554  : 			result->AddRowColumns(key, row, columnIndicesToReturn);

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T2[ebp], esp
	mov	eax, DWORD PTR _columnIndicesToReturn$[ebp]
	push	eax
	call	??0?$List@I@DataStructures@@QAE@ABV01@@Z ; DataStructures::List<unsigned int>::List<unsigned int>
	mov	DWORD PTR tv380[ebp], eax
	mov	ecx, DWORD PTR _row$[ebp]
	push	ecx
	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	mov	ecx, DWORD PTR _result$[ebp]
	call	?AddRowColumns@Table@DataStructures@@IAEPAURow@12@IPAU312@V?$List@I@2@@Z ; DataStructures::Table::AddRowColumns
$LN38@QueryRow:

; 555  : 		}
; 556  : 	}
; 557  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 280				; 00000118H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$LN65@QueryRow:
$LN63@QueryRow:
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	115					; 00000073H
	DB	0
	npad	2
$LN66@QueryRow:
	DD	$LN29@QueryRow
	DD	$LN23@QueryRow
	DD	$LN17@QueryRow
	DD	$LN12@QueryRow
	DD	$LN7@QueryRow
	DD	$LN6@QueryRow
?QueryRow@Table@DataStructures@@IAEXAAV?$List@I@2@0IPAURow@12@PAUFilterQuery@12@PAV12@@Z ENDP ; DataStructures::Table::QueryRow
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ?DeleteRow@Table@DataStructures@@IAEXPAURow@12@@Z
_TEXT	SEGMENT
tv82 = -268						; size = 4
tv77 = -268						; size = 4
$T1 = -260						; size = 4
$T2 = -248						; size = 4
$T3 = -236						; size = 4
$T4 = -224						; size = 4
_rowIndex$ = -20					; size = 4
_this$ = -8						; size = 4
_row$ = 8						; size = 4
?DeleteRow@Table@DataStructures@@IAEXPAURow@12@@Z PROC	; DataStructures::Table::DeleteRow, COMDAT
; _this$ = ecx

; 761  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-268]
	mov	ecx, 67					; 00000043H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 762  : 	unsigned rowIndex;
; 763  : 	for (rowIndex=0; rowIndex < row->cells.Size(); rowIndex++)

	mov	DWORD PTR _rowIndex$[ebp], 0
	jmp	SHORT $LN3@DeleteRow
$LN2@DeleteRow:
	mov	eax, DWORD PTR _rowIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _rowIndex$[ebp], eax
$LN3@DeleteRow:
	mov	ecx, DWORD PTR _row$[ebp]
	call	?Size@?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Table::Cell *>::Size
	cmp	DWORD PTR _rowIndex$[ebp], eax
	jae	SHORT $LN1@DeleteRow

; 764  : 	{
; 765  : 		delete row->cells[rowIndex];

	mov	eax, DWORD PTR _rowIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _row$[ebp]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T1[ebp], edx
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN6@DeleteRow
	push	1
	mov	ecx, DWORD PTR $T1[ebp]
	call	??_GCell@Table@DataStructures@@QAEPAXI@Z
	mov	DWORD PTR tv77[ebp], eax
	jmp	SHORT $LN7@DeleteRow
$LN6@DeleteRow:
	mov	DWORD PTR tv77[ebp], 0
$LN7@DeleteRow:

; 766  : 	}

	jmp	SHORT $LN2@DeleteRow
$LN1@DeleteRow:

; 767  : 	delete row;

	mov	eax, DWORD PTR _row$[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	ecx, DWORD PTR $T4[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN8@DeleteRow
	push	1
	mov	ecx, DWORD PTR $T3[ebp]
	call	??_GRow@Table@DataStructures@@QAEPAXI@Z
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $LN4@DeleteRow
$LN8@DeleteRow:
	mov	DWORD PTR tv82[ebp], 0
$LN4@DeleteRow:

; 768  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 268				; 0000010cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?DeleteRow@Table@DataStructures@@IAEXPAURow@12@@Z ENDP	; DataStructures::Table::DeleteRow
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ?AddRowColumns@Table@DataStructures@@IAEPAURow@12@IPAU312@V?$List@I@2@@Z
_TEXT	SEGMENT
tv161 = -328						; size = 4
tv151 = -328						; size = 4
tv72 = -328						; size = 4
$T2 = -320						; size = 4
$T3 = -308						; size = 4
$T4 = -296						; size = 4
$T5 = -284						; size = 4
$T6 = -272						; size = 4
$T7 = -260						; size = 4
$T8 = -248						; size = 4
_columnIndex$ = -44					; size = 4
_newRow$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_rowId$ = 8						; size = 4
_row$ = 12						; size = 4
_columnIndices$ = 16					; size = 12
?AddRowColumns@Table@DataStructures@@IAEPAURow@12@IPAU312@V?$List@I@2@@Z PROC ; DataStructures::Table::AddRowColumns, COMDAT
; _this$ = ecx

; 274  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddRowColumns@Table@DataStructures@@IAEPAURow@12@IPAU312@V?$List@I@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 316				; 0000013cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-328]
	mov	ecx, 79					; 0000004fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 275  : 	Row *newRow = new Row;

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN8@AddRowColu
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0Row@Table@DataStructures@@QAE@XZ
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN9@AddRowColu
$LN8@AddRowColu:
	mov	DWORD PTR tv72[ebp], 0
$LN9@AddRowColu:
	mov	eax, DWORD PTR tv72[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _newRow$[ebp], ecx

; 276  : 	unsigned columnIndex;
; 277  : 	for (columnIndex=0; columnIndex < columnIndices.Size(); columnIndex++)

	mov	DWORD PTR _columnIndex$[ebp], 0
	jmp	SHORT $LN5@AddRowColu
$LN4@AddRowColu:
	mov	eax, DWORD PTR _columnIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _columnIndex$[ebp], eax
$LN5@AddRowColu:
	lea	ecx, DWORD PTR _columnIndices$[ebp]
	call	?Size@?$List@I@DataStructures@@QBEIXZ	; DataStructures::List<unsigned int>::Size
	cmp	DWORD PTR _columnIndex$[ebp], eax
	jae	$LN3@AddRowColu

; 278  : 	{
; 279  : 		if (row->cells[columnIndices[columnIndex]]->isEmpty==false)

	mov	eax, DWORD PTR _columnIndex$[ebp]
	push	eax
	lea	ecx, DWORD PTR _columnIndices$[ebp]
	call	??A?$List@I@DataStructures@@QBEAAII@Z	; DataStructures::List<unsigned int>::operator[]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _row$[ebp]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	edx, DWORD PTR [eax]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	$LN2@AddRowColu

; 280  : 		{
; 281  : 			newRow->cells.Insert(new Table::Cell(
; 282  : 				row->cells[columnIndices[columnIndex]]->i,
; 283  : 				row->cells[columnIndices[columnIndex]]->c,
; 284  : 				columns[columnIndex].columnType
; 285  : 				));

	push	9
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN10@AddRowColu
	mov	eax, DWORD PTR _columnIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??A?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEAAUColumnDescriptor@Table@1@I@Z ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::operator[]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _columnIndex$[ebp]
	push	edx
	lea	ecx, DWORD PTR _columnIndices$[ebp]
	call	??A?$List@I@DataStructures@@QBEAAII@Z	; DataStructures::List<unsigned int>::operator[]
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _row$[ebp]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+5]
	push	edx
	mov	eax, DWORD PTR _columnIndex$[ebp]
	push	eax
	lea	ecx, DWORD PTR _columnIndices$[ebp]
	call	??A?$List@I@DataStructures@@QBEAAII@Z	; DataStructures::List<unsigned int>::operator[]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _row$[ebp]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+1]
	push	eax
	mov	ecx, DWORD PTR $T5[ebp]
	call	??0Cell@Table@DataStructures@@QAE@HPADW4ColumnType@12@@Z ; DataStructures::Table::Cell::Cell
	mov	DWORD PTR tv151[ebp], eax
	jmp	SHORT $LN11@AddRowColu
$LN10@AddRowColu:
	mov	DWORD PTR tv151[ebp], 0
$LN11@AddRowColu:
	mov	ecx, DWORD PTR tv151[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _newRow$[ebp]
	call	?Insert@?$List@PAUCell@Table@DataStructures@@@DataStructures@@QAEXQAUCell@Table@2@@Z ; DataStructures::List<DataStructures::Table::Cell *>::Insert

; 286  : 		}
; 287  : 		else

	jmp	SHORT $LN1@AddRowColu
$LN2@AddRowColu:

; 288  : 		{
; 289  : 			newRow->cells.Insert(new Cell());

	push	9
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T7[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	cmp	DWORD PTR $T7[ebp], 0
	je	SHORT $LN12@AddRowColu
	mov	ecx, DWORD PTR $T7[ebp]
	call	??0Cell@Table@DataStructures@@QAE@XZ	; DataStructures::Table::Cell::Cell
	mov	DWORD PTR tv161[ebp], eax
	jmp	SHORT $LN13@AddRowColu
$LN12@AddRowColu:
	mov	DWORD PTR tv161[ebp], 0
$LN13@AddRowColu:
	mov	eax, DWORD PTR tv161[ebp]
	mov	DWORD PTR $T6[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR $T6[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newRow$[ebp]
	call	?Insert@?$List@PAUCell@Table@DataStructures@@@DataStructures@@QAEXQAUCell@Table@2@@Z ; DataStructures::List<DataStructures::Table::Cell *>::Insert
$LN1@AddRowColu:

; 290  : 		}
; 291  : 	}

	jmp	$LN4@AddRowColu
$LN3@AddRowColu:

; 292  : 	rows.Insert(rowId, newRow);

	lea	eax, DWORD PTR _newRow$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rowId$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Insert@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAE_NIABQAURow@Table@2@@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::Insert

; 293  : 	return newRow;

	mov	eax, DWORD PTR _newRow$[ebp]
	mov	DWORD PTR $T8[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _columnIndices$[ebp]
	call	??1?$List@I@DataStructures@@QAE@XZ	; DataStructures::List<unsigned int>::~List<unsigned int>
	mov	eax, DWORD PTR $T8[ebp]

; 294  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN21@AddRowColu
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 328				; 00000148H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
	npad	3
$LN21@AddRowColu:
	DD	1
	DD	$LN20@AddRowColu
$LN20@AddRowColu:
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN18@AddRowColu
$LN18@AddRowColu:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	82					; 00000052H
	DB	111					; 0000006fH
	DB	119					; 00000077H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddRowColumns@Table@DataStructures@@IAEPAURow@12@IPAU312@V?$List@I@2@@Z$0:
	lea	ecx, DWORD PTR _columnIndices$[ebp]
	jmp	??1?$List@I@DataStructures@@QAE@XZ	; DataStructures::List<unsigned int>::~List<unsigned int>
__unwindfunclet$?AddRowColumns@Table@DataStructures@@IAEPAURow@12@IPAU312@V?$List@I@2@@Z$1:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?AddRowColumns@Table@DataStructures@@IAEPAURow@12@IPAU312@V?$List@I@2@@Z$2:
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?AddRowColumns@Table@DataStructures@@IAEPAURow@12@IPAU312@V?$List@I@2@@Z$3:
	mov	eax, DWORD PTR $T7[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?AddRowColumns@Table@DataStructures@@IAEPAURow@12@IPAU312@V?$List@I@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-332]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddRowColumns@Table@DataStructures@@IAEPAURow@12@IPAU312@V?$List@I@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddRowColumns@Table@DataStructures@@IAEPAURow@12@IPAU312@V?$List@I@2@@Z ENDP ; DataStructures::Table::AddRowColumns
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ?GetListHead@Table@DataStructures@@QAEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetListHead@Table@DataStructures@@QAEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@XZ PROC ; DataStructures::Table::GetListHead, COMDAT
; _this$ = ecx

; 757  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 758  : 	return rows.GetListHead();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetListHead@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QBEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@XZ ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::GetListHead

; 759  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetListHead@Table@DataStructures@@QAEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@XZ ENDP ; DataStructures::Table::GetListHead
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ?GetRows@Table@DataStructures@@QAEAAV?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetRows@Table@DataStructures@@QAEAAV?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@2@XZ PROC ; DataStructures::Table::GetRows, COMDAT
; _this$ = ecx

; 753  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 754  : 	return rows;

	mov	eax, DWORD PTR _this$[ebp]

; 755  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetRows@Table@DataStructures@@QAEAAV?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@2@XZ ENDP ; DataStructures::Table::GetRows
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ?GetColumns@Table@DataStructures@@QAEAAV?$List@UColumnDescriptor@Table@DataStructures@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetColumns@Table@DataStructures@@QAEAAV?$List@UColumnDescriptor@Table@DataStructures@@@2@XZ PROC ; DataStructures::Table::GetColumns, COMDAT
; _this$ = ecx

; 749  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 750  : 	return columns;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H

; 751  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetColumns@Table@DataStructures@@QAEAAV?$List@UColumnDescriptor@Table@DataStructures@@@2@XZ ENDP ; DataStructures::Table::GetColumns
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ?PrintRow@Table@DataStructures@@QAEXPADHD_NPAURow@12@@Z
_TEXT	SEGMENT
$T1 = -808						; size = 4
$T2 = -796						; size = 4
$T3 = -784						; size = 4
$T4 = -772						; size = 4
$T5 = -760						; size = 4
_len$ = -556						; size = 4
_i$ = -544						; size = 4
_buff$ = -532						; size = 512
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_out$ = 8						; size = 4
_outLength$ = 12					; size = 4
_columnDelineator$ = 16					; size = 1
_printDelineatorForBinary$ = 20				; size = 1
_inputRow$ = 24						; size = 4
?PrintRow@Table@DataStructures@@QAEXPADHD_NPAURow@12@@Z PROC ; DataStructures::Table::PrintRow, COMDAT
; _this$ = ecx

; 672  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 812				; 0000032cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-812]
	mov	ecx, 203				; 000000cbH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 673  : 	if (outLength<=0)

	cmp	DWORD PTR _outLength$[ebp], 0
	jg	SHORT $LN20@PrintRow

; 674  : 		return;

	jmp	$LN22@PrintRow
$LN20@PrintRow:

; 675  : 	if (outLength==1)

	cmp	DWORD PTR _outLength$[ebp], 1
	jne	SHORT $LN19@PrintRow

; 676  : 	{
; 677  : 		*out=0;

	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], 0

; 678  : 		return;

	jmp	$LN22@PrintRow
$LN19@PrintRow:

; 679  : 	}
; 680  : 
; 681  : 	if (inputRow->cells.Size()!=columns.Size())

	mov	ecx, DWORD PTR _inputRow$[ebp]
	call	?Size@?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Table::Cell *>::Size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?Size@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::Size
	cmp	esi, eax
	je	SHORT $LN18@PrintRow

; 682  : 	{
; 683  : 		strncpy(out, "Cell width does not match column width.\n", outLength);

	mov	eax, DWORD PTR _outLength$[ebp]
	push	eax
	push	OFFSET ??_C@_0CJ@PKINFIOI@Cell?5width?5does?5not?5match?5column@
	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	_strncpy
	add	esp, 12					; 0000000cH

; 684  : 		out[outLength-1]=0;

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR _outLength$[ebp]
	mov	BYTE PTR [eax-1], 0

; 685  : 		return;

	jmp	$LN22@PrintRow
$LN18@PrintRow:

; 686  : 	}
; 687  : 
; 688  : 	char buff[512];
; 689  : 	unsigned i;
; 690  : 	int len;
; 691  : 	out[0]=0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 692  : 	for (i=0; i < columns.Size(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN17@PrintRow
$LN16@PrintRow:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN17@PrintRow:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?Size@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	$LN22@PrintRow

; 693  : 	{
; 694  :         if (columns[i].columnType==NUMERIC)

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??A?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEAAUColumnDescriptor@Table@1@I@Z ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::operator[]
	cmp	DWORD PTR [eax+32], 0
	jne	$LN14@PrintRow

; 695  : 		{
; 696  : 			if (inputRow->cells[i]->isEmpty==false)

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inputRow$[ebp]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN13@PrintRow

; 697  : 			{
; 698  : 				sprintf(buff, "%i", inputRow->cells[i]->i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inputRow$[ebp]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+1]
	push	edx
	push	OFFSET ??_C@_02IKAHHCAI@?$CFi?$AA@
	lea	eax, DWORD PTR _buff$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 699  : 				len=(int)strlen(buff);

	lea	eax, DWORD PTR _buff$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax

; 700  : 			}
; 701  : 			else

	jmp	SHORT $LN12@PrintRow
$LN13@PrintRow:

; 702  : 				len=0;

	mov	DWORD PTR _len$[ebp], 0
$LN12@PrintRow:

; 703  : 			if (i+1!=columns.Size())

	mov	esi, DWORD PTR _i$[ebp]
	add	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?Size@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::Size
	cmp	esi, eax
	je	SHORT $LN11@PrintRow

; 704  : 				buff[len++]=columnDelineator;

	mov	eax, DWORD PTR _len$[ebp]
	mov	cl, BYTE PTR _columnDelineator$[ebp]
	mov	BYTE PTR _buff$[ebp+eax], cl
	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	mov	DWORD PTR _len$[ebp], edx
$LN11@PrintRow:

; 705  : 			buff[len]=0;

	mov	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 512			; 00000200H
	jae	SHORT $LN23@PrintRow
	jmp	SHORT $LN24@PrintRow
$LN23@PrintRow:
	call	___report_rangecheckfailure
$LN24@PrintRow:
	mov	ecx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _buff$[ebp+ecx], 0
	jmp	$LN10@PrintRow
$LN14@PrintRow:

; 706  : 		}
; 707  : 		else if (columns[i].columnType==STRING)

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??A?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEAAUColumnDescriptor@Table@1@I@Z ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::operator[]
	cmp	DWORD PTR [eax+32], 1
	jne	$LN9@PrintRow

; 708  : 		{
; 709  : 			if (inputRow->cells[i]->isEmpty==false && inputRow->cells[i]->c)

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inputRow$[ebp]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	$LN8@PrintRow
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inputRow$[ebp]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+5], 0
	je	SHORT $LN8@PrintRow

; 710  : 			{
; 711  : 				strncpy(buff, inputRow->cells[i]->c, 512-2);

	push	510					; 000001feH
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inputRow$[ebp]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+5]
	push	edx
	lea	eax, DWORD PTR _buff$[ebp]
	push	eax
	call	_strncpy
	add	esp, 12					; 0000000cH

; 712  : 				buff[512-2]=0;

	mov	eax, 1
	imul	ecx, eax, 510
	mov	DWORD PTR $T2[ebp], ecx
	cmp	DWORD PTR $T2[ebp], 512			; 00000200H
	jae	SHORT $LN25@PrintRow
	jmp	SHORT $LN26@PrintRow
$LN25@PrintRow:
	call	___report_rangecheckfailure
$LN26@PrintRow:
	mov	edx, DWORD PTR $T2[ebp]
	mov	BYTE PTR _buff$[ebp+edx], 0

; 713  : 				len=(int)strlen(buff);

	lea	eax, DWORD PTR _buff$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax

; 714  : 			}
; 715  : 			else

	jmp	SHORT $LN7@PrintRow
$LN8@PrintRow:

; 716  : 				len=0;

	mov	DWORD PTR _len$[ebp], 0
$LN7@PrintRow:

; 717  : 			if (i+1!=columns.Size())

	mov	esi, DWORD PTR _i$[ebp]
	add	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?Size@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::Size
	cmp	esi, eax
	je	SHORT $LN6@PrintRow

; 718  : 				buff[len++]=columnDelineator;

	mov	eax, DWORD PTR _len$[ebp]
	mov	cl, BYTE PTR _columnDelineator$[ebp]
	mov	BYTE PTR _buff$[ebp+eax], cl
	mov	edx, DWORD PTR _len$[ebp]
	add	edx, 1
	mov	DWORD PTR _len$[ebp], edx
$LN6@PrintRow:

; 719  : 			buff[len]=0;

	mov	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR $T3[ebp], eax
	cmp	DWORD PTR $T3[ebp], 512			; 00000200H
	jae	SHORT $LN27@PrintRow
	jmp	SHORT $LN28@PrintRow
$LN27@PrintRow:
	call	___report_rangecheckfailure
$LN28@PrintRow:
	mov	ecx, DWORD PTR $T3[ebp]
	mov	BYTE PTR _buff$[ebp+ecx], 0

; 720  : 		}
; 721  : 		else

	jmp	$LN10@PrintRow
$LN9@PrintRow:

; 722  : 		{
; 723  : 			if (printDelineatorForBinary)

	movzx	eax, BYTE PTR _printDelineatorForBinary$[ebp]
	test	eax, eax
	je	SHORT $LN4@PrintRow

; 724  : 			{
; 725  : 				if (i+1!=columns.Size())

	mov	esi, DWORD PTR _i$[ebp]
	add	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?Size@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::Size
	cmp	esi, eax
	je	SHORT $LN3@PrintRow

; 726  : 					buff[0]=columnDelineator;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	dl, BYTE PTR _columnDelineator$[ebp]
	mov	BYTE PTR _buff$[ebp+ecx], dl
$LN3@PrintRow:

; 727  : 				buff[1]=0;

	mov	DWORD PTR $T4[ebp], 1
	cmp	DWORD PTR $T4[ebp], 512			; 00000200H
	jae	SHORT $LN29@PrintRow
	jmp	SHORT $LN30@PrintRow
$LN29@PrintRow:
	call	___report_rangecheckfailure
$LN30@PrintRow:
	mov	eax, DWORD PTR $T4[ebp]
	mov	BYTE PTR _buff$[ebp+eax], 0

; 728  : 			}
; 729  : 			else

	jmp	SHORT $LN10@PrintRow
$LN4@PrintRow:

; 730  : 				buff[0]=0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T5[ebp], ecx
	cmp	DWORD PTR $T5[ebp], 512			; 00000200H
	jae	SHORT $LN31@PrintRow
	jmp	SHORT $LN32@PrintRow
$LN31@PrintRow:
	call	___report_rangecheckfailure
$LN32@PrintRow:
	mov	edx, DWORD PTR $T5[ebp]
	mov	BYTE PTR _buff$[ebp+edx], 0
$LN10@PrintRow:

; 731  : 			
; 732  : 		}
; 733  : 
; 734  : 		len=(int)strlen(out);

	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax

; 735  : 		if (outLength==len+1)

	mov	eax, DWORD PTR _len$[ebp]
	add	eax, 1
	cmp	DWORD PTR _outLength$[ebp], eax
	jne	SHORT $LN1@PrintRow

; 736  : 			break;

	jmp	SHORT $LN22@PrintRow
$LN1@PrintRow:

; 737  : 		strncpy(out+len, buff, outLength-len);

	mov	eax, DWORD PTR _outLength$[ebp]
	sub	eax, DWORD PTR _len$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buff$[ebp]
	push	ecx
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, DWORD PTR _len$[ebp]
	push	edx
	call	_strncpy
	add	esp, 12					; 0000000cH

; 738  : 		out[outLength-1]=0;

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR _outLength$[ebp]
	mov	BYTE PTR [eax-1], 0

; 739  : 	}

	jmp	$LN16@PrintRow
$LN22@PrintRow:

; 740  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN35@PrintRow
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 812				; 0000032cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
	npad	3
$LN35@PrintRow:
	DD	1
	DD	$LN34@PrintRow
$LN34@PrintRow:
	DD	-532					; fffffdecH
	DD	512					; 00000200H
	DD	$LN33@PrintRow
$LN33@PrintRow:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	0
?PrintRow@Table@DataStructures@@QAEXPADHD_NPAURow@12@@Z ENDP ; DataStructures::Table::PrintRow
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ?Clear@Table@DataStructures@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Clear@Table@DataStructures@@QAEXXZ PROC		; DataStructures::Table::Clear, COMDAT
; _this$ = ecx

; 743  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 744  : 	rows.ForEachData(FreeRow);

	push	OFFSET ?FreeRow@@YAXPAURow@Table@DataStructures@@H@Z ; FreeRow
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ForEachData@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAEXP6AXPAURow@Table@2@H@Z@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::ForEachData

; 745  : 	rows.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAEXXZ ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::Clear

; 746  : 	columns.Clear(true);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?Clear@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QAEX_N@Z ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::Clear

; 747  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@Table@DataStructures@@QAEXXZ ENDP		; DataStructures::Table::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ?SortTable@Table@DataStructures@@QAEXPAUSortQuery@12@IPAPAURow@12@@Z
_TEXT	SEGMENT
_orderedList$ = -108					; size = 12
_cur$ = -88						; size = 4
_anyValid$ = -73					; size = 1
_columnIndices$ = -64					; size = 12
_outLength$ = -44					; size = 4
_i$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_sortQueries$ = 8					; size = 4
_numSortQueries$ = 12					; size = 4
_out$ = 16						; size = 4
?SortTable@Table@DataStructures@@QAEXPAUSortQuery@12@IPAPAURow@12@@Z PROC ; DataStructures::Table::SortTable, COMDAT
; _this$ = ecx

; 619  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SortTable@Table@DataStructures@@QAEXPAUSortQuery@12@IPAPAURow@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 292				; 00000124H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-304]
	mov	ecx, 73					; 00000049H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 620  : 	unsigned i;
; 621  : 	unsigned outLength;
; 622  : 	DataStructures::List<unsigned> columnIndices;

	lea	ecx, DWORD PTR _columnIndices$[ebp]
	call	??0?$List@I@DataStructures@@QAE@XZ	; DataStructures::List<unsigned int>::List<unsigned int>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 623  : 	_sortQueries=sortQueries;

	mov	eax, DWORD PTR _sortQueries$[ebp]
	mov	DWORD PTR __sortQueries, eax

; 624  : 	_numSortQueries=numSortQueries;

	mov	eax, DWORD PTR _numSortQueries$[ebp]
	mov	DWORD PTR __numSortQueries, eax

; 625  : 	_columnIndices=&columnIndices;

	lea	eax, DWORD PTR _columnIndices$[ebp]
	mov	DWORD PTR __columnIndices, eax

; 626  : 	_columns=&columns;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR __columns, eax

; 627  : 	bool anyValid=false;

	mov	BYTE PTR _anyValid$[ebp], 0

; 628  : 
; 629  : 	for (i=0; i < numSortQueries; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN19@SortTable
$LN18@SortTable:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN19@SortTable:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numSortQueries$[ebp]
	jae	SHORT $LN17@SortTable

; 630  : 	{
; 631  : 		if (sortQueries[i].columnIndex>=0 && sortQueries[i].columnIndex<columns.Size() && columns[sortQueries[i].columnIndex].columnType!=BINARY)

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _sortQueries$[ebp]
	cmp	DWORD PTR [ecx+eax*8], 0
	jb	SHORT $LN16@SortTable
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?Size@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::Size
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _sortQueries$[ebp]
	cmp	DWORD PTR [edx+ecx*8], eax
	jae	SHORT $LN16@SortTable
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _sortQueries$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??A?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEAAUColumnDescriptor@Table@1@I@Z ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::operator[]
	cmp	DWORD PTR [eax+32], 2
	je	SHORT $LN16@SortTable

; 632  : 		{
; 633  : 			columnIndices.Insert(sortQueries[i].columnIndex);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _sortQueries$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	push	edx
	lea	ecx, DWORD PTR _columnIndices$[ebp]
	call	?Insert@?$List@I@DataStructures@@QAEXI@Z ; DataStructures::List<unsigned int>::Insert

; 634  : 			anyValid=true;

	mov	BYTE PTR _anyValid$[ebp], 1

; 635  : 		}
; 636  : 		else

	jmp	SHORT $LN15@SortTable
$LN16@SortTable:

; 637  : 			columnIndices.Insert((unsigned)-1); // Means don't check this column

	push	-1
	lea	ecx, DWORD PTR _columnIndices$[ebp]
	call	?Insert@?$List@I@DataStructures@@QAEXI@Z ; DataStructures::List<unsigned int>::Insert
$LN15@SortTable:

; 638  : 	}

	jmp	SHORT $LN18@SortTable
$LN17@SortTable:

; 639  : 
; 640  : 	DataStructures::Page<unsigned, Row*, _TABLE_BPLUS_TREE_ORDER> *cur;
; 641  : 	cur = rows.GetListHead();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetListHead@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QBEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@XZ ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::GetListHead
	mov	DWORD PTR _cur$[ebp], eax

; 642  : 	if (anyValid==false)

	movzx	eax, BYTE PTR _anyValid$[ebp]
	test	eax, eax
	jne	SHORT $LN14@SortTable

; 643  : 	{
; 644  : 		outLength=0;

	mov	DWORD PTR _outLength$[ebp], 0
$LN13@SortTable:

; 645  : 		while (cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN12@SortTable

; 646  : 		{
; 647  : 			for (i=0; i < (unsigned)cur->size; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN11@SortTable
$LN10@SortTable:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN11@SortTable:
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+1]
	jae	SHORT $LN9@SortTable

; 648  : 			{
; 649  : 				out[(outLength)++]=cur->data[i];

	mov	eax, DWORD PTR _outLength$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+69]
	mov	DWORD PTR [ecx+eax*4], edx
	mov	eax, DWORD PTR _outLength$[ebp]
	add	eax, 1
	mov	DWORD PTR _outLength$[ebp], eax

; 650  : 			}

	jmp	SHORT $LN10@SortTable
$LN9@SortTable:

; 651  : 			cur=cur->next;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+133]
	mov	DWORD PTR _cur$[ebp], ecx

; 652  : 		}

	jmp	SHORT $LN13@SortTable
$LN12@SortTable:

; 653  : 		return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _columnIndices$[ebp]
	call	??1?$List@I@DataStructures@@QAE@XZ	; DataStructures::List<unsigned int>::~List<unsigned int>
	jmp	$LN20@SortTable
$LN14@SortTable:

; 654  : 	}
; 655  : 
; 656  : 	// Start adding to ordered list.
; 657  : 	DataStructures::OrderedList<Row*, Row*, RowSort> orderedList;

	lea	ecx, DWORD PTR _orderedList$[ebp]
	call	??0?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<DataStructures::Table::Row *,DataStructures::Table::Row *,&RowSort>::OrderedList<DataStructures::Table::Row *,DataStructures::Table::Row *,&RowSort>
	mov	BYTE PTR __$EHRec$[ebp+8], 1
$LN8@SortTable:

; 658  : 	while (cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN7@SortTable

; 659  : 	{
; 660  : 		for (i=0; i < (unsigned)cur->size; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@SortTable
$LN5@SortTable:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@SortTable:
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+1]
	jae	SHORT $LN4@SortTable

; 661  : 		{
; 662  : 			orderedList.Insert(cur->data[i],cur->data[i]);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4+69]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4+69]
	push	edx
	lea	ecx, DWORD PTR _orderedList$[ebp]
	call	?Insert@?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QAEIABQAURow@Table@2@0@Z ; DataStructures::OrderedList<DataStructures::Table::Row *,DataStructures::Table::Row *,&RowSort>::Insert

; 663  : 		}

	jmp	SHORT $LN5@SortTable
$LN4@SortTable:

; 664  : 		cur=cur->next;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+133]
	mov	DWORD PTR _cur$[ebp], ecx

; 665  : 	}

	jmp	SHORT $LN8@SortTable
$LN7@SortTable:

; 666  : 
; 667  : 	outLength=0;

	mov	DWORD PTR _outLength$[ebp], 0

; 668  : 	for (i=0; i < orderedList.Size(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@SortTable
$LN2@SortTable:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@SortTable:
	lea	ecx, DWORD PTR _orderedList$[ebp]
	call	?Size@?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<DataStructures::Table::Row *,DataStructures::Table::Row *,&RowSort>::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN1@SortTable

; 669  : 		out[(outLength)++]=orderedList[i];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	lea	ecx, DWORD PTR _orderedList$[ebp]
	call	??A?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QBEAAPAURow@Table@1@I@Z ; DataStructures::OrderedList<DataStructures::Table::Row *,DataStructures::Table::Row *,&RowSort>::operator[]
	mov	ecx, DWORD PTR _outLength$[ebp]
	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	ecx, DWORD PTR _outLength$[ebp]
	add	ecx, 1
	mov	DWORD PTR _outLength$[ebp], ecx
	jmp	SHORT $LN2@SortTable
$LN1@SortTable:

; 670  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _orderedList$[ebp]
	call	??1?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<DataStructures::Table::Row *,DataStructures::Table::Row *,&RowSort>::~OrderedList<DataStructures::Table::Row *,DataStructures::Table::Row *,&RowSort>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _columnIndices$[ebp]
	call	??1?$List@I@DataStructures@@QAE@XZ	; DataStructures::List<unsigned int>::~List<unsigned int>
$LN20@SortTable:
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN28@SortTable
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 304				; 00000130H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	2
$LN28@SortTable:
	DD	2
	DD	$LN27@SortTable
$LN27@SortTable:
	DD	-64					; ffffffc0H
	DD	12					; 0000000cH
	DD	$LN24@SortTable
	DD	-108					; ffffff94H
	DD	12					; 0000000cH
	DD	$LN25@SortTable
$LN25@SortTable:
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	76					; 0000004cH
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
$LN24@SortTable:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	110					; 0000006eH
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SortTable@Table@DataStructures@@QAEXPAUSortQuery@12@IPAPAURow@12@@Z$0:
	lea	ecx, DWORD PTR _columnIndices$[ebp]
	jmp	??1?$List@I@DataStructures@@QAE@XZ	; DataStructures::List<unsigned int>::~List<unsigned int>
__unwindfunclet$?SortTable@Table@DataStructures@@QAEXPAUSortQuery@12@IPAPAURow@12@@Z$1:
	lea	ecx, DWORD PTR _orderedList$[ebp]
	jmp	??1?$OrderedList@PAURow@Table@DataStructures@@PAU123@$1?RowSort@@YAHABQAU123@0@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<DataStructures::Table::Row *,DataStructures::Table::Row *,&RowSort>::~OrderedList<DataStructures::Table::Row *,DataStructures::Table::Row *,&RowSort>
__ehhandler$?SortTable@Table@DataStructures@@QAEXPAUSortQuery@12@IPAPAURow@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-308]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SortTable@Table@DataStructures@@QAEXPAUSortQuery@12@IPAPAURow@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SortTable@Table@DataStructures@@QAEXPAUSortQuery@12@IPAPAURow@12@@Z ENDP ; DataStructures::Table::SortTable
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ?QueryTable@Table@DataStructures@@QAEXPAIIPAUFilterQuery@12@I0IPAV12@@Z
_TEXT	SEGMENT
_row$2 = -96						; size = 4
_cur$3 = -84						; size = 4
_inclusionFilterColumnIndices$ = -72			; size = 12
_columnIndicesToReturn$ = -52				; size = 12
_i$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_columnSubset$ = 8					; size = 4
_numColumnSubset$ = 12					; size = 4
_inclusionFilters$ = 16					; size = 4
_numInclusionFilters$ = 20				; size = 4
_rowIds$ = 24						; size = 4
_numRowIDs$ = 28					; size = 4
_result$ = 32						; size = 4
?QueryTable@Table@DataStructures@@QAEXPAIIPAUFilterQuery@12@I0IPAV12@@Z PROC ; DataStructures::Table::QueryTable, COMDAT
; _this$ = ecx

; 390  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?QueryTable@Table@DataStructures@@QAEXPAIIPAUFilterQuery@12@I0IPAV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 280				; 00000118H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-292]
	mov	ecx, 70					; 00000046H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 391  : 	unsigned i;
; 392  : 	DataStructures::List<unsigned> columnIndicesToReturn;

	lea	ecx, DWORD PTR _columnIndicesToReturn$[ebp]
	call	??0?$List@I@DataStructures@@QAE@XZ	; DataStructures::List<unsigned int>::List<unsigned int>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 393  : 
; 394  : 	// Clear the result table.
; 395  : 	result->Clear();

	mov	ecx, DWORD PTR _result$[ebp]
	call	?Clear@Table@DataStructures@@QAEXXZ	; DataStructures::Table::Clear

; 396  : 
; 397  : 	if (columnSubset && numColumnSubset>0)

	cmp	DWORD PTR _columnSubset$[ebp], 0
	je	SHORT $LN31@QueryTable
	cmp	DWORD PTR _numColumnSubset$[ebp], 0
	jbe	SHORT $LN31@QueryTable

; 398  : 	{
; 399  : 		for (i=0; i < numColumnSubset; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN30@QueryTable
$LN29@QueryTable:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN30@QueryTable:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numColumnSubset$[ebp]
	jae	SHORT $LN28@QueryTable

; 400  : 		{
; 401  : 			if (columnSubset[i]>=0 && columnSubset[i]<columns.Size())

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _columnSubset$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	jb	SHORT $LN27@QueryTable
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?Size@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::Size
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _columnSubset$[ebp]
	cmp	DWORD PTR [edx+ecx*4], eax
	jae	SHORT $LN27@QueryTable

; 402  : 				columnIndicesToReturn.Insert(columnSubset[i]);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _columnSubset$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	lea	ecx, DWORD PTR _columnIndicesToReturn$[ebp]
	call	?Insert@?$List@I@DataStructures@@QAEXI@Z ; DataStructures::List<unsigned int>::Insert
$LN27@QueryTable:

; 403  : 		}

	jmp	SHORT $LN29@QueryTable
$LN28@QueryTable:

; 404  : 	}
; 405  : 	else

	jmp	SHORT $LN26@QueryTable
$LN31@QueryTable:

; 406  : 	{
; 407  : 		for (i=0; i < columns.Size(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN25@QueryTable
$LN24@QueryTable:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN25@QueryTable:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?Size@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN26@QueryTable

; 408  : 			columnIndicesToReturn.Insert(i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	lea	ecx, DWORD PTR _columnIndicesToReturn$[ebp]
	call	?Insert@?$List@I@DataStructures@@QAEXI@Z ; DataStructures::List<unsigned int>::Insert
	jmp	SHORT $LN24@QueryTable
$LN26@QueryTable:

; 409  : 	}
; 410  : 
; 411  : 	if (columnIndicesToReturn.Size()==0)

	lea	ecx, DWORD PTR _columnIndicesToReturn$[ebp]
	call	?Size@?$List@I@DataStructures@@QBEIXZ	; DataStructures::List<unsigned int>::Size
	test	eax, eax
	jne	SHORT $LN22@QueryTable

; 412  : 		return; // No valid columns specified

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _columnIndicesToReturn$[ebp]
	call	??1?$List@I@DataStructures@@QAE@XZ	; DataStructures::List<unsigned int>::~List<unsigned int>
	jmp	$LN32@QueryTable
$LN22@QueryTable:

; 413  : 
; 414  : 	for (i=0; i < columnIndicesToReturn.Size(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN21@QueryTable
$LN20@QueryTable:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN21@QueryTable:
	lea	ecx, DWORD PTR _columnIndicesToReturn$[ebp]
	call	?Size@?$List@I@DataStructures@@QBEIXZ	; DataStructures::List<unsigned int>::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN19@QueryTable

; 415  : 	{
; 416  : 		result->AddColumn(columns[columnIndicesToReturn[i]].columnName,columns[columnIndicesToReturn[i]].columnType);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	lea	ecx, DWORD PTR _columnIndicesToReturn$[ebp]
	call	??A?$List@I@DataStructures@@QBEAAII@Z	; DataStructures::List<unsigned int>::operator[]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??A?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEAAUColumnDescriptor@Table@1@I@Z ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::operator[]
	mov	edx, DWORD PTR [eax+32]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	lea	ecx, DWORD PTR _columnIndicesToReturn$[ebp]
	call	??A?$List@I@DataStructures@@QBEAAII@Z	; DataStructures::List<unsigned int>::operator[]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??A?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEAAUColumnDescriptor@Table@1@I@Z ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::operator[]
	push	eax
	mov	ecx, DWORD PTR _result$[ebp]
	call	?AddColumn@Table@DataStructures@@QAEIQADW4ColumnType@12@@Z ; DataStructures::Table::AddColumn

; 417  : 	}

	jmp	SHORT $LN20@QueryTable
$LN19@QueryTable:

; 418  : 
; 419  : 	// Get the column indices of the filter queries.
; 420  : 	DataStructures::List<unsigned> inclusionFilterColumnIndices;

	lea	ecx, DWORD PTR _inclusionFilterColumnIndices$[ebp]
	call	??0?$List@I@DataStructures@@QAE@XZ	; DataStructures::List<unsigned int>::List<unsigned int>
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 421  : 	if (inclusionFilters && numInclusionFilters>0)

	cmp	DWORD PTR _inclusionFilters$[ebp], 0
	je	SHORT $LN18@QueryTable
	cmp	DWORD PTR _numInclusionFilters$[ebp], 0
	jbe	SHORT $LN18@QueryTable

; 422  : 	{
; 423  : 		for (i=0; i < numInclusionFilters; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN17@QueryTable
$LN16@QueryTable:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN17@QueryTable:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numInclusionFilters$[ebp]
	jae	SHORT $LN18@QueryTable

; 424  : 		{
; 425  : 			if (inclusionFilters[i].columnIndex>=0 && inclusionFilters[i].columnIndex<columns.Size())

	imul	eax, DWORD PTR _i$[ebp], 12
	mov	ecx, DWORD PTR _inclusionFilters$[ebp]
	cmp	DWORD PTR [ecx+eax], 0
	jb	SHORT $LN14@QueryTable
	imul	esi, DWORD PTR _i$[ebp], 12
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?Size@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::Size
	mov	ecx, DWORD PTR _inclusionFilters$[ebp]
	cmp	DWORD PTR [ecx+esi], eax
	jae	SHORT $LN14@QueryTable

; 426  : 				inclusionFilterColumnIndices.Insert(inclusionFilters[i].columnIndex);

	imul	eax, DWORD PTR _i$[ebp], 12
	mov	ecx, DWORD PTR _inclusionFilters$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	lea	ecx, DWORD PTR _inclusionFilterColumnIndices$[ebp]
	call	?Insert@?$List@I@DataStructures@@QAEXI@Z ; DataStructures::List<unsigned int>::Insert

; 427  : 			else

	jmp	SHORT $LN13@QueryTable
$LN14@QueryTable:

; 428  : 				inclusionFilterColumnIndices.Insert((unsigned)-1);

	push	-1
	lea	ecx, DWORD PTR _inclusionFilterColumnIndices$[ebp]
	call	?Insert@?$List@I@DataStructures@@QAEXI@Z ; DataStructures::List<unsigned int>::Insert
$LN13@QueryTable:

; 429  : 		}

	jmp	SHORT $LN16@QueryTable
$LN18@QueryTable:

; 430  : 	}
; 431  : 
; 432  : 	if (rowIds==0 || numRowIDs==0)

	cmp	DWORD PTR _rowIds$[ebp], 0
	je	SHORT $LN11@QueryTable
	cmp	DWORD PTR _numRowIDs$[ebp], 0
	jne	SHORT $LN12@QueryTable
$LN11@QueryTable:

; 433  : 	{
; 434  : 		// All rows
; 435  : 		DataStructures::Page<unsigned, Row*, _TABLE_BPLUS_TREE_ORDER> *cur = rows.GetListHead();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetListHead@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QBEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@XZ ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::GetListHead
	mov	DWORD PTR _cur$3[ebp], eax
$LN10@QueryTable:

; 436  : 		while (cur)

	cmp	DWORD PTR _cur$3[ebp], 0
	je	SHORT $LN9@QueryTable

; 437  : 		{
; 438  : 			for (i=0; i < (unsigned)cur->size; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN8@QueryTable
$LN7@QueryTable:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN8@QueryTable:
	mov	eax, DWORD PTR _cur$3[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+1]
	jae	SHORT $LN6@QueryTable

; 439  : 			{
; 440  : 				QueryRow(inclusionFilterColumnIndices, columnIndicesToReturn, cur->keys[i], cur->data[i], inclusionFilters, result);

	mov	eax, DWORD PTR _result$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inclusionFilters$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _cur$3[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+69]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _cur$3[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+5]
	push	ecx
	lea	edx, DWORD PTR _columnIndicesToReturn$[ebp]
	push	edx
	lea	eax, DWORD PTR _inclusionFilterColumnIndices$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?QueryRow@Table@DataStructures@@IAEXAAV?$List@I@2@0IPAURow@12@PAUFilterQuery@12@PAV12@@Z ; DataStructures::Table::QueryRow

; 441  : 			}

	jmp	SHORT $LN7@QueryTable
$LN6@QueryTable:

; 442  : 			cur=cur->next;

	mov	eax, DWORD PTR _cur$3[ebp]
	mov	ecx, DWORD PTR [eax+133]
	mov	DWORD PTR _cur$3[ebp], ecx

; 443  : 		}

	jmp	SHORT $LN10@QueryTable
$LN9@QueryTable:

; 444  : 	}
; 445  : 	else

	jmp	SHORT $LN5@QueryTable
$LN12@QueryTable:

; 446  : 	{
; 447  : 		// Specific rows
; 448  : 		Row *row;
; 449  : 		for (i=0; i < numRowIDs; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@QueryTable
$LN3@QueryTable:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@QueryTable:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _numRowIDs$[ebp]
	jae	SHORT $LN5@QueryTable

; 450  : 		{
; 451  : 			if (rows.Get(rowIds[i], row))

	lea	eax, DWORD PTR _row$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _rowIds$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QBE_NIAAPAURow@Table@2@@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::Get
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@QueryTable

; 452  : 			{
; 453  : 				QueryRow(inclusionFilterColumnIndices, columnIndicesToReturn, rowIds[i], row, inclusionFilters, result);

	mov	eax, DWORD PTR _result$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inclusionFilters$[ebp]
	push	ecx
	mov	edx, DWORD PTR _row$2[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _rowIds$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	lea	eax, DWORD PTR _columnIndicesToReturn$[ebp]
	push	eax
	lea	ecx, DWORD PTR _inclusionFilterColumnIndices$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?QueryRow@Table@DataStructures@@IAEXAAV?$List@I@2@0IPAURow@12@PAUFilterQuery@12@PAV12@@Z ; DataStructures::Table::QueryRow
$LN1@QueryTable:

; 454  : 			}
; 455  : 		}

	jmp	SHORT $LN3@QueryTable
$LN5@QueryTable:

; 456  : 	}
; 457  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _inclusionFilterColumnIndices$[ebp]
	call	??1?$List@I@DataStructures@@QAE@XZ	; DataStructures::List<unsigned int>::~List<unsigned int>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _columnIndicesToReturn$[ebp]
	call	??1?$List@I@DataStructures@@QAE@XZ	; DataStructures::List<unsigned int>::~List<unsigned int>
$LN32@QueryTable:
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN41@QueryTable
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 292				; 00000124H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
	npad	2
$LN41@QueryTable:
	DD	3
	DD	$LN40@QueryTable
$LN40@QueryTable:
	DD	-52					; ffffffccH
	DD	12					; 0000000cH
	DD	$LN36@QueryTable
	DD	-72					; ffffffb8H
	DD	12					; 0000000cH
	DD	$LN37@QueryTable
	DD	-96					; ffffffa0H
	DD	4
	DD	$LN38@QueryTable
$LN38@QueryTable:
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	119					; 00000077H
	DB	0
$LN37@QueryTable:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	110					; 0000006eH
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	0
$LN36@QueryTable:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	110					; 0000006eH
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	84					; 00000054H
	DB	111					; 0000006fH
	DB	82					; 00000052H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?QueryTable@Table@DataStructures@@QAEXPAIIPAUFilterQuery@12@I0IPAV12@@Z$0:
	lea	ecx, DWORD PTR _columnIndicesToReturn$[ebp]
	jmp	??1?$List@I@DataStructures@@QAE@XZ	; DataStructures::List<unsigned int>::~List<unsigned int>
__unwindfunclet$?QueryTable@Table@DataStructures@@QAEXPAIIPAUFilterQuery@12@I0IPAV12@@Z$1:
	lea	ecx, DWORD PTR _inclusionFilterColumnIndices$[ebp]
	jmp	??1?$List@I@DataStructures@@QAE@XZ	; DataStructures::List<unsigned int>::~List<unsigned int>
__ehhandler$?QueryTable@Table@DataStructures@@QAEXPAIIPAUFilterQuery@12@I0IPAV12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-296]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?QueryTable@Table@DataStructures@@QAEXPAIIPAUFilterQuery@12@I0IPAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?QueryTable@Table@DataStructures@@QAEXPAIIPAUFilterQuery@12@I0IPAV12@@Z ENDP ; DataStructures::Table::QueryTable
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ?GetRowByIndex@Table@DataStructures@@QAEPAURow@12@I@Z
_TEXT	SEGMENT
_cur$ = -20						; size = 4
_this$ = -8						; size = 4
_rowIndex$ = 8						; size = 4
?GetRowByIndex@Table@DataStructures@@QAEPAURow@12@I@Z PROC ; DataStructures::Table::GetRowByIndex, COMDAT
; _this$ = ecx

; 374  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 	DataStructures::Page<unsigned, Row*, _TABLE_BPLUS_TREE_ORDER> *cur = rows.GetListHead();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetListHead@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QBEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@XZ ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::GetListHead
	mov	DWORD PTR _cur$[ebp], eax
$LN5@GetRowByIn:

; 376  : 	while (cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN4@GetRowByIn

; 377  : 	{
; 378  : 		if (rowIndex < (unsigned)cur->size)

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _rowIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+1]
	jae	SHORT $LN3@GetRowByIn

; 379  : 			return cur->data[rowIndex];

	mov	eax, DWORD PTR _rowIndex$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+69]
	jmp	SHORT $LN6@GetRowByIn
$LN3@GetRowByIn:

; 380  : 		if (rowIndex <= (unsigned)cur->size)

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _rowIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+1]
	ja	SHORT $LN2@GetRowByIn

; 381  : 			rowIndex-=cur->size;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _rowIndex$[ebp]
	sub	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR _rowIndex$[ebp], ecx

; 382  : 		else

	jmp	SHORT $LN1@GetRowByIn
$LN2@GetRowByIn:

; 383  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN6@GetRowByIn
$LN1@GetRowByIn:

; 384  : 		cur=cur->next;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+133]
	mov	DWORD PTR _cur$[ebp], ecx

; 385  : 	}

	jmp	SHORT $LN5@GetRowByIn
$LN4@GetRowByIn:

; 386  : 	return 0;

	xor	eax, eax
$LN6@GetRowByIn:

; 387  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetRowByIndex@Table@DataStructures@@QAEPAURow@12@I@Z ENDP ; DataStructures::Table::GetRowByIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ?GetRowByID@Table@DataStructures@@QAEPAURow@12@I@Z
_TEXT	SEGMENT
_row$ = -20						; size = 4
_this$ = -8						; size = 4
_rowId$ = 8						; size = 4
?GetRowByID@Table@DataStructures@@QAEPAURow@12@I@Z PROC	; DataStructures::Table::GetRowByID, COMDAT
; _this$ = ecx

; 366  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 367  : 	Row *row;
; 368  : 	if (rows.Get(rowId, row))

	lea	eax, DWORD PTR _row$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rowId$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QBE_NIAAPAURow@Table@2@@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::Get
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@GetRowByID

; 369  : 		return row;

	mov	eax, DWORD PTR _row$[ebp]
	jmp	SHORT $LN2@GetRowByID
$LN1@GetRowByID:

; 370  : 	return 0;

	xor	eax, eax
$LN2@GetRowByID:

; 371  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetRowByID
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$LN6@GetRowByID:
	DD	1
	DD	$LN5@GetRowByID
$LN5@GetRowByID:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN4@GetRowByID
$LN4@GetRowByID:
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	119					; 00000077H
	DB	0
?GetRowByID@Table@DataStructures@@QAEPAURow@12@I@Z ENDP	; DataStructures::Table::GetRowByID
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ?UpdateCell@Table@DataStructures@@QAE_NIIHPAD@Z
_TEXT	SEGMENT
_row$ = -20						; size = 4
_this$ = -8						; size = 4
_rowId$ = 8						; size = 4
_columnIndex$ = 12					; size = 4
_byteLength$ = 16					; size = 4
_data$ = 20						; size = 4
?UpdateCell@Table@DataStructures@@QAE_NIIHPAD@Z PROC	; DataStructures::Table::UpdateCell, COMDAT
; _this$ = ecx

; 340  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 341  : 	assert(columns[columnIndex].columnType==BINARY);

	mov	eax, DWORD PTR _columnIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??A?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEAAUColumnDescriptor@Table@1@I@Z ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::operator[]
	cmp	DWORD PTR [eax+32], 2
	je	SHORT $LN4@UpdateCell
	mov	ecx, DWORD PTR ?__LINE__Var@?1??UpdateCell@Table@DataStructures@@QAE_NIIHPAD@Z@4JA
	add	ecx, 1
	push	ecx
	push	OFFSET ??_C@_1EK@GEFGNEFE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAt?$AAa?$AAb?$AAl?$AAe@
	push	OFFSET ??_C@_1FA@OFEMIOAC@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?$FL?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?$FN?$AA?4?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAT?$AAy?$AAp?$AAe?$AA?$DN@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@UpdateCell:

; 342  : 
; 343  : 	Row *row = GetRowByID(rowId);

	mov	eax, DWORD PTR _rowId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRowByID@Table@DataStructures@@QAEPAURow@12@I@Z ; DataStructures::Table::GetRowByID
	mov	DWORD PTR _row$[ebp], eax

; 344  : 	if (row)

	cmp	DWORD PTR _row$[ebp], 0
	je	SHORT $LN1@UpdateCell

; 345  : 	{
; 346  : 		row->UpdateCell(columnIndex, byteLength, data);

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _byteLength$[ebp]
	push	ecx
	mov	edx, DWORD PTR _columnIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _row$[ebp]
	call	?UpdateCell@Row@Table@DataStructures@@QAEXIHPAD@Z ; DataStructures::Table::Row::UpdateCell

; 347  : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@UpdateCell
$LN1@UpdateCell:

; 348  : 	}
; 349  : 	return false;

	xor	al, al
$LN2@UpdateCell:

; 350  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?UpdateCell@Table@DataStructures@@QAE_NIIHPAD@Z ENDP	; DataStructures::Table::UpdateCell
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ?UpdateCell@Table@DataStructures@@QAE_NIIPAD@Z
_TEXT	SEGMENT
_row$ = -20						; size = 4
_this$ = -8						; size = 4
_rowId$ = 8						; size = 4
_columnIndex$ = 12					; size = 4
_str$ = 16						; size = 4
?UpdateCell@Table@DataStructures@@QAE_NIIPAD@Z PROC	; DataStructures::Table::UpdateCell, COMDAT
; _this$ = ecx

; 328  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 329  : 	assert(columns[columnIndex].columnType==STRING);

	mov	eax, DWORD PTR _columnIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??A?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEAAUColumnDescriptor@Table@1@I@Z ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::operator[]
	cmp	DWORD PTR [eax+32], 1
	je	SHORT $LN4@UpdateCell
	mov	ecx, DWORD PTR ?__LINE__Var@?1??UpdateCell@Table@DataStructures@@QAE_NIIPAD@Z@4JA
	add	ecx, 1
	push	ecx
	push	OFFSET ??_C@_1EK@GEFGNEFE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAt?$AAa?$AAb?$AAl?$AAe@
	push	OFFSET ??_C@_1FA@KGODCHJF@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?$FL?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?$FN?$AA?4?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAT?$AAy?$AAp?$AAe?$AA?$DN@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@UpdateCell:

; 330  : 
; 331  : 	Row *row = GetRowByID(rowId);

	mov	eax, DWORD PTR _rowId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRowByID@Table@DataStructures@@QAEPAURow@12@I@Z ; DataStructures::Table::GetRowByID
	mov	DWORD PTR _row$[ebp], eax

; 332  : 	if (row)

	cmp	DWORD PTR _row$[ebp], 0
	je	SHORT $LN1@UpdateCell

; 333  : 	{
; 334  : 		row->UpdateCell(columnIndex, str);

	mov	eax, DWORD PTR _str$[ebp]
	push	eax
	mov	ecx, DWORD PTR _columnIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _row$[ebp]
	call	?UpdateCell@Row@Table@DataStructures@@QAEXIPAD@Z ; DataStructures::Table::Row::UpdateCell

; 335  : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@UpdateCell
$LN1@UpdateCell:

; 336  : 	}
; 337  : 	return false;

	xor	al, al
$LN2@UpdateCell:

; 338  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?UpdateCell@Table@DataStructures@@QAE_NIIPAD@Z ENDP	; DataStructures::Table::UpdateCell
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ?UpdateCell@Table@DataStructures@@QAE_NIIH@Z
_TEXT	SEGMENT
_row$ = -20						; size = 4
_this$ = -8						; size = 4
_rowId$ = 8						; size = 4
_columnIndex$ = 12					; size = 4
_value$ = 16						; size = 4
?UpdateCell@Table@DataStructures@@QAE_NIIH@Z PROC	; DataStructures::Table::UpdateCell, COMDAT
; _this$ = ecx

; 316  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 317  : 	assert(columns[columnIndex].columnType==NUMERIC);

	mov	eax, DWORD PTR _columnIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??A?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEAAUColumnDescriptor@Table@1@I@Z ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::operator[]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN4@UpdateCell
	mov	ecx, DWORD PTR ?__LINE__Var@?1??UpdateCell@Table@DataStructures@@QAE_NIIH@Z@4JA
	add	ecx, 1
	push	ecx
	push	OFFSET ??_C@_1EK@GEFGNEFE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAt?$AAa?$AAb?$AAl?$AAe@
	push	OFFSET ??_C@_1FC@CHFBNAKC@?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAs?$AA?$FL?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?$FN?$AA?4?$AAc?$AAo?$AAl?$AAu?$AAm?$AAn?$AAT?$AAy?$AAp?$AAe?$AA?$DN@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@UpdateCell:

; 318  : 
; 319  : 	Row *row = GetRowByID(rowId);

	mov	eax, DWORD PTR _rowId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRowByID@Table@DataStructures@@QAEPAURow@12@I@Z ; DataStructures::Table::GetRowByID
	mov	DWORD PTR _row$[ebp], eax

; 320  : 	if (row)

	cmp	DWORD PTR _row$[ebp], 0
	je	SHORT $LN1@UpdateCell

; 321  : 	{
; 322  : 		row->UpdateCell(columnIndex, value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _columnIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _row$[ebp]
	call	?UpdateCell@Row@Table@DataStructures@@QAEXIH@Z ; DataStructures::Table::Row::UpdateCell

; 323  : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@UpdateCell
$LN1@UpdateCell:

; 324  : 	}
; 325  : 	return false;

	xor	al, al
$LN2@UpdateCell:

; 326  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?UpdateCell@Table@DataStructures@@QAE_NIIH@Z ENDP	; DataStructures::Table::UpdateCell
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ?RemoveRows@Table@DataStructures@@QAEXPAV12@@Z
_TEXT	SEGMENT
_cur$ = -32						; size = 4
_i$ = -20						; size = 4
_this$ = -8						; size = 4
_tableContainingRowIDs$ = 8				; size = 4
?RemoveRows@Table@DataStructures@@QAEXPAV12@@Z PROC	; DataStructures::Table::RemoveRows, COMDAT
; _this$ = ecx

; 302  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 303  : 	unsigned i;
; 304  : 	DataStructures::Page<unsigned, Row*, _TABLE_BPLUS_TREE_ORDER> *cur = tableContainingRowIDs->GetRows().GetListHead();

	mov	ecx, DWORD PTR _tableContainingRowIDs$[ebp]
	call	?GetRows@Table@DataStructures@@QAEAAV?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@2@XZ ; DataStructures::Table::GetRows
	mov	ecx, eax
	call	?GetListHead@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QBEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@XZ ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::GetListHead
	mov	DWORD PTR _cur$[ebp], eax
$LN5@RemoveRows:

; 305  : 	while (cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN6@RemoveRows

; 306  : 	{
; 307  : 		for (i=0; i < (unsigned)cur->size; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@RemoveRows
$LN2@RemoveRows:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@RemoveRows:
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+1]
	jae	SHORT $LN1@RemoveRows

; 308  : 		{
; 309  : 			rows.Delete(cur->keys[i]);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+5]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Delete@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAE_NI@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::Delete

; 310  : 		}

	jmp	SHORT $LN2@RemoveRows
$LN1@RemoveRows:

; 311  : 		cur=cur->next;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+133]
	mov	DWORD PTR _cur$[ebp], ecx

; 312  : 	}

	jmp	SHORT $LN5@RemoveRows
$LN6@RemoveRows:

; 313  : 	return;
; 314  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveRows@Table@DataStructures@@QAEXPAV12@@Z ENDP	; DataStructures::Table::RemoveRows
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ?RemoveRow@Table@DataStructures@@QAEXI@Z
_TEXT	SEGMENT
_out$ = -20						; size = 4
_this$ = -8						; size = 4
_rowId$ = 8						; size = 4
?RemoveRow@Table@DataStructures@@QAEXI@Z PROC		; DataStructures::Table::RemoveRow, COMDAT
; _this$ = ecx

; 296  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 297  : 	Row *out;
; 298  : 	if (rows.Delete(rowId, out))

	lea	eax, DWORD PTR _out$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rowId$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Delete@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAE_NIAAPAURow@Table@2@@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::Delete
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@RemoveRow

; 299  : 		DeleteRow(out);

	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DeleteRow@Table@DataStructures@@IAEXPAURow@12@@Z ; DataStructures::Table::DeleteRow
$LN2@RemoveRow:

; 300  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@RemoveRow
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN6@RemoveRow:
	DD	1
	DD	$LN5@RemoveRow
$LN5@RemoveRow:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN4@RemoveRow
$LN4@RemoveRow:
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	0
?RemoveRow@Table@DataStructures@@QAEXI@Z ENDP		; DataStructures::Table::RemoveRow
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ?AddRow@Table@DataStructures@@QAEPAURow@12@IAAV?$List@UCell@Table@DataStructures@@@2@@Z
_TEXT	SEGMENT
tv152 = -316						; size = 4
tv142 = -316						; size = 4
tv71 = -316						; size = 4
$T2 = -308						; size = 4
$T3 = -296						; size = 4
$T4 = -284						; size = 4
$T5 = -272						; size = 4
$T6 = -260						; size = 4
$T7 = -248						; size = 4
_rowIndex$ = -44					; size = 4
_newRow$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_rowId$ = 8						; size = 4
_initialCellValues$ = 12				; size = 4
?AddRow@Table@DataStructures@@QAEPAURow@12@IAAV?$List@UCell@Table@DataStructures@@@2@@Z PROC ; DataStructures::Table::AddRow, COMDAT
; _this$ = ecx

; 260  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddRow@Table@DataStructures@@QAEPAURow@12@IAAV?$List@UCell@Table@DataStructures@@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 304				; 00000130H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-316]
	mov	ecx, 76					; 0000004cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 261  : 	Row *newRow = new Row;

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN8@AddRow
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0Row@Table@DataStructures@@QAE@XZ
	mov	DWORD PTR tv71[ebp], eax
	jmp	SHORT $LN9@AddRow
$LN8@AddRow:
	mov	DWORD PTR tv71[ebp], 0
$LN9@AddRow:
	mov	eax, DWORD PTR tv71[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _newRow$[ebp], ecx

; 262  : 	unsigned rowIndex;
; 263  : 	for (rowIndex=0; rowIndex < columns.Size(); rowIndex++)

	mov	DWORD PTR _rowIndex$[ebp], 0
	jmp	SHORT $LN5@AddRow
$LN4@AddRow:
	mov	eax, DWORD PTR _rowIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _rowIndex$[ebp], eax
$LN5@AddRow:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?Size@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::Size
	cmp	DWORD PTR _rowIndex$[ebp], eax
	jae	$LN3@AddRow

; 264  : 	{
; 265  : 		if (rowIndex < initialCellValues.Size() && initialCellValues[rowIndex].isEmpty==false)

	mov	ecx, DWORD PTR _initialCellValues$[ebp]
	call	?Size@?$List@UCell@Table@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Table::Cell>::Size
	cmp	DWORD PTR _rowIndex$[ebp], eax
	jae	$LN2@AddRow
	mov	eax, DWORD PTR _rowIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _initialCellValues$[ebp]
	call	??A?$List@UCell@Table@DataStructures@@@DataStructures@@QBEAAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell>::operator[]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	$LN2@AddRow

; 266  : 			newRow->cells.Insert(new Table::Cell(initialCellValues[rowIndex].i, initialCellValues[rowIndex].c, columns[rowIndex].columnType));

	push	9
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN10@AddRow
	mov	eax, DWORD PTR _rowIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??A?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEAAUColumnDescriptor@Table@1@I@Z ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::operator[]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _rowIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _initialCellValues$[ebp]
	call	??A?$List@UCell@Table@DataStructures@@@DataStructures@@QBEAAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell>::operator[]
	mov	eax, DWORD PTR [eax+5]
	push	eax
	mov	ecx, DWORD PTR _rowIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _initialCellValues$[ebp]
	call	??A?$List@UCell@Table@DataStructures@@@DataStructures@@QBEAAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell>::operator[]
	mov	edx, DWORD PTR [eax+1]
	push	edx
	mov	ecx, DWORD PTR $T5[ebp]
	call	??0Cell@Table@DataStructures@@QAE@HPADW4ColumnType@12@@Z ; DataStructures::Table::Cell::Cell
	mov	DWORD PTR tv142[ebp], eax
	jmp	SHORT $LN11@AddRow
$LN10@AddRow:
	mov	DWORD PTR tv142[ebp], 0
$LN11@AddRow:
	mov	eax, DWORD PTR tv142[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newRow$[ebp]
	call	?Insert@?$List@PAUCell@Table@DataStructures@@@DataStructures@@QAEXQAUCell@Table@2@@Z ; DataStructures::List<DataStructures::Table::Cell *>::Insert

; 267  : 		else

	jmp	SHORT $LN1@AddRow
$LN2@AddRow:

; 268  : 			newRow->cells.Insert(new Table::Cell());

	push	9
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T7[ebp], 0
	je	SHORT $LN12@AddRow
	mov	ecx, DWORD PTR $T7[ebp]
	call	??0Cell@Table@DataStructures@@QAE@XZ	; DataStructures::Table::Cell::Cell
	mov	DWORD PTR tv152[ebp], eax
	jmp	SHORT $LN13@AddRow
$LN12@AddRow:
	mov	DWORD PTR tv152[ebp], 0
$LN13@AddRow:
	mov	eax, DWORD PTR tv152[ebp]
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T6[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newRow$[ebp]
	call	?Insert@?$List@PAUCell@Table@DataStructures@@@DataStructures@@QAEXQAUCell@Table@2@@Z ; DataStructures::List<DataStructures::Table::Cell *>::Insert
$LN1@AddRow:

; 269  : 	}

	jmp	$LN4@AddRow
$LN3@AddRow:

; 270  : 	rows.Insert(rowId, newRow);

	lea	eax, DWORD PTR _newRow$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rowId$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Insert@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAE_NIABQAURow@Table@2@@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::Insert

; 271  : 	return newRow;

	mov	eax, DWORD PTR _newRow$[ebp]

; 272  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN20@AddRow
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN20@AddRow:
	DD	1
	DD	$LN19@AddRow
$LN19@AddRow:
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN17@AddRow
$LN17@AddRow:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	82					; 00000052H
	DB	111					; 0000006fH
	DB	119					; 00000077H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddRow@Table@DataStructures@@QAEPAURow@12@IAAV?$List@UCell@Table@DataStructures@@@2@@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?AddRow@Table@DataStructures@@QAEPAURow@12@IAAV?$List@UCell@Table@DataStructures@@@2@@Z$1:
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?AddRow@Table@DataStructures@@QAEPAURow@12@IAAV?$List@UCell@Table@DataStructures@@@2@@Z$2:
	mov	eax, DWORD PTR $T7[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?AddRow@Table@DataStructures@@QAEPAURow@12@IAAV?$List@UCell@Table@DataStructures@@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-320]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddRow@Table@DataStructures@@QAEPAURow@12@IAAV?$List@UCell@Table@DataStructures@@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddRow@Table@DataStructures@@QAEPAURow@12@IAAV?$List@UCell@Table@DataStructures@@@2@@Z ENDP ; DataStructures::Table::AddRow
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ?AddRow@Table@DataStructures@@QAEPAURow@12@I@Z
_TEXT	SEGMENT
tv129 = -316						; size = 4
tv82 = -316						; size = 4
tv71 = -316						; size = 4
$T2 = -308						; size = 4
$T3 = -296						; size = 4
$T4 = -284						; size = 4
$T5 = -272						; size = 4
$T6 = -260						; size = 4
$T7 = -248						; size = 4
_rowIndex$ = -44					; size = 4
_newRow$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_rowId$ = 8						; size = 4
?AddRow@Table@DataStructures@@QAEPAURow@12@I@Z PROC	; DataStructures::Table::AddRow, COMDAT
; _this$ = ecx

; 246  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddRow@Table@DataStructures@@QAEPAURow@12@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 304				; 00000130H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-316]
	mov	ecx, 76					; 0000004cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 247  : 	Row *newRow;
; 248  : 	newRow = new Row;

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN7@AddRow
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0Row@Table@DataStructures@@QAE@XZ
	mov	DWORD PTR tv71[ebp], eax
	jmp	SHORT $LN8@AddRow
$LN7@AddRow:
	mov	DWORD PTR tv71[ebp], 0
$LN8@AddRow:
	mov	eax, DWORD PTR tv71[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _newRow$[ebp], ecx

; 249  : 	if (rows.Insert(rowId, newRow)==false)

	lea	eax, DWORD PTR _newRow$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rowId$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Insert@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAE_NIABQAURow@Table@2@@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::Insert
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN4@AddRow

; 250  : 	{
; 251  : 		delete newRow;

	mov	eax, DWORD PTR _newRow$[ebp]
	mov	DWORD PTR $T5[ebp], eax
	mov	ecx, DWORD PTR $T5[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN9@AddRow
	push	1
	mov	ecx, DWORD PTR $T4[ebp]
	call	??_GRow@Table@DataStructures@@QAEPAXI@Z
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $LN10@AddRow
$LN9@AddRow:
	mov	DWORD PTR tv82[ebp], 0
$LN10@AddRow:

; 252  : 		return 0; // Already exists

	xor	eax, eax
	jmp	$LN5@AddRow
$LN4@AddRow:

; 253  : 	}
; 254  : 	unsigned rowIndex;
; 255  : 	for (rowIndex=0; rowIndex < columns.Size(); rowIndex++)

	mov	DWORD PTR _rowIndex$[ebp], 0
	jmp	SHORT $LN3@AddRow
$LN2@AddRow:
	mov	eax, DWORD PTR _rowIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _rowIndex$[ebp], eax
$LN3@AddRow:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?Size@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::Size
	cmp	DWORD PTR _rowIndex$[ebp], eax
	jae	SHORT $LN1@AddRow

; 256  : 		newRow->cells.Insert( new Table::Cell() );

	push	9
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T7[ebp], 0
	je	SHORT $LN11@AddRow
	mov	ecx, DWORD PTR $T7[ebp]
	call	??0Cell@Table@DataStructures@@QAE@XZ	; DataStructures::Table::Cell::Cell
	mov	DWORD PTR tv129[ebp], eax
	jmp	SHORT $LN12@AddRow
$LN11@AddRow:
	mov	DWORD PTR tv129[ebp], 0
$LN12@AddRow:
	mov	eax, DWORD PTR tv129[ebp]
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T6[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newRow$[ebp]
	call	?Insert@?$List@PAUCell@Table@DataStructures@@@DataStructures@@QAEXQAUCell@Table@2@@Z ; DataStructures::List<DataStructures::Table::Cell *>::Insert
	jmp	SHORT $LN2@AddRow
$LN1@AddRow:

; 257  : 	return newRow;

	mov	eax, DWORD PTR _newRow$[ebp]
$LN5@AddRow:

; 258  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN18@AddRow
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN18@AddRow:
	DD	1
	DD	$LN17@AddRow
$LN17@AddRow:
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN15@AddRow
$LN15@AddRow:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	82					; 00000052H
	DB	111					; 0000006fH
	DB	119					; 00000077H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddRow@Table@DataStructures@@QAEPAURow@12@I@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?AddRow@Table@DataStructures@@QAEPAURow@12@I@Z$1:
	mov	eax, DWORD PTR $T7[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?AddRow@Table@DataStructures@@QAEPAURow@12@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-320]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddRow@Table@DataStructures@@QAEPAURow@12@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddRow@Table@DataStructures@@QAEPAURow@12@I@Z ENDP	; DataStructures::Table::AddRow
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ?GetRowCount@Table@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetRowCount@Table@DataStructures@@QBEIXZ PROC		; DataStructures::Table::GetRowCount, COMDAT
; _this$ = ecx

; 242  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 243  : 	return rows.Size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QBEIXZ ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::Size

; 244  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetRowCount@Table@DataStructures@@QBEIXZ ENDP		; DataStructures::Table::GetRowCount
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ?GetColumnCount@Table@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetColumnCount@Table@DataStructures@@QBEIXZ PROC	; DataStructures::Table::GetColumnCount, COMDAT
; _this$ = ecx

; 238  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 239  : 	return columns.Size();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?Size@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::Size

; 240  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetColumnCount@Table@DataStructures@@QBEIXZ ENDP	; DataStructures::Table::GetColumnCount
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ?GetColumnType@Table@DataStructures@@QAE?AW4ColumnType@12@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_index$ = 8						; size = 4
?GetColumnType@Table@DataStructures@@QAE?AW4ColumnType@12@I@Z PROC ; DataStructures::Table::GetColumnType, COMDAT
; _this$ = ecx

; 231  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 232  : 	if (index >= columns.Size())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?Size@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::Size
	cmp	DWORD PTR _index$[ebp], eax
	jb	SHORT $LN2@GetColumnT

; 233  : 		return (Table::ColumnType) 0;

	xor	eax, eax
	jmp	SHORT $LN3@GetColumnT

; 234  : 	else

	jmp	SHORT $LN3@GetColumnT
$LN2@GetColumnT:

; 235  : 		return columns[index].columnType;

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??A?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEAAUColumnDescriptor@Table@1@I@Z ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::operator[]
	mov	eax, DWORD PTR [eax+32]
$LN3@GetColumnT:

; 236  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetColumnType@Table@DataStructures@@QAE?AW4ColumnType@12@I@Z ENDP ; DataStructures::Table::GetColumnType
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ?ColumnName@Table@DataStructures@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_index$ = 8						; size = 4
?ColumnName@Table@DataStructures@@QAEPADI@Z PROC	; DataStructures::Table::ColumnName, COMDAT
; _this$ = ecx

; 224  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 225  : 	if (index >= columns.Size())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?Size@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::Size
	cmp	DWORD PTR _index$[ebp], eax
	jb	SHORT $LN2@ColumnName

; 226  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN3@ColumnName

; 227  : 	else

	jmp	SHORT $LN3@ColumnName
$LN2@ColumnName:

; 228  : 		return (char*)columns[index].columnName;

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??A?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEAAUColumnDescriptor@Table@1@I@Z ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::operator[]
$LN3@ColumnName:

; 229  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?ColumnName@Table@DataStructures@@QAEPADI@Z ENDP	; DataStructures::Table::ColumnName
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ?ColumnIndex@Table@DataStructures@@QAEIQAD@Z
_TEXT	SEGMENT
_columnIndex$ = -20					; size = 4
_this$ = -8						; size = 4
_columnName$ = 8					; size = 4
?ColumnIndex@Table@DataStructures@@QAEIQAD@Z PROC	; DataStructures::Table::ColumnIndex, COMDAT
; _this$ = ecx

; 216  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 217  : 	unsigned columnIndex;
; 218  : 	for (columnIndex=0; columnIndex<columns.Size(); columnIndex++)

	mov	DWORD PTR _columnIndex$[ebp], 0
	jmp	SHORT $LN4@ColumnInde
$LN3@ColumnInde:
	mov	eax, DWORD PTR _columnIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _columnIndex$[ebp], eax
$LN4@ColumnInde:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?Size@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::Size
	cmp	DWORD PTR _columnIndex$[ebp], eax
	jae	SHORT $LN2@ColumnInde

; 219  : 		if (strcmp(columnName, columns[columnIndex].columnName)==0)

	mov	eax, DWORD PTR _columnIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??A?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEAAUColumnDescriptor@Table@1@I@Z ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::operator[]
	push	eax
	mov	ecx, DWORD PTR _columnName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@ColumnInde

; 220  : 			return columnIndex;

	mov	eax, DWORD PTR _columnIndex$[ebp]
	jmp	SHORT $LN5@ColumnInde
$LN1@ColumnInde:

; 221  : 	return (unsigned)-1;

	jmp	SHORT $LN3@ColumnInde
$LN2@ColumnInde:
	or	eax, -1
$LN5@ColumnInde:

; 222  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?ColumnIndex@Table@DataStructures@@QAEIQAD@Z ENDP	; DataStructures::Table::ColumnIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ?RemoveColumn@Table@DataStructures@@QAEXI@Z
_TEXT	SEGMENT
tv89 = -256						; size = 4
$T1 = -248						; size = 4
$T2 = -236						; size = 4
_cur$ = -32						; size = 4
_i$ = -20						; size = 4
_this$ = -8						; size = 4
_columnIndex$ = 8					; size = 4
?RemoveColumn@Table@DataStructures@@QAEXI@Z PROC	; DataStructures::Table::RemoveColumn, COMDAT
; _this$ = ecx

; 195  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 196  : 	if (columnIndex >= columns.Size())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?Size@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::Size
	cmp	DWORD PTR _columnIndex$[ebp], eax
	jb	SHORT $LN6@RemoveColu

; 197  : 		return;

	jmp	$LN7@RemoveColu
$LN6@RemoveColu:

; 198  : 
; 199  : 	columns.RemoveAtIndex(columnIndex);

	mov	eax, DWORD PTR _columnIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?RemoveAtIndex@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QAEXI@Z ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::RemoveAtIndex

; 200  : 
; 201  : 	// Remove this index from each row.
; 202  : 	int i;
; 203  : 	DataStructures::Page<unsigned, Row*, _TABLE_BPLUS_TREE_ORDER> *cur = rows.GetListHead();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetListHead@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QBEPAU?$Page@IPAURow@Table@DataStructures@@$0BA@@2@XZ ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::GetListHead
	mov	DWORD PTR _cur$[ebp], eax
$LN5@RemoveColu:

; 204  : 	while (cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN7@RemoveColu

; 205  : 	{
; 206  : 		for (i=0; i < cur->size; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@RemoveColu
$LN2@RemoveColu:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@RemoveColu:
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+1]
	jge	SHORT $LN1@RemoveColu

; 207  : 		{
; 208  : 			delete cur->data[i]->cells[columnIndex];

	mov	eax, DWORD PTR _columnIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+69]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN9@RemoveColu
	push	1
	mov	ecx, DWORD PTR $T1[ebp]
	call	??_GCell@Table@DataStructures@@QAEPAXI@Z
	mov	DWORD PTR tv89[ebp], eax
	jmp	SHORT $LN10@RemoveColu
$LN9@RemoveColu:
	mov	DWORD PTR tv89[ebp], 0
$LN10@RemoveColu:

; 209  : 			cur->data[i]->cells.RemoveAtIndex(columnIndex);

	mov	eax, DWORD PTR _columnIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+69]
	call	?RemoveAtIndex@?$List@PAUCell@Table@DataStructures@@@DataStructures@@QAEXI@Z ; DataStructures::List<DataStructures::Table::Cell *>::RemoveAtIndex

; 210  : 		}

	jmp	SHORT $LN2@RemoveColu
$LN1@RemoveColu:

; 211  : 
; 212  : 		cur=cur->next;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+133]
	mov	DWORD PTR _cur$[ebp], ecx

; 213  : 	}

	jmp	$LN5@RemoveColu
$LN7@RemoveColu:

; 214  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveColumn@Table@DataStructures@@QAEXI@Z ENDP	; DataStructures::Table::RemoveColumn
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ?AddColumn@Table@DataStructures@@QAEIQADW4ColumnType@12@@Z
_TEXT	SEGMENT
tv85 = -272						; size = 4
tv86 = -268						; size = 4
$T2 = -260						; size = 36
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_columnName$ = 8					; size = 4
_columnType$ = 12					; size = 4
?AddColumn@Table@DataStructures@@QAEIQADW4ColumnType@12@@Z PROC ; DataStructures::Table::AddColumn, COMDAT
; _this$ = ecx

; 182  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddColumn@Table@DataStructures@@QAEIQADW4ColumnType@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 260				; 00000104H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-272]
	mov	ecx, 65					; 00000041H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 183  : 	if (columnName[0]==0)

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _columnName$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN1@AddColumn

; 184  : 		return (unsigned) -1;

	or	eax, -1
	jmp	SHORT $LN2@AddColumn
$LN1@AddColumn:

; 185  : 
; 186  : 	// Add this column.
; 187  : 	columns.Insert(Table::ColumnDescriptor(columnName, columnType));

	mov	eax, DWORD PTR _columnType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _columnName$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0ColumnDescriptor@Table@DataStructures@@QAE@QADW4ColumnType@12@@Z ; DataStructures::Table::ColumnDescriptor::ColumnDescriptor
	mov	DWORD PTR tv86[ebp], eax
	mov	edx, DWORD PTR tv86[ebp]
	mov	DWORD PTR tv85[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	esi, DWORD PTR tv85[ebp]
	sub	esp, 36					; 00000024H
	mov	ecx, 9
	mov	edi, esp
	rep movsd
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?Insert@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QAEXUColumnDescriptor@Table@2@@Z ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::Insert
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ColumnDescriptor@Table@DataStructures@@QAE@XZ ; DataStructures::Table::ColumnDescriptor::~ColumnDescriptor

; 188  : 
; 189  : 	// Extend the rows by one
; 190  : 	rows.ForEachData(ExtendRows);

	push	OFFSET ?ExtendRows@@YAXPAURow@Table@DataStructures@@H@Z ; ExtendRows
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ForEachData@?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAEXP6AXPAURow@Table@2@H@Z@Z ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::ForEachData

; 191  : 
; 192  : 	return columns.Size()-1;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?Size@?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QBEIXZ ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::Size
	sub	eax, 1
$LN2@AddColumn:

; 193  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 272				; 00000110H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddColumn@Table@DataStructures@@QAEIQADW4ColumnType@12@@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1ColumnDescriptor@Table@DataStructures@@QAE@XZ ; DataStructures::Table::ColumnDescriptor::~ColumnDescriptor
__ehhandler$?AddColumn@Table@DataStructures@@QAEIQADW4ColumnType@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-276]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddColumn@Table@DataStructures@@QAEIQADW4ColumnType@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddColumn@Table@DataStructures@@QAEIQADW4ColumnType@12@@Z ENDP ; DataStructures::Table::AddColumn
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ??1Table@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1Table@DataStructures@@QAE@XZ PROC			; DataStructures::Table::~Table, COMDAT
; _this$ = ecx

; 178  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1Table@DataStructures@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 179  : 	Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@Table@DataStructures@@QAEXXZ	; DataStructures::Table::Clear

; 180  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??1?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::~List<DataStructures::Table::ColumnDescriptor>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAE@XZ ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::~BPlusTree<unsigned int,DataStructures::Table::Row *,16>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1Table@DataStructures@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAE@XZ ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::~BPlusTree<unsigned int,DataStructures::Table::Row *,16>
__unwindfunclet$??1Table@DataStructures@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	??1?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::~List<DataStructures::Table::ColumnDescriptor>
__ehhandler$??1Table@DataStructures@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1Table@DataStructures@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1Table@DataStructures@@QAE@XZ ENDP			; DataStructures::Table::~Table
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ??0Table@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0Table@DataStructures@@QAE@XZ PROC			; DataStructures::Table::Table, COMDAT
; _this$ = ecx

; 175  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Table@DataStructures@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAE@XZ ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::BPlusTree<unsigned int,DataStructures::Table::Row *,16>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??0?$List@UColumnDescriptor@Table@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::List<DataStructures::Table::ColumnDescriptor>::List<DataStructures::Table::ColumnDescriptor>

; 176  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Table@DataStructures@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BPlusTree@IPAURow@Table@DataStructures@@$0BA@@DataStructures@@QAE@XZ ; DataStructures::BPlusTree<unsigned int,DataStructures::Table::Row *,16>::~BPlusTree<unsigned int,DataStructures::Table::Row *,16>
__ehhandler$??0Table@DataStructures@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Table@DataStructures@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Table@DataStructures@@QAE@XZ ENDP			; DataStructures::Table::Table
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ??0FilterQuery@Table@DataStructures@@QAE@IPAUCell@12@W4FilterQueryType@12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_column$ = 8						; size = 4
_cell$ = 12						; size = 4
_op$ = 16						; size = 4
??0FilterQuery@Table@DataStructures@@QAE@IPAUCell@12@W4FilterQueryType@12@@Z PROC ; DataStructures::Table::FilterQuery::FilterQuery, COMDAT
; _this$ = ecx

; 360  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 361  : 	columnIndex=column;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _column$[ebp]
	mov	DWORD PTR [eax], ecx

; 362  : 	cellValue=cell;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _cell$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 363  : 	operation=op;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _op$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 364  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0FilterQuery@Table@DataStructures@@QAE@IPAUCell@12@W4FilterQueryType@12@@Z ENDP ; DataStructures::Table::FilterQuery::FilterQuery
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ??1FilterQuery@Table@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1FilterQuery@Table@DataStructures@@QAE@XZ PROC	; DataStructures::Table::FilterQuery::~FilterQuery, COMDAT
; _this$ = ecx

; 356  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 357  : 
; 358  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1FilterQuery@Table@DataStructures@@QAE@XZ ENDP	; DataStructures::Table::FilterQuery::~FilterQuery
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ??0FilterQuery@Table@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0FilterQuery@Table@DataStructures@@QAE@XZ PROC	; DataStructures::Table::FilterQuery::FilterQuery, COMDAT
; _this$ = ecx

; 352  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 353  : 
; 354  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0FilterQuery@Table@DataStructures@@QAE@XZ ENDP	; DataStructures::Table::FilterQuery::FilterQuery
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GRow@Table@DataStructures@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GRow@Table@DataStructures@@QAEPAXI@Z PROC		; DataStructures::Table::Row::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Row@Table@DataStructures@@QAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GRow@Table@DataStructures@@QAEPAXI@Z ENDP		; DataStructures::Table::Row::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1Row@Table@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1Row@Table@DataStructures@@QAE@XZ PROC		; DataStructures::Table::Row::~Row, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$List@PAUCell@Table@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::List<DataStructures::Table::Cell *>::~List<DataStructures::Table::Cell *>
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1Row@Table@DataStructures@@QAE@XZ ENDP		; DataStructures::Table::Row::~Row
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0Row@Table@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0Row@Table@DataStructures@@QAE@XZ PROC		; DataStructures::Table::Row::Row, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$List@PAUCell@Table@DataStructures@@@DataStructures@@QAE@XZ ; DataStructures::List<DataStructures::Table::Cell *>::List<DataStructures::Table::Cell *>
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0Row@Table@DataStructures@@QAE@XZ ENDP		; DataStructures::Table::Row::Row
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ?UpdateCell@Row@Table@DataStructures@@QAEXIHPAD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_columnIndex$ = 8					; size = 4
_byteLength$ = 12					; size = 4
_data$ = 16						; size = 4
?UpdateCell@Row@Table@DataStructures@@QAEXIHPAD@Z PROC	; DataStructures::Table::Row::UpdateCell, COMDAT
; _this$ = ecx

; 170  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 171  : 	cells[columnIndex]->Clear();

	mov	eax, DWORD PTR _columnIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	ecx, DWORD PTR [eax]
	call	?Clear@Cell@Table@DataStructures@@QAEXXZ ; DataStructures::Table::Cell::Clear

; 172  : 	cells[columnIndex]->Set(data,byteLength);

	mov	eax, DWORD PTR _byteLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _columnIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	ecx, DWORD PTR [eax]
	call	?Set@Cell@Table@DataStructures@@QAEXPADH@Z ; DataStructures::Table::Cell::Set

; 173  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?UpdateCell@Row@Table@DataStructures@@QAEXIHPAD@Z ENDP	; DataStructures::Table::Row::UpdateCell
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ?UpdateCell@Row@Table@DataStructures@@QAEXIPAD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_columnIndex$ = 8					; size = 4
_str$ = 12						; size = 4
?UpdateCell@Row@Table@DataStructures@@QAEXIPAD@Z PROC	; DataStructures::Table::Row::UpdateCell, COMDAT
; _this$ = ecx

; 165  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 166  : 	cells[columnIndex]->Clear();

	mov	eax, DWORD PTR _columnIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	ecx, DWORD PTR [eax]
	call	?Clear@Cell@Table@DataStructures@@QAEXXZ ; DataStructures::Table::Cell::Clear

; 167  : 	cells[columnIndex]->Set(str);

	mov	eax, DWORD PTR _str$[ebp]
	push	eax
	mov	ecx, DWORD PTR _columnIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	ecx, DWORD PTR [eax]
	call	?Set@Cell@Table@DataStructures@@QAEXPAD@Z ; DataStructures::Table::Cell::Set

; 168  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?UpdateCell@Row@Table@DataStructures@@QAEXIPAD@Z ENDP	; DataStructures::Table::Row::UpdateCell
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ?UpdateCell@Row@Table@DataStructures@@QAEXIH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_columnIndex$ = 8					; size = 4
_value$ = 12						; size = 4
?UpdateCell@Row@Table@DataStructures@@QAEXIH@Z PROC	; DataStructures::Table::Row::UpdateCell, COMDAT
; _this$ = ecx

; 156  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 	cells[columnIndex]->Clear();

	mov	eax, DWORD PTR _columnIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	ecx, DWORD PTR [eax]
	call	?Clear@Cell@Table@DataStructures@@QAEXXZ ; DataStructures::Table::Cell::Clear

; 158  : 	cells[columnIndex]->Set(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _columnIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
	mov	ecx, DWORD PTR [eax]
	call	?Set@Cell@Table@DataStructures@@QAEXH@Z	; DataStructures::Table::Cell::Set

; 159  : 
; 160  : //	cells[columnIndex]->i=value;
; 161  : //	cells[columnIndex]->c=0;
; 162  : //	cells[columnIndex]->isEmpty=false;
; 163  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?UpdateCell@Row@Table@DataStructures@@QAEXIH@Z ENDP	; DataStructures::Table::Row::UpdateCell
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Size@?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEIXZ PROC ; DataStructures::List<DataStructures::Table::Cell *>::Size, COMDAT
; _this$ = ecx

; 373  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 374  : 		return list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 375  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEIXZ ENDP ; DataStructures::List<DataStructures::Table::Cell *>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Del@?$List@PAUCell@Table@DataStructures@@@DataStructures@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_num$ = 8						; size = 4
?Del@?$List@PAUCell@Table@DataStructures@@@DataStructures@@QAEXI@Z PROC ; DataStructures::List<DataStructures::Table::Cell *>::Del, COMDAT
; _this$ = ecx

; 353  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 354  : 		// Delete the last elements on the list.  No compression needed
; 355  : #ifdef _DEBUG
; 356  : 		assert(list_size>=num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _num$[ebp]
	jae	SHORT $LN3@Del
	push	356					; 00000164H
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1BO@JBFMBKMD@?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$DO?$AA?$DN?$AAn?$AAu?$AAm?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@Del:

; 357  : #endif
; 358  : 		list_size-=num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _num$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 359  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Del@?$List@PAUCell@Table@DataStructures@@@DataStructures@@QAEXI@Z ENDP ; DataStructures::List<DataStructures::Table::Cell *>::Del
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?RemoveAtIndex@?$List@PAUCell@Table@DataStructures@@@DataStructures@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
?RemoveAtIndex@?$List@PAUCell@Table@DataStructures@@@DataStructures@@QAEXI@Z PROC ; DataStructures::List<DataStructures::Table::Cell *>::RemoveAtIndex, COMDAT
; _this$ = ecx

; 333  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 334  : #ifdef _DEBUG
; 335  : 		assert( position < list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN4@RemoveAtIn
	push	335					; 0000014fH
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@RemoveAtIn:

; 336  : #endif
; 337  : 
; 338  : 		if ( position < list_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN2@RemoveAtIn

; 339  : 		{
; 340  : 			// Compress the array
; 341  : 			/*
; 342  : 			for ( unsigned int counter = position; counter < list_size - 1 ; ++counter )
; 343  : 			listArray[ counter ] = listArray[ counter + 1 ];
; 344  : 			*/
; 345  : 			memmove(listArray+position, listArray+position+1, (list_size-1-position) * sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	sub	ecx, DWORD PTR _position$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _position$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _position$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 346  : 
; 347  : 			Del();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Del@?$List@PAUCell@Table@DataStructures@@@DataStructures@@QAEXI@Z ; DataStructures::List<DataStructures::Table::Cell *>::Del
$LN2@RemoveAtIn:

; 348  : 		}
; 349  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveAtIndex@?$List@PAUCell@Table@DataStructures@@@DataStructures@@QAEXI@Z ENDP ; DataStructures::List<DataStructures::Table::Cell *>::RemoveAtIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Insert@?$List@PAUCell@Table@DataStructures@@@DataStructures@@QAEXQAUCell@Table@2@@Z
_TEXT	SEGMENT
$T1 = -236						; size = 4
$T2 = -224						; size = 4
_new_array$3 = -20					; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
?Insert@?$List@PAUCell@Table@DataStructures@@@DataStructures@@QAEXQAUCell@Table@2@@Z PROC ; DataStructures::List<DataStructures::Table::Cell *>::Insert, COMDAT
; _this$ = ecx

; 242  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 243  : 		// Reallocate list if necessary
; 244  : 
; 245  : 		if ( list_size == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	$LN3@Insert

; 246  : 		{
; 247  : 			// allocate twice the currently allocated memory
; 248  : 			list_type * new_array;
; 249  : 
; 250  : 			if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Insert

; 251  : 				allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 16			; 00000010H

; 252  : 			else

	jmp	SHORT $LN1@Insert
$LN2@Insert:

; 253  : 				allocation_size *= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN1@Insert:

; 254  : 
; 255  : 			new_array = new list_type [ allocation_size ];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _new_array$3[ebp], eax

; 256  : 
; 257  : 			// copy old array over
; 258  : 			//	for ( unsigned int counter = 0; counter < list_size; ++counter )
; 259  : 			//		new_array[ counter ] = listArray[ counter ];
; 260  : 
; 261  : 			// Don't call constructors, assignment operators, etc.
; 262  : 			memcpy(new_array, listArray, list_size*sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _new_array$3[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 263  : 
; 264  : 			// set old array to point to the newly allocated and twice as large array
; 265  : 			delete[] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 266  : 
; 267  : 			listArray = new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$3[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Insert:

; 268  : 		}
; 269  : 
; 270  : 		// Insert the new item at the correct spot
; 271  : 		listArray[ list_size ] = input;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _input$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 272  : 
; 273  : 		++list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 274  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Insert@?$List@PAUCell@Table@DataStructures@@@DataStructures@@QAEXQAUCell@Table@2@@Z ENDP ; DataStructures::List<DataStructures::Table::Cell *>::Insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z PROC ; DataStructures::List<DataStructures::Table::Cell *>::operator[], COMDAT
; _this$ = ecx

; 185  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 186  : #ifdef _DEBUG
; 187  : 		assert ( position < list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN3@operator
	push	187					; 000000bbH
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@operator:

; 188  : #endif
; 189  : 		return listArray[ position ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _position$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 190  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@PAUCell@Table@DataStructures@@@DataStructures@@QBEAAPAUCell@Table@1@I@Z ENDP ; DataStructures::List<DataStructures::Table::Cell *>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??1?$List@PAUCell@Table@DataStructures@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
??1?$List@PAUCell@Table@DataStructures@@@DataStructures@@QAE@XZ PROC ; DataStructures::List<DataStructures::Table::Cell *>::~List<DataStructures::Table::Cell *>, COMDAT
; _this$ = ecx

; 121  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 122  : 		if (allocation_size>0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jbe	SHORT $LN2@List

; 123  : 			delete [] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@List:

; 124  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@PAUCell@Table@DataStructures@@@DataStructures@@QAE@XZ ENDP ; DataStructures::List<DataStructures::Table::Cell *>::~List<DataStructures::Table::Cell *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??0?$List@PAUCell@Table@DataStructures@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$List@PAUCell@Table@DataStructures@@@DataStructures@@QAE@XZ PROC ; DataStructures::List<DataStructures::Table::Cell *>::List<DataStructures::Table::Cell *>, COMDAT
; _this$ = ecx

; 113  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 114  : 		allocation_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 115  : 		listArray = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 116  : 		list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 117  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@PAUCell@Table@DataStructures@@@DataStructures@@QAE@XZ ENDP ; DataStructures::List<DataStructures::Table::Cell *>::List<DataStructures::Table::Cell *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_EColumnDescriptor@Table@DataStructures@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_EColumnDescriptor@Table@DataStructures@@QAEPAXI@Z PROC ; DataStructures::Table::ColumnDescriptor::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector
	push	OFFSET ??1ColumnDescriptor@Table@DataStructures@@QAE@XZ ; DataStructures::Table::ColumnDescriptor::~ColumnDescriptor
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax-4]
	push	ecx
	push	36					; 00000024H
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@vector
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@vector:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector
$LN3@vector:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ColumnDescriptor@Table@DataStructures@@QAE@XZ ; DataStructures::Table::ColumnDescriptor::~ColumnDescriptor
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector:
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_EColumnDescriptor@Table@DataStructures@@QAEPAXI@Z ENDP ; DataStructures::Table::ColumnDescriptor::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ??0ColumnDescriptor@Table@DataStructures@@QAE@QADW4ColumnType@12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_cn$ = 8						; size = 4
_ct$ = 12						; size = 4
??0ColumnDescriptor@Table@DataStructures@@QAE@QADW4ColumnType@12@@Z PROC ; DataStructures::Table::ColumnDescriptor::ColumnDescriptor, COMDAT
; _this$ = ecx

; 151  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 152  : 	columnType=ct;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _ct$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 153  : 	strcpy(columnName, cn);

	mov	eax, DWORD PTR _cn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 154  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0ColumnDescriptor@Table@DataStructures@@QAE@QADW4ColumnType@12@@Z ENDP ; DataStructures::Table::ColumnDescriptor::ColumnDescriptor
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ??1ColumnDescriptor@Table@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1ColumnDescriptor@Table@DataStructures@@QAE@XZ PROC	; DataStructures::Table::ColumnDescriptor::~ColumnDescriptor, COMDAT
; _this$ = ecx

; 147  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 148  : 
; 149  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1ColumnDescriptor@Table@DataStructures@@QAE@XZ ENDP	; DataStructures::Table::ColumnDescriptor::~ColumnDescriptor
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ??0ColumnDescriptor@Table@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0ColumnDescriptor@Table@DataStructures@@QAE@XZ PROC	; DataStructures::Table::ColumnDescriptor::ColumnDescriptor, COMDAT
; _this$ = ecx

; 143  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 144  : 
; 145  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0ColumnDescriptor@Table@DataStructures@@QAE@XZ ENDP	; DataStructures::Table::ColumnDescriptor::ColumnDescriptor
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GCell@Table@DataStructures@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GCell@Table@DataStructures@@QAEPAXI@Z PROC		; DataStructures::Table::Cell::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Cell@Table@DataStructures@@QAE@XZ	; DataStructures::Table::Cell::~Cell
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCell@Table@DataStructures@@QAEPAXI@Z ENDP		; DataStructures::Table::Cell::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ??0Cell@Table@DataStructures@@QAE@ABU012@@Z
_TEXT	SEGMENT
$T1 = -224						; size = 4
$T2 = -212						; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
??0Cell@Table@DataStructures@@QAE@ABU012@@Z PROC	; DataStructures::Table::Cell::Cell, COMDAT
; _this$ = ecx

; 54   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 55   : 	isEmpty=input.isEmpty;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _input$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 56   : 	i=input.i;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [ecx+1]
	mov	DWORD PTR [eax+1], edx

; 57   : 	if (input.c)

	mov	eax, DWORD PTR _input$[ebp]
	cmp	DWORD PTR [eax+5], 0
	je	SHORT $LN3@Cell

; 58   : 	{
; 59   : 		if (c)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+5], 0
	je	SHORT $LN1@Cell

; 60   : 			delete [] c;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Cell:

; 61   : 		c = new char [i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR [edx+5], eax

; 62   : 		memcpy(c, input.c, i);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	push	ecx
	mov	edx, DWORD PTR _input$[ebp]
	mov	eax, DWORD PTR [edx+5]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN3@Cell:

; 63   : 	}
; 64   : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0Cell@Table@DataStructures@@QAE@ABU012@@Z ENDP	; DataStructures::Table::Cell::Cell
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ??4Cell@Table@DataStructures@@QAEAAU012@ABU012@@Z
_TEXT	SEGMENT
$T1 = -224						; size = 4
$T2 = -212						; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
??4Cell@Table@DataStructures@@QAEAAU012@ABU012@@Z PROC	; DataStructures::Table::Cell::operator=, COMDAT
; _this$ = ecx

; 41   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 42   : 	isEmpty=input.isEmpty;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _input$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 43   : 	i=input.i;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [ecx+1]
	mov	DWORD PTR [eax+1], edx

; 44   : 	if (input.c)

	mov	eax, DWORD PTR _input$[ebp]
	cmp	DWORD PTR [eax+5], 0
	je	SHORT $LN2@operator

; 45   : 	{
; 46   : 		if (c)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+5], 0
	je	SHORT $LN1@operator

; 47   : 			delete [] c;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@operator:

; 48   : 		c = new char [i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR [edx+5], eax

; 49   : 		memcpy(c, input.c, i);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	push	ecx
	mov	edx, DWORD PTR _input$[ebp]
	mov	eax, DWORD PTR [edx+5]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN2@operator:

; 50   : 	}
; 51   : 	return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 52   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4Cell@Table@DataStructures@@QAEAAU012@ABU012@@Z ENDP	; DataStructures::Table::Cell::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ?Get@Cell@Table@DataStructures@@QAEXPADPAH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_output$ = 8						; size = 4
_outputLength$ = 12					; size = 4
?Get@Cell@Table@DataStructures@@QAEXPADPAH@Z PROC	; DataStructures::Table::Cell::Get, COMDAT
; _this$ = ecx

; 113  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 114  : 	assert(isEmpty==false);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN4@Get
	mov	edx, DWORD PTR ?__LINE__Var@?1??Get@Cell@Table@DataStructures@@QAEXPADPAH@Z@4JA
	add	edx, 1
	push	edx
	push	OFFSET ??_C@_1EK@GEFGNEFE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAt?$AAa?$AAb?$AAl?$AAe@
	push	OFFSET ??_C@_1BO@OLJOILKC@?$AAi?$AAs?$AAE?$AAm?$AAp?$AAt?$AAy?$AA?$DN?$AA?$DN?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@Get:

; 115  : 	memcpy(output, c, i);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5]
	push	eax
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 116  : 	if (outputLength)

	cmp	DWORD PTR _outputLength$[ebp], 0
	je	SHORT $LN2@Get

; 117  : 		*outputLength=i;

	mov	eax, DWORD PTR _outputLength$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1]
	mov	DWORD PTR [eax], edx
$LN2@Get:

; 118  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?Get@Cell@Table@DataStructures@@QAEXPADPAH@Z ENDP	; DataStructures::Table::Cell::Get
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ?Get@Cell@Table@DataStructures@@QAEXPAD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_output$ = 8						; size = 4
?Get@Cell@Table@DataStructures@@QAEXPAD@Z PROC		; DataStructures::Table::Cell::Get, COMDAT
; _this$ = ecx

; 108  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 109  : 	assert(isEmpty==false);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@Get
	mov	edx, DWORD PTR ?__LINE__Var@?1??Get@Cell@Table@DataStructures@@QAEXPAD@Z@4JA
	add	edx, 1
	push	edx
	push	OFFSET ??_C@_1EK@GEFGNEFE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAt?$AAa?$AAb?$AAl?$AAe@
	push	OFFSET ??_C@_1BO@OLJOILKC@?$AAi?$AAs?$AAE?$AAm?$AAp?$AAt?$AAy?$AA?$DN?$AA?$DN?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@Get:

; 110  : 	strcpy(output, c);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5]
	push	ecx
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 111  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Get@Cell@Table@DataStructures@@QAEXPAD@Z ENDP		; DataStructures::Table::Cell::Get
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ?Get@Cell@Table@DataStructures@@QAEXPAH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_output$ = 8						; size = 4
?Get@Cell@Table@DataStructures@@QAEXPAH@Z PROC		; DataStructures::Table::Cell::Get, COMDAT
; _this$ = ecx

; 103  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 	assert(isEmpty==false);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@Get
	mov	edx, DWORD PTR ?__LINE__Var@?1??Get@Cell@Table@DataStructures@@QAEXPAH@Z@4JA
	add	edx, 1
	push	edx
	push	OFFSET ??_C@_1EK@GEFGNEFE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAt?$AAa?$AAb?$AAl?$AAe@
	push	OFFSET ??_C@_1BO@OLJOILKC@?$AAi?$AAs?$AAE?$AAm?$AAp?$AAt?$AAy?$AA?$DN?$AA?$DN?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@Get:

; 105  : 	*output=i;

	mov	eax, DWORD PTR _output$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1]
	mov	DWORD PTR [eax], edx

; 106  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Get@Cell@Table@DataStructures@@QAEXPAH@Z ENDP		; DataStructures::Table::Cell::Get
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ?Set@Cell@Table@DataStructures@@QAEXPADH@Z
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
_inputLength$ = 12					; size = 4
?Set@Cell@Table@DataStructures@@QAEXPADH@Z PROC		; DataStructures::Table::Cell::Set, COMDAT
; _this$ = ecx

; 87   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 88   : 	assert(isEmpty);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@Set
	mov	edx, DWORD PTR ?__LINE__Var@?1??Set@Cell@Table@DataStructures@@QAEXPADH@Z@4JA
	add	edx, 1
	push	edx
	push	OFFSET ??_C@_1EK@GEFGNEFE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAt?$AAa?$AAb?$AAl?$AAe@
	push	OFFSET ??_C@_1BA@MHHNNPBM@?$AAi?$AAs?$AAE?$AAm?$AAp?$AAt?$AAy?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN5@Set:

; 89   : 	if (input)

	cmp	DWORD PTR _input$[ebp], 0
	je	SHORT $LN2@Set

; 90   : 	{
; 91   : 		c = new char [inputLength];

	mov	eax, DWORD PTR _inputLength$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [ecx+5], edx

; 92   : 		i=inputLength;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _inputLength$[ebp]
	mov	DWORD PTR [eax+1], ecx

; 93   : 		memcpy(c, input, inputLength);

	mov	eax, DWORD PTR _inputLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _input$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+5]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 94   : 	}
; 95   : 	else

	jmp	SHORT $LN1@Set
$LN2@Set:

; 96   : 	{
; 97   : 		c=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+5], 0

; 98   : 		i=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1], 0
$LN1@Set:

; 99   : 	}
; 100  : 	isEmpty=false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax], 0

; 101  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?Set@Cell@Table@DataStructures@@QAEXPADH@Z ENDP		; DataStructures::Table::Cell::Set
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ?Set@Cell@Table@DataStructures@@QAEXPAD@Z
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
?Set@Cell@Table@DataStructures@@QAEXPAD@Z PROC		; DataStructures::Table::Cell::Set, COMDAT
; _this$ = ecx

; 73   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 74   : 	assert(isEmpty);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@Set
	mov	edx, DWORD PTR ?__LINE__Var@?1??Set@Cell@Table@DataStructures@@QAEXPAD@Z@4JA
	add	edx, 1
	push	edx
	push	OFFSET ??_C@_1EK@GEFGNEFE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAt?$AAa?$AAb?$AAl?$AAe@
	push	OFFSET ??_C@_1BA@MHHNNPBM@?$AAi?$AAs?$AAE?$AAm?$AAp?$AAt?$AAy?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN5@Set:

; 75   : 	if (input && input[0])

	cmp	DWORD PTR _input$[ebp], 0
	je	SHORT $LN2@Set
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _input$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	SHORT $LN2@Set

; 76   : 	{
; 77   : 		i=(int)strlen(input)+1;

	mov	eax, DWORD PTR _input$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1], eax

; 78   : 		c = new char [i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR [edx+5], eax

; 79   : 		strcpy(c, input);

	mov	eax, DWORD PTR _input$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+5]
	push	edx
	call	_strcpy
	add	esp, 8

; 80   : 	}
; 81   : 	else

	jmp	SHORT $LN1@Set
$LN2@Set:

; 82   : 		c=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+5], 0
$LN1@Set:

; 83   : 	i=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1], 0

; 84   : 	isEmpty=false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax], 0

; 85   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Set@Cell@Table@DataStructures@@QAEXPAD@Z ENDP		; DataStructures::Table::Cell::Set
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ?Set@Cell@Table@DataStructures@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_input$ = 8						; size = 4
?Set@Cell@Table@DataStructures@@QAEXH@Z PROC		; DataStructures::Table::Cell::Set, COMDAT
; _this$ = ecx

; 66   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 67   : 	assert(isEmpty);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@Set
	mov	edx, DWORD PTR ?__LINE__Var@?1??Set@Cell@Table@DataStructures@@QAEXH@Z@4JA
	add	edx, 1
	push	edx
	push	OFFSET ??_C@_1EK@GEFGNEFE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAt?$AAa?$AAb?$AAl?$AAe@
	push	OFFSET ??_C@_1BA@MHHNNPBM@?$AAi?$AAs?$AAE?$AAm?$AAp?$AAt?$AAy?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@Set:

; 68   : 	i=input;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _input$[ebp]
	mov	DWORD PTR [eax+1], ecx

; 69   : 	c=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+5], 0

; 70   : 	isEmpty=false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax], 0

; 71   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Set@Cell@Table@DataStructures@@QAEXH@Z ENDP		; DataStructures::Table::Cell::Set
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ?Clear@Cell@Table@DataStructures@@QAEXXZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
?Clear@Cell@Table@DataStructures@@QAEXXZ PROC		; DataStructures::Table::Cell::Clear, COMDAT
; _this$ = ecx

; 137  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 138  : 	if (isEmpty==false)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN1@Clear

; 139  : 		delete [] c;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+5]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Clear:

; 140  : 	isEmpty=true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax], 1

; 141  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@Cell@Table@DataStructures@@QAEXXZ ENDP		; DataStructures::Table::Cell::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ??0Cell@Table@DataStructures@@QAE@HPADW4ColumnType@12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_intValue$ = 8						; size = 4
_charValue$ = 12					; size = 4
_type$ = 16						; size = 4
??0Cell@Table@DataStructures@@QAE@HPADW4ColumnType@12@@Z PROC ; DataStructures::Table::Cell::Cell, COMDAT
; _this$ = ecx

; 120  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 121  : 	if (type==NUMERIC)

	cmp	DWORD PTR _type$[ebp], 0
	jne	SHORT $LN4@Cell

; 122  : 	{
; 123  : 		Set(intValue);

	mov	eax, DWORD PTR _intValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Set@Cell@Table@DataStructures@@QAEXH@Z	; DataStructures::Table::Cell::Set
	jmp	SHORT $LN3@Cell
$LN4@Cell:

; 124  : 	}
; 125  : 	else if (type==STRING)

	cmp	DWORD PTR _type$[ebp], 1
	jne	SHORT $LN2@Cell

; 126  : 	{
; 127  : 		Set(charValue);

	mov	eax, DWORD PTR _charValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Set@Cell@Table@DataStructures@@QAEXPAD@Z ; DataStructures::Table::Cell::Set

; 128  : 	}
; 129  : 	else

	jmp	SHORT $LN3@Cell
$LN2@Cell:

; 130  : 	{
; 131  : 		Set(charValue, intValue);

	mov	eax, DWORD PTR _intValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _charValue$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Set@Cell@Table@DataStructures@@QAEXPADH@Z ; DataStructures::Table::Cell::Set
$LN3@Cell:

; 132  : 	}
; 133  : 
; 134  : 	isEmpty=false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax], 0

; 135  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0Cell@Table@DataStructures@@QAE@HPADW4ColumnType@12@@Z ENDP ; DataStructures::Table::Cell::Cell
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ??1Cell@Table@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1Cell@Table@DataStructures@@QAE@XZ PROC		; DataStructures::Table::Cell::~Cell, COMDAT
; _this$ = ecx

; 37   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   : 	Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@Cell@Table@DataStructures@@QAEXXZ ; DataStructures::Table::Cell::Clear

; 39   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1Cell@Table@DataStructures@@QAE@XZ ENDP		; DataStructures::Table::Cell::~Cell
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_table.cpp
;	COMDAT ??0Cell@Table@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0Cell@Table@DataStructures@@QAE@XZ PROC		; DataStructures::Table::Cell::Cell, COMDAT
; _this$ = ecx

; 33   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 34   : 	isEmpty=true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax], 1

; 35   : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Cell@Table@DataStructures@@QAE@XZ ENDP		; DataStructures::Table::Cell::Cell
_TEXT	ENDS
END
