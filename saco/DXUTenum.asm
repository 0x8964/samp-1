; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.31101.0 

	TITLE	Z:\sampsrc\02Xu1\saco\d3d9\common\DXUTenum.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	?StringCopyWorkerA@@YGJPADIPBD@Z		; StringCopyWorkerA
PUBLIC	?StringCatWorkerA@@YGJPADIPBD@Z			; StringCatWorkerA
PUBLIC	?StringVPrintfWorkerA@@YGJPADIPBD0@Z		; StringVPrintfWorkerA
PUBLIC	?StringLengthWorkerA@@YGJPBDIPAI@Z		; StringLengthWorkerA
PUBLIC	?StringCchCatA@@YGJPADIPBD@Z			; StringCchCatA
PUBLIC	?StringCchPrintfA@@YAJPADIPBDZZ			; StringCchPrintfA
PUBLIC	?SetResolutionMinMax@CD3DEnumeration@@QAEXIIII@Z ; CD3DEnumeration::SetResolutionMinMax
PUBLIC	?SetRefreshMinMax@CD3DEnumeration@@QAEXII@Z	; CD3DEnumeration::SetRefreshMinMax
PUBLIC	?SetMultisampleQualityMax@CD3DEnumeration@@QAEXI@Z ; CD3DEnumeration::SetMultisampleQualityMax
PUBLIC	?GetPossibleVertexProcessingList@CD3DEnumeration@@QAEXPA_N000@Z ; CD3DEnumeration::GetPossibleVertexProcessingList
PUBLIC	?SetPossibleVertexProcessingList@CD3DEnumeration@@QAEX_N000@Z ; CD3DEnumeration::SetPossibleVertexProcessingList
PUBLIC	?GetPossibleDepthStencilFormatList@CD3DEnumeration@@QAEPAV?$CGrowableArray@W4_D3DFORMAT@@@@XZ ; CD3DEnumeration::GetPossibleDepthStencilFormatList
PUBLIC	?GetPossibleMultisampleTypeList@CD3DEnumeration@@QAEPAV?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@XZ ; CD3DEnumeration::GetPossibleMultisampleTypeList
PUBLIC	?GetPossiblePresentIntervalList@CD3DEnumeration@@QAEPAV?$CGrowableArray@I@@XZ ; CD3DEnumeration::GetPossiblePresentIntervalList
PUBLIC	?ResetPossibleDepthStencilFormats@CD3DEnumeration@@QAEXXZ ; CD3DEnumeration::ResetPossibleDepthStencilFormats
PUBLIC	?ResetPossibleMultisampleTypeList@CD3DEnumeration@@QAEXXZ ; CD3DEnumeration::ResetPossibleMultisampleTypeList
PUBLIC	?ResetPossiblePresentIntervalList@CD3DEnumeration@@QAEXXZ ; CD3DEnumeration::ResetPossiblePresentIntervalList
PUBLIC	?Enumerate@CD3DEnumeration@@QAEJPAUIDirect3D9@@P6G_NPAU_D3DCAPS9@@W4_D3DFORMAT@@2_NPAX@Z4@Z ; CD3DEnumeration::Enumerate
PUBLIC	?GetAdapterInfoList@CD3DEnumeration@@QAEPAV?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@XZ ; CD3DEnumeration::GetAdapterInfoList
PUBLIC	?GetAdapterInfo@CD3DEnumeration@@QAEPAVCD3DEnumAdapterInfo@@I@Z ; CD3DEnumeration::GetAdapterInfo
PUBLIC	?GetDeviceInfo@CD3DEnumeration@@QAEPAVCD3DEnumDeviceInfo@@IW4_D3DDEVTYPE@@@Z ; CD3DEnumeration::GetDeviceInfo
PUBLIC	?GetDeviceSettingsCombo@CD3DEnumeration@@QAEPAUCD3DEnumDeviceSettingsCombo@@IW4_D3DDEVTYPE@@W4_D3DFORMAT@@1H@Z ; CD3DEnumeration::GetDeviceSettingsCombo
PUBLIC	??1CD3DEnumeration@@QAE@XZ			; CD3DEnumeration::~CD3DEnumeration
PUBLIC	?DXUTGetEnumeration@@YAPAVCD3DEnumeration@@XZ	; DXUTGetEnumeration
PUBLIC	??0CD3DEnumeration@@AAE@XZ			; CD3DEnumeration::CD3DEnumeration
PUBLIC	??0?$CGrowableArray@W4_D3DFORMAT@@@@QAE@XZ	; CGrowableArray<enum _D3DFORMAT>::CGrowableArray<enum _D3DFORMAT>
PUBLIC	??1?$CGrowableArray@W4_D3DFORMAT@@@@QAE@XZ	; CGrowableArray<enum _D3DFORMAT>::~CGrowableArray<enum _D3DFORMAT>
PUBLIC	?SetSize@?$CGrowableArray@W4_D3DFORMAT@@@@QAEJH@Z ; CGrowableArray<enum _D3DFORMAT>::SetSize
PUBLIC	?Add@?$CGrowableArray@W4_D3DFORMAT@@@@QAEJABW4_D3DFORMAT@@@Z ; CGrowableArray<enum _D3DFORMAT>::Add
PUBLIC	?GetAt@?$CGrowableArray@W4_D3DFORMAT@@@@QAEAAW4_D3DFORMAT@@H@Z ; CGrowableArray<enum _D3DFORMAT>::GetAt
PUBLIC	?GetSize@?$CGrowableArray@W4_D3DFORMAT@@@@QBEHXZ ; CGrowableArray<enum _D3DFORMAT>::GetSize
PUBLIC	?Contains@?$CGrowableArray@W4_D3DFORMAT@@@@QAE_NABW4_D3DFORMAT@@@Z ; CGrowableArray<enum _D3DFORMAT>::Contains
PUBLIC	?IndexOf@?$CGrowableArray@W4_D3DFORMAT@@@@QAEHABW4_D3DFORMAT@@@Z ; CGrowableArray<enum _D3DFORMAT>::IndexOf
PUBLIC	?IndexOf@?$CGrowableArray@W4_D3DFORMAT@@@@QAEHABW4_D3DFORMAT@@HH@Z ; CGrowableArray<enum _D3DFORMAT>::IndexOf
PUBLIC	?RemoveAll@?$CGrowableArray@W4_D3DFORMAT@@@@QAEXXZ ; CGrowableArray<enum _D3DFORMAT>::RemoveAll
PUBLIC	?SetSizeInternal@?$CGrowableArray@W4_D3DFORMAT@@@@IAEJH@Z ; CGrowableArray<enum _D3DFORMAT>::SetSizeInternal
PUBLIC	??0?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAE@XZ ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::CGrowableArray<enum _D3DMULTISAMPLE_TYPE>
PUBLIC	??1?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAE@XZ ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::~CGrowableArray<enum _D3DMULTISAMPLE_TYPE>
PUBLIC	?SetSize@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEJH@Z ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::SetSize
PUBLIC	?Add@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEJABW4_D3DMULTISAMPLE_TYPE@@@Z ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::Add
PUBLIC	?GetAt@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEAAW4_D3DMULTISAMPLE_TYPE@@H@Z ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::GetAt
PUBLIC	?GetSize@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QBEHXZ ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::GetSize
PUBLIC	?RemoveAll@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEXXZ ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::RemoveAll
PUBLIC	?SetSizeInternal@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@IAEJH@Z ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::SetSizeInternal
PUBLIC	??0?$CGrowableArray@I@@QAE@XZ			; CGrowableArray<unsigned int>::CGrowableArray<unsigned int>
PUBLIC	??1?$CGrowableArray@I@@QAE@XZ			; CGrowableArray<unsigned int>::~CGrowableArray<unsigned int>
PUBLIC	?SetSize@?$CGrowableArray@I@@QAEJH@Z		; CGrowableArray<unsigned int>::SetSize
PUBLIC	?Add@?$CGrowableArray@I@@QAEJABI@Z		; CGrowableArray<unsigned int>::Add
PUBLIC	?GetAt@?$CGrowableArray@I@@QAEAAIH@Z		; CGrowableArray<unsigned int>::GetAt
PUBLIC	?GetSize@?$CGrowableArray@I@@QBEHXZ		; CGrowableArray<unsigned int>::GetSize
PUBLIC	?RemoveAll@?$CGrowableArray@I@@QAEXXZ		; CGrowableArray<unsigned int>::RemoveAll
PUBLIC	?SetSizeInternal@?$CGrowableArray@I@@IAEJH@Z	; CGrowableArray<unsigned int>::SetSizeInternal
PUBLIC	??0?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAE@XZ ; CGrowableArray<CD3DEnumAdapterInfo *>::CGrowableArray<CD3DEnumAdapterInfo *>
PUBLIC	??1?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAE@XZ ; CGrowableArray<CD3DEnumAdapterInfo *>::~CGrowableArray<CD3DEnumAdapterInfo *>
PUBLIC	?SetSize@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAEJH@Z ; CGrowableArray<CD3DEnumAdapterInfo *>::SetSize
PUBLIC	?Add@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAEJABQAVCD3DEnumAdapterInfo@@@Z ; CGrowableArray<CD3DEnumAdapterInfo *>::Add
PUBLIC	?GetAt@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAEAAPAVCD3DEnumAdapterInfo@@H@Z ; CGrowableArray<CD3DEnumAdapterInfo *>::GetAt
PUBLIC	?GetSize@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QBEHXZ ; CGrowableArray<CD3DEnumAdapterInfo *>::GetSize
PUBLIC	?RemoveAll@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAEXXZ ; CGrowableArray<CD3DEnumAdapterInfo *>::RemoveAll
PUBLIC	?SetSizeInternal@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@IAEJH@Z ; CGrowableArray<CD3DEnumAdapterInfo *>::SetSizeInternal
PUBLIC	?EnumerateDevices@CD3DEnumeration@@AAEJPAVCD3DEnumAdapterInfo@@PAV?$CGrowableArray@W4_D3DFORMAT@@@@@Z ; CD3DEnumeration::EnumerateDevices
PUBLIC	?EnumerateDeviceCombos@CD3DEnumeration@@AAEJPAVCD3DEnumAdapterInfo@@PAVCD3DEnumDeviceInfo@@PAV?$CGrowableArray@W4_D3DFORMAT@@@@@Z ; CD3DEnumeration::EnumerateDeviceCombos
PUBLIC	?BuildDepthStencilFormatList@CD3DEnumeration@@AAEXPAUCD3DEnumDeviceSettingsCombo@@@Z ; CD3DEnumeration::BuildDepthStencilFormatList
PUBLIC	?BuildMultiSampleTypeList@CD3DEnumeration@@AAEXPAUCD3DEnumDeviceSettingsCombo@@@Z ; CD3DEnumeration::BuildMultiSampleTypeList
PUBLIC	?BuildDSMSConflictList@CD3DEnumeration@@AAEXPAUCD3DEnumDeviceSettingsCombo@@@Z ; CD3DEnumeration::BuildDSMSConflictList
PUBLIC	?BuildPresentIntervalList@CD3DEnumeration@@AAEXPAVCD3DEnumDeviceInfo@@PAUCD3DEnumDeviceSettingsCombo@@@Z ; CD3DEnumeration::BuildPresentIntervalList
PUBLIC	?ClearAdapterInfoList@CD3DEnumeration@@AAEXXZ	; CD3DEnumeration::ClearAdapterInfoList
PUBLIC	??1CD3DEnumAdapterInfo@@QAE@XZ			; CD3DEnumAdapterInfo::~CD3DEnumAdapterInfo
PUBLIC	??0?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAE@XZ	; CGrowableArray<_D3DDISPLAYMODE>::CGrowableArray<_D3DDISPLAYMODE>
PUBLIC	??1?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAE@XZ	; CGrowableArray<_D3DDISPLAYMODE>::~CGrowableArray<_D3DDISPLAYMODE>
PUBLIC	?SetSize@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAEJH@Z ; CGrowableArray<_D3DDISPLAYMODE>::SetSize
PUBLIC	?Add@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAEJABU_D3DDISPLAYMODE@@@Z ; CGrowableArray<_D3DDISPLAYMODE>::Add
PUBLIC	?GetSize@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QBEHXZ ; CGrowableArray<_D3DDISPLAYMODE>::GetSize
PUBLIC	?GetData@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAEPAU_D3DDISPLAYMODE@@XZ ; CGrowableArray<_D3DDISPLAYMODE>::GetData
PUBLIC	?RemoveAll@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAEXXZ ; CGrowableArray<_D3DDISPLAYMODE>::RemoveAll
PUBLIC	?SetSizeInternal@?$CGrowableArray@U_D3DDISPLAYMODE@@@@IAEJH@Z ; CGrowableArray<_D3DDISPLAYMODE>::SetSizeInternal
PUBLIC	??0?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QAE@XZ ; CGrowableArray<CD3DEnumDeviceInfo *>::CGrowableArray<CD3DEnumDeviceInfo *>
PUBLIC	??1?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QAE@XZ ; CGrowableArray<CD3DEnumDeviceInfo *>::~CGrowableArray<CD3DEnumDeviceInfo *>
PUBLIC	?SetSize@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QAEJH@Z ; CGrowableArray<CD3DEnumDeviceInfo *>::SetSize
PUBLIC	?Add@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QAEJABQAVCD3DEnumDeviceInfo@@@Z ; CGrowableArray<CD3DEnumDeviceInfo *>::Add
PUBLIC	?GetAt@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QAEAAPAVCD3DEnumDeviceInfo@@H@Z ; CGrowableArray<CD3DEnumDeviceInfo *>::GetAt
PUBLIC	?GetSize@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QBEHXZ ; CGrowableArray<CD3DEnumDeviceInfo *>::GetSize
PUBLIC	?RemoveAll@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QAEXXZ ; CGrowableArray<CD3DEnumDeviceInfo *>::RemoveAll
PUBLIC	?SetSizeInternal@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@IAEJH@Z ; CGrowableArray<CD3DEnumDeviceInfo *>::SetSizeInternal
PUBLIC	??0CD3DEnumAdapterInfo@@QAE@XZ			; CD3DEnumAdapterInfo::CD3DEnumAdapterInfo
PUBLIC	??_GCD3DEnumAdapterInfo@@QAEPAXI@Z		; CD3DEnumAdapterInfo::`scalar deleting destructor'
PUBLIC	??1CD3DEnumDeviceInfo@@QAE@XZ			; CD3DEnumDeviceInfo::~CD3DEnumDeviceInfo
PUBLIC	??0?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QAE@XZ ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::CGrowableArray<CD3DEnumDeviceSettingsCombo *>
PUBLIC	??1?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QAE@XZ ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::~CGrowableArray<CD3DEnumDeviceSettingsCombo *>
PUBLIC	?SetSize@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QAEJH@Z ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::SetSize
PUBLIC	?Add@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QAEJABQAUCD3DEnumDeviceSettingsCombo@@@Z ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::Add
PUBLIC	?GetAt@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QAEAAPAUCD3DEnumDeviceSettingsCombo@@H@Z ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::GetAt
PUBLIC	?GetSize@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QBEHXZ ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::GetSize
PUBLIC	?RemoveAll@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QAEXXZ ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::RemoveAll
PUBLIC	?SetSizeInternal@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@IAEJH@Z ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::SetSizeInternal
PUBLIC	??0CD3DEnumDeviceInfo@@QAE@XZ			; CD3DEnumDeviceInfo::CD3DEnumDeviceInfo
PUBLIC	??_GCD3DEnumDeviceInfo@@QAEPAXI@Z		; CD3DEnumDeviceInfo::`scalar deleting destructor'
PUBLIC	??0?$CGrowableArray@K@@QAE@XZ			; CGrowableArray<unsigned long>::CGrowableArray<unsigned long>
PUBLIC	??1?$CGrowableArray@K@@QAE@XZ			; CGrowableArray<unsigned long>::~CGrowableArray<unsigned long>
PUBLIC	?SetSize@?$CGrowableArray@K@@QAEJH@Z		; CGrowableArray<unsigned long>::SetSize
PUBLIC	?Add@?$CGrowableArray@K@@QAEJABK@Z		; CGrowableArray<unsigned long>::Add
PUBLIC	?RemoveAll@?$CGrowableArray@K@@QAEXXZ		; CGrowableArray<unsigned long>::RemoveAll
PUBLIC	?SetSizeInternal@?$CGrowableArray@K@@IAEJH@Z	; CGrowableArray<unsigned long>::SetSizeInternal
PUBLIC	??0?$CGrowableArray@UCD3DEnumDSMSConflict@@@@QAE@XZ ; CGrowableArray<CD3DEnumDSMSConflict>::CGrowableArray<CD3DEnumDSMSConflict>
PUBLIC	??1?$CGrowableArray@UCD3DEnumDSMSConflict@@@@QAE@XZ ; CGrowableArray<CD3DEnumDSMSConflict>::~CGrowableArray<CD3DEnumDSMSConflict>
PUBLIC	?SetSize@?$CGrowableArray@UCD3DEnumDSMSConflict@@@@QAEJH@Z ; CGrowableArray<CD3DEnumDSMSConflict>::SetSize
PUBLIC	?Add@?$CGrowableArray@UCD3DEnumDSMSConflict@@@@QAEJABUCD3DEnumDSMSConflict@@@Z ; CGrowableArray<CD3DEnumDSMSConflict>::Add
PUBLIC	?RemoveAll@?$CGrowableArray@UCD3DEnumDSMSConflict@@@@QAEXXZ ; CGrowableArray<CD3DEnumDSMSConflict>::RemoveAll
PUBLIC	?SetSizeInternal@?$CGrowableArray@UCD3DEnumDSMSConflict@@@@IAEJH@Z ; CGrowableArray<CD3DEnumDSMSConflict>::SetSizeInternal
PUBLIC	??0CD3DEnumDeviceSettingsCombo@@QAE@XZ		; CD3DEnumDeviceSettingsCombo::CD3DEnumDeviceSettingsCombo
PUBLIC	??1CD3DEnumDeviceSettingsCombo@@QAE@XZ		; CD3DEnumDeviceSettingsCombo::~CD3DEnumDeviceSettingsCombo
PUBLIC	??_GCD3DEnumDeviceSettingsCombo@@QAEPAXI@Z	; CD3DEnumDeviceSettingsCombo::`scalar deleting destructor'
PUBLIC	?DXUTStencilBits@@YAIW4_D3DFORMAT@@@Z		; DXUTStencilBits
PUBLIC	?DXUTDepthBits@@YAIW4_D3DFORMAT@@@Z		; DXUTDepthBits
PUBLIC	?DXUTAlphaChannelBits@@YAIW4_D3DFORMAT@@@Z	; DXUTAlphaChannelBits
PUBLIC	?DXUTColorChannelBits@@YAIW4_D3DFORMAT@@@Z	; DXUTColorChannelBits
PUBLIC	??_C@_06FMMEGIIJ@?5?$CI?$CD?$CFd?$CJ?$AA@	; `string'
PUBLIC	??_C@_1FK@FIMIDMPE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@ ; `string'
PUBLIC	??_C@_1EA@JHMKKLFC@?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAm?$AA_?$AAn?$AAS?$AAi?$AAz?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@HLGKFCJM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@ ; `string'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	_strcpy:PROC
EXTRN	__stricmp:PROC
EXTRN	_qsort:PROC
EXTRN	_free:PROC
EXTRN	_realloc:PROC
EXTRN	__wassert:PROC
EXTRN	__vsnprintf:PROC
EXTRN	?DXUTGetD3DObject@@YAPAUIDirect3D9@@XZ:PROC	; DXUTGetD3DObject
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
?d3denum@?1??DXUTGetEnumeration@@YAPAVCD3DEnumeration@@XZ@4V2@A DB 05dH DUP (?) ; `DXUTGetEnumeration'::`2'::d3denum
	ALIGN	4

?$S1@?1??DXUTGetEnumeration@@YAPAVCD3DEnumeration@@XZ@4IA DD 01H DUP (?) ; `DXUTGetEnumeration'::`2'::$S1
_BSS	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_1M@HLGKFCJM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1M@HLGKFCJM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@ DB 'f', 00H, 'a', 00H
	DB	'l', 00H, 's', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@JHMKKLFC@?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAm?$AA_?$AAn?$AAS?$AAi?$AAz?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1EA@JHMKKLFC@?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAm?$AA_?$AAn?$AAS?$AAi?$AAz?$AAe?$AA?$AA@ DB 'n'
	DB	00H, 'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, ' ', 00H
	DB	'>', 00H, '=', 00H, ' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, 'n', 00H, 'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H
	DB	'x', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'm', 00H, '_', 00H, 'n'
	DB	00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FK@FIMIDMPE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
CONST	SEGMENT
??_C@_1FK@FIMIDMPE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@ DB 'z'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H
	DB	's', 00H, 'r', 00H, 'c', 00H, '\', 00H, '0', 00H, '2', 00H, 'x'
	DB	00H, 'u', 00H, '1', 00H, '\', 00H, 's', 00H, 'a', 00H, 'c', 00H
	DB	'o', 00H, '\', 00H, 'd', 00H, '3', 00H, 'd', 00H, '9', 00H, '\'
	DB	00H, 'c', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'o', 00H, 'n', 00H
	DB	'\', 00H, 'd', 00H, 'x', 00H, 'u', 00H, 't', 00H, 'm', 00H, 'i'
	DB	00H, 's', 00H, 'c', 00H, '.', 00H, 'h', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06FMMEGIIJ@?5?$CI?$CD?$CFd?$CJ?$AA@
CONST	SEGMENT
??_C@_06FMMEGIIJ@?5?$CI?$CD?$CFd?$CJ?$AA@ DB ' (#%d)', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CD3DEnumDeviceSettingsCombo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CD3DEnumDeviceSettingsCombo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CD3DEnumDeviceSettingsCombo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CD3DEnumDeviceSettingsCombo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CD3DEnumDeviceSettingsCombo@@QAE@XZ$3
__ehfuncinfo$??1CD3DEnumDeviceSettingsCombo@@QAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??1CD3DEnumDeviceSettingsCombo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CD3DEnumDeviceSettingsCombo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CD3DEnumDeviceSettingsCombo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CD3DEnumDeviceSettingsCombo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CD3DEnumDeviceSettingsCombo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CD3DEnumDeviceSettingsCombo@@QAE@XZ$3
__ehfuncinfo$??0CD3DEnumDeviceSettingsCombo@@QAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0CD3DEnumDeviceSettingsCombo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CD3DEnumDeviceInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CD3DEnumDeviceInfo@@QAE@XZ$0
__ehfuncinfo$??1CD3DEnumDeviceInfo@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CD3DEnumDeviceInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CD3DEnumAdapterInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CD3DEnumAdapterInfo@@QAE@XZ$0
__ehfuncinfo$??0CD3DEnumAdapterInfo@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CD3DEnumAdapterInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CD3DEnumAdapterInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CD3DEnumAdapterInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CD3DEnumAdapterInfo@@QAE@XZ$1
__ehfuncinfo$??1CD3DEnumAdapterInfo@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1CD3DEnumAdapterInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?EnumerateDeviceCombos@CD3DEnumeration@@AAEJPAVCD3DEnumAdapterInfo@@PAVCD3DEnumDeviceInfo@@PAV?$CGrowableArray@W4_D3DFORMAT@@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?EnumerateDeviceCombos@CD3DEnumeration@@AAEJPAVCD3DEnumAdapterInfo@@PAVCD3DEnumDeviceInfo@@PAV?$CGrowableArray@W4_D3DFORMAT@@@@@Z$0
__ehfuncinfo$?EnumerateDeviceCombos@CD3DEnumeration@@AAEJPAVCD3DEnumAdapterInfo@@PAVCD3DEnumDeviceInfo@@PAV?$CGrowableArray@W4_D3DFORMAT@@@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?EnumerateDeviceCombos@CD3DEnumeration@@AAEJPAVCD3DEnumAdapterInfo@@PAVCD3DEnumDeviceInfo@@PAV?$CGrowableArray@W4_D3DFORMAT@@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?EnumerateDevices@CD3DEnumeration@@AAEJPAVCD3DEnumAdapterInfo@@PAV?$CGrowableArray@W4_D3DFORMAT@@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?EnumerateDevices@CD3DEnumeration@@AAEJPAVCD3DEnumAdapterInfo@@PAV?$CGrowableArray@W4_D3DFORMAT@@@@@Z$0
__ehfuncinfo$?EnumerateDevices@CD3DEnumeration@@AAEJPAVCD3DEnumAdapterInfo@@PAV?$CGrowableArray@W4_D3DFORMAT@@@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?EnumerateDevices@CD3DEnumeration@@AAEJPAVCD3DEnumAdapterInfo@@PAV?$CGrowableArray@W4_D3DFORMAT@@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CD3DEnumeration@@AAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CD3DEnumeration@@AAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CD3DEnumeration@@AAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CD3DEnumeration@@AAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CD3DEnumeration@@AAE@XZ$3
__ehfuncinfo$??0CD3DEnumeration@@AAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0CD3DEnumeration@@AAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?DXUTGetEnumeration@@YAPAVCD3DEnumeration@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DXUTGetEnumeration@@YAPAVCD3DEnumeration@@XZ$0
__ehfuncinfo$?DXUTGetEnumeration@@YAPAVCD3DEnumeration@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DXUTGetEnumeration@@YAPAVCD3DEnumeration@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CD3DEnumeration@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CD3DEnumeration@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CD3DEnumeration@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CD3DEnumeration@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CD3DEnumeration@@QAE@XZ$3
__ehfuncinfo$??1CD3DEnumeration@@QAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??1CD3DEnumeration@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Enumerate@CD3DEnumeration@@QAEJPAUIDirect3D9@@P6G_NPAU_D3DCAPS9@@W4_D3DFORMAT@@2_NPAX@Z4@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Enumerate@CD3DEnumeration@@QAEJPAUIDirect3D9@@P6G_NPAU_D3DCAPS9@@W4_D3DFORMAT@@2_NPAX@Z4@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Enumerate@CD3DEnumeration@@QAEJPAUIDirect3D9@@P6G_NPAU_D3DCAPS9@@W4_D3DFORMAT@@2_NPAX@Z4@Z$1
__ehfuncinfo$?Enumerate@CD3DEnumeration@@QAEJPAUIDirect3D9@@P6G_NPAU_D3DCAPS9@@W4_D3DFORMAT@@2_NPAX@Z4@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Enumerate@CD3DEnumeration@@QAEJPAUIDirect3D9@@P6G_NPAU_D3DCAPS9@@W4_D3DFORMAT@@2_NPAX@Z4@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__Fd3denum@?1??DXUTGetEnumeration@@YAPAVCD3DEnumeration@@XZ@YAXXZ
text$yd	SEGMENT
??__Fd3denum@?1??DXUTGetEnumeration@@YAPAVCD3DEnumeration@@XZ@YAXXZ PROC ; `DXUTGetEnumeration'::`2'::`dynamic atexit destructor for 'd3denum'', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?d3denum@?1??DXUTGetEnumeration@@YAPAVCD3DEnumeration@@XZ@4V2@A
	call	??1CD3DEnumeration@@QAE@XZ		; CD3DEnumeration::~CD3DEnumeration
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__Fd3denum@?1??DXUTGetEnumeration@@YAPAVCD3DEnumeration@@XZ@YAXXZ ENDP ; `DXUTGetEnumeration'::`2'::`dynamic atexit destructor for 'd3denum''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutenum.cpp
;	COMDAT ?DXUTColorChannelBits@@YAIW4_D3DFORMAT@@@Z
_TEXT	SEGMENT
tv64 = -196						; size = 4
_fmt$ = 8						; size = 4
?DXUTColorChannelBits@@YAIW4_D3DFORMAT@@@Z PROC		; DXUTColorChannelBits, COMDAT

; 552  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 553  :     switch( fmt )

	mov	eax, DWORD PTR _fmt$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 20					; 00000014H
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 16			; 00000010H
	ja	SHORT $LN1@DXUTColorC
	mov	edx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN20@DXUTColorC[edx*4]
$LN15@DXUTColorC:

; 554  :     {
; 555  :         case D3DFMT_R8G8B8:
; 556  :             return 8;

	mov	eax, 8
	jmp	SHORT $LN18@DXUTColorC
$LN14@DXUTColorC:

; 557  :         case D3DFMT_A8R8G8B8:
; 558  :             return 8;

	mov	eax, 8
	jmp	SHORT $LN18@DXUTColorC
$LN13@DXUTColorC:

; 559  :         case D3DFMT_X8R8G8B8:
; 560  :             return 8;

	mov	eax, 8
	jmp	SHORT $LN18@DXUTColorC
$LN12@DXUTColorC:

; 561  :         case D3DFMT_R5G6B5:
; 562  :             return 5;

	mov	eax, 5
	jmp	SHORT $LN18@DXUTColorC
$LN11@DXUTColorC:

; 563  :         case D3DFMT_X1R5G5B5:
; 564  :             return 5;

	mov	eax, 5
	jmp	SHORT $LN18@DXUTColorC
$LN10@DXUTColorC:

; 565  :         case D3DFMT_A1R5G5B5:
; 566  :             return 5;

	mov	eax, 5
	jmp	SHORT $LN18@DXUTColorC
$LN9@DXUTColorC:

; 567  :         case D3DFMT_A4R4G4B4:
; 568  :             return 4;

	mov	eax, 4
	jmp	SHORT $LN18@DXUTColorC
$LN8@DXUTColorC:

; 569  :         case D3DFMT_R3G3B2:
; 570  :             return 2;

	mov	eax, 2
	jmp	SHORT $LN18@DXUTColorC
$LN7@DXUTColorC:

; 571  :         case D3DFMT_A8R3G3B2:
; 572  :             return 2;

	mov	eax, 2
	jmp	SHORT $LN18@DXUTColorC
$LN6@DXUTColorC:

; 573  :         case D3DFMT_X4R4G4B4:
; 574  :             return 4;

	mov	eax, 4
	jmp	SHORT $LN18@DXUTColorC
$LN5@DXUTColorC:

; 575  :         case D3DFMT_A2B10G10R10:
; 576  :             return 10;

	mov	eax, 10					; 0000000aH
	jmp	SHORT $LN18@DXUTColorC
$LN4@DXUTColorC:

; 577  :         case D3DFMT_A8B8G8R8:
; 578  :             return 8;

	mov	eax, 8
	jmp	SHORT $LN18@DXUTColorC
$LN3@DXUTColorC:

; 579  :         case D3DFMT_A2R10G10B10:
; 580  :             return 10;

	mov	eax, 10					; 0000000aH
	jmp	SHORT $LN18@DXUTColorC
$LN2@DXUTColorC:

; 581  :         case D3DFMT_A16B16G16R16:
; 582  :             return 16;

	mov	eax, 16					; 00000010H
	jmp	SHORT $LN18@DXUTColorC
$LN1@DXUTColorC:

; 583  :         default:
; 584  :             return 0;

	xor	eax, eax
$LN18@DXUTColorC:

; 585  :     }
; 586  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN20@DXUTColorC:
	DD	$LN15@DXUTColorC
	DD	$LN14@DXUTColorC
	DD	$LN13@DXUTColorC
	DD	$LN12@DXUTColorC
	DD	$LN11@DXUTColorC
	DD	$LN10@DXUTColorC
	DD	$LN9@DXUTColorC
	DD	$LN8@DXUTColorC
	DD	$LN1@DXUTColorC
	DD	$LN7@DXUTColorC
	DD	$LN6@DXUTColorC
	DD	$LN5@DXUTColorC
	DD	$LN4@DXUTColorC
	DD	$LN1@DXUTColorC
	DD	$LN1@DXUTColorC
	DD	$LN3@DXUTColorC
	DD	$LN2@DXUTColorC
?DXUTColorChannelBits@@YAIW4_D3DFORMAT@@@Z ENDP		; DXUTColorChannelBits
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutenum.cpp
;	COMDAT ?DXUTAlphaChannelBits@@YAIW4_D3DFORMAT@@@Z
_TEXT	SEGMENT
tv64 = -196						; size = 4
_fmt$ = 8						; size = 4
?DXUTAlphaChannelBits@@YAIW4_D3DFORMAT@@@Z PROC		; DXUTAlphaChannelBits, COMDAT

; 595  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 596  :     switch( fmt )

	mov	eax, DWORD PTR _fmt$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 20					; 00000014H
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 16			; 00000010H
	ja	SHORT $LN1@DXUTAlphaC
	mov	edx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN20@DXUTAlphaC[edx*4]
$LN15@DXUTAlphaC:

; 597  :     {
; 598  :         case D3DFMT_R8G8B8:
; 599  :             return 0;

	xor	eax, eax
	jmp	SHORT $LN18@DXUTAlphaC
$LN14@DXUTAlphaC:

; 600  :         case D3DFMT_A8R8G8B8:
; 601  :             return 8;

	mov	eax, 8
	jmp	SHORT $LN18@DXUTAlphaC
$LN13@DXUTAlphaC:

; 602  :         case D3DFMT_X8R8G8B8:
; 603  :             return 0;

	xor	eax, eax
	jmp	SHORT $LN18@DXUTAlphaC
$LN12@DXUTAlphaC:

; 604  :         case D3DFMT_R5G6B5:
; 605  :             return 0;

	xor	eax, eax
	jmp	SHORT $LN18@DXUTAlphaC
$LN11@DXUTAlphaC:

; 606  :         case D3DFMT_X1R5G5B5:
; 607  :             return 0;

	xor	eax, eax
	jmp	SHORT $LN18@DXUTAlphaC
$LN10@DXUTAlphaC:

; 608  :         case D3DFMT_A1R5G5B5:
; 609  :             return 1;

	mov	eax, 1
	jmp	SHORT $LN18@DXUTAlphaC
$LN9@DXUTAlphaC:

; 610  :         case D3DFMT_A4R4G4B4:
; 611  :             return 4;

	mov	eax, 4
	jmp	SHORT $LN18@DXUTAlphaC
$LN8@DXUTAlphaC:

; 612  :         case D3DFMT_R3G3B2:
; 613  :             return 0;

	xor	eax, eax
	jmp	SHORT $LN18@DXUTAlphaC
$LN7@DXUTAlphaC:

; 614  :         case D3DFMT_A8R3G3B2:
; 615  :             return 8;

	mov	eax, 8
	jmp	SHORT $LN18@DXUTAlphaC
$LN6@DXUTAlphaC:

; 616  :         case D3DFMT_X4R4G4B4:
; 617  :             return 0;

	xor	eax, eax
	jmp	SHORT $LN18@DXUTAlphaC
$LN5@DXUTAlphaC:

; 618  :         case D3DFMT_A2B10G10R10:
; 619  :             return 2;

	mov	eax, 2
	jmp	SHORT $LN18@DXUTAlphaC
$LN4@DXUTAlphaC:

; 620  :         case D3DFMT_A8B8G8R8:
; 621  :             return 8;

	mov	eax, 8
	jmp	SHORT $LN18@DXUTAlphaC
$LN3@DXUTAlphaC:

; 622  :         case D3DFMT_A2R10G10B10:
; 623  :             return 2;

	mov	eax, 2
	jmp	SHORT $LN18@DXUTAlphaC
$LN2@DXUTAlphaC:

; 624  :         case D3DFMT_A16B16G16R16:
; 625  :             return 16;

	mov	eax, 16					; 00000010H
	jmp	SHORT $LN18@DXUTAlphaC
$LN1@DXUTAlphaC:

; 626  :         default:
; 627  :             return 0;

	xor	eax, eax
$LN18@DXUTAlphaC:

; 628  :     }
; 629  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN20@DXUTAlphaC:
	DD	$LN15@DXUTAlphaC
	DD	$LN14@DXUTAlphaC
	DD	$LN13@DXUTAlphaC
	DD	$LN12@DXUTAlphaC
	DD	$LN11@DXUTAlphaC
	DD	$LN10@DXUTAlphaC
	DD	$LN9@DXUTAlphaC
	DD	$LN8@DXUTAlphaC
	DD	$LN1@DXUTAlphaC
	DD	$LN7@DXUTAlphaC
	DD	$LN6@DXUTAlphaC
	DD	$LN5@DXUTAlphaC
	DD	$LN4@DXUTAlphaC
	DD	$LN1@DXUTAlphaC
	DD	$LN1@DXUTAlphaC
	DD	$LN3@DXUTAlphaC
	DD	$LN2@DXUTAlphaC
?DXUTAlphaChannelBits@@YAIW4_D3DFORMAT@@@Z ENDP		; DXUTAlphaChannelBits
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutenum.cpp
;	COMDAT ?DXUTDepthBits@@YAIW4_D3DFORMAT@@@Z
_TEXT	SEGMENT
tv64 = -196						; size = 4
_fmt$ = 8						; size = 4
?DXUTDepthBits@@YAIW4_D3DFORMAT@@@Z PROC		; DXUTDepthBits, COMDAT

; 638  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 639  :     switch( fmt )

	mov	eax, DWORD PTR _fmt$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 70					; 00000046H
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 13			; 0000000dH
	ja	SHORT $LN1@DXUTDepthB
	mov	edx, DWORD PTR tv64[ebp]
	movzx	eax, BYTE PTR $LN10@DXUTDepthB[edx]
	jmp	DWORD PTR $LN11@DXUTDepthB[eax*4]
$LN5@DXUTDepthB:

; 640  :     {
; 641  :         case D3DFMT_D32F_LOCKABLE:
; 642  :         case D3DFMT_D32:
; 643  :             return 32;

	mov	eax, 32					; 00000020H
	jmp	SHORT $LN8@DXUTDepthB
$LN4@DXUTDepthB:

; 644  : 
; 645  :         case D3DFMT_D24X8:
; 646  :         case D3DFMT_D24S8:
; 647  :         case D3DFMT_D24X4S4:
; 648  :         case D3DFMT_D24FS8:
; 649  :             return 24;

	mov	eax, 24					; 00000018H
	jmp	SHORT $LN8@DXUTDepthB
$LN3@DXUTDepthB:

; 650  : 
; 651  :         case D3DFMT_D16_LOCKABLE:
; 652  :         case D3DFMT_D16:
; 653  :             return 16;

	mov	eax, 16					; 00000010H
	jmp	SHORT $LN8@DXUTDepthB
$LN2@DXUTDepthB:

; 654  : 
; 655  :         case D3DFMT_D15S1:
; 656  :             return 15;

	mov	eax, 15					; 0000000fH
	jmp	SHORT $LN8@DXUTDepthB
$LN1@DXUTDepthB:

; 657  : 
; 658  :         default:
; 659  :             return 0;

	xor	eax, eax
$LN8@DXUTDepthB:

; 660  :     }
; 661  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@DXUTDepthB:
	DD	$LN3@DXUTDepthB
	DD	$LN5@DXUTDepthB
	DD	$LN2@DXUTDepthB
	DD	$LN4@DXUTDepthB
	DD	$LN1@DXUTDepthB
$LN10@DXUTDepthB:
	DB	0
	DB	1
	DB	4
	DB	2
	DB	4
	DB	3
	DB	4
	DB	3
	DB	4
	DB	3
	DB	0
	DB	4
	DB	1
	DB	3
?DXUTDepthBits@@YAIW4_D3DFORMAT@@@Z ENDP		; DXUTDepthBits
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutenum.cpp
;	COMDAT ?DXUTStencilBits@@YAIW4_D3DFORMAT@@@Z
_TEXT	SEGMENT
tv64 = -196						; size = 4
_fmt$ = 8						; size = 4
?DXUTStencilBits@@YAIW4_D3DFORMAT@@@Z PROC		; DXUTStencilBits, COMDAT

; 670  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 671  :     switch( fmt )

	mov	eax, DWORD PTR _fmt$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 70					; 00000046H
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 13			; 0000000dH
	ja	SHORT $LN1@DXUTStenci
	mov	edx, DWORD PTR tv64[ebp]
	movzx	eax, BYTE PTR $LN10@DXUTStenci[edx]
	jmp	DWORD PTR $LN11@DXUTStenci[eax*4]
$LN5@DXUTStenci:

; 672  :     {
; 673  :         case D3DFMT_D16_LOCKABLE:
; 674  :         case D3DFMT_D16:
; 675  :         case D3DFMT_D32F_LOCKABLE:
; 676  :         case D3DFMT_D32:
; 677  :         case D3DFMT_D24X8:
; 678  :             return 0;

	xor	eax, eax
	jmp	SHORT $LN8@DXUTStenci
$LN4@DXUTStenci:

; 679  : 
; 680  :         case D3DFMT_D15S1:
; 681  :             return 1;

	mov	eax, 1
	jmp	SHORT $LN8@DXUTStenci
$LN3@DXUTStenci:

; 682  : 
; 683  :         case D3DFMT_D24X4S4:
; 684  :             return 4;

	mov	eax, 4
	jmp	SHORT $LN8@DXUTStenci
$LN2@DXUTStenci:

; 685  : 
; 686  :         case D3DFMT_D24S8:
; 687  :         case D3DFMT_D24FS8:
; 688  :             return 8;

	mov	eax, 8
	jmp	SHORT $LN8@DXUTStenci
$LN1@DXUTStenci:

; 689  : 
; 690  :         default:
; 691  :             return 0;

	xor	eax, eax
$LN8@DXUTStenci:

; 692  :     }
; 693  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN11@DXUTStenci:
	DD	$LN5@DXUTStenci
	DD	$LN4@DXUTStenci
	DD	$LN2@DXUTStenci
	DD	$LN3@DXUTStenci
	DD	$LN1@DXUTStenci
$LN10@DXUTStenci:
	DB	0
	DB	0
	DB	4
	DB	1
	DB	4
	DB	2
	DB	4
	DB	0
	DB	4
	DB	3
	DB	0
	DB	4
	DB	0
	DB	2
?DXUTStencilBits@@YAIW4_D3DFORMAT@@@Z ENDP		; DXUTStencilBits
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutenum.cpp
;	COMDAT ?SortModesCallback@@YAHPBX0@Z
_TEXT	SEGMENT
_pdm2$ = -20						; size = 4
_pdm1$ = -8						; size = 4
_arg1$ = 8						; size = 4
_arg2$ = 12						; size = 4
?SortModesCallback@@YAHPBX0@Z PROC			; SortModesCallback, COMDAT

; 701  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 702  :     D3DDISPLAYMODE* pdm1 = (D3DDISPLAYMODE*)arg1;

	mov	eax, DWORD PTR _arg1$[ebp]
	mov	DWORD PTR _pdm1$[ebp], eax

; 703  :     D3DDISPLAYMODE* pdm2 = (D3DDISPLAYMODE*)arg2;

	mov	eax, DWORD PTR _arg2$[ebp]
	mov	DWORD PTR _pdm2$[ebp], eax

; 704  : 
; 705  :     if (pdm1->Width > pdm2->Width)

	mov	eax, DWORD PTR _pdm1$[ebp]
	mov	ecx, DWORD PTR _pdm2$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jbe	SHORT $LN8@SortModesC

; 706  :         return 1;

	mov	eax, 1
	jmp	$LN9@SortModesC
$LN8@SortModesC:

; 707  :     if (pdm1->Width < pdm2->Width)

	mov	eax, DWORD PTR _pdm1$[ebp]
	mov	ecx, DWORD PTR _pdm2$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jae	SHORT $LN7@SortModesC

; 708  :         return -1;

	or	eax, -1
	jmp	SHORT $LN9@SortModesC
$LN7@SortModesC:

; 709  :     if (pdm1->Height > pdm2->Height)

	mov	eax, DWORD PTR _pdm1$[ebp]
	mov	ecx, DWORD PTR _pdm2$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jbe	SHORT $LN6@SortModesC

; 710  :         return 1;

	mov	eax, 1
	jmp	SHORT $LN9@SortModesC
$LN6@SortModesC:

; 711  :     if (pdm1->Height < pdm2->Height)

	mov	eax, DWORD PTR _pdm1$[ebp]
	mov	ecx, DWORD PTR _pdm2$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jae	SHORT $LN5@SortModesC

; 712  :         return -1;

	or	eax, -1
	jmp	SHORT $LN9@SortModesC
$LN5@SortModesC:

; 713  :     if (pdm1->Format > pdm2->Format)

	mov	eax, DWORD PTR _pdm1$[ebp]
	mov	ecx, DWORD PTR _pdm2$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+12]
	jle	SHORT $LN4@SortModesC

; 714  :         return 1;

	mov	eax, 1
	jmp	SHORT $LN9@SortModesC
$LN4@SortModesC:

; 715  :     if (pdm1->Format < pdm2->Format)

	mov	eax, DWORD PTR _pdm1$[ebp]
	mov	ecx, DWORD PTR _pdm2$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+12]
	jge	SHORT $LN3@SortModesC

; 716  :         return -1;

	or	eax, -1
	jmp	SHORT $LN9@SortModesC
$LN3@SortModesC:

; 717  :     if (pdm1->RefreshRate > pdm2->RefreshRate)

	mov	eax, DWORD PTR _pdm1$[ebp]
	mov	ecx, DWORD PTR _pdm2$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jbe	SHORT $LN2@SortModesC

; 718  :         return 1;

	mov	eax, 1
	jmp	SHORT $LN9@SortModesC
$LN2@SortModesC:

; 719  :     if (pdm1->RefreshRate < pdm2->RefreshRate)

	mov	eax, DWORD PTR _pdm1$[ebp]
	mov	ecx, DWORD PTR _pdm2$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jae	SHORT $LN1@SortModesC

; 720  :         return -1;

	or	eax, -1
	jmp	SHORT $LN9@SortModesC
$LN1@SortModesC:

; 721  :     return 0;

	xor	eax, eax
$LN9@SortModesC:

; 722  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SortModesCallback@@YAHPBX0@Z ENDP			; SortModesCallback
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GCD3DEnumDeviceSettingsCombo@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GCD3DEnumDeviceSettingsCombo@@QAEPAXI@Z PROC		; CD3DEnumDeviceSettingsCombo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CD3DEnumDeviceSettingsCombo@@QAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCD3DEnumDeviceSettingsCombo@@QAEPAXI@Z ENDP		; CD3DEnumDeviceSettingsCombo::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1CD3DEnumDeviceSettingsCombo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1CD3DEnumDeviceSettingsCombo@@QAE@XZ PROC		; CD3DEnumDeviceSettingsCombo::~CD3DEnumDeviceSettingsCombo, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CD3DEnumDeviceSettingsCombo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 68					; 00000044H
	call	??1?$CGrowableArray@UCD3DEnumDSMSConflict@@@@QAE@XZ ; CGrowableArray<CD3DEnumDSMSConflict>::~CGrowableArray<CD3DEnumDSMSConflict>
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	call	??1?$CGrowableArray@I@@QAE@XZ		; CGrowableArray<unsigned int>::~CGrowableArray<unsigned int>
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	??1?$CGrowableArray@K@@QAE@XZ		; CGrowableArray<unsigned long>::~CGrowableArray<unsigned long>
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??1?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAE@XZ ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::~CGrowableArray<enum _D3DMULTISAMPLE_TYPE>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??1?$CGrowableArray@W4_D3DFORMAT@@@@QAE@XZ ; CGrowableArray<enum _D3DFORMAT>::~CGrowableArray<enum _D3DFORMAT>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CD3DEnumDeviceSettingsCombo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	jmp	??1?$CGrowableArray@W4_D3DFORMAT@@@@QAE@XZ ; CGrowableArray<enum _D3DFORMAT>::~CGrowableArray<enum _D3DFORMAT>
__unwindfunclet$??1CD3DEnumDeviceSettingsCombo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	jmp	??1?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAE@XZ ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::~CGrowableArray<enum _D3DMULTISAMPLE_TYPE>
__unwindfunclet$??1CD3DEnumDeviceSettingsCombo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	jmp	??1?$CGrowableArray@K@@QAE@XZ		; CGrowableArray<unsigned long>::~CGrowableArray<unsigned long>
__unwindfunclet$??1CD3DEnumDeviceSettingsCombo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	jmp	??1?$CGrowableArray@I@@QAE@XZ		; CGrowableArray<unsigned int>::~CGrowableArray<unsigned int>
__ehhandler$??1CD3DEnumDeviceSettingsCombo@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CD3DEnumDeviceSettingsCombo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CD3DEnumDeviceSettingsCombo@@QAE@XZ ENDP		; CD3DEnumDeviceSettingsCombo::~CD3DEnumDeviceSettingsCombo
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0CD3DEnumDeviceSettingsCombo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0CD3DEnumDeviceSettingsCombo@@QAE@XZ PROC		; CD3DEnumDeviceSettingsCombo::CD3DEnumDeviceSettingsCombo, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CD3DEnumDeviceSettingsCombo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0?$CGrowableArray@W4_D3DFORMAT@@@@QAE@XZ ; CGrowableArray<enum _D3DFORMAT>::CGrowableArray<enum _D3DFORMAT>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??0?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAE@XZ ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::CGrowableArray<enum _D3DMULTISAMPLE_TYPE>
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	??0?$CGrowableArray@K@@QAE@XZ		; CGrowableArray<unsigned long>::CGrowableArray<unsigned long>
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	call	??0?$CGrowableArray@I@@QAE@XZ		; CGrowableArray<unsigned int>::CGrowableArray<unsigned int>
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 68					; 00000044H
	call	??0?$CGrowableArray@UCD3DEnumDSMSConflict@@@@QAE@XZ ; CGrowableArray<CD3DEnumDSMSConflict>::CGrowableArray<CD3DEnumDSMSConflict>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CD3DEnumDeviceSettingsCombo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	jmp	??1?$CGrowableArray@W4_D3DFORMAT@@@@QAE@XZ ; CGrowableArray<enum _D3DFORMAT>::~CGrowableArray<enum _D3DFORMAT>
__unwindfunclet$??0CD3DEnumDeviceSettingsCombo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	jmp	??1?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAE@XZ ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::~CGrowableArray<enum _D3DMULTISAMPLE_TYPE>
__unwindfunclet$??0CD3DEnumDeviceSettingsCombo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	jmp	??1?$CGrowableArray@K@@QAE@XZ		; CGrowableArray<unsigned long>::~CGrowableArray<unsigned long>
__unwindfunclet$??0CD3DEnumDeviceSettingsCombo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	jmp	??1?$CGrowableArray@I@@QAE@XZ		; CGrowableArray<unsigned int>::~CGrowableArray<unsigned int>
__ehhandler$??0CD3DEnumDeviceSettingsCombo@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CD3DEnumDeviceSettingsCombo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CD3DEnumDeviceSettingsCombo@@QAE@XZ ENDP		; CD3DEnumDeviceSettingsCombo::CD3DEnumDeviceSettingsCombo
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?SetSizeInternal@?$CGrowableArray@UCD3DEnumDSMSConflict@@@@IAEJH@Z
_TEXT	SEGMENT
tv91 = -232						; size = 4
tv85 = -232						; size = 4
_pDataNew$1 = -32					; size = 4
_nGrowBy$2 = -20					; size = 4
_this$ = -8						; size = 4
_nNewMaxSize$ = 8					; size = 4
?SetSizeInternal@?$CGrowableArray@UCD3DEnumDSMSConflict@@@@IAEJH@Z PROC ; CGrowableArray<CD3DEnumDSMSConflict>::SetSizeInternal, COMDAT
; _this$ = ecx

; 670  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 671  :     if( nNewMaxSize < 0 )

	cmp	DWORD PTR _nNewMaxSize$[ebp], 0
	jge	SHORT $LN7@SetSizeInt

; 672  :     {
; 673  :         assert( false );

	xor	eax, eax
	jne	SHORT $LN10@SetSizeInt
	push	673					; 000002a1H
	push	OFFSET ??_C@_1FK@FIMIDMPE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
	push	OFFSET ??_C@_1M@HLGKFCJM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN10@SetSizeInt:

; 674  :         return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H
	jmp	$LN8@SetSizeInt
$LN7@SetSizeInt:

; 675  :     }
; 676  : 
; 677  :     if( nNewMaxSize == 0 )

	cmp	DWORD PTR _nNewMaxSize$[ebp], 0
	jne	SHORT $LN6@SetSizeInt

; 678  :     {
; 679  :         // Shrink to 0 size & cleanup
; 680  :         if( m_pData )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@SetSizeInt

; 681  :         {
; 682  :             free( m_pData );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_free
	add	esp, 4

; 683  :             m_pData = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN5@SetSizeInt:

; 684  :         }
; 685  : 
; 686  :         m_nMaxSize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 687  :         m_nSize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	jmp	$LN4@SetSizeInt
$LN6@SetSizeInt:

; 688  :     }
; 689  :     else if( m_pData == NULL || nNewMaxSize > m_nMaxSize )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@SetSizeInt
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nNewMaxSize$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jle	$LN4@SetSizeInt
$LN2@SetSizeInt:

; 690  :     {
; 691  :         // Grow array
; 692  :         int nGrowBy = ( m_nMaxSize == 0 ) ? 16 : m_nMaxSize;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN11@SetSizeInt
	mov	DWORD PTR tv85[ebp], 16			; 00000010H
	jmp	SHORT $LN12@SetSizeInt
$LN11@SetSizeInt:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv85[ebp], edx
$LN12@SetSizeInt:
	mov	eax, DWORD PTR tv85[ebp]
	mov	DWORD PTR _nGrowBy$2[ebp], eax

; 693  :         nNewMaxSize = __max( nNewMaxSize, m_nMaxSize + nGrowBy );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _nGrowBy$2[ebp]
	cmp	DWORD PTR _nNewMaxSize$[ebp], ecx
	jle	SHORT $LN13@SetSizeInt
	mov	edx, DWORD PTR _nNewMaxSize$[ebp]
	mov	DWORD PTR tv91[ebp], edx
	jmp	SHORT $LN14@SetSizeInt
$LN13@SetSizeInt:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _nGrowBy$2[ebp]
	mov	DWORD PTR tv91[ebp], ecx
$LN14@SetSizeInt:
	mov	edx, DWORD PTR tv91[ebp]
	mov	DWORD PTR _nNewMaxSize$[ebp], edx

; 694  : 
; 695  :         TYPE* pDataNew = (TYPE*) realloc( m_pData, nNewMaxSize * sizeof(TYPE) );

	mov	eax, DWORD PTR _nNewMaxSize$[ebp]
	shl	eax, 3
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_realloc
	add	esp, 8
	mov	DWORD PTR _pDataNew$1[ebp], eax

; 696  :         if( pDataNew == NULL )

	cmp	DWORD PTR _pDataNew$1[ebp], 0
	jne	SHORT $LN1@SetSizeInt

; 697  :             return E_OUTOFMEMORY;

	mov	eax, -2147024882			; 8007000eH
	jmp	SHORT $LN8@SetSizeInt
$LN1@SetSizeInt:

; 698  : 
; 699  :         m_pData = pDataNew;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pDataNew$1[ebp]
	mov	DWORD PTR [eax], ecx

; 700  :         m_nMaxSize = nNewMaxSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nNewMaxSize$[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN4@SetSizeInt:

; 701  :     }
; 702  : 
; 703  :     return S_OK;

	xor	eax, eax
$LN8@SetSizeInt:

; 704  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSizeInternal@?$CGrowableArray@UCD3DEnumDSMSConflict@@@@IAEJH@Z ENDP ; CGrowableArray<CD3DEnumDSMSConflict>::SetSizeInternal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?RemoveAll@?$CGrowableArray@UCD3DEnumDSMSConflict@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?RemoveAll@?$CGrowableArray@UCD3DEnumDSMSConflict@@@@QAEXXZ PROC ; CGrowableArray<CD3DEnumDSMSConflict>::RemoveAll, COMDAT
; _this$ = ecx

; 47   :     void    RemoveAll() { SetSize(0); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$CGrowableArray@UCD3DEnumDSMSConflict@@@@QAEJH@Z ; CGrowableArray<CD3DEnumDSMSConflict>::SetSize
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CGrowableArray@UCD3DEnumDSMSConflict@@@@QAEXXZ ENDP ; CGrowableArray<CD3DEnumDSMSConflict>::RemoveAll
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?Add@?$CGrowableArray@UCD3DEnumDSMSConflict@@@@QAEJABUCD3DEnumDSMSConflict@@@Z
_TEXT	SEGMENT
$T1 = -224						; size = 4
_hr$ = -20						; size = 4
_this$ = -8						; size = 4
_value$ = 8						; size = 4
?Add@?$CGrowableArray@UCD3DEnumDSMSConflict@@@@QAEJABUCD3DEnumDSMSConflict@@@Z PROC ; CGrowableArray<CD3DEnumDSMSConflict>::Add, COMDAT
; _this$ = ecx

; 740  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 741  :     HRESULT hr;
; 742  :     if( FAILED( hr = SetSizeInternal( m_nSize + 1 ) ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSizeInternal@?$CGrowableArray@UCD3DEnumDSMSConflict@@@@IAEJH@Z ; CGrowableArray<CD3DEnumDSMSConflict>::SetSizeInternal
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN1@Add

; 743  :         return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	jmp	SHORT $LN2@Add
$LN1@Add:

; 744  : 
; 745  :     // Construct the new element
; 746  :     ::new (&m_pData[m_nSize]) TYPE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*8]
	push	ecx
	push	8
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax

; 747  : 
; 748  :     // Assign
; 749  :     m_pData[m_nSize] = value;

	mov	eax, DWORD PTR _value$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [esi]
	mov	DWORD PTR [esi+eax*8], ecx
	mov	DWORD PTR [esi+eax*8+4], edx

; 750  :     ++m_nSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 751  : 
; 752  :     return S_OK;

	xor	eax, eax
$LN2@Add:

; 753  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Add@?$CGrowableArray@UCD3DEnumDSMSConflict@@@@QAEJABUCD3DEnumDSMSConflict@@@Z ENDP ; CGrowableArray<CD3DEnumDSMSConflict>::Add
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?SetSize@?$CGrowableArray@UCD3DEnumDSMSConflict@@@@QAEJH@Z
_TEXT	SEGMENT
$T1 = -260						; size = 4
_i$2 = -56						; size = 4
_hr$ = -44						; size = 4
_i$3 = -32						; size = 4
_nOldSize$ = -20					; size = 4
_this$ = -8						; size = 4
_nNewMaxSize$ = 8					; size = 4
?SetSize@?$CGrowableArray@UCD3DEnumDSMSConflict@@@@QAEJH@Z PROC ; CGrowableArray<CD3DEnumDSMSConflict>::SetSize, COMDAT
; _this$ = ecx

; 710  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 711  :     int nOldSize = m_nSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _nOldSize$[ebp], ecx

; 712  : 
; 713  :     if( nOldSize > nNewMaxSize )

	mov	eax, DWORD PTR _nOldSize$[ebp]
	cmp	eax, DWORD PTR _nNewMaxSize$[ebp]
	jle	SHORT $LN8@SetSize

; 714  :     {
; 715  :         // Removing elements. Call dtor.
; 716  : 
; 717  :         for( int i = nNewMaxSize; i < nOldSize; ++i )

	mov	eax, DWORD PTR _nNewMaxSize$[ebp]
	mov	DWORD PTR _i$3[ebp], eax
	jmp	SHORT $LN7@SetSize
$LN6@SetSize:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN7@SetSize:
	mov	eax, DWORD PTR _i$3[ebp]
	cmp	eax, DWORD PTR _nOldSize$[ebp]
	jge	SHORT $LN8@SetSize

; 718  :             m_pData[i].~TYPE();

	jmp	SHORT $LN6@SetSize
$LN8@SetSize:

; 719  :     }
; 720  : 
; 721  :     // Adjust buffer.  Note that there's no need to check for error
; 722  :     // since if it happens, nOldSize == nNewMaxSize will be true.)
; 723  :     HRESULT hr = SetSizeInternal( nNewMaxSize );

	mov	eax, DWORD PTR _nNewMaxSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSizeInternal@?$CGrowableArray@UCD3DEnumDSMSConflict@@@@IAEJH@Z ; CGrowableArray<CD3DEnumDSMSConflict>::SetSizeInternal
	mov	DWORD PTR _hr$[ebp], eax

; 724  : 
; 725  :     if( nOldSize < nNewMaxSize )

	mov	eax, DWORD PTR _nOldSize$[ebp]
	cmp	eax, DWORD PTR _nNewMaxSize$[ebp]
	jge	SHORT $LN4@SetSize

; 726  :     {
; 727  :         // Adding elements. Call ctor.
; 728  : 
; 729  :         for( int i = nOldSize; i < nNewMaxSize; ++i )

	mov	eax, DWORD PTR _nOldSize$[ebp]
	mov	DWORD PTR _i$2[ebp], eax
	jmp	SHORT $LN3@SetSize
$LN2@SetSize:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN3@SetSize:
	mov	eax, DWORD PTR _i$2[ebp]
	cmp	eax, DWORD PTR _nNewMaxSize$[ebp]
	jge	SHORT $LN4@SetSize

; 730  :             ::new (&m_pData[i]) TYPE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$2[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	push	eax
	push	8
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	jmp	SHORT $LN2@SetSize
$LN4@SetSize:

; 731  :     }
; 732  : 
; 733  :     return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 734  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSize@?$CGrowableArray@UCD3DEnumDSMSConflict@@@@QAEJH@Z ENDP ; CGrowableArray<CD3DEnumDSMSConflict>::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ??1?$CGrowableArray@UCD3DEnumDSMSConflict@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$CGrowableArray@UCD3DEnumDSMSConflict@@@@QAE@XZ PROC ; CGrowableArray<CD3DEnumDSMSConflict>::~CGrowableArray<CD3DEnumDSMSConflict>, COMDAT
; _this$ = ecx

; 22   :     ~CGrowableArray() { RemoveAll(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CGrowableArray@UCD3DEnumDSMSConflict@@@@QAEXXZ ; CGrowableArray<CD3DEnumDSMSConflict>::RemoveAll
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CGrowableArray@UCD3DEnumDSMSConflict@@@@QAE@XZ ENDP ; CGrowableArray<CD3DEnumDSMSConflict>::~CGrowableArray<CD3DEnumDSMSConflict>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ??0?$CGrowableArray@UCD3DEnumDSMSConflict@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$CGrowableArray@UCD3DEnumDSMSConflict@@@@QAE@XZ PROC ; CGrowableArray<CD3DEnumDSMSConflict>::CGrowableArray<CD3DEnumDSMSConflict>, COMDAT
; _this$ = ecx

; 20   :     CGrowableArray()  { m_pData = NULL; m_nSize = 0; m_nMaxSize = 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CGrowableArray@UCD3DEnumDSMSConflict@@@@QAE@XZ ENDP ; CGrowableArray<CD3DEnumDSMSConflict>::CGrowableArray<CD3DEnumDSMSConflict>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?SetSizeInternal@?$CGrowableArray@K@@IAEJH@Z
_TEXT	SEGMENT
tv91 = -232						; size = 4
tv85 = -232						; size = 4
_pDataNew$1 = -32					; size = 4
_nGrowBy$2 = -20					; size = 4
_this$ = -8						; size = 4
_nNewMaxSize$ = 8					; size = 4
?SetSizeInternal@?$CGrowableArray@K@@IAEJH@Z PROC	; CGrowableArray<unsigned long>::SetSizeInternal, COMDAT
; _this$ = ecx

; 670  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 671  :     if( nNewMaxSize < 0 )

	cmp	DWORD PTR _nNewMaxSize$[ebp], 0
	jge	SHORT $LN7@SetSizeInt

; 672  :     {
; 673  :         assert( false );

	xor	eax, eax
	jne	SHORT $LN10@SetSizeInt
	push	673					; 000002a1H
	push	OFFSET ??_C@_1FK@FIMIDMPE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
	push	OFFSET ??_C@_1M@HLGKFCJM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN10@SetSizeInt:

; 674  :         return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H
	jmp	$LN8@SetSizeInt
$LN7@SetSizeInt:

; 675  :     }
; 676  : 
; 677  :     if( nNewMaxSize == 0 )

	cmp	DWORD PTR _nNewMaxSize$[ebp], 0
	jne	SHORT $LN6@SetSizeInt

; 678  :     {
; 679  :         // Shrink to 0 size & cleanup
; 680  :         if( m_pData )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@SetSizeInt

; 681  :         {
; 682  :             free( m_pData );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_free
	add	esp, 4

; 683  :             m_pData = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN5@SetSizeInt:

; 684  :         }
; 685  : 
; 686  :         m_nMaxSize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 687  :         m_nSize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	jmp	$LN4@SetSizeInt
$LN6@SetSizeInt:

; 688  :     }
; 689  :     else if( m_pData == NULL || nNewMaxSize > m_nMaxSize )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@SetSizeInt
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nNewMaxSize$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jle	$LN4@SetSizeInt
$LN2@SetSizeInt:

; 690  :     {
; 691  :         // Grow array
; 692  :         int nGrowBy = ( m_nMaxSize == 0 ) ? 16 : m_nMaxSize;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN11@SetSizeInt
	mov	DWORD PTR tv85[ebp], 16			; 00000010H
	jmp	SHORT $LN12@SetSizeInt
$LN11@SetSizeInt:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv85[ebp], edx
$LN12@SetSizeInt:
	mov	eax, DWORD PTR tv85[ebp]
	mov	DWORD PTR _nGrowBy$2[ebp], eax

; 693  :         nNewMaxSize = __max( nNewMaxSize, m_nMaxSize + nGrowBy );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _nGrowBy$2[ebp]
	cmp	DWORD PTR _nNewMaxSize$[ebp], ecx
	jle	SHORT $LN13@SetSizeInt
	mov	edx, DWORD PTR _nNewMaxSize$[ebp]
	mov	DWORD PTR tv91[ebp], edx
	jmp	SHORT $LN14@SetSizeInt
$LN13@SetSizeInt:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _nGrowBy$2[ebp]
	mov	DWORD PTR tv91[ebp], ecx
$LN14@SetSizeInt:
	mov	edx, DWORD PTR tv91[ebp]
	mov	DWORD PTR _nNewMaxSize$[ebp], edx

; 694  : 
; 695  :         TYPE* pDataNew = (TYPE*) realloc( m_pData, nNewMaxSize * sizeof(TYPE) );

	mov	eax, DWORD PTR _nNewMaxSize$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_realloc
	add	esp, 8
	mov	DWORD PTR _pDataNew$1[ebp], eax

; 696  :         if( pDataNew == NULL )

	cmp	DWORD PTR _pDataNew$1[ebp], 0
	jne	SHORT $LN1@SetSizeInt

; 697  :             return E_OUTOFMEMORY;

	mov	eax, -2147024882			; 8007000eH
	jmp	SHORT $LN8@SetSizeInt
$LN1@SetSizeInt:

; 698  : 
; 699  :         m_pData = pDataNew;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pDataNew$1[ebp]
	mov	DWORD PTR [eax], ecx

; 700  :         m_nMaxSize = nNewMaxSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nNewMaxSize$[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN4@SetSizeInt:

; 701  :     }
; 702  : 
; 703  :     return S_OK;

	xor	eax, eax
$LN8@SetSizeInt:

; 704  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSizeInternal@?$CGrowableArray@K@@IAEJH@Z ENDP	; CGrowableArray<unsigned long>::SetSizeInternal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?RemoveAll@?$CGrowableArray@K@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?RemoveAll@?$CGrowableArray@K@@QAEXXZ PROC		; CGrowableArray<unsigned long>::RemoveAll, COMDAT
; _this$ = ecx

; 47   :     void    RemoveAll() { SetSize(0); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$CGrowableArray@K@@QAEJH@Z	; CGrowableArray<unsigned long>::SetSize
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CGrowableArray@K@@QAEXXZ ENDP		; CGrowableArray<unsigned long>::RemoveAll
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?Add@?$CGrowableArray@K@@QAEJABK@Z
_TEXT	SEGMENT
$T1 = -224						; size = 4
_hr$ = -20						; size = 4
_this$ = -8						; size = 4
_value$ = 8						; size = 4
?Add@?$CGrowableArray@K@@QAEJABK@Z PROC			; CGrowableArray<unsigned long>::Add, COMDAT
; _this$ = ecx

; 740  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 741  :     HRESULT hr;
; 742  :     if( FAILED( hr = SetSizeInternal( m_nSize + 1 ) ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSizeInternal@?$CGrowableArray@K@@IAEJH@Z ; CGrowableArray<unsigned long>::SetSizeInternal
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN1@Add

; 743  :         return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	jmp	SHORT $LN2@Add
$LN1@Add:

; 744  : 
; 745  :     // Construct the new element
; 746  :     ::new (&m_pData[m_nSize]) TYPE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*4]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax

; 747  : 
; 748  :     // Assign
; 749  :     m_pData[m_nSize] = value;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _value$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [eax+ecx*4], edx

; 750  :     ++m_nSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 751  : 
; 752  :     return S_OK;

	xor	eax, eax
$LN2@Add:

; 753  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Add@?$CGrowableArray@K@@QAEJABK@Z ENDP			; CGrowableArray<unsigned long>::Add
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?SetSize@?$CGrowableArray@K@@QAEJH@Z
_TEXT	SEGMENT
$T1 = -260						; size = 4
_i$2 = -56						; size = 4
_hr$ = -44						; size = 4
_i$3 = -32						; size = 4
_nOldSize$ = -20					; size = 4
_this$ = -8						; size = 4
_nNewMaxSize$ = 8					; size = 4
?SetSize@?$CGrowableArray@K@@QAEJH@Z PROC		; CGrowableArray<unsigned long>::SetSize, COMDAT
; _this$ = ecx

; 710  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 711  :     int nOldSize = m_nSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _nOldSize$[ebp], ecx

; 712  : 
; 713  :     if( nOldSize > nNewMaxSize )

	mov	eax, DWORD PTR _nOldSize$[ebp]
	cmp	eax, DWORD PTR _nNewMaxSize$[ebp]
	jle	SHORT $LN8@SetSize

; 714  :     {
; 715  :         // Removing elements. Call dtor.
; 716  : 
; 717  :         for( int i = nNewMaxSize; i < nOldSize; ++i )

	mov	eax, DWORD PTR _nNewMaxSize$[ebp]
	mov	DWORD PTR _i$3[ebp], eax
	jmp	SHORT $LN7@SetSize
$LN6@SetSize:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN7@SetSize:
	mov	eax, DWORD PTR _i$3[ebp]
	cmp	eax, DWORD PTR _nOldSize$[ebp]
	jge	SHORT $LN8@SetSize

; 718  :             m_pData[i].~TYPE();

	jmp	SHORT $LN6@SetSize
$LN8@SetSize:

; 719  :     }
; 720  : 
; 721  :     // Adjust buffer.  Note that there's no need to check for error
; 722  :     // since if it happens, nOldSize == nNewMaxSize will be true.)
; 723  :     HRESULT hr = SetSizeInternal( nNewMaxSize );

	mov	eax, DWORD PTR _nNewMaxSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSizeInternal@?$CGrowableArray@K@@IAEJH@Z ; CGrowableArray<unsigned long>::SetSizeInternal
	mov	DWORD PTR _hr$[ebp], eax

; 724  : 
; 725  :     if( nOldSize < nNewMaxSize )

	mov	eax, DWORD PTR _nOldSize$[ebp]
	cmp	eax, DWORD PTR _nNewMaxSize$[ebp]
	jge	SHORT $LN4@SetSize

; 726  :     {
; 727  :         // Adding elements. Call ctor.
; 728  : 
; 729  :         for( int i = nOldSize; i < nNewMaxSize; ++i )

	mov	eax, DWORD PTR _nOldSize$[ebp]
	mov	DWORD PTR _i$2[ebp], eax
	jmp	SHORT $LN3@SetSize
$LN2@SetSize:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN3@SetSize:
	mov	eax, DWORD PTR _i$2[ebp]
	cmp	eax, DWORD PTR _nNewMaxSize$[ebp]
	jge	SHORT $LN4@SetSize

; 730  :             ::new (&m_pData[i]) TYPE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$2[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	jmp	SHORT $LN2@SetSize
$LN4@SetSize:

; 731  :     }
; 732  : 
; 733  :     return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 734  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSize@?$CGrowableArray@K@@QAEJH@Z ENDP		; CGrowableArray<unsigned long>::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ??1?$CGrowableArray@K@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$CGrowableArray@K@@QAE@XZ PROC			; CGrowableArray<unsigned long>::~CGrowableArray<unsigned long>, COMDAT
; _this$ = ecx

; 22   :     ~CGrowableArray() { RemoveAll(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CGrowableArray@K@@QAEXXZ	; CGrowableArray<unsigned long>::RemoveAll
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CGrowableArray@K@@QAE@XZ ENDP			; CGrowableArray<unsigned long>::~CGrowableArray<unsigned long>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ??0?$CGrowableArray@K@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$CGrowableArray@K@@QAE@XZ PROC			; CGrowableArray<unsigned long>::CGrowableArray<unsigned long>, COMDAT
; _this$ = ecx

; 20   :     CGrowableArray()  { m_pData = NULL; m_nSize = 0; m_nMaxSize = 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CGrowableArray@K@@QAE@XZ ENDP			; CGrowableArray<unsigned long>::CGrowableArray<unsigned long>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GCD3DEnumDeviceInfo@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GCD3DEnumDeviceInfo@@QAEPAXI@Z PROC			; CD3DEnumDeviceInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CD3DEnumDeviceInfo@@QAE@XZ		; CD3DEnumDeviceInfo::~CD3DEnumDeviceInfo
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCD3DEnumDeviceInfo@@QAEPAXI@Z ENDP			; CD3DEnumDeviceInfo::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0CD3DEnumDeviceInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0CD3DEnumDeviceInfo@@QAE@XZ PROC			; CD3DEnumDeviceInfo::CD3DEnumDeviceInfo, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 312				; 00000138H
	call	??0?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QAE@XZ ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::CGrowableArray<CD3DEnumDeviceSettingsCombo *>
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0CD3DEnumDeviceInfo@@QAE@XZ ENDP			; CD3DEnumDeviceInfo::CD3DEnumDeviceInfo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?SetSizeInternal@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@IAEJH@Z
_TEXT	SEGMENT
tv91 = -232						; size = 4
tv85 = -232						; size = 4
_pDataNew$1 = -32					; size = 4
_nGrowBy$2 = -20					; size = 4
_this$ = -8						; size = 4
_nNewMaxSize$ = 8					; size = 4
?SetSizeInternal@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@IAEJH@Z PROC ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::SetSizeInternal, COMDAT
; _this$ = ecx

; 670  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 671  :     if( nNewMaxSize < 0 )

	cmp	DWORD PTR _nNewMaxSize$[ebp], 0
	jge	SHORT $LN7@SetSizeInt

; 672  :     {
; 673  :         assert( false );

	xor	eax, eax
	jne	SHORT $LN10@SetSizeInt
	push	673					; 000002a1H
	push	OFFSET ??_C@_1FK@FIMIDMPE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
	push	OFFSET ??_C@_1M@HLGKFCJM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN10@SetSizeInt:

; 674  :         return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H
	jmp	$LN8@SetSizeInt
$LN7@SetSizeInt:

; 675  :     }
; 676  : 
; 677  :     if( nNewMaxSize == 0 )

	cmp	DWORD PTR _nNewMaxSize$[ebp], 0
	jne	SHORT $LN6@SetSizeInt

; 678  :     {
; 679  :         // Shrink to 0 size & cleanup
; 680  :         if( m_pData )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@SetSizeInt

; 681  :         {
; 682  :             free( m_pData );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_free
	add	esp, 4

; 683  :             m_pData = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN5@SetSizeInt:

; 684  :         }
; 685  : 
; 686  :         m_nMaxSize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 687  :         m_nSize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	jmp	$LN4@SetSizeInt
$LN6@SetSizeInt:

; 688  :     }
; 689  :     else if( m_pData == NULL || nNewMaxSize > m_nMaxSize )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@SetSizeInt
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nNewMaxSize$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jle	$LN4@SetSizeInt
$LN2@SetSizeInt:

; 690  :     {
; 691  :         // Grow array
; 692  :         int nGrowBy = ( m_nMaxSize == 0 ) ? 16 : m_nMaxSize;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN11@SetSizeInt
	mov	DWORD PTR tv85[ebp], 16			; 00000010H
	jmp	SHORT $LN12@SetSizeInt
$LN11@SetSizeInt:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv85[ebp], edx
$LN12@SetSizeInt:
	mov	eax, DWORD PTR tv85[ebp]
	mov	DWORD PTR _nGrowBy$2[ebp], eax

; 693  :         nNewMaxSize = __max( nNewMaxSize, m_nMaxSize + nGrowBy );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _nGrowBy$2[ebp]
	cmp	DWORD PTR _nNewMaxSize$[ebp], ecx
	jle	SHORT $LN13@SetSizeInt
	mov	edx, DWORD PTR _nNewMaxSize$[ebp]
	mov	DWORD PTR tv91[ebp], edx
	jmp	SHORT $LN14@SetSizeInt
$LN13@SetSizeInt:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _nGrowBy$2[ebp]
	mov	DWORD PTR tv91[ebp], ecx
$LN14@SetSizeInt:
	mov	edx, DWORD PTR tv91[ebp]
	mov	DWORD PTR _nNewMaxSize$[ebp], edx

; 694  : 
; 695  :         TYPE* pDataNew = (TYPE*) realloc( m_pData, nNewMaxSize * sizeof(TYPE) );

	mov	eax, DWORD PTR _nNewMaxSize$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_realloc
	add	esp, 8
	mov	DWORD PTR _pDataNew$1[ebp], eax

; 696  :         if( pDataNew == NULL )

	cmp	DWORD PTR _pDataNew$1[ebp], 0
	jne	SHORT $LN1@SetSizeInt

; 697  :             return E_OUTOFMEMORY;

	mov	eax, -2147024882			; 8007000eH
	jmp	SHORT $LN8@SetSizeInt
$LN1@SetSizeInt:

; 698  : 
; 699  :         m_pData = pDataNew;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pDataNew$1[ebp]
	mov	DWORD PTR [eax], ecx

; 700  :         m_nMaxSize = nNewMaxSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nNewMaxSize$[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN4@SetSizeInt:

; 701  :     }
; 702  : 
; 703  :     return S_OK;

	xor	eax, eax
$LN8@SetSizeInt:

; 704  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSizeInternal@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@IAEJH@Z ENDP ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::SetSizeInternal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?RemoveAll@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?RemoveAll@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QAEXXZ PROC ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::RemoveAll, COMDAT
; _this$ = ecx

; 47   :     void    RemoveAll() { SetSize(0); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QAEJH@Z ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::SetSize
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QAEXXZ ENDP ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::RemoveAll
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?GetSize@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetSize@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QBEHXZ PROC ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::GetSize, COMDAT
; _this$ = ecx

; 34   :     int     GetSize() const { return m_nSize; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSize@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QBEHXZ ENDP ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::GetSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?GetAt@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QAEAAPAUCD3DEnumDeviceSettingsCombo@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nIndex$ = 8						; size = 4
?GetAt@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QAEAAPAUCD3DEnumDeviceSettingsCombo@@H@Z PROC ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::GetAt, COMDAT
; _this$ = ecx

; 33   :     TYPE&   GetAt( int nIndex ) { assert( nIndex >= 0 && nIndex < m_nSize ); return m_pData[nIndex]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _nIndex$[ebp], 0
	jl	SHORT $LN3@GetAt
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jl	SHORT $LN4@GetAt
$LN3@GetAt:
	push	33					; 00000021H
	push	OFFSET ??_C@_1FK@FIMIDMPE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
	push	OFFSET ??_C@_1EA@JHMKKLFC@?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAm?$AA_?$AAn?$AAS?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@GetAt:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _nIndex$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetAt@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QAEAAPAUCD3DEnumDeviceSettingsCombo@@H@Z ENDP ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::GetAt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?Add@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QAEJABQAUCD3DEnumDeviceSettingsCombo@@@Z
_TEXT	SEGMENT
$T1 = -224						; size = 4
_hr$ = -20						; size = 4
_this$ = -8						; size = 4
_value$ = 8						; size = 4
?Add@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QAEJABQAUCD3DEnumDeviceSettingsCombo@@@Z PROC ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::Add, COMDAT
; _this$ = ecx

; 740  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 741  :     HRESULT hr;
; 742  :     if( FAILED( hr = SetSizeInternal( m_nSize + 1 ) ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSizeInternal@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@IAEJH@Z ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::SetSizeInternal
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN1@Add

; 743  :         return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	jmp	SHORT $LN2@Add
$LN1@Add:

; 744  : 
; 745  :     // Construct the new element
; 746  :     ::new (&m_pData[m_nSize]) TYPE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*4]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax

; 747  : 
; 748  :     // Assign
; 749  :     m_pData[m_nSize] = value;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _value$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [eax+ecx*4], edx

; 750  :     ++m_nSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 751  : 
; 752  :     return S_OK;

	xor	eax, eax
$LN2@Add:

; 753  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Add@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QAEJABQAUCD3DEnumDeviceSettingsCombo@@@Z ENDP ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::Add
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?SetSize@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QAEJH@Z
_TEXT	SEGMENT
$T1 = -260						; size = 4
_i$2 = -56						; size = 4
_hr$ = -44						; size = 4
_i$3 = -32						; size = 4
_nOldSize$ = -20					; size = 4
_this$ = -8						; size = 4
_nNewMaxSize$ = 8					; size = 4
?SetSize@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QAEJH@Z PROC ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::SetSize, COMDAT
; _this$ = ecx

; 710  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 711  :     int nOldSize = m_nSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _nOldSize$[ebp], ecx

; 712  : 
; 713  :     if( nOldSize > nNewMaxSize )

	mov	eax, DWORD PTR _nOldSize$[ebp]
	cmp	eax, DWORD PTR _nNewMaxSize$[ebp]
	jle	SHORT $LN8@SetSize

; 714  :     {
; 715  :         // Removing elements. Call dtor.
; 716  : 
; 717  :         for( int i = nNewMaxSize; i < nOldSize; ++i )

	mov	eax, DWORD PTR _nNewMaxSize$[ebp]
	mov	DWORD PTR _i$3[ebp], eax
	jmp	SHORT $LN7@SetSize
$LN6@SetSize:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN7@SetSize:
	mov	eax, DWORD PTR _i$3[ebp]
	cmp	eax, DWORD PTR _nOldSize$[ebp]
	jge	SHORT $LN8@SetSize

; 718  :             m_pData[i].~TYPE();

	jmp	SHORT $LN6@SetSize
$LN8@SetSize:

; 719  :     }
; 720  : 
; 721  :     // Adjust buffer.  Note that there's no need to check for error
; 722  :     // since if it happens, nOldSize == nNewMaxSize will be true.)
; 723  :     HRESULT hr = SetSizeInternal( nNewMaxSize );

	mov	eax, DWORD PTR _nNewMaxSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSizeInternal@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@IAEJH@Z ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::SetSizeInternal
	mov	DWORD PTR _hr$[ebp], eax

; 724  : 
; 725  :     if( nOldSize < nNewMaxSize )

	mov	eax, DWORD PTR _nOldSize$[ebp]
	cmp	eax, DWORD PTR _nNewMaxSize$[ebp]
	jge	SHORT $LN4@SetSize

; 726  :     {
; 727  :         // Adding elements. Call ctor.
; 728  : 
; 729  :         for( int i = nOldSize; i < nNewMaxSize; ++i )

	mov	eax, DWORD PTR _nOldSize$[ebp]
	mov	DWORD PTR _i$2[ebp], eax
	jmp	SHORT $LN3@SetSize
$LN2@SetSize:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN3@SetSize:
	mov	eax, DWORD PTR _i$2[ebp]
	cmp	eax, DWORD PTR _nNewMaxSize$[ebp]
	jge	SHORT $LN4@SetSize

; 730  :             ::new (&m_pData[i]) TYPE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$2[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	jmp	SHORT $LN2@SetSize
$LN4@SetSize:

; 731  :     }
; 732  : 
; 733  :     return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 734  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSize@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QAEJH@Z ENDP ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ??1?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QAE@XZ PROC ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::~CGrowableArray<CD3DEnumDeviceSettingsCombo *>, COMDAT
; _this$ = ecx

; 22   :     ~CGrowableArray() { RemoveAll(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QAEXXZ ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::RemoveAll
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QAE@XZ ENDP ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::~CGrowableArray<CD3DEnumDeviceSettingsCombo *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ??0?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QAE@XZ PROC ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::CGrowableArray<CD3DEnumDeviceSettingsCombo *>, COMDAT
; _this$ = ecx

; 20   :     CGrowableArray()  { m_pData = NULL; m_nSize = 0; m_nMaxSize = 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QAE@XZ ENDP ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::CGrowableArray<CD3DEnumDeviceSettingsCombo *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutenum.cpp
;	COMDAT ??1CD3DEnumDeviceInfo@@QAE@XZ
_TEXT	SEGMENT
tv79 = -268						; size = 4
$T2 = -260						; size = 4
$T3 = -248						; size = 4
_i$4 = -44						; size = 4
_pDeviceCombo$ = -32					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1CD3DEnumDeviceInfo@@QAE@XZ PROC			; CD3DEnumDeviceInfo::~CD3DEnumDeviceInfo, COMDAT
; _this$ = ecx

; 743  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CD3DEnumDeviceInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-268]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 744  :     CD3DEnumDeviceSettingsCombo* pDeviceCombo;
; 745  :     for( int i=0; i<deviceSettingsComboList.GetSize(); i++ )

	mov	DWORD PTR _i$4[ebp], 0
	jmp	SHORT $LN3@CD3DEnumDe
$LN2@CD3DEnumDe:
	mov	eax, DWORD PTR _i$4[ebp]
	add	eax, 1
	mov	DWORD PTR _i$4[ebp], eax
$LN3@CD3DEnumDe:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 312				; 00000138H
	call	?GetSize@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QBEHXZ ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::GetSize
	cmp	DWORD PTR _i$4[ebp], eax
	jge	SHORT $LN1@CD3DEnumDe

; 746  :     {
; 747  :         pDeviceCombo = deviceSettingsComboList.GetAt(i);

	mov	eax, DWORD PTR _i$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 312				; 00000138H
	call	?GetAt@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QAEAAPAUCD3DEnumDeviceSettingsCombo@@H@Z ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::GetAt
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pDeviceCombo$[ebp], ecx

; 748  :         delete pDeviceCombo;

	mov	eax, DWORD PTR _pDeviceCombo$[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN6@CD3DEnumDe
	push	1
	mov	ecx, DWORD PTR $T2[ebp]
	call	??_GCD3DEnumDeviceSettingsCombo@@QAEPAXI@Z
	mov	DWORD PTR tv79[ebp], eax
	jmp	SHORT $LN7@CD3DEnumDe
$LN6@CD3DEnumDe:
	mov	DWORD PTR tv79[ebp], 0
$LN7@CD3DEnumDe:

; 749  :     }

	jmp	SHORT $LN2@CD3DEnumDe
$LN1@CD3DEnumDe:

; 750  :     deviceSettingsComboList.RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 312				; 00000138H
	call	?RemoveAll@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QAEXXZ ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::RemoveAll

; 751  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 312				; 00000138H
	call	??1?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QAE@XZ ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::~CGrowableArray<CD3DEnumDeviceSettingsCombo *>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 268				; 0000010cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CD3DEnumDeviceInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 312				; 00000138H
	jmp	??1?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QAE@XZ ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::~CGrowableArray<CD3DEnumDeviceSettingsCombo *>
__ehhandler$??1CD3DEnumDeviceInfo@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-272]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CD3DEnumDeviceInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CD3DEnumDeviceInfo@@QAE@XZ ENDP			; CD3DEnumDeviceInfo::~CD3DEnumDeviceInfo
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GCD3DEnumAdapterInfo@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GCD3DEnumAdapterInfo@@QAEPAXI@Z PROC			; CD3DEnumAdapterInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CD3DEnumAdapterInfo@@QAE@XZ		; CD3DEnumAdapterInfo::~CD3DEnumAdapterInfo
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCD3DEnumAdapterInfo@@QAEPAXI@Z ENDP			; CD3DEnumAdapterInfo::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0CD3DEnumAdapterInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0CD3DEnumAdapterInfo@@QAE@XZ PROC			; CD3DEnumAdapterInfo::CD3DEnumAdapterInfo, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CD3DEnumAdapterInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1360				; 00000550H
	call	??0?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAE@XZ ; CGrowableArray<_D3DDISPLAYMODE>::CGrowableArray<_D3DDISPLAYMODE>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1372				; 0000055cH
	call	??0?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QAE@XZ ; CGrowableArray<CD3DEnumDeviceInfo *>::CGrowableArray<CD3DEnumDeviceInfo *>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CD3DEnumAdapterInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1360				; 00000550H
	jmp	??1?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAE@XZ ; CGrowableArray<_D3DDISPLAYMODE>::~CGrowableArray<_D3DDISPLAYMODE>
__ehhandler$??0CD3DEnumAdapterInfo@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CD3DEnumAdapterInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CD3DEnumAdapterInfo@@QAE@XZ ENDP			; CD3DEnumAdapterInfo::CD3DEnumAdapterInfo
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?SetSizeInternal@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@IAEJH@Z
_TEXT	SEGMENT
tv91 = -232						; size = 4
tv85 = -232						; size = 4
_pDataNew$1 = -32					; size = 4
_nGrowBy$2 = -20					; size = 4
_this$ = -8						; size = 4
_nNewMaxSize$ = 8					; size = 4
?SetSizeInternal@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@IAEJH@Z PROC ; CGrowableArray<CD3DEnumDeviceInfo *>::SetSizeInternal, COMDAT
; _this$ = ecx

; 670  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 671  :     if( nNewMaxSize < 0 )

	cmp	DWORD PTR _nNewMaxSize$[ebp], 0
	jge	SHORT $LN7@SetSizeInt

; 672  :     {
; 673  :         assert( false );

	xor	eax, eax
	jne	SHORT $LN10@SetSizeInt
	push	673					; 000002a1H
	push	OFFSET ??_C@_1FK@FIMIDMPE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
	push	OFFSET ??_C@_1M@HLGKFCJM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN10@SetSizeInt:

; 674  :         return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H
	jmp	$LN8@SetSizeInt
$LN7@SetSizeInt:

; 675  :     }
; 676  : 
; 677  :     if( nNewMaxSize == 0 )

	cmp	DWORD PTR _nNewMaxSize$[ebp], 0
	jne	SHORT $LN6@SetSizeInt

; 678  :     {
; 679  :         // Shrink to 0 size & cleanup
; 680  :         if( m_pData )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@SetSizeInt

; 681  :         {
; 682  :             free( m_pData );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_free
	add	esp, 4

; 683  :             m_pData = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN5@SetSizeInt:

; 684  :         }
; 685  : 
; 686  :         m_nMaxSize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 687  :         m_nSize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	jmp	$LN4@SetSizeInt
$LN6@SetSizeInt:

; 688  :     }
; 689  :     else if( m_pData == NULL || nNewMaxSize > m_nMaxSize )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@SetSizeInt
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nNewMaxSize$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jle	$LN4@SetSizeInt
$LN2@SetSizeInt:

; 690  :     {
; 691  :         // Grow array
; 692  :         int nGrowBy = ( m_nMaxSize == 0 ) ? 16 : m_nMaxSize;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN11@SetSizeInt
	mov	DWORD PTR tv85[ebp], 16			; 00000010H
	jmp	SHORT $LN12@SetSizeInt
$LN11@SetSizeInt:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv85[ebp], edx
$LN12@SetSizeInt:
	mov	eax, DWORD PTR tv85[ebp]
	mov	DWORD PTR _nGrowBy$2[ebp], eax

; 693  :         nNewMaxSize = __max( nNewMaxSize, m_nMaxSize + nGrowBy );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _nGrowBy$2[ebp]
	cmp	DWORD PTR _nNewMaxSize$[ebp], ecx
	jle	SHORT $LN13@SetSizeInt
	mov	edx, DWORD PTR _nNewMaxSize$[ebp]
	mov	DWORD PTR tv91[ebp], edx
	jmp	SHORT $LN14@SetSizeInt
$LN13@SetSizeInt:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _nGrowBy$2[ebp]
	mov	DWORD PTR tv91[ebp], ecx
$LN14@SetSizeInt:
	mov	edx, DWORD PTR tv91[ebp]
	mov	DWORD PTR _nNewMaxSize$[ebp], edx

; 694  : 
; 695  :         TYPE* pDataNew = (TYPE*) realloc( m_pData, nNewMaxSize * sizeof(TYPE) );

	mov	eax, DWORD PTR _nNewMaxSize$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_realloc
	add	esp, 8
	mov	DWORD PTR _pDataNew$1[ebp], eax

; 696  :         if( pDataNew == NULL )

	cmp	DWORD PTR _pDataNew$1[ebp], 0
	jne	SHORT $LN1@SetSizeInt

; 697  :             return E_OUTOFMEMORY;

	mov	eax, -2147024882			; 8007000eH
	jmp	SHORT $LN8@SetSizeInt
$LN1@SetSizeInt:

; 698  : 
; 699  :         m_pData = pDataNew;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pDataNew$1[ebp]
	mov	DWORD PTR [eax], ecx

; 700  :         m_nMaxSize = nNewMaxSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nNewMaxSize$[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN4@SetSizeInt:

; 701  :     }
; 702  : 
; 703  :     return S_OK;

	xor	eax, eax
$LN8@SetSizeInt:

; 704  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSizeInternal@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@IAEJH@Z ENDP ; CGrowableArray<CD3DEnumDeviceInfo *>::SetSizeInternal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?RemoveAll@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?RemoveAll@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QAEXXZ PROC ; CGrowableArray<CD3DEnumDeviceInfo *>::RemoveAll, COMDAT
; _this$ = ecx

; 47   :     void    RemoveAll() { SetSize(0); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QAEJH@Z ; CGrowableArray<CD3DEnumDeviceInfo *>::SetSize
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QAEXXZ ENDP ; CGrowableArray<CD3DEnumDeviceInfo *>::RemoveAll
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?GetSize@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetSize@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QBEHXZ PROC ; CGrowableArray<CD3DEnumDeviceInfo *>::GetSize, COMDAT
; _this$ = ecx

; 34   :     int     GetSize() const { return m_nSize; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSize@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QBEHXZ ENDP ; CGrowableArray<CD3DEnumDeviceInfo *>::GetSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?GetAt@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QAEAAPAVCD3DEnumDeviceInfo@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nIndex$ = 8						; size = 4
?GetAt@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QAEAAPAVCD3DEnumDeviceInfo@@H@Z PROC ; CGrowableArray<CD3DEnumDeviceInfo *>::GetAt, COMDAT
; _this$ = ecx

; 33   :     TYPE&   GetAt( int nIndex ) { assert( nIndex >= 0 && nIndex < m_nSize ); return m_pData[nIndex]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _nIndex$[ebp], 0
	jl	SHORT $LN3@GetAt
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jl	SHORT $LN4@GetAt
$LN3@GetAt:
	push	33					; 00000021H
	push	OFFSET ??_C@_1FK@FIMIDMPE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
	push	OFFSET ??_C@_1EA@JHMKKLFC@?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAm?$AA_?$AAn?$AAS?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@GetAt:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _nIndex$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetAt@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QAEAAPAVCD3DEnumDeviceInfo@@H@Z ENDP ; CGrowableArray<CD3DEnumDeviceInfo *>::GetAt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?Add@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QAEJABQAVCD3DEnumDeviceInfo@@@Z
_TEXT	SEGMENT
$T1 = -224						; size = 4
_hr$ = -20						; size = 4
_this$ = -8						; size = 4
_value$ = 8						; size = 4
?Add@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QAEJABQAVCD3DEnumDeviceInfo@@@Z PROC ; CGrowableArray<CD3DEnumDeviceInfo *>::Add, COMDAT
; _this$ = ecx

; 740  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 741  :     HRESULT hr;
; 742  :     if( FAILED( hr = SetSizeInternal( m_nSize + 1 ) ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSizeInternal@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@IAEJH@Z ; CGrowableArray<CD3DEnumDeviceInfo *>::SetSizeInternal
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN1@Add

; 743  :         return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	jmp	SHORT $LN2@Add
$LN1@Add:

; 744  : 
; 745  :     // Construct the new element
; 746  :     ::new (&m_pData[m_nSize]) TYPE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*4]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax

; 747  : 
; 748  :     // Assign
; 749  :     m_pData[m_nSize] = value;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _value$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [eax+ecx*4], edx

; 750  :     ++m_nSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 751  : 
; 752  :     return S_OK;

	xor	eax, eax
$LN2@Add:

; 753  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Add@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QAEJABQAVCD3DEnumDeviceInfo@@@Z ENDP ; CGrowableArray<CD3DEnumDeviceInfo *>::Add
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?SetSize@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QAEJH@Z
_TEXT	SEGMENT
$T1 = -260						; size = 4
_i$2 = -56						; size = 4
_hr$ = -44						; size = 4
_i$3 = -32						; size = 4
_nOldSize$ = -20					; size = 4
_this$ = -8						; size = 4
_nNewMaxSize$ = 8					; size = 4
?SetSize@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QAEJH@Z PROC ; CGrowableArray<CD3DEnumDeviceInfo *>::SetSize, COMDAT
; _this$ = ecx

; 710  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 711  :     int nOldSize = m_nSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _nOldSize$[ebp], ecx

; 712  : 
; 713  :     if( nOldSize > nNewMaxSize )

	mov	eax, DWORD PTR _nOldSize$[ebp]
	cmp	eax, DWORD PTR _nNewMaxSize$[ebp]
	jle	SHORT $LN8@SetSize

; 714  :     {
; 715  :         // Removing elements. Call dtor.
; 716  : 
; 717  :         for( int i = nNewMaxSize; i < nOldSize; ++i )

	mov	eax, DWORD PTR _nNewMaxSize$[ebp]
	mov	DWORD PTR _i$3[ebp], eax
	jmp	SHORT $LN7@SetSize
$LN6@SetSize:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN7@SetSize:
	mov	eax, DWORD PTR _i$3[ebp]
	cmp	eax, DWORD PTR _nOldSize$[ebp]
	jge	SHORT $LN8@SetSize

; 718  :             m_pData[i].~TYPE();

	jmp	SHORT $LN6@SetSize
$LN8@SetSize:

; 719  :     }
; 720  : 
; 721  :     // Adjust buffer.  Note that there's no need to check for error
; 722  :     // since if it happens, nOldSize == nNewMaxSize will be true.)
; 723  :     HRESULT hr = SetSizeInternal( nNewMaxSize );

	mov	eax, DWORD PTR _nNewMaxSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSizeInternal@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@IAEJH@Z ; CGrowableArray<CD3DEnumDeviceInfo *>::SetSizeInternal
	mov	DWORD PTR _hr$[ebp], eax

; 724  : 
; 725  :     if( nOldSize < nNewMaxSize )

	mov	eax, DWORD PTR _nOldSize$[ebp]
	cmp	eax, DWORD PTR _nNewMaxSize$[ebp]
	jge	SHORT $LN4@SetSize

; 726  :     {
; 727  :         // Adding elements. Call ctor.
; 728  : 
; 729  :         for( int i = nOldSize; i < nNewMaxSize; ++i )

	mov	eax, DWORD PTR _nOldSize$[ebp]
	mov	DWORD PTR _i$2[ebp], eax
	jmp	SHORT $LN3@SetSize
$LN2@SetSize:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN3@SetSize:
	mov	eax, DWORD PTR _i$2[ebp]
	cmp	eax, DWORD PTR _nNewMaxSize$[ebp]
	jge	SHORT $LN4@SetSize

; 730  :             ::new (&m_pData[i]) TYPE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$2[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	jmp	SHORT $LN2@SetSize
$LN4@SetSize:

; 731  :     }
; 732  : 
; 733  :     return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 734  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSize@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QAEJH@Z ENDP ; CGrowableArray<CD3DEnumDeviceInfo *>::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ??1?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QAE@XZ PROC ; CGrowableArray<CD3DEnumDeviceInfo *>::~CGrowableArray<CD3DEnumDeviceInfo *>, COMDAT
; _this$ = ecx

; 22   :     ~CGrowableArray() { RemoveAll(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QAEXXZ ; CGrowableArray<CD3DEnumDeviceInfo *>::RemoveAll
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QAE@XZ ENDP ; CGrowableArray<CD3DEnumDeviceInfo *>::~CGrowableArray<CD3DEnumDeviceInfo *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ??0?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QAE@XZ PROC ; CGrowableArray<CD3DEnumDeviceInfo *>::CGrowableArray<CD3DEnumDeviceInfo *>, COMDAT
; _this$ = ecx

; 20   :     CGrowableArray()  { m_pData = NULL; m_nSize = 0; m_nMaxSize = 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QAE@XZ ENDP ; CGrowableArray<CD3DEnumDeviceInfo *>::CGrowableArray<CD3DEnumDeviceInfo *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?SetSizeInternal@?$CGrowableArray@U_D3DDISPLAYMODE@@@@IAEJH@Z
_TEXT	SEGMENT
tv91 = -232						; size = 4
tv85 = -232						; size = 4
_pDataNew$1 = -32					; size = 4
_nGrowBy$2 = -20					; size = 4
_this$ = -8						; size = 4
_nNewMaxSize$ = 8					; size = 4
?SetSizeInternal@?$CGrowableArray@U_D3DDISPLAYMODE@@@@IAEJH@Z PROC ; CGrowableArray<_D3DDISPLAYMODE>::SetSizeInternal, COMDAT
; _this$ = ecx

; 670  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 671  :     if( nNewMaxSize < 0 )

	cmp	DWORD PTR _nNewMaxSize$[ebp], 0
	jge	SHORT $LN7@SetSizeInt

; 672  :     {
; 673  :         assert( false );

	xor	eax, eax
	jne	SHORT $LN10@SetSizeInt
	push	673					; 000002a1H
	push	OFFSET ??_C@_1FK@FIMIDMPE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
	push	OFFSET ??_C@_1M@HLGKFCJM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN10@SetSizeInt:

; 674  :         return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H
	jmp	$LN8@SetSizeInt
$LN7@SetSizeInt:

; 675  :     }
; 676  : 
; 677  :     if( nNewMaxSize == 0 )

	cmp	DWORD PTR _nNewMaxSize$[ebp], 0
	jne	SHORT $LN6@SetSizeInt

; 678  :     {
; 679  :         // Shrink to 0 size & cleanup
; 680  :         if( m_pData )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@SetSizeInt

; 681  :         {
; 682  :             free( m_pData );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_free
	add	esp, 4

; 683  :             m_pData = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN5@SetSizeInt:

; 684  :         }
; 685  : 
; 686  :         m_nMaxSize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 687  :         m_nSize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	jmp	$LN4@SetSizeInt
$LN6@SetSizeInt:

; 688  :     }
; 689  :     else if( m_pData == NULL || nNewMaxSize > m_nMaxSize )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@SetSizeInt
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nNewMaxSize$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jle	$LN4@SetSizeInt
$LN2@SetSizeInt:

; 690  :     {
; 691  :         // Grow array
; 692  :         int nGrowBy = ( m_nMaxSize == 0 ) ? 16 : m_nMaxSize;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN11@SetSizeInt
	mov	DWORD PTR tv85[ebp], 16			; 00000010H
	jmp	SHORT $LN12@SetSizeInt
$LN11@SetSizeInt:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv85[ebp], edx
$LN12@SetSizeInt:
	mov	eax, DWORD PTR tv85[ebp]
	mov	DWORD PTR _nGrowBy$2[ebp], eax

; 693  :         nNewMaxSize = __max( nNewMaxSize, m_nMaxSize + nGrowBy );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _nGrowBy$2[ebp]
	cmp	DWORD PTR _nNewMaxSize$[ebp], ecx
	jle	SHORT $LN13@SetSizeInt
	mov	edx, DWORD PTR _nNewMaxSize$[ebp]
	mov	DWORD PTR tv91[ebp], edx
	jmp	SHORT $LN14@SetSizeInt
$LN13@SetSizeInt:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _nGrowBy$2[ebp]
	mov	DWORD PTR tv91[ebp], ecx
$LN14@SetSizeInt:
	mov	edx, DWORD PTR tv91[ebp]
	mov	DWORD PTR _nNewMaxSize$[ebp], edx

; 694  : 
; 695  :         TYPE* pDataNew = (TYPE*) realloc( m_pData, nNewMaxSize * sizeof(TYPE) );

	mov	eax, DWORD PTR _nNewMaxSize$[ebp]
	shl	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_realloc
	add	esp, 8
	mov	DWORD PTR _pDataNew$1[ebp], eax

; 696  :         if( pDataNew == NULL )

	cmp	DWORD PTR _pDataNew$1[ebp], 0
	jne	SHORT $LN1@SetSizeInt

; 697  :             return E_OUTOFMEMORY;

	mov	eax, -2147024882			; 8007000eH
	jmp	SHORT $LN8@SetSizeInt
$LN1@SetSizeInt:

; 698  : 
; 699  :         m_pData = pDataNew;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pDataNew$1[ebp]
	mov	DWORD PTR [eax], ecx

; 700  :         m_nMaxSize = nNewMaxSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nNewMaxSize$[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN4@SetSizeInt:

; 701  :     }
; 702  : 
; 703  :     return S_OK;

	xor	eax, eax
$LN8@SetSizeInt:

; 704  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSizeInternal@?$CGrowableArray@U_D3DDISPLAYMODE@@@@IAEJH@Z ENDP ; CGrowableArray<_D3DDISPLAYMODE>::SetSizeInternal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?RemoveAll@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?RemoveAll@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAEXXZ PROC ; CGrowableArray<_D3DDISPLAYMODE>::RemoveAll, COMDAT
; _this$ = ecx

; 47   :     void    RemoveAll() { SetSize(0); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAEJH@Z ; CGrowableArray<_D3DDISPLAYMODE>::SetSize
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAEXXZ ENDP ; CGrowableArray<_D3DDISPLAYMODE>::RemoveAll
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?GetData@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAEPAU_D3DDISPLAYMODE@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetData@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAEPAU_D3DDISPLAYMODE@@XZ PROC ; CGrowableArray<_D3DDISPLAYMODE>::GetData, COMDAT
; _this$ = ecx

; 35   :     TYPE*   GetData() { return m_pData; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetData@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAEPAU_D3DDISPLAYMODE@@XZ ENDP ; CGrowableArray<_D3DDISPLAYMODE>::GetData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?GetSize@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetSize@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QBEHXZ PROC ; CGrowableArray<_D3DDISPLAYMODE>::GetSize, COMDAT
; _this$ = ecx

; 34   :     int     GetSize() const { return m_nSize; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSize@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QBEHXZ ENDP ; CGrowableArray<_D3DDISPLAYMODE>::GetSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?Add@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAEJABU_D3DDISPLAYMODE@@@Z
_TEXT	SEGMENT
$T1 = -224						; size = 4
_hr$ = -20						; size = 4
_this$ = -8						; size = 4
_value$ = 8						; size = 4
?Add@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAEJABU_D3DDISPLAYMODE@@@Z PROC ; CGrowableArray<_D3DDISPLAYMODE>::Add, COMDAT
; _this$ = ecx

; 740  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 741  :     HRESULT hr;
; 742  :     if( FAILED( hr = SetSizeInternal( m_nSize + 1 ) ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSizeInternal@?$CGrowableArray@U_D3DDISPLAYMODE@@@@IAEJH@Z ; CGrowableArray<_D3DDISPLAYMODE>::SetSizeInternal
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN1@Add

; 743  :         return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	jmp	SHORT $LN2@Add
$LN1@Add:

; 744  : 
; 745  :     // Construct the new element
; 746  :     ::new (&m_pData[m_nSize]) TYPE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	push	16					; 00000010H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax

; 747  : 
; 748  :     // Assign
; 749  :     m_pData[m_nSize] = value;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, ecx
	mov	ecx, DWORD PTR _value$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ecx

; 750  :     ++m_nSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 751  : 
; 752  :     return S_OK;

	xor	eax, eax
$LN2@Add:

; 753  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Add@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAEJABU_D3DDISPLAYMODE@@@Z ENDP ; CGrowableArray<_D3DDISPLAYMODE>::Add
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?SetSize@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAEJH@Z
_TEXT	SEGMENT
$T1 = -260						; size = 4
_i$2 = -56						; size = 4
_hr$ = -44						; size = 4
_i$3 = -32						; size = 4
_nOldSize$ = -20					; size = 4
_this$ = -8						; size = 4
_nNewMaxSize$ = 8					; size = 4
?SetSize@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAEJH@Z PROC ; CGrowableArray<_D3DDISPLAYMODE>::SetSize, COMDAT
; _this$ = ecx

; 710  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 711  :     int nOldSize = m_nSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _nOldSize$[ebp], ecx

; 712  : 
; 713  :     if( nOldSize > nNewMaxSize )

	mov	eax, DWORD PTR _nOldSize$[ebp]
	cmp	eax, DWORD PTR _nNewMaxSize$[ebp]
	jle	SHORT $LN8@SetSize

; 714  :     {
; 715  :         // Removing elements. Call dtor.
; 716  : 
; 717  :         for( int i = nNewMaxSize; i < nOldSize; ++i )

	mov	eax, DWORD PTR _nNewMaxSize$[ebp]
	mov	DWORD PTR _i$3[ebp], eax
	jmp	SHORT $LN7@SetSize
$LN6@SetSize:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN7@SetSize:
	mov	eax, DWORD PTR _i$3[ebp]
	cmp	eax, DWORD PTR _nOldSize$[ebp]
	jge	SHORT $LN8@SetSize

; 718  :             m_pData[i].~TYPE();

	jmp	SHORT $LN6@SetSize
$LN8@SetSize:

; 719  :     }
; 720  : 
; 721  :     // Adjust buffer.  Note that there's no need to check for error
; 722  :     // since if it happens, nOldSize == nNewMaxSize will be true.)
; 723  :     HRESULT hr = SetSizeInternal( nNewMaxSize );

	mov	eax, DWORD PTR _nNewMaxSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSizeInternal@?$CGrowableArray@U_D3DDISPLAYMODE@@@@IAEJH@Z ; CGrowableArray<_D3DDISPLAYMODE>::SetSizeInternal
	mov	DWORD PTR _hr$[ebp], eax

; 724  : 
; 725  :     if( nOldSize < nNewMaxSize )

	mov	eax, DWORD PTR _nOldSize$[ebp]
	cmp	eax, DWORD PTR _nNewMaxSize$[ebp]
	jge	SHORT $LN4@SetSize

; 726  :     {
; 727  :         // Adding elements. Call ctor.
; 728  : 
; 729  :         for( int i = nOldSize; i < nNewMaxSize; ++i )

	mov	eax, DWORD PTR _nOldSize$[ebp]
	mov	DWORD PTR _i$2[ebp], eax
	jmp	SHORT $LN3@SetSize
$LN2@SetSize:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN3@SetSize:
	mov	eax, DWORD PTR _i$2[ebp]
	cmp	eax, DWORD PTR _nNewMaxSize$[ebp]
	jge	SHORT $LN4@SetSize

; 730  :             ::new (&m_pData[i]) TYPE;

	mov	eax, DWORD PTR _i$2[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	push	eax
	push	16					; 00000010H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	jmp	SHORT $LN2@SetSize
$LN4@SetSize:

; 731  :     }
; 732  : 
; 733  :     return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 734  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSize@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAEJH@Z ENDP ; CGrowableArray<_D3DDISPLAYMODE>::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ??1?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAE@XZ PROC	; CGrowableArray<_D3DDISPLAYMODE>::~CGrowableArray<_D3DDISPLAYMODE>, COMDAT
; _this$ = ecx

; 22   :     ~CGrowableArray() { RemoveAll(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAEXXZ ; CGrowableArray<_D3DDISPLAYMODE>::RemoveAll
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAE@XZ ENDP	; CGrowableArray<_D3DDISPLAYMODE>::~CGrowableArray<_D3DDISPLAYMODE>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ??0?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAE@XZ PROC	; CGrowableArray<_D3DDISPLAYMODE>::CGrowableArray<_D3DDISPLAYMODE>, COMDAT
; _this$ = ecx

; 20   :     CGrowableArray()  { m_pData = NULL; m_nSize = 0; m_nMaxSize = 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAE@XZ ENDP	; CGrowableArray<_D3DDISPLAYMODE>::CGrowableArray<_D3DDISPLAYMODE>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutenum.cpp
;	COMDAT ??1CD3DEnumAdapterInfo@@QAE@XZ
_TEXT	SEGMENT
tv81 = -268						; size = 4
$T2 = -260						; size = 4
$T3 = -248						; size = 4
_i$4 = -44						; size = 4
_pDeviceInfo$ = -32					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1CD3DEnumAdapterInfo@@QAE@XZ PROC			; CD3DEnumAdapterInfo::~CD3DEnumAdapterInfo, COMDAT
; _this$ = ecx

; 728  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CD3DEnumAdapterInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-268]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 729  :     CD3DEnumDeviceInfo* pDeviceInfo;
; 730  :     for( int i=0; i<deviceInfoList.GetSize(); i++ )

	mov	DWORD PTR _i$4[ebp], 0
	jmp	SHORT $LN3@CD3DEnumAd
$LN2@CD3DEnumAd:
	mov	eax, DWORD PTR _i$4[ebp]
	add	eax, 1
	mov	DWORD PTR _i$4[ebp], eax
$LN3@CD3DEnumAd:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1372				; 0000055cH
	call	?GetSize@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QBEHXZ ; CGrowableArray<CD3DEnumDeviceInfo *>::GetSize
	cmp	DWORD PTR _i$4[ebp], eax
	jge	SHORT $LN1@CD3DEnumAd

; 731  :     {
; 732  :         pDeviceInfo = deviceInfoList.GetAt(i);

	mov	eax, DWORD PTR _i$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1372				; 0000055cH
	call	?GetAt@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QAEAAPAVCD3DEnumDeviceInfo@@H@Z ; CGrowableArray<CD3DEnumDeviceInfo *>::GetAt
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pDeviceInfo$[ebp], ecx

; 733  :         delete pDeviceInfo;

	mov	eax, DWORD PTR _pDeviceInfo$[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN6@CD3DEnumAd
	push	1
	mov	ecx, DWORD PTR $T2[ebp]
	call	??_GCD3DEnumDeviceInfo@@QAEPAXI@Z
	mov	DWORD PTR tv81[ebp], eax
	jmp	SHORT $LN7@CD3DEnumAd
$LN6@CD3DEnumAd:
	mov	DWORD PTR tv81[ebp], 0
$LN7@CD3DEnumAd:

; 734  :     }

	jmp	SHORT $LN2@CD3DEnumAd
$LN1@CD3DEnumAd:

; 735  :     deviceInfoList.RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1372				; 0000055cH
	call	?RemoveAll@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QAEXXZ ; CGrowableArray<CD3DEnumDeviceInfo *>::RemoveAll

; 736  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1372				; 0000055cH
	call	??1?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QAE@XZ ; CGrowableArray<CD3DEnumDeviceInfo *>::~CGrowableArray<CD3DEnumDeviceInfo *>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1360				; 00000550H
	call	??1?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAE@XZ ; CGrowableArray<_D3DDISPLAYMODE>::~CGrowableArray<_D3DDISPLAYMODE>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 268				; 0000010cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CD3DEnumAdapterInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1360				; 00000550H
	jmp	??1?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAE@XZ ; CGrowableArray<_D3DDISPLAYMODE>::~CGrowableArray<_D3DDISPLAYMODE>
__unwindfunclet$??1CD3DEnumAdapterInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1372				; 0000055cH
	jmp	??1?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QAE@XZ ; CGrowableArray<CD3DEnumDeviceInfo *>::~CGrowableArray<CD3DEnumDeviceInfo *>
__ehhandler$??1CD3DEnumAdapterInfo@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-272]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CD3DEnumAdapterInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CD3DEnumAdapterInfo@@QAE@XZ ENDP			; CD3DEnumAdapterInfo::~CD3DEnumAdapterInfo
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutenum.cpp
;	COMDAT ?ClearAdapterInfoList@CD3DEnumeration@@AAEXXZ
_TEXT	SEGMENT
tv77 = -256						; size = 4
$T1 = -248						; size = 4
$T2 = -236						; size = 4
_i$3 = -32						; size = 4
_pAdapterInfo$ = -20					; size = 4
_this$ = -8						; size = 4
?ClearAdapterInfoList@CD3DEnumeration@@AAEXXZ PROC	; CD3DEnumeration::ClearAdapterInfoList, COMDAT
; _this$ = ecx

; 470  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 471  :     CD3DEnumAdapterInfo* pAdapterInfo;
; 472  :     for( int i=0; i<m_AdapterInfoList.GetSize(); i++ )

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN3@ClearAdapt
$LN2@ClearAdapt:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN3@ClearAdapt:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 81					; 00000051H
	call	?GetSize@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QBEHXZ ; CGrowableArray<CD3DEnumAdapterInfo *>::GetSize
	cmp	DWORD PTR _i$3[ebp], eax
	jge	SHORT $LN1@ClearAdapt

; 473  :     {
; 474  :         pAdapterInfo = m_AdapterInfoList.GetAt(i);

	mov	eax, DWORD PTR _i$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 81					; 00000051H
	call	?GetAt@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAEAAPAVCD3DEnumAdapterInfo@@H@Z ; CGrowableArray<CD3DEnumAdapterInfo *>::GetAt
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pAdapterInfo$[ebp], ecx

; 475  :         delete pAdapterInfo;

	mov	eax, DWORD PTR _pAdapterInfo$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN6@ClearAdapt
	push	1
	mov	ecx, DWORD PTR $T1[ebp]
	call	??_GCD3DEnumAdapterInfo@@QAEPAXI@Z
	mov	DWORD PTR tv77[ebp], eax
	jmp	SHORT $LN7@ClearAdapt
$LN6@ClearAdapt:
	mov	DWORD PTR tv77[ebp], 0
$LN7@ClearAdapt:

; 476  :     }

	jmp	SHORT $LN2@ClearAdapt
$LN1@ClearAdapt:

; 477  : 
; 478  :     m_AdapterInfoList.RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 81					; 00000051H
	call	?RemoveAll@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAEXXZ ; CGrowableArray<CD3DEnumAdapterInfo *>::RemoveAll

; 479  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?ClearAdapterInfoList@CD3DEnumeration@@AAEXXZ ENDP	; CD3DEnumeration::ClearAdapterInfoList
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutenum.cpp
;	COMDAT ?BuildPresentIntervalList@CD3DEnumeration@@AAEXPAVCD3DEnumDeviceInfo@@PAUCD3DEnumDeviceSettingsCombo@@@Z
_TEXT	SEGMENT
_ipi$1 = -32						; size = 4
_pi$ = -20						; size = 4
_this$ = -8						; size = 4
_pDeviceInfo$ = 8					; size = 4
_pDeviceCombo$ = 12					; size = 4
?BuildPresentIntervalList@CD3DEnumeration@@AAEXPAVCD3DEnumDeviceInfo@@PAUCD3DEnumDeviceSettingsCombo@@@Z PROC ; CD3DEnumeration::BuildPresentIntervalList, COMDAT
; _this$ = ecx

; 439  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 440  :     UINT pi;
; 441  :     for( int ipi = 0; ipi < m_PresentIntervalList.GetSize(); ipi++ )

	mov	DWORD PTR _ipi$1[ebp], 0
	jmp	SHORT $LN8@BuildPrese
$LN7@BuildPrese:
	mov	eax, DWORD PTR _ipi$1[ebp]
	add	eax, 1
	mov	DWORD PTR _ipi$1[ebp], eax
$LN8@BuildPrese:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 37					; 00000025H
	call	?GetSize@?$CGrowableArray@I@@QBEHXZ	; CGrowableArray<unsigned int>::GetSize
	cmp	DWORD PTR _ipi$1[ebp], eax
	jge	SHORT $LN9@BuildPrese

; 442  :     {
; 443  :         pi = m_PresentIntervalList.GetAt(ipi);

	mov	eax, DWORD PTR _ipi$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 37					; 00000025H
	call	?GetAt@?$CGrowableArray@I@@QAEAAIH@Z	; CGrowableArray<unsigned int>::GetAt
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pi$[ebp], ecx

; 444  :         if( pDeviceCombo->Windowed )

	mov	eax, DWORD PTR _pDeviceCombo$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN5@BuildPrese

; 445  :         {
; 446  :             if( pi == D3DPRESENT_INTERVAL_TWO ||
; 447  :                 pi == D3DPRESENT_INTERVAL_THREE ||
; 448  :                 pi == D3DPRESENT_INTERVAL_FOUR )

	cmp	DWORD PTR _pi$[ebp], 2
	je	SHORT $LN3@BuildPrese
	cmp	DWORD PTR _pi$[ebp], 4
	je	SHORT $LN3@BuildPrese
	cmp	DWORD PTR _pi$[ebp], 8
	jne	SHORT $LN5@BuildPrese
$LN3@BuildPrese:

; 449  :             {
; 450  :                 // These intervals are not supported in windowed mode.
; 451  :                 continue;

	jmp	SHORT $LN7@BuildPrese
$LN5@BuildPrese:

; 452  :             }
; 453  :         }
; 454  :         // Note that D3DPRESENT_INTERVAL_DEFAULT is zero, so you
; 455  :         // can't do a caps check for it -- it is always available.
; 456  :         if( pi == D3DPRESENT_INTERVAL_DEFAULT ||
; 457  :             (pDeviceInfo->Caps.PresentationIntervals & pi) )

	cmp	DWORD PTR _pi$[ebp], 0
	je	SHORT $LN1@BuildPrese
	mov	eax, DWORD PTR _pDeviceInfo$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	and	ecx, DWORD PTR _pi$[ebp]
	je	SHORT $LN2@BuildPrese
$LN1@BuildPrese:

; 458  :         {
; 459  :             pDeviceCombo->presentIntervalList.Add( pi );

	lea	eax, DWORD PTR _pi$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeviceCombo$[ebp]
	add	ecx, 56					; 00000038H
	call	?Add@?$CGrowableArray@I@@QAEJABI@Z	; CGrowableArray<unsigned int>::Add
$LN2@BuildPrese:

; 460  :         }
; 461  :     }

	jmp	SHORT $LN7@BuildPrese
$LN9@BuildPrese:

; 462  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN13@BuildPrese
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN13@BuildPrese:
	DD	1
	DD	$LN12@BuildPrese
$LN12@BuildPrese:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN11@BuildPrese
$LN11@BuildPrese:
	DB	112					; 00000070H
	DB	105					; 00000069H
	DB	0
?BuildPresentIntervalList@CD3DEnumeration@@AAEXPAVCD3DEnumDeviceInfo@@PAUCD3DEnumDeviceSettingsCombo@@@Z ENDP ; CD3DEnumeration::BuildPresentIntervalList
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutenum.cpp
;	COMDAT ?BuildDSMSConflictList@CD3DEnumeration@@AAEXPAUCD3DEnumDeviceSettingsCombo@@@Z
_TEXT	SEGMENT
_msType$1 = -72						; size = 4
_iMS$2 = -60						; size = 4
_dsFmt$3 = -48						; size = 4
_iDS$4 = -36						; size = 4
_DSMSConflict$ = -24					; size = 8
_this$ = -8						; size = 4
_pDeviceCombo$ = 8					; size = 4
?BuildDSMSConflictList@CD3DEnumeration@@AAEXPAUCD3DEnumDeviceSettingsCombo@@@Z PROC ; CD3DEnumeration::BuildDSMSConflictList, COMDAT
; _this$ = ecx

; 409  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-268]
	mov	ecx, 67					; 00000043H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 410  :     CD3DEnumDSMSConflict DSMSConflict;
; 411  : 
; 412  :     for( int iDS=0; iDS<pDeviceCombo->depthStencilFormatList.GetSize(); iDS++ )

	mov	DWORD PTR _iDS$4[ebp], 0
	jmp	SHORT $LN7@BuildDSMSC
$LN6@BuildDSMSC:
	mov	eax, DWORD PTR _iDS$4[ebp]
	add	eax, 1
	mov	DWORD PTR _iDS$4[ebp], eax
$LN7@BuildDSMSC:
	mov	ecx, DWORD PTR _pDeviceCombo$[ebp]
	add	ecx, 20					; 00000014H
	call	?GetSize@?$CGrowableArray@W4_D3DFORMAT@@@@QBEHXZ ; CGrowableArray<enum _D3DFORMAT>::GetSize
	cmp	DWORD PTR _iDS$4[ebp], eax
	jge	$LN8@BuildDSMSC

; 413  :     {
; 414  :         D3DFORMAT dsFmt = pDeviceCombo->depthStencilFormatList.GetAt(iDS);

	mov	eax, DWORD PTR _iDS$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeviceCombo$[ebp]
	add	ecx, 20					; 00000014H
	call	?GetAt@?$CGrowableArray@W4_D3DFORMAT@@@@QAEAAW4_D3DFORMAT@@H@Z ; CGrowableArray<enum _D3DFORMAT>::GetAt
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _dsFmt$3[ebp], ecx

; 415  : 
; 416  :         for( int iMS=0; iMS<pDeviceCombo->multiSampleTypeList.GetSize(); iMS++ )

	mov	DWORD PTR _iMS$2[ebp], 0
	jmp	SHORT $LN4@BuildDSMSC
$LN3@BuildDSMSC:
	mov	eax, DWORD PTR _iMS$2[ebp]
	add	eax, 1
	mov	DWORD PTR _iMS$2[ebp], eax
$LN4@BuildDSMSC:
	mov	ecx, DWORD PTR _pDeviceCombo$[ebp]
	add	ecx, 32					; 00000020H
	call	?GetSize@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QBEHXZ ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::GetSize
	cmp	DWORD PTR _iMS$2[ebp], eax
	jge	SHORT $LN2@BuildDSMSC

; 417  :         {
; 418  :             D3DMULTISAMPLE_TYPE msType = pDeviceCombo->multiSampleTypeList.GetAt(iMS);

	mov	eax, DWORD PTR _iMS$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeviceCombo$[ebp]
	add	ecx, 32					; 00000020H
	call	?GetAt@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEAAW4_D3DMULTISAMPLE_TYPE@@H@Z ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::GetAt
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _msType$1[ebp], ecx

; 419  : 
; 420  :             if( FAILED( m_pD3D->CheckDeviceMultiSampleType( pDeviceCombo->AdapterOrdinal, pDeviceCombo->DeviceType,
; 421  :                                                             dsFmt, pDeviceCombo->Windowed, msType, NULL ) ) )

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR _msType$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeviceCombo$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _dsFmt$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeviceCombo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _pDeviceCombo$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+44]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jge	SHORT $LN1@BuildDSMSC

; 422  :             {
; 423  :                 DSMSConflict.DSFormat = dsFmt;

	mov	eax, DWORD PTR _dsFmt$3[ebp]
	mov	DWORD PTR _DSMSConflict$[ebp], eax

; 424  :                 DSMSConflict.MSType = msType;

	mov	eax, DWORD PTR _msType$1[ebp]
	mov	DWORD PTR _DSMSConflict$[ebp+4], eax

; 425  :                 pDeviceCombo->DSMSConflictList.Add( DSMSConflict );

	lea	eax, DWORD PTR _DSMSConflict$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeviceCombo$[ebp]
	add	ecx, 68					; 00000044H
	call	?Add@?$CGrowableArray@UCD3DEnumDSMSConflict@@@@QAEJABUCD3DEnumDSMSConflict@@@Z ; CGrowableArray<CD3DEnumDSMSConflict>::Add
$LN1@BuildDSMSC:

; 426  :             }
; 427  :         }

	jmp	$LN3@BuildDSMSC
$LN2@BuildDSMSC:

; 428  :     }

	jmp	$LN6@BuildDSMSC
$LN8@BuildDSMSC:

; 429  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@BuildDSMSC
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 268				; 0000010cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$LN12@BuildDSMSC:
	DD	1
	DD	$LN11@BuildDSMSC
$LN11@BuildDSMSC:
	DD	-24					; ffffffe8H
	DD	8
	DD	$LN10@BuildDSMSC
$LN10@BuildDSMSC:
	DB	68					; 00000044H
	DB	83					; 00000053H
	DB	77					; 0000004dH
	DB	83					; 00000053H
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	102					; 00000066H
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	0
?BuildDSMSConflictList@CD3DEnumeration@@AAEXPAUCD3DEnumDeviceSettingsCombo@@@Z ENDP ; CD3DEnumeration::BuildDSMSConflictList
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutenum.cpp
;	COMDAT ?BuildMultiSampleTypeList@CD3DEnumeration@@AAEXPAUCD3DEnumDeviceSettingsCombo@@@Z
_TEXT	SEGMENT
_imst$1 = -44						; size = 4
_msQuality$ = -32					; size = 4
_msType$ = -20						; size = 4
_this$ = -8						; size = 4
_pDeviceCombo$ = 8					; size = 4
?BuildMultiSampleTypeList@CD3DEnumeration@@AAEXPAUCD3DEnumDeviceSettingsCombo@@@Z PROC ; CD3DEnumeration::BuildMultiSampleTypeList, COMDAT
; _this$ = ecx

; 383  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 384  :     D3DMULTISAMPLE_TYPE msType;
; 385  :     DWORD msQuality;
; 386  :     for( int imst = 0; imst < m_MultiSampleTypeList.GetSize(); imst++ )

	mov	DWORD PTR _imst$1[ebp], 0
	jmp	SHORT $LN5@BuildMulti
$LN4@BuildMulti:
	mov	eax, DWORD PTR _imst$1[ebp]
	add	eax, 1
	mov	DWORD PTR _imst$1[ebp], eax
$LN5@BuildMulti:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 25					; 00000019H
	call	?GetSize@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QBEHXZ ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::GetSize
	cmp	DWORD PTR _imst$1[ebp], eax
	jge	$LN6@BuildMulti

; 387  :     {
; 388  :         msType = m_MultiSampleTypeList.GetAt(imst);

	mov	eax, DWORD PTR _imst$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 25					; 00000019H
	call	?GetAt@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEAAW4_D3DMULTISAMPLE_TYPE@@H@Z ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::GetAt
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _msType$[ebp], ecx

; 389  :         if( SUCCEEDED( m_pD3D->CheckDeviceMultiSampleType( pDeviceCombo->AdapterOrdinal, 
; 390  :                 pDeviceCombo->DeviceType, pDeviceCombo->BackBufferFormat, 
; 391  :                 pDeviceCombo->Windowed, msType, &msQuality ) ) )

	mov	esi, esp
	lea	eax, DWORD PTR _msQuality$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pDeviceCombo$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _pDeviceCombo$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _pDeviceCombo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _pDeviceCombo$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+44]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jl	SHORT $LN2@BuildMulti

; 392  :         {
; 393  :             pDeviceCombo->multiSampleTypeList.Add( msType );

	lea	eax, DWORD PTR _msType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeviceCombo$[ebp]
	add	ecx, 32					; 00000020H
	call	?Add@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEJABW4_D3DMULTISAMPLE_TYPE@@@Z ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::Add

; 394  :             if( msQuality > m_nMultisampleQualityMax+1 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+77]
	add	ecx, 1
	cmp	DWORD PTR _msQuality$[ebp], ecx
	jbe	SHORT $LN1@BuildMulti

; 395  :                 msQuality = m_nMultisampleQualityMax+1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+77]
	add	ecx, 1
	mov	DWORD PTR _msQuality$[ebp], ecx
$LN1@BuildMulti:

; 396  :             pDeviceCombo->multiSampleQualityList.Add( msQuality );

	lea	eax, DWORD PTR _msQuality$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeviceCombo$[ebp]
	add	ecx, 44					; 0000002cH
	call	?Add@?$CGrowableArray@K@@QAEJABK@Z	; CGrowableArray<unsigned long>::Add
$LN2@BuildMulti:

; 397  :         }
; 398  :     }

	jmp	$LN4@BuildMulti
$LN6@BuildMulti:

; 399  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@BuildMulti
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN11@BuildMulti:
	DD	2
	DD	$LN10@BuildMulti
$LN10@BuildMulti:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN8@BuildMulti
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN9@BuildMulti
$LN9@BuildMulti:
	DB	109					; 0000006dH
	DB	115					; 00000073H
	DB	81					; 00000051H
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	121					; 00000079H
	DB	0
$LN8@BuildMulti:
	DB	109					; 0000006dH
	DB	115					; 00000073H
	DB	84					; 00000054H
	DB	121					; 00000079H
	DB	112					; 00000070H
	DB	101					; 00000065H
	DB	0
?BuildMultiSampleTypeList@CD3DEnumeration@@AAEXPAUCD3DEnumDeviceSettingsCombo@@@Z ENDP ; CD3DEnumeration::BuildMultiSampleTypeList
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutenum.cpp
;	COMDAT ?BuildDepthStencilFormatList@CD3DEnumeration@@AAEXPAUCD3DEnumDeviceSettingsCombo@@@Z
_TEXT	SEGMENT
_idsf$1 = -32						; size = 4
_depthStencilFmt$ = -20					; size = 4
_this$ = -8						; size = 4
_pDeviceCombo$ = 8					; size = 4
?BuildDepthStencilFormatList@CD3DEnumeration@@AAEXPAUCD3DEnumDeviceSettingsCombo@@@Z PROC ; CD3DEnumeration::BuildDepthStencilFormatList, COMDAT
; _this$ = ecx

; 356  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 357  :     D3DFORMAT depthStencilFmt;
; 358  :     for( int idsf = 0; idsf < m_DepthStecilPossibleList.GetSize(); idsf++ )

	mov	DWORD PTR _idsf$1[ebp], 0
	jmp	SHORT $LN5@BuildDepth
$LN4@BuildDepth:
	mov	eax, DWORD PTR _idsf$1[ebp]
	add	eax, 1
	mov	DWORD PTR _idsf$1[ebp], eax
$LN5@BuildDepth:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 13					; 0000000dH
	call	?GetSize@?$CGrowableArray@W4_D3DFORMAT@@@@QBEHXZ ; CGrowableArray<enum _D3DFORMAT>::GetSize
	cmp	DWORD PTR _idsf$1[ebp], eax
	jge	$LN6@BuildDepth

; 359  :     {
; 360  :         depthStencilFmt = m_DepthStecilPossibleList.GetAt(idsf);

	mov	eax, DWORD PTR _idsf$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 13					; 0000000dH
	call	?GetAt@?$CGrowableArray@W4_D3DFORMAT@@@@QAEAAW4_D3DFORMAT@@H@Z ; CGrowableArray<enum _D3DFORMAT>::GetAt
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _depthStencilFmt$[ebp], ecx

; 361  :         if (SUCCEEDED(m_pD3D->CheckDeviceFormat(pDeviceCombo->AdapterOrdinal, 
; 362  :                 pDeviceCombo->DeviceType, pDeviceCombo->AdapterFormat, 
; 363  :                 D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_SURFACE, depthStencilFmt)))

	mov	esi, esp
	mov	eax, DWORD PTR _depthStencilFmt$[ebp]
	push	eax
	push	1
	push	2
	mov	ecx, DWORD PTR _pDeviceCombo$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _pDeviceCombo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _pDeviceCombo$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+40]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jl	SHORT $LN2@BuildDepth

; 364  :         {
; 365  :             if (SUCCEEDED(m_pD3D->CheckDepthStencilMatch(pDeviceCombo->AdapterOrdinal, 
; 366  :                     pDeviceCombo->DeviceType, pDeviceCombo->AdapterFormat, 
; 367  :                     pDeviceCombo->BackBufferFormat, depthStencilFmt)))

	mov	esi, esp
	mov	eax, DWORD PTR _depthStencilFmt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeviceCombo$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _pDeviceCombo$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _pDeviceCombo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _pDeviceCombo$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+48]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jl	SHORT $LN2@BuildDepth

; 368  :             {
; 369  :                 pDeviceCombo->depthStencilFormatList.Add( depthStencilFmt );

	lea	eax, DWORD PTR _depthStencilFmt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeviceCombo$[ebp]
	add	ecx, 20					; 00000014H
	call	?Add@?$CGrowableArray@W4_D3DFORMAT@@@@QAEJABW4_D3DFORMAT@@@Z ; CGrowableArray<enum _D3DFORMAT>::Add
$LN2@BuildDepth:

; 370  :             }
; 371  :         }
; 372  :     }

	jmp	$LN4@BuildDepth
$LN6@BuildDepth:

; 373  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@BuildDepth
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN10@BuildDepth:
	DD	1
	DD	$LN9@BuildDepth
$LN9@BuildDepth:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN8@BuildDepth
$LN8@BuildDepth:
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	70					; 00000046H
	DB	109					; 0000006dH
	DB	116					; 00000074H
	DB	0
?BuildDepthStencilFormatList@CD3DEnumeration@@AAEXPAUCD3DEnumDeviceSettingsCombo@@@Z ENDP ; CD3DEnumeration::BuildDepthStencilFormatList
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutenum.cpp
;	COMDAT ?EnumerateDeviceCombos@CD3DEnumeration@@AAEJPAVCD3DEnumAdapterInfo@@PAVCD3DEnumDeviceInfo@@PAV?$CGrowableArray@W4_D3DFORMAT@@@@@Z
_TEXT	SEGMENT
tv194 = -388						; size = 4
tv181 = -388						; size = 4
tv172 = -388						; size = 4
tv157 = -385						; size = 1
$T2 = -380						; size = 4
$T3 = -368						; size = 4
$T4 = -356						; size = 4
$T5 = -344						; size = 4
_pDeviceCombo$6 = -140					; size = 4
_nWindowed$7 = -128					; size = 4
_backBufferFormat$8 = -116				; size = 4
_iBackBufferFormat$9 = -104				; size = 4
_adapterFormat$10 = -92					; size = 4
_iFormat$11 = -80					; size = 4
_backBufferFormatArrayCount$ = -68			; size = 4
_backBufferFormatArray$ = -56				; size = 24
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pAdapterInfo$ = 8					; size = 4
_pDeviceInfo$ = 12					; size = 4
_pAdapterFormatList$ = 16				; size = 4
?EnumerateDeviceCombos@CD3DEnumeration@@AAEJPAVCD3DEnumAdapterInfo@@PAVCD3DEnumDeviceInfo@@PAV?$CGrowableArray@W4_D3DFORMAT@@@@@Z PROC ; CD3DEnumeration::EnumerateDeviceCombos, COMDAT
; _this$ = ecx

; 261  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?EnumerateDeviceCombos@CD3DEnumeration@@AAEJPAVCD3DEnumAdapterInfo@@PAVCD3DEnumDeviceInfo@@PAV?$CGrowableArray@W4_D3DFORMAT@@@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 376				; 00000178H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-388]
	mov	ecx, 94					; 0000005eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 262  :     const D3DFORMAT backBufferFormatArray[] = 
; 263  :     {   
; 264  :         D3DFMT_A8R8G8B8, 
; 265  :         D3DFMT_X8R8G8B8, 
; 266  :         D3DFMT_A2R10G10B10, 
; 267  :         D3DFMT_R5G6B5, 
; 268  :         D3DFMT_A1R5G5B5, 
; 269  :         D3DFMT_X1R5G5B5 
; 270  :     };

	mov	DWORD PTR _backBufferFormatArray$[ebp], 21 ; 00000015H
	mov	DWORD PTR _backBufferFormatArray$[ebp+4], 22 ; 00000016H
	mov	DWORD PTR _backBufferFormatArray$[ebp+8], 35 ; 00000023H
	mov	DWORD PTR _backBufferFormatArray$[ebp+12], 23 ; 00000017H
	mov	DWORD PTR _backBufferFormatArray$[ebp+16], 25 ; 00000019H
	mov	DWORD PTR _backBufferFormatArray$[ebp+20], 24 ; 00000018H

; 271  :     const UINT backBufferFormatArrayCount = sizeof(backBufferFormatArray) / sizeof(backBufferFormatArray[0]);

	mov	DWORD PTR _backBufferFormatArrayCount$[ebp], 6

; 272  : 
; 273  :     // See which adapter formats are supported by this device
; 274  :     for( int iFormat=0; iFormat<pAdapterFormatList->GetSize(); iFormat++ )

	mov	DWORD PTR _iFormat$11[ebp], 0
	jmp	SHORT $LN17@EnumerateD
$LN16@EnumerateD:
	mov	eax, DWORD PTR _iFormat$11[ebp]
	add	eax, 1
	mov	DWORD PTR _iFormat$11[ebp], eax
$LN17@EnumerateD:
	mov	ecx, DWORD PTR _pAdapterFormatList$[ebp]
	call	?GetSize@?$CGrowableArray@W4_D3DFORMAT@@@@QBEHXZ ; CGrowableArray<enum _D3DFORMAT>::GetSize
	cmp	DWORD PTR _iFormat$11[ebp], eax
	jge	$LN15@EnumerateD

; 275  :     {
; 276  :         D3DFORMAT adapterFormat = pAdapterFormatList->GetAt(iFormat);

	mov	eax, DWORD PTR _iFormat$11[ebp]
	push	eax
	mov	ecx, DWORD PTR _pAdapterFormatList$[ebp]
	call	?GetAt@?$CGrowableArray@W4_D3DFORMAT@@@@QAEAAW4_D3DFORMAT@@H@Z ; CGrowableArray<enum _D3DFORMAT>::GetAt
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _adapterFormat$10[ebp], ecx

; 277  : 
; 278  :         for( UINT iBackBufferFormat = 0; iBackBufferFormat < backBufferFormatArrayCount; iBackBufferFormat++ )

	mov	DWORD PTR _iBackBufferFormat$9[ebp], 0
	jmp	SHORT $LN14@EnumerateD
$LN13@EnumerateD:
	mov	eax, DWORD PTR _iBackBufferFormat$9[ebp]
	add	eax, 1
	mov	DWORD PTR _iBackBufferFormat$9[ebp], eax
$LN14@EnumerateD:
	cmp	DWORD PTR _iBackBufferFormat$9[ebp], 6
	jae	$LN12@EnumerateD

; 279  :         {
; 280  :             D3DFORMAT backBufferFormat = backBufferFormatArray[iBackBufferFormat];

	mov	eax, DWORD PTR _iBackBufferFormat$9[ebp]
	mov	ecx, DWORD PTR _backBufferFormatArray$[ebp+eax*4]
	mov	DWORD PTR _backBufferFormat$8[ebp], ecx

; 281  : 
; 282  :             for( int nWindowed = 0; nWindowed < 2; nWindowed++)

	mov	DWORD PTR _nWindowed$7[ebp], 0
	jmp	SHORT $LN11@EnumerateD
$LN10@EnumerateD:
	mov	eax, DWORD PTR _nWindowed$7[ebp]
	add	eax, 1
	mov	DWORD PTR _nWindowed$7[ebp], eax
$LN11@EnumerateD:
	cmp	DWORD PTR _nWindowed$7[ebp], 2
	jge	$LN9@EnumerateD

; 283  :             {
; 284  :                 if( !nWindowed && pAdapterInfo->displayModeList.GetSize() == 0 )

	cmp	DWORD PTR _nWindowed$7[ebp], 0
	jne	SHORT $LN8@EnumerateD
	mov	ecx, DWORD PTR _pAdapterInfo$[ebp]
	add	ecx, 1360				; 00000550H
	call	?GetSize@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QBEHXZ ; CGrowableArray<_D3DDISPLAYMODE>::GetSize
	test	eax, eax
	jne	SHORT $LN8@EnumerateD

; 285  :                     continue;

	jmp	SHORT $LN10@EnumerateD
$LN8@EnumerateD:

; 286  : 
; 287  :                 if (FAILED( m_pD3D->CheckDeviceType( pAdapterInfo->AdapterOrdinal, pDeviceInfo->DeviceType, 
; 288  :                                                      adapterFormat, backBufferFormat, nWindowed )))

	mov	esi, esp
	mov	eax, DWORD PTR _nWindowed$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _backBufferFormat$8[ebp]
	push	ecx
	mov	edx, DWORD PTR _adapterFormat$10[ebp]
	push	edx
	mov	eax, DWORD PTR _pDeviceInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _pAdapterInfo$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+36]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jge	SHORT $LN7@EnumerateD

; 289  :                 {
; 290  :                     continue;

	jmp	SHORT $LN10@EnumerateD
$LN7@EnumerateD:

; 291  :                 }
; 292  : 
; 293  :                 if( m_bRequirePostPixelShaderBlending )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+12]
	test	ecx, ecx
	je	SHORT $LN6@EnumerateD

; 294  :                 {
; 295  :                     // If the backbuffer format doesn't support D3DUSAGE_QUERY_POSTPIXELSHADER_BLENDING
; 296  :                     // then alpha test, pixel fog, render-target blending, color write enable, and dithering. 
; 297  :                     // are not supported.
; 298  :                     if( FAILED( m_pD3D->CheckDeviceFormat( pAdapterInfo->AdapterOrdinal, pDeviceInfo->DeviceType,
; 299  :                                                         adapterFormat, D3DUSAGE_QUERY_POSTPIXELSHADER_BLENDING, 
; 300  :                                                         D3DRTYPE_TEXTURE, backBufferFormat ) ) )

	mov	esi, esp
	mov	eax, DWORD PTR _backBufferFormat$8[ebp]
	push	eax
	push	3
	push	524288					; 00080000H
	mov	ecx, DWORD PTR _adapterFormat$10[ebp]
	push	ecx
	mov	edx, DWORD PTR _pDeviceInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _pAdapterInfo$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+40]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jge	SHORT $LN6@EnumerateD

; 301  :                     {
; 302  :                         continue;

	jmp	$LN10@EnumerateD
$LN6@EnumerateD:

; 303  :                     }
; 304  :                 }
; 305  : 
; 306  :                 // If an application callback function has been provided, make sure this device
; 307  :                 // is acceptable to the app.
; 308  :                 if( m_IsDeviceAcceptableFunc != NULL )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN4@EnumerateD

; 309  :                 {
; 310  :                     if( !m_IsDeviceAcceptableFunc( &pDeviceInfo->Caps, adapterFormat, backBufferFormat, FALSE != nWindowed, m_pIsDeviceAcceptableFuncUserContext ) )

	cmp	DWORD PTR _nWindowed$7[ebp], 0
	je	SHORT $LN20@EnumerateD
	mov	BYTE PTR tv157[ebp], 1
	jmp	SHORT $LN21@EnumerateD
$LN20@EnumerateD:
	mov	BYTE PTR tv157[ebp], 0
$LN21@EnumerateD:
	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	movzx	edx, BYTE PTR tv157[ebp]
	push	edx
	mov	eax, DWORD PTR _backBufferFormat$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _adapterFormat$10[ebp]
	push	ecx
	mov	edx, DWORD PTR _pDeviceInfo$[ebp]
	add	edx, 8
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN4@EnumerateD

; 311  :                         continue;

	jmp	$LN10@EnumerateD
$LN4@EnumerateD:

; 312  :                 }
; 313  :                 
; 314  :                 // At this point, we have an adapter/device/adapterformat/backbufferformat/iswindowed
; 315  :                 // DeviceCombo that is supported by the system and acceptable to the app. We still 
; 316  :                 // need to find one or more suitable depth/stencil buffer format,
; 317  :                 // multisample type, and present interval.
; 318  :                 CD3DEnumDeviceSettingsCombo* pDeviceCombo = new CD3DEnumDeviceSettingsCombo;

	push	88					; 00000058H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN22@EnumerateD
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0CD3DEnumDeviceSettingsCombo@@QAE@XZ
	mov	DWORD PTR tv172[ebp], eax
	jmp	SHORT $LN23@EnumerateD
$LN22@EnumerateD:
	mov	DWORD PTR tv172[ebp], 0
$LN23@EnumerateD:
	mov	eax, DWORD PTR tv172[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _pDeviceCombo$6[ebp], ecx

; 319  :                 if( pDeviceCombo == NULL )

	cmp	DWORD PTR _pDeviceCombo$6[ebp], 0
	jne	SHORT $LN2@EnumerateD

; 320  :                     return E_OUTOFMEMORY;

	mov	eax, -2147024882			; 8007000eH
	jmp	$LN18@EnumerateD
$LN2@EnumerateD:

; 321  : 
; 322  :                 pDeviceCombo->AdapterOrdinal = pAdapterInfo->AdapterOrdinal;

	mov	eax, DWORD PTR _pDeviceCombo$6[ebp]
	mov	ecx, DWORD PTR _pAdapterInfo$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 323  :                 pDeviceCombo->DeviceType = pDeviceInfo->DeviceType;

	mov	eax, DWORD PTR _pDeviceCombo$6[ebp]
	mov	ecx, DWORD PTR _pDeviceInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 324  :                 pDeviceCombo->AdapterFormat = adapterFormat;

	mov	eax, DWORD PTR _pDeviceCombo$6[ebp]
	mov	ecx, DWORD PTR _adapterFormat$10[ebp]
	mov	DWORD PTR [eax+8], ecx

; 325  :                 pDeviceCombo->BackBufferFormat = backBufferFormat;

	mov	eax, DWORD PTR _pDeviceCombo$6[ebp]
	mov	ecx, DWORD PTR _backBufferFormat$8[ebp]
	mov	DWORD PTR [eax+12], ecx

; 326  :                 pDeviceCombo->Windowed = (nWindowed != 0);

	cmp	DWORD PTR _nWindowed$7[ebp], 0
	je	SHORT $LN24@EnumerateD
	mov	DWORD PTR tv181[ebp], 1
	jmp	SHORT $LN25@EnumerateD
$LN24@EnumerateD:
	mov	DWORD PTR tv181[ebp], 0
$LN25@EnumerateD:
	mov	eax, DWORD PTR _pDeviceCombo$6[ebp]
	mov	ecx, DWORD PTR tv181[ebp]
	mov	DWORD PTR [eax+16], ecx

; 327  :                
; 328  :                 BuildDepthStencilFormatList( pDeviceCombo );

	mov	eax, DWORD PTR _pDeviceCombo$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildDepthStencilFormatList@CD3DEnumeration@@AAEXPAUCD3DEnumDeviceSettingsCombo@@@Z ; CD3DEnumeration::BuildDepthStencilFormatList

; 329  :                 BuildMultiSampleTypeList( pDeviceCombo );

	mov	eax, DWORD PTR _pDeviceCombo$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildMultiSampleTypeList@CD3DEnumeration@@AAEXPAUCD3DEnumDeviceSettingsCombo@@@Z ; CD3DEnumeration::BuildMultiSampleTypeList

; 330  :                 if (pDeviceCombo->multiSampleTypeList.GetSize() == 0)

	mov	ecx, DWORD PTR _pDeviceCombo$6[ebp]
	add	ecx, 32					; 00000020H
	call	?GetSize@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QBEHXZ ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::GetSize
	test	eax, eax
	jne	SHORT $LN1@EnumerateD

; 331  :                 {
; 332  :                     delete pDeviceCombo;

	mov	eax, DWORD PTR _pDeviceCombo$6[ebp]
	mov	DWORD PTR $T5[ebp], eax
	mov	ecx, DWORD PTR $T5[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN26@EnumerateD
	push	1
	mov	ecx, DWORD PTR $T4[ebp]
	call	??_GCD3DEnumDeviceSettingsCombo@@QAEPAXI@Z
	mov	DWORD PTR tv194[ebp], eax
	jmp	SHORT $LN27@EnumerateD
$LN26@EnumerateD:
	mov	DWORD PTR tv194[ebp], 0
$LN27@EnumerateD:

; 333  :                     continue;

	jmp	$LN10@EnumerateD
$LN1@EnumerateD:

; 334  :                 }
; 335  :                 BuildDSMSConflictList( pDeviceCombo );

	mov	eax, DWORD PTR _pDeviceCombo$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildDSMSConflictList@CD3DEnumeration@@AAEXPAUCD3DEnumDeviceSettingsCombo@@@Z ; CD3DEnumeration::BuildDSMSConflictList

; 336  :                 BuildPresentIntervalList(pDeviceInfo, pDeviceCombo );

	mov	eax, DWORD PTR _pDeviceCombo$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeviceInfo$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildPresentIntervalList@CD3DEnumeration@@AAEXPAVCD3DEnumDeviceInfo@@PAUCD3DEnumDeviceSettingsCombo@@@Z ; CD3DEnumeration::BuildPresentIntervalList

; 337  :                 pDeviceCombo->pAdapterInfo = pAdapterInfo;

	mov	eax, DWORD PTR _pDeviceCombo$6[ebp]
	mov	ecx, DWORD PTR _pAdapterInfo$[ebp]
	mov	DWORD PTR [eax+80], ecx

; 338  :                 pDeviceCombo->pDeviceInfo = pDeviceInfo;

	mov	eax, DWORD PTR _pDeviceCombo$6[ebp]
	mov	ecx, DWORD PTR _pDeviceInfo$[ebp]
	mov	DWORD PTR [eax+84], ecx

; 339  : 
; 340  :                 pDeviceInfo->deviceSettingsComboList.Add( pDeviceCombo );

	lea	eax, DWORD PTR _pDeviceCombo$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeviceInfo$[ebp]
	add	ecx, 312				; 00000138H
	call	?Add@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QAEJABQAUCD3DEnumDeviceSettingsCombo@@@Z ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::Add

; 341  :             
; 342  :             }

	jmp	$LN10@EnumerateD
$LN9@EnumerateD:

; 343  :         }

	jmp	$LN13@EnumerateD
$LN12@EnumerateD:

; 344  :     }

	jmp	$LN16@EnumerateD
$LN15@EnumerateD:

; 345  : 
; 346  :     return S_OK;

	xor	eax, eax
$LN18@EnumerateD:

; 347  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN33@EnumerateD
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 388				; 00000184H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN33@EnumerateD:
	DD	2
	DD	$LN32@EnumerateD
$LN32@EnumerateD:
	DD	-56					; ffffffc8H
	DD	24					; 00000018H
	DD	$LN29@EnumerateD
	DD	-140					; ffffff74H
	DD	4
	DD	$LN30@EnumerateD
$LN30@EnumerateD:
	DB	112					; 00000070H
	DB	68					; 00000044H
	DB	101					; 00000065H
	DB	118					; 00000076H
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	109					; 0000006dH
	DB	98					; 00000062H
	DB	111					; 0000006fH
	DB	0
$LN29@EnumerateD:
	DB	98					; 00000062H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	70					; 00000046H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	65					; 00000041H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?EnumerateDeviceCombos@CD3DEnumeration@@AAEJPAVCD3DEnumAdapterInfo@@PAVCD3DEnumDeviceInfo@@PAV?$CGrowableArray@W4_D3DFORMAT@@@@@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?EnumerateDeviceCombos@CD3DEnumeration@@AAEJPAVCD3DEnumAdapterInfo@@PAVCD3DEnumDeviceInfo@@PAV?$CGrowableArray@W4_D3DFORMAT@@@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-392]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?EnumerateDeviceCombos@CD3DEnumeration@@AAEJPAVCD3DEnumAdapterInfo@@PAVCD3DEnumDeviceInfo@@PAV?$CGrowableArray@W4_D3DFORMAT@@@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?EnumerateDeviceCombos@CD3DEnumeration@@AAEJPAVCD3DEnumAdapterInfo@@PAVCD3DEnumDeviceInfo@@PAV?$CGrowableArray@W4_D3DFORMAT@@@@@Z ENDP ; CD3DEnumeration::EnumerateDeviceCombos
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutenum.cpp
;	COMDAT ?EnumerateDevices@CD3DEnumeration@@AAEJPAVCD3DEnumAdapterInfo@@PAV?$CGrowableArray@W4_D3DFORMAT@@@@@Z
_TEXT	SEGMENT
tv151 = -388						; size = 4
tv139 = -388						; size = 4
tv128 = -388						; size = 4
tv73 = -388						; size = 4
$T2 = -380						; size = 4
$T3 = -368						; size = 4
$T4 = -356						; size = 4
$T5 = -344						; size = 4
$T6 = -332						; size = 4
$T7 = -320						; size = 4
$T8 = -308						; size = 4
$T9 = -296						; size = 4
_pDeviceInfo$10 = -92					; size = 4
_iDeviceType$11 = -80					; size = 4
_devTypeArrayCount$ = -68				; size = 4
_devTypeArray$ = -56					; size = 12
_hr$ = -36						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pAdapterInfo$ = 8					; size = 4
_pAdapterFormatList$ = 12				; size = 4
?EnumerateDevices@CD3DEnumeration@@AAEJPAVCD3DEnumAdapterInfo@@PAV?$CGrowableArray@W4_D3DFORMAT@@@@@Z PROC ; CD3DEnumeration::EnumerateDevices, COMDAT
; _this$ = ecx

; 208  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?EnumerateDevices@CD3DEnumeration@@AAEJPAVCD3DEnumAdapterInfo@@PAV?$CGrowableArray@W4_D3DFORMAT@@@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 376				; 00000178H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-388]
	mov	ecx, 94					; 0000005eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 209  :     HRESULT hr;
; 210  : 
; 211  :     const D3DDEVTYPE devTypeArray[] = 
; 212  :     { 
; 213  :         D3DDEVTYPE_HAL, 
; 214  :         D3DDEVTYPE_SW, 
; 215  :         D3DDEVTYPE_REF 
; 216  :     };

	mov	DWORD PTR _devTypeArray$[ebp], 1
	mov	DWORD PTR _devTypeArray$[ebp+4], 3
	mov	DWORD PTR _devTypeArray$[ebp+8], 2

; 217  :     const UINT devTypeArrayCount = sizeof(devTypeArray) / sizeof(devTypeArray[0]);

	mov	DWORD PTR _devTypeArrayCount$[ebp], 3

; 218  : 
; 219  :     // Enumerate each Direct3D device type
; 220  :     for( UINT iDeviceType = 0; iDeviceType < devTypeArrayCount; iDeviceType++ )

	mov	DWORD PTR _iDeviceType$11[ebp], 0
	jmp	SHORT $LN8@EnumerateD
$LN7@EnumerateD:
	mov	eax, DWORD PTR _iDeviceType$11[ebp]
	add	eax, 1
	mov	DWORD PTR _iDeviceType$11[ebp], eax
$LN8@EnumerateD:
	cmp	DWORD PTR _iDeviceType$11[ebp], 3
	jae	$LN6@EnumerateD

; 221  :     {
; 222  :         CD3DEnumDeviceInfo* pDeviceInfo = new CD3DEnumDeviceInfo;

	push	324					; 00000144H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN11@EnumerateD
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0CD3DEnumDeviceInfo@@QAE@XZ
	mov	DWORD PTR tv73[ebp], eax
	jmp	SHORT $LN12@EnumerateD
$LN11@EnumerateD:
	mov	DWORD PTR tv73[ebp], 0
$LN12@EnumerateD:
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _pDeviceInfo$10[ebp], ecx

; 223  :         if( pDeviceInfo == NULL )

	cmp	DWORD PTR _pDeviceInfo$10[ebp], 0
	jne	SHORT $LN5@EnumerateD

; 224  :             return E_OUTOFMEMORY;

	mov	eax, -2147024882			; 8007000eH
	jmp	$LN9@EnumerateD
$LN5@EnumerateD:

; 225  : 
; 226  :         // Fill struct w/ AdapterOrdinal and D3DDEVTYPE
; 227  :         pDeviceInfo->DeviceType = devTypeArray[iDeviceType];

	mov	eax, DWORD PTR _pDeviceInfo$10[ebp]
	mov	ecx, DWORD PTR _iDeviceType$11[ebp]
	mov	edx, DWORD PTR _devTypeArray$[ebp+ecx*4]
	mov	DWORD PTR [eax+4], edx

; 228  : 
; 229  :         // Store device caps
; 230  :         if( FAILED( hr = m_pD3D->GetDeviceCaps( pAdapterInfo->AdapterOrdinal, pDeviceInfo->DeviceType, 
; 231  :                                               &pDeviceInfo->Caps ) ) )

	mov	eax, DWORD PTR _pDeviceInfo$10[ebp]
	add	eax, 8
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _pDeviceInfo$10[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _pAdapterInfo$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+56]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN4@EnumerateD

; 232  :         {
; 233  :             delete pDeviceInfo;

	mov	eax, DWORD PTR _pDeviceInfo$10[ebp]
	mov	DWORD PTR $T5[ebp], eax
	mov	ecx, DWORD PTR $T5[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN13@EnumerateD
	push	1
	mov	ecx, DWORD PTR $T4[ebp]
	call	??_GCD3DEnumDeviceInfo@@QAEPAXI@Z
	mov	DWORD PTR tv128[ebp], eax
	jmp	SHORT $LN14@EnumerateD
$LN13@EnumerateD:
	mov	DWORD PTR tv128[ebp], 0
$LN14@EnumerateD:

; 234  :             continue;

	jmp	$LN7@EnumerateD
$LN4@EnumerateD:

; 235  :         }
; 236  : 
; 237  :         // Get info for each devicecombo on this device
; 238  :         if( FAILED( hr = EnumerateDeviceCombos( pAdapterInfo, pDeviceInfo, pAdapterFormatList ) ) )

	mov	eax, DWORD PTR _pAdapterFormatList$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeviceInfo$10[ebp]
	push	ecx
	mov	edx, DWORD PTR _pAdapterInfo$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EnumerateDeviceCombos@CD3DEnumeration@@AAEJPAVCD3DEnumAdapterInfo@@PAVCD3DEnumDeviceInfo@@PAV?$CGrowableArray@W4_D3DFORMAT@@@@@Z ; CD3DEnumeration::EnumerateDeviceCombos
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN3@EnumerateD

; 239  :         {
; 240  :             delete pDeviceInfo;

	mov	eax, DWORD PTR _pDeviceInfo$10[ebp]
	mov	DWORD PTR $T7[ebp], eax
	mov	ecx, DWORD PTR $T7[ebp]
	mov	DWORD PTR $T6[ebp], ecx
	cmp	DWORD PTR $T6[ebp], 0
	je	SHORT $LN15@EnumerateD
	push	1
	mov	ecx, DWORD PTR $T6[ebp]
	call	??_GCD3DEnumDeviceInfo@@QAEPAXI@Z
	mov	DWORD PTR tv139[ebp], eax
	jmp	SHORT $LN16@EnumerateD
$LN15@EnumerateD:
	mov	DWORD PTR tv139[ebp], 0
$LN16@EnumerateD:

; 241  :             continue;

	jmp	$LN7@EnumerateD
$LN3@EnumerateD:

; 242  :         }
; 243  : 
; 244  :         // If at least one devicecombo for this device is found, 
; 245  :         // add the deviceInfo to the list
; 246  :         if (pDeviceInfo->deviceSettingsComboList.GetSize() > 0 )

	mov	ecx, DWORD PTR _pDeviceInfo$10[ebp]
	add	ecx, 312				; 00000138H
	call	?GetSize@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QBEHXZ ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::GetSize
	test	eax, eax
	jle	SHORT $LN2@EnumerateD

; 247  :             pAdapterInfo->deviceInfoList.Add( pDeviceInfo );

	lea	eax, DWORD PTR _pDeviceInfo$10[ebp]
	push	eax
	mov	ecx, DWORD PTR _pAdapterInfo$[ebp]
	add	ecx, 1372				; 0000055cH
	call	?Add@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QAEJABQAVCD3DEnumDeviceInfo@@@Z ; CGrowableArray<CD3DEnumDeviceInfo *>::Add

; 248  :         else

	jmp	SHORT $LN1@EnumerateD
$LN2@EnumerateD:

; 249  :             delete pDeviceInfo;

	mov	eax, DWORD PTR _pDeviceInfo$10[ebp]
	mov	DWORD PTR $T9[ebp], eax
	mov	ecx, DWORD PTR $T9[ebp]
	mov	DWORD PTR $T8[ebp], ecx
	cmp	DWORD PTR $T8[ebp], 0
	je	SHORT $LN17@EnumerateD
	push	1
	mov	ecx, DWORD PTR $T8[ebp]
	call	??_GCD3DEnumDeviceInfo@@QAEPAXI@Z
	mov	DWORD PTR tv151[ebp], eax
	jmp	SHORT $LN1@EnumerateD
$LN17@EnumerateD:
	mov	DWORD PTR tv151[ebp], 0
$LN1@EnumerateD:

; 250  :     }

	jmp	$LN7@EnumerateD
$LN6@EnumerateD:

; 251  : 
; 252  :     return S_OK;

	xor	eax, eax
$LN9@EnumerateD:

; 253  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN24@EnumerateD
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 388				; 00000184H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN24@EnumerateD:
	DD	2
	DD	$LN23@EnumerateD
$LN23@EnumerateD:
	DD	-56					; ffffffc8H
	DD	12					; 0000000cH
	DD	$LN20@EnumerateD
	DD	-92					; ffffffa4H
	DD	4
	DD	$LN21@EnumerateD
$LN21@EnumerateD:
	DB	112					; 00000070H
	DB	68					; 00000044H
	DB	101					; 00000065H
	DB	118					; 00000076H
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	102					; 00000066H
	DB	111					; 0000006fH
	DB	0
$LN20@EnumerateD:
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	118					; 00000076H
	DB	84					; 00000054H
	DB	121					; 00000079H
	DB	112					; 00000070H
	DB	101					; 00000065H
	DB	65					; 00000041H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?EnumerateDevices@CD3DEnumeration@@AAEJPAVCD3DEnumAdapterInfo@@PAV?$CGrowableArray@W4_D3DFORMAT@@@@@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?EnumerateDevices@CD3DEnumeration@@AAEJPAVCD3DEnumAdapterInfo@@PAV?$CGrowableArray@W4_D3DFORMAT@@@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-392]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?EnumerateDevices@CD3DEnumeration@@AAEJPAVCD3DEnumAdapterInfo@@PAV?$CGrowableArray@W4_D3DFORMAT@@@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?EnumerateDevices@CD3DEnumeration@@AAEJPAVCD3DEnumAdapterInfo@@PAV?$CGrowableArray@W4_D3DFORMAT@@@@@Z ENDP ; CD3DEnumeration::EnumerateDevices
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?SetSizeInternal@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@IAEJH@Z
_TEXT	SEGMENT
tv91 = -232						; size = 4
tv85 = -232						; size = 4
_pDataNew$1 = -32					; size = 4
_nGrowBy$2 = -20					; size = 4
_this$ = -8						; size = 4
_nNewMaxSize$ = 8					; size = 4
?SetSizeInternal@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@IAEJH@Z PROC ; CGrowableArray<CD3DEnumAdapterInfo *>::SetSizeInternal, COMDAT
; _this$ = ecx

; 670  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 671  :     if( nNewMaxSize < 0 )

	cmp	DWORD PTR _nNewMaxSize$[ebp], 0
	jge	SHORT $LN7@SetSizeInt

; 672  :     {
; 673  :         assert( false );

	xor	eax, eax
	jne	SHORT $LN10@SetSizeInt
	push	673					; 000002a1H
	push	OFFSET ??_C@_1FK@FIMIDMPE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
	push	OFFSET ??_C@_1M@HLGKFCJM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN10@SetSizeInt:

; 674  :         return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H
	jmp	$LN8@SetSizeInt
$LN7@SetSizeInt:

; 675  :     }
; 676  : 
; 677  :     if( nNewMaxSize == 0 )

	cmp	DWORD PTR _nNewMaxSize$[ebp], 0
	jne	SHORT $LN6@SetSizeInt

; 678  :     {
; 679  :         // Shrink to 0 size & cleanup
; 680  :         if( m_pData )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@SetSizeInt

; 681  :         {
; 682  :             free( m_pData );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_free
	add	esp, 4

; 683  :             m_pData = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN5@SetSizeInt:

; 684  :         }
; 685  : 
; 686  :         m_nMaxSize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 687  :         m_nSize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	jmp	$LN4@SetSizeInt
$LN6@SetSizeInt:

; 688  :     }
; 689  :     else if( m_pData == NULL || nNewMaxSize > m_nMaxSize )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@SetSizeInt
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nNewMaxSize$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jle	$LN4@SetSizeInt
$LN2@SetSizeInt:

; 690  :     {
; 691  :         // Grow array
; 692  :         int nGrowBy = ( m_nMaxSize == 0 ) ? 16 : m_nMaxSize;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN11@SetSizeInt
	mov	DWORD PTR tv85[ebp], 16			; 00000010H
	jmp	SHORT $LN12@SetSizeInt
$LN11@SetSizeInt:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv85[ebp], edx
$LN12@SetSizeInt:
	mov	eax, DWORD PTR tv85[ebp]
	mov	DWORD PTR _nGrowBy$2[ebp], eax

; 693  :         nNewMaxSize = __max( nNewMaxSize, m_nMaxSize + nGrowBy );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _nGrowBy$2[ebp]
	cmp	DWORD PTR _nNewMaxSize$[ebp], ecx
	jle	SHORT $LN13@SetSizeInt
	mov	edx, DWORD PTR _nNewMaxSize$[ebp]
	mov	DWORD PTR tv91[ebp], edx
	jmp	SHORT $LN14@SetSizeInt
$LN13@SetSizeInt:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _nGrowBy$2[ebp]
	mov	DWORD PTR tv91[ebp], ecx
$LN14@SetSizeInt:
	mov	edx, DWORD PTR tv91[ebp]
	mov	DWORD PTR _nNewMaxSize$[ebp], edx

; 694  : 
; 695  :         TYPE* pDataNew = (TYPE*) realloc( m_pData, nNewMaxSize * sizeof(TYPE) );

	mov	eax, DWORD PTR _nNewMaxSize$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_realloc
	add	esp, 8
	mov	DWORD PTR _pDataNew$1[ebp], eax

; 696  :         if( pDataNew == NULL )

	cmp	DWORD PTR _pDataNew$1[ebp], 0
	jne	SHORT $LN1@SetSizeInt

; 697  :             return E_OUTOFMEMORY;

	mov	eax, -2147024882			; 8007000eH
	jmp	SHORT $LN8@SetSizeInt
$LN1@SetSizeInt:

; 698  : 
; 699  :         m_pData = pDataNew;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pDataNew$1[ebp]
	mov	DWORD PTR [eax], ecx

; 700  :         m_nMaxSize = nNewMaxSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nNewMaxSize$[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN4@SetSizeInt:

; 701  :     }
; 702  : 
; 703  :     return S_OK;

	xor	eax, eax
$LN8@SetSizeInt:

; 704  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSizeInternal@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@IAEJH@Z ENDP ; CGrowableArray<CD3DEnumAdapterInfo *>::SetSizeInternal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?RemoveAll@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?RemoveAll@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAEXXZ PROC ; CGrowableArray<CD3DEnumAdapterInfo *>::RemoveAll, COMDAT
; _this$ = ecx

; 47   :     void    RemoveAll() { SetSize(0); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAEJH@Z ; CGrowableArray<CD3DEnumAdapterInfo *>::SetSize
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAEXXZ ENDP ; CGrowableArray<CD3DEnumAdapterInfo *>::RemoveAll
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?GetSize@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetSize@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QBEHXZ PROC ; CGrowableArray<CD3DEnumAdapterInfo *>::GetSize, COMDAT
; _this$ = ecx

; 34   :     int     GetSize() const { return m_nSize; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSize@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QBEHXZ ENDP ; CGrowableArray<CD3DEnumAdapterInfo *>::GetSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?GetAt@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAEAAPAVCD3DEnumAdapterInfo@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nIndex$ = 8						; size = 4
?GetAt@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAEAAPAVCD3DEnumAdapterInfo@@H@Z PROC ; CGrowableArray<CD3DEnumAdapterInfo *>::GetAt, COMDAT
; _this$ = ecx

; 33   :     TYPE&   GetAt( int nIndex ) { assert( nIndex >= 0 && nIndex < m_nSize ); return m_pData[nIndex]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _nIndex$[ebp], 0
	jl	SHORT $LN3@GetAt
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jl	SHORT $LN4@GetAt
$LN3@GetAt:
	push	33					; 00000021H
	push	OFFSET ??_C@_1FK@FIMIDMPE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
	push	OFFSET ??_C@_1EA@JHMKKLFC@?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAm?$AA_?$AAn?$AAS?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@GetAt:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _nIndex$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetAt@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAEAAPAVCD3DEnumAdapterInfo@@H@Z ENDP ; CGrowableArray<CD3DEnumAdapterInfo *>::GetAt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?Add@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAEJABQAVCD3DEnumAdapterInfo@@@Z
_TEXT	SEGMENT
$T1 = -224						; size = 4
_hr$ = -20						; size = 4
_this$ = -8						; size = 4
_value$ = 8						; size = 4
?Add@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAEJABQAVCD3DEnumAdapterInfo@@@Z PROC ; CGrowableArray<CD3DEnumAdapterInfo *>::Add, COMDAT
; _this$ = ecx

; 740  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 741  :     HRESULT hr;
; 742  :     if( FAILED( hr = SetSizeInternal( m_nSize + 1 ) ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSizeInternal@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@IAEJH@Z ; CGrowableArray<CD3DEnumAdapterInfo *>::SetSizeInternal
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN1@Add

; 743  :         return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	jmp	SHORT $LN2@Add
$LN1@Add:

; 744  : 
; 745  :     // Construct the new element
; 746  :     ::new (&m_pData[m_nSize]) TYPE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*4]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax

; 747  : 
; 748  :     // Assign
; 749  :     m_pData[m_nSize] = value;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _value$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [eax+ecx*4], edx

; 750  :     ++m_nSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 751  : 
; 752  :     return S_OK;

	xor	eax, eax
$LN2@Add:

; 753  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Add@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAEJABQAVCD3DEnumAdapterInfo@@@Z ENDP ; CGrowableArray<CD3DEnumAdapterInfo *>::Add
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?SetSize@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAEJH@Z
_TEXT	SEGMENT
$T1 = -260						; size = 4
_i$2 = -56						; size = 4
_hr$ = -44						; size = 4
_i$3 = -32						; size = 4
_nOldSize$ = -20					; size = 4
_this$ = -8						; size = 4
_nNewMaxSize$ = 8					; size = 4
?SetSize@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAEJH@Z PROC ; CGrowableArray<CD3DEnumAdapterInfo *>::SetSize, COMDAT
; _this$ = ecx

; 710  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 711  :     int nOldSize = m_nSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _nOldSize$[ebp], ecx

; 712  : 
; 713  :     if( nOldSize > nNewMaxSize )

	mov	eax, DWORD PTR _nOldSize$[ebp]
	cmp	eax, DWORD PTR _nNewMaxSize$[ebp]
	jle	SHORT $LN8@SetSize

; 714  :     {
; 715  :         // Removing elements. Call dtor.
; 716  : 
; 717  :         for( int i = nNewMaxSize; i < nOldSize; ++i )

	mov	eax, DWORD PTR _nNewMaxSize$[ebp]
	mov	DWORD PTR _i$3[ebp], eax
	jmp	SHORT $LN7@SetSize
$LN6@SetSize:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN7@SetSize:
	mov	eax, DWORD PTR _i$3[ebp]
	cmp	eax, DWORD PTR _nOldSize$[ebp]
	jge	SHORT $LN8@SetSize

; 718  :             m_pData[i].~TYPE();

	jmp	SHORT $LN6@SetSize
$LN8@SetSize:

; 719  :     }
; 720  : 
; 721  :     // Adjust buffer.  Note that there's no need to check for error
; 722  :     // since if it happens, nOldSize == nNewMaxSize will be true.)
; 723  :     HRESULT hr = SetSizeInternal( nNewMaxSize );

	mov	eax, DWORD PTR _nNewMaxSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSizeInternal@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@IAEJH@Z ; CGrowableArray<CD3DEnumAdapterInfo *>::SetSizeInternal
	mov	DWORD PTR _hr$[ebp], eax

; 724  : 
; 725  :     if( nOldSize < nNewMaxSize )

	mov	eax, DWORD PTR _nOldSize$[ebp]
	cmp	eax, DWORD PTR _nNewMaxSize$[ebp]
	jge	SHORT $LN4@SetSize

; 726  :     {
; 727  :         // Adding elements. Call ctor.
; 728  : 
; 729  :         for( int i = nOldSize; i < nNewMaxSize; ++i )

	mov	eax, DWORD PTR _nOldSize$[ebp]
	mov	DWORD PTR _i$2[ebp], eax
	jmp	SHORT $LN3@SetSize
$LN2@SetSize:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN3@SetSize:
	mov	eax, DWORD PTR _i$2[ebp]
	cmp	eax, DWORD PTR _nNewMaxSize$[ebp]
	jge	SHORT $LN4@SetSize

; 730  :             ::new (&m_pData[i]) TYPE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$2[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	jmp	SHORT $LN2@SetSize
$LN4@SetSize:

; 731  :     }
; 732  : 
; 733  :     return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 734  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSize@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAEJH@Z ENDP ; CGrowableArray<CD3DEnumAdapterInfo *>::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ??1?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAE@XZ PROC ; CGrowableArray<CD3DEnumAdapterInfo *>::~CGrowableArray<CD3DEnumAdapterInfo *>, COMDAT
; _this$ = ecx

; 22   :     ~CGrowableArray() { RemoveAll(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAEXXZ ; CGrowableArray<CD3DEnumAdapterInfo *>::RemoveAll
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAE@XZ ENDP ; CGrowableArray<CD3DEnumAdapterInfo *>::~CGrowableArray<CD3DEnumAdapterInfo *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ??0?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAE@XZ PROC ; CGrowableArray<CD3DEnumAdapterInfo *>::CGrowableArray<CD3DEnumAdapterInfo *>, COMDAT
; _this$ = ecx

; 20   :     CGrowableArray()  { m_pData = NULL; m_nSize = 0; m_nMaxSize = 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAE@XZ ENDP ; CGrowableArray<CD3DEnumAdapterInfo *>::CGrowableArray<CD3DEnumAdapterInfo *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?SetSizeInternal@?$CGrowableArray@I@@IAEJH@Z
_TEXT	SEGMENT
tv91 = -232						; size = 4
tv85 = -232						; size = 4
_pDataNew$1 = -32					; size = 4
_nGrowBy$2 = -20					; size = 4
_this$ = -8						; size = 4
_nNewMaxSize$ = 8					; size = 4
?SetSizeInternal@?$CGrowableArray@I@@IAEJH@Z PROC	; CGrowableArray<unsigned int>::SetSizeInternal, COMDAT
; _this$ = ecx

; 670  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 671  :     if( nNewMaxSize < 0 )

	cmp	DWORD PTR _nNewMaxSize$[ebp], 0
	jge	SHORT $LN7@SetSizeInt

; 672  :     {
; 673  :         assert( false );

	xor	eax, eax
	jne	SHORT $LN10@SetSizeInt
	push	673					; 000002a1H
	push	OFFSET ??_C@_1FK@FIMIDMPE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
	push	OFFSET ??_C@_1M@HLGKFCJM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN10@SetSizeInt:

; 674  :         return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H
	jmp	$LN8@SetSizeInt
$LN7@SetSizeInt:

; 675  :     }
; 676  : 
; 677  :     if( nNewMaxSize == 0 )

	cmp	DWORD PTR _nNewMaxSize$[ebp], 0
	jne	SHORT $LN6@SetSizeInt

; 678  :     {
; 679  :         // Shrink to 0 size & cleanup
; 680  :         if( m_pData )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@SetSizeInt

; 681  :         {
; 682  :             free( m_pData );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_free
	add	esp, 4

; 683  :             m_pData = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN5@SetSizeInt:

; 684  :         }
; 685  : 
; 686  :         m_nMaxSize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 687  :         m_nSize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	jmp	$LN4@SetSizeInt
$LN6@SetSizeInt:

; 688  :     }
; 689  :     else if( m_pData == NULL || nNewMaxSize > m_nMaxSize )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@SetSizeInt
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nNewMaxSize$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jle	$LN4@SetSizeInt
$LN2@SetSizeInt:

; 690  :     {
; 691  :         // Grow array
; 692  :         int nGrowBy = ( m_nMaxSize == 0 ) ? 16 : m_nMaxSize;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN11@SetSizeInt
	mov	DWORD PTR tv85[ebp], 16			; 00000010H
	jmp	SHORT $LN12@SetSizeInt
$LN11@SetSizeInt:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv85[ebp], edx
$LN12@SetSizeInt:
	mov	eax, DWORD PTR tv85[ebp]
	mov	DWORD PTR _nGrowBy$2[ebp], eax

; 693  :         nNewMaxSize = __max( nNewMaxSize, m_nMaxSize + nGrowBy );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _nGrowBy$2[ebp]
	cmp	DWORD PTR _nNewMaxSize$[ebp], ecx
	jle	SHORT $LN13@SetSizeInt
	mov	edx, DWORD PTR _nNewMaxSize$[ebp]
	mov	DWORD PTR tv91[ebp], edx
	jmp	SHORT $LN14@SetSizeInt
$LN13@SetSizeInt:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _nGrowBy$2[ebp]
	mov	DWORD PTR tv91[ebp], ecx
$LN14@SetSizeInt:
	mov	edx, DWORD PTR tv91[ebp]
	mov	DWORD PTR _nNewMaxSize$[ebp], edx

; 694  : 
; 695  :         TYPE* pDataNew = (TYPE*) realloc( m_pData, nNewMaxSize * sizeof(TYPE) );

	mov	eax, DWORD PTR _nNewMaxSize$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_realloc
	add	esp, 8
	mov	DWORD PTR _pDataNew$1[ebp], eax

; 696  :         if( pDataNew == NULL )

	cmp	DWORD PTR _pDataNew$1[ebp], 0
	jne	SHORT $LN1@SetSizeInt

; 697  :             return E_OUTOFMEMORY;

	mov	eax, -2147024882			; 8007000eH
	jmp	SHORT $LN8@SetSizeInt
$LN1@SetSizeInt:

; 698  : 
; 699  :         m_pData = pDataNew;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pDataNew$1[ebp]
	mov	DWORD PTR [eax], ecx

; 700  :         m_nMaxSize = nNewMaxSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nNewMaxSize$[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN4@SetSizeInt:

; 701  :     }
; 702  : 
; 703  :     return S_OK;

	xor	eax, eax
$LN8@SetSizeInt:

; 704  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSizeInternal@?$CGrowableArray@I@@IAEJH@Z ENDP	; CGrowableArray<unsigned int>::SetSizeInternal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?RemoveAll@?$CGrowableArray@I@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?RemoveAll@?$CGrowableArray@I@@QAEXXZ PROC		; CGrowableArray<unsigned int>::RemoveAll, COMDAT
; _this$ = ecx

; 47   :     void    RemoveAll() { SetSize(0); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$CGrowableArray@I@@QAEJH@Z	; CGrowableArray<unsigned int>::SetSize
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CGrowableArray@I@@QAEXXZ ENDP		; CGrowableArray<unsigned int>::RemoveAll
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?GetSize@?$CGrowableArray@I@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetSize@?$CGrowableArray@I@@QBEHXZ PROC		; CGrowableArray<unsigned int>::GetSize, COMDAT
; _this$ = ecx

; 34   :     int     GetSize() const { return m_nSize; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSize@?$CGrowableArray@I@@QBEHXZ ENDP		; CGrowableArray<unsigned int>::GetSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?GetAt@?$CGrowableArray@I@@QAEAAIH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nIndex$ = 8						; size = 4
?GetAt@?$CGrowableArray@I@@QAEAAIH@Z PROC		; CGrowableArray<unsigned int>::GetAt, COMDAT
; _this$ = ecx

; 33   :     TYPE&   GetAt( int nIndex ) { assert( nIndex >= 0 && nIndex < m_nSize ); return m_pData[nIndex]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _nIndex$[ebp], 0
	jl	SHORT $LN3@GetAt
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jl	SHORT $LN4@GetAt
$LN3@GetAt:
	push	33					; 00000021H
	push	OFFSET ??_C@_1FK@FIMIDMPE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
	push	OFFSET ??_C@_1EA@JHMKKLFC@?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAm?$AA_?$AAn?$AAS?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@GetAt:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _nIndex$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetAt@?$CGrowableArray@I@@QAEAAIH@Z ENDP		; CGrowableArray<unsigned int>::GetAt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?Add@?$CGrowableArray@I@@QAEJABI@Z
_TEXT	SEGMENT
$T1 = -224						; size = 4
_hr$ = -20						; size = 4
_this$ = -8						; size = 4
_value$ = 8						; size = 4
?Add@?$CGrowableArray@I@@QAEJABI@Z PROC			; CGrowableArray<unsigned int>::Add, COMDAT
; _this$ = ecx

; 740  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 741  :     HRESULT hr;
; 742  :     if( FAILED( hr = SetSizeInternal( m_nSize + 1 ) ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSizeInternal@?$CGrowableArray@I@@IAEJH@Z ; CGrowableArray<unsigned int>::SetSizeInternal
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN1@Add

; 743  :         return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	jmp	SHORT $LN2@Add
$LN1@Add:

; 744  : 
; 745  :     // Construct the new element
; 746  :     ::new (&m_pData[m_nSize]) TYPE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*4]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax

; 747  : 
; 748  :     // Assign
; 749  :     m_pData[m_nSize] = value;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _value$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [eax+ecx*4], edx

; 750  :     ++m_nSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 751  : 
; 752  :     return S_OK;

	xor	eax, eax
$LN2@Add:

; 753  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Add@?$CGrowableArray@I@@QAEJABI@Z ENDP			; CGrowableArray<unsigned int>::Add
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?SetSize@?$CGrowableArray@I@@QAEJH@Z
_TEXT	SEGMENT
$T1 = -260						; size = 4
_i$2 = -56						; size = 4
_hr$ = -44						; size = 4
_i$3 = -32						; size = 4
_nOldSize$ = -20					; size = 4
_this$ = -8						; size = 4
_nNewMaxSize$ = 8					; size = 4
?SetSize@?$CGrowableArray@I@@QAEJH@Z PROC		; CGrowableArray<unsigned int>::SetSize, COMDAT
; _this$ = ecx

; 710  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 711  :     int nOldSize = m_nSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _nOldSize$[ebp], ecx

; 712  : 
; 713  :     if( nOldSize > nNewMaxSize )

	mov	eax, DWORD PTR _nOldSize$[ebp]
	cmp	eax, DWORD PTR _nNewMaxSize$[ebp]
	jle	SHORT $LN8@SetSize

; 714  :     {
; 715  :         // Removing elements. Call dtor.
; 716  : 
; 717  :         for( int i = nNewMaxSize; i < nOldSize; ++i )

	mov	eax, DWORD PTR _nNewMaxSize$[ebp]
	mov	DWORD PTR _i$3[ebp], eax
	jmp	SHORT $LN7@SetSize
$LN6@SetSize:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN7@SetSize:
	mov	eax, DWORD PTR _i$3[ebp]
	cmp	eax, DWORD PTR _nOldSize$[ebp]
	jge	SHORT $LN8@SetSize

; 718  :             m_pData[i].~TYPE();

	jmp	SHORT $LN6@SetSize
$LN8@SetSize:

; 719  :     }
; 720  : 
; 721  :     // Adjust buffer.  Note that there's no need to check for error
; 722  :     // since if it happens, nOldSize == nNewMaxSize will be true.)
; 723  :     HRESULT hr = SetSizeInternal( nNewMaxSize );

	mov	eax, DWORD PTR _nNewMaxSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSizeInternal@?$CGrowableArray@I@@IAEJH@Z ; CGrowableArray<unsigned int>::SetSizeInternal
	mov	DWORD PTR _hr$[ebp], eax

; 724  : 
; 725  :     if( nOldSize < nNewMaxSize )

	mov	eax, DWORD PTR _nOldSize$[ebp]
	cmp	eax, DWORD PTR _nNewMaxSize$[ebp]
	jge	SHORT $LN4@SetSize

; 726  :     {
; 727  :         // Adding elements. Call ctor.
; 728  : 
; 729  :         for( int i = nOldSize; i < nNewMaxSize; ++i )

	mov	eax, DWORD PTR _nOldSize$[ebp]
	mov	DWORD PTR _i$2[ebp], eax
	jmp	SHORT $LN3@SetSize
$LN2@SetSize:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN3@SetSize:
	mov	eax, DWORD PTR _i$2[ebp]
	cmp	eax, DWORD PTR _nNewMaxSize$[ebp]
	jge	SHORT $LN4@SetSize

; 730  :             ::new (&m_pData[i]) TYPE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$2[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	jmp	SHORT $LN2@SetSize
$LN4@SetSize:

; 731  :     }
; 732  : 
; 733  :     return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 734  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSize@?$CGrowableArray@I@@QAEJH@Z ENDP		; CGrowableArray<unsigned int>::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ??1?$CGrowableArray@I@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$CGrowableArray@I@@QAE@XZ PROC			; CGrowableArray<unsigned int>::~CGrowableArray<unsigned int>, COMDAT
; _this$ = ecx

; 22   :     ~CGrowableArray() { RemoveAll(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CGrowableArray@I@@QAEXXZ	; CGrowableArray<unsigned int>::RemoveAll
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CGrowableArray@I@@QAE@XZ ENDP			; CGrowableArray<unsigned int>::~CGrowableArray<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ??0?$CGrowableArray@I@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$CGrowableArray@I@@QAE@XZ PROC			; CGrowableArray<unsigned int>::CGrowableArray<unsigned int>, COMDAT
; _this$ = ecx

; 20   :     CGrowableArray()  { m_pData = NULL; m_nSize = 0; m_nMaxSize = 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CGrowableArray@I@@QAE@XZ ENDP			; CGrowableArray<unsigned int>::CGrowableArray<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?SetSizeInternal@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@IAEJH@Z
_TEXT	SEGMENT
tv91 = -232						; size = 4
tv85 = -232						; size = 4
_pDataNew$1 = -32					; size = 4
_nGrowBy$2 = -20					; size = 4
_this$ = -8						; size = 4
_nNewMaxSize$ = 8					; size = 4
?SetSizeInternal@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@IAEJH@Z PROC ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::SetSizeInternal, COMDAT
; _this$ = ecx

; 670  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 671  :     if( nNewMaxSize < 0 )

	cmp	DWORD PTR _nNewMaxSize$[ebp], 0
	jge	SHORT $LN7@SetSizeInt

; 672  :     {
; 673  :         assert( false );

	xor	eax, eax
	jne	SHORT $LN10@SetSizeInt
	push	673					; 000002a1H
	push	OFFSET ??_C@_1FK@FIMIDMPE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
	push	OFFSET ??_C@_1M@HLGKFCJM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN10@SetSizeInt:

; 674  :         return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H
	jmp	$LN8@SetSizeInt
$LN7@SetSizeInt:

; 675  :     }
; 676  : 
; 677  :     if( nNewMaxSize == 0 )

	cmp	DWORD PTR _nNewMaxSize$[ebp], 0
	jne	SHORT $LN6@SetSizeInt

; 678  :     {
; 679  :         // Shrink to 0 size & cleanup
; 680  :         if( m_pData )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@SetSizeInt

; 681  :         {
; 682  :             free( m_pData );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_free
	add	esp, 4

; 683  :             m_pData = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN5@SetSizeInt:

; 684  :         }
; 685  : 
; 686  :         m_nMaxSize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 687  :         m_nSize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	jmp	$LN4@SetSizeInt
$LN6@SetSizeInt:

; 688  :     }
; 689  :     else if( m_pData == NULL || nNewMaxSize > m_nMaxSize )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@SetSizeInt
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nNewMaxSize$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jle	$LN4@SetSizeInt
$LN2@SetSizeInt:

; 690  :     {
; 691  :         // Grow array
; 692  :         int nGrowBy = ( m_nMaxSize == 0 ) ? 16 : m_nMaxSize;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN11@SetSizeInt
	mov	DWORD PTR tv85[ebp], 16			; 00000010H
	jmp	SHORT $LN12@SetSizeInt
$LN11@SetSizeInt:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv85[ebp], edx
$LN12@SetSizeInt:
	mov	eax, DWORD PTR tv85[ebp]
	mov	DWORD PTR _nGrowBy$2[ebp], eax

; 693  :         nNewMaxSize = __max( nNewMaxSize, m_nMaxSize + nGrowBy );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _nGrowBy$2[ebp]
	cmp	DWORD PTR _nNewMaxSize$[ebp], ecx
	jle	SHORT $LN13@SetSizeInt
	mov	edx, DWORD PTR _nNewMaxSize$[ebp]
	mov	DWORD PTR tv91[ebp], edx
	jmp	SHORT $LN14@SetSizeInt
$LN13@SetSizeInt:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _nGrowBy$2[ebp]
	mov	DWORD PTR tv91[ebp], ecx
$LN14@SetSizeInt:
	mov	edx, DWORD PTR tv91[ebp]
	mov	DWORD PTR _nNewMaxSize$[ebp], edx

; 694  : 
; 695  :         TYPE* pDataNew = (TYPE*) realloc( m_pData, nNewMaxSize * sizeof(TYPE) );

	mov	eax, DWORD PTR _nNewMaxSize$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_realloc
	add	esp, 8
	mov	DWORD PTR _pDataNew$1[ebp], eax

; 696  :         if( pDataNew == NULL )

	cmp	DWORD PTR _pDataNew$1[ebp], 0
	jne	SHORT $LN1@SetSizeInt

; 697  :             return E_OUTOFMEMORY;

	mov	eax, -2147024882			; 8007000eH
	jmp	SHORT $LN8@SetSizeInt
$LN1@SetSizeInt:

; 698  : 
; 699  :         m_pData = pDataNew;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pDataNew$1[ebp]
	mov	DWORD PTR [eax], ecx

; 700  :         m_nMaxSize = nNewMaxSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nNewMaxSize$[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN4@SetSizeInt:

; 701  :     }
; 702  : 
; 703  :     return S_OK;

	xor	eax, eax
$LN8@SetSizeInt:

; 704  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSizeInternal@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@IAEJH@Z ENDP ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::SetSizeInternal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?RemoveAll@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?RemoveAll@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEXXZ PROC ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::RemoveAll, COMDAT
; _this$ = ecx

; 47   :     void    RemoveAll() { SetSize(0); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEJH@Z ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::SetSize
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEXXZ ENDP ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::RemoveAll
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?GetSize@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetSize@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QBEHXZ PROC ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::GetSize, COMDAT
; _this$ = ecx

; 34   :     int     GetSize() const { return m_nSize; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSize@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QBEHXZ ENDP ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::GetSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?GetAt@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEAAW4_D3DMULTISAMPLE_TYPE@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nIndex$ = 8						; size = 4
?GetAt@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEAAW4_D3DMULTISAMPLE_TYPE@@H@Z PROC ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::GetAt, COMDAT
; _this$ = ecx

; 33   :     TYPE&   GetAt( int nIndex ) { assert( nIndex >= 0 && nIndex < m_nSize ); return m_pData[nIndex]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _nIndex$[ebp], 0
	jl	SHORT $LN3@GetAt
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jl	SHORT $LN4@GetAt
$LN3@GetAt:
	push	33					; 00000021H
	push	OFFSET ??_C@_1FK@FIMIDMPE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
	push	OFFSET ??_C@_1EA@JHMKKLFC@?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAm?$AA_?$AAn?$AAS?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@GetAt:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _nIndex$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetAt@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEAAW4_D3DMULTISAMPLE_TYPE@@H@Z ENDP ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::GetAt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?Add@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEJABW4_D3DMULTISAMPLE_TYPE@@@Z
_TEXT	SEGMENT
$T1 = -224						; size = 4
_hr$ = -20						; size = 4
_this$ = -8						; size = 4
_value$ = 8						; size = 4
?Add@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEJABW4_D3DMULTISAMPLE_TYPE@@@Z PROC ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::Add, COMDAT
; _this$ = ecx

; 740  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 741  :     HRESULT hr;
; 742  :     if( FAILED( hr = SetSizeInternal( m_nSize + 1 ) ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSizeInternal@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@IAEJH@Z ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::SetSizeInternal
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN1@Add

; 743  :         return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	jmp	SHORT $LN2@Add
$LN1@Add:

; 744  : 
; 745  :     // Construct the new element
; 746  :     ::new (&m_pData[m_nSize]) TYPE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*4]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax

; 747  : 
; 748  :     // Assign
; 749  :     m_pData[m_nSize] = value;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _value$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [eax+ecx*4], edx

; 750  :     ++m_nSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 751  : 
; 752  :     return S_OK;

	xor	eax, eax
$LN2@Add:

; 753  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Add@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEJABW4_D3DMULTISAMPLE_TYPE@@@Z ENDP ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::Add
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?SetSize@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEJH@Z
_TEXT	SEGMENT
$T1 = -260						; size = 4
_i$2 = -56						; size = 4
_hr$ = -44						; size = 4
_i$3 = -32						; size = 4
_nOldSize$ = -20					; size = 4
_this$ = -8						; size = 4
_nNewMaxSize$ = 8					; size = 4
?SetSize@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEJH@Z PROC ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::SetSize, COMDAT
; _this$ = ecx

; 710  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 711  :     int nOldSize = m_nSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _nOldSize$[ebp], ecx

; 712  : 
; 713  :     if( nOldSize > nNewMaxSize )

	mov	eax, DWORD PTR _nOldSize$[ebp]
	cmp	eax, DWORD PTR _nNewMaxSize$[ebp]
	jle	SHORT $LN8@SetSize

; 714  :     {
; 715  :         // Removing elements. Call dtor.
; 716  : 
; 717  :         for( int i = nNewMaxSize; i < nOldSize; ++i )

	mov	eax, DWORD PTR _nNewMaxSize$[ebp]
	mov	DWORD PTR _i$3[ebp], eax
	jmp	SHORT $LN7@SetSize
$LN6@SetSize:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN7@SetSize:
	mov	eax, DWORD PTR _i$3[ebp]
	cmp	eax, DWORD PTR _nOldSize$[ebp]
	jge	SHORT $LN8@SetSize

; 718  :             m_pData[i].~TYPE();

	jmp	SHORT $LN6@SetSize
$LN8@SetSize:

; 719  :     }
; 720  : 
; 721  :     // Adjust buffer.  Note that there's no need to check for error
; 722  :     // since if it happens, nOldSize == nNewMaxSize will be true.)
; 723  :     HRESULT hr = SetSizeInternal( nNewMaxSize );

	mov	eax, DWORD PTR _nNewMaxSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSizeInternal@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@IAEJH@Z ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::SetSizeInternal
	mov	DWORD PTR _hr$[ebp], eax

; 724  : 
; 725  :     if( nOldSize < nNewMaxSize )

	mov	eax, DWORD PTR _nOldSize$[ebp]
	cmp	eax, DWORD PTR _nNewMaxSize$[ebp]
	jge	SHORT $LN4@SetSize

; 726  :     {
; 727  :         // Adding elements. Call ctor.
; 728  : 
; 729  :         for( int i = nOldSize; i < nNewMaxSize; ++i )

	mov	eax, DWORD PTR _nOldSize$[ebp]
	mov	DWORD PTR _i$2[ebp], eax
	jmp	SHORT $LN3@SetSize
$LN2@SetSize:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN3@SetSize:
	mov	eax, DWORD PTR _i$2[ebp]
	cmp	eax, DWORD PTR _nNewMaxSize$[ebp]
	jge	SHORT $LN4@SetSize

; 730  :             ::new (&m_pData[i]) TYPE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$2[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	jmp	SHORT $LN2@SetSize
$LN4@SetSize:

; 731  :     }
; 732  : 
; 733  :     return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 734  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSize@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEJH@Z ENDP ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ??1?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAE@XZ PROC ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::~CGrowableArray<enum _D3DMULTISAMPLE_TYPE>, COMDAT
; _this$ = ecx

; 22   :     ~CGrowableArray() { RemoveAll(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEXXZ ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::RemoveAll
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAE@XZ ENDP ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::~CGrowableArray<enum _D3DMULTISAMPLE_TYPE>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ??0?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAE@XZ PROC ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::CGrowableArray<enum _D3DMULTISAMPLE_TYPE>, COMDAT
; _this$ = ecx

; 20   :     CGrowableArray()  { m_pData = NULL; m_nSize = 0; m_nMaxSize = 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAE@XZ ENDP ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::CGrowableArray<enum _D3DMULTISAMPLE_TYPE>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?SetSizeInternal@?$CGrowableArray@W4_D3DFORMAT@@@@IAEJH@Z
_TEXT	SEGMENT
tv91 = -232						; size = 4
tv85 = -232						; size = 4
_pDataNew$1 = -32					; size = 4
_nGrowBy$2 = -20					; size = 4
_this$ = -8						; size = 4
_nNewMaxSize$ = 8					; size = 4
?SetSizeInternal@?$CGrowableArray@W4_D3DFORMAT@@@@IAEJH@Z PROC ; CGrowableArray<enum _D3DFORMAT>::SetSizeInternal, COMDAT
; _this$ = ecx

; 670  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 671  :     if( nNewMaxSize < 0 )

	cmp	DWORD PTR _nNewMaxSize$[ebp], 0
	jge	SHORT $LN7@SetSizeInt

; 672  :     {
; 673  :         assert( false );

	xor	eax, eax
	jne	SHORT $LN10@SetSizeInt
	push	673					; 000002a1H
	push	OFFSET ??_C@_1FK@FIMIDMPE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
	push	OFFSET ??_C@_1M@HLGKFCJM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN10@SetSizeInt:

; 674  :         return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H
	jmp	$LN8@SetSizeInt
$LN7@SetSizeInt:

; 675  :     }
; 676  : 
; 677  :     if( nNewMaxSize == 0 )

	cmp	DWORD PTR _nNewMaxSize$[ebp], 0
	jne	SHORT $LN6@SetSizeInt

; 678  :     {
; 679  :         // Shrink to 0 size & cleanup
; 680  :         if( m_pData )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@SetSizeInt

; 681  :         {
; 682  :             free( m_pData );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_free
	add	esp, 4

; 683  :             m_pData = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN5@SetSizeInt:

; 684  :         }
; 685  : 
; 686  :         m_nMaxSize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 687  :         m_nSize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	jmp	$LN4@SetSizeInt
$LN6@SetSizeInt:

; 688  :     }
; 689  :     else if( m_pData == NULL || nNewMaxSize > m_nMaxSize )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@SetSizeInt
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nNewMaxSize$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jle	$LN4@SetSizeInt
$LN2@SetSizeInt:

; 690  :     {
; 691  :         // Grow array
; 692  :         int nGrowBy = ( m_nMaxSize == 0 ) ? 16 : m_nMaxSize;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN11@SetSizeInt
	mov	DWORD PTR tv85[ebp], 16			; 00000010H
	jmp	SHORT $LN12@SetSizeInt
$LN11@SetSizeInt:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv85[ebp], edx
$LN12@SetSizeInt:
	mov	eax, DWORD PTR tv85[ebp]
	mov	DWORD PTR _nGrowBy$2[ebp], eax

; 693  :         nNewMaxSize = __max( nNewMaxSize, m_nMaxSize + nGrowBy );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _nGrowBy$2[ebp]
	cmp	DWORD PTR _nNewMaxSize$[ebp], ecx
	jle	SHORT $LN13@SetSizeInt
	mov	edx, DWORD PTR _nNewMaxSize$[ebp]
	mov	DWORD PTR tv91[ebp], edx
	jmp	SHORT $LN14@SetSizeInt
$LN13@SetSizeInt:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _nGrowBy$2[ebp]
	mov	DWORD PTR tv91[ebp], ecx
$LN14@SetSizeInt:
	mov	edx, DWORD PTR tv91[ebp]
	mov	DWORD PTR _nNewMaxSize$[ebp], edx

; 694  : 
; 695  :         TYPE* pDataNew = (TYPE*) realloc( m_pData, nNewMaxSize * sizeof(TYPE) );

	mov	eax, DWORD PTR _nNewMaxSize$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_realloc
	add	esp, 8
	mov	DWORD PTR _pDataNew$1[ebp], eax

; 696  :         if( pDataNew == NULL )

	cmp	DWORD PTR _pDataNew$1[ebp], 0
	jne	SHORT $LN1@SetSizeInt

; 697  :             return E_OUTOFMEMORY;

	mov	eax, -2147024882			; 8007000eH
	jmp	SHORT $LN8@SetSizeInt
$LN1@SetSizeInt:

; 698  : 
; 699  :         m_pData = pDataNew;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pDataNew$1[ebp]
	mov	DWORD PTR [eax], ecx

; 700  :         m_nMaxSize = nNewMaxSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nNewMaxSize$[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN4@SetSizeInt:

; 701  :     }
; 702  : 
; 703  :     return S_OK;

	xor	eax, eax
$LN8@SetSizeInt:

; 704  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSizeInternal@?$CGrowableArray@W4_D3DFORMAT@@@@IAEJH@Z ENDP ; CGrowableArray<enum _D3DFORMAT>::SetSizeInternal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?RemoveAll@?$CGrowableArray@W4_D3DFORMAT@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?RemoveAll@?$CGrowableArray@W4_D3DFORMAT@@@@QAEXXZ PROC	; CGrowableArray<enum _D3DFORMAT>::RemoveAll, COMDAT
; _this$ = ecx

; 47   :     void    RemoveAll() { SetSize(0); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$CGrowableArray@W4_D3DFORMAT@@@@QAEJH@Z ; CGrowableArray<enum _D3DFORMAT>::SetSize
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CGrowableArray@W4_D3DFORMAT@@@@QAEXXZ ENDP	; CGrowableArray<enum _D3DFORMAT>::RemoveAll
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?IndexOf@?$CGrowableArray@W4_D3DFORMAT@@@@QAEHABW4_D3DFORMAT@@HH@Z
_TEXT	SEGMENT
_i$1 = -20						; size = 4
_this$ = -8						; size = 4
_value$ = 8						; size = 4
_iStart$ = 12						; size = 4
_nNumElements$ = 16					; size = 4
?IndexOf@?$CGrowableArray@W4_D3DFORMAT@@@@QAEHABW4_D3DFORMAT@@HH@Z PROC ; CGrowableArray<enum _D3DFORMAT>::IndexOf, COMDAT
; _this$ = ecx

; 813  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 814  :     // Validate arguments
; 815  :     if( iStart < 0 || 
; 816  :         iStart >= m_nSize ||
; 817  :         nNumElements < 0 ||
; 818  :         iStart + nNumElements > m_nSize )

	cmp	DWORD PTR _iStart$[ebp], 0
	jl	SHORT $LN5@IndexOf
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iStart$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $LN5@IndexOf
	cmp	DWORD PTR _nNumElements$[ebp], 0
	jl	SHORT $LN5@IndexOf
	mov	eax, DWORD PTR _iStart$[ebp]
	add	eax, DWORD PTR _nNumElements$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [ecx+4]
	jle	SHORT $LN6@IndexOf
$LN5@IndexOf:

; 819  :     {
; 820  :         assert( false );

	xor	eax, eax
	jne	SHORT $LN9@IndexOf
	push	820					; 00000334H
	push	OFFSET ??_C@_1FK@FIMIDMPE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
	push	OFFSET ??_C@_1M@HLGKFCJM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN9@IndexOf:

; 821  :         return -1;

	or	eax, -1
	jmp	SHORT $LN7@IndexOf
$LN6@IndexOf:

; 822  :     }
; 823  : 
; 824  :     // Search
; 825  :     for( int i = iStart; i < (iStart + nNumElements); i++ )

	mov	eax, DWORD PTR _iStart$[ebp]
	mov	DWORD PTR _i$1[ebp], eax
	jmp	SHORT $LN4@IndexOf
$LN3@IndexOf:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@IndexOf:
	mov	eax, DWORD PTR _iStart$[ebp]
	add	eax, DWORD PTR _nNumElements$[ebp]
	cmp	DWORD PTR _i$1[ebp], eax
	jge	SHORT $LN2@IndexOf

; 826  :     {
; 827  :         if( value == m_pData[i] )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _value$[ebp]
	mov	eax, DWORD PTR _i$1[ebp]
	mov	edx, DWORD PTR [edx]
	cmp	edx, DWORD PTR [ecx+eax*4]
	jne	SHORT $LN1@IndexOf

; 828  :             return i;

	mov	eax, DWORD PTR _i$1[ebp]
	jmp	SHORT $LN7@IndexOf
$LN1@IndexOf:

; 829  :     }

	jmp	SHORT $LN3@IndexOf
$LN2@IndexOf:

; 830  : 
; 831  :     // Not found
; 832  :     return -1;

	or	eax, -1
$LN7@IndexOf:

; 833  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?IndexOf@?$CGrowableArray@W4_D3DFORMAT@@@@QAEHABW4_D3DFORMAT@@HH@Z ENDP ; CGrowableArray<enum _D3DFORMAT>::IndexOf
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?IndexOf@?$CGrowableArray@W4_D3DFORMAT@@@@QAEHABW4_D3DFORMAT@@@Z
_TEXT	SEGMENT
tv72 = -208						; size = 4
_this$ = -8						; size = 4
_value$ = 8						; size = 4
?IndexOf@?$CGrowableArray@W4_D3DFORMAT@@@@QAEHABW4_D3DFORMAT@@@Z PROC ; CGrowableArray<enum _D3DFORMAT>::IndexOf, COMDAT
; _this$ = ecx

; 38   :     int     IndexOf( const TYPE& value ) { return ( m_nSize > 0 ) ? IndexOf( value, 0, m_nSize ) : -1; }

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jle	SHORT $LN3@IndexOf
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	push	0
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IndexOf@?$CGrowableArray@W4_D3DFORMAT@@@@QAEHABW4_D3DFORMAT@@HH@Z ; CGrowableArray<enum _D3DFORMAT>::IndexOf
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@IndexOf
$LN3@IndexOf:
	mov	DWORD PTR tv72[ebp], -1
$LN4@IndexOf:
	mov	eax, DWORD PTR tv72[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?IndexOf@?$CGrowableArray@W4_D3DFORMAT@@@@QAEHABW4_D3DFORMAT@@@Z ENDP ; CGrowableArray<enum _D3DFORMAT>::IndexOf
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?Contains@?$CGrowableArray@W4_D3DFORMAT@@@@QAE_NABW4_D3DFORMAT@@@Z
_TEXT	SEGMENT
tv68 = -208						; size = 4
_this$ = -8						; size = 4
_value$ = 8						; size = 4
?Contains@?$CGrowableArray@W4_D3DFORMAT@@@@QAE_NABW4_D3DFORMAT@@@Z PROC ; CGrowableArray<enum _D3DFORMAT>::Contains, COMDAT
; _this$ = ecx

; 36   :     bool    Contains( const TYPE& value ){ return ( -1 != IndexOf( value ) ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IndexOf@?$CGrowableArray@W4_D3DFORMAT@@@@QAEHABW4_D3DFORMAT@@@Z ; CGrowableArray<enum _D3DFORMAT>::IndexOf
	cmp	eax, -1
	je	SHORT $LN3@Contains
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@Contains
$LN3@Contains:
	mov	DWORD PTR tv68[ebp], 0
$LN4@Contains:
	mov	al, BYTE PTR tv68[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Contains@?$CGrowableArray@W4_D3DFORMAT@@@@QAE_NABW4_D3DFORMAT@@@Z ENDP ; CGrowableArray<enum _D3DFORMAT>::Contains
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?GetSize@?$CGrowableArray@W4_D3DFORMAT@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetSize@?$CGrowableArray@W4_D3DFORMAT@@@@QBEHXZ PROC	; CGrowableArray<enum _D3DFORMAT>::GetSize, COMDAT
; _this$ = ecx

; 34   :     int     GetSize() const { return m_nSize; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSize@?$CGrowableArray@W4_D3DFORMAT@@@@QBEHXZ ENDP	; CGrowableArray<enum _D3DFORMAT>::GetSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?GetAt@?$CGrowableArray@W4_D3DFORMAT@@@@QAEAAW4_D3DFORMAT@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nIndex$ = 8						; size = 4
?GetAt@?$CGrowableArray@W4_D3DFORMAT@@@@QAEAAW4_D3DFORMAT@@H@Z PROC ; CGrowableArray<enum _D3DFORMAT>::GetAt, COMDAT
; _this$ = ecx

; 33   :     TYPE&   GetAt( int nIndex ) { assert( nIndex >= 0 && nIndex < m_nSize ); return m_pData[nIndex]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _nIndex$[ebp], 0
	jl	SHORT $LN3@GetAt
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jl	SHORT $LN4@GetAt
$LN3@GetAt:
	push	33					; 00000021H
	push	OFFSET ??_C@_1FK@FIMIDMPE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
	push	OFFSET ??_C@_1EA@JHMKKLFC@?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAm?$AA_?$AAn?$AAS?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@GetAt:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _nIndex$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetAt@?$CGrowableArray@W4_D3DFORMAT@@@@QAEAAW4_D3DFORMAT@@H@Z ENDP ; CGrowableArray<enum _D3DFORMAT>::GetAt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?Add@?$CGrowableArray@W4_D3DFORMAT@@@@QAEJABW4_D3DFORMAT@@@Z
_TEXT	SEGMENT
$T1 = -224						; size = 4
_hr$ = -20						; size = 4
_this$ = -8						; size = 4
_value$ = 8						; size = 4
?Add@?$CGrowableArray@W4_D3DFORMAT@@@@QAEJABW4_D3DFORMAT@@@Z PROC ; CGrowableArray<enum _D3DFORMAT>::Add, COMDAT
; _this$ = ecx

; 740  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 741  :     HRESULT hr;
; 742  :     if( FAILED( hr = SetSizeInternal( m_nSize + 1 ) ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSizeInternal@?$CGrowableArray@W4_D3DFORMAT@@@@IAEJH@Z ; CGrowableArray<enum _D3DFORMAT>::SetSizeInternal
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN1@Add

; 743  :         return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	jmp	SHORT $LN2@Add
$LN1@Add:

; 744  : 
; 745  :     // Construct the new element
; 746  :     ::new (&m_pData[m_nSize]) TYPE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*4]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax

; 747  : 
; 748  :     // Assign
; 749  :     m_pData[m_nSize] = value;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _value$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [eax+ecx*4], edx

; 750  :     ++m_nSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 751  : 
; 752  :     return S_OK;

	xor	eax, eax
$LN2@Add:

; 753  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Add@?$CGrowableArray@W4_D3DFORMAT@@@@QAEJABW4_D3DFORMAT@@@Z ENDP ; CGrowableArray<enum _D3DFORMAT>::Add
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?SetSize@?$CGrowableArray@W4_D3DFORMAT@@@@QAEJH@Z
_TEXT	SEGMENT
$T1 = -260						; size = 4
_i$2 = -56						; size = 4
_hr$ = -44						; size = 4
_i$3 = -32						; size = 4
_nOldSize$ = -20					; size = 4
_this$ = -8						; size = 4
_nNewMaxSize$ = 8					; size = 4
?SetSize@?$CGrowableArray@W4_D3DFORMAT@@@@QAEJH@Z PROC	; CGrowableArray<enum _D3DFORMAT>::SetSize, COMDAT
; _this$ = ecx

; 710  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 711  :     int nOldSize = m_nSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _nOldSize$[ebp], ecx

; 712  : 
; 713  :     if( nOldSize > nNewMaxSize )

	mov	eax, DWORD PTR _nOldSize$[ebp]
	cmp	eax, DWORD PTR _nNewMaxSize$[ebp]
	jle	SHORT $LN8@SetSize

; 714  :     {
; 715  :         // Removing elements. Call dtor.
; 716  : 
; 717  :         for( int i = nNewMaxSize; i < nOldSize; ++i )

	mov	eax, DWORD PTR _nNewMaxSize$[ebp]
	mov	DWORD PTR _i$3[ebp], eax
	jmp	SHORT $LN7@SetSize
$LN6@SetSize:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN7@SetSize:
	mov	eax, DWORD PTR _i$3[ebp]
	cmp	eax, DWORD PTR _nOldSize$[ebp]
	jge	SHORT $LN8@SetSize

; 718  :             m_pData[i].~TYPE();

	jmp	SHORT $LN6@SetSize
$LN8@SetSize:

; 719  :     }
; 720  : 
; 721  :     // Adjust buffer.  Note that there's no need to check for error
; 722  :     // since if it happens, nOldSize == nNewMaxSize will be true.)
; 723  :     HRESULT hr = SetSizeInternal( nNewMaxSize );

	mov	eax, DWORD PTR _nNewMaxSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSizeInternal@?$CGrowableArray@W4_D3DFORMAT@@@@IAEJH@Z ; CGrowableArray<enum _D3DFORMAT>::SetSizeInternal
	mov	DWORD PTR _hr$[ebp], eax

; 724  : 
; 725  :     if( nOldSize < nNewMaxSize )

	mov	eax, DWORD PTR _nOldSize$[ebp]
	cmp	eax, DWORD PTR _nNewMaxSize$[ebp]
	jge	SHORT $LN4@SetSize

; 726  :     {
; 727  :         // Adding elements. Call ctor.
; 728  : 
; 729  :         for( int i = nOldSize; i < nNewMaxSize; ++i )

	mov	eax, DWORD PTR _nOldSize$[ebp]
	mov	DWORD PTR _i$2[ebp], eax
	jmp	SHORT $LN3@SetSize
$LN2@SetSize:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN3@SetSize:
	mov	eax, DWORD PTR _i$2[ebp]
	cmp	eax, DWORD PTR _nNewMaxSize$[ebp]
	jge	SHORT $LN4@SetSize

; 730  :             ::new (&m_pData[i]) TYPE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$2[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	jmp	SHORT $LN2@SetSize
$LN4@SetSize:

; 731  :     }
; 732  : 
; 733  :     return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 734  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSize@?$CGrowableArray@W4_D3DFORMAT@@@@QAEJH@Z ENDP	; CGrowableArray<enum _D3DFORMAT>::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ??1?$CGrowableArray@W4_D3DFORMAT@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$CGrowableArray@W4_D3DFORMAT@@@@QAE@XZ PROC		; CGrowableArray<enum _D3DFORMAT>::~CGrowableArray<enum _D3DFORMAT>, COMDAT
; _this$ = ecx

; 22   :     ~CGrowableArray() { RemoveAll(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CGrowableArray@W4_D3DFORMAT@@@@QAEXXZ ; CGrowableArray<enum _D3DFORMAT>::RemoveAll
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CGrowableArray@W4_D3DFORMAT@@@@QAE@XZ ENDP		; CGrowableArray<enum _D3DFORMAT>::~CGrowableArray<enum _D3DFORMAT>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ??0?$CGrowableArray@W4_D3DFORMAT@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$CGrowableArray@W4_D3DFORMAT@@@@QAE@XZ PROC		; CGrowableArray<enum _D3DFORMAT>::CGrowableArray<enum _D3DFORMAT>, COMDAT
; _this$ = ecx

; 20   :     CGrowableArray()  { m_pData = NULL; m_nSize = 0; m_nMaxSize = 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CGrowableArray@W4_D3DFORMAT@@@@QAE@XZ ENDP		; CGrowableArray<enum _D3DFORMAT>::CGrowableArray<enum _D3DFORMAT>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutenum.cpp
;	COMDAT ??0CD3DEnumeration@@AAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0CD3DEnumeration@@AAE@XZ PROC				; CD3DEnumeration::CD3DEnumeration, COMDAT
; _this$ = ecx

; 31   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CD3DEnumeration@@AAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 13					; 0000000dH
	call	??0?$CGrowableArray@W4_D3DFORMAT@@@@QAE@XZ ; CGrowableArray<enum _D3DFORMAT>::CGrowableArray<enum _D3DFORMAT>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 25					; 00000019H
	call	??0?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAE@XZ ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::CGrowableArray<enum _D3DMULTISAMPLE_TYPE>
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 37					; 00000025H
	call	??0?$CGrowableArray@I@@QAE@XZ		; CGrowableArray<unsigned int>::CGrowableArray<unsigned int>
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 81					; 00000051H
	call	??0?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAE@XZ ; CGrowableArray<CD3DEnumAdapterInfo *>::CGrowableArray<CD3DEnumAdapterInfo *>
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 32   :     m_pD3D = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 33   :     m_IsDeviceAcceptableFunc = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 34   :     m_pIsDeviceAcceptableFuncUserContext = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 35   :     m_bRequirePostPixelShaderBlending = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+12], 1

; 36   : 
; 37   :     m_nMinWidth = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+53], 0

; 38   :     m_nMinHeight = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+61], 0

; 39   :     m_nMaxWidth = UINT_MAX;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+57], -1

; 40   :     m_nMaxHeight = UINT_MAX;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+65], -1

; 41   : 
; 42   :     m_nRefreshMin = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+69], 0

; 43   :     m_nRefreshMax = UINT_MAX;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+73], -1

; 44   : 
; 45   :     m_nMultisampleQualityMax = 0xFFFF;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+77], 65535		; 0000ffffH

; 46   : 
; 47   :     ResetPossibleDepthStencilFormats();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetPossibleDepthStencilFormats@CD3DEnumeration@@QAEXXZ ; CD3DEnumeration::ResetPossibleDepthStencilFormats

; 48   :     ResetPossibleMultisampleTypeList();                                   

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetPossibleMultisampleTypeList@CD3DEnumeration@@QAEXXZ ; CD3DEnumeration::ResetPossibleMultisampleTypeList

; 49   :     ResetPossiblePresentIntervalList();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetPossiblePresentIntervalList@CD3DEnumeration@@QAEXXZ ; CD3DEnumeration::ResetPossiblePresentIntervalList

; 50   :     SetPossibleVertexProcessingList( true, true, true, false );

	push	0
	push	1
	push	1
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPossibleVertexProcessingList@CD3DEnumeration@@QAEX_N000@Z ; CD3DEnumeration::SetPossibleVertexProcessingList

; 51   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CD3DEnumeration@@AAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 13					; 0000000dH
	jmp	??1?$CGrowableArray@W4_D3DFORMAT@@@@QAE@XZ ; CGrowableArray<enum _D3DFORMAT>::~CGrowableArray<enum _D3DFORMAT>
__unwindfunclet$??0CD3DEnumeration@@AAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 25					; 00000019H
	jmp	??1?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAE@XZ ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::~CGrowableArray<enum _D3DMULTISAMPLE_TYPE>
__unwindfunclet$??0CD3DEnumeration@@AAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 37					; 00000025H
	jmp	??1?$CGrowableArray@I@@QAE@XZ		; CGrowableArray<unsigned int>::~CGrowableArray<unsigned int>
__unwindfunclet$??0CD3DEnumeration@@AAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 81					; 00000051H
	jmp	??1?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAE@XZ ; CGrowableArray<CD3DEnumAdapterInfo *>::~CGrowableArray<CD3DEnumAdapterInfo *>
__ehhandler$??0CD3DEnumeration@@AAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CD3DEnumeration@@AAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CD3DEnumeration@@AAE@XZ ENDP				; CD3DEnumeration::CD3DEnumeration
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutenum.cpp
;	COMDAT ?DXUTGetEnumeration@@YAPAVCD3DEnumeration@@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?DXUTGetEnumeration@@YAPAVCD3DEnumeration@@XZ PROC	; DXUTGetEnumeration, COMDAT

; 22   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DXUTGetEnumeration@@YAPAVCD3DEnumeration@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 23   :     // Using an accessor function gives control of the construction order
; 24   :     static CD3DEnumeration d3denum;

	mov	eax, DWORD PTR ?$S1@?1??DXUTGetEnumeration@@YAPAVCD3DEnumeration@@XZ@4IA
	and	eax, 1
	jne	SHORT $LN1@DXUTGetEnu
	mov	eax, DWORD PTR ?$S1@?1??DXUTGetEnumeration@@YAPAVCD3DEnumeration@@XZ@4IA
	or	eax, 1
	mov	DWORD PTR ?$S1@?1??DXUTGetEnumeration@@YAPAVCD3DEnumeration@@XZ@4IA, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, OFFSET ?d3denum@?1??DXUTGetEnumeration@@YAPAVCD3DEnumeration@@XZ@4V2@A
	call	??0CD3DEnumeration@@AAE@XZ		; CD3DEnumeration::CD3DEnumeration
	push	OFFSET ??__Fd3denum@?1??DXUTGetEnumeration@@YAPAVCD3DEnumeration@@XZ@YAXXZ ; `DXUTGetEnumeration'::`2'::`dynamic atexit destructor for 'd3denum''
	call	_atexit
	add	esp, 4
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN1@DXUTGetEnu:

; 25   :     return &d3denum;

	mov	eax, OFFSET ?d3denum@?1??DXUTGetEnumeration@@YAPAVCD3DEnumeration@@XZ@4V2@A

; 26   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DXUTGetEnumeration@@YAPAVCD3DEnumeration@@XZ$0:
	mov	eax, DWORD PTR ?$S1@?1??DXUTGetEnumeration@@YAPAVCD3DEnumeration@@XZ@4IA
	and	eax, -2					; fffffffeH
	mov	DWORD PTR ?$S1@?1??DXUTGetEnumeration@@YAPAVCD3DEnumeration@@XZ@4IA, eax
	ret	0
__ehhandler$?DXUTGetEnumeration@@YAPAVCD3DEnumeration@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DXUTGetEnumeration@@YAPAVCD3DEnumeration@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?DXUTGetEnumeration@@YAPAVCD3DEnumeration@@XZ ENDP	; DXUTGetEnumeration
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutenum.cpp
;	COMDAT ??1CD3DEnumeration@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1CD3DEnumeration@@QAE@XZ PROC				; CD3DEnumeration::~CD3DEnumeration, COMDAT
; _this$ = ecx

; 56   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CD3DEnumeration@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 3

; 57   :     ClearAdapterInfoList();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearAdapterInfoList@CD3DEnumeration@@AAEXXZ ; CD3DEnumeration::ClearAdapterInfoList

; 58   : }

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 81					; 00000051H
	call	??1?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAE@XZ ; CGrowableArray<CD3DEnumAdapterInfo *>::~CGrowableArray<CD3DEnumAdapterInfo *>
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 37					; 00000025H
	call	??1?$CGrowableArray@I@@QAE@XZ		; CGrowableArray<unsigned int>::~CGrowableArray<unsigned int>
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 25					; 00000019H
	call	??1?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAE@XZ ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::~CGrowableArray<enum _D3DMULTISAMPLE_TYPE>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 13					; 0000000dH
	call	??1?$CGrowableArray@W4_D3DFORMAT@@@@QAE@XZ ; CGrowableArray<enum _D3DFORMAT>::~CGrowableArray<enum _D3DFORMAT>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CD3DEnumeration@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 13					; 0000000dH
	jmp	??1?$CGrowableArray@W4_D3DFORMAT@@@@QAE@XZ ; CGrowableArray<enum _D3DFORMAT>::~CGrowableArray<enum _D3DFORMAT>
__unwindfunclet$??1CD3DEnumeration@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 25					; 00000019H
	jmp	??1?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAE@XZ ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::~CGrowableArray<enum _D3DMULTISAMPLE_TYPE>
__unwindfunclet$??1CD3DEnumeration@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 37					; 00000025H
	jmp	??1?$CGrowableArray@I@@QAE@XZ		; CGrowableArray<unsigned int>::~CGrowableArray<unsigned int>
__unwindfunclet$??1CD3DEnumeration@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 81					; 00000051H
	jmp	??1?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAE@XZ ; CGrowableArray<CD3DEnumAdapterInfo *>::~CGrowableArray<CD3DEnumAdapterInfo *>
__ehhandler$??1CD3DEnumeration@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CD3DEnumeration@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CD3DEnumeration@@QAE@XZ ENDP				; CD3DEnumeration::~CD3DEnumeration
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutenum.cpp
;	COMDAT ?GetDeviceSettingsCombo@CD3DEnumeration@@QAEPAUCD3DEnumDeviceSettingsCombo@@IW4_D3DDEVTYPE@@W4_D3DFORMAT@@1H@Z
_TEXT	SEGMENT
_pDeviceSettingsCombo$1 = -44				; size = 4
_iDeviceCombo$2 = -32					; size = 4
_pDeviceInfo$ = -20					; size = 4
_this$ = -8						; size = 4
_AdapterOrdinal$ = 8					; size = 4
_DeviceType$ = 12					; size = 4
_AdapterFormat$ = 16					; size = 4
_BackBufferFormat$ = 20					; size = 4
_bWindowed$ = 24					; size = 4
?GetDeviceSettingsCombo@CD3DEnumeration@@QAEPAUCD3DEnumDeviceSettingsCombo@@IW4_D3DDEVTYPE@@W4_D3DFORMAT@@1H@Z PROC ; CD3DEnumeration::GetDeviceSettingsCombo, COMDAT
; _this$ = ecx

; 530  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 531  :     CD3DEnumDeviceInfo* pDeviceInfo = GetDeviceInfo( AdapterOrdinal, DeviceType );

	mov	eax, DWORD PTR _DeviceType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _AdapterOrdinal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDeviceInfo@CD3DEnumeration@@QAEPAVCD3DEnumDeviceInfo@@IW4_D3DDEVTYPE@@@Z ; CD3DEnumeration::GetDeviceInfo
	mov	DWORD PTR _pDeviceInfo$[ebp], eax

; 532  :     if( pDeviceInfo )

	cmp	DWORD PTR _pDeviceInfo$[ebp], 0
	je	SHORT $LN5@GetDeviceS

; 533  :     {
; 534  :         for( int iDeviceCombo=0; iDeviceCombo<pDeviceInfo->deviceSettingsComboList.GetSize(); iDeviceCombo++ )

	mov	DWORD PTR _iDeviceCombo$2[ebp], 0
	jmp	SHORT $LN4@GetDeviceS
$LN3@GetDeviceS:
	mov	eax, DWORD PTR _iDeviceCombo$2[ebp]
	add	eax, 1
	mov	DWORD PTR _iDeviceCombo$2[ebp], eax
$LN4@GetDeviceS:
	mov	ecx, DWORD PTR _pDeviceInfo$[ebp]
	add	ecx, 312				; 00000138H
	call	?GetSize@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QBEHXZ ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::GetSize
	cmp	DWORD PTR _iDeviceCombo$2[ebp], eax
	jge	SHORT $LN5@GetDeviceS

; 535  :         {
; 536  :             CD3DEnumDeviceSettingsCombo* pDeviceSettingsCombo = pDeviceInfo->deviceSettingsComboList.GetAt(iDeviceCombo);

	mov	eax, DWORD PTR _iDeviceCombo$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeviceInfo$[ebp]
	add	ecx, 312				; 00000138H
	call	?GetAt@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QAEAAPAUCD3DEnumDeviceSettingsCombo@@H@Z ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::GetAt
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pDeviceSettingsCombo$1[ebp], ecx

; 537  :             if( pDeviceSettingsCombo->AdapterFormat == AdapterFormat &&
; 538  :                 pDeviceSettingsCombo->BackBufferFormat == BackBufferFormat &&
; 539  :                 pDeviceSettingsCombo->Windowed == bWindowed )

	mov	eax, DWORD PTR _pDeviceSettingsCombo$1[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _AdapterFormat$[ebp]
	jne	SHORT $LN1@GetDeviceS
	mov	eax, DWORD PTR _pDeviceSettingsCombo$1[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR _BackBufferFormat$[ebp]
	jne	SHORT $LN1@GetDeviceS
	mov	eax, DWORD PTR _pDeviceSettingsCombo$1[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR _bWindowed$[ebp]
	jne	SHORT $LN1@GetDeviceS

; 540  :                 return pDeviceSettingsCombo;

	mov	eax, DWORD PTR _pDeviceSettingsCombo$1[ebp]
	jmp	SHORT $LN6@GetDeviceS
$LN1@GetDeviceS:

; 541  :         }

	jmp	SHORT $LN3@GetDeviceS
$LN5@GetDeviceS:

; 542  :     }
; 543  : 
; 544  :     return NULL;

	xor	eax, eax
$LN6@GetDeviceS:

; 545  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?GetDeviceSettingsCombo@CD3DEnumeration@@QAEPAUCD3DEnumDeviceSettingsCombo@@IW4_D3DDEVTYPE@@W4_D3DFORMAT@@1H@Z ENDP ; CD3DEnumeration::GetDeviceSettingsCombo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutenum.cpp
;	COMDAT ?GetDeviceInfo@CD3DEnumeration@@QAEPAVCD3DEnumDeviceInfo@@IW4_D3DDEVTYPE@@@Z
_TEXT	SEGMENT
_pDeviceInfo$1 = -44					; size = 4
_iDeviceInfo$2 = -32					; size = 4
_pAdapterInfo$ = -20					; size = 4
_this$ = -8						; size = 4
_AdapterOrdinal$ = 8					; size = 4
_DeviceType$ = 12					; size = 4
?GetDeviceInfo@CD3DEnumeration@@QAEPAVCD3DEnumDeviceInfo@@IW4_D3DDEVTYPE@@@Z PROC ; CD3DEnumeration::GetDeviceInfo, COMDAT
; _this$ = ecx

; 510  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 511  :     CD3DEnumAdapterInfo* pAdapterInfo = GetAdapterInfo( AdapterOrdinal );

	mov	eax, DWORD PTR _AdapterOrdinal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAdapterInfo@CD3DEnumeration@@QAEPAVCD3DEnumAdapterInfo@@I@Z ; CD3DEnumeration::GetAdapterInfo
	mov	DWORD PTR _pAdapterInfo$[ebp], eax

; 512  :     if( pAdapterInfo )

	cmp	DWORD PTR _pAdapterInfo$[ebp], 0
	je	SHORT $LN5@GetDeviceI

; 513  :     {
; 514  :         for( int iDeviceInfo=0; iDeviceInfo<pAdapterInfo->deviceInfoList.GetSize(); iDeviceInfo++ )

	mov	DWORD PTR _iDeviceInfo$2[ebp], 0
	jmp	SHORT $LN4@GetDeviceI
$LN3@GetDeviceI:
	mov	eax, DWORD PTR _iDeviceInfo$2[ebp]
	add	eax, 1
	mov	DWORD PTR _iDeviceInfo$2[ebp], eax
$LN4@GetDeviceI:
	mov	ecx, DWORD PTR _pAdapterInfo$[ebp]
	add	ecx, 1372				; 0000055cH
	call	?GetSize@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QBEHXZ ; CGrowableArray<CD3DEnumDeviceInfo *>::GetSize
	cmp	DWORD PTR _iDeviceInfo$2[ebp], eax
	jge	SHORT $LN5@GetDeviceI

; 515  :         {
; 516  :             CD3DEnumDeviceInfo* pDeviceInfo = pAdapterInfo->deviceInfoList.GetAt(iDeviceInfo);

	mov	eax, DWORD PTR _iDeviceInfo$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _pAdapterInfo$[ebp]
	add	ecx, 1372				; 0000055cH
	call	?GetAt@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QAEAAPAVCD3DEnumDeviceInfo@@H@Z ; CGrowableArray<CD3DEnumDeviceInfo *>::GetAt
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pDeviceInfo$1[ebp], ecx

; 517  :             if( pDeviceInfo->DeviceType == DeviceType )

	mov	eax, DWORD PTR _pDeviceInfo$1[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _DeviceType$[ebp]
	jne	SHORT $LN1@GetDeviceI

; 518  :                 return pDeviceInfo;

	mov	eax, DWORD PTR _pDeviceInfo$1[ebp]
	jmp	SHORT $LN6@GetDeviceI
$LN1@GetDeviceI:

; 519  :         }

	jmp	SHORT $LN3@GetDeviceI
$LN5@GetDeviceI:

; 520  :     }
; 521  : 
; 522  :     return NULL;

	xor	eax, eax
$LN6@GetDeviceI:

; 523  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?GetDeviceInfo@CD3DEnumeration@@QAEPAVCD3DEnumDeviceInfo@@IW4_D3DDEVTYPE@@@Z ENDP ; CD3DEnumeration::GetDeviceInfo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutenum.cpp
;	COMDAT ?GetAdapterInfo@CD3DEnumeration@@QAEPAVCD3DEnumAdapterInfo@@I@Z
_TEXT	SEGMENT
_pAdapterInfo$1 = -32					; size = 4
_iAdapter$2 = -20					; size = 4
_this$ = -8						; size = 4
_AdapterOrdinal$ = 8					; size = 4
?GetAdapterInfo@CD3DEnumeration@@QAEPAVCD3DEnumAdapterInfo@@I@Z PROC ; CD3DEnumeration::GetAdapterInfo, COMDAT
; _this$ = ecx

; 496  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  :     for( int iAdapter=0; iAdapter<m_AdapterInfoList.GetSize(); iAdapter++ )

	mov	DWORD PTR _iAdapter$2[ebp], 0
	jmp	SHORT $LN4@GetAdapter
$LN3@GetAdapter:
	mov	eax, DWORD PTR _iAdapter$2[ebp]
	add	eax, 1
	mov	DWORD PTR _iAdapter$2[ebp], eax
$LN4@GetAdapter:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 81					; 00000051H
	call	?GetSize@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QBEHXZ ; CGrowableArray<CD3DEnumAdapterInfo *>::GetSize
	cmp	DWORD PTR _iAdapter$2[ebp], eax
	jge	SHORT $LN2@GetAdapter

; 498  :     {
; 499  :         CD3DEnumAdapterInfo* pAdapterInfo = m_AdapterInfoList.GetAt(iAdapter);

	mov	eax, DWORD PTR _iAdapter$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 81					; 00000051H
	call	?GetAt@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAEAAPAVCD3DEnumAdapterInfo@@H@Z ; CGrowableArray<CD3DEnumAdapterInfo *>::GetAt
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pAdapterInfo$1[ebp], ecx

; 500  :         if( pAdapterInfo->AdapterOrdinal == AdapterOrdinal )

	mov	eax, DWORD PTR _pAdapterInfo$1[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _AdapterOrdinal$[ebp]
	jne	SHORT $LN1@GetAdapter

; 501  :             return pAdapterInfo;

	mov	eax, DWORD PTR _pAdapterInfo$1[ebp]
	jmp	SHORT $LN5@GetAdapter
$LN1@GetAdapter:

; 502  :     }

	jmp	SHORT $LN3@GetAdapter
$LN2@GetAdapter:

; 503  : 
; 504  :     return NULL;

	xor	eax, eax
$LN5@GetAdapter:

; 505  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetAdapterInfo@CD3DEnumeration@@QAEPAVCD3DEnumAdapterInfo@@I@Z ENDP ; CD3DEnumeration::GetAdapterInfo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutenum.cpp
;	COMDAT ?GetAdapterInfoList@CD3DEnumeration@@QAEPAV?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetAdapterInfoList@CD3DEnumeration@@QAEPAV?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@XZ PROC ; CD3DEnumeration::GetAdapterInfoList, COMDAT
; _this$ = ecx

; 488  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 489  :     return &m_AdapterInfoList;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 81					; 00000051H

; 490  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAdapterInfoList@CD3DEnumeration@@QAEPAV?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@XZ ENDP ; CD3DEnumeration::GetAdapterInfoList
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutenum.cpp
;	COMDAT ?Enumerate@CD3DEnumeration@@QAEJPAUIDirect3D9@@P6G_NPAU_D3DCAPS9@@W4_D3DFORMAT@@2_NPAX@Z4@Z
_TEXT	SEGMENT
tv247 = -724						; size = 4
tv233 = -724						; size = 4
tv87 = -724						; size = 4
$T2 = -716						; size = 4
$T3 = -704						; size = 4
$T4 = -692						; size = 4
$T5 = -680						; size = 4
$T6 = -668						; size = 4
$T7 = -656						; size = 4
$T8 = -644						; size = 4
$T9 = -632						; size = 4
$T10 = -620						; size = 4
_sz$11 = -416						; size = 100
_i$12 = -308						; size = 4
_pAdapterInfo2$13 = -296				; size = 4
_j$14 = -284						; size = 4
_pAdapterInfo1$15 = -272				; size = 4
_i$16 = -260						; size = 4
_pAdapterInfo$ = -248					; size = 4
_bUniqueDesc$ = -233					; size = 1
_displayMode$17 = -224					; size = 16
_displayMode$18 = -200					; size = 16
_mode$19 = -176						; size = 4
_numAdapterModes$20 = -164				; size = 4
_allowedAdapterFormat$21 = -152				; size = 4
_iFormatList$22 = -140					; size = 4
_pAdapterInfo$23 = -128					; size = 4
_adapterOrdinal$24 = -116				; size = 4
_numAdapters$ = -104					; size = 4
_allowedAdapterFormatArrayCount$ = -92			; size = 4
_allowedAdapterFormatArray$ = -80			; size = 16
_adapterFormatList$ = -56				; size = 12
_hr$ = -36						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pD3D$ = 8						; size = 4
_IsDeviceAcceptableFunc$ = 12				; size = 4
_pIsDeviceAcceptableFuncUserContext$ = 16		; size = 4
?Enumerate@CD3DEnumeration@@QAEJPAUIDirect3D9@@P6G_NPAU_D3DCAPS9@@W4_D3DFORMAT@@2_NPAX@Z4@Z PROC ; CD3DEnumeration::Enumerate, COMDAT
; _this$ = ecx

; 68   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Enumerate@CD3DEnumeration@@QAEJPAUIDirect3D9@@P6G_NPAU_D3DCAPS9@@W4_D3DFORMAT@@2_NPAX@Z4@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 712				; 000002c8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-724]
	mov	ecx, 178				; 000000b2H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 69   :     if( pD3D == NULL )

	cmp	DWORD PTR _pD3D$[ebp], 0
	jne	SHORT $LN32@Enumerate

; 70   :     {
; 71   :         pD3D = DXUTGetD3DObject();

	call	?DXUTGetD3DObject@@YAPAUIDirect3D9@@XZ	; DXUTGetD3DObject
	mov	DWORD PTR _pD3D$[ebp], eax

; 72   :         if( pD3D == NULL )

	cmp	DWORD PTR _pD3D$[ebp], 0
	jne	SHORT $LN32@Enumerate

; 73   :             return DXUTERR_NODIRECT3D;

	mov	eax, -2147219199			; 80040901H
	jmp	$LN33@Enumerate
$LN32@Enumerate:

; 74   :     }
; 75   : 
; 76   :     m_pD3D = pD3D;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pD3D$[ebp]
	mov	DWORD PTR [eax], ecx

; 77   :     m_IsDeviceAcceptableFunc = IsDeviceAcceptableFunc;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _IsDeviceAcceptableFunc$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 78   :     m_pIsDeviceAcceptableFuncUserContext = pIsDeviceAcceptableFuncUserContext;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pIsDeviceAcceptableFuncUserContext$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 79   : 
; 80   :     HRESULT hr;
; 81   :     ClearAdapterInfoList();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearAdapterInfoList@CD3DEnumeration@@AAEXXZ ; CD3DEnumeration::ClearAdapterInfoList

; 82   :     CGrowableArray<D3DFORMAT> adapterFormatList;

	lea	ecx, DWORD PTR _adapterFormatList$[ebp]
	call	??0?$CGrowableArray@W4_D3DFORMAT@@@@QAE@XZ ; CGrowableArray<enum _D3DFORMAT>::CGrowableArray<enum _D3DFORMAT>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 83   : 
; 84   :     const D3DFORMAT allowedAdapterFormatArray[] = 
; 85   :     {   
; 86   :         D3DFMT_X8R8G8B8, 
; 87   :         D3DFMT_X1R5G5B5, 
; 88   :         D3DFMT_R5G6B5, 
; 89   :         D3DFMT_A2R10G10B10
; 90   :     };

	mov	DWORD PTR _allowedAdapterFormatArray$[ebp], 22 ; 00000016H
	mov	DWORD PTR _allowedAdapterFormatArray$[ebp+4], 24 ; 00000018H
	mov	DWORD PTR _allowedAdapterFormatArray$[ebp+8], 23 ; 00000017H
	mov	DWORD PTR _allowedAdapterFormatArray$[ebp+12], 35 ; 00000023H

; 91   :     const UINT allowedAdapterFormatArrayCount  = sizeof(allowedAdapterFormatArray) / sizeof(allowedAdapterFormatArray[0]);

	mov	DWORD PTR _allowedAdapterFormatArrayCount$[ebp], 4

; 92   : 
; 93   :     UINT numAdapters = pD3D->GetAdapterCount();

	mov	eax, DWORD PTR _pD3D$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR _pD3D$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+16]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _numAdapters$[ebp], eax

; 94   :     for (UINT adapterOrdinal = 0; adapterOrdinal < numAdapters; adapterOrdinal++)

	mov	DWORD PTR _adapterOrdinal$24[ebp], 0
	jmp	SHORT $LN30@Enumerate
$LN29@Enumerate:
	mov	eax, DWORD PTR _adapterOrdinal$24[ebp]
	add	eax, 1
	mov	DWORD PTR _adapterOrdinal$24[ebp], eax
$LN30@Enumerate:
	mov	eax, DWORD PTR _adapterOrdinal$24[ebp]
	cmp	eax, DWORD PTR _numAdapters$[ebp]
	jae	$LN28@Enumerate

; 95   :     {
; 96   :         CD3DEnumAdapterInfo* pAdapterInfo = new CD3DEnumAdapterInfo;

	push	1384					; 00000568H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN35@Enumerate
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0CD3DEnumAdapterInfo@@QAE@XZ
	mov	DWORD PTR tv87[ebp], eax
	jmp	SHORT $LN36@Enumerate
$LN35@Enumerate:
	mov	DWORD PTR tv87[ebp], 0
$LN36@Enumerate:
	mov	eax, DWORD PTR tv87[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _pAdapterInfo$23[ebp], ecx

; 97   :         if( pAdapterInfo == NULL )

	cmp	DWORD PTR _pAdapterInfo$23[ebp], 0
	jne	SHORT $LN27@Enumerate

; 98   :             return E_OUTOFMEMORY;

	mov	DWORD PTR $T4[ebp], -2147024882		; 8007000eH
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _adapterFormatList$[ebp]
	call	??1?$CGrowableArray@W4_D3DFORMAT@@@@QAE@XZ ; CGrowableArray<enum _D3DFORMAT>::~CGrowableArray<enum _D3DFORMAT>
	mov	eax, DWORD PTR $T4[ebp]
	jmp	$LN33@Enumerate
$LN27@Enumerate:

; 99   : 
; 100  :         pAdapterInfo->AdapterOrdinal = adapterOrdinal;

	mov	eax, DWORD PTR _pAdapterInfo$23[ebp]
	mov	ecx, DWORD PTR _adapterOrdinal$24[ebp]
	mov	DWORD PTR [eax], ecx

; 101  :         pD3D->GetAdapterIdentifier(adapterOrdinal, 0, &pAdapterInfo->AdapterIdentifier);

	mov	eax, DWORD PTR _pAdapterInfo$23[ebp]
	add	eax, 4
	mov	esi, esp
	push	eax
	push	0
	mov	ecx, DWORD PTR _adapterOrdinal$24[ebp]
	push	ecx
	mov	edx, DWORD PTR _pD3D$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pD3D$[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+20]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 102  : 
; 103  :         // Get list of all display modes on this adapter.  
; 104  :         // Also build a temporary list of all display adapter formats.
; 105  :         adapterFormatList.RemoveAll();

	lea	ecx, DWORD PTR _adapterFormatList$[ebp]
	call	?RemoveAll@?$CGrowableArray@W4_D3DFORMAT@@@@QAEXXZ ; CGrowableArray<enum _D3DFORMAT>::RemoveAll

; 106  : 
; 107  :         for( UINT iFormatList = 0; iFormatList < allowedAdapterFormatArrayCount; iFormatList++ )

	mov	DWORD PTR _iFormatList$22[ebp], 0
	jmp	SHORT $LN26@Enumerate
$LN25@Enumerate:
	mov	eax, DWORD PTR _iFormatList$22[ebp]
	add	eax, 1
	mov	DWORD PTR _iFormatList$22[ebp], eax
$LN26@Enumerate:
	cmp	DWORD PTR _iFormatList$22[ebp], 4
	jae	$LN24@Enumerate

; 108  :         {
; 109  :             D3DFORMAT allowedAdapterFormat = allowedAdapterFormatArray[iFormatList];

	mov	eax, DWORD PTR _iFormatList$22[ebp]
	mov	ecx, DWORD PTR _allowedAdapterFormatArray$[ebp+eax*4]
	mov	DWORD PTR _allowedAdapterFormat$21[ebp], ecx

; 110  :             UINT numAdapterModes = pD3D->GetAdapterModeCount( adapterOrdinal, allowedAdapterFormat );

	mov	esi, esp
	mov	eax, DWORD PTR _allowedAdapterFormat$21[ebp]
	push	eax
	mov	ecx, DWORD PTR _adapterOrdinal$24[ebp]
	push	ecx
	mov	edx, DWORD PTR _pD3D$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pD3D$[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+24]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _numAdapterModes$20[ebp], eax

; 111  :             for (UINT mode = 0; mode < numAdapterModes; mode++)

	mov	DWORD PTR _mode$19[ebp], 0
	jmp	SHORT $LN23@Enumerate
$LN22@Enumerate:
	mov	eax, DWORD PTR _mode$19[ebp]
	add	eax, 1
	mov	DWORD PTR _mode$19[ebp], eax
$LN23@Enumerate:
	mov	eax, DWORD PTR _mode$19[ebp]
	cmp	eax, DWORD PTR _numAdapterModes$20[ebp]
	jae	$LN21@Enumerate

; 112  :             {
; 113  :                 D3DDISPLAYMODE displayMode;
; 114  :                 pD3D->EnumAdapterModes( adapterOrdinal, allowedAdapterFormat, mode, &displayMode );

	mov	esi, esp
	lea	eax, DWORD PTR _displayMode$18[ebp]
	push	eax
	mov	ecx, DWORD PTR _mode$19[ebp]
	push	ecx
	mov	edx, DWORD PTR _allowedAdapterFormat$21[ebp]
	push	edx
	mov	eax, DWORD PTR _adapterOrdinal$24[ebp]
	push	eax
	mov	ecx, DWORD PTR _pD3D$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pD3D$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+28]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 115  : 
; 116  :                 if( displayMode.Width < m_nMinWidth ||
; 117  :                     displayMode.Height < m_nMinHeight || 
; 118  :                     displayMode.Width > m_nMaxWidth ||
; 119  :                     displayMode.Height > m_nMaxHeight || 
; 120  :                     displayMode.RefreshRate < m_nRefreshMin ||
; 121  :                     displayMode.RefreshRate > m_nRefreshMax )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _displayMode$18[ebp]
	cmp	ecx, DWORD PTR [eax+53]
	jb	SHORT $LN19@Enumerate
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _displayMode$18[ebp+4]
	cmp	ecx, DWORD PTR [eax+61]
	jb	SHORT $LN19@Enumerate
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _displayMode$18[ebp]
	cmp	ecx, DWORD PTR [eax+57]
	ja	SHORT $LN19@Enumerate
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _displayMode$18[ebp+4]
	cmp	ecx, DWORD PTR [eax+65]
	ja	SHORT $LN19@Enumerate
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _displayMode$18[ebp+8]
	cmp	ecx, DWORD PTR [eax+69]
	jb	SHORT $LN19@Enumerate
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _displayMode$18[ebp+8]
	cmp	ecx, DWORD PTR [eax+73]
	jbe	SHORT $LN20@Enumerate
$LN19@Enumerate:

; 122  :                 {
; 123  :                     continue;

	jmp	$LN22@Enumerate
$LN20@Enumerate:

; 124  :                 }
; 125  : 
; 126  :                 pAdapterInfo->displayModeList.Add( displayMode );

	lea	eax, DWORD PTR _displayMode$18[ebp]
	push	eax
	mov	ecx, DWORD PTR _pAdapterInfo$23[ebp]
	add	ecx, 1360				; 00000550H
	call	?Add@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAEJABU_D3DDISPLAYMODE@@@Z ; CGrowableArray<_D3DDISPLAYMODE>::Add

; 127  :                 
; 128  :                 if( !adapterFormatList.Contains(displayMode.Format) )

	lea	eax, DWORD PTR _displayMode$18[ebp+12]
	push	eax
	lea	ecx, DWORD PTR _adapterFormatList$[ebp]
	call	?Contains@?$CGrowableArray@W4_D3DFORMAT@@@@QAE_NABW4_D3DFORMAT@@@Z ; CGrowableArray<enum _D3DFORMAT>::Contains
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN18@Enumerate

; 129  :                     adapterFormatList.Add( displayMode.Format );

	lea	eax, DWORD PTR _displayMode$18[ebp+12]
	push	eax
	lea	ecx, DWORD PTR _adapterFormatList$[ebp]
	call	?Add@?$CGrowableArray@W4_D3DFORMAT@@@@QAEJABW4_D3DFORMAT@@@Z ; CGrowableArray<enum _D3DFORMAT>::Add
$LN18@Enumerate:

; 130  :             }

	jmp	$LN22@Enumerate
$LN21@Enumerate:

; 131  : 
; 132  :         }

	jmp	$LN25@Enumerate
$LN24@Enumerate:

; 133  : 
; 134  :         D3DDISPLAYMODE displayMode;
; 135  :         pD3D->GetAdapterDisplayMode( adapterOrdinal, &displayMode );

	mov	esi, esp
	lea	eax, DWORD PTR _displayMode$17[ebp]
	push	eax
	mov	ecx, DWORD PTR _adapterOrdinal$24[ebp]
	push	ecx
	mov	edx, DWORD PTR _pD3D$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pD3D$[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+32]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 136  :         if( !adapterFormatList.Contains(displayMode.Format) )

	lea	eax, DWORD PTR _displayMode$17[ebp+12]
	push	eax
	lea	ecx, DWORD PTR _adapterFormatList$[ebp]
	call	?Contains@?$CGrowableArray@W4_D3DFORMAT@@@@QAE_NABW4_D3DFORMAT@@@Z ; CGrowableArray<enum _D3DFORMAT>::Contains
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN17@Enumerate

; 137  :             adapterFormatList.Add( displayMode.Format );

	lea	eax, DWORD PTR _displayMode$17[ebp+12]
	push	eax
	lea	ecx, DWORD PTR _adapterFormatList$[ebp]
	call	?Add@?$CGrowableArray@W4_D3DFORMAT@@@@QAEJABW4_D3DFORMAT@@@Z ; CGrowableArray<enum _D3DFORMAT>::Add
$LN17@Enumerate:

; 138  : 
; 139  :         // Sort displaymode list
; 140  :         qsort( pAdapterInfo->displayModeList.GetData(), 
; 141  :                pAdapterInfo->displayModeList.GetSize(), sizeof( D3DDISPLAYMODE ),
; 142  :                SortModesCallback );

	push	OFFSET ?SortModesCallback@@YAHPBX0@Z	; SortModesCallback
	push	16					; 00000010H
	mov	ecx, DWORD PTR _pAdapterInfo$23[ebp]
	add	ecx, 1360				; 00000550H
	call	?GetSize@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QBEHXZ ; CGrowableArray<_D3DDISPLAYMODE>::GetSize
	push	eax
	mov	ecx, DWORD PTR _pAdapterInfo$23[ebp]
	add	ecx, 1360				; 00000550H
	call	?GetData@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAEPAU_D3DDISPLAYMODE@@XZ ; CGrowableArray<_D3DDISPLAYMODE>::GetData
	push	eax
	call	_qsort
	add	esp, 16					; 00000010H

; 143  : 
; 144  :         // Get info for each device on this adapter
; 145  :         if( FAILED( EnumerateDevices( pAdapterInfo, &adapterFormatList ) ) )

	lea	eax, DWORD PTR _adapterFormatList$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pAdapterInfo$23[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EnumerateDevices@CD3DEnumeration@@AAEJPAVCD3DEnumAdapterInfo@@PAV?$CGrowableArray@W4_D3DFORMAT@@@@@Z ; CD3DEnumeration::EnumerateDevices
	test	eax, eax
	jge	SHORT $LN16@Enumerate

; 146  :         {
; 147  :             delete pAdapterInfo;

	mov	eax, DWORD PTR _pAdapterInfo$23[ebp]
	mov	DWORD PTR $T6[ebp], eax
	mov	ecx, DWORD PTR $T6[ebp]
	mov	DWORD PTR $T5[ebp], ecx
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN37@Enumerate
	push	1
	mov	ecx, DWORD PTR $T5[ebp]
	call	??_GCD3DEnumAdapterInfo@@QAEPAXI@Z
	mov	DWORD PTR tv233[ebp], eax
	jmp	SHORT $LN38@Enumerate
$LN37@Enumerate:
	mov	DWORD PTR tv233[ebp], 0
$LN38@Enumerate:

; 148  :             continue;

	jmp	$LN29@Enumerate
$LN16@Enumerate:

; 149  :         }
; 150  : 
; 151  :         // If at least one device on this adapter is available and compatible
; 152  :         // with the app, add the adapterInfo to the list
; 153  :         if( pAdapterInfo->deviceInfoList.GetSize() > 0 )

	mov	ecx, DWORD PTR _pAdapterInfo$23[ebp]
	add	ecx, 1372				; 0000055cH
	call	?GetSize@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QBEHXZ ; CGrowableArray<CD3DEnumDeviceInfo *>::GetSize
	test	eax, eax
	jle	SHORT $LN15@Enumerate

; 154  :         {
; 155  :             hr = m_AdapterInfoList.Add( pAdapterInfo );

	lea	eax, DWORD PTR _pAdapterInfo$23[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 81					; 00000051H
	call	?Add@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAEJABQAVCD3DEnumAdapterInfo@@@Z ; CGrowableArray<CD3DEnumAdapterInfo *>::Add
	mov	DWORD PTR _hr$[ebp], eax

; 156  :             if( FAILED(hr) )

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN14@Enumerate

; 157  :                 return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _adapterFormatList$[ebp]
	call	??1?$CGrowableArray@W4_D3DFORMAT@@@@QAE@XZ ; CGrowableArray<enum _D3DFORMAT>::~CGrowableArray<enum _D3DFORMAT>
	mov	eax, DWORD PTR $T7[ebp]
	jmp	$LN33@Enumerate
$LN14@Enumerate:

; 158  :         } else

	jmp	SHORT $LN13@Enumerate
$LN15@Enumerate:

; 159  :             delete pAdapterInfo;

	mov	eax, DWORD PTR _pAdapterInfo$23[ebp]
	mov	DWORD PTR $T9[ebp], eax
	mov	ecx, DWORD PTR $T9[ebp]
	mov	DWORD PTR $T8[ebp], ecx
	cmp	DWORD PTR $T8[ebp], 0
	je	SHORT $LN39@Enumerate
	push	1
	mov	ecx, DWORD PTR $T8[ebp]
	call	??_GCD3DEnumAdapterInfo@@QAEPAXI@Z
	mov	DWORD PTR tv247[ebp], eax
	jmp	SHORT $LN13@Enumerate
$LN39@Enumerate:
	mov	DWORD PTR tv247[ebp], 0
$LN13@Enumerate:

; 160  :     }

	jmp	$LN29@Enumerate
$LN28@Enumerate:

; 161  : 
; 162  :     bool bUniqueDesc = true;

	mov	BYTE PTR _bUniqueDesc$[ebp], 1

; 163  :     CD3DEnumAdapterInfo* pAdapterInfo;
; 164  :     for( int i=0; i<m_AdapterInfoList.GetSize(); i++ )

	mov	DWORD PTR _i$16[ebp], 0
	jmp	SHORT $LN12@Enumerate
$LN11@Enumerate:
	mov	eax, DWORD PTR _i$16[ebp]
	add	eax, 1
	mov	DWORD PTR _i$16[ebp], eax
$LN12@Enumerate:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 81					; 00000051H
	call	?GetSize@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QBEHXZ ; CGrowableArray<CD3DEnumAdapterInfo *>::GetSize
	cmp	DWORD PTR _i$16[ebp], eax
	jge	$LN10@Enumerate

; 165  :     {
; 166  :         CD3DEnumAdapterInfo* pAdapterInfo1 = m_AdapterInfoList.GetAt(i);

	mov	eax, DWORD PTR _i$16[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 81					; 00000051H
	call	?GetAt@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAEAAPAVCD3DEnumAdapterInfo@@H@Z ; CGrowableArray<CD3DEnumAdapterInfo *>::GetAt
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pAdapterInfo1$15[ebp], ecx

; 167  : 
; 168  :         for( int j=i+1; j<m_AdapterInfoList.GetSize(); j++ )

	mov	eax, DWORD PTR _i$16[ebp]
	add	eax, 1
	mov	DWORD PTR _j$14[ebp], eax
	jmp	SHORT $LN9@Enumerate
$LN8@Enumerate:
	mov	eax, DWORD PTR _j$14[ebp]
	add	eax, 1
	mov	DWORD PTR _j$14[ebp], eax
$LN9@Enumerate:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 81					; 00000051H
	call	?GetSize@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QBEHXZ ; CGrowableArray<CD3DEnumAdapterInfo *>::GetSize
	cmp	DWORD PTR _j$14[ebp], eax
	jge	SHORT $LN7@Enumerate

; 169  :         {
; 170  :             CD3DEnumAdapterInfo* pAdapterInfo2 = m_AdapterInfoList.GetAt(j);

	mov	eax, DWORD PTR _j$14[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 81					; 00000051H
	call	?GetAt@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAEAAPAVCD3DEnumAdapterInfo@@H@Z ; CGrowableArray<CD3DEnumAdapterInfo *>::GetAt
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pAdapterInfo2$13[ebp], ecx

; 171  :             if( _stricmp( pAdapterInfo1->AdapterIdentifier.Description, 
; 172  :                           pAdapterInfo2->AdapterIdentifier.Description ) == 0 )

	mov	eax, DWORD PTR _pAdapterInfo2$13[ebp]
	add	eax, 516				; 00000204H
	push	eax
	mov	ecx, DWORD PTR _pAdapterInfo1$15[ebp]
	add	ecx, 516				; 00000204H
	push	ecx
	call	__stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN6@Enumerate

; 173  :             {
; 174  :                 bUniqueDesc = false;

	mov	BYTE PTR _bUniqueDesc$[ebp], 0

; 175  :                 break;

	jmp	SHORT $LN7@Enumerate
$LN6@Enumerate:

; 176  :             }
; 177  :         }

	jmp	SHORT $LN8@Enumerate
$LN7@Enumerate:

; 178  : 
; 179  :         if( !bUniqueDesc )

	movzx	eax, BYTE PTR _bUniqueDesc$[ebp]
	test	eax, eax
	jne	SHORT $LN5@Enumerate

; 180  :             break;

	jmp	SHORT $LN10@Enumerate
$LN5@Enumerate:

; 181  :     }

	jmp	$LN11@Enumerate
$LN10@Enumerate:

; 182  : 
; 183  :     for( int i=0; i<m_AdapterInfoList.GetSize(); i++ )

	mov	DWORD PTR _i$12[ebp], 0
	jmp	SHORT $LN4@Enumerate
$LN3@Enumerate:
	mov	eax, DWORD PTR _i$12[ebp]
	add	eax, 1
	mov	DWORD PTR _i$12[ebp], eax
$LN4@Enumerate:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 81					; 00000051H
	call	?GetSize@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QBEHXZ ; CGrowableArray<CD3DEnumAdapterInfo *>::GetSize
	cmp	DWORD PTR _i$12[ebp], eax
	jge	$LN2@Enumerate

; 184  :     {
; 185  :         pAdapterInfo = m_AdapterInfoList.GetAt(i);

	mov	eax, DWORD PTR _i$12[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 81					; 00000051H
	call	?GetAt@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAEAAPAVCD3DEnumAdapterInfo@@H@Z ; CGrowableArray<CD3DEnumAdapterInfo *>::GetAt
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pAdapterInfo$[ebp], ecx

; 186  : 
; 187  :         strcpy(pAdapterInfo->szUniqueDescription,pAdapterInfo->AdapterIdentifier.Description);

	mov	eax, DWORD PTR _pAdapterInfo$[ebp]
	add	eax, 516				; 00000204H
	push	eax
	mov	ecx, DWORD PTR _pAdapterInfo$[ebp]
	add	ecx, 1104				; 00000450H
	push	ecx
	call	_strcpy
	add	esp, 8

; 188  :         pAdapterInfo->szUniqueDescription[100] = 0;

	mov	eax, 1
	imul	ecx, eax, 100
	mov	edx, DWORD PTR _pAdapterInfo$[ebp]
	mov	BYTE PTR [edx+ecx+1104], 0

; 189  : 
; 190  :         if( !bUniqueDesc )

	movzx	eax, BYTE PTR _bUniqueDesc$[ebp]
	test	eax, eax
	jne	SHORT $LN1@Enumerate

; 191  :         {
; 192  :             TCHAR sz[100];
; 193  :             StringCchPrintf( sz, 100, " (#%d)", pAdapterInfo->AdapterOrdinal );

	mov	eax, DWORD PTR _pAdapterInfo$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_06FMMEGIIJ@?5?$CI?$CD?$CFd?$CJ?$AA@
	push	100					; 00000064H
	lea	edx, DWORD PTR _sz$11[ebp]
	push	edx
	call	?StringCchPrintfA@@YAJPADIPBDZZ		; StringCchPrintfA
	add	esp, 16					; 00000010H

; 194  :             StringCchCat( pAdapterInfo->szUniqueDescription, 256, sz );

	lea	eax, DWORD PTR _sz$11[ebp]
	push	eax
	push	256					; 00000100H
	mov	ecx, DWORD PTR _pAdapterInfo$[ebp]
	add	ecx, 1104				; 00000450H
	push	ecx
	call	?StringCchCatA@@YGJPADIPBD@Z		; StringCchCatA
$LN1@Enumerate:

; 195  : 
; 196  :         }
; 197  :     }

	jmp	$LN3@Enumerate
$LN2@Enumerate:

; 198  : 
; 199  :     return S_OK;

	mov	DWORD PTR $T10[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _adapterFormatList$[ebp]
	call	??1?$CGrowableArray@W4_D3DFORMAT@@@@QAE@XZ ; CGrowableArray<enum _D3DFORMAT>::~CGrowableArray<enum _D3DFORMAT>
	mov	eax, DWORD PTR $T10[ebp]
$LN33@Enumerate:

; 200  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN51@Enumerate
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 724				; 000002d4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	3
$LN51@Enumerate:
	DD	6
	DD	$LN50@Enumerate
$LN50@Enumerate:
	DD	-56					; ffffffc8H
	DD	12					; 0000000cH
	DD	$LN43@Enumerate
	DD	-80					; ffffffb0H
	DD	16					; 00000010H
	DD	$LN44@Enumerate
	DD	-128					; ffffff80H
	DD	4
	DD	$LN45@Enumerate
	DD	-200					; ffffff38H
	DD	16					; 00000010H
	DD	$LN46@Enumerate
	DD	-224					; ffffff20H
	DD	16					; 00000010H
	DD	$LN47@Enumerate
	DD	-416					; fffffe60H
	DD	100					; 00000064H
	DD	$LN48@Enumerate
$LN48@Enumerate:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	0
$LN47@Enumerate:
	DB	100					; 00000064H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	77					; 0000004dH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
$LN46@Enumerate:
	DB	100					; 00000064H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	77					; 0000004dH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
$LN45@Enumerate:
	DB	112					; 00000070H
	DB	65					; 00000041H
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	102					; 00000066H
	DB	111					; 0000006fH
	DB	0
$LN44@Enumerate:
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	119					; 00000077H
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	65					; 00000041H
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	70					; 00000046H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	65					; 00000041H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	0
$LN43@Enumerate:
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	70					; 00000046H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	76					; 0000004cH
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Enumerate@CD3DEnumeration@@QAEJPAUIDirect3D9@@P6G_NPAU_D3DCAPS9@@W4_D3DFORMAT@@2_NPAX@Z4@Z$0:
	lea	ecx, DWORD PTR _adapterFormatList$[ebp]
	jmp	??1?$CGrowableArray@W4_D3DFORMAT@@@@QAE@XZ ; CGrowableArray<enum _D3DFORMAT>::~CGrowableArray<enum _D3DFORMAT>
__unwindfunclet$?Enumerate@CD3DEnumeration@@QAEJPAUIDirect3D9@@P6G_NPAU_D3DCAPS9@@W4_D3DFORMAT@@2_NPAX@Z4@Z$1:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?Enumerate@CD3DEnumeration@@QAEJPAUIDirect3D9@@P6G_NPAU_D3DCAPS9@@W4_D3DFORMAT@@2_NPAX@Z4@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-728]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Enumerate@CD3DEnumeration@@QAEJPAUIDirect3D9@@P6G_NPAU_D3DCAPS9@@W4_D3DFORMAT@@2_NPAX@Z4@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Enumerate@CD3DEnumeration@@QAEJPAUIDirect3D9@@P6G_NPAU_D3DCAPS9@@W4_D3DFORMAT@@2_NPAX@Z4@Z ENDP ; CD3DEnumeration::Enumerate
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutenum.cpp
;	COMDAT ?ResetPossiblePresentIntervalList@CD3DEnumeration@@QAEXXZ
_TEXT	SEGMENT
$T1 = -272						; size = 4
$T2 = -260						; size = 4
$T3 = -248						; size = 4
$T4 = -236						; size = 4
$T5 = -224						; size = 4
$T6 = -212						; size = 4
_this$ = -8						; size = 4
?ResetPossiblePresentIntervalList@CD3DEnumeration@@QAEXXZ PROC ; CD3DEnumeration::ResetPossiblePresentIntervalList, COMDAT
; _this$ = ecx

; 834  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-276]
	mov	ecx, 69					; 00000045H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 835  :     m_PresentIntervalList.RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 37					; 00000025H
	call	?RemoveAll@?$CGrowableArray@I@@QAEXXZ	; CGrowableArray<unsigned int>::RemoveAll

; 836  :     m_PresentIntervalList.Add( D3DPRESENT_INTERVAL_IMMEDIATE );

	mov	DWORD PTR $T1[ebp], -2147483648		; 80000000H
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 37					; 00000025H
	call	?Add@?$CGrowableArray@I@@QAEJABI@Z	; CGrowableArray<unsigned int>::Add

; 837  :     m_PresentIntervalList.Add( D3DPRESENT_INTERVAL_DEFAULT );

	mov	DWORD PTR $T2[ebp], 0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 37					; 00000025H
	call	?Add@?$CGrowableArray@I@@QAEJABI@Z	; CGrowableArray<unsigned int>::Add

; 838  :     m_PresentIntervalList.Add( D3DPRESENT_INTERVAL_ONE );

	mov	DWORD PTR $T3[ebp], 1
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 37					; 00000025H
	call	?Add@?$CGrowableArray@I@@QAEJABI@Z	; CGrowableArray<unsigned int>::Add

; 839  :     m_PresentIntervalList.Add( D3DPRESENT_INTERVAL_TWO );

	mov	DWORD PTR $T4[ebp], 2
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 37					; 00000025H
	call	?Add@?$CGrowableArray@I@@QAEJABI@Z	; CGrowableArray<unsigned int>::Add

; 840  :     m_PresentIntervalList.Add( D3DPRESENT_INTERVAL_THREE );

	mov	DWORD PTR $T5[ebp], 4
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 37					; 00000025H
	call	?Add@?$CGrowableArray@I@@QAEJABI@Z	; CGrowableArray<unsigned int>::Add

; 841  :     m_PresentIntervalList.Add( D3DPRESENT_INTERVAL_FOUR );

	mov	DWORD PTR $T6[ebp], 8
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 37					; 00000025H
	call	?Add@?$CGrowableArray@I@@QAEJABI@Z	; CGrowableArray<unsigned int>::Add

; 842  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetPossiblePresentIntervalList@CD3DEnumeration@@QAEXXZ ENDP ; CD3DEnumeration::ResetPossiblePresentIntervalList
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutenum.cpp
;	COMDAT ?ResetPossibleMultisampleTypeList@CD3DEnumeration@@QAEXXZ
_TEXT	SEGMENT
$T1 = -404						; size = 4
$T2 = -392						; size = 4
$T3 = -380						; size = 4
$T4 = -368						; size = 4
$T5 = -356						; size = 4
$T6 = -344						; size = 4
$T7 = -332						; size = 4
$T8 = -320						; size = 4
$T9 = -308						; size = 4
$T10 = -296						; size = 4
$T11 = -284						; size = 4
$T12 = -272						; size = 4
$T13 = -260						; size = 4
$T14 = -248						; size = 4
$T15 = -236						; size = 4
$T16 = -224						; size = 4
$T17 = -212						; size = 4
_this$ = -8						; size = 4
?ResetPossibleMultisampleTypeList@CD3DEnumeration@@QAEXXZ PROC ; CD3DEnumeration::ResetPossibleMultisampleTypeList, COMDAT
; _this$ = ecx

; 783  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 408				; 00000198H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-408]
	mov	ecx, 102				; 00000066H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 784  :     m_MultiSampleTypeList.RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 25					; 00000019H
	call	?RemoveAll@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEXXZ ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::RemoveAll

; 785  :     m_MultiSampleTypeList.Add( D3DMULTISAMPLE_NONE );

	mov	DWORD PTR $T1[ebp], 0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 25					; 00000019H
	call	?Add@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEJABW4_D3DMULTISAMPLE_TYPE@@@Z ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::Add

; 786  :     m_MultiSampleTypeList.Add( D3DMULTISAMPLE_NONMASKABLE );

	mov	DWORD PTR $T2[ebp], 1
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 25					; 00000019H
	call	?Add@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEJABW4_D3DMULTISAMPLE_TYPE@@@Z ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::Add

; 787  :     m_MultiSampleTypeList.Add( D3DMULTISAMPLE_2_SAMPLES );

	mov	DWORD PTR $T3[ebp], 2
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 25					; 00000019H
	call	?Add@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEJABW4_D3DMULTISAMPLE_TYPE@@@Z ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::Add

; 788  :     m_MultiSampleTypeList.Add( D3DMULTISAMPLE_3_SAMPLES );

	mov	DWORD PTR $T4[ebp], 3
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 25					; 00000019H
	call	?Add@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEJABW4_D3DMULTISAMPLE_TYPE@@@Z ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::Add

; 789  :     m_MultiSampleTypeList.Add( D3DMULTISAMPLE_4_SAMPLES );

	mov	DWORD PTR $T5[ebp], 4
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 25					; 00000019H
	call	?Add@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEJABW4_D3DMULTISAMPLE_TYPE@@@Z ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::Add

; 790  :     m_MultiSampleTypeList.Add( D3DMULTISAMPLE_5_SAMPLES );

	mov	DWORD PTR $T6[ebp], 5
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 25					; 00000019H
	call	?Add@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEJABW4_D3DMULTISAMPLE_TYPE@@@Z ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::Add

; 791  :     m_MultiSampleTypeList.Add( D3DMULTISAMPLE_6_SAMPLES );

	mov	DWORD PTR $T7[ebp], 6
	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 25					; 00000019H
	call	?Add@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEJABW4_D3DMULTISAMPLE_TYPE@@@Z ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::Add

; 792  :     m_MultiSampleTypeList.Add( D3DMULTISAMPLE_7_SAMPLES );

	mov	DWORD PTR $T8[ebp], 7
	lea	eax, DWORD PTR $T8[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 25					; 00000019H
	call	?Add@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEJABW4_D3DMULTISAMPLE_TYPE@@@Z ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::Add

; 793  :     m_MultiSampleTypeList.Add( D3DMULTISAMPLE_8_SAMPLES );

	mov	DWORD PTR $T9[ebp], 8
	lea	eax, DWORD PTR $T9[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 25					; 00000019H
	call	?Add@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEJABW4_D3DMULTISAMPLE_TYPE@@@Z ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::Add

; 794  :     m_MultiSampleTypeList.Add( D3DMULTISAMPLE_9_SAMPLES );

	mov	DWORD PTR $T10[ebp], 9
	lea	eax, DWORD PTR $T10[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 25					; 00000019H
	call	?Add@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEJABW4_D3DMULTISAMPLE_TYPE@@@Z ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::Add

; 795  :     m_MultiSampleTypeList.Add( D3DMULTISAMPLE_10_SAMPLES );

	mov	DWORD PTR $T11[ebp], 10			; 0000000aH
	lea	eax, DWORD PTR $T11[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 25					; 00000019H
	call	?Add@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEJABW4_D3DMULTISAMPLE_TYPE@@@Z ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::Add

; 796  :     m_MultiSampleTypeList.Add( D3DMULTISAMPLE_11_SAMPLES );

	mov	DWORD PTR $T12[ebp], 11			; 0000000bH
	lea	eax, DWORD PTR $T12[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 25					; 00000019H
	call	?Add@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEJABW4_D3DMULTISAMPLE_TYPE@@@Z ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::Add

; 797  :     m_MultiSampleTypeList.Add( D3DMULTISAMPLE_12_SAMPLES );

	mov	DWORD PTR $T13[ebp], 12			; 0000000cH
	lea	eax, DWORD PTR $T13[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 25					; 00000019H
	call	?Add@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEJABW4_D3DMULTISAMPLE_TYPE@@@Z ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::Add

; 798  :     m_MultiSampleTypeList.Add( D3DMULTISAMPLE_13_SAMPLES );

	mov	DWORD PTR $T14[ebp], 13			; 0000000dH
	lea	eax, DWORD PTR $T14[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 25					; 00000019H
	call	?Add@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEJABW4_D3DMULTISAMPLE_TYPE@@@Z ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::Add

; 799  :     m_MultiSampleTypeList.Add( D3DMULTISAMPLE_14_SAMPLES );

	mov	DWORD PTR $T15[ebp], 14			; 0000000eH
	lea	eax, DWORD PTR $T15[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 25					; 00000019H
	call	?Add@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEJABW4_D3DMULTISAMPLE_TYPE@@@Z ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::Add

; 800  :     m_MultiSampleTypeList.Add( D3DMULTISAMPLE_15_SAMPLES );

	mov	DWORD PTR $T16[ebp], 15			; 0000000fH
	lea	eax, DWORD PTR $T16[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 25					; 00000019H
	call	?Add@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEJABW4_D3DMULTISAMPLE_TYPE@@@Z ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::Add

; 801  :     m_MultiSampleTypeList.Add( D3DMULTISAMPLE_16_SAMPLES );

	mov	DWORD PTR $T17[ebp], 16			; 00000010H
	lea	eax, DWORD PTR $T17[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 25					; 00000019H
	call	?Add@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEJABW4_D3DMULTISAMPLE_TYPE@@@Z ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::Add

; 802  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 408				; 00000198H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetPossibleMultisampleTypeList@CD3DEnumeration@@QAEXXZ ENDP ; CD3DEnumeration::ResetPossibleMultisampleTypeList
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutenum.cpp
;	COMDAT ?ResetPossibleDepthStencilFormats@CD3DEnumeration@@QAEXXZ
_TEXT	SEGMENT
$T1 = -272						; size = 4
$T2 = -260						; size = 4
$T3 = -248						; size = 4
$T4 = -236						; size = 4
$T5 = -224						; size = 4
$T6 = -212						; size = 4
_this$ = -8						; size = 4
?ResetPossibleDepthStencilFormats@CD3DEnumeration@@QAEXXZ PROC ; CD3DEnumeration::ResetPossibleDepthStencilFormats, COMDAT
; _this$ = ecx

; 756  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-276]
	mov	ecx, 69					; 00000045H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 757  :     m_DepthStecilPossibleList.RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 13					; 0000000dH
	call	?RemoveAll@?$CGrowableArray@W4_D3DFORMAT@@@@QAEXXZ ; CGrowableArray<enum _D3DFORMAT>::RemoveAll

; 758  :     m_DepthStecilPossibleList.Add( D3DFMT_D16 );

	mov	DWORD PTR $T1[ebp], 80			; 00000050H
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 13					; 0000000dH
	call	?Add@?$CGrowableArray@W4_D3DFORMAT@@@@QAEJABW4_D3DFORMAT@@@Z ; CGrowableArray<enum _D3DFORMAT>::Add

; 759  :     m_DepthStecilPossibleList.Add( D3DFMT_D15S1 );

	mov	DWORD PTR $T2[ebp], 73			; 00000049H
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 13					; 0000000dH
	call	?Add@?$CGrowableArray@W4_D3DFORMAT@@@@QAEJABW4_D3DFORMAT@@@Z ; CGrowableArray<enum _D3DFORMAT>::Add

; 760  :     m_DepthStecilPossibleList.Add( D3DFMT_D24X8 );

	mov	DWORD PTR $T3[ebp], 77			; 0000004dH
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 13					; 0000000dH
	call	?Add@?$CGrowableArray@W4_D3DFORMAT@@@@QAEJABW4_D3DFORMAT@@@Z ; CGrowableArray<enum _D3DFORMAT>::Add

; 761  :     m_DepthStecilPossibleList.Add( D3DFMT_D24S8 );

	mov	DWORD PTR $T4[ebp], 75			; 0000004bH
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 13					; 0000000dH
	call	?Add@?$CGrowableArray@W4_D3DFORMAT@@@@QAEJABW4_D3DFORMAT@@@Z ; CGrowableArray<enum _D3DFORMAT>::Add

; 762  :     m_DepthStecilPossibleList.Add( D3DFMT_D24X4S4 );

	mov	DWORD PTR $T5[ebp], 79			; 0000004fH
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 13					; 0000000dH
	call	?Add@?$CGrowableArray@W4_D3DFORMAT@@@@QAEJABW4_D3DFORMAT@@@Z ; CGrowableArray<enum _D3DFORMAT>::Add

; 763  :     m_DepthStecilPossibleList.Add( D3DFMT_D32 );

	mov	DWORD PTR $T6[ebp], 71			; 00000047H
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 13					; 0000000dH
	call	?Add@?$CGrowableArray@W4_D3DFORMAT@@@@QAEJABW4_D3DFORMAT@@@Z ; CGrowableArray<enum _D3DFORMAT>::Add

; 764  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetPossibleDepthStencilFormats@CD3DEnumeration@@QAEXXZ ENDP ; CD3DEnumeration::ResetPossibleDepthStencilFormats
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutenum.cpp
;	COMDAT ?GetPossiblePresentIntervalList@CD3DEnumeration@@QAEPAV?$CGrowableArray@I@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetPossiblePresentIntervalList@CD3DEnumeration@@QAEPAV?$CGrowableArray@I@@XZ PROC ; CD3DEnumeration::GetPossiblePresentIntervalList, COMDAT
; _this$ = ecx

; 827  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 828  :     return &m_PresentIntervalList;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 37					; 00000025H

; 829  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPossiblePresentIntervalList@CD3DEnumeration@@QAEPAV?$CGrowableArray@I@@XZ ENDP ; CD3DEnumeration::GetPossiblePresentIntervalList
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutenum.cpp
;	COMDAT ?GetPossibleMultisampleTypeList@CD3DEnumeration@@QAEPAV?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetPossibleMultisampleTypeList@CD3DEnumeration@@QAEPAV?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@XZ PROC ; CD3DEnumeration::GetPossibleMultisampleTypeList, COMDAT
; _this$ = ecx

; 776  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 777  :     return &m_MultiSampleTypeList;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 25					; 00000019H

; 778  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPossibleMultisampleTypeList@CD3DEnumeration@@QAEPAV?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@XZ ENDP ; CD3DEnumeration::GetPossibleMultisampleTypeList
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutenum.cpp
;	COMDAT ?GetPossibleDepthStencilFormatList@CD3DEnumeration@@QAEPAV?$CGrowableArray@W4_D3DFORMAT@@@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetPossibleDepthStencilFormatList@CD3DEnumeration@@QAEPAV?$CGrowableArray@W4_D3DFORMAT@@@@XZ PROC ; CD3DEnumeration::GetPossibleDepthStencilFormatList, COMDAT
; _this$ = ecx

; 769  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 770  :     return &m_DepthStecilPossibleList;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 13					; 0000000dH

; 771  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPossibleDepthStencilFormatList@CD3DEnumeration@@QAEPAV?$CGrowableArray@W4_D3DFORMAT@@@@XZ ENDP ; CD3DEnumeration::GetPossibleDepthStencilFormatList
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutenum.cpp
;	COMDAT ?SetPossibleVertexProcessingList@CD3DEnumeration@@QAEX_N000@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_bSoftwareVP$ = 8					; size = 1
_bHardwareVP$ = 12					; size = 1
_bPureHarewareVP$ = 16					; size = 1
_bMixedVP$ = 20						; size = 1
?SetPossibleVertexProcessingList@CD3DEnumeration@@QAEX_N000@Z PROC ; CD3DEnumeration::SetPossibleVertexProcessingList, COMDAT
; _this$ = ecx

; 817  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 818  :     m_bSoftwareVP = bSoftwareVP;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _bSoftwareVP$[ebp]
	mov	BYTE PTR [eax+49], cl

; 819  :     m_bHardwareVP = bHardwareVP;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _bHardwareVP$[ebp]
	mov	BYTE PTR [eax+50], cl

; 820  :     m_bPureHarewareVP = bPureHarewareVP;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _bPureHarewareVP$[ebp]
	mov	BYTE PTR [eax+51], cl

; 821  :     m_bMixedVP = bMixedVP;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _bMixedVP$[ebp]
	mov	BYTE PTR [eax+52], cl

; 822  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?SetPossibleVertexProcessingList@CD3DEnumeration@@QAEX_N000@Z ENDP ; CD3DEnumeration::SetPossibleVertexProcessingList
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutenum.cpp
;	COMDAT ?GetPossibleVertexProcessingList@CD3DEnumeration@@QAEXPA_N000@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pbSoftwareVP$ = 8					; size = 4
_pbHardwareVP$ = 12					; size = 4
_pbPureHarewareVP$ = 16					; size = 4
_pbMixedVP$ = 20					; size = 4
?GetPossibleVertexProcessingList@CD3DEnumeration@@QAEXPA_N000@Z PROC ; CD3DEnumeration::GetPossibleVertexProcessingList, COMDAT
; _this$ = ecx

; 807  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 808  :     *pbSoftwareVP = m_bSoftwareVP;

	mov	eax, DWORD PTR _pbSoftwareVP$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+49]
	mov	BYTE PTR [eax], dl

; 809  :     *pbHardwareVP = m_bHardwareVP;

	mov	eax, DWORD PTR _pbHardwareVP$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+50]
	mov	BYTE PTR [eax], dl

; 810  :     *pbPureHarewareVP = m_bPureHarewareVP;

	mov	eax, DWORD PTR _pbPureHarewareVP$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+51]
	mov	BYTE PTR [eax], dl

; 811  :     *pbMixedVP = m_bMixedVP;

	mov	eax, DWORD PTR _pbMixedVP$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+52]
	mov	BYTE PTR [eax], dl

; 812  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?GetPossibleVertexProcessingList@CD3DEnumeration@@QAEXPA_N000@Z ENDP ; CD3DEnumeration::GetPossibleVertexProcessingList
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutenum.cpp
;	COMDAT ?SetMultisampleQualityMax@CD3DEnumeration@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nMax$ = 8						; size = 4
?SetMultisampleQualityMax@CD3DEnumeration@@QAEXI@Z PROC	; CD3DEnumeration::SetMultisampleQualityMax, COMDAT
; _this$ = ecx

; 866  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 867  :     if( nMax > 0xFFFF )

	cmp	DWORD PTR _nMax$[ebp], 65535		; 0000ffffH
	jbe	SHORT $LN1@SetMultisa

; 868  :         nMax = 0xFFFF;

	mov	DWORD PTR _nMax$[ebp], 65535		; 0000ffffH
$LN1@SetMultisa:

; 869  :     m_nMultisampleQualityMax = nMax;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nMax$[ebp]
	mov	DWORD PTR [eax+77], ecx

; 870  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetMultisampleQualityMax@CD3DEnumeration@@QAEXI@Z ENDP	; CD3DEnumeration::SetMultisampleQualityMax
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutenum.cpp
;	COMDAT ?SetRefreshMinMax@CD3DEnumeration@@QAEXII@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nMin$ = 8						; size = 4
_nMax$ = 12						; size = 4
?SetRefreshMinMax@CD3DEnumeration@@QAEXII@Z PROC	; CD3DEnumeration::SetRefreshMinMax, COMDAT
; _this$ = ecx

; 858  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 859  :     m_nRefreshMin = nMin;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nMin$[ebp]
	mov	DWORD PTR [eax+69], ecx

; 860  :     m_nRefreshMax = nMax;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nMax$[ebp]
	mov	DWORD PTR [eax+73], ecx

; 861  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetRefreshMinMax@CD3DEnumeration@@QAEXII@Z ENDP	; CD3DEnumeration::SetRefreshMinMax
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutenum.cpp
;	COMDAT ?SetResolutionMinMax@CD3DEnumeration@@QAEXIIII@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nMinWidth$ = 8						; size = 4
_nMinHeight$ = 12					; size = 4
_nMaxWidth$ = 16					; size = 4
_nMaxHeight$ = 20					; size = 4
?SetResolutionMinMax@CD3DEnumeration@@QAEXIIII@Z PROC	; CD3DEnumeration::SetResolutionMinMax, COMDAT
; _this$ = ecx

; 848  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 849  :     m_nMinWidth = nMinWidth;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nMinWidth$[ebp]
	mov	DWORD PTR [eax+53], ecx

; 850  :     m_nMinHeight = nMinHeight;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nMinHeight$[ebp]
	mov	DWORD PTR [eax+61], ecx

; 851  :     m_nMaxWidth = nMaxWidth;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nMaxWidth$[ebp]
	mov	DWORD PTR [eax+57], ecx

; 852  :     m_nMaxHeight = nMaxHeight;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nMaxHeight$[ebp]
	mov	DWORD PTR [eax+65], ecx

; 853  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?SetResolutionMinMax@CD3DEnumeration@@QAEXIIII@Z ENDP	; CD3DEnumeration::SetResolutionMinMax
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\include\strsafe.h
;	COMDAT ?StringCchPrintfA@@YAJPADIPBDZZ
_TEXT	SEGMENT
_argList$1 = -20					; size = 4
_hr$ = -8						; size = 4
_pszDest$ = 8						; size = 4
_cchDest$ = 12						; size = 4
_pszFormat$ = 16					; size = 4
?StringCchPrintfA@@YAJPADIPBDZZ PROC			; StringCchPrintfA, COMDAT

; 2678 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2679 :     HRESULT hr;
; 2680 : 
; 2681 :     if (cchDest > STRSAFE_MAX_CCH)

	cmp	DWORD PTR _cchDest$[ebp], 2147483647	; 7fffffffH
	jbe	SHORT $LN2@StringCchP

; 2682 :     {
; 2683 :         hr = STRSAFE_E_INVALID_PARAMETER;

	mov	DWORD PTR _hr$[ebp], -2147024809	; 80070057H

; 2684 :     }
; 2685 :     else

	jmp	SHORT $LN1@StringCchP
$LN2@StringCchP:

; 2686 :     {
; 2687 :         va_list argList;
; 2688 : 
; 2689 :         va_start(argList, pszFormat);

	lea	eax, DWORD PTR _pszFormat$[ebp+4]
	mov	DWORD PTR _argList$1[ebp], eax

; 2690 : 
; 2691 :         hr = StringVPrintfWorkerA(pszDest, cchDest, pszFormat, argList);

	mov	eax, DWORD PTR _argList$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszFormat$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cchDest$[ebp]
	push	edx
	mov	eax, DWORD PTR _pszDest$[ebp]
	push	eax
	call	?StringVPrintfWorkerA@@YGJPADIPBD0@Z	; StringVPrintfWorkerA
	mov	DWORD PTR _hr$[ebp], eax

; 2692 : 
; 2693 :         va_end(argList);

	mov	DWORD PTR _argList$1[ebp], 0
$LN1@StringCchP:

; 2694 :     }
; 2695 : 
; 2696 :     return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 2697 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?StringCchPrintfA@@YAJPADIPBDZZ ENDP			; StringCchPrintfA
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\include\strsafe.h
;	COMDAT ?StringCchCatA@@YGJPADIPBD@Z
_TEXT	SEGMENT
_hr$ = -8						; size = 4
_pszDest$ = 8						; size = 4
_cchDest$ = 12						; size = 4
_pszSrc$ = 16						; size = 4
?StringCchCatA@@YGJPADIPBD@Z PROC			; StringCchCatA, COMDAT

; 1347 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1348 :     HRESULT hr;
; 1349 : 
; 1350 :     if (cchDest > STRSAFE_MAX_CCH)

	cmp	DWORD PTR _cchDest$[ebp], 2147483647	; 7fffffffH
	jbe	SHORT $LN2@StringCchC

; 1351 :     {
; 1352 :         hr = STRSAFE_E_INVALID_PARAMETER;

	mov	DWORD PTR _hr$[ebp], -2147024809	; 80070057H

; 1353 :     }
; 1354 :     else

	jmp	SHORT $LN1@StringCchC
$LN2@StringCchC:

; 1355 :     {
; 1356 :         hr = StringCatWorkerA(pszDest, cchDest, pszSrc);

	mov	eax, DWORD PTR _pszSrc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cchDest$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszDest$[ebp]
	push	edx
	call	?StringCatWorkerA@@YGJPADIPBD@Z		; StringCatWorkerA
	mov	DWORD PTR _hr$[ebp], eax
$LN1@StringCchC:

; 1357 :     }
; 1358 : 
; 1359 :     return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 1360 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?StringCchCatA@@YGJPADIPBD@Z ENDP			; StringCchCatA
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\include\strsafe.h
;	COMDAT ?StringLengthWorkerA@@YGJPBDIPAI@Z
_TEXT	SEGMENT
_cchMaxPrev$ = -20					; size = 4
_hr$ = -8						; size = 4
_psz$ = 8						; size = 4
_cchMax$ = 12						; size = 4
_pcch$ = 16						; size = 4
?StringLengthWorkerA@@YGJPBDIPAI@Z PROC			; StringLengthWorkerA, COMDAT

; 5963 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5964 :     HRESULT hr = S_OK;

	mov	DWORD PTR _hr$[ebp], 0

; 5965 :     size_t cchMaxPrev = cchMax;

	mov	eax, DWORD PTR _cchMax$[ebp]
	mov	DWORD PTR _cchMaxPrev$[ebp], eax
$LN4@StringLeng:

; 5966 : 
; 5967 :     while (cchMax && (*psz != '\0'))

	cmp	DWORD PTR _cchMax$[ebp], 0
	je	SHORT $LN3@StringLeng
	mov	eax, DWORD PTR _psz$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@StringLeng

; 5968 :     {
; 5969 :         psz++;

	mov	eax, DWORD PTR _psz$[ebp]
	add	eax, 1
	mov	DWORD PTR _psz$[ebp], eax

; 5970 :         cchMax--;

	mov	eax, DWORD PTR _cchMax$[ebp]
	sub	eax, 1
	mov	DWORD PTR _cchMax$[ebp], eax

; 5971 :     }

	jmp	SHORT $LN4@StringLeng
$LN3@StringLeng:

; 5972 : 
; 5973 :     if (cchMax == 0)

	cmp	DWORD PTR _cchMax$[ebp], 0
	jne	SHORT $LN2@StringLeng

; 5974 :     {
; 5975 :         // the string is longer than cchMax
; 5976 :         hr = STRSAFE_E_INVALID_PARAMETER;

	mov	DWORD PTR _hr$[ebp], -2147024809	; 80070057H
$LN2@StringLeng:

; 5977 :     }
; 5978 : 
; 5979 :     if (SUCCEEDED(hr) && pcch)

	cmp	DWORD PTR _hr$[ebp], 0
	jl	SHORT $LN1@StringLeng
	cmp	DWORD PTR _pcch$[ebp], 0
	je	SHORT $LN1@StringLeng

; 5980 :     {
; 5981 :         *pcch = cchMaxPrev - cchMax;

	mov	eax, DWORD PTR _cchMaxPrev$[ebp]
	sub	eax, DWORD PTR _cchMax$[ebp]
	mov	ecx, DWORD PTR _pcch$[ebp]
	mov	DWORD PTR [ecx], eax
$LN1@StringLeng:

; 5982 :     }
; 5983 : 
; 5984 :     return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 5985 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?StringLengthWorkerA@@YGJPBDIPAI@Z ENDP			; StringLengthWorkerA
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\include\strsafe.h
;	COMDAT ?StringVPrintfWorkerA@@YGJPADIPBD0@Z
_TEXT	SEGMENT
_cchMax$1 = -32						; size = 4
_iRet$2 = -20						; size = 4
_hr$ = -8						; size = 4
_pszDest$ = 8						; size = 4
_cchDest$ = 12						; size = 4
_pszFormat$ = 16					; size = 4
_argList$ = 20						; size = 4
?StringVPrintfWorkerA@@YGJPADIPBD0@Z PROC		; StringVPrintfWorkerA, COMDAT

; 5579 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5580 :     HRESULT hr = S_OK;

	mov	DWORD PTR _hr$[ebp], 0

; 5581 : 
; 5582 :     if (cchDest == 0)

	cmp	DWORD PTR _cchDest$[ebp], 0
	jne	SHORT $LN6@StringVPri

; 5583 :     {
; 5584 :         // can not null terminate a zero-byte dest buffer
; 5585 :         hr = STRSAFE_E_INVALID_PARAMETER;

	mov	DWORD PTR _hr$[ebp], -2147024809	; 80070057H

; 5586 :     }
; 5587 :     else

	jmp	SHORT $LN5@StringVPri
$LN6@StringVPri:

; 5588 :     {
; 5589 :         int iRet;
; 5590 :         size_t cchMax;
; 5591 : 
; 5592 :         // leave the last space for the null terminator
; 5593 :         cchMax = cchDest - 1;

	mov	eax, DWORD PTR _cchDest$[ebp]
	sub	eax, 1
	mov	DWORD PTR _cchMax$1[ebp], eax

; 5594 : 
; 5595 :         iRet = _vsnprintf(pszDest, cchMax, pszFormat, argList);

	mov	eax, DWORD PTR _argList$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszFormat$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cchMax$1[ebp]
	push	edx
	mov	eax, DWORD PTR _pszDest$[ebp]
	push	eax
	call	__vsnprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iRet$2[ebp], eax

; 5596 :         // ASSERT((iRet < 0) || (((size_t)iRet) <= cchMax));
; 5597 : 
; 5598 :         if ((iRet < 0) || (((size_t)iRet) > cchMax))

	cmp	DWORD PTR _iRet$2[ebp], 0
	jl	SHORT $LN3@StringVPri
	mov	eax, DWORD PTR _iRet$2[ebp]
	cmp	eax, DWORD PTR _cchMax$1[ebp]
	jbe	SHORT $LN4@StringVPri
$LN3@StringVPri:

; 5599 :         {
; 5600 :             // need to null terminate the string
; 5601 :             pszDest += cchMax;

	mov	eax, DWORD PTR _pszDest$[ebp]
	add	eax, DWORD PTR _cchMax$1[ebp]
	mov	DWORD PTR _pszDest$[ebp], eax

; 5602 :             *pszDest = '\0';

	mov	eax, DWORD PTR _pszDest$[ebp]
	mov	BYTE PTR [eax], 0

; 5603 : 
; 5604 :             // we have truncated pszDest
; 5605 :             hr = STRSAFE_E_INSUFFICIENT_BUFFER;

	mov	DWORD PTR _hr$[ebp], -2147024774	; 8007007aH
	jmp	SHORT $LN5@StringVPri
$LN4@StringVPri:

; 5606 :         }
; 5607 :         else if (((size_t)iRet) == cchMax)

	mov	eax, DWORD PTR _iRet$2[ebp]
	cmp	eax, DWORD PTR _cchMax$1[ebp]
	jne	SHORT $LN5@StringVPri

; 5608 :         {
; 5609 :             // need to null terminate the string
; 5610 :             pszDest += cchMax;

	mov	eax, DWORD PTR _pszDest$[ebp]
	add	eax, DWORD PTR _cchMax$1[ebp]
	mov	DWORD PTR _pszDest$[ebp], eax

; 5611 :             *pszDest = '\0';

	mov	eax, DWORD PTR _pszDest$[ebp]
	mov	BYTE PTR [eax], 0
$LN5@StringVPri:

; 5612 :         }
; 5613 :     }
; 5614 : 
; 5615 :     return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 5616 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?StringVPrintfWorkerA@@YGJPADIPBD0@Z ENDP		; StringVPrintfWorkerA
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\include\strsafe.h
;	COMDAT ?StringCatWorkerA@@YGJPADIPBD@Z
_TEXT	SEGMENT
_cchDestCurrent$ = -20					; size = 4
_hr$ = -8						; size = 4
_pszDest$ = 8						; size = 4
_cchDest$ = 12						; size = 4
_pszSrc$ = 16						; size = 4
?StringCatWorkerA@@YGJPADIPBD@Z PROC			; StringCatWorkerA, COMDAT

; 4923 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4924 :    HRESULT hr;
; 4925 :    size_t cchDestCurrent;
; 4926 : 
; 4927 :    hr = StringLengthWorkerA(pszDest, cchDest, &cchDestCurrent);

	lea	eax, DWORD PTR _cchDestCurrent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cchDest$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszDest$[ebp]
	push	edx
	call	?StringLengthWorkerA@@YGJPBDIPAI@Z	; StringLengthWorkerA
	mov	DWORD PTR _hr$[ebp], eax

; 4928 : 
; 4929 :    if (SUCCEEDED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jl	SHORT $LN1@StringCatW

; 4930 :    {
; 4931 :        hr = StringCopyWorkerA(pszDest + cchDestCurrent,
; 4932 :                               cchDest - cchDestCurrent,
; 4933 :                               pszSrc);

	mov	eax, DWORD PTR _pszSrc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cchDest$[ebp]
	sub	ecx, DWORD PTR _cchDestCurrent$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszDest$[ebp]
	add	edx, DWORD PTR _cchDestCurrent$[ebp]
	push	edx
	call	?StringCopyWorkerA@@YGJPADIPBD@Z	; StringCopyWorkerA
	mov	DWORD PTR _hr$[ebp], eax
$LN1@StringCatW:

; 4934 :    }
; 4935 : 
; 4936 :    return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 4937 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@StringCatW
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN6@StringCatW:
	DD	1
	DD	$LN5@StringCatW
$LN5@StringCatW:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN4@StringCatW
$LN4@StringCatW:
	DB	99					; 00000063H
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	68					; 00000044H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	67					; 00000043H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
?StringCatWorkerA@@YGJPADIPBD@Z ENDP			; StringCatWorkerA
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\include\strsafe.h
;	COMDAT ?StringCopyWorkerA@@YGJPADIPBD@Z
_TEXT	SEGMENT
_hr$ = -8						; size = 4
_pszDest$ = 8						; size = 4
_cchDest$ = 12						; size = 4
_pszSrc$ = 16						; size = 4
?StringCopyWorkerA@@YGJPADIPBD@Z PROC			; StringCopyWorkerA, COMDAT

; 4247 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4248 :     HRESULT hr = S_OK;

	mov	DWORD PTR _hr$[ebp], 0

; 4249 : 
; 4250 :     if (cchDest == 0)

	cmp	DWORD PTR _cchDest$[ebp], 0
	jne	SHORT $LN3@StringCopy

; 4251 :     {
; 4252 :         // can not null terminate a zero-byte dest buffer
; 4253 :         hr = STRSAFE_E_INVALID_PARAMETER;

	mov	DWORD PTR _hr$[ebp], -2147024809	; 80070057H

; 4254 :     }
; 4255 :     else

	jmp	SHORT $LN4@StringCopy
$LN3@StringCopy:

; 4256 :     {
; 4257 :         while (cchDest && (*pszSrc != '\0'))

	cmp	DWORD PTR _cchDest$[ebp], 0
	je	SHORT $LN2@StringCopy
	mov	eax, DWORD PTR _pszSrc$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN2@StringCopy

; 4258 :         {
; 4259 :             *pszDest++ = *pszSrc++;

	mov	eax, DWORD PTR _pszDest$[ebp]
	mov	ecx, DWORD PTR _pszSrc$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _pszDest$[ebp]
	add	eax, 1
	mov	DWORD PTR _pszDest$[ebp], eax
	mov	ecx, DWORD PTR _pszSrc$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pszSrc$[ebp], ecx

; 4260 :             cchDest--;

	mov	eax, DWORD PTR _cchDest$[ebp]
	sub	eax, 1
	mov	DWORD PTR _cchDest$[ebp], eax

; 4261 :         }

	jmp	SHORT $LN3@StringCopy
$LN2@StringCopy:

; 4262 : 
; 4263 :         if (cchDest == 0)

	cmp	DWORD PTR _cchDest$[ebp], 0
	jne	SHORT $LN1@StringCopy

; 4264 :         {
; 4265 :             // we are going to truncate pszDest
; 4266 :             pszDest--;

	mov	eax, DWORD PTR _pszDest$[ebp]
	sub	eax, 1
	mov	DWORD PTR _pszDest$[ebp], eax

; 4267 :             hr = STRSAFE_E_INSUFFICIENT_BUFFER;

	mov	DWORD PTR _hr$[ebp], -2147024774	; 8007007aH
$LN1@StringCopy:

; 4268 :         }
; 4269 : 
; 4270 :         *pszDest= '\0';

	mov	eax, DWORD PTR _pszDest$[ebp]
	mov	BYTE PTR [eax], 0
$LN4@StringCopy:

; 4271 :     }
; 4272 : 
; 4273 :     return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 4274 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?StringCopyWorkerA@@YGJPADIPBD@Z ENDP			; StringCopyWorkerA
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\program files (x86)\microsoft visual studio 12.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 103  :         {return (_Where); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR __Where$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
END
