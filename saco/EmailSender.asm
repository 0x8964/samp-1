; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.31101.0 

	TITLE	Z:\sampsrc\02Xu1\raknet\EmailSender.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
_UNASSIGNED_PLAYER_ID DD 0ffffffffH
	DW	0ffffH
CONST	ENDS
PUBLIC	??4PlayerID@@QAEAAU0@ABU0@@Z			; PlayerID::operator=
PUBLIC	?Send@EmailSender@@QAEPADPBDG000000PAVFileList@@_N@Z ; EmailSender::Send
PUBLIC	?Base64Encoding@EmailSender@@QAEHPBDHPAD0@Z	; EmailSender::Base64Encoding
PUBLIC	?GetResponse@EmailSender@@IAEPADPAVTCPInterface@@ABUPlayerID@@_N@Z ; EmailSender::GetResponse
PUBLIC	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
PUBLIC	?Size@?$List@UFileListNode@@@DataStructures@@QBEIXZ ; DataStructures::List<FileListNode>::Size
PUBLIC	??_C@_0BL@JFJLFONC@Unknown?5error?5starting?5TCP?$AA@ ; `string'
PUBLIC	??_C@_0BK@HBOBHECK@Failed?5to?5connect?5to?5host?$AA@ ; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	??_C@_0DE@IJKMDCLC@Timeout?5while?5waiting?5for?5initia@ ; `string'
PUBLIC	??_C@_06OGKBAGLK@HELO?$AN?6?$AA@		; `string'
PUBLIC	??_C@_0BC@KOBLNCCF@MAIL?5From?3?5?$DM?$CFs?$DO?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BA@BOEBHIHF@MAIL?5From?3?5?$DM?$DO?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BA@PAJOOKEN@RCPT?5TO?3?5?$DM?$CFs?$DO?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0O@BIJBNMK@RCPT?5TO?3?5?$DM?$DO?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_06KNPIFKI@DATA?$AN?6?$AA@			; `string'
PUBLIC	??_C@_0O@FHPOFNAI@Subject?3?5?$CFs?$AN?6?$AA@	; `string'
PUBLIC	??_C@_0L@BJCOBIPA@From?3?5?$CFs?$AN?6?$AA@	; `string'
PUBLIC	??_C@_08LGKAGCMJ@To?3?5?$CFs?$AN?6?$AA@		; `string'
PUBLIC	??_C@_0EB@NFPJKBDG@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef@ ; `string'
PUBLIC	??_C@_0BE@EMHINEHA@MIME?9version?3?51?40?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0DB@ECCABOFN@Content?9type?3?5multipart?1mixed?$DL?5B@ ; `string'
PUBLIC	??_C@_0DH@NEAHFABD@This?5is?5a?5multi?9part?5message?5in?5@ ; `string'
PUBLIC	??_C@_0DB@FKLLMGFB@Content?9Type?3?5text?1plain?$DL?5charse@ ; `string'
PUBLIC	??_C@_08OOLNIKKF@?$AN?6?9?9?$CFs?$AN?6?$AA@	; `string'
PUBLIC	??_C@_0IB@POOHHMMF@Content?9Type?3?5APPLICATION?1Octet?9@ ; `string'
PUBLIC	??_C@_0L@NAAOAPHF@?$AN?6?9?9?$CFs?9?9?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_05KMJPGPH@?$AN?6?4?$AN?6?$AA@		; `string'
PUBLIC	??_C@_06FIMJICNC@QUIT?$AN?6?$AA@		; `string'
PUBLIC	??_C@_0BL@HOIDLJBI@Connection?5to?5server?5lost?4?$AA@ ; `string'
PUBLIC	??_C@_03HJHPABEB@250?$AA@			; `string'
PUBLIC	??_C@_03KFKPKDCA@354?$AA@			; `string'
PUBLIC	??_C@_03OEKIDJPI@550?$AA@			; `string'
PUBLIC	??_C@_0BJ@JKOAHELK@Failed?5on?5error?5code?5550?$AA@ ; `string'
PUBLIC	??_C@_03MPIFGKDL@553?$AA@			; `string'
PUBLIC	??_C@_0BJ@LBMNCHHJ@Failed?5on?5error?5code?5553?$AA@ ; `string'
PUBLIC	??_C@_09OGKCMDDI@Timed?5out?$AA@		; `string'
PUBLIC	??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@ ; `string'
PUBLIC	??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ ; `string'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	___report_rangecheckfailure:PROC
EXTRN	??8PlayerID@@QBE_NABU0@@Z:PROC			; PlayerID::operator==
EXTRN	_strlen:PROC
EXTRN	_strstr:PROC
EXTRN	__wassert:PROC
EXTRN	??0TCPInterface@@QAE@XZ:PROC			; TCPInterface::TCPInterface
EXTRN	??1TCPInterface@@QAE@XZ:PROC			; TCPInterface::~TCPInterface
EXTRN	?Start@TCPInterface@@QAE_NGG@Z:PROC		; TCPInterface::Start
EXTRN	?Stop@TCPInterface@@QAEXXZ:PROC			; TCPInterface::Stop
EXTRN	?Connect@TCPInterface@@QAE?AUPlayerID@@PBDG@Z:PROC ; TCPInterface::Connect
EXTRN	?Send@TCPInterface@@QAEXPBDIUPlayerID@@@Z:PROC	; TCPInterface::Send
EXTRN	?Receive@TCPInterface@@QAEPAUPacket@@XZ:PROC	; TCPInterface::Receive
EXTRN	?HasLostConnection@TCPInterface@@QAE?AUPlayerID@@XZ:PROC ; TCPInterface::HasLostConnection
EXTRN	?GetTime@RakNet@@YAIXZ:PROC			; RakNet::GetTime
EXTRN	?seedMT@@YAXI@Z:PROC				; seedMT
EXTRN	?randomMT@@YAIXZ:PROC				; randomMT
EXTRN	_printf:PROC
EXTRN	_sprintf:PROC
EXTRN	?RakSleep@@YAXI@Z:PROC				; RakSleep
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ DB 'p'
	DB	00H, 'o', 00H, 's', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'o', 00H
	DB	'n', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'l', 00H, 'i', 00H, 's'
	DB	00H, 't', 00H, '_', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
CONST	SEGMENT
??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@ DB 'z'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H
	DB	's', 00H, 'r', 00H, 'c', 00H, '\', 00H, '0', 00H, '2', 00H, 'x'
	DB	00H, 'u', 00H, '1', 00H, '\', 00H, 'r', 00H, 'a', 00H, 'k', 00H
	DB	'n', 00H, 'e', 00H, 't', 00H, '\', 00H, 'd', 00H, 's', 00H, '_'
	DB	00H, 'l', 00H, 'i', 00H, 's', 00H, 't', 00H, '.', 00H, 'h', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_09OGKCMDDI@Timed?5out?$AA@
CONST	SEGMENT
??_C@_09OGKCMDDI@Timed?5out?$AA@ DB 'Timed out', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@LBMNCHHJ@Failed?5on?5error?5code?5553?$AA@
CONST	SEGMENT
??_C@_0BJ@LBMNCHHJ@Failed?5on?5error?5code?5553?$AA@ DB 'Failed on error '
	DB	'code 553', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03MPIFGKDL@553?$AA@
CONST	SEGMENT
??_C@_03MPIFGKDL@553?$AA@ DB '553', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@JKOAHELK@Failed?5on?5error?5code?5550?$AA@
CONST	SEGMENT
??_C@_0BJ@JKOAHELK@Failed?5on?5error?5code?5550?$AA@ DB 'Failed on error '
	DB	'code 550', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03OEKIDJPI@550?$AA@
CONST	SEGMENT
??_C@_03OEKIDJPI@550?$AA@ DB '550', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KFKPKDCA@354?$AA@
CONST	SEGMENT
??_C@_03KFKPKDCA@354?$AA@ DB '354', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HJHPABEB@250?$AA@
CONST	SEGMENT
??_C@_03HJHPABEB@250?$AA@ DB '250', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@HOIDLJBI@Connection?5to?5server?5lost?4?$AA@
CONST	SEGMENT
??_C@_0BL@HOIDLJBI@Connection?5to?5server?5lost?4?$AA@ DB 'Connection to '
	DB	'server lost.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06FIMJICNC@QUIT?$AN?6?$AA@
CONST	SEGMENT
??_C@_06FIMJICNC@QUIT?$AN?6?$AA@ DB 'QUIT', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05KMJPGPH@?$AN?6?4?$AN?6?$AA@
CONST	SEGMENT
??_C@_05KMJPGPH@?$AN?6?4?$AN?6?$AA@ DB 0dH, 0aH, '.', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NAAOAPHF@?$AN?6?9?9?$CFs?9?9?$AN?6?$AA@
CONST	SEGMENT
??_C@_0L@NAAOAPHF@?$AN?6?9?9?$CFs?9?9?$AN?6?$AA@ DB 0dH, 0aH, '--%s--', 0dH
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0IB@POOHHMMF@Content?9Type?3?5APPLICATION?1Octet?9@
CONST	SEGMENT
??_C@_0IB@POOHHMMF@Content?9Type?3?5APPLICATION?1Octet?9@ DB 'Content-Typ'
	DB	'e: APPLICATION/Octet-Stream; SizeOnDisk=%i; name="%s"', 0dH, 0aH
	DB	'Content-Transfer-Encoding: BASE64', 0dH, 0aH, 'Content-Descri'
	DB	'ption: %s', 0dH, 0aH, 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08OOLNIKKF@?$AN?6?9?9?$CFs?$AN?6?$AA@
CONST	SEGMENT
??_C@_08OOLNIKKF@?$AN?6?9?9?$CFs?$AN?6?$AA@ DB 0dH, 0aH, '--%s', 0dH, 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@FKLLMGFB@Content?9Type?3?5text?1plain?$DL?5charse@
CONST	SEGMENT
??_C@_0DB@FKLLMGFB@Content?9Type?3?5text?1plain?$DL?5charse@ DB 'Content-'
	DB	'Type: text/plain; charset="US-ASCII"', 0dH, 0aH, 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@NEAHFABD@This?5is?5a?5multi?9part?5message?5in?5@
CONST	SEGMENT
??_C@_0DH@NEAHFABD@This?5is?5a?5multi?9part?5message?5in?5@ DB 'This is a'
	DB	' multi-part message in MIME format.', 0dH, 0aH, 0dH, 0aH, '--'
	DB	'%s', 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@ECCABOFN@Content?9type?3?5multipart?1mixed?$DL?5B@
CONST	SEGMENT
??_C@_0DB@ECCABOFN@Content?9type?3?5multipart?1mixed?$DL?5B@ DB 'Content-'
	DB	'type: multipart/mixed; BOUNDARY="%s"', 0dH, 0aH, 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMHINEHA@MIME?9version?3?51?40?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BE@EMHINEHA@MIME?9version?3?51?40?$AN?6?$AA@ DB 'MIME-version: 1.0'
	DB	0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@NFPJKBDG@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef@
CONST	SEGMENT
??_C@_0EB@NFPJKBDG@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef@ DB 'ABCDEFGHIJKLMNOP'
	DB	'QRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08LGKAGCMJ@To?3?5?$CFs?$AN?6?$AA@
CONST	SEGMENT
??_C@_08LGKAGCMJ@To?3?5?$CFs?$AN?6?$AA@ DB 'To: %s', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BJCOBIPA@From?3?5?$CFs?$AN?6?$AA@
CONST	SEGMENT
??_C@_0L@BJCOBIPA@From?3?5?$CFs?$AN?6?$AA@ DB 'From: %s', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FHPOFNAI@Subject?3?5?$CFs?$AN?6?$AA@
CONST	SEGMENT
??_C@_0O@FHPOFNAI@Subject?3?5?$CFs?$AN?6?$AA@ DB 'Subject: %s', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06KNPIFKI@DATA?$AN?6?$AA@
CONST	SEGMENT
??_C@_06KNPIFKI@DATA?$AN?6?$AA@ DB 'DATA', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BIJBNMK@RCPT?5TO?3?5?$DM?$DO?$AN?6?$AA@
CONST	SEGMENT
??_C@_0O@BIJBNMK@RCPT?5TO?3?5?$DM?$DO?$AN?6?$AA@ DB 'RCPT TO: <>', 0dH, 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PAJOOKEN@RCPT?5TO?3?5?$DM?$CFs?$DO?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BA@PAJOOKEN@RCPT?5TO?3?5?$DM?$CFs?$DO?$AN?6?$AA@ DB 'RCPT TO: <%s>'
	DB	0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BOEBHIHF@MAIL?5From?3?5?$DM?$DO?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BA@BOEBHIHF@MAIL?5From?3?5?$DM?$DO?$AN?6?$AA@ DB 'MAIL From: <>', 0dH
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KOBLNCCF@MAIL?5From?3?5?$DM?$CFs?$DO?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BC@KOBLNCCF@MAIL?5From?3?5?$DM?$CFs?$DO?$AN?6?$AA@ DB 'MAIL From: '
	DB	'<%s>', 0dH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06OGKBAGLK@HELO?$AN?6?$AA@
CONST	SEGMENT
??_C@_06OGKBAGLK@HELO?$AN?6?$AA@ DB 'HELO', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@IJKMDCLC@Timeout?5while?5waiting?5for?5initia@
CONST	SEGMENT
??_C@_0DE@IJKMDCLC@Timeout?5while?5waiting?5for?5initia@ DB 'Timeout whil'
	DB	'e waiting for initial data from server.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@HBOBHECK@Failed?5to?5connect?5to?5host?$AA@
CONST	SEGMENT
??_C@_0BK@HBOBHECK@Failed?5to?5connect?5to?5host?$AA@ DB 'Failed to conne'
	DB	'ct to host', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@JFJLFONC@Unknown?5error?5starting?5TCP?$AA@
CONST	SEGMENT
??_C@_0BL@JFJLFONC@Unknown?5error?5starting?5TCP?$AA@ DB 'Unknown error s'
	DB	'tarting TCP', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Send@EmailSender@@QAEPADPBDG000000PAVFileList@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Send@EmailSender@@QAEPADPBDG000000PAVFileList@@_N@Z$0
__ehfuncinfo$?Send@EmailSender@@QAEPADPBDG000000PAVFileList@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Send@EmailSender@@QAEPADPBDG000000PAVFileList@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Size@?$List@UFileListNode@@@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$List@UFileListNode@@@DataStructures@@QBEIXZ PROC ; DataStructures::List<FileListNode>::Size, COMDAT
; _this$ = ecx

; 373  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 374  : 		return list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 375  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$List@UFileListNode@@@DataStructures@@QBEIXZ ENDP ; DataStructures::List<FileListNode>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z PROC ; DataStructures::List<FileListNode>::operator[], COMDAT
; _this$ = ecx

; 185  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 186  : #ifdef _DEBUG
; 187  : 		assert ( position < list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN3@operator
	push	187					; 000000bbH
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@operator:

; 188  : #endif
; 189  : 		return listArray[ position ];

	imul	eax, DWORD PTR _position$[ebp], 17
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]

; 190  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ENDP ; DataStructures::List<FileListNode>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\emailsender.cpp
;	COMDAT ?GetResponse@EmailSender@@IAEPADPAVTCPInterface@@ABUPlayerID@@_N@Z
_TEXT	SEGMENT
$T1 = -238						; size = 6
_timeout$ = -32						; size = 4
_packet$ = -20						; size = 4
_this$ = -8						; size = 4
_tcpInterface$ = 8					; size = 4
_emailServer$ = 12					; size = 4
_doPrintf$ = 16						; size = 1
?GetResponse@EmailSender@@IAEPADPAVTCPInterface@@ABUPlayerID@@_N@Z PROC ; EmailSender::GetResponse, COMDAT
; _this$ = ecx

; 249  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 250  : 	Packet *packet;
; 251  : 	RakNetTime timeout;
; 252  : 	timeout=RakNet::GetTime()+5000;

	call	?GetTime@RakNet@@YAIXZ			; RakNet::GetTime
	add	eax, 5000				; 00001388H
	mov	DWORD PTR _timeout$[ebp], eax
$LN10@GetRespons:

; 253  : 	while (1)

	mov	eax, 1
	test	eax, eax
	je	$LN11@GetRespons

; 254  : 	{
; 255  : 		if (tcpInterface->HasLostConnection()==emailServer)

	mov	eax, DWORD PTR _emailServer$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _tcpInterface$[ebp]
	call	?HasLostConnection@TCPInterface@@QAE?AUPlayerID@@XZ ; TCPInterface::HasLostConnection
	mov	ecx, eax
	call	??8PlayerID@@QBE_NABU0@@Z		; PlayerID::operator==
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN8@GetRespons

; 256  : 			return "Connection to server lost.";

	mov	eax, OFFSET ??_C@_0BL@HOIDLJBI@Connection?5to?5server?5lost?4?$AA@
	jmp	$LN11@GetRespons
$LN8@GetRespons:

; 257  : 		packet = tcpInterface->Receive();

	mov	ecx, DWORD PTR _tcpInterface$[ebp]
	call	?Receive@TCPInterface@@QAEPAUPacket@@XZ	; TCPInterface::Receive
	mov	DWORD PTR _packet$[ebp], eax

; 258  : 		if (packet)

	cmp	DWORD PTR _packet$[ebp], 0
	je	$LN7@GetRespons

; 259  : 		{
; 260  : 			if (doPrintf)

	movzx	eax, BYTE PTR _doPrintf$[ebp]
	test	eax, eax
	je	SHORT $LN6@GetRespons

; 261  : 				printf("%s", packet->data);

	mov	eax, DWORD PTR _packet$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	push	OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
	call	_printf
	add	esp, 8
$LN6@GetRespons:

; 262  : 			if (strstr((const char*)packet->data, "250"))

	push	OFFSET ??_C@_03HJHPABEB@250?$AA@
	mov	eax, DWORD PTR _packet$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@GetRespons

; 263  : 				return 0; // OK

	xor	eax, eax
	jmp	SHORT $LN11@GetRespons
$LN5@GetRespons:

; 264  : 			if (strstr((const char*)packet->data, "354"))

	push	OFFSET ??_C@_03KFKPKDCA@354?$AA@
	mov	eax, DWORD PTR _packet$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@GetRespons

; 265  : 				return 0; // OK

	xor	eax, eax
	jmp	SHORT $LN11@GetRespons
$LN4@GetRespons:

; 266  : 			if (strstr((const char*)packet->data, "550"))

	push	OFFSET ??_C@_03OEKIDJPI@550?$AA@
	mov	eax, DWORD PTR _packet$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@GetRespons

; 267  : 				return "Failed on error code 550";

	mov	eax, OFFSET ??_C@_0BJ@JKOAHELK@Failed?5on?5error?5code?5550?$AA@
	jmp	SHORT $LN11@GetRespons
$LN3@GetRespons:

; 268  : 			if (strstr((const char*)packet->data, "553"))

	push	OFFSET ??_C@_03MPIFGKDL@553?$AA@
	mov	eax, DWORD PTR _packet$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@GetRespons

; 269  : 				return "Failed on error code 553";

	mov	eax, OFFSET ??_C@_0BJ@LBMNCHHJ@Failed?5on?5error?5code?5553?$AA@
	jmp	SHORT $LN11@GetRespons
$LN7@GetRespons:

; 270  : 		}
; 271  : 		if (RakNet::GetTime() > timeout)

	call	?GetTime@RakNet@@YAIXZ			; RakNet::GetTime
	cmp	eax, DWORD PTR _timeout$[ebp]
	jbe	SHORT $LN1@GetRespons

; 272  : 			return "Timed out";

	mov	eax, OFFSET ??_C@_09OGKCMDDI@Timed?5out?$AA@
	jmp	SHORT $LN11@GetRespons
$LN1@GetRespons:

; 273  : 		RakSleep(100);

	push	100					; 00000064H
	call	?RakSleep@@YAXI@Z			; RakSleep
	add	esp, 4

; 274  : 	}

	jmp	$LN10@GetRespons
$LN11@GetRespons:

; 275  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetResponse@EmailSender@@IAEPADPAVTCPInterface@@ABUPlayerID@@_N@Z ENDP ; EmailSender::GetResponse
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\emailsender.cpp
;	COMDAT ?Base64Encoding@EmailSender@@QAEHPBDHPAD0@Z
_TEXT	SEGMENT
_j$ = -56						; size = 4
_write3Count$ = -44					; size = 4
_charCount$ = -32					; size = 4
_outputOffset$ = -20					; size = 4
_this$ = -8						; size = 4
_inputData$ = 8						; size = 4
_dataLength$ = 12					; size = 4
_outputData$ = 16					; size = 4
_base64Map$ = 20					; size = 4
?Base64Encoding@EmailSender@@QAEHPBDHPAD0@Z PROC	; EmailSender::Base64Encoding, COMDAT
; _this$ = ecx

; 278  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 279  : 	int outputOffset, charCount;
; 280  : 	int write3Count;
; 281  : 	outputOffset=0;

	mov	DWORD PTR _outputOffset$[ebp], 0

; 282  : 	charCount=0;

	mov	DWORD PTR _charCount$[ebp], 0

; 283  : 	int j;
; 284  : 
; 285  : 	write3Count=dataLength/3;

	mov	eax, DWORD PTR _dataLength$[ebp]
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	DWORD PTR _write3Count$[ebp], eax

; 286  : 	for (j=0; j < write3Count; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN14@Base64Enco
$LN13@Base64Enco:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN14@Base64Enco:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _write3Count$[ebp]
	jge	$LN12@Base64Enco

; 287  : 	{
; 288  : 		// 6 leftmost bits from first byte, shifted to bits 7,8 are 0
; 289  : 		outputData[outputOffset++]=base64Map[inputData[j*3+0] >> 2];

	imul	eax, DWORD PTR _j$[ebp], 3
	mov	ecx, DWORD PTR _inputData$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	sar	edx, 2
	mov	eax, DWORD PTR _outputData$[ebp]
	add	eax, DWORD PTR _outputOffset$[ebp]
	mov	ecx, DWORD PTR _base64Map$[ebp]
	mov	dl, BYTE PTR [ecx+edx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _outputOffset$[ebp]
	add	eax, 1
	mov	DWORD PTR _outputOffset$[ebp], eax

; 290  : 		if ((++charCount % 76)==0) {outputData[outputOffset++]='\r'; outputData[outputOffset++]='\n'; charCount=0;}

	mov	eax, DWORD PTR _charCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _charCount$[ebp], eax
	mov	eax, DWORD PTR _charCount$[ebp]
	cdq
	mov	ecx, 76					; 0000004cH
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN11@Base64Enco
	mov	eax, DWORD PTR _outputData$[ebp]
	add	eax, DWORD PTR _outputOffset$[ebp]
	mov	BYTE PTR [eax], 13			; 0000000dH
	mov	ecx, DWORD PTR _outputOffset$[ebp]
	add	ecx, 1
	mov	DWORD PTR _outputOffset$[ebp], ecx
	mov	eax, DWORD PTR _outputData$[ebp]
	add	eax, DWORD PTR _outputOffset$[ebp]
	mov	BYTE PTR [eax], 10			; 0000000aH
	mov	ecx, DWORD PTR _outputOffset$[ebp]
	add	ecx, 1
	mov	DWORD PTR _outputOffset$[ebp], ecx
	mov	DWORD PTR _charCount$[ebp], 0
$LN11@Base64Enco:

; 291  : 
; 292  : 		// Remaining 2 bits from first byte, placed in position, and 4 high bits from the second byte, masked to ignore bits 7,8
; 293  : 		outputData[outputOffset++]=base64Map[((inputData[j*3+0] << 4) | (inputData[j*3+1] >> 4)) & 63];

	imul	eax, DWORD PTR _j$[ebp], 3
	mov	ecx, DWORD PTR _inputData$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	shl	edx, 4
	imul	eax, DWORD PTR _j$[ebp], 3
	mov	ecx, DWORD PTR _inputData$[ebp]
	movsx	eax, BYTE PTR [ecx+eax+1]
	sar	eax, 4
	or	edx, eax
	and	edx, 63					; 0000003fH
	mov	ecx, DWORD PTR _outputData$[ebp]
	add	ecx, DWORD PTR _outputOffset$[ebp]
	mov	eax, DWORD PTR _base64Map$[ebp]
	mov	dl, BYTE PTR [eax+edx]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _outputOffset$[ebp]
	add	eax, 1
	mov	DWORD PTR _outputOffset$[ebp], eax

; 294  : 		if ((++charCount % 76)==0) {outputData[outputOffset++]='\r'; outputData[outputOffset++]='\n'; charCount=0;}

	mov	eax, DWORD PTR _charCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _charCount$[ebp], eax
	mov	eax, DWORD PTR _charCount$[ebp]
	cdq
	mov	ecx, 76					; 0000004cH
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN10@Base64Enco
	mov	eax, DWORD PTR _outputData$[ebp]
	add	eax, DWORD PTR _outputOffset$[ebp]
	mov	BYTE PTR [eax], 13			; 0000000dH
	mov	ecx, DWORD PTR _outputOffset$[ebp]
	add	ecx, 1
	mov	DWORD PTR _outputOffset$[ebp], ecx
	mov	eax, DWORD PTR _outputData$[ebp]
	add	eax, DWORD PTR _outputOffset$[ebp]
	mov	BYTE PTR [eax], 10			; 0000000aH
	mov	ecx, DWORD PTR _outputOffset$[ebp]
	add	ecx, 1
	mov	DWORD PTR _outputOffset$[ebp], ecx
	mov	DWORD PTR _charCount$[ebp], 0
$LN10@Base64Enco:

; 295  : 
; 296  : 		// 4 low bits from the second byte and the two high bits from the third byte, masked to ignore bits 7,8
; 297  : 		outputData[outputOffset++]=base64Map[((inputData[j*3+1] << 2) | (inputData[j*3+2] >> 6)) & 63]; // Third 6 bits

	imul	eax, DWORD PTR _j$[ebp], 3
	mov	ecx, DWORD PTR _inputData$[ebp]
	movsx	edx, BYTE PTR [ecx+eax+1]
	shl	edx, 2
	imul	eax, DWORD PTR _j$[ebp], 3
	mov	ecx, DWORD PTR _inputData$[ebp]
	movsx	eax, BYTE PTR [ecx+eax+2]
	sar	eax, 6
	or	edx, eax
	and	edx, 63					; 0000003fH
	mov	ecx, DWORD PTR _outputData$[ebp]
	add	ecx, DWORD PTR _outputOffset$[ebp]
	mov	eax, DWORD PTR _base64Map$[ebp]
	mov	dl, BYTE PTR [eax+edx]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _outputOffset$[ebp]
	add	eax, 1
	mov	DWORD PTR _outputOffset$[ebp], eax

; 298  : 		if ((++charCount % 76)==0) {outputData[outputOffset++]='\r'; outputData[outputOffset++]='\n'; charCount=0;}

	mov	eax, DWORD PTR _charCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _charCount$[ebp], eax
	mov	eax, DWORD PTR _charCount$[ebp]
	cdq
	mov	ecx, 76					; 0000004cH
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN9@Base64Enco
	mov	eax, DWORD PTR _outputData$[ebp]
	add	eax, DWORD PTR _outputOffset$[ebp]
	mov	BYTE PTR [eax], 13			; 0000000dH
	mov	ecx, DWORD PTR _outputOffset$[ebp]
	add	ecx, 1
	mov	DWORD PTR _outputOffset$[ebp], ecx
	mov	eax, DWORD PTR _outputData$[ebp]
	add	eax, DWORD PTR _outputOffset$[ebp]
	mov	BYTE PTR [eax], 10			; 0000000aH
	mov	ecx, DWORD PTR _outputOffset$[ebp]
	add	ecx, 1
	mov	DWORD PTR _outputOffset$[ebp], ecx
	mov	DWORD PTR _charCount$[ebp], 0
$LN9@Base64Enco:

; 299  : 
; 300  : 		// Last 6 bits from the third byte, masked to ignore bits 7,8
; 301  : 		outputData[outputOffset++]=base64Map[inputData[j*3+2] & 63];

	imul	eax, DWORD PTR _j$[ebp], 3
	mov	ecx, DWORD PTR _inputData$[ebp]
	movsx	edx, BYTE PTR [ecx+eax+2]
	and	edx, 63					; 0000003fH
	mov	eax, DWORD PTR _outputData$[ebp]
	add	eax, DWORD PTR _outputOffset$[ebp]
	mov	ecx, DWORD PTR _base64Map$[ebp]
	mov	dl, BYTE PTR [ecx+edx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _outputOffset$[ebp]
	add	eax, 1
	mov	DWORD PTR _outputOffset$[ebp], eax

; 302  : 		if ((++charCount % 76)==0) {outputData[outputOffset++]='\r'; outputData[outputOffset++]='\n'; charCount=0;}

	mov	eax, DWORD PTR _charCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _charCount$[ebp], eax
	mov	eax, DWORD PTR _charCount$[ebp]
	cdq
	mov	ecx, 76					; 0000004cH
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN8@Base64Enco
	mov	eax, DWORD PTR _outputData$[ebp]
	add	eax, DWORD PTR _outputOffset$[ebp]
	mov	BYTE PTR [eax], 13			; 0000000dH
	mov	ecx, DWORD PTR _outputOffset$[ebp]
	add	ecx, 1
	mov	DWORD PTR _outputOffset$[ebp], ecx
	mov	eax, DWORD PTR _outputData$[ebp]
	add	eax, DWORD PTR _outputOffset$[ebp]
	mov	BYTE PTR [eax], 10			; 0000000aH
	mov	ecx, DWORD PTR _outputOffset$[ebp]
	add	ecx, 1
	mov	DWORD PTR _outputOffset$[ebp], ecx
	mov	DWORD PTR _charCount$[ebp], 0
$LN8@Base64Enco:

; 303  : 	}

	jmp	$LN13@Base64Enco
$LN12@Base64Enco:

; 304  : 
; 305  : 	if (dataLength % 3==1)

	mov	eax, DWORD PTR _dataLength$[ebp]
	cdq
	mov	ecx, 3
	idiv	ecx
	cmp	edx, 1
	jne	$LN7@Base64Enco

; 306  : 	{
; 307  : 		// One input byte remaining
; 308  : 		outputData[outputOffset++]=base64Map[inputData[j*3+0] >> 2];

	imul	eax, DWORD PTR _j$[ebp], 3
	mov	ecx, DWORD PTR _inputData$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	sar	edx, 2
	mov	eax, DWORD PTR _outputData$[ebp]
	add	eax, DWORD PTR _outputOffset$[ebp]
	mov	ecx, DWORD PTR _base64Map$[ebp]
	mov	dl, BYTE PTR [ecx+edx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _outputOffset$[ebp]
	add	eax, 1
	mov	DWORD PTR _outputOffset$[ebp], eax

; 309  : 		if ((++charCount % 76)==0) {outputData[outputOffset++]='\r'; outputData[outputOffset++]='\n'; charCount=0;}

	mov	eax, DWORD PTR _charCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _charCount$[ebp], eax
	mov	eax, DWORD PTR _charCount$[ebp]
	cdq
	mov	ecx, 76					; 0000004cH
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN6@Base64Enco
	mov	eax, DWORD PTR _outputData$[ebp]
	add	eax, DWORD PTR _outputOffset$[ebp]
	mov	BYTE PTR [eax], 13			; 0000000dH
	mov	ecx, DWORD PTR _outputOffset$[ebp]
	add	ecx, 1
	mov	DWORD PTR _outputOffset$[ebp], ecx
	mov	eax, DWORD PTR _outputData$[ebp]
	add	eax, DWORD PTR _outputOffset$[ebp]
	mov	BYTE PTR [eax], 10			; 0000000aH
	mov	ecx, DWORD PTR _outputOffset$[ebp]
	add	ecx, 1
	mov	DWORD PTR _outputOffset$[ebp], ecx
	mov	DWORD PTR _charCount$[ebp], 0
$LN6@Base64Enco:

; 310  : 	
; 311  : 		// Pad with two equals
; 312  : 		outputData[outputOffset++]='=';

	mov	eax, DWORD PTR _outputData$[ebp]
	add	eax, DWORD PTR _outputOffset$[ebp]
	mov	BYTE PTR [eax], 61			; 0000003dH
	mov	ecx, DWORD PTR _outputOffset$[ebp]
	add	ecx, 1
	mov	DWORD PTR _outputOffset$[ebp], ecx

; 313  : 		outputData[outputOffset++]='=';

	mov	eax, DWORD PTR _outputData$[ebp]
	add	eax, DWORD PTR _outputOffset$[ebp]
	mov	BYTE PTR [eax], 61			; 0000003dH
	mov	ecx, DWORD PTR _outputOffset$[ebp]
	add	ecx, 1
	mov	DWORD PTR _outputOffset$[ebp], ecx
	jmp	$LN5@Base64Enco
$LN7@Base64Enco:

; 314  : 	}
; 315  : 	else if (dataLength % 3==2)

	mov	eax, DWORD PTR _dataLength$[ebp]
	cdq
	mov	ecx, 3
	idiv	ecx
	cmp	edx, 2
	jne	$LN5@Base64Enco

; 316  : 	{
; 317  : 		// Two input bytes remaining
; 318  : 
; 319  : 		// 6 leftmost bits from first byte, shifted to bits 7,8 are 0
; 320  : 		outputData[outputOffset++]=base64Map[inputData[j*3+0] >> 2];

	imul	eax, DWORD PTR _j$[ebp], 3
	mov	ecx, DWORD PTR _inputData$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	sar	edx, 2
	mov	eax, DWORD PTR _outputData$[ebp]
	add	eax, DWORD PTR _outputOffset$[ebp]
	mov	ecx, DWORD PTR _base64Map$[ebp]
	mov	dl, BYTE PTR [ecx+edx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _outputOffset$[ebp]
	add	eax, 1
	mov	DWORD PTR _outputOffset$[ebp], eax

; 321  : 		if ((++charCount % 76)==0) {outputData[outputOffset++]='\r'; outputData[outputOffset++]='\n'; charCount=0;}

	mov	eax, DWORD PTR _charCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _charCount$[ebp], eax
	mov	eax, DWORD PTR _charCount$[ebp]
	cdq
	mov	ecx, 76					; 0000004cH
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN3@Base64Enco
	mov	eax, DWORD PTR _outputData$[ebp]
	add	eax, DWORD PTR _outputOffset$[ebp]
	mov	BYTE PTR [eax], 13			; 0000000dH
	mov	ecx, DWORD PTR _outputOffset$[ebp]
	add	ecx, 1
	mov	DWORD PTR _outputOffset$[ebp], ecx
	mov	eax, DWORD PTR _outputData$[ebp]
	add	eax, DWORD PTR _outputOffset$[ebp]
	mov	BYTE PTR [eax], 10			; 0000000aH
	mov	ecx, DWORD PTR _outputOffset$[ebp]
	add	ecx, 1
	mov	DWORD PTR _outputOffset$[ebp], ecx
	mov	DWORD PTR _charCount$[ebp], 0
$LN3@Base64Enco:

; 322  : 
; 323  : 		// Remaining 2 bits from first byte, placed in position, and 4 high bits from the second byte, masked to ignore bits 7,8
; 324  : 		outputData[outputOffset++]=base64Map[((inputData[j*3+0] << 4) | (inputData[j*3+1] >> 4)) & 63];

	imul	eax, DWORD PTR _j$[ebp], 3
	mov	ecx, DWORD PTR _inputData$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	shl	edx, 4
	imul	eax, DWORD PTR _j$[ebp], 3
	mov	ecx, DWORD PTR _inputData$[ebp]
	movsx	eax, BYTE PTR [ecx+eax+1]
	sar	eax, 4
	or	edx, eax
	and	edx, 63					; 0000003fH
	mov	ecx, DWORD PTR _outputData$[ebp]
	add	ecx, DWORD PTR _outputOffset$[ebp]
	mov	eax, DWORD PTR _base64Map$[ebp]
	mov	dl, BYTE PTR [eax+edx]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _outputOffset$[ebp]
	add	eax, 1
	mov	DWORD PTR _outputOffset$[ebp], eax

; 325  : 		if ((++charCount % 76)==0) {outputData[outputOffset++]='\r'; outputData[outputOffset++]='\n'; charCount=0;}

	mov	eax, DWORD PTR _charCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _charCount$[ebp], eax
	mov	eax, DWORD PTR _charCount$[ebp]
	cdq
	mov	ecx, 76					; 0000004cH
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN2@Base64Enco
	mov	eax, DWORD PTR _outputData$[ebp]
	add	eax, DWORD PTR _outputOffset$[ebp]
	mov	BYTE PTR [eax], 13			; 0000000dH
	mov	ecx, DWORD PTR _outputOffset$[ebp]
	add	ecx, 1
	mov	DWORD PTR _outputOffset$[ebp], ecx
	mov	eax, DWORD PTR _outputData$[ebp]
	add	eax, DWORD PTR _outputOffset$[ebp]
	mov	BYTE PTR [eax], 10			; 0000000aH
	mov	ecx, DWORD PTR _outputOffset$[ebp]
	add	ecx, 1
	mov	DWORD PTR _outputOffset$[ebp], ecx
	mov	DWORD PTR _charCount$[ebp], 0
$LN2@Base64Enco:

; 326  : 
; 327  : 		// 4 low bits from the second byte, followed by 00
; 328  : 		outputData[outputOffset++]=base64Map[(inputData[j*3+1] << 2) & 63]; // Third 6 bits

	imul	eax, DWORD PTR _j$[ebp], 3
	mov	ecx, DWORD PTR _inputData$[ebp]
	movsx	edx, BYTE PTR [ecx+eax+1]
	shl	edx, 2
	and	edx, 63					; 0000003fH
	mov	eax, DWORD PTR _outputData$[ebp]
	add	eax, DWORD PTR _outputOffset$[ebp]
	mov	ecx, DWORD PTR _base64Map$[ebp]
	mov	dl, BYTE PTR [ecx+edx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _outputOffset$[ebp]
	add	eax, 1
	mov	DWORD PTR _outputOffset$[ebp], eax

; 329  : 		if ((++charCount % 76)==0) {outputData[outputOffset++]='\r'; outputData[outputOffset++]='\n'; charCount=0;}

	mov	eax, DWORD PTR _charCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _charCount$[ebp], eax
	mov	eax, DWORD PTR _charCount$[ebp]
	cdq
	mov	ecx, 76					; 0000004cH
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN1@Base64Enco
	mov	eax, DWORD PTR _outputData$[ebp]
	add	eax, DWORD PTR _outputOffset$[ebp]
	mov	BYTE PTR [eax], 13			; 0000000dH
	mov	ecx, DWORD PTR _outputOffset$[ebp]
	add	ecx, 1
	mov	DWORD PTR _outputOffset$[ebp], ecx
	mov	eax, DWORD PTR _outputData$[ebp]
	add	eax, DWORD PTR _outputOffset$[ebp]
	mov	BYTE PTR [eax], 10			; 0000000aH
	mov	ecx, DWORD PTR _outputOffset$[ebp]
	add	ecx, 1
	mov	DWORD PTR _outputOffset$[ebp], ecx
	mov	DWORD PTR _charCount$[ebp], 0
$LN1@Base64Enco:

; 330  : 
; 331  : 		// Pad with one equal
; 332  : 		outputData[outputOffset++]='=';

	mov	eax, DWORD PTR _outputData$[ebp]
	add	eax, DWORD PTR _outputOffset$[ebp]
	mov	BYTE PTR [eax], 61			; 0000003dH
	mov	ecx, DWORD PTR _outputOffset$[ebp]
	add	ecx, 1
	mov	DWORD PTR _outputOffset$[ebp], ecx
$LN5@Base64Enco:

; 333  : 		//outputData[outputOffset++]='=';
; 334  : 	}
; 335  : 
; 336  : 	// Append \r\n
; 337  : 	outputData[outputOffset++]='\r';

	mov	eax, DWORD PTR _outputData$[ebp]
	add	eax, DWORD PTR _outputOffset$[ebp]
	mov	BYTE PTR [eax], 13			; 0000000dH
	mov	ecx, DWORD PTR _outputOffset$[ebp]
	add	ecx, 1
	mov	DWORD PTR _outputOffset$[ebp], ecx

; 338  : 	outputData[outputOffset++]='\n';

	mov	eax, DWORD PTR _outputData$[ebp]
	add	eax, DWORD PTR _outputOffset$[ebp]
	mov	BYTE PTR [eax], 10			; 0000000aH
	mov	ecx, DWORD PTR _outputOffset$[ebp]
	add	ecx, 1
	mov	DWORD PTR _outputOffset$[ebp], ecx

; 339  : 	outputData[outputOffset]=0;

	mov	eax, DWORD PTR _outputData$[ebp]
	add	eax, DWORD PTR _outputOffset$[ebp]
	mov	BYTE PTR [eax], 0

; 340  : 
; 341  : 	return outputOffset;

	mov	eax, DWORD PTR _outputOffset$[ebp]

; 342  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Base64Encoding@EmailSender@@QAEHPBDHPAD0@Z ENDP	; EmailSender::Base64Encoding
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\emailsender.cpp
;	COMDAT ?Send@EmailSender@@QAEPADPBDG000000PAVFileList@@_N@Z
_TEXT	SEGMENT
$T2 = -1880						; size = 4
$T3 = -1866						; size = 6
$T4 = -1852						; size = 4
$T5 = -1840						; size = 4
$T6 = -1828						; size = 4
$T7 = -1816						; size = 4
$T8 = -1804						; size = 4
$T9 = -1792						; size = 4
$T10 = -1780						; size = 4
$T11 = -1768						; size = 4
$T12 = -1756						; size = 4
$T13 = -1744						; size = 4
$T14 = -1732						; size = 4
$T15 = -1720						; size = 4
$T16 = -1708						; size = 4
_outputOffset$ = -1504					; size = 4
_bodyLength$ = -1492					; size = 4
_newBody$ = -1480					; size = 4
_j$ = -1468						; size = 4
_i$ = -1456						; size = 4
_boundary$ = -1444					; size = 61
_boundarySize$ = -1372					; size = 4
_base64Map$ = -1360					; size = 65
_timeoutTime$ = -1284					; size = 4
_emailServer$ = -1272					; size = 6
_tcpInterface$ = -1256					; size = 167
_response$ = -1080					; size = 4
_query$ = -1068						; size = 1024
_packet$ = -36						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_hostAddress$ = 8					; size = 4
_hostPort$ = 12						; size = 2
_sender$ = 16						; size = 4
_recipient$ = 20					; size = 4
_senderName$ = 24					; size = 4
_recipientName$ = 28					; size = 4
_subject$ = 32						; size = 4
_body$ = 36						; size = 4
_attachedFiles$ = 40					; size = 4
_doPrintf$ = 44						; size = 1
?Send@EmailSender@@QAEPADPBDG000000PAVFileList@@_N@Z PROC ; EmailSender::Send, COMDAT
; _this$ = ecx

; 20   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Send@EmailSender@@QAEPADPBDG000000PAVFileList@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1872				; 00000750H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-1884]
	mov	ecx, 468				; 000001d4H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 21   : 	Packet *packet;
; 22   : 	char query[1024];
; 23   : 	char *response;
; 24   : 	TCPInterface tcpInterface;

	lea	ecx, DWORD PTR _tcpInterface$[ebp]
	call	??0TCPInterface@@QAE@XZ			; TCPInterface::TCPInterface
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 25   : 	PlayerID emailServer;
; 26   : 	if (tcpInterface.Start(0, 0)==false)

	push	0
	push	0
	lea	ecx, DWORD PTR _tcpInterface$[ebp]
	call	?Start@TCPInterface@@QAE_NGG@Z		; TCPInterface::Start
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN43@Send

; 27   : 		return "Unknown error starting TCP";

	mov	DWORD PTR $T2[ebp], OFFSET ??_C@_0BL@JFJLFONC@Unknown?5error?5starting?5TCP?$AA@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tcpInterface$[ebp]
	call	??1TCPInterface@@QAE@XZ			; TCPInterface::~TCPInterface
	mov	eax, DWORD PTR $T2[ebp]
	jmp	$LN45@Send
$LN43@Send:

; 28   : 	emailServer=tcpInterface.Connect(hostAddress, hostPort);

	movzx	eax, WORD PTR _hostPort$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hostAddress$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	lea	ecx, DWORD PTR _tcpInterface$[ebp]
	call	?Connect@TCPInterface@@QAE?AUPlayerID@@PBDG@Z ; TCPInterface::Connect
	push	eax
	lea	ecx, DWORD PTR _emailServer$[ebp]
	call	??4PlayerID@@QAEAAU0@ABU0@@Z		; PlayerID::operator=

; 29   : 	if (emailServer==UNASSIGNED_PLAYER_ID)

	push	OFFSET _UNASSIGNED_PLAYER_ID
	lea	ecx, DWORD PTR _emailServer$[ebp]
	call	??8PlayerID@@QBE_NABU0@@Z		; PlayerID::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN42@Send

; 30   : 		return "Failed to connect to host";

	mov	DWORD PTR $T4[ebp], OFFSET ??_C@_0BK@HBOBHECK@Failed?5to?5connect?5to?5host?$AA@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tcpInterface$[ebp]
	call	??1TCPInterface@@QAE@XZ			; TCPInterface::~TCPInterface
	mov	eax, DWORD PTR $T4[ebp]
	jmp	$LN45@Send
$LN42@Send:

; 31   : 	RakNetTime timeoutTime = RakNet::GetTime()+3000;

	call	?GetTime@RakNet@@YAIXZ			; RakNet::GetTime
	add	eax, 3000				; 00000bb8H
	mov	DWORD PTR _timeoutTime$[ebp], eax

; 32   : 	packet=0;

	mov	DWORD PTR _packet$[ebp], 0
$LN41@Send:

; 33   : 	while (RakNet::GetTime() < timeoutTime)

	call	?GetTime@RakNet@@YAIXZ			; RakNet::GetTime
	cmp	eax, DWORD PTR _timeoutTime$[ebp]
	jae	SHORT $LN40@Send

; 34   : 	{
; 35   : 		packet = tcpInterface.Receive();

	lea	ecx, DWORD PTR _tcpInterface$[ebp]
	call	?Receive@TCPInterface@@QAEPAUPacket@@XZ	; TCPInterface::Receive
	mov	DWORD PTR _packet$[ebp], eax

; 36   : 		if (packet)

	cmp	DWORD PTR _packet$[ebp], 0
	je	SHORT $LN39@Send

; 37   : 		{
; 38   : 			if (doPrintf)

	movzx	eax, BYTE PTR _doPrintf$[ebp]
	test	eax, eax
	je	SHORT $LN38@Send

; 39   : 				printf("%s", packet->data);

	mov	eax, DWORD PTR _packet$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	push	OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
	call	_printf
	add	esp, 8
$LN38@Send:

; 40   : 			break;

	jmp	SHORT $LN40@Send
$LN39@Send:

; 41   : 		}
; 42   : 		RakSleep(250);

	push	250					; 000000faH
	call	?RakSleep@@YAXI@Z			; RakSleep
	add	esp, 4

; 43   : 	}

	jmp	SHORT $LN41@Send
$LN40@Send:

; 44   : 
; 45   : 	if (packet==0)

	cmp	DWORD PTR _packet$[ebp], 0
	jne	SHORT $LN37@Send

; 46   : 		return "Timeout while waiting for initial data from server.";

	mov	DWORD PTR $T5[ebp], OFFSET ??_C@_0DE@IJKMDCLC@Timeout?5while?5waiting?5for?5initia@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tcpInterface$[ebp]
	call	??1TCPInterface@@QAE@XZ			; TCPInterface::~TCPInterface
	mov	eax, DWORD PTR $T5[ebp]
	jmp	$LN45@Send
$LN37@Send:

; 47   : 	
; 48   : 	tcpInterface.Send("HELO\r\n", 6, emailServer);

	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _emailServer$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _emailServer$[ebp+4]
	mov	WORD PTR [eax+4], dx
	push	6
	push	OFFSET ??_C@_06OGKBAGLK@HELO?$AN?6?$AA@
	lea	ecx, DWORD PTR _tcpInterface$[ebp]
	call	?Send@TCPInterface@@QAEXPBDIUPlayerID@@@Z ; TCPInterface::Send

; 49   : 	
; 50   : 	response=GetResponse(&tcpInterface, emailServer, doPrintf);

	movzx	eax, BYTE PTR _doPrintf$[ebp]
	push	eax
	lea	ecx, DWORD PTR _emailServer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _tcpInterface$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetResponse@EmailSender@@IAEPADPAVTCPInterface@@ABUPlayerID@@_N@Z ; EmailSender::GetResponse
	mov	DWORD PTR _response$[ebp], eax

; 51   : 	if (response!=0)

	cmp	DWORD PTR _response$[ebp], 0
	je	SHORT $LN36@Send

; 52   : 		return response;

	mov	eax, DWORD PTR _response$[ebp]
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tcpInterface$[ebp]
	call	??1TCPInterface@@QAE@XZ			; TCPInterface::~TCPInterface
	mov	eax, DWORD PTR $T6[ebp]
	jmp	$LN45@Send
$LN36@Send:

; 53   : 
; 54   : 	if (sender)

	cmp	DWORD PTR _sender$[ebp], 0
	je	SHORT $LN35@Send

; 55   : 		sprintf(query, "MAIL From: <%s>\r\n", sender);

	mov	eax, DWORD PTR _sender$[ebp]
	push	eax
	push	OFFSET ??_C@_0BC@KOBLNCCF@MAIL?5From?3?5?$DM?$CFs?$DO?$AN?6?$AA@
	lea	ecx, DWORD PTR _query$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 56   : 	else

	jmp	SHORT $LN34@Send
$LN35@Send:

; 57   : 		sprintf(query, "MAIL From: <>\r\n");

	push	OFFSET ??_C@_0BA@BOEBHIHF@MAIL?5From?3?5?$DM?$DO?$AN?6?$AA@
	lea	eax, DWORD PTR _query$[ebp]
	push	eax
	call	_sprintf
	add	esp, 8
$LN34@Send:

; 58   : 	tcpInterface.Send(query, (unsigned int)strlen(query), emailServer);

	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _emailServer$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _emailServer$[ebp+4]
	mov	WORD PTR [eax+4], dx
	lea	eax, DWORD PTR _query$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR _query$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _tcpInterface$[ebp]
	call	?Send@TCPInterface@@QAEXPBDIUPlayerID@@@Z ; TCPInterface::Send

; 59   : 	response=GetResponse(&tcpInterface, emailServer, doPrintf);

	movzx	eax, BYTE PTR _doPrintf$[ebp]
	push	eax
	lea	ecx, DWORD PTR _emailServer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _tcpInterface$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetResponse@EmailSender@@IAEPADPAVTCPInterface@@ABUPlayerID@@_N@Z ; EmailSender::GetResponse
	mov	DWORD PTR _response$[ebp], eax

; 60   : 	if (response!=0)

	cmp	DWORD PTR _response$[ebp], 0
	je	SHORT $LN33@Send

; 61   : 		return response;

	mov	eax, DWORD PTR _response$[ebp]
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tcpInterface$[ebp]
	call	??1TCPInterface@@QAE@XZ			; TCPInterface::~TCPInterface
	mov	eax, DWORD PTR $T7[ebp]
	jmp	$LN45@Send
$LN33@Send:

; 62   : 
; 63   : 	if (recipient)

	cmp	DWORD PTR _recipient$[ebp], 0
	je	SHORT $LN32@Send

; 64   : 		sprintf(query, "RCPT TO: <%s>\r\n", recipient);

	mov	eax, DWORD PTR _recipient$[ebp]
	push	eax
	push	OFFSET ??_C@_0BA@PAJOOKEN@RCPT?5TO?3?5?$DM?$CFs?$DO?$AN?6?$AA@
	lea	ecx, DWORD PTR _query$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 65   : 	else

	jmp	SHORT $LN31@Send
$LN32@Send:

; 66   : 		sprintf(query, "RCPT TO: <>\r\n");

	push	OFFSET ??_C@_0O@BIJBNMK@RCPT?5TO?3?5?$DM?$DO?$AN?6?$AA@
	lea	eax, DWORD PTR _query$[ebp]
	push	eax
	call	_sprintf
	add	esp, 8
$LN31@Send:

; 67   : 	tcpInterface.Send(query, (unsigned int)strlen(query), emailServer);

	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _emailServer$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _emailServer$[ebp+4]
	mov	WORD PTR [eax+4], dx
	lea	eax, DWORD PTR _query$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR _query$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _tcpInterface$[ebp]
	call	?Send@TCPInterface@@QAEXPBDIUPlayerID@@@Z ; TCPInterface::Send

; 68   : 	response=GetResponse(&tcpInterface, emailServer, doPrintf);

	movzx	eax, BYTE PTR _doPrintf$[ebp]
	push	eax
	lea	ecx, DWORD PTR _emailServer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _tcpInterface$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetResponse@EmailSender@@IAEPADPAVTCPInterface@@ABUPlayerID@@_N@Z ; EmailSender::GetResponse
	mov	DWORD PTR _response$[ebp], eax

; 69   : 	if (response!=0)

	cmp	DWORD PTR _response$[ebp], 0
	je	SHORT $LN30@Send

; 70   : 		return response;

	mov	eax, DWORD PTR _response$[ebp]
	mov	DWORD PTR $T8[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tcpInterface$[ebp]
	call	??1TCPInterface@@QAE@XZ			; TCPInterface::~TCPInterface
	mov	eax, DWORD PTR $T8[ebp]
	jmp	$LN45@Send
$LN30@Send:

; 71   : 
; 72   : 	tcpInterface.Send("DATA\r\n", (unsigned int)strlen("DATA\r\n"), emailServer);

	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _emailServer$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _emailServer$[ebp+4]
	mov	WORD PTR [eax+4], dx
	push	OFFSET ??_C@_06KNPIFKI@DATA?$AN?6?$AA@
	call	_strlen
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_06KNPIFKI@DATA?$AN?6?$AA@
	lea	ecx, DWORD PTR _tcpInterface$[ebp]
	call	?Send@TCPInterface@@QAEXPBDIUPlayerID@@@Z ; TCPInterface::Send

; 73   : 
; 74   : 	response=GetResponse(&tcpInterface, emailServer, doPrintf);

	movzx	eax, BYTE PTR _doPrintf$[ebp]
	push	eax
	lea	ecx, DWORD PTR _emailServer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _tcpInterface$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetResponse@EmailSender@@IAEPADPAVTCPInterface@@ABUPlayerID@@_N@Z ; EmailSender::GetResponse
	mov	DWORD PTR _response$[ebp], eax

; 75   : 	if (response!=0)

	cmp	DWORD PTR _response$[ebp], 0
	je	SHORT $LN29@Send

; 76   : 		return response;

	mov	eax, DWORD PTR _response$[ebp]
	mov	DWORD PTR $T9[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tcpInterface$[ebp]
	call	??1TCPInterface@@QAE@XZ			; TCPInterface::~TCPInterface
	mov	eax, DWORD PTR $T9[ebp]
	jmp	$LN45@Send
$LN29@Send:

; 77   : 
; 78   : 	if (subject)

	cmp	DWORD PTR _subject$[ebp], 0
	je	SHORT $LN28@Send

; 79   : 	{
; 80   : 		sprintf(query, "Subject: %s\r\n", subject);

	mov	eax, DWORD PTR _subject$[ebp]
	push	eax
	push	OFFSET ??_C@_0O@FHPOFNAI@Subject?3?5?$CFs?$AN?6?$AA@
	lea	ecx, DWORD PTR _query$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 81   : 		tcpInterface.Send(query, (unsigned int)strlen(query), emailServer);

	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _emailServer$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _emailServer$[ebp+4]
	mov	WORD PTR [eax+4], dx
	lea	eax, DWORD PTR _query$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR _query$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _tcpInterface$[ebp]
	call	?Send@TCPInterface@@QAEXPBDIUPlayerID@@@Z ; TCPInterface::Send
$LN28@Send:

; 82   : 	}
; 83   : 	if (senderName)

	cmp	DWORD PTR _senderName$[ebp], 0
	je	SHORT $LN27@Send

; 84   : 	{
; 85   : 		sprintf(query, "From: %s\r\n", senderName);

	mov	eax, DWORD PTR _senderName$[ebp]
	push	eax
	push	OFFSET ??_C@_0L@BJCOBIPA@From?3?5?$CFs?$AN?6?$AA@
	lea	ecx, DWORD PTR _query$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 86   : 		tcpInterface.Send(query, (unsigned int)strlen(query), emailServer);

	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _emailServer$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _emailServer$[ebp+4]
	mov	WORD PTR [eax+4], dx
	lea	eax, DWORD PTR _query$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR _query$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _tcpInterface$[ebp]
	call	?Send@TCPInterface@@QAEXPBDIUPlayerID@@@Z ; TCPInterface::Send
$LN27@Send:

; 87   : 	}
; 88   : 	if (recipientName)

	cmp	DWORD PTR _recipientName$[ebp], 0
	je	SHORT $LN26@Send

; 89   : 	{
; 90   : 		sprintf(query, "To: %s\r\n", recipientName);

	mov	eax, DWORD PTR _recipientName$[ebp]
	push	eax
	push	OFFSET ??_C@_08LGKAGCMJ@To?3?5?$CFs?$AN?6?$AA@
	lea	ecx, DWORD PTR _query$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 91   : 		tcpInterface.Send(query, (unsigned int)strlen(query), emailServer);

	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _emailServer$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _emailServer$[ebp+4]
	mov	WORD PTR [eax+4], dx
	lea	eax, DWORD PTR _query$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR _query$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _tcpInterface$[ebp]
	call	?Send@TCPInterface@@QAEXPBDIUPlayerID@@@Z ; TCPInterface::Send
$LN26@Send:

; 92   : 	}
; 93   : 
; 94   : 	const char base64Map[]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

	mov	ecx, 16					; 00000010H
	mov	esi, OFFSET ??_C@_0EB@NFPJKBDG@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef@
	lea	edi, DWORD PTR _base64Map$[ebp]
	rep movsd
	movsb

; 95   : 	const int boundarySize=60;

	mov	DWORD PTR _boundarySize$[ebp], 60	; 0000003cH

; 96   : 	char boundary[boundarySize+1];
; 97   : 	int i,j;
; 98   : 	if (attachedFiles && attachedFiles->fileList.Size())

	cmp	DWORD PTR _attachedFiles$[ebp], 0
	je	$LN25@Send
	mov	ecx, DWORD PTR _attachedFiles$[ebp]
	call	?Size@?$List@UFileListNode@@@DataStructures@@QBEIXZ ; DataStructures::List<FileListNode>::Size
	test	eax, eax
	je	$LN25@Send

; 99   : 	{
; 100  : 		seedMT(RakNet::GetTime());

	call	?GetTime@RakNet@@YAIXZ			; RakNet::GetTime
	push	eax
	call	?seedMT@@YAXI@Z				; seedMT
	add	esp, 4

; 101  : 		// Random multipart message boundary
; 102  : 		for (i=0; i < boundarySize; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN24@Send
$LN23@Send:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN24@Send:
	cmp	DWORD PTR _i$[ebp], 60			; 0000003cH
	jge	SHORT $LN22@Send

; 103  : 			boundary[i]=base64Map[randomMT()%64];

	call	?randomMT@@YAIXZ			; randomMT
	xor	edx, edx
	mov	ecx, 64					; 00000040H
	div	ecx
	mov	eax, DWORD PTR _i$[ebp]
	mov	cl, BYTE PTR _base64Map$[ebp+edx]
	mov	BYTE PTR _boundary$[ebp+eax], cl
	jmp	SHORT $LN23@Send
$LN22@Send:

; 104  : 		boundary[boundarySize]=0;

	mov	eax, 1
	imul	ecx, eax, 60
	mov	DWORD PTR $T10[ebp], ecx
	cmp	DWORD PTR $T10[ebp], 61			; 0000003dH
	jae	SHORT $LN46@Send
	jmp	SHORT $LN47@Send
$LN46@Send:
	call	___report_rangecheckfailure
$LN47@Send:
	mov	edx, DWORD PTR $T10[ebp]
	mov	BYTE PTR _boundary$[ebp+edx], 0
$LN25@Send:

; 105  : 	}
; 106  : 
; 107  : 	sprintf(query, "MIME-version: 1.0\r\n");

	push	OFFSET ??_C@_0BE@EMHINEHA@MIME?9version?3?51?40?$AN?6?$AA@
	lea	eax, DWORD PTR _query$[ebp]
	push	eax
	call	_sprintf
	add	esp, 8

; 108  : 	tcpInterface.Send(query, (unsigned int)strlen(query), emailServer);

	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _emailServer$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _emailServer$[ebp+4]
	mov	WORD PTR [eax+4], dx
	lea	eax, DWORD PTR _query$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR _query$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _tcpInterface$[ebp]
	call	?Send@TCPInterface@@QAEXPBDIUPlayerID@@@Z ; TCPInterface::Send

; 109  : 
; 110  : 	if (attachedFiles && attachedFiles->fileList.Size())

	cmp	DWORD PTR _attachedFiles$[ebp], 0
	je	$LN21@Send
	mov	ecx, DWORD PTR _attachedFiles$[ebp]
	call	?Size@?$List@UFileListNode@@@DataStructures@@QBEIXZ ; DataStructures::List<FileListNode>::Size
	test	eax, eax
	je	$LN21@Send

; 111  : 	{
; 112  : 		sprintf(query, "Content-type: multipart/mixed; BOUNDARY=\"%s\"\r\n\r\n", boundary);

	lea	eax, DWORD PTR _boundary$[ebp]
	push	eax
	push	OFFSET ??_C@_0DB@ECCABOFN@Content?9type?3?5multipart?1mixed?$DL?5B@
	lea	ecx, DWORD PTR _query$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 113  : 		tcpInterface.Send(query, (unsigned int)strlen(query), emailServer);

	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _emailServer$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _emailServer$[ebp+4]
	mov	WORD PTR [eax+4], dx
	lea	eax, DWORD PTR _query$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR _query$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _tcpInterface$[ebp]
	call	?Send@TCPInterface@@QAEXPBDIUPlayerID@@@Z ; TCPInterface::Send

; 114  : 
; 115  : 		sprintf(query, "This is a multi-part message in MIME format.\r\n\r\n--%s\r\n", boundary);

	lea	eax, DWORD PTR _boundary$[ebp]
	push	eax
	push	OFFSET ??_C@_0DH@NEAHFABD@This?5is?5a?5multi?9part?5message?5in?5@
	lea	ecx, DWORD PTR _query$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 116  : 		tcpInterface.Send(query, (unsigned int)strlen(query), emailServer);

	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _emailServer$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _emailServer$[ebp+4]
	mov	WORD PTR [eax+4], dx
	lea	eax, DWORD PTR _query$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR _query$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _tcpInterface$[ebp]
	call	?Send@TCPInterface@@QAEXPBDIUPlayerID@@@Z ; TCPInterface::Send
$LN21@Send:

; 117  : 	}
; 118  : 	
; 119  : 	sprintf(query, "Content-Type: text/plain; charset=\"US-ASCII\"\r\n\r\n");

	push	OFFSET ??_C@_0DB@FKLLMGFB@Content?9Type?3?5text?1plain?$DL?5charse@
	lea	eax, DWORD PTR _query$[ebp]
	push	eax
	call	_sprintf
	add	esp, 8

; 120  : 	tcpInterface.Send(query, (unsigned int)strlen(query), emailServer);

	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _emailServer$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _emailServer$[ebp+4]
	mov	WORD PTR [eax+4], dx
	lea	eax, DWORD PTR _query$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR _query$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _tcpInterface$[ebp]
	call	?Send@TCPInterface@@QAEXPBDIUPlayerID@@@Z ; TCPInterface::Send

; 121  : 
; 122  : 	// Write the body of the email, doing some lame shitty shit where I have to make periods at the start of a newline have a second period.
; 123  : 	char *newBody;
; 124  : 	int bodyLength;
; 125  : 	bodyLength=(int)strlen(body);

	mov	eax, DWORD PTR _body$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _bodyLength$[ebp], eax

; 126  : 	newBody = new char [bodyLength*3];

	imul	eax, DWORD PTR _bodyLength$[ebp], 3
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T11[ebp], eax
	mov	ecx, DWORD PTR $T11[ebp]
	mov	DWORD PTR _newBody$[ebp], ecx

; 127  : 	if (bodyLength>0)

	cmp	DWORD PTR _bodyLength$[ebp], 0
	jle	SHORT $LN20@Send

; 128  : 		newBody[0]=body[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _newBody$[ebp]
	mov	esi, DWORD PTR _body$[ebp]
	mov	cl, BYTE PTR [esi+ecx]
	mov	BYTE PTR [edx+eax], cl
$LN20@Send:

; 129  : 	for (i=1, j=1; i < bodyLength; i++)

	mov	DWORD PTR _i$[ebp], 1
	mov	DWORD PTR _j$[ebp], 1
	jmp	SHORT $LN19@Send
$LN18@Send:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN19@Send:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _bodyLength$[ebp]
	jge	$LN17@Send

; 130  : 	{
; 131  : 		// Transform \n . \r \n into \n . . \r \n
; 132  : 		if (i < bodyLength-2 &&
; 133  : 			body[i-1]=='\n' &&
; 134  : 			body[i+0]=='.' &&
; 135  : 			body[i+1]=='\r' &&
; 136  : 			body[i+2]=='\n')

	mov	eax, DWORD PTR _bodyLength$[ebp]
	sub	eax, 2
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN16@Send
	mov	eax, DWORD PTR _body$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax-1]
	cmp	ecx, 10					; 0000000aH
	jne	$LN16@Send
	mov	eax, DWORD PTR _body$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 46					; 0000002eH
	jne	$LN16@Send
	mov	eax, DWORD PTR _body$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 13					; 0000000dH
	jne	$LN16@Send
	mov	eax, DWORD PTR _body$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax+2]
	cmp	ecx, 10					; 0000000aH
	jne	$LN16@Send

; 137  : 		{
; 138  : 			newBody[j++]='.';

	mov	eax, DWORD PTR _newBody$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	BYTE PTR [eax], 46			; 0000002eH
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx

; 139  : 			newBody[j++]='.';

	mov	eax, DWORD PTR _newBody$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	BYTE PTR [eax], 46			; 0000002eH
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx

; 140  : 			newBody[j++]='\r';

	mov	eax, DWORD PTR _newBody$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	BYTE PTR [eax], 13			; 0000000dH
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx

; 141  : 			newBody[j++]='\n';

	mov	eax, DWORD PTR _newBody$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	BYTE PTR [eax], 10			; 0000000aH
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx

; 142  : 			i+=2;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 2
	mov	DWORD PTR _i$[ebp], eax

; 143  : 		}
; 144  : 		// Transform \n . . \r \n into \n . . . \r \n
; 145  : 		// Having to process .. is a bug in the mail server - the spec says ONLY \r\n.\r\n should be transformed
; 146  : 		else if (i <= bodyLength-3 &&

	jmp	$LN15@Send
$LN16@Send:

; 147  : 			body[i-1]=='\n' &&
; 148  : 			body[i+0]=='.' &&
; 149  : 			body[i+1]=='.' &&
; 150  : 			body[i+2]=='\r' &&
; 151  : 			body[i+3]=='\n')

	mov	eax, DWORD PTR _bodyLength$[ebp]
	sub	eax, 3
	cmp	DWORD PTR _i$[ebp], eax
	jg	$LN14@Send
	mov	eax, DWORD PTR _body$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax-1]
	cmp	ecx, 10					; 0000000aH
	jne	$LN14@Send
	mov	eax, DWORD PTR _body$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 46					; 0000002eH
	jne	$LN14@Send
	mov	eax, DWORD PTR _body$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 46					; 0000002eH
	jne	$LN14@Send
	mov	eax, DWORD PTR _body$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax+2]
	cmp	ecx, 13					; 0000000dH
	jne	$LN14@Send
	mov	eax, DWORD PTR _body$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax+3]
	cmp	ecx, 10					; 0000000aH
	jne	$LN14@Send

; 152  : 		{
; 153  : 			newBody[j++]='.';

	mov	eax, DWORD PTR _newBody$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	BYTE PTR [eax], 46			; 0000002eH
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx

; 154  : 			newBody[j++]='.';

	mov	eax, DWORD PTR _newBody$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	BYTE PTR [eax], 46			; 0000002eH
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx

; 155  : 			newBody[j++]='.';

	mov	eax, DWORD PTR _newBody$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	BYTE PTR [eax], 46			; 0000002eH
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx

; 156  : 			newBody[j++]='\r';

	mov	eax, DWORD PTR _newBody$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	BYTE PTR [eax], 13			; 0000000dH
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx

; 157  : 			newBody[j++]='\n';

	mov	eax, DWORD PTR _newBody$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	BYTE PTR [eax], 10			; 0000000aH
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx

; 158  : 			i+=3;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 3
	mov	DWORD PTR _i$[ebp], eax

; 159  : 		}
; 160  : 		// Transform \n . \n into \n . . \r \n (this is a bug in the mail server - the spec says do not count \n alone but it does)
; 161  : 		else if (i < bodyLength-1 &&

	jmp	$LN15@Send
$LN14@Send:

; 162  : 			body[i-1]=='\n' &&
; 163  : 			body[i+0]=='.' &&
; 164  : 			body[i+1]=='\n')

	mov	eax, DWORD PTR _bodyLength$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN12@Send
	mov	eax, DWORD PTR _body$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax-1]
	cmp	ecx, 10					; 0000000aH
	jne	$LN12@Send
	mov	eax, DWORD PTR _body$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 46					; 0000002eH
	jne	$LN12@Send
	mov	eax, DWORD PTR _body$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 10					; 0000000aH
	jne	$LN12@Send

; 165  : 		{
; 166  : 			newBody[j++]='.';

	mov	eax, DWORD PTR _newBody$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	BYTE PTR [eax], 46			; 0000002eH
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx

; 167  : 			newBody[j++]='.';

	mov	eax, DWORD PTR _newBody$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	BYTE PTR [eax], 46			; 0000002eH
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx

; 168  : 			newBody[j++]='\r';

	mov	eax, DWORD PTR _newBody$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	BYTE PTR [eax], 13			; 0000000dH
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx

; 169  : 			newBody[j++]='\n';

	mov	eax, DWORD PTR _newBody$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	BYTE PTR [eax], 10			; 0000000aH
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx

; 170  : 			i+=1;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 171  : 		}
; 172  : 		// Transform \n . . \n into \n . . . \r \n (this is a bug in the mail server - the spec says do not count \n alone but it does)
; 173  : 		// In fact having to process .. is a bug too - because the spec says ONLY \r\n.\r\n should be transformed
; 174  : 		else if (i <= bodyLength-2 &&

	jmp	$LN15@Send
$LN12@Send:

; 175  : 			body[i-1]=='\n' &&
; 176  : 			body[i+0]=='.' &&
; 177  : 			body[i+1]=='.' &&
; 178  : 			body[i+2]=='\n')

	mov	eax, DWORD PTR _bodyLength$[ebp]
	sub	eax, 2
	cmp	DWORD PTR _i$[ebp], eax
	jg	$LN10@Send
	mov	eax, DWORD PTR _body$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax-1]
	cmp	ecx, 10					; 0000000aH
	jne	$LN10@Send
	mov	eax, DWORD PTR _body$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 46					; 0000002eH
	jne	$LN10@Send
	mov	eax, DWORD PTR _body$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 46					; 0000002eH
	jne	$LN10@Send
	mov	eax, DWORD PTR _body$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax+2]
	cmp	ecx, 10					; 0000000aH
	jne	$LN10@Send

; 179  : 		{
; 180  : 			newBody[j++]='.';

	mov	eax, DWORD PTR _newBody$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	BYTE PTR [eax], 46			; 0000002eH
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx

; 181  : 			newBody[j++]='.';

	mov	eax, DWORD PTR _newBody$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	BYTE PTR [eax], 46			; 0000002eH
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx

; 182  : 			newBody[j++]='.';

	mov	eax, DWORD PTR _newBody$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	BYTE PTR [eax], 46			; 0000002eH
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx

; 183  : 			newBody[j++]='\r';

	mov	eax, DWORD PTR _newBody$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	BYTE PTR [eax], 13			; 0000000dH
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx

; 184  : 			newBody[j++]='\n';

	mov	eax, DWORD PTR _newBody$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	BYTE PTR [eax], 10			; 0000000aH
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx

; 185  : 			i+=2;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 2
	mov	DWORD PTR _i$[ebp], eax

; 186  : 		}
; 187  : 		else

	jmp	SHORT $LN15@Send
$LN10@Send:

; 188  : 			newBody[j++]=body[i];

	mov	eax, DWORD PTR _newBody$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _body$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN15@Send:

; 189  : 	}

	jmp	$LN18@Send
$LN17@Send:

; 190  : 	
; 191  : 	newBody[j++]='\r';

	mov	eax, DWORD PTR _newBody$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	BYTE PTR [eax], 13			; 0000000dH
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx

; 192  : 	newBody[j++]='\n';

	mov	eax, DWORD PTR _newBody$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	mov	BYTE PTR [eax], 10			; 0000000aH
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx

; 193  : 	tcpInterface.Send(newBody, j, emailServer);

	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _emailServer$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _emailServer$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newBody$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _tcpInterface$[ebp]
	call	?Send@TCPInterface@@QAEXPBDIUPlayerID@@@Z ; TCPInterface::Send

; 194  : 
; 195  : 	delete [] newBody;

	mov	eax, DWORD PTR _newBody$[ebp]
	mov	DWORD PTR $T12[ebp], eax
	mov	ecx, DWORD PTR $T12[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 196  : 	int outputOffset;
; 197  : 
; 198  : 	// What a pain in the rear.  I have to map the binary to printable characters using 6 bits per character.
; 199  : 	if (attachedFiles && attachedFiles->fileList.Size())

	cmp	DWORD PTR _attachedFiles$[ebp], 0
	je	$LN8@Send
	mov	ecx, DWORD PTR _attachedFiles$[ebp]
	call	?Size@?$List@UFileListNode@@@DataStructures@@QBEIXZ ; DataStructures::List<FileListNode>::Size
	test	eax, eax
	je	$LN8@Send

; 200  : 	{
; 201  : 		for (i=0; i < (int) attachedFiles->fileList.Size(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@Send
$LN6@Send:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@Send:
	mov	ecx, DWORD PTR _attachedFiles$[ebp]
	call	?Size@?$List@UFileListNode@@@DataStructures@@QBEIXZ ; DataStructures::List<FileListNode>::Size
	cmp	DWORD PTR _i$[ebp], eax
	jge	$LN5@Send

; 202  : 		{
; 203  : 			// Write boundary
; 204  : 			sprintf(query, "\r\n--%s\r\n", boundary);

	lea	eax, DWORD PTR _boundary$[ebp]
	push	eax
	push	OFFSET ??_C@_08OOLNIKKF@?$AN?6?9?9?$CFs?$AN?6?$AA@
	lea	ecx, DWORD PTR _query$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 205  : 			tcpInterface.Send(query, (unsigned int)strlen(query), emailServer);

	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _emailServer$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _emailServer$[ebp+4]
	mov	WORD PTR [eax+4], dx
	lea	eax, DWORD PTR _query$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR _query$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _tcpInterface$[ebp]
	call	?Send@TCPInterface@@QAEXPBDIUPlayerID@@@Z ; TCPInterface::Send

; 206  : 
; 207  : 			sprintf(query, "Content-Type: APPLICATION/Octet-Stream; SizeOnDisk=%i; name=\"%s\"\r\nContent-Transfer-Encoding: BASE64\r\nContent-Description: %s\r\n\r\n", attachedFiles->fileList[i].dataLength, attachedFiles->fileList[i].filename, attachedFiles->fileList[i].filename);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _attachedFiles$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _attachedFiles$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _attachedFiles$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	edx, DWORD PTR [eax+8]
	push	edx
	push	OFFSET ??_C@_0IB@POOHHMMF@Content?9Type?3?5APPLICATION?1Octet?9@
	lea	eax, DWORD PTR _query$[ebp]
	push	eax
	call	_sprintf
	add	esp, 20					; 00000014H

; 208  : 			tcpInterface.Send(query, (unsigned int)strlen(query), emailServer);

	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _emailServer$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _emailServer$[ebp+4]
	mov	WORD PTR [eax+4], dx
	lea	eax, DWORD PTR _query$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR _query$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _tcpInterface$[ebp]
	call	?Send@TCPInterface@@QAEXPBDIUPlayerID@@@Z ; TCPInterface::Send

; 209  : 
; 210  : 			newBody = new char[(attachedFiles->fileList[i].dataLength*3)/2];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _attachedFiles$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	imul	ecx, DWORD PTR [eax+8], 3
	shr	ecx, 1
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T13[ebp], eax
	mov	edx, DWORD PTR $T13[ebp]
	mov	DWORD PTR _newBody$[ebp], edx

; 211  : 
; 212  : 			outputOffset=Base64Encoding(attachedFiles->fileList[i].data, attachedFiles->fileList[i].dataLength, newBody, base64Map);

	lea	eax, DWORD PTR _base64Map$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newBody$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _attachedFiles$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _attachedFiles$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base64Encoding@EmailSender@@QAEHPBDHPAD0@Z ; EmailSender::Base64Encoding
	mov	DWORD PTR _outputOffset$[ebp], eax

; 213  : 
; 214  : 			// Send the base64 mapped file.
; 215  : 			tcpInterface.Send(newBody, outputOffset, emailServer);

	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _emailServer$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _emailServer$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	eax, DWORD PTR _outputOffset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newBody$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _tcpInterface$[ebp]
	call	?Send@TCPInterface@@QAEXPBDIUPlayerID@@@Z ; TCPInterface::Send

; 216  : 			delete [] newBody;

	mov	eax, DWORD PTR _newBody$[ebp]
	mov	DWORD PTR $T14[ebp], eax
	mov	ecx, DWORD PTR $T14[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 217  : 
; 218  : 		}

	jmp	$LN6@Send
$LN5@Send:

; 219  : 
; 220  : 		// Write last boundary
; 221  : 		sprintf(query, "\r\n--%s--\r\n", boundary);

	lea	eax, DWORD PTR _boundary$[ebp]
	push	eax
	push	OFFSET ??_C@_0L@NAAOAPHF@?$AN?6?9?9?$CFs?9?9?$AN?6?$AA@
	lea	ecx, DWORD PTR _query$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 222  : 		tcpInterface.Send(query, (unsigned int)strlen(query), emailServer);

	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _emailServer$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _emailServer$[ebp+4]
	mov	WORD PTR [eax+4], dx
	lea	eax, DWORD PTR _query$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR _query$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _tcpInterface$[ebp]
	call	?Send@TCPInterface@@QAEXPBDIUPlayerID@@@Z ; TCPInterface::Send
$LN8@Send:

; 223  : 	}
; 224  : 
; 225  : 
; 226  : 	sprintf(query, "\r\n.\r\n");

	push	OFFSET ??_C@_05KMJPGPH@?$AN?6?4?$AN?6?$AA@
	lea	eax, DWORD PTR _query$[ebp]
	push	eax
	call	_sprintf
	add	esp, 8

; 227  : 	tcpInterface.Send(query, (unsigned int)strlen(query), emailServer);

	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _emailServer$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _emailServer$[ebp+4]
	mov	WORD PTR [eax+4], dx
	lea	eax, DWORD PTR _query$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR _query$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _tcpInterface$[ebp]
	call	?Send@TCPInterface@@QAEXPBDIUPlayerID@@@Z ; TCPInterface::Send

; 228  : 	response=GetResponse(&tcpInterface, emailServer, doPrintf);

	movzx	eax, BYTE PTR _doPrintf$[ebp]
	push	eax
	lea	ecx, DWORD PTR _emailServer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _tcpInterface$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetResponse@EmailSender@@IAEPADPAVTCPInterface@@ABUPlayerID@@_N@Z ; EmailSender::GetResponse
	mov	DWORD PTR _response$[ebp], eax

; 229  : 	if (response!=0)

	cmp	DWORD PTR _response$[ebp], 0
	je	SHORT $LN4@Send

; 230  : 		return response;

	mov	eax, DWORD PTR _response$[ebp]
	mov	DWORD PTR $T15[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tcpInterface$[ebp]
	call	??1TCPInterface@@QAE@XZ			; TCPInterface::~TCPInterface
	mov	eax, DWORD PTR $T15[ebp]
	jmp	$LN45@Send
$LN4@Send:

; 231  : 
; 232  : 	tcpInterface.Send("QUIT\r\n", (unsigned int)strlen("QUIT\r\n"), emailServer);

	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _emailServer$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _emailServer$[ebp+4]
	mov	WORD PTR [eax+4], dx
	push	OFFSET ??_C@_06FIMJICNC@QUIT?$AN?6?$AA@
	call	_strlen
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_06FIMJICNC@QUIT?$AN?6?$AA@
	lea	ecx, DWORD PTR _tcpInterface$[ebp]
	call	?Send@TCPInterface@@QAEXPBDIUPlayerID@@@Z ; TCPInterface::Send

; 233  : 
; 234  : 	RakSleep(30);

	push	30					; 0000001eH
	call	?RakSleep@@YAXI@Z			; RakSleep
	add	esp, 4

; 235  : 	if (doPrintf)

	movzx	eax, BYTE PTR _doPrintf$[ebp]
	test	eax, eax
	je	SHORT $LN3@Send

; 236  : 	{
; 237  : 		packet = tcpInterface.Receive();

	lea	ecx, DWORD PTR _tcpInterface$[ebp]
	call	?Receive@TCPInterface@@QAEPAUPacket@@XZ	; TCPInterface::Receive
	mov	DWORD PTR _packet$[ebp], eax
$LN2@Send:

; 238  : 		while (packet)

	cmp	DWORD PTR _packet$[ebp], 0
	je	SHORT $LN3@Send

; 239  : 		{
; 240  : 			printf("%s", packet->data);

	mov	eax, DWORD PTR _packet$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	push	OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
	call	_printf
	add	esp, 8

; 241  : 			packet = tcpInterface.Receive();

	lea	ecx, DWORD PTR _tcpInterface$[ebp]
	call	?Receive@TCPInterface@@QAEPAUPacket@@XZ	; TCPInterface::Receive
	mov	DWORD PTR _packet$[ebp], eax

; 242  : 		}

	jmp	SHORT $LN2@Send
$LN3@Send:

; 243  : 	}
; 244  : 	tcpInterface.Stop();

	lea	ecx, DWORD PTR _tcpInterface$[ebp]
	call	?Stop@TCPInterface@@QAEXXZ		; TCPInterface::Stop

; 245  : 	return 0; // Success

	mov	DWORD PTR $T16[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tcpInterface$[ebp]
	call	??1TCPInterface@@QAE@XZ			; TCPInterface::~TCPInterface
	mov	eax, DWORD PTR $T16[ebp]
$LN45@Send:

; 246  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN56@Send
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 1884				; 0000075cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	40					; 00000028H
	npad	2
$LN56@Send:
	DD	5
	DD	$LN55@Send
$LN55@Send:
	DD	-1068					; fffffbd4H
	DD	1024					; 00000400H
	DD	$LN49@Send
	DD	-1256					; fffffb18H
	DD	167					; 000000a7H
	DD	$LN50@Send
	DD	-1272					; fffffb08H
	DD	6
	DD	$LN51@Send
	DD	-1360					; fffffab0H
	DD	65					; 00000041H
	DD	$LN52@Send
	DD	-1444					; fffffa5cH
	DD	61					; 0000003dH
	DD	$LN53@Send
$LN53@Send:
	DB	98					; 00000062H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	121					; 00000079H
	DB	0
$LN52@Send:
	DB	98					; 00000062H
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	54					; 00000036H
	DB	52					; 00000034H
	DB	77					; 0000004dH
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	0
$LN51@Send:
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	83					; 00000053H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$LN50@Send:
	DB	116					; 00000074H
	DB	99					; 00000063H
	DB	112					; 00000070H
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	102					; 00000066H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	0
$LN49@Send:
	DB	113					; 00000071H
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	121					; 00000079H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Send@EmailSender@@QAEPADPBDG000000PAVFileList@@_N@Z$0:
	lea	ecx, DWORD PTR _tcpInterface$[ebp]
	jmp	??1TCPInterface@@QAE@XZ			; TCPInterface::~TCPInterface
__ehhandler$?Send@EmailSender@@QAEPADPBDG000000PAVFileList@@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1888]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Send@EmailSender@@QAEPADPBDG000000PAVFileList@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Send@EmailSender@@QAEPADPBDG000000PAVFileList@@_N@Z ENDP ; EmailSender::Send
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\networktypes.h
;	COMDAT ??4PlayerID@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_input$ = 8						; size = 4
??4PlayerID@@QAEAAU0@ABU0@@Z PROC			; PlayerID::operator=, COMDAT
; _this$ = ecx

; 74   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 75   : 		binaryAddress = input.binaryAddress;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 76   : 		port = input.port;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _input$[ebp]
	mov	dx, WORD PTR [ecx+4]
	mov	WORD PTR [eax+4], dx

; 77   : 		return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 78   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4PlayerID@@QAEAAU0@ABU0@@Z ENDP			; PlayerID::operator=
_TEXT	ENDS
END
