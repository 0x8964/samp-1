; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.31101.0 

	TITLE	Z:\sampsrc\02Xu1\raknet\DS_HuffmanEncodingTree.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ	; RakNet::BitStream::GetNumberOfBitsUsed
PUBLIC	?GetWriteOffset@BitStream@RakNet@@QBEHXZ	; RakNet::BitStream::GetWriteOffset
PUBLIC	??0HuffmanEncodingTree@@QAE@XZ			; HuffmanEncodingTree::HuffmanEncodingTree
PUBLIC	??1HuffmanEncodingTree@@QAE@XZ			; HuffmanEncodingTree::~HuffmanEncodingTree
PUBLIC	?EncodeArray@HuffmanEncodingTree@@QAEXPAEIPAVBitStream@RakNet@@@Z ; HuffmanEncodingTree::EncodeArray
PUBLIC	?DecodeArray@HuffmanEncodingTree@@QAEIPAVBitStream@RakNet@@IIPAE@Z ; HuffmanEncodingTree::DecodeArray
PUBLIC	?DecodeArray@HuffmanEncodingTree@@QAEXPAEIPAVBitStream@RakNet@@@Z ; HuffmanEncodingTree::DecodeArray
PUBLIC	?GenerateFromFrequencyTable@HuffmanEncodingTree@@QAEXQAI@Z ; HuffmanEncodingTree::GenerateFromFrequencyTable
PUBLIC	?FreeMemory@HuffmanEncodingTree@@QAEXXZ		; HuffmanEncodingTree::FreeMemory
PUBLIC	?InsertNodeIntoSortedList@HuffmanEncodingTree@@ABEXPAUHuffmanEncodingTreeNode@@PAV?$LinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@@Z ; HuffmanEncodingTree::InsertNodeIntoSortedList
PUBLIC	??0?$Queue@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAE@XZ ; DataStructures::Queue<HuffmanEncodingTreeNode *>::Queue<HuffmanEncodingTreeNode *>
PUBLIC	??1?$Queue@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAE@XZ ; DataStructures::Queue<HuffmanEncodingTreeNode *>::~Queue<HuffmanEncodingTreeNode *>
PUBLIC	?Push@?$Queue@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEXABQAUHuffmanEncodingTreeNode@@@Z ; DataStructures::Queue<HuffmanEncodingTreeNode *>::Push
PUBLIC	?Pop@?$Queue@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEPAUHuffmanEncodingTreeNode@@XZ ; DataStructures::Queue<HuffmanEncodingTreeNode *>::Pop
PUBLIC	?Size@?$Queue@PAUHuffmanEncodingTreeNode@@@DataStructures@@QBEIXZ ; DataStructures::Queue<HuffmanEncodingTreeNode *>::Size
PUBLIC	??0?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAE@XZ ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::CircularLinkedList<HuffmanEncodingTreeNode *>
PUBLIC	??1?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAE@XZ ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::~CircularLinkedList<HuffmanEncodingTreeNode *>
PUBLIC	?Insert@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEXABQAUHuffmanEncodingTreeNode@@@Z ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::Insert
PUBLIC	?Add@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEAAPAUHuffmanEncodingTreeNode@@ABQAU3@@Z ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::Add
PUBLIC	?Del@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEXXZ ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::Del
PUBLIC	?Size@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEIXZ ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::Size
PUBLIC	?Peek@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEAAPAUHuffmanEncodingTreeNode@@XZ ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::Peek
PUBLIC	?Pop@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEPAUHuffmanEncodingTreeNode@@XZ ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::Pop
PUBLIC	?Clear@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEXXZ ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::Clear
PUBLIC	?Beginning@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEXXZ ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::Beginning
PUBLIC	?End@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEXXZ ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::End
PUBLIC	??0?$LinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAE@XZ ; DataStructures::LinkedList<HuffmanEncodingTreeNode *>::LinkedList<HuffmanEncodingTreeNode *>
PUBLIC	??1?$LinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAE@XZ ; DataStructures::LinkedList<HuffmanEncodingTreeNode *>::~LinkedList<HuffmanEncodingTreeNode *>
PUBLIC	??E?$LinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEAAV01@XZ ; DataStructures::LinkedList<HuffmanEncodingTreeNode *>::operator++
PUBLIC	?__LINE__Var@?1??EncodeArray@HuffmanEncodingTree@@QAEXPAEIPAVBitStream@RakNet@@@Z@4JA ; `HuffmanEncodingTree::EncodeArray'::`2'::__LINE__Var
PUBLIC	??_C@_1GG@GEMENPHH@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAh?$AAu?$AAf?$AAf?$AAm@ ; `string'
PUBLIC	??_C@_1BO@DNOOEHMA@?$AAc?$AAo?$AAu?$AAn?$AAt?$AAe?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA2?$AA5?$AA6?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@ ; `string'
PUBLIC	??_C@_1BE@OMEGJCHO@?$AAn?$AAe?$AAw?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?$AA@ ; `string'
PUBLIC	??_C@_1GG@JDEIIJCO@?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN@ ; `string'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__wassert:PROC
EXTRN	??0BitStream@RakNet@@QAE@XZ:PROC		; RakNet::BitStream::BitStream
EXTRN	??0BitStream@RakNet@@QAE@PAEI_N@Z:PROC		; RakNet::BitStream::BitStream
EXTRN	??1BitStream@RakNet@@QAE@XZ:PROC		; RakNet::BitStream::~BitStream
EXTRN	?Reset@BitStream@RakNet@@QAEXXZ:PROC		; RakNet::BitStream::Reset
EXTRN	?CopyData@BitStream@RakNet@@QBEHPAPAE@Z:PROC	; RakNet::BitStream::CopyData
EXTRN	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z:PROC	; RakNet::BitStream::WriteBits
EXTRN	?Write0@BitStream@RakNet@@QAEXXZ:PROC		; RakNet::BitStream::Write0
EXTRN	?Write1@BitStream@RakNet@@QAEXXZ:PROC		; RakNet::BitStream::Write1
EXTRN	?ReadBit@BitStream@RakNet@@QAE_NXZ:PROC		; RakNet::BitStream::ReadBit
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_1GG@JDEIIJCO@?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN@
CONST	SEGMENT
??_C@_1GG@JDEIIJCO@?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN@ DB 'a'
	DB	00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H
	DB	'i', 00H, 'o', 00H, 'n', 00H, '_', 00H, 's', 00H, 'i', 00H, 'z'
	DB	00H, 'e', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e'
	DB	00H, '(', 00H, ')', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H
	DB	'0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'h', 00H, 'e'
	DB	00H, 'a', 00H, 'd', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H
	DB	't', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@OMEGJCHO@?$AAn?$AAe?$AAw?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@OMEGJCHO@?$AAn?$AAe?$AAw?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?$AA@ DB 'n'
	DB	00H, 'e', 00H, 'w', 00H, '_', 00H, 'a', 00H, 'r', 00H, 'r', 00H
	DB	'a', 00H, 'y', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@
CONST	SEGMENT
??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@ DB 'z'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H
	DB	's', 00H, 'r', 00H, 'c', 00H, '\', 00H, '0', 00H, '2', 00H, 'x'
	DB	00H, 'u', 00H, '1', 00H, '\', 00H, 'r', 00H, 'a', 00H, 'k', 00H
	DB	'n', 00H, 'e', 00H, 't', 00H, '\', 00H, 'd', 00H, 's', 00H, '_'
	DB	00H, 'q', 00H, 'u', 00H, 'e', 00H, 'u', 00H, 'e', 00H, '.', 00H
	DB	'h', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@DNOOEHMA@?$AAc?$AAo?$AAu?$AAn?$AAt?$AAe?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA2?$AA5?$AA6?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@DNOOEHMA@?$AAc?$AAo?$AAu?$AAn?$AAt?$AAe?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA2?$AA5?$AA6?$AA?$AA@ DB 'c'
	DB	00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H
	DB	' ', 00H, '!', 00H, '=', 00H, ' ', 00H, '2', 00H, '5', 00H, '6'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1GG@GEMENPHH@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAh?$AAu?$AAf?$AAf?$AAm@
CONST	SEGMENT
??_C@_1GG@GEMENPHH@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAh?$AAu?$AAf?$AAf?$AAm@ DB 'z'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H
	DB	's', 00H, 'r', 00H, 'c', 00H, '\', 00H, '0', 00H, '2', 00H, 'x'
	DB	00H, 'u', 00H, '1', 00H, '\', 00H, 'r', 00H, 'a', 00H, 'k', 00H
	DB	'n', 00H, 'e', 00H, 't', 00H, '\', 00H, 'd', 00H, 's', 00H, '_'
	DB	00H, 'h', 00H, 'u', 00H, 'f', 00H, 'f', 00H, 'm', 00H, 'a', 00H
	DB	'n', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'i'
	DB	00H, 'n', 00H, 'g', 00H, 't', 00H, 'r', 00H, 'e', 00H, 'e', 00H
	DB	'.', 00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??EncodeArray@HuffmanEncodingTree@@QAEXPAEIPAVBitStream@RakNet@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??EncodeArray@HuffmanEncodingTree@@QAEXPAEIPAVBitStream@RakNet@@@Z@4JA DD 0b0H ; `HuffmanEncodingTree::EncodeArray'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$LinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$LinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAE@XZ$0
__ehfuncinfo$??1?$LinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$LinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?FreeMemory@HuffmanEncodingTree@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FreeMemory@HuffmanEncodingTree@@QAEXXZ$0
__ehfuncinfo$?FreeMemory@HuffmanEncodingTree@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FreeMemory@HuffmanEncodingTree@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GenerateFromFrequencyTable@HuffmanEncodingTree@@QAEXQAI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GenerateFromFrequencyTable@HuffmanEncodingTree@@QAEXQAI@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GenerateFromFrequencyTable@HuffmanEncodingTree@@QAEXQAI@Z$1
__ehfuncinfo$?GenerateFromFrequencyTable@HuffmanEncodingTree@@QAEXQAI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GenerateFromFrequencyTable@HuffmanEncodingTree@@QAEXQAI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?DecodeArray@HuffmanEncodingTree@@QAEXPAEIPAVBitStream@RakNet@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DecodeArray@HuffmanEncodingTree@@QAEXPAEIPAVBitStream@RakNet@@@Z$0
__ehfuncinfo$?DecodeArray@HuffmanEncodingTree@@QAEXPAEIPAVBitStream@RakNet@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DecodeArray@HuffmanEncodingTree@@QAEXPAEIPAVBitStream@RakNet@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_linkedlist.h
;	COMDAT ??E?$LinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??E?$LinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEAAV01@XZ PROC ; DataStructures::LinkedList<HuffmanEncodingTreeNode *>::operator++, COMDAT
; _this$ = ecx

; 1198 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1199 : 		if ( ( this->list_size != 0 ) && ( this->position->next != this->root ) )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	cmp	eax, DWORD PTR [edx+4]
	je	SHORT $LN1@operator

; 1200 : 			this->position = this->position->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
$LN1@operator:

; 1201 : 
; 1202 : 		return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1203 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$LinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEAAV01@XZ ENDP ; DataStructures::LinkedList<HuffmanEncodingTreeNode *>::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_linkedlist.h
;	COMDAT ??1?$LinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$LinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAE@XZ PROC ; DataStructures::LinkedList<HuffmanEncodingTreeNode *>::~LinkedList<HuffmanEncodingTreeNode *>, COMDAT
; _this$ = ecx

; 361  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$LinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 362  : 		this->Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEXXZ ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::Clear

; 363  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAE@XZ ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::~CircularLinkedList<HuffmanEncodingTreeNode *>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$LinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAE@XZ ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::~CircularLinkedList<HuffmanEncodingTreeNode *>
__ehhandler$??1?$LinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$LinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$LinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAE@XZ ENDP ; DataStructures::LinkedList<HuffmanEncodingTreeNode *>::~LinkedList<HuffmanEncodingTreeNode *>
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_linkedlist.h
;	COMDAT ??0?$LinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$LinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAE@XZ PROC ; DataStructures::LinkedList<HuffmanEncodingTreeNode *>::LinkedList<HuffmanEncodingTreeNode *>, COMDAT
; _this$ = ecx

; 222  : 		LinkedList()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAE@XZ ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::CircularLinkedList<HuffmanEncodingTreeNode *>
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$LinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAE@XZ ENDP ; DataStructures::LinkedList<HuffmanEncodingTreeNode *>::LinkedList<HuffmanEncodingTreeNode *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_linkedlist.h
;	COMDAT ?End@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?End@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEXXZ PROC ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::End, COMDAT
; _this$ = ecx

; 249  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 250  : 		if ( this->root )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN2@End

; 251  : 			this->position = this->root->previous;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+8], eax
$LN2@End:

; 252  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?End@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEXXZ ENDP ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::End
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_linkedlist.h
;	COMDAT ?Beginning@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Beginning@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEXXZ PROC ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::Beginning, COMDAT
; _this$ = ecx

; 242  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 243  : 		if ( this->root )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN2@Beginning

; 244  : 			this->position = this->root;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+8], edx
$LN2@Beginning:

; 245  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Beginning@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEXXZ ENDP ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::Beginning
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_linkedlist.h
;	COMDAT ?Clear@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEXXZ
_TEXT	SEGMENT
$T1 = -248						; size = 4
$T2 = -236						; size = 4
_temp$3 = -32						; size = 4
_current$4 = -20					; size = 4
_this$ = -8						; size = 4
?Clear@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEXXZ PROC ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::Clear, COMDAT
; _this$ = ecx

; 959  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 960  : 		if ( this->list_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN7@Clear

; 961  : 			return ;

	jmp	SHORT $LN8@Clear

; 962  : 		else

	jmp	SHORT $LN6@Clear
$LN7@Clear:

; 963  : 			if ( this->list_size == 1 )  // {delete root->item; delete root;}

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN5@Clear

; 964  : 			{
; 965  : 				delete this->root;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 966  : 			}
; 967  : 
; 968  : 			else

	jmp	SHORT $LN6@Clear
$LN5@Clear:

; 969  : 			{
; 970  : 				node* current;
; 971  : 				node* temp;
; 972  : 
; 973  : 				current = this->root;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _current$4[ebp], ecx
$LN3@Clear:

; 974  : 
; 975  : 				do
; 976  : 				{
; 977  : 					temp = current;

	mov	eax, DWORD PTR _current$4[ebp]
	mov	DWORD PTR _temp$3[ebp], eax

; 978  : 					current = current->next;

	mov	eax, DWORD PTR _current$4[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _current$4[ebp], ecx

; 979  : 					// delete temp->item;
; 980  : 					delete temp;

	mov	eax, DWORD PTR _temp$3[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 981  : 				}
; 982  : 
; 983  : 				while ( current != this->root );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _current$4[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN3@Clear
$LN6@Clear:

; 984  : 			}
; 985  : 
; 986  : 			this->list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 987  : 			this->root = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 988  : 			this->position = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
$LN8@Clear:

; 989  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEXXZ ENDP ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_linkedlist.h
;	COMDAT ?Pop@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEPAUHuffmanEncodingTreeNode@@XZ
_TEXT	SEGMENT
_element$ = -20						; size = 4
_this$ = -8						; size = 4
?Pop@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEPAUHuffmanEncodingTreeNode@@XZ PROC ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::Pop, COMDAT
; _this$ = ecx

; 894  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 895  : 		CircularLinkedListType element;
; 896  : 		element = Peek();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Peek@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEAAPAUHuffmanEncodingTreeNode@@XZ ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::Peek
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _element$[ebp], eax

; 897  : 		Del();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Del@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEXXZ ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::Del

; 898  : 		return CircularLinkedListType( element ); // return temporary

	mov	eax, DWORD PTR _element$[ebp]

; 899  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Pop@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEPAUHuffmanEncodingTreeNode@@XZ ENDP ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::Pop
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_linkedlist.h
;	COMDAT ?Peek@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEAAPAUHuffmanEncodingTreeNode@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Peek@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEAAPAUHuffmanEncodingTreeNode@@XZ PROC ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::Peek, COMDAT
; _this$ = ecx

; 887  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 888  : 		// return *(position->item);
; 889  : 		return this->position->item;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 890  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Peek@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEAAPAUHuffmanEncodingTreeNode@@XZ ENDP ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::Peek
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_linkedlist.h
;	COMDAT ?Size@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEIXZ PROC ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::Size, COMDAT
; _this$ = ecx

; 881  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 882  : 		return this->list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 883  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEIXZ ENDP ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_linkedlist.h
;	COMDAT ?Del@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEXXZ
_TEXT	SEGMENT
$T1 = -236						; size = 4
$T2 = -224						; size = 4
_new_position$ = -20					; size = 4
_this$ = -8						; size = 4
?Del@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEXXZ PROC ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::Del, COMDAT
; _this$ = ecx

; 785  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 786  : 		node * new_position;
; 787  : 
; 788  : 		if ( this->list_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN5@Del

; 789  : 			return ;

	jmp	$LN6@Del

; 790  : 
; 791  : 		else

	jmp	$LN6@Del
$LN5@Del:

; 792  : 			if ( this->list_size == 1 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN3@Del

; 793  : 			{
; 794  : 				// delete root->item;
; 795  : 				delete this->root;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 796  : 				this->root = this->position = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 797  : 				this->list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 798  : 			}
; 799  : 
; 800  : 			else

	jmp	SHORT $LN6@Del
$LN3@Del:

; 801  : 			{
; 802  : 				( this->position->previous ) ->next = this->position->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax

; 803  : 				( this->position->next ) ->previous = this->position->previous;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax

; 804  : 				new_position = this->position->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _new_position$[ebp], edx

; 805  : 
; 806  : 				if ( this->position == this->root )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN1@Del

; 807  : 					this->root = new_position;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_position$[ebp]
	mov	DWORD PTR [eax+4], ecx
$LN1@Del:

; 808  : 
; 809  : 				// delete position->item;
; 810  : 				delete this->position;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 811  : 
; 812  : 				this->position = new_position;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_position$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 813  : 
; 814  : 				this->list_size--;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
$LN6@Del:

; 815  : 			}
; 816  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Del@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEXXZ ENDP ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::Del
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_linkedlist.h
;	COMDAT ?Add@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEAAPAUHuffmanEncodingTreeNode@@ABQAU3@@Z
_TEXT	SEGMENT
$T1 = -248						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_new_node$ = -20					; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
?Add@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEAAPAUHuffmanEncodingTreeNode@@ABQAU3@@Z PROC ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::Add, COMDAT
; _this$ = ecx

; 701  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 702  : 		node * new_node;
; 703  : 
; 704  : 		if ( this->list_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN4@Add

; 705  : 		{
; 706  : 			this->root = new typename CircularLinkedList::node;

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax+4], ecx

; 707  : 			// root->item = new CircularLinkedListType;
; 708  : 			// *(root->item)=input;
; 709  : 			this->root->item = input;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _input$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 710  : 			this->root->next = this->root;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+8], eax

; 711  : 			this->root->previous = this->root;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 712  : 			this->list_size = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 1

; 713  : 			this->position = this->root;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+8], edx

; 714  : 			// return *(position->item);
; 715  : 			return this->position->item;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	jmp	$LN5@Add

; 716  : 		}
; 717  : 
; 718  : 		else

	jmp	$LN5@Add
$LN4@Add:

; 719  : 			if ( list_size == 1 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 1
	jne	$LN2@Add

; 720  : 			{
; 721  : 				this->position = new typename CircularLinkedList::node;

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [eax+8], ecx

; 722  : 				// position->item = new CircularLinkedListType;
; 723  : 				this->root->next = this->position;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax

; 724  : 				this->root->previous = this->position;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+4], eax

; 725  : 				this->position->previous = this->root;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 726  : 				this->position->next = this->root;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+8], eax

; 727  : 				// *(position->item)=input;
; 728  : 				this->position->item = input;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _input$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 729  : 				this->list_size = 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 2

; 730  : 				this->position = this->root; // Don't move the position from the root

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+8], edx

; 731  : 				// return *(position->item);
; 732  : 				return this->position->item;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN5@Add

; 733  : 			}
; 734  : 
; 735  : 			else

	jmp	SHORT $LN5@Add
$LN2@Add:

; 736  : 			{
; 737  : 				/*
; 738  : 
; 739  : 				   B
; 740  : 			       |
; 741  : 				A --- C
; 742  : 
; 743  : 				new_node=B
; 744  : 				position=A
; 745  : 				position->next=C
; 746  : 
; 747  : 				Note that the order of the following statements is important  */
; 748  : 
; 749  : 				new_node = new typename CircularLinkedList::node;

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR _new_node$[ebp], eax

; 750  : 				// new_node->item = new CircularLinkedListType;
; 751  : 
; 752  : 				// *(new_node->item)=input;
; 753  : 				new_node->item = input;

	mov	eax, DWORD PTR _new_node$[ebp]
	mov	ecx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 754  : 
; 755  : 				// Point last of B to A
; 756  : 				new_node->previous = this->position;

	mov	eax, DWORD PTR _new_node$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+4], edx

; 757  : 
; 758  : 				// Point next of B to C
; 759  : 				new_node->next = ( this->position->next );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _new_node$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax

; 760  : 
; 761  : 				// Point last of C to B
; 762  : 				( this->position->next ) ->previous = new_node;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _new_node$[ebp]
	mov	DWORD PTR [edx+4], eax

; 763  : 
; 764  : 				// Point next of A to B
; 765  : 				( this->position->next ) = new_node;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _new_node$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 766  : 
; 767  : 				// Increase the recorded size of the list by one
; 768  : 				this->list_size++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 769  : 
; 770  : 				// return *(new_node->item);
; 771  : 				return new_node->item;

	mov	eax, DWORD PTR _new_node$[ebp]
$LN5@Add:

; 772  : 			}
; 773  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Add@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEAAPAUHuffmanEncodingTreeNode@@ABQAU3@@Z ENDP ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::Add
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_linkedlist.h
;	COMDAT ?Insert@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEXABQAUHuffmanEncodingTreeNode@@@Z
_TEXT	SEGMENT
$T1 = -248						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_new_node$ = -20					; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
?Insert@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEXABQAUHuffmanEncodingTreeNode@@@Z PROC ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::Insert, COMDAT
; _this$ = ecx

; 624  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 625  : 		node * new_node;
; 626  : 
; 627  : 		if ( list_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN5@Insert

; 628  : 		{
; 629  : 			this->root = new typename CircularLinkedList::node;

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax+4], ecx

; 630  : 			// root->item = new CircularLinkedListType;
; 631  : 			//*(root->item)=input;
; 632  : 			this->root->item = input;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _input$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 633  : 			this->root->next = this->root;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+8], eax

; 634  : 			this->root->previous = this->root;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 635  : 			this->list_size = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 1

; 636  : 			this->position = this->root;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+8], edx

; 637  : 		}
; 638  : 
; 639  : 		else

	jmp	$LN6@Insert
$LN5@Insert:

; 640  : 			if ( list_size == 1 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN3@Insert

; 641  : 			{
; 642  : 				this->position = new typename CircularLinkedList::node;

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [eax+8], ecx

; 643  : 				// position->item = new CircularLinkedListType;
; 644  : 				this->root->next = this->position;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax

; 645  : 				this->root->previous = this->position;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+4], eax

; 646  : 				this->position->previous = this->root;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 647  : 				this->position->next = this->root;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+8], eax

; 648  : 				// *(position->item)=input;
; 649  : 				this->position->item = input;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _input$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 650  : 				this->root = this->position; // Since we're inserting into a 1 element list the old root is now the second item

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+4], edx

; 651  : 				this->list_size = 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 2

; 652  : 			}
; 653  : 
; 654  : 			else

	jmp	$LN6@Insert
$LN3@Insert:

; 655  : 			{
; 656  : 				/*
; 657  : 
; 658  : 				B
; 659  : 				|
; 660  : 				A --- C
; 661  : 
; 662  : 				position->previous=A
; 663  : 				new_node=B
; 664  : 				position=C
; 665  : 
; 666  : 				Note that the order of the following statements is important  */
; 667  : 
; 668  : 				new_node = new typename CircularLinkedList::node;

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR _new_node$[ebp], eax

; 669  : 				// new_node->item = new CircularLinkedListType;
; 670  : 
; 671  : 				// *(new_node->item)=input;
; 672  : 				new_node->item = input;

	mov	eax, DWORD PTR _new_node$[ebp]
	mov	ecx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 673  : 
; 674  : 				// Point next of A to B
; 675  : 				( this->position->previous ) ->next = new_node;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _new_node$[ebp]
	mov	DWORD PTR [edx+8], eax

; 676  : 
; 677  : 				// Point last of B to A
; 678  : 				new_node->previous = this->position->previous;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _new_node$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax

; 679  : 
; 680  : 				// Point last of C to B
; 681  : 				this->position->previous = new_node;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _new_node$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 682  : 
; 683  : 				// Point next of B to C
; 684  : 				new_node->next = this->position;

	mov	eax, DWORD PTR _new_node$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 685  : 
; 686  : 				// Since the root pointer is bound to a node rather than an index this moves it back if you insert an element at the root
; 687  : 
; 688  : 				if ( this->position == this->root )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN1@Insert

; 689  : 				{
; 690  : 					this->root = new_node;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_node$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 691  : 					this->position = this->root;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+8], edx
$LN1@Insert:

; 692  : 				}
; 693  : 
; 694  : 				// Increase the recorded size of the list by one
; 695  : 				this->list_size++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
$LN6@Insert:

; 696  : 			}
; 697  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Insert@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEXABQAUHuffmanEncodingTreeNode@@@Z ENDP ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::Insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_linkedlist.h
;	COMDAT ??1?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAE@XZ PROC ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::~CircularLinkedList<HuffmanEncodingTreeNode *>, COMDAT
; _this$ = ecx

; 355  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 356  : 		this->Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEXXZ ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::Clear

; 357  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAE@XZ ENDP ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::~CircularLinkedList<HuffmanEncodingTreeNode *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_linkedlist.h
;	COMDAT ??0?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAE@XZ PROC ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::CircularLinkedList<HuffmanEncodingTreeNode *>, COMDAT
; _this$ = ecx

; 347  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 348  : 		this->root = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 349  : 		this->position = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 350  : 		this->list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 351  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAE@XZ ENDP ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::CircularLinkedList<HuffmanEncodingTreeNode *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ?Size@?$Queue@PAUHuffmanEncodingTreeNode@@@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$Queue@PAUHuffmanEncodingTreeNode@@@DataStructures@@QBEIXZ PROC ; DataStructures::Queue<HuffmanEncodingTreeNode *>::Size, COMDAT
; _this$ = ecx

; 62   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 63   : 		if ( head <= tail )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	ja	SHORT $LN2@Size

; 64   : 			return tail -head;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	jmp	SHORT $LN3@Size

; 65   : 		else

	jmp	SHORT $LN3@Size
$LN2@Size:

; 66   : 			return allocation_size -head + tail;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx+8]
$LN3@Size:

; 67   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$Queue@PAUHuffmanEncodingTreeNode@@@DataStructures@@QBEIXZ ENDP ; DataStructures::Queue<HuffmanEncodingTreeNode *>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ?Pop@?$Queue@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEPAUHuffmanEncodingTreeNode@@XZ
_TEXT	SEGMENT
tv78 = -208						; size = 4
_this$ = -8						; size = 4
?Pop@?$Queue@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEPAUHuffmanEncodingTreeNode@@XZ PROC ; DataStructures::Queue<HuffmanEncodingTreeNode *>::Pop, COMDAT
; _this$ = ecx

; 99   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 100  : #ifdef _DEBUG
; 101  : 		assert( allocation_size > 0 && Size() >= 0 && head != tail);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jbe	SHORT $LN5@Pop
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$Queue@PAUHuffmanEncodingTreeNode@@@DataStructures@@QBEIXZ ; DataStructures::Queue<HuffmanEncodingTreeNode *>::Size
	test	eax, eax
	jb	SHORT $LN5@Pop
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN6@Pop
$LN5@Pop:
	push	101					; 00000065H
	push	OFFSET ??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@
	push	OFFSET ??_C@_1GG@JDEIIJCO@?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN6@Pop:

; 102  : #endif
; 103  : 		//head=(head+1) % allocation_size;
; 104  : 
; 105  : 		if ( ++head == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	DWORD PTR tv78[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv78[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv78[ebp]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN2@Pop

; 106  : 			head = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
$LN2@Pop:

; 107  : 
; 108  : 		if ( head == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN1@Pop

; 109  : 			return ( queue_type ) array[ allocation_size -1 ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+ecx*4-4]
	jmp	SHORT $LN3@Pop
$LN1@Pop:

; 110  : 
; 111  : 		return ( queue_type ) array[ head -1 ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+ecx*4-4]
$LN3@Pop:

; 112  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Pop@?$Queue@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEPAUHuffmanEncodingTreeNode@@XZ ENDP ; DataStructures::Queue<HuffmanEncodingTreeNode *>::Pop
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ?Push@?$Queue@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEXABQAUHuffmanEncodingTreeNode@@@Z
_TEXT	SEGMENT
$T1 = -260						; size = 4
$T2 = -248						; size = 4
$T3 = -236						; size = 4
_counter$4 = -32					; size = 4
_new_array$5 = -20					; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
?Push@?$Queue@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEXABQAUHuffmanEncodingTreeNode@@@Z PROC ; DataStructures::Queue<HuffmanEncodingTreeNode *>::Push, COMDAT
; _this$ = ecx

; 182  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 183  : 		if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN6@Push

; 184  : 		{
; 185  : 			array = new queue_type[ 16 ];

	push	64					; 00000040H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax], ecx

; 186  : 			head = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 187  : 			tail = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 1

; 188  : 			array[ 0 ] = input;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+eax], edx

; 189  : 			allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 16			; 00000010H

; 190  : 			return ;

	jmp	$LN7@Push
$LN6@Push:

; 191  : 		}
; 192  : 
; 193  : 		array[ tail++ ] = input;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [eax+ecx*4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 194  : 
; 195  : 		if ( tail == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN5@Push

; 196  : 			tail = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
$LN5@Push:

; 197  : 
; 198  : 		if ( tail == head )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+4]
	jne	$LN7@Push

; 199  : 		{
; 200  : 			//  unsigned int index=tail;
; 201  : 
; 202  : 			// Need to allocate more memory.
; 203  : 			queue_type * new_array;
; 204  : 			new_array = new queue_type[ allocation_size * 2 ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	shl	eax, 1
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _new_array$5[ebp], eax

; 205  : #ifdef _DEBUG
; 206  : 
; 207  : 			assert( new_array );

	cmp	DWORD PTR _new_array$5[ebp], 0
	jne	SHORT $LN9@Push
	push	207					; 000000cfH
	push	OFFSET ??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@
	push	OFFSET ??_C@_1BE@OMEGJCHO@?$AAn?$AAe?$AAw?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN9@Push:

; 208  : #endif
; 209  : 
; 210  : 			for ( unsigned int counter = 0; counter < allocation_size; ++counter )

	mov	DWORD PTR _counter$4[ebp], 0
	jmp	SHORT $LN3@Push
$LN2@Push:
	mov	eax, DWORD PTR _counter$4[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$4[ebp], eax
$LN3@Push:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _counter$4[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN1@Push

; 211  : 				new_array[ counter ] = array[ ( head + counter ) % ( allocation_size ) ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, DWORD PTR _counter$4[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _counter$4[ebp]
	mov	esi, DWORD PTR _new_array$5[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [esi+eax*4], ecx
	jmp	SHORT $LN2@Push
$LN1@Push:

; 212  : 
; 213  : 			head = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 214  : 
; 215  : 			tail = allocation_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+8], edx

; 216  : 
; 217  : 			allocation_size *= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 218  : 
; 219  : 			// Delete the old array and move the pointer to the new array
; 220  : 			delete [] array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T3[ebp], ecx
	mov	edx, DWORD PTR $T3[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 221  : 
; 222  : 			array = new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$5[ebp]
	mov	DWORD PTR [eax], ecx
$LN7@Push:

; 223  : 		}
; 224  : 
; 225  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Push@?$Queue@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEXABQAUHuffmanEncodingTreeNode@@@Z ENDP ; DataStructures::Queue<HuffmanEncodingTreeNode *>::Push
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ??1?$Queue@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
??1?$Queue@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAE@XZ PROC ; DataStructures::Queue<HuffmanEncodingTreeNode *>::~Queue<HuffmanEncodingTreeNode *>, COMDAT
; _this$ = ecx

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		if (allocation_size>0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jbe	SHORT $LN2@Queue

; 94   : 			delete [] array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@Queue:

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$Queue@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAE@XZ ENDP ; DataStructures::Queue<HuffmanEncodingTreeNode *>::~Queue<HuffmanEncodingTreeNode *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ??0?$Queue@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
??0?$Queue@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAE@XZ PROC ; DataStructures::Queue<HuffmanEncodingTreeNode *>::Queue<HuffmanEncodingTreeNode *>, COMDAT
; _this$ = ecx

; 83   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 84   : 		allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 16			; 00000010H

; 85   : 		array = new queue_type[ allocation_size ];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax], ecx

; 86   : 		head = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 87   : 		tail = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 88   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$Queue@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAE@XZ ENDP ; DataStructures::Queue<HuffmanEncodingTreeNode *>::Queue<HuffmanEncodingTreeNode *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_huffmanencodingtree.cpp
;	COMDAT ?InsertNodeIntoSortedList@HuffmanEncodingTree@@ABEXPAUHuffmanEncodingTreeNode@@PAV?$LinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@@Z
_TEXT	SEGMENT
_counter$ = -20						; size = 4
_this$ = -8						; size = 4
_node$ = 8						; size = 4
_huffmanEncodingTreeNodeList$ = 12			; size = 4
?InsertNodeIntoSortedList@HuffmanEncodingTree@@ABEXPAUHuffmanEncodingTreeNode@@PAV?$LinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@@Z PROC ; HuffmanEncodingTree::InsertNodeIntoSortedList, COMDAT
; _this$ = ecx

; 268  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 269  : 	if ( huffmanEncodingTreeNodeList->Size() == 0 )

	mov	ecx, DWORD PTR _huffmanEncodingTreeNodeList$[ebp]
	call	?Size@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEIXZ ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::Size
	test	eax, eax
	jne	SHORT $LN6@InsertNode

; 270  : 	{
; 271  : 		huffmanEncodingTreeNodeList->Insert( node );

	lea	eax, DWORD PTR _node$[ebp]
	push	eax
	mov	ecx, DWORD PTR _huffmanEncodingTreeNodeList$[ebp]
	call	?Insert@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEXABQAUHuffmanEncodingTreeNode@@@Z ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::Insert

; 272  : 		return ;

	jmp	SHORT $LN7@InsertNode
$LN6@InsertNode:

; 273  : 	}
; 274  : 	
; 275  : 	huffmanEncodingTreeNodeList->Beginning();

	mov	ecx, DWORD PTR _huffmanEncodingTreeNodeList$[ebp]
	call	?Beginning@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEXXZ ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::Beginning

; 276  : 	
; 277  : 	unsigned counter = 0;

	mov	DWORD PTR _counter$[ebp], 0
$LN5@InsertNode:

; 278  : #ifdef _MSC_VER
; 279  : #pragma warning( disable : 4127 ) // warning C4127: conditional expression is constant
; 280  : #endif
; 281  : 	while ( 1 )

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN7@InsertNode

; 282  : 	{
; 283  : 		if ( huffmanEncodingTreeNodeList->Peek()->weight < node->weight )

	mov	ecx, DWORD PTR _huffmanEncodingTreeNodeList$[ebp]
	call	?Peek@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEAAPAUHuffmanEncodingTreeNode@@XZ ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::Peek
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [eax+1]
	cmp	edx, DWORD PTR [ecx+1]
	jae	SHORT $LN3@InsertNode

; 284  : 			++( *huffmanEncodingTreeNodeList );

	mov	ecx, DWORD PTR _huffmanEncodingTreeNodeList$[ebp]
	call	??E?$LinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEAAV01@XZ ; DataStructures::LinkedList<HuffmanEncodingTreeNode *>::operator++

; 285  : 		else

	jmp	SHORT $LN2@InsertNode
$LN3@InsertNode:

; 286  : 		{
; 287  : 			huffmanEncodingTreeNodeList->Insert( node );

	lea	eax, DWORD PTR _node$[ebp]
	push	eax
	mov	ecx, DWORD PTR _huffmanEncodingTreeNodeList$[ebp]
	call	?Insert@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEXABQAUHuffmanEncodingTreeNode@@@Z ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::Insert

; 288  : 			break;

	jmp	SHORT $LN7@InsertNode
$LN2@InsertNode:

; 289  : 		}
; 290  : 		
; 291  : 		// Didn't find a spot in the middle - add to the end
; 292  : 		if ( ++counter == huffmanEncodingTreeNodeList->Size() )

	mov	eax, DWORD PTR _counter$[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$[ebp], eax
	mov	ecx, DWORD PTR _huffmanEncodingTreeNodeList$[ebp]
	call	?Size@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEIXZ ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::Size
	cmp	DWORD PTR _counter$[ebp], eax
	jne	SHORT $LN1@InsertNode

; 293  : 		{
; 294  : 			huffmanEncodingTreeNodeList->End();

	mov	ecx, DWORD PTR _huffmanEncodingTreeNodeList$[ebp]
	call	?End@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEXXZ ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::End

; 295  : 			
; 296  : 			huffmanEncodingTreeNodeList->Add( node )
; 297  : 			
; 298  : 			; // Add to the end

	lea	eax, DWORD PTR _node$[ebp]
	push	eax
	mov	ecx, DWORD PTR _huffmanEncodingTreeNodeList$[ebp]
	call	?Add@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEAAPAUHuffmanEncodingTreeNode@@ABQAU3@@Z ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::Add

; 299  : 			break;

	jmp	SHORT $LN7@InsertNode
$LN1@InsertNode:

; 300  : 		}
; 301  : 	}

	jmp	SHORT $LN5@InsertNode
$LN7@InsertNode:

; 302  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?InsertNodeIntoSortedList@HuffmanEncodingTree@@ABEXPAUHuffmanEncodingTreeNode@@PAV?$LinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@@Z ENDP ; HuffmanEncodingTree::InsertNodeIntoSortedList
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_huffmanencodingtree.cpp
;	COMDAT ?FreeMemory@HuffmanEncodingTree@@QAEXXZ
_TEXT	SEGMENT
$T2 = -284						; size = 4
$T3 = -272						; size = 4
_i$4 = -68						; size = 4
_node$ = -56						; size = 4
_nodeQueue$ = -44					; size = 16
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?FreeMemory@HuffmanEncodingTree@@QAEXXZ PROC		; HuffmanEncodingTree::FreeMemory, COMDAT
; _this$ = ecx

; 37   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?FreeMemory@HuffmanEncodingTree@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-288]
	mov	ecx, 69					; 00000045H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 38   : 	if ( root == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN8@FreeMemory

; 39   : 		return ;

	jmp	$LN9@FreeMemory
$LN8@FreeMemory:

; 40   : 		
; 41   : 	// Use an in-order traversal to delete the tree
; 42   : 	DataStructures::Queue<HuffmanEncodingTreeNode *> nodeQueue;

	lea	ecx, DWORD PTR _nodeQueue$[ebp]
	call	??0?$Queue@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAE@XZ ; DataStructures::Queue<HuffmanEncodingTreeNode *>::Queue<HuffmanEncodingTreeNode *>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 43   : 	
; 44   : 	HuffmanEncodingTreeNode *node;
; 45   : 	
; 46   : 	nodeQueue.Push( root );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR _nodeQueue$[ebp]
	call	?Push@?$Queue@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEXABQAUHuffmanEncodingTreeNode@@@Z ; DataStructures::Queue<HuffmanEncodingTreeNode *>::Push
$LN7@FreeMemory:

; 47   : 	
; 48   : 	while ( nodeQueue.Size() > 0 )

	lea	ecx, DWORD PTR _nodeQueue$[ebp]
	call	?Size@?$Queue@PAUHuffmanEncodingTreeNode@@@DataStructures@@QBEIXZ ; DataStructures::Queue<HuffmanEncodingTreeNode *>::Size
	test	eax, eax
	jbe	SHORT $LN6@FreeMemory

; 49   : 	{
; 50   : 		node = nodeQueue.Pop();

	lea	ecx, DWORD PTR _nodeQueue$[ebp]
	call	?Pop@?$Queue@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEPAUHuffmanEncodingTreeNode@@XZ ; DataStructures::Queue<HuffmanEncodingTreeNode *>::Pop
	mov	DWORD PTR _node$[ebp], eax

; 51   : 		
; 52   : 		if ( node->left )

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+5], 0
	je	SHORT $LN5@FreeMemory

; 53   : 			nodeQueue.Push( node->left );

	mov	eax, DWORD PTR _node$[ebp]
	add	eax, 5
	push	eax
	lea	ecx, DWORD PTR _nodeQueue$[ebp]
	call	?Push@?$Queue@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEXABQAUHuffmanEncodingTreeNode@@@Z ; DataStructures::Queue<HuffmanEncodingTreeNode *>::Push
$LN5@FreeMemory:

; 54   : 			
; 55   : 		if ( node->right )

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+9], 0
	je	SHORT $LN4@FreeMemory

; 56   : 			nodeQueue.Push( node->right );

	mov	eax, DWORD PTR _node$[ebp]
	add	eax, 9
	push	eax
	lea	ecx, DWORD PTR _nodeQueue$[ebp]
	call	?Push@?$Queue@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEXABQAUHuffmanEncodingTreeNode@@@Z ; DataStructures::Queue<HuffmanEncodingTreeNode *>::Push
$LN4@FreeMemory:

; 57   : 			
; 58   : 		delete node;

	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 59   : 	}

	jmp	SHORT $LN7@FreeMemory
$LN6@FreeMemory:

; 60   : 	
; 61   : 	// Delete the encoding table
; 62   : 	for ( int i = 0; i < 256; i++ )

	mov	DWORD PTR _i$4[ebp], 0
	jmp	SHORT $LN3@FreeMemory
$LN2@FreeMemory:
	mov	eax, DWORD PTR _i$4[ebp]
	add	eax, 1
	mov	DWORD PTR _i$4[ebp], eax
$LN3@FreeMemory:
	cmp	DWORD PTR _i$4[ebp], 256		; 00000100H
	jge	SHORT $LN1@FreeMemory

; 63   : 		delete [] encodingTable[ i ].encoding;

	imul	eax, DWORD PTR _i$4[ebp], 6
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+4]
	mov	DWORD PTR $T3[ebp], edx
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	jmp	SHORT $LN2@FreeMemory
$LN1@FreeMemory:

; 64   : 		
; 65   : 	root = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 66   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _nodeQueue$[ebp]
	call	??1?$Queue@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAE@XZ ; DataStructures::Queue<HuffmanEncodingTreeNode *>::~Queue<HuffmanEncodingTreeNode *>
$LN9@FreeMemory:
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN15@FreeMemory
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 288				; 00000120H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@FreeMemory:
	DD	1
	DD	$LN14@FreeMemory
$LN14@FreeMemory:
	DD	-44					; ffffffd4H
	DD	16					; 00000010H
	DD	$LN12@FreeMemory
$LN12@FreeMemory:
	DB	110					; 0000006eH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	81					; 00000051H
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FreeMemory@HuffmanEncodingTree@@QAEXXZ$0:
	lea	ecx, DWORD PTR _nodeQueue$[ebp]
	jmp	??1?$Queue@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAE@XZ ; DataStructures::Queue<HuffmanEncodingTreeNode *>::~Queue<HuffmanEncodingTreeNode *>
__ehhandler$?FreeMemory@HuffmanEncodingTree@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-292]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?FreeMemory@HuffmanEncodingTree@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?FreeMemory@HuffmanEncodingTree@@QAEXXZ ENDP		; HuffmanEncodingTree::FreeMemory
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_huffmanencodingtree.cpp
;	COMDAT ?GenerateFromFrequencyTable@HuffmanEncodingTree@@QAEXQAI@Z
_TEXT	SEGMENT
tv184 = -1936						; size = 4
tv183 = -1932						; size = 4
$T2 = -1924						; size = 4
$T3 = -1912						; size = 4
$T4 = -1900						; size = 4
_bitStream$ = -1696					; size = 273
_currentNode$ = -1412					; size = 4
_tempPathLength$ = -1400				; size = 2
_tempPath$ = -1388					; size = 256
_greater$5 = -1124					; size = 4
_lesser$6 = -1112					; size = 4
_huffmanEncodingTreeNodeList$ = -1100			; size = 12
_leafList$ = -1080					; size = 1024
_node$ = -48						; size = 4
_counter$ = -36						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_frequencyTable$ = 8					; size = 4
?GenerateFromFrequencyTable@HuffmanEncodingTree@@QAEXQAI@Z PROC ; HuffmanEncodingTree::GenerateFromFrequencyTable, COMDAT
; _this$ = ecx

; 73   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GenerateFromFrequencyTable@HuffmanEncodingTree@@QAEXQAI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1924				; 00000784H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-1936]
	mov	ecx, 481				; 000001e1H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 74   : 	int counter;
; 75   : 	HuffmanEncodingTreeNode * node;
; 76   : 	HuffmanEncodingTreeNode *leafList[ 256 ]; // Keep a copy of the pointers to all the leaves so we can generate the encryption table bottom-up, which is easier
; 77   : 	// 1.  Make 256 trees each with a weight equal to the frequency of the corresponding character
; 78   : 	DataStructures::LinkedList<HuffmanEncodingTreeNode *> huffmanEncodingTreeNodeList;

	lea	ecx, DWORD PTR _huffmanEncodingTreeNodeList$[ebp]
	call	??0?$LinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAE@XZ ; DataStructures::LinkedList<HuffmanEncodingTreeNode *>::LinkedList<HuffmanEncodingTreeNode *>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 79   : 	
; 80   : 	FreeMemory();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeMemory@HuffmanEncodingTree@@QAEXXZ	; HuffmanEncodingTree::FreeMemory

; 81   : 	
; 82   : 	for ( counter = 0; counter < 256; counter++ )

	mov	DWORD PTR _counter$[ebp], 0
	jmp	SHORT $LN19@GenerateFr
$LN18@GenerateFr:
	mov	eax, DWORD PTR _counter$[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$[ebp], eax
$LN19@GenerateFr:
	cmp	DWORD PTR _counter$[ebp], 256		; 00000100H
	jge	SHORT $LN15@GenerateFr

; 83   : 	{
; 84   : 		node = new HuffmanEncodingTreeNode;

	push	17					; 00000011H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _node$[ebp], eax

; 85   : 		node->left = 0;

	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR [eax+5], 0

; 86   : 		node->right = 0;

	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR [eax+9], 0

; 87   : 		node->value = (unsigned char) counter;

	mov	eax, DWORD PTR _node$[ebp]
	mov	cl, BYTE PTR _counter$[ebp]
	mov	BYTE PTR [eax], cl

; 88   : 		node->weight = frequencyTable[ counter ];

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR _counter$[ebp]
	mov	edx, DWORD PTR _frequencyTable$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [eax+1], ecx

; 89   : 		
; 90   : 		if ( node->weight == 0 )

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+1], 0
	jne	SHORT $LN16@GenerateFr

; 91   : 			node->weight = 1; // 0 weights are illegal

	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR [eax+1], 1
$LN16@GenerateFr:

; 92   : 			
; 93   : 		leafList[ counter ] = node; // Used later to generate the encryption table

	mov	eax, DWORD PTR _counter$[ebp]
	mov	ecx, DWORD PTR _node$[ebp]
	mov	DWORD PTR _leafList$[ebp+eax*4], ecx

; 94   : 		
; 95   : 		InsertNodeIntoSortedList( node, &huffmanEncodingTreeNodeList ); // Insert and maintain sort order.

	lea	eax, DWORD PTR _huffmanEncodingTreeNodeList$[ebp]
	push	eax
	mov	ecx, DWORD PTR _node$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertNodeIntoSortedList@HuffmanEncodingTree@@ABEXPAUHuffmanEncodingTreeNode@@PAV?$LinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@@Z ; HuffmanEncodingTree::InsertNodeIntoSortedList

; 96   : 	}

	jmp	$LN18@GenerateFr
$LN15@GenerateFr:

; 97   : 	
; 98   : 	
; 99   : 	// 2.  While there is more than one tree, take the two smallest trees and merge them so that the two trees are the left and right
; 100  : 	// children of a new node, where the new node has the weight the sum of the weight of the left and right child nodes.
; 101  : #ifdef _MSC_VER
; 102  : #pragma warning( disable : 4127 ) // warning C4127: conditional expression is constant
; 103  : #endif
; 104  : 	while ( 1 )

	mov	eax, 1
	test	eax, eax
	je	$LN14@GenerateFr

; 105  : 	{
; 106  : 		huffmanEncodingTreeNodeList.Beginning();

	lea	ecx, DWORD PTR _huffmanEncodingTreeNodeList$[ebp]
	call	?Beginning@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEXXZ ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::Beginning

; 107  : 		HuffmanEncodingTreeNode *lesser, *greater;
; 108  : 		lesser = huffmanEncodingTreeNodeList.Pop();

	lea	ecx, DWORD PTR _huffmanEncodingTreeNodeList$[ebp]
	call	?Pop@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEPAUHuffmanEncodingTreeNode@@XZ ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::Pop
	mov	DWORD PTR _lesser$6[ebp], eax

; 109  : 		greater = huffmanEncodingTreeNodeList.Pop();

	lea	ecx, DWORD PTR _huffmanEncodingTreeNodeList$[ebp]
	call	?Pop@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEPAUHuffmanEncodingTreeNode@@XZ ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::Pop
	mov	DWORD PTR _greater$5[ebp], eax

; 110  : 		node = new HuffmanEncodingTreeNode;

	push	17					; 00000011H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR _node$[ebp], eax

; 111  : 		node->left = lesser;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR _lesser$6[ebp]
	mov	DWORD PTR [eax+5], ecx

; 112  : 		node->right = greater;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR _greater$5[ebp]
	mov	DWORD PTR [eax+9], ecx

; 113  : 		node->weight = lesser->weight + greater->weight;

	mov	eax, DWORD PTR _lesser$6[ebp]
	mov	ecx, DWORD PTR [eax+1]
	mov	edx, DWORD PTR _greater$5[ebp]
	add	ecx, DWORD PTR [edx+1]
	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR [eax+1], ecx

; 114  : 		lesser->parent = node;  // This is done to make generating the encryption table easier

	mov	eax, DWORD PTR _lesser$6[ebp]
	mov	ecx, DWORD PTR _node$[ebp]
	mov	DWORD PTR [eax+13], ecx

; 115  : 		greater->parent = node;  // This is done to make generating the encryption table easier

	mov	eax, DWORD PTR _greater$5[ebp]
	mov	ecx, DWORD PTR _node$[ebp]
	mov	DWORD PTR [eax+13], ecx

; 116  : 		
; 117  : 		if ( huffmanEncodingTreeNodeList.Size() == 0 )

	lea	ecx, DWORD PTR _huffmanEncodingTreeNodeList$[ebp]
	call	?Size@?$CircularLinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAEIXZ ; DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::Size
	test	eax, eax
	jne	SHORT $LN13@GenerateFr

; 118  : 		{
; 119  : 			// 3. Assign the one remaining node in the list to the root node.
; 120  : 			root = node;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _node$[ebp]
	mov	DWORD PTR [eax], ecx

; 121  : 			root->parent = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+13], 0

; 122  : 			break;

	jmp	SHORT $LN14@GenerateFr
$LN13@GenerateFr:

; 123  : 		}
; 124  : 		
; 125  : 		// Put the new node back into the list at the correct spot to maintain the sort.  Linear search time
; 126  : 		InsertNodeIntoSortedList( node, &huffmanEncodingTreeNodeList );

	lea	eax, DWORD PTR _huffmanEncodingTreeNodeList$[ebp]
	push	eax
	mov	ecx, DWORD PTR _node$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertNodeIntoSortedList@HuffmanEncodingTree@@ABEXPAUHuffmanEncodingTreeNode@@PAV?$LinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@@Z ; HuffmanEncodingTree::InsertNodeIntoSortedList

; 127  : 	}

	jmp	$LN15@GenerateFr
$LN14@GenerateFr:

; 128  : 	
; 129  : 	bool tempPath[ 256 ]; // Maximum path length is 256
; 130  : 	unsigned short tempPathLength;
; 131  : 	HuffmanEncodingTreeNode *currentNode;
; 132  : 	RakNet::BitStream bitStream;

	lea	ecx, DWORD PTR _bitStream$[ebp]
	call	??0BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::BitStream
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 133  : 	
; 134  : 	// Generate the encryption table. From before, we have an array of pointers to all the leaves which contain pointers to their parents.
; 135  : 	// This can be done more efficiently but this isn't bad and it's way easier to program and debug
; 136  : 	
; 137  : 	for ( counter = 0; counter < 256; counter++ )

	mov	DWORD PTR _counter$[ebp], 0
	jmp	SHORT $LN12@GenerateFr
$LN11@GenerateFr:
	mov	eax, DWORD PTR _counter$[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$[ebp], eax
$LN12@GenerateFr:
	cmp	DWORD PTR _counter$[ebp], 256		; 00000100H
	jge	$LN10@GenerateFr

; 138  : 	{
; 139  : 		// Already done at the end of the loop and before it!
; 140  : 		tempPathLength = 0;

	xor	eax, eax
	mov	WORD PTR _tempPathLength$[ebp], ax

; 141  : 		
; 142  : 		// Set the current node at the leaf
; 143  : 		currentNode = leafList[ counter ];

	mov	eax, DWORD PTR _counter$[ebp]
	mov	ecx, DWORD PTR _leafList$[ebp+eax*4]
	mov	DWORD PTR _currentNode$[ebp], ecx
$LN9@GenerateFr:

; 144  : 		
; 145  : 		do
; 146  : 		{
; 147  : 			if ( currentNode->parent->left == currentNode )   // We're storing the paths in reverse order.since we are going from the leaf to the root

	mov	eax, DWORD PTR _currentNode$[ebp]
	mov	ecx, DWORD PTR [eax+13]
	mov	edx, DWORD PTR [ecx+5]
	cmp	edx, DWORD PTR _currentNode$[ebp]
	jne	SHORT $LN6@GenerateFr

; 148  : 				tempPath[ tempPathLength++ ] = false;

	movzx	eax, WORD PTR _tempPathLength$[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	cx, WORD PTR _tempPathLength$[ebp]
	add	cx, 1
	mov	WORD PTR _tempPathLength$[ebp], cx
	cmp	DWORD PTR $T4[ebp], 256			; 00000100H
	jae	SHORT $LN22@GenerateFr
	jmp	SHORT $LN23@GenerateFr
$LN22@GenerateFr:
	call	___report_rangecheckfailure
$LN23@GenerateFr:
	mov	edx, DWORD PTR $T4[ebp]
	mov	BYTE PTR _tempPath$[ebp+edx], 0

; 149  : 			else

	jmp	SHORT $LN5@GenerateFr
$LN6@GenerateFr:

; 150  : 				tempPath[ tempPathLength++ ] = true;

	movzx	eax, WORD PTR _tempPathLength$[ebp]
	mov	BYTE PTR _tempPath$[ebp+eax], 1
	mov	cx, WORD PTR _tempPathLength$[ebp]
	add	cx, 1
	mov	WORD PTR _tempPathLength$[ebp], cx
$LN5@GenerateFr:

; 151  : 				
; 152  : 			currentNode = currentNode->parent;

	mov	eax, DWORD PTR _currentNode$[ebp]
	mov	ecx, DWORD PTR [eax+13]
	mov	DWORD PTR _currentNode$[ebp], ecx

; 153  : 		}
; 154  : 		
; 155  : 		while ( currentNode != root );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _currentNode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN9@GenerateFr
$LN4@GenerateFr:

; 156  : 		
; 157  : 		// Write to the bitstream in the reverse order that we stored the path, which gives us the correct order from the root to the leaf
; 158  : 		while ( tempPathLength-- > 0 )

	movzx	eax, WORD PTR _tempPathLength$[ebp]
	mov	DWORD PTR tv183[ebp], eax
	mov	cx, WORD PTR _tempPathLength$[ebp]
	sub	cx, 1
	mov	WORD PTR _tempPathLength$[ebp], cx
	cmp	DWORD PTR tv183[ebp], 0
	jle	SHORT $LN24@GenerateFr
	mov	DWORD PTR tv184[ebp], 1
	jmp	SHORT $LN25@GenerateFr
$LN24@GenerateFr:
	mov	DWORD PTR tv184[ebp], 0
$LN25@GenerateFr:
	cmp	DWORD PTR tv184[ebp], 0
	je	SHORT $LN3@GenerateFr

; 159  : 		{
; 160  : 			if ( tempPath[ tempPathLength ] )   // Write 1's and 0's because writing a bool will write the BitStream TYPE_CHECKING validation bits if that is defined along with the actual data bit, which is not what we want

	movzx	eax, WORD PTR _tempPathLength$[ebp]
	movzx	ecx, BYTE PTR _tempPath$[ebp+eax]
	test	ecx, ecx
	je	SHORT $LN2@GenerateFr

; 161  : 				bitStream.Write1();

	lea	ecx, DWORD PTR _bitStream$[ebp]
	call	?Write1@BitStream@RakNet@@QAEXXZ	; RakNet::BitStream::Write1

; 162  : 			else

	jmp	SHORT $LN1@GenerateFr
$LN2@GenerateFr:

; 163  : 				bitStream.Write0();

	lea	ecx, DWORD PTR _bitStream$[ebp]
	call	?Write0@BitStream@RakNet@@QAEXXZ	; RakNet::BitStream::Write0
$LN1@GenerateFr:

; 164  : 		}

	jmp	SHORT $LN4@GenerateFr
$LN3@GenerateFr:

; 165  : 		
; 166  : 		// Read data from the bitstream, which is written to the encoding table in bits and bitlength. Note this function allocates the encodingTable[counter].encoding pointer
; 167  : 		encodingTable[ counter ].bitLength = ( unsigned char ) bitStream.CopyData( &encodingTable[ counter ].encoding );

	imul	eax, DWORD PTR _counter$[ebp], 6
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+4]
	push	edx
	lea	ecx, DWORD PTR _bitStream$[ebp]
	call	?CopyData@BitStream@RakNet@@QBEHPAPAE@Z	; RakNet::BitStream::CopyData
	movzx	ax, al
	imul	ecx, DWORD PTR _counter$[ebp], 6
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+ecx+8], ax

; 168  : 		
; 169  : 		// Reset the bitstream for the next iteration
; 170  : 		bitStream.Reset();

	lea	ecx, DWORD PTR _bitStream$[ebp]
	call	?Reset@BitStream@RakNet@@QAEXXZ		; RakNet::BitStream::Reset

; 171  : 	}

	jmp	$LN11@GenerateFr
$LN10@GenerateFr:

; 172  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _bitStream$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _huffmanEncodingTreeNodeList$[ebp]
	call	??1?$LinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAE@XZ ; DataStructures::LinkedList<HuffmanEncodingTreeNode *>::~LinkedList<HuffmanEncodingTreeNode *>
$LN21@GenerateFr:
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN34@GenerateFr
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 1936				; 00000790H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$LN34@GenerateFr:
	DD	4
	DD	$LN33@GenerateFr
$LN33@GenerateFr:
	DD	-1080					; fffffbc8H
	DD	1024					; 00000400H
	DD	$LN28@GenerateFr
	DD	-1100					; fffffbb4H
	DD	12					; 0000000cH
	DD	$LN29@GenerateFr
	DD	-1388					; fffffa94H
	DD	256					; 00000100H
	DD	$LN30@GenerateFr
	DD	-1696					; fffff960H
	DD	273					; 00000111H
	DD	$LN31@GenerateFr
$LN31@GenerateFr:
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	0
$LN30@GenerateFr:
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$LN29@GenerateFr:
	DB	104					; 00000068H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	69					; 00000045H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	84					; 00000054H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	101					; 00000065H
	DB	78					; 0000004eH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	76					; 0000004cH
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
$LN28@GenerateFr:
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	102					; 00000066H
	DB	76					; 0000004cH
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GenerateFromFrequencyTable@HuffmanEncodingTree@@QAEXQAI@Z$0:
	lea	ecx, DWORD PTR _huffmanEncodingTreeNodeList$[ebp]
	jmp	??1?$LinkedList@PAUHuffmanEncodingTreeNode@@@DataStructures@@QAE@XZ ; DataStructures::LinkedList<HuffmanEncodingTreeNode *>::~LinkedList<HuffmanEncodingTreeNode *>
__unwindfunclet$?GenerateFromFrequencyTable@HuffmanEncodingTree@@QAEXQAI@Z$1:
	lea	ecx, DWORD PTR _bitStream$[ebp]
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__ehhandler$?GenerateFromFrequencyTable@HuffmanEncodingTree@@QAEXQAI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1940]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GenerateFromFrequencyTable@HuffmanEncodingTree@@QAEXQAI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GenerateFromFrequencyTable@HuffmanEncodingTree@@QAEXQAI@Z ENDP ; HuffmanEncodingTree::GenerateFromFrequencyTable
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_huffmanencodingtree.cpp
;	COMDAT ?DecodeArray@HuffmanEncodingTree@@QAEXPAEIPAVBitStream@RakNet@@@Z
_TEXT	SEGMENT
_counter$2 = -332					; size = 4
_bitStream$ = -320					; size = 273
_currentNode$ = -36					; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_input$ = 8						; size = 4
_sizeInBits$ = 12					; size = 4
_output$ = 16						; size = 4
?DecodeArray@HuffmanEncodingTree@@QAEXPAEIPAVBitStream@RakNet@@@Z PROC ; HuffmanEncodingTree::DecodeArray, COMDAT
; _this$ = ecx

; 240  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DecodeArray@HuffmanEncodingTree@@QAEXPAEIPAVBitStream@RakNet@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 516				; 00000204H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-528]
	mov	ecx, 129				; 00000081H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 241  : 	HuffmanEncodingTreeNode * currentNode;
; 242  : 	
; 243  : 	if ( sizeInBits <= 0 )

	cmp	DWORD PTR _sizeInBits$[ebp], 0
	ja	SHORT $LN7@DecodeArra

; 244  : 		return ;

	jmp	$LN8@DecodeArra
$LN7@DecodeArra:

; 245  : 		
; 246  : 	RakNet::BitStream bitStream( input, BITS_TO_BYTES(sizeInBits), false );

	push	0
	mov	eax, DWORD PTR _sizeInBits$[ebp]
	add	eax, 7
	shr	eax, 3
	push	eax
	mov	ecx, DWORD PTR _input$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _bitStream$[ebp]
	call	??0BitStream@RakNet@@QAE@PAEI_N@Z	; RakNet::BitStream::BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 247  : 	
; 248  : 	currentNode = root;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _currentNode$[ebp], ecx

; 249  : 	
; 250  : 	// For each bit, go left if it is a 0 and right if it is a 1.  When we reach a leaf, that gives us the desired value and we restart from the root
; 251  : 	for ( unsigned counter = 0; counter < sizeInBits; counter++ )

	mov	DWORD PTR _counter$2[ebp], 0
	jmp	SHORT $LN6@DecodeArra
$LN5@DecodeArra:
	mov	eax, DWORD PTR _counter$2[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$2[ebp], eax
$LN6@DecodeArra:
	mov	eax, DWORD PTR _counter$2[ebp]
	cmp	eax, DWORD PTR _sizeInBits$[ebp]
	jae	SHORT $LN4@DecodeArra

; 252  : 	{
; 253  : 		if ( bitStream.ReadBit() == false )   // left!

	lea	ecx, DWORD PTR _bitStream$[ebp]
	call	?ReadBit@BitStream@RakNet@@QAE_NXZ	; RakNet::BitStream::ReadBit
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@DecodeArra

; 254  : 			currentNode = currentNode->left;

	mov	eax, DWORD PTR _currentNode$[ebp]
	mov	ecx, DWORD PTR [eax+5]
	mov	DWORD PTR _currentNode$[ebp], ecx

; 255  : 		else

	jmp	SHORT $LN2@DecodeArra
$LN3@DecodeArra:

; 256  : 			currentNode = currentNode->right;

	mov	eax, DWORD PTR _currentNode$[ebp]
	mov	ecx, DWORD PTR [eax+9]
	mov	DWORD PTR _currentNode$[ebp], ecx
$LN2@DecodeArra:

; 257  : 			
; 258  : 		if ( currentNode->left == 0 && currentNode->right == 0 )   // Leaf

	mov	eax, DWORD PTR _currentNode$[ebp]
	cmp	DWORD PTR [eax+5], 0
	jne	SHORT $LN1@DecodeArra
	mov	eax, DWORD PTR _currentNode$[ebp]
	cmp	DWORD PTR [eax+9], 0
	jne	SHORT $LN1@DecodeArra

; 259  : 		{
; 260  : 			output->WriteBits( &( currentNode->value ), sizeof( char ) * 8, true ); // Use WriteBits instead of Write(char) because we want to avoid TYPE_CHECKING

	push	1
	push	8
	mov	eax, DWORD PTR _currentNode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _output$[ebp]
	call	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z ; RakNet::BitStream::WriteBits

; 261  : 			currentNode = root;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _currentNode$[ebp], ecx
$LN1@DecodeArra:

; 262  : 		}
; 263  : 	}

	jmp	SHORT $LN5@DecodeArra
$LN4@DecodeArra:

; 264  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _bitStream$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
$LN8@DecodeArra:
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN14@DecodeArra
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 528				; 00000210H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN14@DecodeArra:
	DD	1
	DD	$LN13@DecodeArra
$LN13@DecodeArra:
	DD	-320					; fffffec0H
	DD	273					; 00000111H
	DD	$LN11@DecodeArra
$LN11@DecodeArra:
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DecodeArray@HuffmanEncodingTree@@QAEXPAEIPAVBitStream@RakNet@@@Z$0:
	lea	ecx, DWORD PTR _bitStream$[ebp]
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__ehhandler$?DecodeArray@HuffmanEncodingTree@@QAEXPAEIPAVBitStream@RakNet@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-532]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DecodeArray@HuffmanEncodingTree@@QAEXPAEIPAVBitStream@RakNet@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DecodeArray@HuffmanEncodingTree@@QAEXPAEIPAVBitStream@RakNet@@@Z ENDP ; HuffmanEncodingTree::DecodeArray
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_huffmanencodingtree.cpp
;	COMDAT ?DecodeArray@HuffmanEncodingTree@@QAEIPAVBitStream@RakNet@@IIPAE@Z
_TEXT	SEGMENT
_counter$1 = -44					; size = 4
_outputWriteIndex$ = -32				; size = 4
_currentNode$ = -20					; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
_sizeInBits$ = 12					; size = 4
_maxCharsToWrite$ = 16					; size = 4
_output$ = 20						; size = 4
?DecodeArray@HuffmanEncodingTree@@QAEIPAVBitStream@RakNet@@IIPAE@Z PROC ; HuffmanEncodingTree::DecodeArray, COMDAT
; _this$ = ecx

; 207  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 208  : 	HuffmanEncodingTreeNode * currentNode;
; 209  : 	
; 210  : 	unsigned outputWriteIndex;
; 211  : 	outputWriteIndex = 0;

	mov	DWORD PTR _outputWriteIndex$[ebp], 0

; 212  : 	currentNode = root;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _currentNode$[ebp], ecx

; 213  : 	
; 214  : 	// For each bit, go left if it is a 0 and right if it is a 1.  When we reach a leaf, that gives us the desired value and we restart from the root
; 215  : 	
; 216  : 	for ( unsigned counter = 0; counter < sizeInBits; counter++ )

	mov	DWORD PTR _counter$1[ebp], 0
	jmp	SHORT $LN7@DecodeArra
$LN6@DecodeArra:
	mov	eax, DWORD PTR _counter$1[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$1[ebp], eax
$LN7@DecodeArra:
	mov	eax, DWORD PTR _counter$1[ebp]
	cmp	eax, DWORD PTR _sizeInBits$[ebp]
	jae	SHORT $LN5@DecodeArra

; 217  : 	{
; 218  : 		if ( input->ReadBit() == false )   // left!

	mov	ecx, DWORD PTR _input$[ebp]
	call	?ReadBit@BitStream@RakNet@@QAE_NXZ	; RakNet::BitStream::ReadBit
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@DecodeArra

; 219  : 			currentNode = currentNode->left;

	mov	eax, DWORD PTR _currentNode$[ebp]
	mov	ecx, DWORD PTR [eax+5]
	mov	DWORD PTR _currentNode$[ebp], ecx

; 220  : 		else

	jmp	SHORT $LN3@DecodeArra
$LN4@DecodeArra:

; 221  : 			currentNode = currentNode->right;

	mov	eax, DWORD PTR _currentNode$[ebp]
	mov	ecx, DWORD PTR [eax+9]
	mov	DWORD PTR _currentNode$[ebp], ecx
$LN3@DecodeArra:

; 222  : 			
; 223  : 		if ( currentNode->left == 0 && currentNode->right == 0 )   // Leaf

	mov	eax, DWORD PTR _currentNode$[ebp]
	cmp	DWORD PTR [eax+5], 0
	jne	SHORT $LN2@DecodeArra
	mov	eax, DWORD PTR _currentNode$[ebp]
	cmp	DWORD PTR [eax+9], 0
	jne	SHORT $LN2@DecodeArra

; 224  : 		{
; 225  : 		
; 226  : 			if ( outputWriteIndex < maxCharsToWrite )

	mov	eax, DWORD PTR _outputWriteIndex$[ebp]
	cmp	eax, DWORD PTR _maxCharsToWrite$[ebp]
	jae	SHORT $LN1@DecodeArra

; 227  : 				output[ outputWriteIndex ] = currentNode->value;

	mov	eax, DWORD PTR _output$[ebp]
	add	eax, DWORD PTR _outputWriteIndex$[ebp]
	mov	ecx, DWORD PTR _currentNode$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
$LN1@DecodeArra:

; 228  : 				
; 229  : 			outputWriteIndex++;

	mov	eax, DWORD PTR _outputWriteIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _outputWriteIndex$[ebp], eax

; 230  : 			
; 231  : 			currentNode = root;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _currentNode$[ebp], ecx
$LN2@DecodeArra:

; 232  : 		}
; 233  : 	}

	jmp	SHORT $LN6@DecodeArra
$LN5@DecodeArra:

; 234  : 	
; 235  : 	return outputWriteIndex;

	mov	eax, DWORD PTR _outputWriteIndex$[ebp]

; 236  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?DecodeArray@HuffmanEncodingTree@@QAEIPAVBitStream@RakNet@@IIPAE@Z ENDP ; HuffmanEncodingTree::DecodeArray
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_huffmanencodingtree.cpp
;	COMDAT ?EncodeArray@HuffmanEncodingTree@@QAEXPAEIPAVBitStream@RakNet@@@Z
_TEXT	SEGMENT
_remainingBits$1 = -29					; size = 1
_counter$ = -20						; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
_sizeInBytes$ = 12					; size = 4
_output$ = 16						; size = 4
?EncodeArray@HuffmanEncodingTree@@QAEXPAEIPAVBitStream@RakNet@@@Z PROC ; HuffmanEncodingTree::EncodeArray, COMDAT
; _this$ = ecx

; 176  : {		

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 177  : 	unsigned counter;
; 178  : 	
; 179  : 	// For each input byte, Write out the corresponding series of 1's and 0's that give the encoded representation
; 180  : 	for ( counter = 0; counter < sizeInBytes; counter++ )

	mov	DWORD PTR _counter$[ebp], 0
	jmp	SHORT $LN8@EncodeArra
$LN7@EncodeArra:
	mov	eax, DWORD PTR _counter$[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$[ebp], eax
$LN8@EncodeArra:
	mov	eax, DWORD PTR _counter$[ebp]
	cmp	eax, DWORD PTR _sizeInBytes$[ebp]
	jae	SHORT $LN6@EncodeArra

; 181  : 	{
; 182  : 		output->WriteBits( encodingTable[ input[ counter ] ].encoding, encodingTable[ input[ counter ] ].bitLength, false ); // Data is left aligned

	push	0
	mov	eax, DWORD PTR _input$[ebp]
	add	eax, DWORD PTR _counter$[ebp]
	movzx	ecx, BYTE PTR [eax]
	imul	edx, ecx, 6
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+edx+8]
	push	ecx
	mov	edx, DWORD PTR _input$[ebp]
	add	edx, DWORD PTR _counter$[ebp]
	movzx	eax, BYTE PTR [edx]
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+4]
	push	eax
	mov	ecx, DWORD PTR _output$[ebp]
	call	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z ; RakNet::BitStream::WriteBits

; 183  : 	}

	jmp	SHORT $LN7@EncodeArra
$LN6@EncodeArra:

; 184  : 	
; 185  : 	// Byte align the output so the unassigned remaining bits don't equate to some actual value
; 186  : 	if ( output->GetNumberOfBitsUsed() % 8 != 0 )

	mov	ecx, DWORD PTR _output$[ebp]
	call	?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBitsUsed
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN12@EncodeArra
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN12@EncodeArra:
	test	eax, eax
	je	$LN9@EncodeArra

; 187  : 	{
; 188  : 		// Find an input that is longer than the remaining bits.  Write out part of it to pad the output to be byte aligned.
; 189  : 		unsigned char remainingBits = (unsigned char) ( 8 - ( output->GetNumberOfBitsUsed() % 8 ) );

	mov	ecx, DWORD PTR _output$[ebp]
	call	?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBitsUsed
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN13@EncodeArra
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN13@EncodeArra:
	mov	ecx, 8
	sub	ecx, eax
	mov	BYTE PTR _remainingBits$1[ebp], cl

; 190  : 		
; 191  : 		for ( counter = 0; counter < 256; counter++ )

	mov	DWORD PTR _counter$[ebp], 0
	jmp	SHORT $LN4@EncodeArra
$LN3@EncodeArra:
	mov	eax, DWORD PTR _counter$[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$[ebp], eax
$LN4@EncodeArra:
	cmp	DWORD PTR _counter$[ebp], 256		; 00000100H
	jae	SHORT $LN2@EncodeArra

; 192  : 			if ( encodingTable[ counter ].bitLength > remainingBits )

	imul	eax, DWORD PTR _counter$[ebp], 6
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+eax+8]
	movzx	eax, BYTE PTR _remainingBits$1[ebp]
	cmp	edx, eax
	jle	SHORT $LN1@EncodeArra

; 193  : 			{
; 194  : 				output->WriteBits( encodingTable[ counter ].encoding, remainingBits, false ); // Data is left aligned

	push	0
	movzx	eax, BYTE PTR _remainingBits$1[ebp]
	push	eax
	imul	ecx, DWORD PTR _counter$[ebp], 6
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+4]
	push	eax
	mov	ecx, DWORD PTR _output$[ebp]
	call	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z ; RakNet::BitStream::WriteBits

; 195  : 				break;

	jmp	SHORT $LN2@EncodeArra
$LN1@EncodeArra:

; 196  : 			}

	jmp	SHORT $LN3@EncodeArra
$LN2@EncodeArra:

; 197  : 			
; 198  : #ifdef _DEBUG
; 199  : 		assert( counter != 256 );  // Given 256 elements, we should always be able to find an input that would be >= 7 bits

	cmp	DWORD PTR _counter$[ebp], 256		; 00000100H
	jne	SHORT $LN9@EncodeArra
	mov	eax, DWORD PTR ?__LINE__Var@?1??EncodeArray@HuffmanEncodingTree@@QAEXPAEIPAVBitStream@RakNet@@@Z@4JA
	add	eax, 23					; 00000017H
	push	eax
	push	OFFSET ??_C@_1GG@GEMENPHH@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAh?$AAu?$AAf?$AAf?$AAm@
	push	OFFSET ??_C@_1BO@DNOOEHMA@?$AAc?$AAo?$AAu?$AAn?$AAt?$AAe?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA2?$AA5?$AA6?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN9@EncodeArra:

; 200  : 		
; 201  : #endif
; 202  : 		
; 203  : 	}
; 204  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?EncodeArray@HuffmanEncodingTree@@QAEXPAEIPAVBitStream@RakNet@@@Z ENDP ; HuffmanEncodingTree::EncodeArray
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_huffmanencodingtree.cpp
;	COMDAT ??1HuffmanEncodingTree@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1HuffmanEncodingTree@@QAE@XZ PROC			; HuffmanEncodingTree::~HuffmanEncodingTree, COMDAT
; _this$ = ecx

; 32   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 33   : 	FreeMemory();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeMemory@HuffmanEncodingTree@@QAEXXZ	; HuffmanEncodingTree::FreeMemory

; 34   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1HuffmanEncodingTree@@QAE@XZ ENDP			; HuffmanEncodingTree::~HuffmanEncodingTree
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_huffmanencodingtree.cpp
;	COMDAT ??0HuffmanEncodingTree@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0HuffmanEncodingTree@@QAE@XZ PROC			; HuffmanEncodingTree::HuffmanEncodingTree, COMDAT
; _this$ = ecx

; 27   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 28   : 	root = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 29   : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0HuffmanEncodingTree@@QAE@XZ ENDP			; HuffmanEncodingTree::HuffmanEncodingTree
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ?GetWriteOffset@BitStream@RakNet@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetWriteOffset@BitStream@RakNet@@QBEHXZ PROC		; RakNet::BitStream::GetWriteOffset, COMDAT
; _this$ = ecx

; 370  : 		inline int GetWriteOffset( void ) const {return numberOfBitsUsed;}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWriteOffset@BitStream@RakNet@@QBEHXZ ENDP		; RakNet::BitStream::GetWriteOffset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ PROC	; RakNet::BitStream::GetNumberOfBitsUsed, COMDAT
; _this$ = ecx

; 369  : 		inline int GetNumberOfBitsUsed( void ) const {return GetWriteOffset();}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetWriteOffset@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetWriteOffset
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ ENDP	; RakNet::BitStream::GetNumberOfBitsUsed
_TEXT	ENDS
END
