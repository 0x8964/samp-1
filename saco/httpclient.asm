; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.31101.0 

	TITLE	Z:\sampsrc\02Xu1\saco\httpclient.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?strchr@@YAPADPADH@Z				; strchr
PUBLIC	?strstr@@YAPADPADPBD@Z				; strstr
PUBLIC	?Connect@CHttpClient@@AAE_NPADH@Z		; CHttpClient::Connect
PUBLIC	?CloseConnection@CHttpClient@@AAEXXZ		; CHttpClient::CloseConnection
PUBLIC	?Send@CHttpClient@@AAE_NPAD@Z			; CHttpClient::Send
PUBLIC	?Recv@CHttpClient@@AAEHPADH@Z			; CHttpClient::Recv
PUBLIC	?InitRequest@CHttpClient@@AAEXHPAD00@Z		; CHttpClient::InitRequest
PUBLIC	?HandleEntity@CHttpClient@@AAEXXZ		; CHttpClient::HandleEntity
PUBLIC	?Process@CHttpClient@@AAEXXZ			; CHttpClient::Process
PUBLIC	?ProcessURL@CHttpClient@@QAEHHPAD00@Z		; CHttpClient::ProcessURL
PUBLIC	?GetHeaderValue@CHttpClient@@QAE_NPAD0H@Z	; CHttpClient::GetHeaderValue
PUBLIC	??0CHttpClient@@QAE@XZ				; CHttpClient::CHttpClient
PUBLIC	??1CHttpClient@@QAE@XZ				; CHttpClient::~CHttpClient
PUBLIC	??_C@_01KMDKNFGN@?1?$AA@			; `string'
PUBLIC	??_C@_0EP@DCALGLGB@GET?5?$CFs?5HTTP?11?40?$AN?6Accept?3?5?$CK?1?$CK?$AN?6Us@ ; `string'
PUBLIC	??_C@_0L@IKGODMLA@SAMP?10?42?40?$AA@		; `string'
PUBLIC	??_C@_0FA@NENJLDAP@HEAD?5?$CFs?5HTTP?11?40?$AN?6Accept?3?5?$CK?1?$CK?$AN?6U@ ; `string'
PUBLIC	??_C@_0JH@BNIDHCGB@POST?5?$CFs?5HTTP?11?40?$AN?6Accept?3?5?$CK?1?$CK?$AN?6U@ ; `string'
PUBLIC	??_C@_04FMMHFHOO@?$AN?6?$AN?6?$AA@		; `string'
PUBLIC	??_C@_02PHMGELLB@?6?6?$AA@			; `string'
PUBLIC	??_C@_0BA@IOOAPING@CONTENT?9LENGTH?3?$AA@	; `string'
PUBLIC	??_C@_0O@LDHIBCHO@CONTENT?9TYPE?3?$AA@		; `string'
PUBLIC	??_C@_09KABDMIOB@text?1html?$AA@		; `string'
PUBLIC	??_C@_0L@NPNLKGOJ@text?1plain?$AA@		; `string'
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_sprintf:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strcpy:PROC
EXTRN	_strcat:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	_strchr:PROC
EXTRN	_strstr:PROC
EXTRN	_closesocket@4:PROC
EXTRN	_connect@12:PROC
EXTRN	_htons@4:PROC
EXTRN	_recv@16:PROC
EXTRN	_send@16:PROC
EXTRN	_socket@12:PROC
EXTRN	_gethostbyname@4:PROC
EXTRN	_WSAStartup@8:PROC
EXTRN	_WSACleanup@0:PROC
EXTRN	_atoi:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_realloc:PROC
EXTRN	?Util_stristr@@YAPADPBD0@Z:PROC			; Util_stristr
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_UninitUse:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0L@NPNLKGOJ@text?1plain?$AA@
CONST	SEGMENT
??_C@_0L@NPNLKGOJ@text?1plain?$AA@ DB 'text/plain', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09KABDMIOB@text?1html?$AA@
CONST	SEGMENT
??_C@_09KABDMIOB@text?1html?$AA@ DB 'text/html', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LDHIBCHO@CONTENT?9TYPE?3?$AA@
CONST	SEGMENT
??_C@_0O@LDHIBCHO@CONTENT?9TYPE?3?$AA@ DB 'CONTENT-TYPE:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IOOAPING@CONTENT?9LENGTH?3?$AA@
CONST	SEGMENT
??_C@_0BA@IOOAPING@CONTENT?9LENGTH?3?$AA@ DB 'CONTENT-LENGTH:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02PHMGELLB@?6?6?$AA@
CONST	SEGMENT
??_C@_02PHMGELLB@?6?6?$AA@ DB 0aH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04FMMHFHOO@?$AN?6?$AN?6?$AA@
CONST	SEGMENT
??_C@_04FMMHFHOO@?$AN?6?$AN?6?$AA@ DB 0dH, 0aH, 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0JH@BNIDHCGB@POST?5?$CFs?5HTTP?11?40?$AN?6Accept?3?5?$CK?1?$CK?$AN?6U@
CONST	SEGMENT
??_C@_0JH@BNIDHCGB@POST?5?$CFs?5HTTP?11?40?$AN?6Accept?3?5?$CK?1?$CK?$AN?6U@ DB 'P'
	DB	'OST %s HTTP/1.0', 0dH, 0aH, 'Accept: */*', 0dH, 0aH, 'User-Ag'
	DB	'ent: %s', 0dH, 0aH, 'Referer: http://%s', 0dH, 0aH, 'Host: %s'
	DB	0dH, 0aH, 'Content-type: application/x-www-form-urlencoded', 0dH
	DB	0aH, 'Content-length: %u', 0dH, 0aH, 0dH, 0aH, '%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@NENJLDAP@HEAD?5?$CFs?5HTTP?11?40?$AN?6Accept?3?5?$CK?1?$CK?$AN?6U@
CONST	SEGMENT
??_C@_0FA@NENJLDAP@HEAD?5?$CFs?5HTTP?11?40?$AN?6Accept?3?5?$CK?1?$CK?$AN?6U@ DB 'H'
	DB	'EAD %s HTTP/1.0', 0dH, 0aH, 'Accept: */*', 0dH, 0aH, 'User-Ag'
	DB	'ent: %s', 0dH, 0aH, 'Referer: http://%s', 0dH, 0aH, 'Host: %s'
	DB	0dH, 0aH, 0dH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IKGODMLA@SAMP?10?42?40?$AA@
CONST	SEGMENT
??_C@_0L@IKGODMLA@SAMP?10?42?40?$AA@ DB 'SAMP/0.2.0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EP@DCALGLGB@GET?5?$CFs?5HTTP?11?40?$AN?6Accept?3?5?$CK?1?$CK?$AN?6Us@
CONST	SEGMENT
??_C@_0EP@DCALGLGB@GET?5?$CFs?5HTTP?11?40?$AN?6Accept?3?5?$CK?1?$CK?$AN?6Us@ DB 'G'
	DB	'ET %s HTTP/1.0', 0dH, 0aH, 'Accept: */*', 0dH, 0aH, 'User-Age'
	DB	'nt: %s', 0dH, 0aH, 'Referer: http://%s', 0dH, 0aH, 'Host: %s', 0dH
	DB	0aH, 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01KMDKNFGN@?1?$AA@
CONST	SEGMENT
??_C@_01KMDKNFGN@?1?$AA@ DB '/', 00H			; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\httpclient.cpp
;	COMDAT ??1CHttpClient@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1CHttpClient@@QAE@XZ PROC				; CHttpClient::~CHttpClient, COMDAT
; _this$ = ecx

; 50   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 51   : 	// Deallocate the request data memory
; 52   : 	if(m_Request.file) free(m_Request.file);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+14], 0
	je	SHORT $LN7@CHttpClien
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	_free
	add	esp, 4
$LN7@CHttpClien:

; 53   : 	if(m_Request.host) free(m_Request.host);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+10], 0
	je	SHORT $LN6@CHttpClien
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	_free
	add	esp, 4
$LN6@CHttpClien:

; 54   : 	if(m_Request.referer) free(m_Request.referer);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+22], 0
	je	SHORT $LN5@CHttpClien
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	_free
	add	esp, 4
$LN5@CHttpClien:

; 55   : 
; 56   : 	if(m_Request.rtype == HTTP_POST) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+6], 2
	jne	SHORT $LN4@CHttpClien

; 57   : 		if(m_Request.data) free(m_Request.data);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+18], 0
	je	SHORT $LN4@CHttpClien
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	_free
	add	esp, 4
$LN4@CHttpClien:

; 58   : 	}
; 59   : 
; 60   : 	// Deallocate the response data memory
; 61   : 	if(m_Response.header) free(m_Response.header);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+26], 0
	je	SHORT $LN2@CHttpClien
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	_free
	add	esp, 4
$LN2@CHttpClien:

; 62   : 	if(m_Response.response) free(m_Response.response);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+30], 0
	je	SHORT $LN1@CHttpClien
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	_free
	add	esp, 4
$LN1@CHttpClien:

; 63   : 
; 64   : // Winsock cleanup
; 65   : #ifdef WIN32
; 66   : 	WSACleanup();

	call	_WSACleanup@0

; 67   : #endif
; 68   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1CHttpClient@@QAE@XZ ENDP				; CHttpClient::~CHttpClient
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\httpclient.cpp
;	COMDAT ??0CHttpClient@@QAE@XZ
_TEXT	SEGMENT
_wsaData$ = -432					; size = 398
_wVersionRequested$ = -24				; size = 2
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
??0CHttpClient@@QAE@XZ PROC				; CHttpClient::CHttpClient, COMDAT
; _this$ = ecx

; 32   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 628				; 00000274H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-628]
	mov	ecx, 157				; 0000009dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 33   : 	memset(&m_Request,0,sizeof(HTTP_REQUEST));

	push	22					; 00000016H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 34   : 	memset(&m_Response,0,sizeof(HTTP_RESPONSE));

	push	24					; 00000018H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 26					; 0000001aH
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 35   : 	m_iError = HTTP_SUCCESS; // Request is successful until otherwise indicated

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+50], 0

; 36   : 	m_iSocket = (-1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], -1

; 37   : 
; 38   : // Winsock init
; 39   : #ifdef WIN32
; 40   : 	WORD				wVersionRequested;
; 41   : 	WSADATA				wsaData;
; 42   : 	wVersionRequested = MAKEWORD(2,2);

	mov	eax, 514				; 00000202H
	mov	WORD PTR _wVersionRequested$[ebp], ax

; 43   : 	WSAStartup(wVersionRequested,&wsaData);

	lea	eax, DWORD PTR _wsaData$[ebp]
	push	eax
	movzx	ecx, WORD PTR _wVersionRequested$[ebp]
	push	ecx
	call	_WSAStartup@8

; 44   : #endif
; 45   : }

	mov	eax, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@CHttpClien
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 628				; 00000274H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN5@CHttpClien:
	DD	1
	DD	$LN4@CHttpClien
$LN4@CHttpClien:
	DD	-432					; fffffe50H
	DD	398					; 0000018eH
	DD	$LN3@CHttpClien
$LN3@CHttpClien:
	DB	119					; 00000077H
	DB	115					; 00000073H
	DB	97					; 00000061H
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
??0CHttpClient@@QAE@XZ ENDP				; CHttpClient::CHttpClient
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\httpclient.cpp
;	COMDAT ?GetHeaderValue@CHttpClient@@QAE_NPAD0H@Z
_TEXT	SEGMENT
_iCopyLength$ = -56					; size = 4
_iLengthSearchHeader$ = -44				; size = 4
_szHeaderEnd$ = -32					; size = 4
_szHeaderStart$ = -20					; size = 4
_this$ = -8						; size = 4
_szHeaderName$ = 8					; size = 4
_szReturnBuffer$ = 12					; size = 4
_iBufSize$ = 16						; size = 4
?GetHeaderValue@CHttpClient@@QAE_NPAD0H@Z PROC		; CHttpClient::GetHeaderValue, COMDAT
; _this$ = ecx

; 84   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 85   : 	char *szHeaderStart;
; 86   : 	char *szHeaderEnd;
; 87   : 	int iLengthSearchHeader = strlen(szHeaderName);

	mov	eax, DWORD PTR _szHeaderName$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _iLengthSearchHeader$[ebp], eax

; 88   : 	int iCopyLength;
; 89   : 
; 90   : 	szHeaderStart = Util_stristr(m_Response.header,szHeaderName);

	mov	eax, DWORD PTR _szHeaderName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	?Util_stristr@@YAPADPBD0@Z		; Util_stristr
	add	esp, 8
	mov	DWORD PTR _szHeaderStart$[ebp], eax

; 91   : 	if(!szHeaderStart) {

	cmp	DWORD PTR _szHeaderStart$[ebp], 0
	jne	SHORT $LN3@GetHeaderV

; 92   : 		return false;

	xor	al, al
	jmp	SHORT $LN4@GetHeaderV
$LN3@GetHeaderV:

; 93   : 	}
; 94   : 	szHeaderStart+=iLengthSearchHeader+1;

	mov	eax, DWORD PTR _iLengthSearchHeader$[ebp]
	mov	ecx, DWORD PTR _szHeaderStart$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR _szHeaderStart$[ebp], edx

; 95   : 
; 96   : 	szHeaderEnd = strchr(szHeaderStart,'\n');

	push	10					; 0000000aH
	mov	eax, DWORD PTR _szHeaderStart$[ebp]
	push	eax
	call	?strchr@@YAPADPADH@Z			; strchr
	add	esp, 8
	mov	DWORD PTR _szHeaderEnd$[ebp], eax

; 97   : 	if(!szHeaderEnd) {

	cmp	DWORD PTR _szHeaderEnd$[ebp], 0
	jne	SHORT $LN2@GetHeaderV

; 98   : 		szHeaderEnd = m_Response.header + strlen(m_Response.header); // (END OF STRING)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx+26]
	mov	DWORD PTR _szHeaderEnd$[ebp], eax
$LN2@GetHeaderV:

; 99   : 	}
; 100  : 
; 101  : 	iCopyLength = szHeaderEnd - szHeaderStart;

	mov	eax, DWORD PTR _szHeaderEnd$[ebp]
	sub	eax, DWORD PTR _szHeaderStart$[ebp]
	mov	DWORD PTR _iCopyLength$[ebp], eax

; 102  : 	if(iBufSize < iCopyLength) {

	mov	eax, DWORD PTR _iBufSize$[ebp]
	cmp	eax, DWORD PTR _iCopyLength$[ebp]
	jge	SHORT $LN1@GetHeaderV

; 103  : 		return false;

	xor	al, al
	jmp	SHORT $LN4@GetHeaderV
$LN1@GetHeaderV:

; 104  : 	}
; 105  : 
; 106  : 	memcpy(szReturnBuffer,szHeaderStart,iCopyLength);

	mov	eax, DWORD PTR _iCopyLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szHeaderStart$[ebp]
	push	ecx
	mov	edx, DWORD PTR _szReturnBuffer$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 107  : 	szReturnBuffer[iCopyLength] = '\0';

	mov	eax, DWORD PTR _szReturnBuffer$[ebp]
	add	eax, DWORD PTR _iCopyLength$[ebp]
	mov	BYTE PTR [eax], 0

; 108  : 	return true;

	mov	al, 1
$LN4@GetHeaderV:

; 109  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetHeaderValue@CHttpClient@@QAE_NPAD0H@Z ENDP		; CHttpClient::GetHeaderValue
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\httpclient.cpp
;	COMDAT ?ProcessURL@CHttpClient@@QAEHHPAD00@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_iType$ = 8						; size = 4
_szURL$ = 12						; size = 4
_szPostData$ = 16					; size = 4
_szReferer$ = 20					; size = 4
?ProcessURL@CHttpClient@@QAEHHPAD00@Z PROC		; CHttpClient::ProcessURL, COMDAT
; _this$ = ecx

; 73   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 74   : 	InitRequest(iType,szURL,szPostData,szReferer);

	mov	eax, DWORD PTR _szReferer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szPostData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _szURL$[ebp]
	push	edx
	mov	eax, DWORD PTR _iType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitRequest@CHttpClient@@AAEXHPAD00@Z	; CHttpClient::InitRequest

; 75   : 
; 76   : 	Process();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Process@CHttpClient@@AAEXXZ		; CHttpClient::Process

; 77   : 
; 78   : 	return m_iError;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+50]

; 79   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?ProcessURL@CHttpClient@@QAEHHPAD00@Z ENDP		; CHttpClient::ProcessURL
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\httpclient.cpp
;	COMDAT ?Process@CHttpClient@@AAEXXZ
_TEXT	SEGMENT
tv77 = -244						; size = 4
$T1 = -233						; size = 1
_request_head$ = -32					; size = 4
_header_len$ = -20					; size = 4
_this$ = -8						; size = 4
?Process@CHttpClient@@AAEXXZ PROC			; CHttpClient::Process, COMDAT
; _this$ = ecx

; 231  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	BYTE PTR $T1[ebp], 0

; 232  : 	int   header_len;
; 233  : 	char  *request_head;
; 234  : 
; 235  : 	if(!Connect(m_Request.host,m_Request.port)) {

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Connect@CHttpClient@@AAE_NPADH@Z	; CHttpClient::Connect
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN7@Process

; 236  : 		return;

	jmp	$LN8@Process
$LN7@Process:

; 237  : 	}
; 238  : 
; 239  : 	// Build the HTTP Header
; 240  : 	switch(m_Request.rtype)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	mov	DWORD PTR tv77[ebp], ecx
	cmp	DWORD PTR tv77[ebp], 1
	je	SHORT $LN4@Process
	cmp	DWORD PTR tv77[ebp], 2
	je	$LN2@Process
	cmp	DWORD PTR tv77[ebp], 3
	je	$LN3@Process
	jmp	$LN5@Process
$LN4@Process:

; 241  : 	{
; 242  : 		case HTTP_GET:
; 243  : 			header_len = strlen(m_Request.file)+strlen(m_Request.host)+
; 244  : 				(strlen(GET_FORMAT)-8)+strlen(USER_AGENT)+
; 245  : 				strlen(m_Request.referer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	push	OFFSET ??_C@_0EP@DCALGLGB@GET?5?$CFs?5HTTP?11?40?$AN?6Accept?3?5?$CK?1?$CK?$AN?6Us@
	call	_strlen
	add	esp, 4
	lea	esi, DWORD PTR [esi+eax-8]
	push	OFFSET ??_C@_0L@IKGODMLA@SAMP?10?42?40?$AA@
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	DWORD PTR _header_len$[ebp], esi

; 246  : 			request_head = (char *)malloc(header_len+1);

	mov	eax, DWORD PTR _header_len$[ebp]
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	BYTE PTR $T1[ebp], 1
	mov	DWORD PTR _request_head$[ebp], eax

; 247  : 			sprintf(request_head,GET_FORMAT,m_Request.file,USER_AGENT,m_Request.referer,m_Request.host);

	cmp	BYTE PTR $T1[ebp], 0
	jne	SHORT $LN10@Process
	push	OFFSET $LN11@Process
	call	__RTC_UninitUse
	add	esp, 4
$LN10@Process:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	push	OFFSET ??_C@_0L@IKGODMLA@SAMP?10?42?40?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	push	OFFSET ??_C@_0EP@DCALGLGB@GET?5?$CFs?5HTTP?11?40?$AN?6Accept?3?5?$CK?1?$CK?$AN?6Us@
	mov	eax, DWORD PTR _request_head$[ebp]
	push	eax
	call	_sprintf
	add	esp, 24					; 00000018H

; 248  : 			break;

	jmp	$LN5@Process
$LN3@Process:

; 249  : 
; 250  : 		case HTTP_HEAD:
; 251  : 			header_len = strlen(m_Request.file)+strlen(m_Request.host)+
; 252  : 				(strlen(HEAD_FORMAT)-8)+strlen(USER_AGENT)+
; 253  : 				strlen(m_Request.referer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	push	OFFSET ??_C@_0FA@NENJLDAP@HEAD?5?$CFs?5HTTP?11?40?$AN?6Accept?3?5?$CK?1?$CK?$AN?6U@
	call	_strlen
	add	esp, 4
	lea	esi, DWORD PTR [esi+eax-8]
	push	OFFSET ??_C@_0L@IKGODMLA@SAMP?10?42?40?$AA@
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	DWORD PTR _header_len$[ebp], esi

; 254  : 			request_head = (char *)malloc(header_len+1);

	mov	eax, DWORD PTR _header_len$[ebp]
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	BYTE PTR $T1[ebp], 1
	mov	DWORD PTR _request_head$[ebp], eax

; 255  : 			sprintf(request_head,HEAD_FORMAT,m_Request.file,USER_AGENT,m_Request.referer,m_Request.host);

	cmp	BYTE PTR $T1[ebp], 0
	jne	SHORT $LN12@Process
	push	OFFSET $LN11@Process
	call	__RTC_UninitUse
	add	esp, 4
$LN12@Process:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	push	OFFSET ??_C@_0L@IKGODMLA@SAMP?10?42?40?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	push	OFFSET ??_C@_0FA@NENJLDAP@HEAD?5?$CFs?5HTTP?11?40?$AN?6Accept?3?5?$CK?1?$CK?$AN?6U@
	mov	eax, DWORD PTR _request_head$[ebp]
	push	eax
	call	_sprintf
	add	esp, 24					; 00000018H

; 256  : 			break;

	jmp	$LN5@Process
$LN2@Process:

; 257  : 
; 258  : 		case HTTP_POST:
; 259  : 			header_len = strlen(m_Request.data)+strlen(m_Request.file)+
; 260  : 				strlen(m_Request.host)+strlen(POST_FORMAT)+
; 261  : 				strlen(USER_AGENT)+strlen(m_Request.referer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	push	OFFSET ??_C@_0JH@BNIDHCGB@POST?5?$CFs?5HTTP?11?40?$AN?6Accept?3?5?$CK?1?$CK?$AN?6U@
	call	_strlen
	add	esp, 4
	add	esi, eax
	push	OFFSET ??_C@_0L@IKGODMLA@SAMP?10?42?40?$AA@
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	DWORD PTR _header_len$[ebp], esi

; 262  : 			request_head = (char *)malloc(header_len+1);

	mov	eax, DWORD PTR _header_len$[ebp]
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	BYTE PTR $T1[ebp], 1
	mov	DWORD PTR _request_head$[ebp], eax

; 263  : 			sprintf(request_head,POST_FORMAT,m_Request.file,USER_AGENT,m_Request.referer,m_Request.host,strlen(m_Request.data),m_Request.data);

	cmp	BYTE PTR $T1[ebp], 0
	jne	SHORT $LN13@Process
	push	OFFSET $LN11@Process
	call	__RTC_UninitUse
	add	esp, 4
$LN13@Process:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	_strlen
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	push	OFFSET ??_C@_0L@IKGODMLA@SAMP?10?42?40?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	push	OFFSET ??_C@_0JH@BNIDHCGB@POST?5?$CFs?5HTTP?11?40?$AN?6Accept?3?5?$CK?1?$CK?$AN?6U@
	mov	ecx, DWORD PTR _request_head$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 32					; 00000020H
$LN5@Process:

; 264  : 			break;	
; 265  : 	}
; 266  : 
; 267  : 	if(!Send(request_head)) {	

	cmp	BYTE PTR $T1[ebp], 0
	jne	SHORT $LN14@Process
	push	OFFSET $LN11@Process
	call	__RTC_UninitUse
	add	esp, 4
$LN14@Process:
	mov	eax, DWORD PTR _request_head$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Send@CHttpClient@@AAE_NPAD@Z		; CHttpClient::Send
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@Process

; 268  : 		free(request_head);

	cmp	BYTE PTR $T1[ebp], 0
	jne	SHORT $LN15@Process
	push	OFFSET $LN11@Process
	call	__RTC_UninitUse
	add	esp, 4
$LN15@Process:
	mov	eax, DWORD PTR _request_head$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 269  : 		return;

	jmp	SHORT $LN8@Process
$LN1@Process:

; 270  : 	}
; 271  : 
; 272  : 	free(request_head);

	cmp	BYTE PTR $T1[ebp], 0
	jne	SHORT $LN16@Process
	push	OFFSET $LN11@Process
	call	__RTC_UninitUse
	add	esp, 4
$LN16@Process:
	mov	eax, DWORD PTR _request_head$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 273  : 
; 274  : 	HandleEntity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?HandleEntity@CHttpClient@@AAEXXZ	; CHttpClient::HandleEntity
$LN8@Process:

; 275  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@Process:
$LN11@Process:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	113					; 00000071H
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	104					; 00000068H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	0
?Process@CHttpClient@@AAEXXZ ENDP			; CHttpClient::Process
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\httpclient.cpp
;	COMDAT ?HandleEntity@CHttpClient@@AAEXXZ
_TEXT	SEGMENT
$T1 = -648						; size = 4
$T2 = -633						; size = 1
_szContentType$ = -432					; size = 256
_response_code_str$ = -168				; size = 4
_content_len$ = -156					; size = 4
_header_len$ = -144					; size = 4
_has_content_len$ = -129				; size = 1
_header_got$ = -117					; size = 1
_content_len_str$ = -108				; size = 4
_pcontent_buf$ = -96					; size = 4
_head_end$ = -84					; size = 4
_header$ = -72						; size = 4
_response$ = -60					; size = 4
_buffer$ = -48						; size = 4
_bytes_read$ = -36					; size = 4
_bytes_total$ = -24					; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?HandleEntity@CHttpClient@@AAEXXZ PROC			; CHttpClient::HandleEntity, COMDAT
; _this$ = ecx

; 282  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 652				; 0000028cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-652]
	mov	ecx, 163				; 000000a3H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	BYTE PTR $T2[ebp], 0

; 283  : 	int				bytes_total		= 0;

	mov	DWORD PTR _bytes_total$[ebp], 0

; 284  : 	int				bytes_read		= 0;

	mov	DWORD PTR _bytes_read$[ebp], 0

; 285  : 	char			*buffer			= (char *)malloc(RECV_BUFFER_SIZE);

	push	2048					; 00000800H
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _buffer$[ebp], eax

; 286  : 	char			*response		= (char *)malloc(1);

	push	1
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _response$[ebp], eax

; 287  : 	char			*header;
; 288  : 	char			*head_end;
; 289  : 	char			*pcontent_buf;
; 290  : 	char			*content_len_str;
; 291  : 
; 292  : 	bool			header_got		= false;

	mov	BYTE PTR _header_got$[ebp], 0

; 293  : 	bool			has_content_len = false;

	mov	BYTE PTR _has_content_len$[ebp], 0

; 294  : 	int				header_len		= 0;

	mov	DWORD PTR _header_len$[ebp], 0

; 295  : 	int				content_len		= 0;

	mov	DWORD PTR _content_len$[ebp], 0
$LN22@HandleEnti:

; 296  : 
; 297  : 	while((bytes_read=Recv(buffer,RECV_BUFFER_SIZE)) > 0)

	push	2048					; 00000800H
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Recv@CHttpClient@@AAEHPADH@Z		; CHttpClient::Recv
	mov	DWORD PTR _bytes_read$[ebp], eax
	cmp	DWORD PTR _bytes_read$[ebp], 0
	jle	$LN21@HandleEnti

; 298  : 	{
; 299  : 		bytes_total+=bytes_read;

	mov	eax, DWORD PTR _bytes_total$[ebp]
	add	eax, DWORD PTR _bytes_read$[ebp]
	mov	DWORD PTR _bytes_total$[ebp], eax

; 300  : 		response=(char *)realloc(response,bytes_total+1);

	mov	eax, DWORD PTR _bytes_total$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _response$[ebp]
	push	ecx
	call	_realloc
	add	esp, 8
	mov	DWORD PTR _response$[ebp], eax

; 301  : 		memcpy(response+(bytes_total-bytes_read),buffer,(unsigned int)bytes_read);

	mov	eax, DWORD PTR _bytes_read$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bytes_total$[ebp]
	sub	edx, DWORD PTR _bytes_read$[ebp]
	add	edx, DWORD PTR _response$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 302  : 	
; 303  : 		if(!header_got)

	movzx	eax, BYTE PTR _header_got$[ebp]
	test	eax, eax
	jne	$LN20@HandleEnti

; 304  : 		{
; 305  : 			if((head_end=strstr(response,"\r\n\r\n"))!=NULL
; 306  : 				|| (head_end=strstr(response,"\n\n"))!=NULL)

	push	OFFSET ??_C@_04FMMHFHOO@?$AN?6?$AN?6?$AA@
	mov	eax, DWORD PTR _response$[ebp]
	push	eax
	call	?strstr@@YAPADPADPBD@Z			; strstr
	add	esp, 8
	mov	DWORD PTR _head_end$[ebp], eax
	cmp	DWORD PTR _head_end$[ebp], 0
	jne	SHORT $LN18@HandleEnti
	push	OFFSET ??_C@_02PHMGELLB@?6?6?$AA@
	mov	eax, DWORD PTR _response$[ebp]
	push	eax
	call	?strstr@@YAPADPADPBD@Z			; strstr
	add	esp, 8
	mov	DWORD PTR _head_end$[ebp], eax
	cmp	DWORD PTR _head_end$[ebp], 0
	je	$LN20@HandleEnti
$LN18@HandleEnti:

; 307  : 			{
; 308  : 
; 309  : 				header_got=true;

	mov	BYTE PTR _header_got$[ebp], 1

; 310  : 
; 311  : 				header_len=(head_end-response);

	mov	eax, DWORD PTR _head_end$[ebp]
	sub	eax, DWORD PTR _response$[ebp]
	mov	DWORD PTR _header_len$[ebp], eax

; 312  : 				header=(char *)malloc(header_len+1);

	mov	eax, DWORD PTR _header_len$[ebp]
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	BYTE PTR $T2[ebp], 1
	mov	DWORD PTR _header$[ebp], eax

; 313  : 				memcpy(header,response,header_len);

	cmp	BYTE PTR $T2[ebp], 0
	jne	SHORT $LN27@HandleEnti
	push	OFFSET $LN28@HandleEnti
	call	__RTC_UninitUse
	add	esp, 4
$LN27@HandleEnti:
	mov	eax, DWORD PTR _header_len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _response$[ebp]
	push	ecx
	mov	edx, DWORD PTR _header$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 314  : 				header[header_len]='\0';

	cmp	BYTE PTR $T2[ebp], 0
	jne	SHORT $LN29@HandleEnti
	push	OFFSET $LN28@HandleEnti
	call	__RTC_UninitUse
	add	esp, 4
$LN29@HandleEnti:
	mov	eax, DWORD PTR _header$[ebp]
	add	eax, DWORD PTR _header_len$[ebp]
	mov	BYTE PTR [eax], 0

; 315  : 
; 316  : 				if((*(response+header_len))=='\n') /* LFLF */

	mov	eax, DWORD PTR _response$[ebp]
	add	eax, DWORD PTR _header_len$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN17@HandleEnti

; 317  : 				{
; 318  : 					bytes_total-=(header_len+2);

	mov	eax, DWORD PTR _header_len$[ebp]
	add	eax, 2
	mov	ecx, DWORD PTR _bytes_total$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _bytes_total$[ebp], ecx

; 319  : 					memmove(response,(response+(header_len+2)),bytes_total);

	mov	eax, DWORD PTR _bytes_total$[ebp]
	push	eax
	mov	ecx, DWORD PTR _header_len$[ebp]
	mov	edx, DWORD PTR _response$[ebp]
	lea	eax, DWORD PTR [edx+ecx+2]
	push	eax
	mov	ecx, DWORD PTR _response$[ebp]
	push	ecx
	call	_memmove
	add	esp, 12					; 0000000cH

; 320  : 				}
; 321  : 				else /* assume CRLFCRLF */

	jmp	SHORT $LN16@HandleEnti
$LN17@HandleEnti:

; 322  : 				{
; 323  : 					bytes_total-=(header_len+4);

	mov	eax, DWORD PTR _header_len$[ebp]
	add	eax, 4
	mov	ecx, DWORD PTR _bytes_total$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _bytes_total$[ebp], ecx

; 324  : 					memmove(response,(response+(header_len+4)),bytes_total);

	mov	eax, DWORD PTR _bytes_total$[ebp]
	push	eax
	mov	ecx, DWORD PTR _header_len$[ebp]
	mov	edx, DWORD PTR _response$[ebp]
	lea	eax, DWORD PTR [edx+ecx+4]
	push	eax
	mov	ecx, DWORD PTR _response$[ebp]
	push	ecx
	call	_memmove
	add	esp, 12					; 0000000cH
$LN16@HandleEnti:

; 325  : 				}
; 326  : 
; 327  : 				/* find the content-length if available */
; 328  : 				if((pcontent_buf=Util_stristr(header,"CONTENT-LENGTH:"))!=NULL)

	cmp	BYTE PTR $T2[ebp], 0
	jne	SHORT $LN30@HandleEnti
	push	OFFSET $LN28@HandleEnti
	call	__RTC_UninitUse
	add	esp, 4
$LN30@HandleEnti:
	push	OFFSET ??_C@_0BA@IOOAPING@CONTENT?9LENGTH?3?$AA@
	mov	eax, DWORD PTR _header$[ebp]
	push	eax
	call	?Util_stristr@@YAPADPBD0@Z		; Util_stristr
	add	esp, 8
	mov	DWORD PTR _pcontent_buf$[ebp], eax
	cmp	DWORD PTR _pcontent_buf$[ebp], 0
	je	$LN20@HandleEnti

; 329  : 				{
; 330  : 					has_content_len=true;

	mov	BYTE PTR _has_content_len$[ebp], 1

; 331  : 
; 332  : 					pcontent_buf+=16;

	mov	eax, DWORD PTR _pcontent_buf$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _pcontent_buf$[ebp], eax
$LN14@HandleEnti:

; 333  : 					while(*pcontent_buf!='\n' && *pcontent_buf)

	mov	eax, DWORD PTR _pcontent_buf$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	je	SHORT $LN13@HandleEnti
	mov	eax, DWORD PTR _pcontent_buf$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN13@HandleEnti

; 334  : 					{
; 335  : 						*pcontent_buf++;

	mov	eax, DWORD PTR _pcontent_buf$[ebp]
	add	eax, 1
	mov	DWORD PTR _pcontent_buf$[ebp], eax

; 336  : 						content_len++;

	mov	eax, DWORD PTR _content_len$[ebp]
	add	eax, 1
	mov	DWORD PTR _content_len$[ebp], eax

; 337  : 					}

	jmp	SHORT $LN14@HandleEnti
$LN13@HandleEnti:

; 338  : 
; 339  : 					content_len_str=(char *)malloc(content_len+1);

	mov	eax, DWORD PTR _content_len$[ebp]
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _content_len_str$[ebp], eax

; 340  : 					pcontent_buf-=content_len;

	mov	eax, DWORD PTR _pcontent_buf$[ebp]
	sub	eax, DWORD PTR _content_len$[ebp]
	mov	DWORD PTR _pcontent_buf$[ebp], eax

; 341  : 					memcpy(content_len_str,pcontent_buf,content_len);

	mov	eax, DWORD PTR _content_len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pcontent_buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _content_len_str$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 342  : 
; 343  : 					if(content_len_str[content_len-1] == '\r') {

	mov	eax, DWORD PTR _content_len_str$[ebp]
	add	eax, DWORD PTR _content_len$[ebp]
	movsx	ecx, BYTE PTR [eax-1]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN12@HandleEnti

; 344  : 						content_len_str[content_len-1]='\0';

	mov	eax, DWORD PTR _content_len_str$[ebp]
	add	eax, DWORD PTR _content_len$[ebp]
	mov	BYTE PTR [eax-1], 0

; 345  : 					}
; 346  : 					else {

	jmp	SHORT $LN11@HandleEnti
$LN12@HandleEnti:

; 347  : 						content_len_str[content_len]='\0';

	mov	eax, DWORD PTR _content_len_str$[ebp]
	add	eax, DWORD PTR _content_len$[ebp]
	mov	BYTE PTR [eax], 0
$LN11@HandleEnti:

; 348  : 					}
; 349  : 
; 350  : 					content_len=atoi(content_len_str);

	mov	eax, DWORD PTR _content_len_str$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	DWORD PTR _content_len$[ebp], eax

; 351  : 					free(content_len_str);

	mov	eax, DWORD PTR _content_len_str$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 352  : 
; 353  : 					if(content_len > MAX_ENTITY_LENGTH) {

	cmp	DWORD PTR _content_len$[ebp], 500000	; 0007a120H
	jle	SHORT $LN20@HandleEnti

; 354  : 						CloseConnection();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CloseConnection@CHttpClient@@AAEXXZ	; CHttpClient::CloseConnection

; 355  : 						m_iError = HTTP_ERROR_CONTENT_TOO_BIG;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+50], 5

; 356  : 						return;

	jmp	$LN24@HandleEnti
$LN20@HandleEnti:

; 357  : 					}
; 358  : 				}
; 359  : 			}
; 360  : 		}
; 361  : 
; 362  : 		if(header_got && has_content_len)

	movzx	eax, BYTE PTR _header_got$[ebp]
	test	eax, eax
	je	SHORT $LN9@HandleEnti
	movzx	eax, BYTE PTR _has_content_len$[ebp]
	test	eax, eax
	je	SHORT $LN9@HandleEnti

; 363  : 			if(bytes_total>=content_len) break;

	mov	eax, DWORD PTR _bytes_total$[ebp]
	cmp	eax, DWORD PTR _content_len$[ebp]
	jl	SHORT $LN9@HandleEnti
	jmp	SHORT $LN21@HandleEnti
$LN9@HandleEnti:

; 364  : 	}

	jmp	$LN22@HandleEnti
$LN21@HandleEnti:

; 365  : 
; 366  : 	CloseConnection();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CloseConnection@CHttpClient@@AAEXXZ	; CHttpClient::CloseConnection

; 367  : 	
; 368  : 	response[bytes_total]='\0';

	mov	eax, DWORD PTR _response$[ebp]
	add	eax, DWORD PTR _bytes_total$[ebp]
	mov	BYTE PTR [eax], 0

; 369  : 	free(buffer);

	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 370  : 
; 371  : 	// check the returned header
; 372  : 	if(!header_got || *(DWORD *)header != 0x50545448) { // 'HTTP'

	movzx	eax, BYTE PTR _header_got$[ebp]
	test	eax, eax
	je	SHORT $LN6@HandleEnti
	cmp	BYTE PTR $T2[ebp], 0
	jne	SHORT $LN31@HandleEnti
	push	OFFSET $LN28@HandleEnti
	call	__RTC_UninitUse
	add	esp, 4
$LN31@HandleEnti:
	mov	eax, DWORD PTR _header$[ebp]
	cmp	DWORD PTR [eax], 1347703880		; 50545448H
	je	SHORT $LN7@HandleEnti
$LN6@HandleEnti:

; 373  : 		m_iError = HTTP_ERROR_MALFORMED_RESPONSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+50], 6

; 374  : 		return;

	jmp	$LN24@HandleEnti
$LN7@HandleEnti:

; 375  : 	}
; 376  : 
; 377  : 	// Now fill in the response code
; 378  : 	char response_code_str[4];
; 379  : 	response_code_str[0] = *(header+9);

	cmp	BYTE PTR $T2[ebp], 0
	jne	SHORT $LN32@HandleEnti
	push	OFFSET $LN28@HandleEnti
	call	__RTC_UninitUse
	add	esp, 4
$LN32@HandleEnti:
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _header$[ebp]
	mov	al, BYTE PTR [edx+9]
	mov	BYTE PTR _response_code_str$[ebp+ecx], al

; 380  : 	response_code_str[1] = *(header+10);

	cmp	BYTE PTR $T2[ebp], 0
	jne	SHORT $LN33@HandleEnti
	push	OFFSET $LN28@HandleEnti
	call	__RTC_UninitUse
	add	esp, 4
$LN33@HandleEnti:
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _header$[ebp]
	mov	dl, BYTE PTR [ecx+10]
	mov	BYTE PTR _response_code_str$[ebp+eax], dl

; 381  : 	response_code_str[2] = *(header+11);

	cmp	BYTE PTR $T2[ebp], 0
	jne	SHORT $LN34@HandleEnti
	push	OFFSET $LN28@HandleEnti
	call	__RTC_UninitUse
	add	esp, 4
$LN34@HandleEnti:
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _header$[ebp]
	mov	dl, BYTE PTR [ecx+11]
	mov	BYTE PTR _response_code_str$[ebp+eax], dl

; 382  : 	response_code_str[3] = '\0';

	mov	eax, 1
	imul	ecx, eax, 3
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 4
	jae	SHORT $LN25@HandleEnti
	jmp	SHORT $LN26@HandleEnti
$LN25@HandleEnti:
	call	___report_rangecheckfailure
$LN26@HandleEnti:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _response_code_str$[ebp+edx], 0

; 383  : 	m_Response.response_code = atoi(response_code_str);

	lea	eax, DWORD PTR _response_code_str$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+42], eax

; 384  : 
; 385  : 	// Copy over the document entity strings and sizes
; 386  : 	m_Response.header		= header;

	cmp	BYTE PTR $T2[ebp], 0
	jne	SHORT $LN35@HandleEnti
	push	OFFSET $LN28@HandleEnti
	call	__RTC_UninitUse
	add	esp, 4
$LN35@HandleEnti:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _header$[ebp]
	mov	DWORD PTR [eax+26], ecx

; 387  : 	m_Response.header_len	= header_len;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _header_len$[ebp]
	mov	DWORD PTR [eax+34], ecx

; 388  : 	m_Response.response		= response;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _response$[ebp]
	mov	DWORD PTR [eax+30], ecx

; 389  : 	m_Response.response_len	= bytes_total;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _bytes_total$[ebp]
	mov	DWORD PTR [eax+38], ecx

; 390  : 
; 391  : 	//printf("Code: %u\n\n%s\n",m_Response.response_code,m_Response.header);
; 392  : 
; 393  : 	// Try and determine the document type
; 394  : 	m_Response.content_type = CONTENT_TYPE_HTML; // default to html

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+46], 2

; 395  : 
; 396  : 	char szContentType[256];
; 397  : 
; 398  : 	if(GetHeaderValue("CONTENT-TYPE:",szContentType,256) == true) {

	push	256					; 00000100H
	lea	eax, DWORD PTR _szContentType$[ebp]
	push	eax
	push	OFFSET ??_C@_0O@LDHIBCHO@CONTENT?9TYPE?3?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetHeaderValue@CHttpClient@@QAE_NPAD0H@Z ; CHttpClient::GetHeaderValue
	movzx	ecx, al
	cmp	ecx, 1
	jne	SHORT $LN24@HandleEnti

; 399  : 		if(strstr(szContentType,"text/html") != NULL) {

	push	OFFSET ??_C@_09KABDMIOB@text?1html?$AA@
	lea	eax, DWORD PTR _szContentType$[ebp]
	push	eax
	call	?strstr@@YAPADPADPBD@Z			; strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN4@HandleEnti

; 400  : 			m_Response.content_type = CONTENT_TYPE_HTML;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+46], 2
	jmp	SHORT $LN24@HandleEnti
$LN4@HandleEnti:

; 401  : 		}
; 402  : 		else if(strstr(szContentType,"text/plain") != NULL) {

	push	OFFSET ??_C@_0L@NPNLKGOJ@text?1plain?$AA@
	lea	eax, DWORD PTR _szContentType$[ebp]
	push	eax
	call	?strstr@@YAPADPADPBD@Z			; strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN2@HandleEnti

; 403  : 			m_Response.content_type = CONTENT_TYPE_TEXT;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+46], 1

; 404  : 		} else {

	jmp	SHORT $LN24@HandleEnti
$LN2@HandleEnti:

; 405  : 			m_Response.content_type = CONTENT_TYPE_UNKNOWN;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+46], 0
$LN24@HandleEnti:

; 406  : 		}
; 407  : 	}
; 408  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN39@HandleEnti
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 652				; 0000028cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN39@HandleEnti:
	DD	2
	DD	$LN38@HandleEnti
$LN38@HandleEnti:
	DD	-168					; ffffff58H
	DD	4
	DD	$LN36@HandleEnti
	DD	-432					; fffffe50H
	DD	256					; 00000100H
	DD	$LN37@HandleEnti
$LN37@HandleEnti:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	84					; 00000054H
	DB	121					; 00000079H
	DB	112					; 00000070H
	DB	101					; 00000065H
	DB	0
$LN36@HandleEnti:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	112					; 00000070H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	95					; 0000005fH
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$LN28@HandleEnti:
	DB	104					; 00000068H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
?HandleEntity@CHttpClient@@AAEXXZ ENDP			; CHttpClient::HandleEntity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\httpclient.cpp
;	COMDAT ?InitRequest@CHttpClient@@AAEXHPAD00@Z
_TEXT	SEGMENT
_szUseURL$ = -68					; size = 4
_slash_ptr$ = -56					; size = 4
_slash_pos$ = -44					; size = 4
_port_char$ = -32					; size = 4
_port$ = -20						; size = 4
_this$ = -8						; size = 4
_iType$ = 8						; size = 4
_szURL$ = 12						; size = 4
_szPostData$ = 16					; size = 4
_szReferer$ = 20					; size = 4
?InitRequest@CHttpClient@@AAEXHPAD00@Z PROC		; CHttpClient::InitRequest, COMDAT
; _this$ = ecx

; 177  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 178  : 	char		 *port;			// port string
; 179  : 	char		 *port_char;	// position of ':' if any
; 180  : 	unsigned int slash_pos;		// position of first '/' numeric
; 181  : 	char		 *slash_ptr;
; 182  : 	char		 *szUseURL; // incase we have to cat something to it.
; 183  : 
; 184  : 	szUseURL = (char *)malloc(strlen(szURL)+256);

	mov	eax, DWORD PTR _szURL$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 256				; 00000100H
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _szUseURL$[ebp], eax

; 185  : 	strcpy(szUseURL,szURL);

	mov	eax, DWORD PTR _szURL$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szUseURL$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 186  : 
; 187  : 	m_Request.rtype = iType;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iType$[ebp]
	mov	DWORD PTR [eax+6], ecx

; 188  : 	m_Request.referer = (char *)malloc(strlen(szReferer)+1);

	mov	eax, DWORD PTR _szReferer$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+22], eax

; 189  : 	strcpy(m_Request.referer,szReferer);

	mov	eax, DWORD PTR _szReferer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	call	_strcpy
	add	esp, 8

; 190  : 
; 191  : 	if(iType==HTTP_POST) {

	cmp	DWORD PTR _iType$[ebp], 2
	jne	SHORT $LN4@InitReques

; 192  : 		m_Request.data=(char *)malloc(strlen(szPostData)+1);

	mov	eax, DWORD PTR _szPostData$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+18], eax

; 193  : 		strcpy(m_Request.data,szPostData);

	mov	eax, DWORD PTR _szPostData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	_strcpy
	add	esp, 8
$LN4@InitReques:

; 194  : 	}
; 195  : 
; 196  : 	// Copy hostname from URL
; 197  : 	slash_ptr = strchr(szUseURL,'/');

	push	47					; 0000002fH
	mov	eax, DWORD PTR _szUseURL$[ebp]
	push	eax
	call	?strchr@@YAPADPADH@Z			; strchr
	add	esp, 8
	mov	DWORD PTR _slash_ptr$[ebp], eax

; 198  : 
; 199  : 	if(!slash_ptr) {

	cmp	DWORD PTR _slash_ptr$[ebp], 0
	jne	SHORT $LN3@InitReques

; 200  : 		strcat(szUseURL,"/");

	push	OFFSET ??_C@_01KMDKNFGN@?1?$AA@
	mov	eax, DWORD PTR _szUseURL$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 201  : 		slash_ptr = strchr(szUseURL,'/');

	push	47					; 0000002fH
	mov	eax, DWORD PTR _szUseURL$[ebp]
	push	eax
	call	?strchr@@YAPADPADH@Z			; strchr
	add	esp, 8
	mov	DWORD PTR _slash_ptr$[ebp], eax
$LN3@InitReques:

; 202  : 	}
; 203  : 
; 204  : 	slash_pos=(slash_ptr-szUseURL);

	mov	eax, DWORD PTR _slash_ptr$[ebp]
	sub	eax, DWORD PTR _szUseURL$[ebp]
	mov	DWORD PTR _slash_pos$[ebp], eax

; 205  : 	m_Request.host=(char *)malloc(slash_pos+1);

	mov	eax, DWORD PTR _slash_pos$[ebp]
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+10], eax

; 206  : 	memcpy(m_Request.host,szUseURL,slash_pos);

	mov	eax, DWORD PTR _slash_pos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szUseURL$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 207  : 	m_Request.host[slash_pos]='\0';

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	mov	edx, DWORD PTR _slash_pos$[ebp]
	mov	BYTE PTR [ecx+edx], 0

; 208  : 
; 209  : 	// Copy the rest of the url to the file string.
; 210  : 	m_Request.file=(char *)malloc((strlen(szUseURL)-slash_pos)+1);

	mov	eax, DWORD PTR _szUseURL$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	sub	eax, DWORD PTR _slash_pos$[ebp]
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+14], eax

; 211  : 	strcpy(m_Request.file,strchr(szUseURL,'/'));

	push	47					; 0000002fH
	mov	eax, DWORD PTR _szUseURL$[ebp]
	push	eax
	call	?strchr@@YAPADPADH@Z			; strchr
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	_strcpy
	add	esp, 8

; 212  : 
; 213  : 	// Any special port used in the URL?
; 214  : 	if((port_char=strchr(m_Request.host,':'))!=NULL) {

	push	58					; 0000003aH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	?strchr@@YAPADPADH@Z			; strchr
	add	esp, 8
	mov	DWORD PTR _port_char$[ebp], eax
	cmp	DWORD PTR _port_char$[ebp], 0
	je	SHORT $LN2@InitReques

; 215  : 		port=(char *)malloc(strlen(port_char));

	mov	eax, DWORD PTR _port_char$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _port$[ebp], eax

; 216  : 		strcpy(port,port_char+1);

	mov	eax, DWORD PTR _port_char$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _port$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 217  : 		*port_char='\0';

	mov	eax, DWORD PTR _port_char$[ebp]
	mov	BYTE PTR [eax], 0

; 218  : 		m_Request.port = atoi(port);

	mov	eax, DWORD PTR _port$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+4], ax

; 219  : 		free(port);

	mov	eax, DWORD PTR _port$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 220  : 	}
; 221  : 	else {

	jmp	SHORT $LN1@InitReques
$LN2@InitReques:

; 222  : 		m_Request.port = 80;

	mov	eax, 80					; 00000050H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+4], ax
$LN1@InitReques:

; 223  : 	}
; 224  : 
; 225  : 	free(szUseURL);

	mov	eax, DWORD PTR _szUseURL$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 226  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?InitRequest@CHttpClient@@AAEXHPAD00@Z ENDP		; CHttpClient::InitRequest
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\httpclient.cpp
;	COMDAT ?Recv@CHttpClient@@AAEHPADH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_szBuffer$ = 8						; size = 4
_iBufferSize$ = 12					; size = 4
?Recv@CHttpClient@@AAEHPADH@Z PROC			; CHttpClient::Recv, COMDAT
; _this$ = ecx

; 170  : {	

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 171  : 	return recv(m_iSocket,szBuffer,iBufferSize,0);

	push	0
	mov	eax, DWORD PTR _iBufferSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szBuffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_recv@16

; 172  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?Recv@CHttpClient@@AAEHPADH@Z ENDP			; CHttpClient::Recv
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\httpclient.cpp
;	COMDAT ?Send@CHttpClient@@AAE_NPAD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_szData$ = 8						; size = 4
?Send@CHttpClient@@AAE_NPAD@Z PROC			; CHttpClient::Send, COMDAT
; _this$ = ecx

; 159  : {	

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 	if(send(m_iSocket,szData,strlen(szData),0) < 0) {	

	push	0
	mov	eax, DWORD PTR _szData$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _szData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_send@16
	test	eax, eax
	jge	SHORT $LN1@Send

; 161  : 		m_iError = HTTP_ERROR_CANT_WRITE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+50], 4

; 162  : 		return false;

	xor	al, al
	jmp	SHORT $LN2@Send
$LN1@Send:

; 163  : 	}
; 164  : 	return true;

	mov	al, 1
$LN2@Send:

; 165  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Send@CHttpClient@@AAE_NPAD@Z ENDP			; CHttpClient::Send
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\httpclient.cpp
;	COMDAT ?CloseConnection@CHttpClient@@AAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?CloseConnection@CHttpClient@@AAEXXZ PROC		; CHttpClient::CloseConnection, COMDAT
; _this$ = ecx

; 148  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 149  : #ifdef WIN32
; 150  : 	closesocket(m_iSocket);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_closesocket@4

; 151  : #else
; 152  : 	close(m_iSocket);
; 153  : #endif
; 154  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?CloseConnection@CHttpClient@@AAEXXZ ENDP		; CHttpClient::CloseConnection
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\httpclient.cpp
;	COMDAT ?Connect@CHttpClient@@AAE_NPADH@Z
_TEXT	SEGMENT
tv83 = -248						; size = 4
_hp$ = -48						; size = 4
_sa$ = -36						; size = 16
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_szHost$ = 8						; size = 4
_iPort$ = 12						; size = 4
?Connect@CHttpClient@@AAE_NPADH@Z PROC			; CHttpClient::Connect, COMDAT
; _this$ = ecx

; 114  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 248				; 000000f8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-248]
	mov	ecx, 62					; 0000003eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 115  : 	struct sockaddr_in	sa;
; 116  : 	struct hostent		*hp;
; 117  : 
; 118  : 	// Hostname translation
; 119  : 	if((hp=(struct hostent *)gethostbyname(szHost)) == NULL ) {

	mov	eax, DWORD PTR _szHost$[ebp]
	push	eax
	call	_gethostbyname@4
	mov	DWORD PTR _hp$[ebp], eax
	cmp	DWORD PTR _hp$[ebp], 0
	jne	SHORT $LN3@Connect

; 120  : 		m_iError=HTTP_ERROR_BAD_HOST;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+50], 1

; 121  : 		return false;

	xor	al, al
	jmp	$LN4@Connect
$LN3@Connect:

; 122  : 	}
; 123  : 
; 124  : 	// Prepare a socket	
; 125  : 	memset(&sa,0,sizeof(sa));

	push	16					; 00000010H
	push	0
	lea	eax, DWORD PTR _sa$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 126  : 	memcpy(&sa.sin_addr,hp->h_addr,hp->h_length);

	mov	eax, DWORD PTR _hp$[ebp]
	movsx	ecx, WORD PTR [eax+10]
	push	ecx
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _hp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx+eax]
	push	eax
	lea	ecx, DWORD PTR _sa$[ebp+4]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 127  : 	sa.sin_family = hp->h_addrtype;

	mov	eax, DWORD PTR _hp$[ebp]
	mov	cx, WORD PTR [eax+8]
	mov	WORD PTR _sa$[ebp], cx

; 128  : 	sa.sin_port = htons((unsigned short)iPort);

	movzx	eax, WORD PTR _iPort$[ebp]
	push	eax
	call	_htons@4
	mov	WORD PTR _sa$[ebp+2], ax

; 129  : 
; 130  : 	if((m_iSocket=socket(AF_INET,SOCK_STREAM,0)) < 0) {

	push	0
	push	1
	push	2
	call	_socket@12
	mov	DWORD PTR tv83[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR tv83[ebp]
	mov	DWORD PTR [eax], ecx
	cmp	DWORD PTR tv83[ebp], 0
	jge	SHORT $LN2@Connect

; 131  : 		m_iError=HTTP_ERROR_NO_SOCKET;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+50], 2

; 132  : 		return false;

	xor	al, al
	jmp	SHORT $LN4@Connect
$LN2@Connect:

; 133  : 	}
; 134  : 
; 135  : 	// Try to connect
; 136  : 	if(connect(m_iSocket,(struct sockaddr *)&sa,sizeof sa) < 0)	{

	push	16					; 00000010H
	lea	eax, DWORD PTR _sa$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_connect@12
	test	eax, eax
	jge	SHORT $LN1@Connect

; 137  : 		CloseConnection();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CloseConnection@CHttpClient@@AAEXXZ	; CHttpClient::CloseConnection

; 138  : 		m_iError=HTTP_ERROR_CANT_CONNECT;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+50], 3

; 139  : 		return false;

	xor	al, al
	jmp	SHORT $LN4@Connect
$LN1@Connect:

; 140  : 	}
; 141  : 
; 142  : 	return true;

	mov	al, 1
$LN4@Connect:

; 143  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@Connect
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 248				; 000000f8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$LN8@Connect:
	DD	1
	DD	$LN7@Connect
$LN7@Connect:
	DD	-36					; ffffffdcH
	DD	16					; 00000010H
	DD	$LN6@Connect
$LN6@Connect:
	DB	115					; 00000073H
	DB	97					; 00000061H
	DB	0
?Connect@CHttpClient@@AAE_NPADH@Z ENDP			; CHttpClient::Connect
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
;	COMDAT ?strstr@@YAPADPADPBD@Z
_TEXT	SEGMENT
__Str$ = 8						; size = 4
__SubStr$ = 12						; size = 4
?strstr@@YAPADPADPBD@Z PROC				; strstr, COMDAT

; 228  :         { return (char*)strstr((const char*)_Str, _SubStr); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR __SubStr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Str$[ebp]
	push	ecx
	call	_strstr
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?strstr@@YAPADPADPBD@Z ENDP				; strstr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
;	COMDAT ?strchr@@YAPADPADH@Z
_TEXT	SEGMENT
__Str$ = 8						; size = 4
__Ch$ = 12						; size = 4
?strchr@@YAPADPADH@Z PROC				; strchr, COMDAT

; 222  :         { return (char*)strchr((const char*)_Str, _Ch); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Str$[ebp]
	push	ecx
	call	_strchr
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?strchr@@YAPADPADH@Z ENDP				; strchr
_TEXT	ENDS
END
