; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.31101.0 

	TITLE	Z:\sampsrc\02Xu1\saco\d3d9\common\DXUT.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	_g_pfnGetSystemMetrics
PUBLIC	_g_pfnMonitorFromWindow
PUBLIC	_g_pfnMonitorFromRect
PUBLIC	_g_pfnMonitorFromPoint
PUBLIC	_g_pfnGetMonitorInfo
PUBLIC	_g_pfnEnumDisplayMonitors
PUBLIC	_g_pfnEnumDisplayDevices
PUBLIC	_g_fMultiMonInitDone
PUBLIC	_g_fMultimonPlatformNT
PUBLIC	?g_cs@@3U_RTL_CRITICAL_SECTION@@A		; g_cs
PUBLIC	?g_bThreadSafe@@3_NA				; g_bThreadSafe
_BSS	SEGMENT
_g_pfnGetSystemMetrics DD 01H DUP (?)
_g_pfnMonitorFromWindow DD 01H DUP (?)
_g_pfnMonitorFromRect DD 01H DUP (?)
_g_pfnMonitorFromPoint DD 01H DUP (?)
_g_pfnGetMonitorInfo DD 01H DUP (?)
_g_pfnEnumDisplayMonitors DD 01H DUP (?)
_g_pfnEnumDisplayDevices DD 01H DUP (?)
_g_fMultiMonInitDone DD 01H DUP (?)
_g_fMultimonPlatformNT DD 01H DUP (?)
?g_cs@@3U_RTL_CRITICAL_SECTION@@A DB 018H DUP (?)	; g_cs
_BSS	ENDS
_DATA	SEGMENT
?g_bThreadSafe@@3_NA DB 01H				; g_bThreadSafe
_DATA	ENDS
PUBLIC	_HRESULT_FROM_WIN32
PUBLIC	?abs@@YAJJ@Z					; abs
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	_xGetSystemMetrics@4
PUBLIC	_xMonitorFromWindow@8
PUBLIC	_xMonitorFromRect@8
PUBLIC	_xMonitorFromPoint@12
PUBLIC	_xGetMonitorInfo@8
PUBLIC	_xEnumDisplayMonitors@16
PUBLIC	_xEnumDisplayDevices@16
PUBLIC	?StringCopyWorkerA@@YGJPADIPBD@Z		; StringCopyWorkerA
PUBLIC	?StringCatWorkerA@@YGJPADIPBD@Z			; StringCatWorkerA
PUBLIC	?StringVPrintfWorkerA@@YGJPADIPBD0@Z		; StringVPrintfWorkerA
PUBLIC	?StringLengthWorkerA@@YGJPBDIPAI@Z		; StringLengthWorkerA
PUBLIC	?StringCchCopyA@@YGJPADIPBD@Z			; StringCchCopyA
PUBLIC	?StringCchCatA@@YGJPADIPBD@Z			; StringCchCatA
PUBLIC	?StringCchPrintfA@@YAJPADIPBDZZ			; StringCchPrintfA
PUBLIC	?DXUTSetCallbackDeviceCreated@@YAXP6GJPAUIDirect3DDevice9@@PBU_D3DSURFACE_DESC@@PAX@Z2@Z ; DXUTSetCallbackDeviceCreated
PUBLIC	?DXUTSetCallbackDeviceReset@@YAXP6GJPAUIDirect3DDevice9@@PBU_D3DSURFACE_DESC@@PAX@Z2@Z ; DXUTSetCallbackDeviceReset
PUBLIC	?DXUTSetCallbackDeviceLost@@YAXP6GXPAX@Z0@Z	; DXUTSetCallbackDeviceLost
PUBLIC	?DXUTSetCallbackDeviceDestroyed@@YAXP6GXPAX@Z0@Z ; DXUTSetCallbackDeviceDestroyed
PUBLIC	?DXUTSetCallbackDeviceChanging@@YAXP6G_NPAUDXUTDeviceSettings@@PBU_D3DCAPS9@@PAX@Z2@Z ; DXUTSetCallbackDeviceChanging
PUBLIC	?DXUTSetCallbackFrameMove@@YAXP6GXPAUIDirect3DDevice9@@NMPAX@Z1@Z ; DXUTSetCallbackFrameMove
PUBLIC	?DXUTSetCallbackFrameRender@@YAXP6GXPAUIDirect3DDevice9@@NMPAX@Z1@Z ; DXUTSetCallbackFrameRender
PUBLIC	?DXUTSetCallbackKeyboard@@YAXP6GXI_N0PAX@Z1@Z	; DXUTSetCallbackKeyboard
PUBLIC	?DXUTSetCallbackMouse@@YAXP6GX_N0000HHHPAX@Z01@Z ; DXUTSetCallbackMouse
PUBLIC	?DXUTSetCallbackMsgProc@@YAXP6GJPAUHWND__@@IIJPA_NPAX@Z2@Z ; DXUTSetCallbackMsgProc
PUBLIC	?DXUTInit@@YAJ_N00@Z				; DXUTInit
PUBLIC	?DXUTCreateWindow@@YAJPBDPAUHINSTANCE__@@PAUHICON__@@PAUHMENU__@@HH@Z ; DXUTCreateWindow
PUBLIC	?DXUTSetWindow@@YAJPAUHWND__@@00_N@Z		; DXUTSetWindow
PUBLIC	?DXUTStaticWndProc@@YGJPAUHWND__@@IIJ@Z		; DXUTStaticWndProc
PUBLIC	?DXUTCreateDevice@@YAJI_NHHP6G_NPAU_D3DCAPS9@@W4_D3DFORMAT@@20PAX@ZP6G_NPAUDXUTDeviceSettings@@PBU1@3@Z3@Z ; DXUTCreateDevice
PUBLIC	?DXUTCreateDeviceFromSettings@@YAJPAUDXUTDeviceSettings@@_N1@Z ; DXUTCreateDeviceFromSettings
PUBLIC	?DXUTSetDevice@@YAJPAUIDirect3DDevice9@@@Z	; DXUTSetDevice
PUBLIC	?DXUTMainLoop@@YAJPAUHACCEL__@@@Z		; DXUTMainLoop
PUBLIC	?DXUTRender3DEnvironment@@YAXXZ			; DXUTRender3DEnvironment
PUBLIC	?DXUTFindValidDeviceSettings@@YAJPAUDXUTDeviceSettings@@0PAUDXUTMatchOptions@@@Z ; DXUTFindValidDeviceSettings
PUBLIC	?DXUTSetCursorSettings@@YAX_N0@Z		; DXUTSetCursorSettings
PUBLIC	?DXUTSetMultimonSettings@@YAX_N@Z		; DXUTSetMultimonSettings
PUBLIC	?DXUTSetShortcutKeySettings@@YAX_N0@Z		; DXUTSetShortcutKeySettings
PUBLIC	?DXUTSetConstantFrameTime@@YAX_NM@Z		; DXUTSetConstantFrameTime
PUBLIC	?DXUTSetTimer@@YAJP6GXIPAX@ZMPAI0@Z		; DXUTSetTimer
PUBLIC	?DXUTKillTimer@@YAJI@Z				; DXUTKillTimer
PUBLIC	?DXUTToggleFullScreen@@YAJXZ			; DXUTToggleFullScreen
PUBLIC	?DXUTToggleREF@@YAJXZ				; DXUTToggleREF
PUBLIC	?DXUTPause@@YAX_N0@Z				; DXUTPause
PUBLIC	?DXUTResetFrameworkState@@YAXXZ			; DXUTResetFrameworkState
PUBLIC	?DXUTShutdown@@YAXH@Z				; DXUTShutdown
PUBLIC	?DXUTGetD3DObject@@YAPAUIDirect3D9@@XZ		; DXUTGetD3DObject
PUBLIC	?DXUTGetD3DDevice@@YAPAUIDirect3DDevice9@@XZ	; DXUTGetD3DDevice
PUBLIC	?DXUTGetDeviceSettings@@YA?AUDXUTDeviceSettings@@XZ ; DXUTGetDeviceSettings
PUBLIC	?DXUTGetPresentParameters@@YA?AU_D3DPRESENT_PARAMETERS_@@XZ ; DXUTGetPresentParameters
PUBLIC	?DXUTGetBackBufferSurfaceDesc@@YAPBU_D3DSURFACE_DESC@@XZ ; DXUTGetBackBufferSurfaceDesc
PUBLIC	?DXUTGetDeviceCaps@@YAPBU_D3DCAPS9@@XZ		; DXUTGetDeviceCaps
PUBLIC	?DXUTGetHINSTANCE@@YAPAUHINSTANCE__@@XZ		; DXUTGetHINSTANCE
PUBLIC	?DXUTGetHWND@@YAPAUHWND__@@XZ			; DXUTGetHWND
PUBLIC	?DXUTGetHWNDFocus@@YAPAUHWND__@@XZ		; DXUTGetHWNDFocus
PUBLIC	?DXUTGetHWNDDeviceFullScreen@@YAPAUHWND__@@XZ	; DXUTGetHWNDDeviceFullScreen
PUBLIC	?DXUTGetHWNDDeviceWindowed@@YAPAUHWND__@@XZ	; DXUTGetHWNDDeviceWindowed
PUBLIC	?DXUTGetWindowClientRect@@YA?AUtagRECT@@XZ	; DXUTGetWindowClientRect
PUBLIC	?DXUTGetWindowClientRectAtModeChange@@YA?AUtagRECT@@XZ ; DXUTGetWindowClientRectAtModeChange
PUBLIC	?DXUTGetFullsceenClientRectAtModeChange@@YA?AUtagRECT@@XZ ; DXUTGetFullsceenClientRectAtModeChange
PUBLIC	?DXUTGetTime@@YANXZ				; DXUTGetTime
PUBLIC	?DXUTGetElapsedTime@@YAMXZ			; DXUTGetElapsedTime
PUBLIC	?DXUTIsWindowed@@YA_NXZ				; DXUTIsWindowed
PUBLIC	?DXUTGetFPS@@YAMXZ				; DXUTGetFPS
PUBLIC	?DXUTGetWindowTitle@@YAPBDXZ			; DXUTGetWindowTitle
PUBLIC	?DXUTGetFrameStats@@YAPBDXZ			; DXUTGetFrameStats
PUBLIC	?DXUTGetDeviceStats@@YAPBDXZ			; DXUTGetDeviceStats
PUBLIC	?DXUTIsRenderingPaused@@YA_NXZ			; DXUTIsRenderingPaused
PUBLIC	?DXUTIsTimePaused@@YA_NXZ			; DXUTIsTimePaused
PUBLIC	?DXUTGetExitCode@@YAHXZ				; DXUTGetExitCode
PUBLIC	?DXUTGetShowMsgBoxOnError@@YA_NXZ		; DXUTGetShowMsgBoxOnError
PUBLIC	?DXUTIsKeyDown@@YA_NE@Z				; DXUTIsKeyDown
PUBLIC	?DXUTIsMouseButtonDown@@YA_NE@Z			; DXUTIsMouseButtonDown
PUBLIC	?DXUTGetAutomation@@YA_NXZ			; DXUTGetAutomation
PUBLIC	?DXUTReset3DEnvironment@@YAJXZ			; DXUTReset3DEnvironment
PUBLIC	?DXUTCleanup3DEnvironment@@YAX_N@Z		; DXUTCleanup3DEnvironment
PUBLIC	?DXUTTrace@@YGJPBDKJ0_N@Z			; DXUTTrace
PUBLIC	?GetAt@?$CGrowableArray@W4_D3DFORMAT@@@@QAEAAW4_D3DFORMAT@@H@Z ; CGrowableArray<enum _D3DFORMAT>::GetAt
PUBLIC	?GetSize@?$CGrowableArray@W4_D3DFORMAT@@@@QBEHXZ ; CGrowableArray<enum _D3DFORMAT>::GetSize
PUBLIC	?Contains@?$CGrowableArray@W4_D3DFORMAT@@@@QAE_NABW4_D3DFORMAT@@@Z ; CGrowableArray<enum _D3DFORMAT>::Contains
PUBLIC	?IndexOf@?$CGrowableArray@W4_D3DFORMAT@@@@QAEHABW4_D3DFORMAT@@@Z ; CGrowableArray<enum _D3DFORMAT>::IndexOf
PUBLIC	?IndexOf@?$CGrowableArray@W4_D3DFORMAT@@@@QAEHABW4_D3DFORMAT@@HH@Z ; CGrowableArray<enum _D3DFORMAT>::IndexOf
PUBLIC	?GetAt@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEAAW4_D3DMULTISAMPLE_TYPE@@H@Z ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::GetAt
PUBLIC	?GetSize@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QBEHXZ ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::GetSize
PUBLIC	?Contains@?$CGrowableArray@I@@QAE_NABI@Z	; CGrowableArray<unsigned int>::Contains
PUBLIC	?IndexOf@?$CGrowableArray@I@@QAEHABI@Z		; CGrowableArray<unsigned int>::IndexOf
PUBLIC	?IndexOf@?$CGrowableArray@I@@QAEHABIHH@Z	; CGrowableArray<unsigned int>::IndexOf
PUBLIC	?GetAt@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAEAAPAVCD3DEnumAdapterInfo@@H@Z ; CGrowableArray<CD3DEnumAdapterInfo *>::GetAt
PUBLIC	?GetSize@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QBEHXZ ; CGrowableArray<CD3DEnumAdapterInfo *>::GetSize
PUBLIC	?GetAt@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAEAAU_D3DDISPLAYMODE@@H@Z ; CGrowableArray<_D3DDISPLAYMODE>::GetAt
PUBLIC	?GetSize@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QBEHXZ ; CGrowableArray<_D3DDISPLAYMODE>::GetSize
PUBLIC	?GetAt@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QAEAAPAVCD3DEnumDeviceInfo@@H@Z ; CGrowableArray<CD3DEnumDeviceInfo *>::GetAt
PUBLIC	?GetSize@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QBEHXZ ; CGrowableArray<CD3DEnumDeviceInfo *>::GetSize
PUBLIC	?GetAt@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QAEAAPAUCD3DEnumDeviceSettingsCombo@@H@Z ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::GetAt
PUBLIC	?GetSize@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QBEHXZ ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::GetSize
PUBLIC	?GetAt@?$CGrowableArray@K@@QAEAAKH@Z		; CGrowableArray<unsigned long>::GetAt
PUBLIC	??0?$CGrowableArray@H@@QAE@XZ			; CGrowableArray<int>::CGrowableArray<int>
PUBLIC	??1?$CGrowableArray@H@@QAE@XZ			; CGrowableArray<int>::~CGrowableArray<int>
PUBLIC	?SetSize@?$CGrowableArray@H@@QAEJH@Z		; CGrowableArray<int>::SetSize
PUBLIC	?Add@?$CGrowableArray@H@@QAEJABH@Z		; CGrowableArray<int>::Add
PUBLIC	?SetAt@?$CGrowableArray@H@@QAEJHABH@Z		; CGrowableArray<int>::SetAt
PUBLIC	?GetAt@?$CGrowableArray@H@@QAEAAHH@Z		; CGrowableArray<int>::GetAt
PUBLIC	?RemoveAll@?$CGrowableArray@H@@QAEXXZ		; CGrowableArray<int>::RemoveAll
PUBLIC	?SetSizeInternal@?$CGrowableArray@H@@IAEJH@Z	; CGrowableArray<int>::SetSizeInternal
PUBLIC	_IsPlatformNT
PUBLIC	_InitMultipleMonitorStubs
PUBLIC	??0DXUTLock@@QAE@XZ				; DXUTLock::DXUTLock
PUBLIC	??1DXUTLock@@QAE@XZ				; DXUTLock::~DXUTLock
PUBLIC	??0DXUTState@@QAE@XZ				; DXUTState::DXUTState
PUBLIC	??1DXUTState@@QAE@XZ				; DXUTState::~DXUTState
PUBLIC	?Create@DXUTState@@QAEXXZ			; DXUTState::Create
PUBLIC	?Destroy@DXUTState@@QAEXXZ			; DXUTState::Destroy
PUBLIC	?SetD3D@DXUTState@@QAEXPAUIDirect3D9@@@Z	; DXUTState::SetD3D
PUBLIC	?GetD3D@DXUTState@@QAEPAUIDirect3D9@@XZ		; DXUTState::GetD3D
PUBLIC	?SetD3DDevice@DXUTState@@QAEXPAUIDirect3DDevice9@@@Z ; DXUTState::SetD3DDevice
PUBLIC	?GetD3DDevice@DXUTState@@QAEPAUIDirect3DDevice9@@XZ ; DXUTState::GetD3DDevice
PUBLIC	?SetD3DEnumeration@DXUTState@@QAEXPAVCD3DEnumeration@@@Z ; DXUTState::SetD3DEnumeration
PUBLIC	?GetD3DEnumeration@DXUTState@@QAEPAVCD3DEnumeration@@XZ ; DXUTState::GetD3DEnumeration
PUBLIC	?SetCurrentDeviceSettings@DXUTState@@QAEXPAUDXUTDeviceSettings@@@Z ; DXUTState::SetCurrentDeviceSettings
PUBLIC	?GetCurrentDeviceSettings@DXUTState@@QAEPAUDXUTDeviceSettings@@XZ ; DXUTState::GetCurrentDeviceSettings
PUBLIC	?GetBackBufferSurfaceDesc@DXUTState@@QAEPAU_D3DSURFACE_DESC@@XZ ; DXUTState::GetBackBufferSurfaceDesc
PUBLIC	?GetCaps@DXUTState@@QAEPAU_D3DCAPS9@@XZ		; DXUTState::GetCaps
PUBLIC	?SetHWNDFocus@DXUTState@@QAEXPAUHWND__@@@Z	; DXUTState::SetHWNDFocus
PUBLIC	?GetHWNDFocus@DXUTState@@QAEPAUHWND__@@XZ	; DXUTState::GetHWNDFocus
PUBLIC	?SetHWNDDeviceFullScreen@DXUTState@@QAEXPAUHWND__@@@Z ; DXUTState::SetHWNDDeviceFullScreen
PUBLIC	?GetHWNDDeviceFullScreen@DXUTState@@QAEPAUHWND__@@XZ ; DXUTState::GetHWNDDeviceFullScreen
PUBLIC	?SetHWNDDeviceWindowed@DXUTState@@QAEXPAUHWND__@@@Z ; DXUTState::SetHWNDDeviceWindowed
PUBLIC	?GetHWNDDeviceWindowed@DXUTState@@QAEPAUHWND__@@XZ ; DXUTState::GetHWNDDeviceWindowed
PUBLIC	?SetAdapterMonitor@DXUTState@@QAEXPAUHMONITOR__@@@Z ; DXUTState::SetAdapterMonitor
PUBLIC	?GetAdapterMonitor@DXUTState@@QAEPAUHMONITOR__@@XZ ; DXUTState::GetAdapterMonitor
PUBLIC	?SetMenu@DXUTState@@QAEXPAUHMENU__@@@Z		; DXUTState::SetMenu
PUBLIC	?GetMenu@DXUTState@@QAEPAUHMENU__@@XZ		; DXUTState::GetMenu
PUBLIC	?SetFullScreenBackBufferWidthAtModeChange@DXUTState@@QAEXI@Z ; DXUTState::SetFullScreenBackBufferWidthAtModeChange
PUBLIC	?GetFullScreenBackBufferWidthAtModeChange@DXUTState@@QAEIXZ ; DXUTState::GetFullScreenBackBufferWidthAtModeChange
PUBLIC	?SetFullScreenBackBufferHeightAtModeChange@DXUTState@@QAEXI@Z ; DXUTState::SetFullScreenBackBufferHeightAtModeChange
PUBLIC	?GetFullScreenBackBufferHeightAtModeChange@DXUTState@@QAEIXZ ; DXUTState::GetFullScreenBackBufferHeightAtModeChange
PUBLIC	?SetWindowBackBufferWidthAtModeChange@DXUTState@@QAEXI@Z ; DXUTState::SetWindowBackBufferWidthAtModeChange
PUBLIC	?GetWindowBackBufferWidthAtModeChange@DXUTState@@QAEIXZ ; DXUTState::GetWindowBackBufferWidthAtModeChange
PUBLIC	?SetWindowBackBufferHeightAtModeChange@DXUTState@@QAEXI@Z ; DXUTState::SetWindowBackBufferHeightAtModeChange
PUBLIC	?GetWindowBackBufferHeightAtModeChange@DXUTState@@QAEIXZ ; DXUTState::GetWindowBackBufferHeightAtModeChange
PUBLIC	?GetWindowedPlacement@DXUTState@@QAEPAUtagWINDOWPLACEMENT@@XZ ; DXUTState::GetWindowedPlacement
PUBLIC	?SetWindowedStyleAtModeChange@DXUTState@@QAEXK@Z ; DXUTState::SetWindowedStyleAtModeChange
PUBLIC	?GetWindowedStyleAtModeChange@DXUTState@@QAEKXZ	; DXUTState::GetWindowedStyleAtModeChange
PUBLIC	?SetMinimized@DXUTState@@QAEX_N@Z		; DXUTState::SetMinimized
PUBLIC	?GetMinimized@DXUTState@@QAE_NXZ		; DXUTState::GetMinimized
PUBLIC	?SetMaximized@DXUTState@@QAEX_N@Z		; DXUTState::SetMaximized
PUBLIC	?GetMaximized@DXUTState@@QAE_NXZ		; DXUTState::GetMaximized
PUBLIC	?SetMinimizedWhileFullscreen@DXUTState@@QAEX_N@Z ; DXUTState::SetMinimizedWhileFullscreen
PUBLIC	?GetMinimizedWhileFullscreen@DXUTState@@QAE_NXZ	; DXUTState::GetMinimizedWhileFullscreen
PUBLIC	?SetIgnoreSizeChange@DXUTState@@QAEX_N@Z	; DXUTState::SetIgnoreSizeChange
PUBLIC	?GetIgnoreSizeChange@DXUTState@@QAE_NXZ		; DXUTState::GetIgnoreSizeChange
PUBLIC	?SetTime@DXUTState@@QAEXN@Z			; DXUTState::SetTime
PUBLIC	?GetTime@DXUTState@@QAENXZ			; DXUTState::GetTime
PUBLIC	?SetElapsedTime@DXUTState@@QAEXM@Z		; DXUTState::SetElapsedTime
PUBLIC	?GetElapsedTime@DXUTState@@QAEMXZ		; DXUTState::GetElapsedTime
PUBLIC	?SetHInstance@DXUTState@@QAEXPAUHINSTANCE__@@@Z	; DXUTState::SetHInstance
PUBLIC	?GetHInstance@DXUTState@@QAEPAUHINSTANCE__@@XZ	; DXUTState::GetHInstance
PUBLIC	?SetLastStatsUpdateTime@DXUTState@@QAEXN@Z	; DXUTState::SetLastStatsUpdateTime
PUBLIC	?GetLastStatsUpdateTime@DXUTState@@QAENXZ	; DXUTState::GetLastStatsUpdateTime
PUBLIC	?SetLastStatsUpdateFrames@DXUTState@@QAEXK@Z	; DXUTState::SetLastStatsUpdateFrames
PUBLIC	?GetLastStatsUpdateFrames@DXUTState@@QAEKXZ	; DXUTState::GetLastStatsUpdateFrames
PUBLIC	?SetFPS@DXUTState@@QAEXM@Z			; DXUTState::SetFPS
PUBLIC	?GetFPS@DXUTState@@QAEMXZ			; DXUTState::GetFPS
PUBLIC	?SetCurrentFrameNumber@DXUTState@@QAEXH@Z	; DXUTState::SetCurrentFrameNumber
PUBLIC	?GetCurrentFrameNumber@DXUTState@@QAEHXZ	; DXUTState::GetCurrentFrameNumber
PUBLIC	?GetKeyboardHook@DXUTState@@QAEPAUHHOOK__@@XZ	; DXUTState::GetKeyboardHook
PUBLIC	?SetAllowShortcutKeysWhenFullscreen@DXUTState@@QAEX_N@Z ; DXUTState::SetAllowShortcutKeysWhenFullscreen
PUBLIC	?GetAllowShortcutKeysWhenFullscreen@DXUTState@@QAE_NXZ ; DXUTState::GetAllowShortcutKeysWhenFullscreen
PUBLIC	?SetAllowShortcutKeysWhenWindowed@DXUTState@@QAEX_N@Z ; DXUTState::SetAllowShortcutKeysWhenWindowed
PUBLIC	?GetAllowShortcutKeysWhenWindowed@DXUTState@@QAE_NXZ ; DXUTState::GetAllowShortcutKeysWhenWindowed
PUBLIC	?SetAllowShortcutKeys@DXUTState@@QAEX_N@Z	; DXUTState::SetAllowShortcutKeys
PUBLIC	?SetStartupStickyKeys@DXUTState@@QAEXUtagSTICKYKEYS@@@Z ; DXUTState::SetStartupStickyKeys
PUBLIC	?SetStartupToggleKeys@DXUTState@@QAEXUtagTOGGLEKEYS@@@Z ; DXUTState::SetStartupToggleKeys
PUBLIC	?SetStartupFilterKeys@DXUTState@@QAEXUtagFILTERKEYS@@@Z ; DXUTState::SetStartupFilterKeys
PUBLIC	?SetHandleDefaultHotkeys@DXUTState@@QAEX_N@Z	; DXUTState::SetHandleDefaultHotkeys
PUBLIC	?GetHandleDefaultHotkeys@DXUTState@@QAE_NXZ	; DXUTState::GetHandleDefaultHotkeys
PUBLIC	?SetShowMsgBoxOnError@DXUTState@@QAEX_N@Z	; DXUTState::SetShowMsgBoxOnError
PUBLIC	?GetShowMsgBoxOnError@DXUTState@@QAE_NXZ	; DXUTState::GetShowMsgBoxOnError
PUBLIC	?SetClipCursorWhenFullScreen@DXUTState@@QAEX_N@Z ; DXUTState::SetClipCursorWhenFullScreen
PUBLIC	?GetClipCursorWhenFullScreen@DXUTState@@QAE_NXZ	; DXUTState::GetClipCursorWhenFullScreen
PUBLIC	?SetShowCursorWhenFullScreen@DXUTState@@QAEX_N@Z ; DXUTState::SetShowCursorWhenFullScreen
PUBLIC	?GetShowCursorWhenFullScreen@DXUTState@@QAE_NXZ	; DXUTState::GetShowCursorWhenFullScreen
PUBLIC	?SetConstantFrameTime@DXUTState@@QAEX_N@Z	; DXUTState::SetConstantFrameTime
PUBLIC	?GetConstantFrameTime@DXUTState@@QAE_NXZ	; DXUTState::GetConstantFrameTime
PUBLIC	?SetTimePerFrame@DXUTState@@QAEXM@Z		; DXUTState::SetTimePerFrame
PUBLIC	?GetTimePerFrame@DXUTState@@QAEMXZ		; DXUTState::GetTimePerFrame
PUBLIC	?SetWireframeMode@DXUTState@@QAEX_N@Z		; DXUTState::SetWireframeMode
PUBLIC	?GetWireframeMode@DXUTState@@QAE_NXZ		; DXUTState::GetWireframeMode
PUBLIC	?SetAutoChangeAdapter@DXUTState@@QAEX_N@Z	; DXUTState::SetAutoChangeAdapter
PUBLIC	?GetAutoChangeAdapter@DXUTState@@QAE_NXZ	; DXUTState::GetAutoChangeAdapter
PUBLIC	?SetWindowCreatedWithDefaultPositions@DXUTState@@QAEX_N@Z ; DXUTState::SetWindowCreatedWithDefaultPositions
PUBLIC	?SetExitCode@DXUTState@@QAEXH@Z			; DXUTState::SetExitCode
PUBLIC	?GetExitCode@DXUTState@@QAEHXZ			; DXUTState::GetExitCode
PUBLIC	?SetDXUTInited@DXUTState@@QAEX_N@Z		; DXUTState::SetDXUTInited
PUBLIC	?GetDXUTInited@DXUTState@@QAE_NXZ		; DXUTState::GetDXUTInited
PUBLIC	?SetWindowCreated@DXUTState@@QAEX_N@Z		; DXUTState::SetWindowCreated
PUBLIC	?GetWindowCreated@DXUTState@@QAE_NXZ		; DXUTState::GetWindowCreated
PUBLIC	?SetDeviceCreated@DXUTState@@QAEX_N@Z		; DXUTState::SetDeviceCreated
PUBLIC	?GetDeviceCreated@DXUTState@@QAE_NXZ		; DXUTState::GetDeviceCreated
PUBLIC	?SetDXUTInitCalled@DXUTState@@QAEX_N@Z		; DXUTState::SetDXUTInitCalled
PUBLIC	?GetDXUTInitCalled@DXUTState@@QAE_NXZ		; DXUTState::GetDXUTInitCalled
PUBLIC	?SetWindowCreateCalled@DXUTState@@QAEX_N@Z	; DXUTState::SetWindowCreateCalled
PUBLIC	?GetWindowCreateCalled@DXUTState@@QAE_NXZ	; DXUTState::GetWindowCreateCalled
PUBLIC	?SetDeviceCreateCalled@DXUTState@@QAEX_N@Z	; DXUTState::SetDeviceCreateCalled
PUBLIC	?GetDeviceCreateCalled@DXUTState@@QAE_NXZ	; DXUTState::GetDeviceCreateCalled
PUBLIC	?SetInsideDeviceCallback@DXUTState@@QAEX_N@Z	; DXUTState::SetInsideDeviceCallback
PUBLIC	?GetInsideDeviceCallback@DXUTState@@QAE_NXZ	; DXUTState::GetInsideDeviceCallback
PUBLIC	?SetInsideMainloop@DXUTState@@QAEX_N@Z		; DXUTState::SetInsideMainloop
PUBLIC	?GetInsideMainloop@DXUTState@@QAE_NXZ		; DXUTState::GetInsideMainloop
PUBLIC	?SetDeviceObjectsCreated@DXUTState@@QAEX_N@Z	; DXUTState::SetDeviceObjectsCreated
PUBLIC	?GetDeviceObjectsCreated@DXUTState@@QAE_NXZ	; DXUTState::GetDeviceObjectsCreated
PUBLIC	?SetDeviceObjectsReset@DXUTState@@QAEX_N@Z	; DXUTState::SetDeviceObjectsReset
PUBLIC	?GetDeviceObjectsReset@DXUTState@@QAE_NXZ	; DXUTState::GetDeviceObjectsReset
PUBLIC	?SetActive@DXUTState@@QAEX_N@Z			; DXUTState::SetActive
PUBLIC	?GetActive@DXUTState@@QAE_NXZ			; DXUTState::GetActive
PUBLIC	?SetRenderingPaused@DXUTState@@QAEX_N@Z		; DXUTState::SetRenderingPaused
PUBLIC	?GetRenderingPaused@DXUTState@@QAE_NXZ		; DXUTState::GetRenderingPaused
PUBLIC	?SetTimePaused@DXUTState@@QAEX_N@Z		; DXUTState::SetTimePaused
PUBLIC	?SetPauseRenderingCount@DXUTState@@QAEXH@Z	; DXUTState::SetPauseRenderingCount
PUBLIC	?GetPauseRenderingCount@DXUTState@@QAEHXZ	; DXUTState::GetPauseRenderingCount
PUBLIC	?SetPauseTimeCount@DXUTState@@QAEXH@Z		; DXUTState::SetPauseTimeCount
PUBLIC	?GetPauseTimeCount@DXUTState@@QAEHXZ		; DXUTState::GetPauseTimeCount
PUBLIC	?SetDeviceLost@DXUTState@@QAEX_N@Z		; DXUTState::SetDeviceLost
PUBLIC	?GetDeviceLost@DXUTState@@QAE_NXZ		; DXUTState::GetDeviceLost
PUBLIC	?SetNotifyOnMouseMove@DXUTState@@QAEX_N@Z	; DXUTState::SetNotifyOnMouseMove
PUBLIC	?GetNotifyOnMouseMove@DXUTState@@QAE_NXZ	; DXUTState::GetNotifyOnMouseMove
PUBLIC	?SetAutomation@DXUTState@@QAEX_N@Z		; DXUTState::SetAutomation
PUBLIC	?GetAutomation@DXUTState@@QAE_NXZ		; DXUTState::GetAutomation
PUBLIC	?SetInSizeMove@DXUTState@@QAEX_N@Z		; DXUTState::SetInSizeMove
PUBLIC	?GetInSizeMove@DXUTState@@QAE_NXZ		; DXUTState::GetInSizeMove
PUBLIC	?SetOverrideAdapterOrdinal@DXUTState@@QAEXH@Z	; DXUTState::SetOverrideAdapterOrdinal
PUBLIC	?GetOverrideAdapterOrdinal@DXUTState@@QAEHXZ	; DXUTState::GetOverrideAdapterOrdinal
PUBLIC	?SetOverrideWindowed@DXUTState@@QAEX_N@Z	; DXUTState::SetOverrideWindowed
PUBLIC	?GetOverrideWindowed@DXUTState@@QAE_NXZ		; DXUTState::GetOverrideWindowed
PUBLIC	?SetOverrideFullScreen@DXUTState@@QAEX_N@Z	; DXUTState::SetOverrideFullScreen
PUBLIC	?GetOverrideFullScreen@DXUTState@@QAE_NXZ	; DXUTState::GetOverrideFullScreen
PUBLIC	?SetOverrideStartX@DXUTState@@QAEXH@Z		; DXUTState::SetOverrideStartX
PUBLIC	?GetOverrideStartX@DXUTState@@QAEHXZ		; DXUTState::GetOverrideStartX
PUBLIC	?SetOverrideStartY@DXUTState@@QAEXH@Z		; DXUTState::SetOverrideStartY
PUBLIC	?GetOverrideStartY@DXUTState@@QAEHXZ		; DXUTState::GetOverrideStartY
PUBLIC	?SetOverrideWidth@DXUTState@@QAEXH@Z		; DXUTState::SetOverrideWidth
PUBLIC	?GetOverrideWidth@DXUTState@@QAEHXZ		; DXUTState::GetOverrideWidth
PUBLIC	?SetOverrideHeight@DXUTState@@QAEXH@Z		; DXUTState::SetOverrideHeight
PUBLIC	?GetOverrideHeight@DXUTState@@QAEHXZ		; DXUTState::GetOverrideHeight
PUBLIC	?SetOverrideForceHAL@DXUTState@@QAEX_N@Z	; DXUTState::SetOverrideForceHAL
PUBLIC	?GetOverrideForceHAL@DXUTState@@QAE_NXZ		; DXUTState::GetOverrideForceHAL
PUBLIC	?SetOverrideForceREF@DXUTState@@QAEX_N@Z	; DXUTState::SetOverrideForceREF
PUBLIC	?GetOverrideForceREF@DXUTState@@QAE_NXZ		; DXUTState::GetOverrideForceREF
PUBLIC	?SetOverrideForcePureHWVP@DXUTState@@QAEX_N@Z	; DXUTState::SetOverrideForcePureHWVP
PUBLIC	?GetOverrideForcePureHWVP@DXUTState@@QAE_NXZ	; DXUTState::GetOverrideForcePureHWVP
PUBLIC	?SetOverrideForceHWVP@DXUTState@@QAEX_N@Z	; DXUTState::SetOverrideForceHWVP
PUBLIC	?GetOverrideForceHWVP@DXUTState@@QAE_NXZ	; DXUTState::GetOverrideForceHWVP
PUBLIC	?SetOverrideForceSWVP@DXUTState@@QAEX_N@Z	; DXUTState::SetOverrideForceSWVP
PUBLIC	?GetOverrideForceSWVP@DXUTState@@QAE_NXZ	; DXUTState::GetOverrideForceSWVP
PUBLIC	?SetOverrideConstantFrameTime@DXUTState@@QAEX_N@Z ; DXUTState::SetOverrideConstantFrameTime
PUBLIC	?GetOverrideConstantFrameTime@DXUTState@@QAE_NXZ ; DXUTState::GetOverrideConstantFrameTime
PUBLIC	?SetOverrideConstantTimePerFrame@DXUTState@@QAEXM@Z ; DXUTState::SetOverrideConstantTimePerFrame
PUBLIC	?GetOverrideConstantTimePerFrame@DXUTState@@QAEMXZ ; DXUTState::GetOverrideConstantTimePerFrame
PUBLIC	?SetOverrideQuitAfterFrame@DXUTState@@QAEXH@Z	; DXUTState::SetOverrideQuitAfterFrame
PUBLIC	?GetOverrideQuitAfterFrame@DXUTState@@QAEHXZ	; DXUTState::GetOverrideQuitAfterFrame
PUBLIC	?SetIsDeviceAcceptableFunc@DXUTState@@QAEXP6G_NPAU_D3DCAPS9@@W4_D3DFORMAT@@1_NPAX@Z@Z ; DXUTState::SetIsDeviceAcceptableFunc
PUBLIC	?GetIsDeviceAcceptableFunc@DXUTState@@QAEP6G_NPAU_D3DCAPS9@@W4_D3DFORMAT@@1_NPAX@ZXZ ; DXUTState::GetIsDeviceAcceptableFunc
PUBLIC	?SetModifyDeviceSettingsFunc@DXUTState@@QAEXP6G_NPAUDXUTDeviceSettings@@PBU_D3DCAPS9@@PAX@Z@Z ; DXUTState::SetModifyDeviceSettingsFunc
PUBLIC	?GetModifyDeviceSettingsFunc@DXUTState@@QAEP6G_NPAUDXUTDeviceSettings@@PBU_D3DCAPS9@@PAX@ZXZ ; DXUTState::GetModifyDeviceSettingsFunc
PUBLIC	?SetDeviceCreatedFunc@DXUTState@@QAEXP6GJPAUIDirect3DDevice9@@PBU_D3DSURFACE_DESC@@PAX@Z@Z ; DXUTState::SetDeviceCreatedFunc
PUBLIC	?GetDeviceCreatedFunc@DXUTState@@QAEP6GJPAUIDirect3DDevice9@@PBU_D3DSURFACE_DESC@@PAX@ZXZ ; DXUTState::GetDeviceCreatedFunc
PUBLIC	?SetDeviceResetFunc@DXUTState@@QAEXP6GJPAUIDirect3DDevice9@@PBU_D3DSURFACE_DESC@@PAX@Z@Z ; DXUTState::SetDeviceResetFunc
PUBLIC	?GetDeviceResetFunc@DXUTState@@QAEP6GJPAUIDirect3DDevice9@@PBU_D3DSURFACE_DESC@@PAX@ZXZ ; DXUTState::GetDeviceResetFunc
PUBLIC	?SetDeviceLostFunc@DXUTState@@QAEXP6GXPAX@Z@Z	; DXUTState::SetDeviceLostFunc
PUBLIC	?GetDeviceLostFunc@DXUTState@@QAEP6GXPAX@ZXZ	; DXUTState::GetDeviceLostFunc
PUBLIC	?SetDeviceDestroyedFunc@DXUTState@@QAEXP6GXPAX@Z@Z ; DXUTState::SetDeviceDestroyedFunc
PUBLIC	?GetDeviceDestroyedFunc@DXUTState@@QAEP6GXPAX@ZXZ ; DXUTState::GetDeviceDestroyedFunc
PUBLIC	?SetFrameMoveFunc@DXUTState@@QAEXP6GXPAUIDirect3DDevice9@@NMPAX@Z@Z ; DXUTState::SetFrameMoveFunc
PUBLIC	?GetFrameMoveFunc@DXUTState@@QAEP6GXPAUIDirect3DDevice9@@NMPAX@ZXZ ; DXUTState::GetFrameMoveFunc
PUBLIC	?SetFrameRenderFunc@DXUTState@@QAEXP6GXPAUIDirect3DDevice9@@NMPAX@Z@Z ; DXUTState::SetFrameRenderFunc
PUBLIC	?GetFrameRenderFunc@DXUTState@@QAEP6GXPAUIDirect3DDevice9@@NMPAX@ZXZ ; DXUTState::GetFrameRenderFunc
PUBLIC	?SetKeyboardFunc@DXUTState@@QAEXP6GXI_N0PAX@Z@Z	; DXUTState::SetKeyboardFunc
PUBLIC	?GetKeyboardFunc@DXUTState@@QAEP6GXI_N0PAX@ZXZ	; DXUTState::GetKeyboardFunc
PUBLIC	?SetMouseFunc@DXUTState@@QAEXP6GX_N0000HHHPAX@Z@Z ; DXUTState::SetMouseFunc
PUBLIC	?GetMouseFunc@DXUTState@@QAEP6GX_N0000HHHPAX@ZXZ ; DXUTState::GetMouseFunc
PUBLIC	?SetWindowMsgFunc@DXUTState@@QAEXP6GJPAUHWND__@@IIJPA_NPAX@Z@Z ; DXUTState::SetWindowMsgFunc
PUBLIC	?SetIsDeviceAcceptableFuncUserContext@DXUTState@@QAEXPAX@Z ; DXUTState::SetIsDeviceAcceptableFuncUserContext
PUBLIC	?GetIsDeviceAcceptableFuncUserContext@DXUTState@@QAEPAXXZ ; DXUTState::GetIsDeviceAcceptableFuncUserContext
PUBLIC	?SetModifyDeviceSettingsFuncUserContext@DXUTState@@QAEXPAX@Z ; DXUTState::SetModifyDeviceSettingsFuncUserContext
PUBLIC	?GetModifyDeviceSettingsFuncUserContext@DXUTState@@QAEPAXXZ ; DXUTState::GetModifyDeviceSettingsFuncUserContext
PUBLIC	?SetDeviceCreatedFuncUserContext@DXUTState@@QAEXPAX@Z ; DXUTState::SetDeviceCreatedFuncUserContext
PUBLIC	?GetDeviceCreatedFuncUserContext@DXUTState@@QAEPAXXZ ; DXUTState::GetDeviceCreatedFuncUserContext
PUBLIC	?SetDeviceResetFuncUserContext@DXUTState@@QAEXPAX@Z ; DXUTState::SetDeviceResetFuncUserContext
PUBLIC	?GetDeviceResetFuncUserContext@DXUTState@@QAEPAXXZ ; DXUTState::GetDeviceResetFuncUserContext
PUBLIC	?SetDeviceLostFuncUserContext@DXUTState@@QAEXPAX@Z ; DXUTState::SetDeviceLostFuncUserContext
PUBLIC	?GetDeviceLostFuncUserContext@DXUTState@@QAEPAXXZ ; DXUTState::GetDeviceLostFuncUserContext
PUBLIC	?SetDeviceDestroyedFuncUserContext@DXUTState@@QAEXPAX@Z ; DXUTState::SetDeviceDestroyedFuncUserContext
PUBLIC	?GetDeviceDestroyedFuncUserContext@DXUTState@@QAEPAXXZ ; DXUTState::GetDeviceDestroyedFuncUserContext
PUBLIC	?SetFrameMoveFuncUserContext@DXUTState@@QAEXPAX@Z ; DXUTState::SetFrameMoveFuncUserContext
PUBLIC	?GetFrameMoveFuncUserContext@DXUTState@@QAEPAXXZ ; DXUTState::GetFrameMoveFuncUserContext
PUBLIC	?SetFrameRenderFuncUserContext@DXUTState@@QAEXPAX@Z ; DXUTState::SetFrameRenderFuncUserContext
PUBLIC	?GetFrameRenderFuncUserContext@DXUTState@@QAEPAXXZ ; DXUTState::GetFrameRenderFuncUserContext
PUBLIC	?SetKeyboardFuncUserContext@DXUTState@@QAEXPAX@Z ; DXUTState::SetKeyboardFuncUserContext
PUBLIC	?GetKeyboardFuncUserContext@DXUTState@@QAEPAXXZ	; DXUTState::GetKeyboardFuncUserContext
PUBLIC	?SetMouseFuncUserContext@DXUTState@@QAEXPAX@Z	; DXUTState::SetMouseFuncUserContext
PUBLIC	?GetMouseFuncUserContext@DXUTState@@QAEPAXXZ	; DXUTState::GetMouseFuncUserContext
PUBLIC	?SetWindowMsgFuncUserContext@DXUTState@@QAEXPAX@Z ; DXUTState::SetWindowMsgFuncUserContext
PUBLIC	?SetTimerList@DXUTState@@QAEXPAV?$CGrowableArray@UDXUT_TIMER@@@@@Z ; DXUTState::SetTimerList
PUBLIC	?GetTimerList@DXUTState@@QAEPAV?$CGrowableArray@UDXUT_TIMER@@@@XZ ; DXUTState::GetTimerList
PUBLIC	?GetKeys@DXUTState@@QAEPA_NXZ			; DXUTState::GetKeys
PUBLIC	?GetMouseButtons@DXUTState@@QAEPA_NXZ		; DXUTState::GetMouseButtons
PUBLIC	?GetStaticFrameStats@DXUTState@@QAEPADXZ	; DXUTState::GetStaticFrameStats
PUBLIC	?GetFrameStats@DXUTState@@QAEPADXZ		; DXUTState::GetFrameStats
PUBLIC	?GetDeviceStats@DXUTState@@QAEPADXZ		; DXUTState::GetDeviceStats
PUBLIC	?GetWindowTitle@DXUTState@@QAEPADXZ		; DXUTState::GetWindowTitle
PUBLIC	?GetDXUTState@@YAAAVDXUTState@@XZ		; GetDXUTState
PUBLIC	?DXUTMapButtonToArrayIndex@@YAHE@Z		; DXUTMapButtonToArrayIndex
PUBLIC	?DXUTParseCommandLine@@YAXXZ			; DXUTParseCommandLine
PUBLIC	?DXUTPrepareEnumerationObject@@YAPAVCD3DEnumeration@@_N@Z ; DXUTPrepareEnumerationObject
PUBLIC	?DXUTBuildOptimalDeviceSettings@@YAXPAUDXUTDeviceSettings@@0PAUDXUTMatchOptions@@@Z ; DXUTBuildOptimalDeviceSettings
PUBLIC	?DXUTDoesDeviceComboMatchPreserveOptions@@YA_NPAUCD3DEnumDeviceSettingsCombo@@PAUDXUTDeviceSettings@@PAUDXUTMatchOptions@@@Z ; DXUTDoesDeviceComboMatchPreserveOptions
PUBLIC	?DXUTRankDeviceCombo@@YAMPAUCD3DEnumDeviceSettingsCombo@@PAUDXUTDeviceSettings@@PAU_D3DDISPLAYMODE@@@Z ; DXUTRankDeviceCombo
PUBLIC	?DXUTBuildValidDeviceSettings@@YAXPAUDXUTDeviceSettings@@PAUCD3DEnumDeviceSettingsCombo@@0PAUDXUTMatchOptions@@@Z ; DXUTBuildValidDeviceSettings
PUBLIC	?DXUTFindValidResolution@@YAJPAUCD3DEnumDeviceSettingsCombo@@U_D3DDISPLAYMODE@@PAU2@@Z ; DXUTFindValidResolution
PUBLIC	?DXUTFindAdapterFormat@@YAJIW4_D3DDEVTYPE@@W4_D3DFORMAT@@HPAW42@@Z ; DXUTFindAdapterFormat
PUBLIC	?DXUTChangeDevice@@YAJPAUDXUTDeviceSettings@@PAUIDirect3DDevice9@@_N2@Z ; DXUTChangeDevice
PUBLIC	?DXUTUpdateDeviceSettingsWithOverrides@@YAXPAUDXUTDeviceSettings@@@Z ; DXUTUpdateDeviceSettingsWithOverrides
PUBLIC	?DXUTCreate3DEnvironment@@YAJPAUIDirect3DDevice9@@@Z ; DXUTCreate3DEnvironment
PUBLIC	?DXUTUpdateFrameStats@@YAXXZ			; DXUTUpdateFrameStats
PUBLIC	?DXUTUpdateDeviceStats@@YAXW4_D3DDEVTYPE@@KPAU_D3DADAPTER_IDENTIFIER9@@@Z ; DXUTUpdateDeviceStats
PUBLIC	?DXUTUpdateStaticFrameStats@@YAXXZ		; DXUTUpdateStaticFrameStats
PUBLIC	?DXUTHandleTimers@@YAXXZ			; DXUTHandleTimers
PUBLIC	?DXUTGetCmdParam@@YA_NAAPADPADH@Z		; DXUTGetCmdParam
PUBLIC	?DXUTDisplayErrorMessage@@YAXJ@Z		; DXUTDisplayErrorMessage
PUBLIC	?DXUTCheckForWindowSizeChange@@YAXXZ		; DXUTCheckForWindowSizeChange
PUBLIC	?DXUTCheckForWindowChangingMonitors@@YAXXZ	; DXUTCheckForWindowChangingMonitors
PUBLIC	?DXUTGetAdapterOrdinalFromMonitor@@YAJPAUHMONITOR__@@PAI@Z ; DXUTGetAdapterOrdinalFromMonitor
PUBLIC	?DXUTAllowShortcutKeys@@YAX_N@Z			; DXUTAllowShortcutKeys
PUBLIC	?DXUTUpdateBackBufferDesc@@YAXXZ		; DXUTUpdateBackBufferDesc
PUBLIC	?DXUTInitHWCursor@@YAXXZ			; DXUTInitHWCursor
PUBLIC	?DXUTSetDeviceCursor@@YAJPAUIDirect3DDevice9@@PAUHICON__@@_N@Z ; DXUTSetDeviceCursor
PUBLIC	?DXUTGetDesktopResolution@@YAXIPAK0@Z		; DXUTGetDesktopResolution
PUBLIC	?LowLevelKeyboardProc@@YGJHIJ@Z			; LowLevelKeyboardProc
PUBLIC	??0?$CGrowableArray@UDXUT_TIMER@@@@QAE@XZ	; CGrowableArray<DXUT_TIMER>::CGrowableArray<DXUT_TIMER>
PUBLIC	?Add@?$CGrowableArray@UDXUT_TIMER@@@@QAEJABUDXUT_TIMER@@@Z ; CGrowableArray<DXUT_TIMER>::Add
PUBLIC	?SetAt@?$CGrowableArray@UDXUT_TIMER@@@@QAEJHABUDXUT_TIMER@@@Z ; CGrowableArray<DXUT_TIMER>::SetAt
PUBLIC	?GetAt@?$CGrowableArray@UDXUT_TIMER@@@@QAEAAUDXUT_TIMER@@H@Z ; CGrowableArray<DXUT_TIMER>::GetAt
PUBLIC	?GetSize@?$CGrowableArray@UDXUT_TIMER@@@@QBEHXZ	; CGrowableArray<DXUT_TIMER>::GetSize
PUBLIC	?SetSizeInternal@?$CGrowableArray@UDXUT_TIMER@@@@IAEJH@Z ; CGrowableArray<DXUT_TIMER>::SetSizeInternal
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_06KDCOIDGA@USER32?$AA@			; `string'
PUBLIC	??_C@_0BB@BFCABEPI@GetSystemMetrics?$AA@	; `string'
PUBLIC	??_C@_0BC@CHFENAPF@MonitorFromWindow?$AA@	; `string'
PUBLIC	??_C@_0BA@DPLKJPEB@MonitorFromRect?$AA@		; `string'
PUBLIC	??_C@_0BB@DDMDAIAD@MonitorFromPoint?$AA@	; `string'
PUBLIC	??_C@_0BE@OHNDFFJG@EnumDisplayMonitors?$AA@	; `string'
PUBLIC	??_C@_0BA@KIAMMEPJ@GetMonitorInfoA?$AA@		; `string'
PUBLIC	??_C@_0BE@NPEOLIBM@EnumDisplayDevicesA?$AA@	; `string'
PUBLIC	??_C@_07JPHDIPNG@DISPLAY?$AA@			; `string'
PUBLIC	??_C@_0L@NLNDMMBI@?2winmm?4dll?$AA@		; `string'
PUBLIC	??_C@_0BA@DCPFICL@timeBeginPeriod?$AA@		; `string'
PUBLIC	?__LINE__Var@?1??DXUTInit@@YAJ_N00@Z@4JA	; `DXUTInit'::`2'::__LINE__Var
PUBLIC	??_C@_0BB@DDKDNGFF@D3DXCheckVersion?$AA@	; `string'
PUBLIC	??_C@_0CL@KBAHBIDF@z?3?2sampsrc?202xu1?2saco?2d3d9?2commo@ ; `string'
PUBLIC	??_C@_0BA@FAFMMBOF@Direct3DCreate9?$AA@		; `string'
PUBLIC	??_C@_07HEFHPBAB@adapter?$AA@			; `string'
PUBLIC	??_C@_08KIHLFLPI@windowed?$AA@			; `string'
PUBLIC	??_C@_0L@GIACNHMO@fullscreen?$AA@		; `string'
PUBLIC	??_C@_08OFMOLPPD@forcehal?$AA@			; `string'
PUBLIC	??_C@_08CHIMEIFO@forceref?$AA@			; `string'
PUBLIC	??_C@_0O@FCGFKHNN@forcepurehwvp?$AA@		; `string'
PUBLIC	??_C@_09GPKNDKAK@forcehwvp?$AA@			; `string'
PUBLIC	??_C@_09HIJNJMJJ@forceswvp?$AA@			; `string'
PUBLIC	??_C@_05IGKADHGO@width?$AA@			; `string'
PUBLIC	??_C@_06LNLHEAAG@height?$AA@			; `string'
PUBLIC	??_C@_06PONKKAHI@startx?$AA@			; `string'
PUBLIC	??_C@_06OHMBJBDJ@starty?$AA@			; `string'
PUBLIC	??_C@_0BC@DPFOJONK@constantframetime?$AA@	; `string'
PUBLIC	??_C@_0P@NCNNICJN@quitafterframe?$AA@		; `string'
PUBLIC	??_C@_0BA@EMDPCOOI@noerrormsgboxes?$AA@		; `string'
PUBLIC	??_C@_0L@GKIGKMJB@automation?$AA@		; `string'
PUBLIC	??_C@_0BG@BAGONEII@Unrecognized?5flag?3?5?$CFs?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??DXUTCreateWindow@@YAJPBDPAUHINSTANCE__@@PAUHICON__@@PAUHMENU__@@HH@Z@4JA ; `DXUTCreateWindow'::`2'::__LINE__Var
PUBLIC	??_C@_0BB@LKEDMNKO@DXUTCreateWindow?$AA@	; `string'
PUBLIC	??_C@_0BE@MKMDFNEO@Direct3DWindowClass?$AA@	; `string'
PUBLIC	??_C@_0O@NLFCIADE@RegisterClass?$AA@		; `string'
PUBLIC	??_C@_0N@GKGFHBLO@CreateWindow?$AA@		; `string'
PUBLIC	?__LINE__Var@?1??DXUTSetWindow@@YAJPAUHWND__@@00_N@Z@4JA ; `DXUTSetWindow'::`2'::__LINE__Var
PUBLIC	??_C@_0O@FNJALMEB@DXUTSetWindow?$AA@		; `string'
PUBLIC	??_C@_0BB@CBJJKGDE@SetWindowLongPtr?$AA@	; `string'
PUBLIC	?__LINE__Var@?1??DXUTCreateDevice@@YAJI_NHHP6G_NPAU_D3DCAPS9@@W4_D3DFORMAT@@20PAX@ZP6G_NPAUDXUTDeviceSettings@@PBU2@3@Z3@Z@4JA ; `DXUTCreateDevice'::`2'::__LINE__Var
PUBLIC	??_C@_0BA@FFFLJHOO@Direct3D?5Window?$AA@	; `string'
PUBLIC	??_C@_0BM@MONLLCLM@DXUTFindValidDeviceSettings?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??DXUTSetDevice@@YAJPAUIDirect3DDevice9@@@Z@4JA ; `DXUTSetDevice'::`2'::__LINE__Var
PUBLIC	??_C@_0O@KPHAHHEA@DXUTSetDevice?$AA@		; `string'
PUBLIC	?__LINE__Var@?1??DXUTCreateDeviceFromSettings@@YAJPAUDXUTDeviceSettings@@_N1@Z@4JA ; `DXUTCreateDeviceFromSettings'::`2'::__LINE__Var
PUBLIC	?__LINE__Var@?1??DXUTFindValidDeviceSettings@@YAJPAUDXUTDeviceSettings@@0PAUDXUTMatchOptions@@@Z@4JA ; `DXUTFindValidDeviceSettings'::`2'::__LINE__Var
PUBLIC	?__LINE__Var@?1??DXUTCreate3DEnvironment@@YAJPAUIDirect3DDevice9@@@Z@4JA ; `DXUTCreate3DEnvironment'::`2'::__LINE__Var
PUBLIC	??_C@_0N@JIIFLKLP@CreateDevice?$AA@		; `string'
PUBLIC	??_C@_0P@JJBHJNJD@OnCreateDevice?$AA@		; `string'
PUBLIC	??_C@_0BH@PGNAKDOD@DeviceCreated?5callback?$AA@	; `string'
PUBLIC	??_C@_0O@JFPFAANM@OnResetDevice?$AA@		; `string'
PUBLIC	??_C@_0BF@LLKHGPAB@DeviceReset?5callback?$AA@	; `string'
PUBLIC	?__LINE__Var@?1??DXUTReset3DEnvironment@@YAJXZ@4JA ; `DXUTReset3DEnvironment'::`2'::__LINE__Var
PUBLIC	??_C@_1FG@OJNOEDOF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@ ; `string'
PUBLIC	??_C@_1CG@LNDKPHPB@?$AAp?$AAd?$AA3?$AAd?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_05CCGMLFNG@Reset?$AA@			; `string'
PUBLIC	??_C@_0BE@FGIMCOFA@DeviceResetCallback?$AA@	; `string'
PUBLIC	?__LINE__Var@?1??DXUTMainLoop@@YAJPAUHACCEL__@@@Z@4JA ; `DXUTMainLoop'::`2'::__LINE__Var
PUBLIC	??_C@_0N@IDGALNHJ@DXUTMainLoop?$AA@		; `string'
PUBLIC	?__LINE__Var@?1??DXUTRender3DEnvironment@@YAXXZ@4JA ; `DXUTRender3DEnvironment'::`2'::__LINE__Var
PUBLIC	??_C@_1HM@DAKFLFBC@?$AAD?$AAX?$AAU?$AAT?$AAG?$AAe?$AAt?$AAB?$AAa?$AAc?$AAk?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAS?$AAu?$AAr?$AAf?$AAa?$AAc?$AAe?$AAD?$AAe?$AAs?$AAc?$AA?$CI?$AA?$CJ?$AA?9?$AA?$DO@ ; `string'
PUBLIC	??_C@_1IA@LBHFHEOB@?$AAD?$AAX?$AAU?$AAT?$AAG?$AAe?$AAt?$AAB?$AAa?$AAc?$AAk?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAS?$AAu?$AAr?$AAf?$AAa?$AAc?$AAe?$AAD?$AAe?$AAs?$AAc?$AA?$CI?$AA?$CJ?$AA?9?$AA?$DO@ ; `string'
PUBLIC	??_C@_03GPMNEAGC@REF?$AA@			; `string'
PUBLIC	??_C@_02JHFFIENB@HA?$AA@			; `string'
PUBLIC	??_C@_02JLLOHNJH@SW?$AA@			; `string'
PUBLIC	??_C@_0O@INAAPCCB@?5?$CIpure?5hw?5vp?$CJ?$AA@	; `string'
PUBLIC	??_C@_0BI@KADHBMJM@?5?$CIsimulated?5pure?5hw?5vp?$CJ?$AA@ ; `string'
PUBLIC	??_C@_08IAMIAIBF@?5?$CIhw?5vp?$CJ?$AA@		; `string'
PUBLIC	??_C@_0BD@NNKCKNKM@?5?$CIsimulated?5hw?5vp?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0M@NOOBLHBB@?5?$CImixed?5vp?$CJ?$AA@	; `string'
PUBLIC	??_C@_0BG@GKHJLCDJ@?5?$CIsimulated?5mixed?5vp?$CJ?$AA@ ; `string'
PUBLIC	??_C@_08OFBBMACB@?5?$CIsw?5vp?$CJ?$AA@		; `string'
PUBLIC	??_C@_02LMMGGCAJ@?3?5?$AA@			; `string'
PUBLIC	??_C@_0BH@CNBHLFAO@backbuf?5?$CFs?0?5adapter?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_05DNDNCJEB@?5?$CI?$CFs?$CJ?$AA@		; `string'
PUBLIC	??_C@_0BL@OEMADDMG@?5?$CINonmaskable?5Multisample?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BD@FAEAMFBM@?5?$CI?$CFdx?5Multisample?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BL@ELHDMKOG@?$CF?$CF?402f?5fps?5?$CI?$CFdx?$CFd?$CJ?0?5?$CFs?$CFs?$CFs?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??DXUTCleanup3DEnvironment@@YAX_N@Z@4JA ; `DXUTCleanup3DEnvironment'::`2'::__LINE__Var
PUBLIC	??_C@_0BJ@MCGMIGD@DXUTCleanup3DEnvironment?$AA@	; `string'
PUBLIC	?__LINE__Var@?1??DXUTSetTimer@@YAJP6GXIPAX@ZMPAI0@Z@4JA ; `DXUTSetTimer'::`2'::__LINE__Var
PUBLIC	??_C@_0N@FMEJHMAO@DXUTSetTimer?$AA@		; `string'
PUBLIC	?__LINE__Var@?1??DXUTKillTimer@@YAJI@Z@4JA	; `DXUTKillTimer'::`2'::__LINE__Var
PUBLIC	??_C@_0O@INMLKDAF@DXUTKillTimer?$AA@		; `string'
PUBLIC	??_C@_0OH@FLJPMJOG@Could?5not?5initialize?5Direct3D?4?5Y@ ; `string'
PUBLIC	??_C@_0CL@IGPDECHP@Incorrect?5version?5of?5Direct3D?5an@ ; `string'
PUBLIC	??_C@_0FD@EJIIMMAA@Could?5not?5find?5required?5media?4?5E@ ; `string'
PUBLIC	??_C@_0FH@GHOOFLN@The?5D3D?5device?5has?5a?5non?9zero?5re@ ; `string'
PUBLIC	??_C@_0CF@CPEKMMJN@Failed?5creating?5the?5Direct3D?5dev@ ; `string'
PUBLIC	??_C@_0CG@NKKNAJJN@Failed?5resetting?5the?5Direct3D?5de@ ; `string'
PUBLIC	??_C@_0CJ@NGDMEEIH@Failed?5creating?5Direct3D?5device?5@ ; `string'
PUBLIC	??_C@_0CK@JNLAHDJE@Failed?5resetting?5Direct3D?5device@ ; `string'
PUBLIC	??_C@_0CO@JDBEDMFP@Direct3D?5does?5not?5work?5over?5a?5re@ ; `string'
PUBLIC	??_C@_0DA@IAMFMDGP@Could?5not?5find?5any?5compatible?5Di@ ; `string'
PUBLIC	??_C@_0BE@BDKDCPJA@DirectX?5Application?$AA@	; `string'
PUBLIC	??_C@_1FK@FIMIDMPE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@ ; `string'
PUBLIC	??_C@_1EA@JHMKKLFC@?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAm?$AA_?$AAn?$AAS?$AAi?$AAz?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@HLGKFCJM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3d086595
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3f666666
PUBLIC	__real@3f800000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@41200000
PUBLIC	__real@42c80000
PUBLIC	__real@447a0000
PUBLIC	__real@bf800000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	__strnicmp:PROC
EXTRN	__imp__GetCommandLineA@0:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__InitializeCriticalSection@4:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__DeleteCriticalSection@4:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__GetSystemDirectoryA@8:PROC
EXTRN	__imp__GetVersionExA@4:PROC
EXTRN	__imp__FreeLibrary@4:PROC
EXTRN	__imp__GetModuleFileNameA@12:PROC
EXTRN	__imp__GetModuleHandleA@4:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__lstrcpyA@8:PROC
EXTRN	__imp__LoadLibraryA@4:PROC
EXTRN	__imp__CreateCompatibleDC@4:PROC
EXTRN	__imp__DeleteDC@4:PROC
EXTRN	__imp__DeleteObject@4:PROC
EXTRN	__imp__GetClipBox@8:PROC
EXTRN	__imp__GetDIBits@28:PROC
EXTRN	__imp__GetStockObject@4:PROC
EXTRN	__imp__SelectObject@8:PROC
EXTRN	__imp__GetObjectA@12:PROC
EXTRN	__imp__GetDCOrgEx@8:PROC
EXTRN	__imp__TranslateMessage@4:PROC
EXTRN	__imp__DispatchMessageA@4:PROC
EXTRN	__imp__PeekMessageA@20:PROC
EXTRN	__imp__SendMessageA@16:PROC
EXTRN	__imp__DefWindowProcA@16:PROC
EXTRN	__imp__PostQuitMessage@4:PROC
EXTRN	__imp__RegisterClassA@4:PROC
EXTRN	__imp__UnregisterClassA@8:PROC
EXTRN	__imp__CreateWindowExA@48:PROC
EXTRN	__imp__DestroyWindow@4:PROC
EXTRN	__imp__ShowWindow@8:PROC
EXTRN	__imp__SetWindowPos@28:PROC
EXTRN	__imp__GetWindowPlacement@8:PROC
EXTRN	__imp__SetWindowPlacement@8:PROC
EXTRN	__imp__IsWindowVisible@4:PROC
EXTRN	__imp__IsIconic@4:PROC
EXTRN	__imp__IsZoomed@4:PROC
EXTRN	__imp__GetAsyncKeyState@4:PROC
EXTRN	__imp__DestroyAcceleratorTable@4:PROC
EXTRN	__imp__TranslateAcceleratorA@12:PROC
EXTRN	__imp__GetSystemMetrics@4:PROC
EXTRN	__imp__GetMenu@4:PROC
EXTRN	__imp__SetMenu@8:PROC
EXTRN	__imp__DestroyMenu@4:PROC
EXTRN	__imp__GetDC@4:PROC
EXTRN	__imp__ReleaseDC@8:PROC
EXTRN	__imp__GetWindowTextA@12:PROC
EXTRN	__imp__GetClientRect@8:PROC
EXTRN	__imp__GetWindowRect@8:PROC
EXTRN	__imp__AdjustWindowRect@12:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	__imp__GetCursorPos@4:PROC
EXTRN	__imp__ClipCursor@4:PROC
EXTRN	__imp__ScreenToClient@8:PROC
EXTRN	__imp__SetRect@20:PROC
EXTRN	__imp__IntersectRect@12:PROC
EXTRN	__imp__OffsetRect@12:PROC
EXTRN	__imp__GetWindowLongA@8:PROC
EXTRN	__imp__SetWindowLongA@12:PROC
EXTRN	__imp__GetClassLongA@8:PROC
EXTRN	__imp__CallNextHookEx@16:PROC
EXTRN	__imp__LoadCursorA@8:PROC
EXTRN	__imp__GetIconInfo@8:PROC
EXTRN	__imp__EnumDisplaySettingsA@12:PROC
EXTRN	__imp__SystemParametersInfoA@16:PROC
EXTRN	__imp__ExtractIconA@12:PROC
EXTRN	_abs:PROC
EXTRN	_labs:PROC
EXTRN	_atoi:PROC
EXTRN	_strtod:PROC
EXTRN	_free:PROC
EXTRN	_realloc:PROC
EXTRN	__wassert:PROC
EXTRN	__imp__InitCommonControls@0:PROC
EXTRN	__vsnprintf:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	_D3DXCheckVersion@8:PROC
EXTRN	?DXTraceWrapper@@YGJPBDKJ0H@Z:PROC		; DXTraceWrapper
EXTRN	?Reset@CDXUTTimer@@QAEXXZ:PROC			; CDXUTTimer::Reset
EXTRN	?Start@CDXUTTimer@@QAEXXZ:PROC			; CDXUTTimer::Start
EXTRN	?Stop@CDXUTTimer@@QAEXXZ:PROC			; CDXUTTimer::Stop
EXTRN	?GetAbsoluteTime@CDXUTTimer@@QAENXZ:PROC	; CDXUTTimer::GetAbsoluteTime
EXTRN	?GetTime@CDXUTTimer@@QAENXZ:PROC		; CDXUTTimer::GetTime
EXTRN	?GetElapsedTime@CDXUTTimer@@QAENXZ:PROC		; CDXUTTimer::GetElapsedTime
EXTRN	?DXUTGetGlobalTimer@@YAPAVCDXUTTimer@@XZ:PROC	; DXUTGetGlobalTimer
EXTRN	?OnCreateDevice@CDXUTResourceCache@@QAEJPAUIDirect3DDevice9@@@Z:PROC ; CDXUTResourceCache::OnCreateDevice
EXTRN	?OnResetDevice@CDXUTResourceCache@@QAEJPAUIDirect3DDevice9@@@Z:PROC ; CDXUTResourceCache::OnResetDevice
EXTRN	?OnLostDevice@CDXUTResourceCache@@QAEJXZ:PROC	; CDXUTResourceCache::OnLostDevice
EXTRN	?OnDestroyDevice@CDXUTResourceCache@@QAEJXZ:PROC ; CDXUTResourceCache::OnDestroyDevice
EXTRN	?DXUTGetGlobalResourceCache@@YAAAVCDXUTResourceCache@@XZ:PROC ; DXUTGetGlobalResourceCache
EXTRN	?DXUTD3DFormatToString@@YAPBDW4_D3DFORMAT@@_N@Z:PROC ; DXUTD3DFormatToString
EXTRN	?DXUTOutputDebugStringA@@YAXPBDZZ:PROC		; DXUTOutputDebugStringA
EXTRN	?DXUT_Dynamic_Direct3DCreate9@@YGPAUIDirect3D9@@I@Z:PROC ; DXUT_Dynamic_Direct3DCreate9
EXTRN	?Enumerate@CD3DEnumeration@@QAEJPAUIDirect3D9@@P6G_NPAU_D3DCAPS9@@W4_D3DFORMAT@@2_NPAX@Z4@Z:PROC ; CD3DEnumeration::Enumerate
EXTRN	?GetAdapterInfoList@CD3DEnumeration@@QAEPAV?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@XZ:PROC ; CD3DEnumeration::GetAdapterInfoList
EXTRN	?GetAdapterInfo@CD3DEnumeration@@QAEPAVCD3DEnumAdapterInfo@@I@Z:PROC ; CD3DEnumeration::GetAdapterInfo
EXTRN	?GetDeviceInfo@CD3DEnumeration@@QAEPAVCD3DEnumDeviceInfo@@IW4_D3DDEVTYPE@@@Z:PROC ; CD3DEnumeration::GetDeviceInfo
EXTRN	?GetDeviceSettingsCombo@CD3DEnumeration@@QAEPAUCD3DEnumDeviceSettingsCombo@@IW4_D3DDEVTYPE@@W4_D3DFORMAT@@1H@Z:PROC ; CD3DEnumeration::GetDeviceSettingsCombo
EXTRN	?DXUTGetEnumeration@@YAPAVCD3DEnumeration@@XZ:PROC ; DXUTGetEnumeration
EXTRN	?DXUTColorChannelBits@@YAIW4_D3DFORMAT@@@Z:PROC	; DXUTColorChannelBits
EXTRN	?DXUTStencilBits@@YAIW4_D3DFORMAT@@@Z:PROC	; DXUTStencilBits
EXTRN	?DXUTDepthBits@@YAIW4_D3DFORMAT@@@Z:PROC	; DXUTDepthBits
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memset:PROC
EXTRN	_IID_IDirect3DSwapChain9:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?state@?1??GetDXUTState@@YAAAVDXUTState@@XZ@4V2@A DB 07bdH DUP (?) ; `GetDXUTState'::`2'::state
	ALIGN	4

?$S1@?1??GetDXUTState@@YAAAVDXUTState@@XZ@4IA DD 01H DUP (?) ; `GetDXUTState'::`2'::$S1
_BSS	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f666666
CONST	SEGMENT
__real@3f666666 DD 03f666666r			; 0.9
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3d086595
CONST	SEGMENT
__real@3d086595 DD 03d086595r			; 0.0333
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_1M@HLGKFCJM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1M@HLGKFCJM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@ DB 'f', 00H, 'a', 00H
	DB	'l', 00H, 's', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@JHMKKLFC@?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAm?$AA_?$AAn?$AAS?$AAi?$AAz?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1EA@JHMKKLFC@?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAm?$AA_?$AAn?$AAS?$AAi?$AAz?$AAe?$AA?$AA@ DB 'n'
	DB	00H, 'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, ' ', 00H
	DB	'>', 00H, '=', 00H, ' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, 'n', 00H, 'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H
	DB	'x', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'm', 00H, '_', 00H, 'n'
	DB	00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FK@FIMIDMPE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
CONST	SEGMENT
??_C@_1FK@FIMIDMPE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@ DB 'z'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H
	DB	's', 00H, 'r', 00H, 'c', 00H, '\', 00H, '0', 00H, '2', 00H, 'x'
	DB	00H, 'u', 00H, '1', 00H, '\', 00H, 's', 00H, 'a', 00H, 'c', 00H
	DB	'o', 00H, '\', 00H, 'd', 00H, '3', 00H, 'd', 00H, '9', 00H, '\'
	DB	00H, 'c', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'o', 00H, 'n', 00H
	DB	'\', 00H, 'd', 00H, 'x', 00H, 'u', 00H, 't', 00H, 'm', 00H, 'i'
	DB	00H, 's', 00H, 'c', 00H, '.', 00H, 'h', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BDKDCPJA@DirectX?5Application?$AA@
CONST	SEGMENT
??_C@_0BE@BDKDCPJA@DirectX?5Application?$AA@ DB 'DirectX Application', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@IAMFMDGP@Could?5not?5find?5any?5compatible?5Di@
CONST	SEGMENT
??_C@_0DA@IAMFMDGP@Could?5not?5find?5any?5compatible?5Di@ DB 'Could not f'
	DB	'ind any compatible Direct3D devices.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@JDBEDMFP@Direct3D?5does?5not?5work?5over?5a?5re@
CONST	SEGMENT
??_C@_0CO@JDBEDMFP@Direct3D?5does?5not?5work?5over?5a?5re@ DB 'Direct3D d'
	DB	'oes not work over a remote session.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@JNLAHDJE@Failed?5resetting?5Direct3D?5device@
CONST	SEGMENT
??_C@_0CK@JNLAHDJE@Failed?5resetting?5Direct3D?5device@ DB 'Failed resett'
	DB	'ing Direct3D device objects.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@NGDMEEIH@Failed?5creating?5Direct3D?5device?5@
CONST	SEGMENT
??_C@_0CJ@NGDMEEIH@Failed?5creating?5Direct3D?5device?5@ DB 'Failed creat'
	DB	'ing Direct3D device objects.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@NKKNAJJN@Failed?5resetting?5the?5Direct3D?5de@
CONST	SEGMENT
??_C@_0CG@NKKNAJJN@Failed?5resetting?5the?5Direct3D?5de@ DB 'Failed reset'
	DB	'ting the Direct3D device.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@CPEKMMJN@Failed?5creating?5the?5Direct3D?5dev@
CONST	SEGMENT
??_C@_0CF@CPEKMMJN@Failed?5creating?5the?5Direct3D?5dev@ DB 'Failed creat'
	DB	'ing the Direct3D device.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FH@GHOOFLN@The?5D3D?5device?5has?5a?5non?9zero?5re@
CONST	SEGMENT
??_C@_0FH@GHOOFLN@The?5D3D?5device?5has?5a?5non?9zero?5re@ DB 'The D3D de'
	DB	'vice has a non-zero reference count, meaning some objects wer'
	DB	'e not released.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@EJIIMMAA@Could?5not?5find?5required?5media?4?5E@
CONST	SEGMENT
??_C@_0FD@EJIIMMAA@Could?5not?5find?5required?5media?4?5E@ DB 'Could not '
	DB	'find required media. Ensure that the DirectX SDK is correctly'
	DB	' installed.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@IGPDECHP@Incorrect?5version?5of?5Direct3D?5an@
CONST	SEGMENT
??_C@_0CL@IGPDECHP@Incorrect?5version?5of?5Direct3D?5an@ DB 'Incorrect ve'
	DB	'rsion of Direct3D and/or D3DX.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0OH@FLJPMJOG@Could?5not?5initialize?5Direct3D?4?5Y@
CONST	SEGMENT
??_C@_0OH@FLJPMJOG@Could?5not?5initialize?5Direct3D?4?5Y@ DB 'Could not i'
	DB	'nitialize Direct3D. You may want to check that the latest ver'
	DB	'sion of DirectX is correctly installed on your system.  Also '
	DB	'make sure that this program was compiled with header files th'
	DB	'at match the installed DirectX DLLs.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@INMLKDAF@DXUTKillTimer?$AA@
CONST	SEGMENT
??_C@_0O@INMLKDAF@DXUTKillTimer?$AA@ DB 'DXUTKillTimer', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??DXUTKillTimer@@YAJI@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??DXUTKillTimer@@YAJI@Z@4JA DD 01171H	; `DXUTKillTimer'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0N@FMEJHMAO@DXUTSetTimer?$AA@
CONST	SEGMENT
??_C@_0N@FMEJHMAO@DXUTSetTimer?$AA@ DB 'DXUTSetTimer', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??DXUTSetTimer@@YAJP6GXIPAX@ZMPAI0@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??DXUTSetTimer@@YAJP6GXIPAX@ZMPAI0@Z@4JA DD 0114eH ; `DXUTSetTimer'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BJ@MCGMIGD@DXUTCleanup3DEnvironment?$AA@
CONST	SEGMENT
??_C@_0BJ@MCGMIGD@DXUTCleanup3DEnvironment?$AA@ DB 'DXUTCleanup3DEnvironm'
	DB	'ent', 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??DXUTCleanup3DEnvironment@@YAX_N@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??DXUTCleanup3DEnvironment@@YAX_N@Z@4JA DD 010faH ; `DXUTCleanup3DEnvironment'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BL@ELHDMKOG@?$CF?$CF?402f?5fps?5?$CI?$CFdx?$CFd?$CJ?0?5?$CFs?$CFs?$CFs?$AA@
CONST	SEGMENT
??_C@_0BL@ELHDMKOG@?$CF?$CF?402f?5fps?5?$CI?$CFdx?$CFd?$CJ?0?5?$CFs?$CFs?$CFs?$AA@ DB '%'
	DB	'%.02f fps (%dx%d), %s%s%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FAEAMFBM@?5?$CI?$CFdx?5Multisample?$CJ?$AA@
CONST	SEGMENT
??_C@_0BD@FAEAMFBM@?5?$CI?$CFdx?5Multisample?$CJ?$AA@ DB ' (%dx Multisamp'
	DB	'le)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@OEMADDMG@?5?$CINonmaskable?5Multisample?$CJ?$AA@
CONST	SEGMENT
??_C@_0BL@OEMADDMG@?5?$CINonmaskable?5Multisample?$CJ?$AA@ DB ' (Nonmaska'
	DB	'ble Multisample)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05DNDNCJEB@?5?$CI?$CFs?$CJ?$AA@
CONST	SEGMENT
??_C@_05DNDNCJEB@?5?$CI?$CFs?$CJ?$AA@ DB ' (%s)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CNBHLFAO@backbuf?5?$CFs?0?5adapter?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BH@CNBHLFAO@backbuf?5?$CFs?0?5adapter?5?$CFs?$AA@ DB 'backbuf %s, '
	DB	'adapter %s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02LMMGGCAJ@?3?5?$AA@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5?$AA@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08OFBBMACB@?5?$CIsw?5vp?$CJ?$AA@
CONST	SEGMENT
??_C@_08OFBBMACB@?5?$CIsw?5vp?$CJ?$AA@ DB ' (sw vp)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GKHJLCDJ@?5?$CIsimulated?5mixed?5vp?$CJ?$AA@
CONST	SEGMENT
??_C@_0BG@GKHJLCDJ@?5?$CIsimulated?5mixed?5vp?$CJ?$AA@ DB ' (simulated mi'
	DB	'xed vp)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NOOBLHBB@?5?$CImixed?5vp?$CJ?$AA@
CONST	SEGMENT
??_C@_0M@NOOBLHBB@?5?$CImixed?5vp?$CJ?$AA@ DB ' (mixed vp)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NNKCKNKM@?5?$CIsimulated?5hw?5vp?$CJ?$AA@
CONST	SEGMENT
??_C@_0BD@NNKCKNKM@?5?$CIsimulated?5hw?5vp?$CJ?$AA@ DB ' (simulated hw vp'
	DB	')', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_08IAMIAIBF@?5?$CIhw?5vp?$CJ?$AA@
CONST	SEGMENT
??_C@_08IAMIAIBF@?5?$CIhw?5vp?$CJ?$AA@ DB ' (hw vp)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KADHBMJM@?5?$CIsimulated?5pure?5hw?5vp?$CJ?$AA@
CONST	SEGMENT
??_C@_0BI@KADHBMJM@?5?$CIsimulated?5pure?5hw?5vp?$CJ?$AA@ DB ' (simulated'
	DB	' pure hw vp)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@INAAPCCB@?5?$CIpure?5hw?5vp?$CJ?$AA@
CONST	SEGMENT
??_C@_0O@INAAPCCB@?5?$CIpure?5hw?5vp?$CJ?$AA@ DB ' (pure hw vp)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02JLLOHNJH@SW?$AA@
CONST	SEGMENT
??_C@_02JLLOHNJH@SW?$AA@ DB 'SW', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JHFFIENB@HA?$AA@
CONST	SEGMENT
??_C@_02JHFFIENB@HA?$AA@ DB 'HA', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GPMNEAGC@REF?$AA@
CONST	SEGMENT
??_C@_03GPMNEAGC@REF?$AA@ DB 'REF', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1IA@LBHFHEOB@?$AAD?$AAX?$AAU?$AAT?$AAG?$AAe?$AAt?$AAB?$AAa?$AAc?$AAk?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAS?$AAu?$AAr?$AAf?$AAa?$AAc?$AAe?$AAD?$AAe?$AAs?$AAc?$AA?$CI?$AA?$CJ?$AA?9?$AA?$DO@
CONST	SEGMENT
??_C@_1IA@LBHFHEOB@?$AAD?$AAX?$AAU?$AAT?$AAG?$AAe?$AAt?$AAB?$AAa?$AAc?$AAk?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAS?$AAu?$AAr?$AAf?$AAa?$AAc?$AAe?$AAD?$AAe?$AAs?$AAc?$AA?$CI?$AA?$CJ?$AA?9?$AA?$DO@ DB 'D'
	DB	00H, 'X', 00H, 'U', 00H, 'T', 00H, 'G', 00H, 'e', 00H, 't', 00H
	DB	'B', 00H, 'a', 00H, 'c', 00H, 'k', 00H, 'B', 00H, 'u', 00H, 'f'
	DB	00H, 'f', 00H, 'e', 00H, 'r', 00H, 'S', 00H, 'u', 00H, 'r', 00H
	DB	'f', 00H, 'a', 00H, 'c', 00H, 'e', 00H, 'D', 00H, 'e', 00H, 's'
	DB	00H, 'c', 00H, '(', 00H, ')', 00H, '-', 00H, '>', 00H, 'H', 00H
	DB	'e', 00H, 'i', 00H, 'g', 00H, 'h', 00H, 't', 00H, ' ', 00H, '='
	DB	00H, '=', 00H, ' ', 00H, '(', 00H, 'U', 00H, 'I', 00H, 'N', 00H
	DB	'T', 00H, ')', 00H, 'r', 00H, 'c', 00H, 'C', 00H, 'l', 00H, 'i'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, '.', 00H, 'b', 00H, 'o', 00H
	DB	't', 00H, 't', 00H, 'o', 00H, 'm', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1HM@DAKFLFBC@?$AAD?$AAX?$AAU?$AAT?$AAG?$AAe?$AAt?$AAB?$AAa?$AAc?$AAk?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAS?$AAu?$AAr?$AAf?$AAa?$AAc?$AAe?$AAD?$AAe?$AAs?$AAc?$AA?$CI?$AA?$CJ?$AA?9?$AA?$DO@
CONST	SEGMENT
??_C@_1HM@DAKFLFBC@?$AAD?$AAX?$AAU?$AAT?$AAG?$AAe?$AAt?$AAB?$AAa?$AAc?$AAk?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAS?$AAu?$AAr?$AAf?$AAa?$AAc?$AAe?$AAD?$AAe?$AAs?$AAc?$AA?$CI?$AA?$CJ?$AA?9?$AA?$DO@ DB 'D'
	DB	00H, 'X', 00H, 'U', 00H, 'T', 00H, 'G', 00H, 'e', 00H, 't', 00H
	DB	'B', 00H, 'a', 00H, 'c', 00H, 'k', 00H, 'B', 00H, 'u', 00H, 'f'
	DB	00H, 'f', 00H, 'e', 00H, 'r', 00H, 'S', 00H, 'u', 00H, 'r', 00H
	DB	'f', 00H, 'a', 00H, 'c', 00H, 'e', 00H, 'D', 00H, 'e', 00H, 's'
	DB	00H, 'c', 00H, '(', 00H, ')', 00H, '-', 00H, '>', 00H, 'W', 00H
	DB	'i', 00H, 'd', 00H, 't', 00H, 'h', 00H, ' ', 00H, '=', 00H, '='
	DB	00H, ' ', 00H, '(', 00H, 'U', 00H, 'I', 00H, 'N', 00H, 'T', 00H
	DB	')', 00H, 'r', 00H, 'c', 00H, 'C', 00H, 'l', 00H, 'i', 00H, 'e'
	DB	00H, 'n', 00H, 't', 00H, '.', 00H, 'r', 00H, 'i', 00H, 'g', 00H
	DB	'h', 00H, 't', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??DXUTRender3DEnvironment@@YAXXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?1??DXUTRender3DEnvironment@@YAXXZ@4JA DD 0db0H ; `DXUTRender3DEnvironment'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0N@IDGALNHJ@DXUTMainLoop?$AA@
CONST	SEGMENT
??_C@_0N@IDGALNHJ@DXUTMainLoop?$AA@ DB 'DXUTMainLoop', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??DXUTMainLoop@@YAJPAUHACCEL__@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??DXUTMainLoop@@YAJPAUHACCEL__@@@Z@4JA DD 0d55H ; `DXUTMainLoop'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BE@FGIMCOFA@DeviceResetCallback?$AA@
CONST	SEGMENT
??_C@_0BE@FGIMCOFA@DeviceResetCallback?$AA@ DB 'DeviceResetCallback', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05CCGMLFNG@Reset?$AA@
CONST	SEGMENT
??_C@_05CCGMLFNG@Reset?$AA@ DB 'Reset', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@LNDKPHPB@?$AAp?$AAd?$AA3?$AAd?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@LNDKPHPB@?$AAp?$AAd?$AA3?$AAd?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'p'
	DB	00H, 'd', 00H, '3', 00H, 'd', 00H, 'D', 00H, 'e', 00H, 'v', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, ' ', 00H, '!', 00H, '=', 00H, ' '
	DB	00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FG@OJNOEDOF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
CONST	SEGMENT
??_C@_1FG@OJNOEDOF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@ DB 'z'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H
	DB	's', 00H, 'r', 00H, 'c', 00H, '\', 00H, '0', 00H, '2', 00H, 'x'
	DB	00H, 'u', 00H, '1', 00H, '\', 00H, 's', 00H, 'a', 00H, 'c', 00H
	DB	'o', 00H, '\', 00H, 'd', 00H, '3', 00H, 'd', 00H, '9', 00H, '\'
	DB	00H, 'c', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'o', 00H, 'n', 00H
	DB	'\', 00H, 'd', 00H, 'x', 00H, 'u', 00H, 't', 00H, '.', 00H, 'c'
	DB	00H, 'p', 00H, 'p', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??DXUTReset3DEnvironment@@YAJXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?1??DXUTReset3DEnvironment@@YAJXZ@4JA DD 0cccH ; `DXUTReset3DEnvironment'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BF@LLKHGPAB@DeviceReset?5callback?$AA@
CONST	SEGMENT
??_C@_0BF@LLKHGPAB@DeviceReset?5callback?$AA@ DB 'DeviceReset callback', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JFPFAANM@OnResetDevice?$AA@
CONST	SEGMENT
??_C@_0O@JFPFAANM@OnResetDevice?$AA@ DB 'OnResetDevice', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PGNAKDOD@DeviceCreated?5callback?$AA@
CONST	SEGMENT
??_C@_0BH@PGNAKDOD@DeviceCreated?5callback?$AA@ DB 'DeviceCreated callbac'
	DB	'k', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JJBHJNJD@OnCreateDevice?$AA@
CONST	SEGMENT
??_C@_0P@JJBHJNJD@OnCreateDevice?$AA@ DB 'OnCreateDevice', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JIIFLKLP@CreateDevice?$AA@
CONST	SEGMENT
??_C@_0N@JIIFLKLP@CreateDevice?$AA@ DB 'CreateDevice', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??DXUTCreate3DEnvironment@@YAJPAUIDirect3DDevice9@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??DXUTCreate3DEnvironment@@YAJPAUIDirect3DDevice9@@@Z@4JA DD 0c68H ; `DXUTCreate3DEnvironment'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??DXUTFindValidDeviceSettings@@YAJPAUDXUTDeviceSettings@@0PAUDXUTMatchOptions@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??DXUTFindValidDeviceSettings@@YAJPAUDXUTDeviceSettings@@0PAUDXUTMatchOptions@@@Z@4JA DD 0589H ; `DXUTFindValidDeviceSettings'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??DXUTCreateDeviceFromSettings@@YAJPAUDXUTDeviceSettings@@_N1@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??DXUTCreateDeviceFromSettings@@YAJPAUDXUTDeviceSettings@@_N1@Z@4JA DD 0484H ; `DXUTCreateDeviceFromSettings'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0O@KPHAHHEA@DXUTSetDevice?$AA@
CONST	SEGMENT
??_C@_0O@KPHAHHEA@DXUTSetDevice?$AA@ DB 'DXUTSetDevice', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??DXUTSetDevice@@YAJPAUIDirect3DDevice9@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??DXUTSetDevice@@YAJPAUIDirect3DDevice9@@@Z@4JA DD 0438H ; `DXUTSetDevice'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BM@MONLLCLM@DXUTFindValidDeviceSettings?$AA@
CONST	SEGMENT
??_C@_0BM@MONLLCLM@DXUTFindValidDeviceSettings?$AA@ DB 'DXUTFindValidDevi'
	DB	'ceSettings', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FFFLJHOO@Direct3D?5Window?$AA@
CONST	SEGMENT
??_C@_0BA@FFFLJHOO@Direct3D?5Window?$AA@ DB 'Direct3D Window', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??DXUTCreateDevice@@YAJI_NHHP6G_NPAU_D3DCAPS9@@W4_D3DFORMAT@@20PAX@ZP6G_NPAUDXUTDeviceSettings@@PBU2@3@Z3@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??DXUTCreateDevice@@YAJI_NHHP6G_NPAU_D3DCAPS9@@W4_D3DFORMAT@@20PAX@ZP6G_NPAUDXUTDeviceSettings@@PBU2@3@Z3@Z@4JA DD 03b9H ; `DXUTCreateDevice'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BB@CBJJKGDE@SetWindowLongPtr?$AA@
CONST	SEGMENT
??_C@_0BB@CBJJKGDE@SetWindowLongPtr?$AA@ DB 'SetWindowLongPtr', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FNJALMEB@DXUTSetWindow?$AA@
CONST	SEGMENT
??_C@_0O@FNJALMEB@DXUTSetWindow?$AA@ DB 'DXUTSetWindow', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??DXUTSetWindow@@YAJPAUHWND__@@00_N@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??DXUTSetWindow@@YAJPAUHWND__@@00_N@Z@4JA DD 0373H ; `DXUTSetWindow'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0N@GKGFHBLO@CreateWindow?$AA@
CONST	SEGMENT
??_C@_0N@GKGFHBLO@CreateWindow?$AA@ DB 'CreateWindow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NLFCIADE@RegisterClass?$AA@
CONST	SEGMENT
??_C@_0O@NLFCIADE@RegisterClass?$AA@ DB 'RegisterClass', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MKMDFNEO@Direct3DWindowClass?$AA@
CONST	SEGMENT
??_C@_0BE@MKMDFNEO@Direct3DWindowClass?$AA@ DB 'Direct3DWindowClass', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LKEDMNKO@DXUTCreateWindow?$AA@
CONST	SEGMENT
??_C@_0BB@LKEDMNKO@DXUTCreateWindow?$AA@ DB 'DXUTCreateWindow', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??DXUTCreateWindow@@YAJPBDPAUHINSTANCE__@@PAUHICON__@@PAUHMENU__@@HH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??DXUTCreateWindow@@YAJPBDPAUHINSTANCE__@@PAUHICON__@@PAUHMENU__@@HH@Z@4JA DD 0305H ; `DXUTCreateWindow'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BG@BAGONEII@Unrecognized?5flag?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BG@BAGONEII@Unrecognized?5flag?3?5?$CFs?$AA@ DB 'Unrecognized flag'
	DB	': %s', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GKIGKMJB@automation?$AA@
CONST	SEGMENT
??_C@_0L@GKIGKMJB@automation?$AA@ DB 'automation', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@EMDPCOOI@noerrormsgboxes?$AA@
CONST	SEGMENT
??_C@_0BA@EMDPCOOI@noerrormsgboxes?$AA@ DB 'noerrormsgboxes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NCNNICJN@quitafterframe?$AA@
CONST	SEGMENT
??_C@_0P@NCNNICJN@quitafterframe?$AA@ DB 'quitafterframe', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DPFOJONK@constantframetime?$AA@
CONST	SEGMENT
??_C@_0BC@DPFOJONK@constantframetime?$AA@ DB 'constantframetime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06OHMBJBDJ@starty?$AA@
CONST	SEGMENT
??_C@_06OHMBJBDJ@starty?$AA@ DB 'starty', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PONKKAHI@startx?$AA@
CONST	SEGMENT
??_C@_06PONKKAHI@startx?$AA@ DB 'startx', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LNLHEAAG@height?$AA@
CONST	SEGMENT
??_C@_06LNLHEAAG@height?$AA@ DB 'height', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IGKADHGO@width?$AA@
CONST	SEGMENT
??_C@_05IGKADHGO@width?$AA@ DB 'width', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09HIJNJMJJ@forceswvp?$AA@
CONST	SEGMENT
??_C@_09HIJNJMJJ@forceswvp?$AA@ DB 'forceswvp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09GPKNDKAK@forcehwvp?$AA@
CONST	SEGMENT
??_C@_09GPKNDKAK@forcehwvp?$AA@ DB 'forcehwvp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FCGFKHNN@forcepurehwvp?$AA@
CONST	SEGMENT
??_C@_0O@FCGFKHNN@forcepurehwvp?$AA@ DB 'forcepurehwvp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08CHIMEIFO@forceref?$AA@
CONST	SEGMENT
??_C@_08CHIMEIFO@forceref?$AA@ DB 'forceref', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08OFMOLPPD@forcehal?$AA@
CONST	SEGMENT
??_C@_08OFMOLPPD@forcehal?$AA@ DB 'forcehal', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GIACNHMO@fullscreen?$AA@
CONST	SEGMENT
??_C@_0L@GIACNHMO@fullscreen?$AA@ DB 'fullscreen', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08KIHLFLPI@windowed?$AA@
CONST	SEGMENT
??_C@_08KIHLFLPI@windowed?$AA@ DB 'windowed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07HEFHPBAB@adapter?$AA@
CONST	SEGMENT
??_C@_07HEFHPBAB@adapter?$AA@ DB 'adapter', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FAFMMBOF@Direct3DCreate9?$AA@
CONST	SEGMENT
??_C@_0BA@FAFMMBOF@Direct3DCreate9?$AA@ DB 'Direct3DCreate9', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@KBAHBIDF@z?3?2sampsrc?202xu1?2saco?2d3d9?2commo@
CONST	SEGMENT
??_C@_0CL@KBAHBIDF@z?3?2sampsrc?202xu1?2saco?2d3d9?2commo@ DB 'z:\sampsrc'
	DB	'\02xu1\saco\d3d9\common\dxut.cpp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DDKDNGFF@D3DXCheckVersion?$AA@
CONST	SEGMENT
??_C@_0BB@DDKDNGFF@D3DXCheckVersion?$AA@ DB 'D3DXCheckVersion', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??DXUTInit@@YAJ_N00@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??DXUTInit@@YAJ_N00@Z@4JA DD 01c1H	; `DXUTInit'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BA@DCPFICL@timeBeginPeriod?$AA@
CONST	SEGMENT
??_C@_0BA@DCPFICL@timeBeginPeriod?$AA@ DB 'timeBeginPeriod', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NLNDMMBI@?2winmm?4dll?$AA@
CONST	SEGMENT
??_C@_0L@NLNDMMBI@?2winmm?4dll?$AA@ DB '\winmm.dll', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07JPHDIPNG@DISPLAY?$AA@
CONST	SEGMENT
??_C@_07JPHDIPNG@DISPLAY?$AA@ DB 'DISPLAY', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NPEOLIBM@EnumDisplayDevicesA?$AA@
CONST	SEGMENT
??_C@_0BE@NPEOLIBM@EnumDisplayDevicesA?$AA@ DB 'EnumDisplayDevicesA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KIAMMEPJ@GetMonitorInfoA?$AA@
CONST	SEGMENT
??_C@_0BA@KIAMMEPJ@GetMonitorInfoA?$AA@ DB 'GetMonitorInfoA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OHNDFFJG@EnumDisplayMonitors?$AA@
CONST	SEGMENT
??_C@_0BE@OHNDFFJG@EnumDisplayMonitors?$AA@ DB 'EnumDisplayMonitors', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DDMDAIAD@MonitorFromPoint?$AA@
CONST	SEGMENT
??_C@_0BB@DDMDAIAD@MonitorFromPoint?$AA@ DB 'MonitorFromPoint', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DPLKJPEB@MonitorFromRect?$AA@
CONST	SEGMENT
??_C@_0BA@DPLKJPEB@MonitorFromRect?$AA@ DB 'MonitorFromRect', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CHFENAPF@MonitorFromWindow?$AA@
CONST	SEGMENT
??_C@_0BC@CHFENAPF@MonitorFromWindow?$AA@ DB 'MonitorFromWindow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BFCABEPI@GetSystemMetrics?$AA@
CONST	SEGMENT
??_C@_0BB@BFCABEPI@GetSystemMetrics?$AA@ DB 'GetSystemMetrics', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06KDCOIDGA@USER32?$AA@
CONST	SEGMENT
??_C@_06KDCOIDGA@USER32?$AA@ DB 'USER32', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?DXUTBuildValidDeviceSettings@@YAXPAUDXUTDeviceSettings@@PAUCD3DEnumDeviceSettingsCombo@@0PAUDXUTMatchOptions@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DXUTBuildValidDeviceSettings@@YAXPAUDXUTDeviceSettings@@PAUCD3DEnumDeviceSettingsCombo@@0PAUDXUTMatchOptions@@@Z$0
__ehfuncinfo$?DXUTBuildValidDeviceSettings@@YAXPAUDXUTDeviceSettings@@PAUCD3DEnumDeviceSettingsCombo@@0PAUDXUTMatchOptions@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DXUTBuildValidDeviceSettings@@YAXPAUDXUTDeviceSettings@@PAUCD3DEnumDeviceSettingsCombo@@0PAUDXUTMatchOptions@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetDXUTState@@YAAAVDXUTState@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetDXUTState@@YAAAVDXUTState@@XZ$0
__ehfuncinfo$?GetDXUTState@@YAAAVDXUTState@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetDXUTState@@YAAAVDXUTState@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?DXUTSetTimer@@YAJP6GXIPAX@ZMPAI0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DXUTSetTimer@@YAJP6GXIPAX@ZMPAI0@Z$0
__ehfuncinfo$?DXUTSetTimer@@YAJP6GXIPAX@ZMPAI0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DXUTSetTimer@@YAJP6GXIPAX@ZMPAI0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?SetSizeInternal@?$CGrowableArray@UDXUT_TIMER@@@@IAEJH@Z
_TEXT	SEGMENT
tv91 = -232						; size = 4
tv85 = -232						; size = 4
_pDataNew$1 = -32					; size = 4
_nGrowBy$2 = -20					; size = 4
_this$ = -8						; size = 4
_nNewMaxSize$ = 8					; size = 4
?SetSizeInternal@?$CGrowableArray@UDXUT_TIMER@@@@IAEJH@Z PROC ; CGrowableArray<DXUT_TIMER>::SetSizeInternal, COMDAT
; _this$ = ecx

; 670  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 671  :     if( nNewMaxSize < 0 )

	cmp	DWORD PTR _nNewMaxSize$[ebp], 0
	jge	SHORT $LN7@SetSizeInt

; 672  :     {
; 673  :         assert( false );

	xor	eax, eax
	jne	SHORT $LN10@SetSizeInt
	push	673					; 000002a1H
	push	OFFSET ??_C@_1FK@FIMIDMPE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
	push	OFFSET ??_C@_1M@HLGKFCJM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN10@SetSizeInt:

; 674  :         return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H
	jmp	$LN8@SetSizeInt
$LN7@SetSizeInt:

; 675  :     }
; 676  : 
; 677  :     if( nNewMaxSize == 0 )

	cmp	DWORD PTR _nNewMaxSize$[ebp], 0
	jne	SHORT $LN6@SetSizeInt

; 678  :     {
; 679  :         // Shrink to 0 size & cleanup
; 680  :         if( m_pData )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@SetSizeInt

; 681  :         {
; 682  :             free( m_pData );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_free
	add	esp, 4

; 683  :             m_pData = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN5@SetSizeInt:

; 684  :         }
; 685  : 
; 686  :         m_nMaxSize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 687  :         m_nSize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	jmp	$LN4@SetSizeInt
$LN6@SetSizeInt:

; 688  :     }
; 689  :     else if( m_pData == NULL || nNewMaxSize > m_nMaxSize )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@SetSizeInt
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nNewMaxSize$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jle	$LN4@SetSizeInt
$LN2@SetSizeInt:

; 690  :     {
; 691  :         // Grow array
; 692  :         int nGrowBy = ( m_nMaxSize == 0 ) ? 16 : m_nMaxSize;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN11@SetSizeInt
	mov	DWORD PTR tv85[ebp], 16			; 00000010H
	jmp	SHORT $LN12@SetSizeInt
$LN11@SetSizeInt:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv85[ebp], edx
$LN12@SetSizeInt:
	mov	eax, DWORD PTR tv85[ebp]
	mov	DWORD PTR _nGrowBy$2[ebp], eax

; 693  :         nNewMaxSize = __max( nNewMaxSize, m_nMaxSize + nGrowBy );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _nGrowBy$2[ebp]
	cmp	DWORD PTR _nNewMaxSize$[ebp], ecx
	jle	SHORT $LN13@SetSizeInt
	mov	edx, DWORD PTR _nNewMaxSize$[ebp]
	mov	DWORD PTR tv91[ebp], edx
	jmp	SHORT $LN14@SetSizeInt
$LN13@SetSizeInt:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _nGrowBy$2[ebp]
	mov	DWORD PTR tv91[ebp], ecx
$LN14@SetSizeInt:
	mov	edx, DWORD PTR tv91[ebp]
	mov	DWORD PTR _nNewMaxSize$[ebp], edx

; 694  : 
; 695  :         TYPE* pDataNew = (TYPE*) realloc( m_pData, nNewMaxSize * sizeof(TYPE) );

	imul	eax, DWORD PTR _nNewMaxSize$[ebp], 17
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_realloc
	add	esp, 8
	mov	DWORD PTR _pDataNew$1[ebp], eax

; 696  :         if( pDataNew == NULL )

	cmp	DWORD PTR _pDataNew$1[ebp], 0
	jne	SHORT $LN1@SetSizeInt

; 697  :             return E_OUTOFMEMORY;

	mov	eax, -2147024882			; 8007000eH
	jmp	SHORT $LN8@SetSizeInt
$LN1@SetSizeInt:

; 698  : 
; 699  :         m_pData = pDataNew;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pDataNew$1[ebp]
	mov	DWORD PTR [eax], ecx

; 700  :         m_nMaxSize = nNewMaxSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nNewMaxSize$[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN4@SetSizeInt:

; 701  :     }
; 702  : 
; 703  :     return S_OK;

	xor	eax, eax
$LN8@SetSizeInt:

; 704  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSizeInternal@?$CGrowableArray@UDXUT_TIMER@@@@IAEJH@Z ENDP ; CGrowableArray<DXUT_TIMER>::SetSizeInternal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?GetSize@?$CGrowableArray@UDXUT_TIMER@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetSize@?$CGrowableArray@UDXUT_TIMER@@@@QBEHXZ PROC	; CGrowableArray<DXUT_TIMER>::GetSize, COMDAT
; _this$ = ecx

; 34   :     int     GetSize() const { return m_nSize; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSize@?$CGrowableArray@UDXUT_TIMER@@@@QBEHXZ ENDP	; CGrowableArray<DXUT_TIMER>::GetSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?GetAt@?$CGrowableArray@UDXUT_TIMER@@@@QAEAAUDXUT_TIMER@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nIndex$ = 8						; size = 4
?GetAt@?$CGrowableArray@UDXUT_TIMER@@@@QAEAAUDXUT_TIMER@@H@Z PROC ; CGrowableArray<DXUT_TIMER>::GetAt, COMDAT
; _this$ = ecx

; 33   :     TYPE&   GetAt( int nIndex ) { assert( nIndex >= 0 && nIndex < m_nSize ); return m_pData[nIndex]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _nIndex$[ebp], 0
	jl	SHORT $LN3@GetAt
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jl	SHORT $LN4@GetAt
$LN3@GetAt:
	push	33					; 00000021H
	push	OFFSET ??_C@_1FK@FIMIDMPE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
	push	OFFSET ??_C@_1EA@JHMKKLFC@?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAm?$AA_?$AAn?$AAS?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@GetAt:
	imul	eax, DWORD PTR _nIndex$[ebp], 17
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetAt@?$CGrowableArray@UDXUT_TIMER@@@@QAEAAUDXUT_TIMER@@H@Z ENDP ; CGrowableArray<DXUT_TIMER>::GetAt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?SetAt@?$CGrowableArray@UDXUT_TIMER@@@@QAEJHABUDXUT_TIMER@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nIndex$ = 8						; size = 4
_value$ = 12						; size = 4
?SetAt@?$CGrowableArray@UDXUT_TIMER@@@@QAEJHABUDXUT_TIMER@@@Z PROC ; CGrowableArray<DXUT_TIMER>::SetAt, COMDAT
; _this$ = ecx

; 791  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 792  :     // Validate arguments
; 793  :     if( nIndex < 0 ||
; 794  :         nIndex >= m_nSize )

	cmp	DWORD PTR _nIndex$[ebp], 0
	jl	SHORT $LN1@SetAt
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jl	SHORT $LN2@SetAt
$LN1@SetAt:

; 795  :     {
; 796  :         assert( false );

	xor	eax, eax
	jne	SHORT $LN5@SetAt
	push	796					; 0000031cH
	push	OFFSET ??_C@_1FK@FIMIDMPE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
	push	OFFSET ??_C@_1M@HLGKFCJM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN5@SetAt:

; 797  :         return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H
	jmp	SHORT $LN3@SetAt
$LN2@SetAt:

; 798  :     }
; 799  : 
; 800  :     m_pData[nIndex] = value;

	imul	eax, DWORD PTR _nIndex$[ebp], 17
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, eax
	mov	eax, DWORD PTR _value$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], ecx
	mov	al, BYTE PTR [eax+16]
	mov	BYTE PTR [edx+16], al

; 801  :     return S_OK;

	xor	eax, eax
$LN3@SetAt:

; 802  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?SetAt@?$CGrowableArray@UDXUT_TIMER@@@@QAEJHABUDXUT_TIMER@@@Z ENDP ; CGrowableArray<DXUT_TIMER>::SetAt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?Add@?$CGrowableArray@UDXUT_TIMER@@@@QAEJABUDXUT_TIMER@@@Z
_TEXT	SEGMENT
$T1 = -224						; size = 4
_hr$ = -20						; size = 4
_this$ = -8						; size = 4
_value$ = 8						; size = 4
?Add@?$CGrowableArray@UDXUT_TIMER@@@@QAEJABUDXUT_TIMER@@@Z PROC ; CGrowableArray<DXUT_TIMER>::Add, COMDAT
; _this$ = ecx

; 740  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 741  :     HRESULT hr;
; 742  :     if( FAILED( hr = SetSizeInternal( m_nSize + 1 ) ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSizeInternal@?$CGrowableArray@UDXUT_TIMER@@@@IAEJH@Z ; CGrowableArray<DXUT_TIMER>::SetSizeInternal
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN1@Add

; 743  :         return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	jmp	SHORT $LN2@Add
$LN1@Add:

; 744  : 
; 745  :     // Construct the new element
; 746  :     ::new (&m_pData[m_nSize]) TYPE;

	mov	eax, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [eax+4], 17
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	push	17					; 00000011H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax

; 747  : 
; 748  :     // Assign
; 749  :     m_pData[m_nSize] = value;

	mov	eax, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [eax+4], 17
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, ecx
	mov	ecx, DWORD PTR _value$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	cl, BYTE PTR [ecx+16]
	mov	BYTE PTR [eax+16], cl

; 750  :     ++m_nSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 751  : 
; 752  :     return S_OK;

	xor	eax, eax
$LN2@Add:

; 753  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Add@?$CGrowableArray@UDXUT_TIMER@@@@QAEJABUDXUT_TIMER@@@Z ENDP ; CGrowableArray<DXUT_TIMER>::Add
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ??0?$CGrowableArray@UDXUT_TIMER@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$CGrowableArray@UDXUT_TIMER@@@@QAE@XZ PROC		; CGrowableArray<DXUT_TIMER>::CGrowableArray<DXUT_TIMER>, COMDAT
; _this$ = ecx

; 20   :     CGrowableArray()  { m_pData = NULL; m_nSize = 0; m_nMaxSize = 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CGrowableArray@UDXUT_TIMER@@@@QAE@XZ ENDP		; CGrowableArray<DXUT_TIMER>::CGrowableArray<DXUT_TIMER>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?LowLevelKeyboardProc@@YGJHIJ@Z
_TEXT	SEGMENT
_nCode$ = 8						; size = 4
_wParam$ = 12						; size = 4
_lParam$ = 16						; size = 4
?LowLevelKeyboardProc@@YGJHIJ@Z PROC			; LowLevelKeyboardProc, COMDAT

; 3090 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3091 :     if (nCode < 0 || nCode != HC_ACTION)  // do not process message 

	cmp	DWORD PTR _nCode$[ebp], 0
	jl	SHORT $LN1@LowLevelKe
	cmp	DWORD PTR _nCode$[ebp], 0
	je	SHORT $LN2@LowLevelKe
$LN1@LowLevelKe:

; 3092 :         return CallNextHookEx( GetDXUTState().GetKeyboardHook(), nCode, wParam, lParam); 

	mov	esi, esp
	mov	eax, DWORD PTR _lParam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wParam$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nCode$[ebp]
	push	edx
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetKeyboardHook@DXUTState@@QAEPAUHHOOK__@@XZ ; DXUTState::GetKeyboardHook
	push	eax
	call	DWORD PTR __imp__CallNextHookEx@16
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN3@LowLevelKe
$LN2@LowLevelKe:

; 3093 : 
; 3094 : 	return CallNextHookEx( GetDXUTState().GetKeyboardHook(), nCode, wParam, lParam );

	mov	esi, esp
	mov	eax, DWORD PTR _lParam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wParam$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nCode$[ebp]
	push	edx
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetKeyboardHook@DXUTState@@QAEPAUHHOOK__@@XZ ; DXUTState::GetKeyboardHook
	push	eax
	call	DWORD PTR __imp__CallNextHookEx@16
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@LowLevelKe:

; 3095 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?LowLevelKeyboardProc@@YGJHIJ@Z ENDP			; LowLevelKeyboardProc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTGetDesktopResolution@@YAXIPAK0@Z
_TEXT	SEGMENT
$T1 = -656						; size = 4
_strDeviceName$ = -452					; size = 256
_devMode$ = -188					; size = 156
_pAdapterInfo$ = -24					; size = 4
_pd3dEnum$ = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
_AdapterOrdinal$ = 8					; size = 4
_pdwWidth$ = 12						; size = 4
_pdwHeight$ = 16					; size = 4
?DXUTGetDesktopResolution@@YAXIPAK0@Z PROC		; DXUTGetDesktopResolution, COMDAT

; 4993 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 660				; 00000294H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-660]
	mov	ecx, 165				; 000000a5H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4994 :     CD3DEnumeration* pd3dEnum = DXUTPrepareEnumerationObject();

	push	0
	call	?DXUTPrepareEnumerationObject@@YAPAVCD3DEnumeration@@_N@Z ; DXUTPrepareEnumerationObject
	add	esp, 4
	mov	DWORD PTR _pd3dEnum$[ebp], eax

; 4995 :     CD3DEnumAdapterInfo* pAdapterInfo = pd3dEnum->GetAdapterInfo( AdapterOrdinal );                       

	mov	eax, DWORD PTR _AdapterOrdinal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pd3dEnum$[ebp]
	call	?GetAdapterInfo@CD3DEnumeration@@QAEPAVCD3DEnumAdapterInfo@@I@Z ; CD3DEnumeration::GetAdapterInfo
	mov	DWORD PTR _pAdapterInfo$[ebp], eax

; 4996 :     DEVMODE devMode;
; 4997 :     ZeroMemory( &devMode, sizeof(DEVMODE) );

	push	156					; 0000009cH
	push	0
	lea	eax, DWORD PTR _devMode$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 4998 :     devMode.dmSize = sizeof(DEVMODE);

	mov	eax, 156				; 0000009cH
	mov	WORD PTR _devMode$[ebp+36], ax

; 4999 :     TCHAR strDeviceName[256];
; 5000 :     strcpy(strDeviceName,pAdapterInfo->AdapterIdentifier.DeviceName);

	mov	eax, DWORD PTR _pAdapterInfo$[ebp]
	add	eax, 1028				; 00000404H
	push	eax
	lea	ecx, DWORD PTR _strDeviceName$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 5001 :     strDeviceName[255] = 0;

	mov	eax, 1
	imul	ecx, eax, 255
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 256			; 00000100H
	jae	SHORT $LN3@DXUTGetDes
	jmp	SHORT $LN4@DXUTGetDes
$LN3@DXUTGetDes:
	call	___report_rangecheckfailure
$LN4@DXUTGetDes:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _strDeviceName$[ebp+edx], 0

; 5002 :     EnumDisplaySettings( strDeviceName, ENUM_REGISTRY_SETTINGS, &devMode );

	mov	esi, esp
	lea	eax, DWORD PTR _devMode$[ebp]
	push	eax
	push	-2					; fffffffeH
	lea	ecx, DWORD PTR _strDeviceName$[ebp]
	push	ecx
	call	DWORD PTR __imp__EnumDisplaySettingsA@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 5003 :     *pdwWidth = devMode.dmPelsWidth;

	mov	eax, DWORD PTR _pdwWidth$[ebp]
	mov	ecx, DWORD PTR _devMode$[ebp+108]
	mov	DWORD PTR [eax], ecx

; 5004 :     *pdwHeight = devMode.dmPelsHeight;

	mov	eax, DWORD PTR _pdwHeight$[ebp]
	mov	ecx, DWORD PTR _devMode$[ebp+112]
	mov	DWORD PTR [eax], ecx
$LN2@DXUTGetDes:

; 5005 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@DXUTGetDes
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 660				; 00000294H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN8@DXUTGetDes:
	DD	2
	DD	$LN7@DXUTGetDes
$LN7@DXUTGetDes:
	DD	-188					; ffffff44H
	DD	156					; 0000009cH
	DD	$LN5@DXUTGetDes
	DD	-452					; fffffe3cH
	DD	256					; 00000100H
	DD	$LN6@DXUTGetDes
$LN6@DXUTGetDes:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	68					; 00000044H
	DB	101					; 00000065H
	DB	118					; 00000076H
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	78					; 0000004eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$LN5@DXUTGetDes:
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	118					; 00000076H
	DB	77					; 0000004dH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
?DXUTGetDesktopResolution@@YAXIPAK0@Z ENDP		; DXUTGetDesktopResolution
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTSetDeviceCursor@@YAJPAUIDirect3DDevice9@@PAUHICON__@@_N@Z
_TEXT	SEGMENT
$T1 = -592						; size = 4
$T2 = -580						; size = 4
$T3 = -568						; size = 4
$T4 = -556						; size = 4
_wMask$5 = -352						; size = 10
_lr$ = -332						; size = 8
_hgdiobjOld$ = -316					; size = 4
_pBitmap$ = -304					; size = 4
_pcrArrayMask$ = -292					; size = 4
_pcrArrayColor$ = -280					; size = 4
_bmi$ = -268						; size = 44
_y$ = -216						; size = 4
_x$ = -204						; size = 4
_crMask$ = -192						; size = 4
_crColor$ = -180					; size = 4
_dwHeightDest$ = -168					; size = 4
_dwHeightSrc$ = -156					; size = 4
_dwWidth$ = -144					; size = 4
_bm$ = -132						; size = 24
_hdcScreen$ = -100					; size = 4
_hdcMask$ = -88						; size = 4
_hdcColor$ = -76					; size = 4
_pCursorSurface$ = -64					; size = 4
_bBWCursor$ = -49					; size = 1
_iconinfo$ = -40					; size = 20
_hr$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_pd3dDevice$ = 8					; size = 4
_hCursor$ = 12						; size = 4
_bAddWatermark$ = 16					; size = 1
?DXUTSetDeviceCursor@@YAJPAUIDirect3DDevice9@@PAUHICON__@@_N@Z PROC ; DXUTSetDeviceCursor, COMDAT

; 4830 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 596				; 00000254H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-596]
	mov	ecx, 149				; 00000095H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4831 :     HRESULT hr = E_FAIL;

	mov	DWORD PTR _hr$[ebp], -2147467259	; 80004005H

; 4832 :     ICONINFO iconinfo;
; 4833 :     bool bBWCursor;
; 4834 :     LPDIRECT3DSURFACE9 pCursorSurface = NULL;

	mov	DWORD PTR _pCursorSurface$[ebp], 0

; 4835 :     HDC hdcColor = NULL;

	mov	DWORD PTR _hdcColor$[ebp], 0

; 4836 :     HDC hdcMask = NULL;

	mov	DWORD PTR _hdcMask$[ebp], 0

; 4837 :     HDC hdcScreen = NULL;

	mov	DWORD PTR _hdcScreen$[ebp], 0

; 4838 :     BITMAP bm;
; 4839 :     DWORD dwWidth;
; 4840 :     DWORD dwHeightSrc;
; 4841 :     DWORD dwHeightDest;
; 4842 :     COLORREF crColor;
; 4843 :     COLORREF crMask;
; 4844 :     UINT x;
; 4845 :     UINT y;
; 4846 :     BITMAPINFO bmi;
; 4847 :     COLORREF* pcrArrayColor = NULL;

	mov	DWORD PTR _pcrArrayColor$[ebp], 0

; 4848 :     COLORREF* pcrArrayMask = NULL;

	mov	DWORD PTR _pcrArrayMask$[ebp], 0

; 4849 :     DWORD* pBitmap;
; 4850 :     HGDIOBJ hgdiobjOld;
; 4851 : 
; 4852 :     ZeroMemory( &iconinfo, sizeof(iconinfo) );

	push	20					; 00000014H
	push	0
	lea	eax, DWORD PTR _iconinfo$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 4853 :     if( !GetIconInfo( hCursor, &iconinfo ) )

	mov	esi, esp
	lea	eax, DWORD PTR _iconinfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hCursor$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetIconInfo@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN35@DXUTSetDev

; 4854 :         goto End;

	jmp	$End$46
	jmp	$End$46
$LN35@DXUTSetDev:

; 4855 : 
; 4856 :     if (0 == GetObject((HGDIOBJ)iconinfo.hbmMask, sizeof(BITMAP), (LPVOID)&bm))

	mov	esi, esp
	lea	eax, DWORD PTR _bm$[ebp]
	push	eax
	push	24					; 00000018H
	mov	ecx, DWORD PTR _iconinfo$[ebp+12]
	push	ecx
	call	DWORD PTR __imp__GetObjectA@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN33@DXUTSetDev

; 4857 :         goto End;

	jmp	$End$46
	jmp	$End$46
$LN33@DXUTSetDev:

; 4858 :     dwWidth = bm.bmWidth;

	mov	eax, DWORD PTR _bm$[ebp+4]
	mov	DWORD PTR _dwWidth$[ebp], eax

; 4859 :     dwHeightSrc = bm.bmHeight;

	mov	eax, DWORD PTR _bm$[ebp+8]
	mov	DWORD PTR _dwHeightSrc$[ebp], eax

; 4860 : 
; 4861 :     if( iconinfo.hbmColor == NULL )

	cmp	DWORD PTR _iconinfo$[ebp+16], 0
	jne	SHORT $LN31@DXUTSetDev

; 4862 :     {
; 4863 :         bBWCursor = TRUE;

	mov	BYTE PTR _bBWCursor$[ebp], 1

; 4864 :         dwHeightDest = dwHeightSrc / 2;

	mov	eax, DWORD PTR _dwHeightSrc$[ebp]
	shr	eax, 1
	mov	DWORD PTR _dwHeightDest$[ebp], eax

; 4865 :     }
; 4866 :     else 

	jmp	SHORT $LN30@DXUTSetDev
$LN31@DXUTSetDev:

; 4867 :     {
; 4868 :         bBWCursor = FALSE;

	mov	BYTE PTR _bBWCursor$[ebp], 0

; 4869 :         dwHeightDest = dwHeightSrc;

	mov	eax, DWORD PTR _dwHeightSrc$[ebp]
	mov	DWORD PTR _dwHeightDest$[ebp], eax
$LN30@DXUTSetDev:

; 4870 :     }
; 4871 : 
; 4872 :     // Create a surface for the fullscreen cursor
; 4873 :     if( FAILED( hr = pd3dDevice->CreateOffscreenPlainSurface( dwWidth, dwHeightDest, 
; 4874 :         D3DFMT_A8R8G8B8, D3DPOOL_SCRATCH, &pCursorSurface, NULL ) ) )

	mov	esi, esp
	push	0
	lea	eax, DWORD PTR _pCursorSurface$[ebp]
	push	eax
	push	3
	push	21					; 00000015H
	mov	ecx, DWORD PTR _dwHeightDest$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwWidth$[ebp]
	push	edx
	mov	eax, DWORD PTR _pd3dDevice$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pd3dDevice$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+144]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN29@DXUTSetDev

; 4875 :     {
; 4876 :         goto End;

	jmp	$End$46
	jmp	$End$46
$LN29@DXUTSetDev:

; 4877 :     }
; 4878 : 
; 4879 :     pcrArrayMask = new DWORD[dwWidth * dwHeightSrc];

	mov	eax, DWORD PTR _dwWidth$[ebp]
	imul	eax, DWORD PTR _dwHeightSrc$[ebp]
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _pcrArrayMask$[ebp], eax

; 4880 : 
; 4881 :     ZeroMemory(&bmi, sizeof(bmi));

	push	44					; 0000002cH
	push	0
	lea	eax, DWORD PTR _bmi$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 4882 :     bmi.bmiHeader.biSize = sizeof(bmi.bmiHeader);

	mov	DWORD PTR _bmi$[ebp], 40		; 00000028H

; 4883 :     bmi.bmiHeader.biWidth = dwWidth;

	mov	eax, DWORD PTR _dwWidth$[ebp]
	mov	DWORD PTR _bmi$[ebp+4], eax

; 4884 :     bmi.bmiHeader.biHeight = dwHeightSrc;

	mov	eax, DWORD PTR _dwHeightSrc$[ebp]
	mov	DWORD PTR _bmi$[ebp+8], eax

; 4885 :     bmi.bmiHeader.biPlanes = 1;

	mov	eax, 1
	mov	WORD PTR _bmi$[ebp+12], ax

; 4886 :     bmi.bmiHeader.biBitCount = 32;

	mov	eax, 32					; 00000020H
	mov	WORD PTR _bmi$[ebp+14], ax

; 4887 :     bmi.bmiHeader.biCompression = BI_RGB;

	mov	DWORD PTR _bmi$[ebp+16], 0

; 4888 : 
; 4889 :     hdcScreen = GetDC( NULL );

	mov	esi, esp
	push	0
	call	DWORD PTR __imp__GetDC@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hdcScreen$[ebp], eax

; 4890 :     hdcMask = CreateCompatibleDC( hdcScreen );

	mov	esi, esp
	mov	eax, DWORD PTR _hdcScreen$[ebp]
	push	eax
	call	DWORD PTR __imp__CreateCompatibleDC@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hdcMask$[ebp], eax

; 4891 :     if( hdcMask == NULL )

	cmp	DWORD PTR _hdcMask$[ebp], 0
	jne	SHORT $LN27@DXUTSetDev

; 4892 :     {
; 4893 :         hr = E_FAIL;

	mov	DWORD PTR _hr$[ebp], -2147467259	; 80004005H

; 4894 :         goto End;

	jmp	$End$46
	jmp	$End$46
$LN27@DXUTSetDev:

; 4895 :     }
; 4896 :     hgdiobjOld = SelectObject(hdcMask, iconinfo.hbmMask);

	mov	esi, esp
	mov	eax, DWORD PTR _iconinfo$[ebp+12]
	push	eax
	mov	ecx, DWORD PTR _hdcMask$[ebp]
	push	ecx
	call	DWORD PTR __imp__SelectObject@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hgdiobjOld$[ebp], eax

; 4897 :     GetDIBits(hdcMask, iconinfo.hbmMask, 0, dwHeightSrc, 
; 4898 :         pcrArrayMask, &bmi, DIB_RGB_COLORS);

	mov	esi, esp
	push	0
	lea	eax, DWORD PTR _bmi$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pcrArrayMask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwHeightSrc$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _iconinfo$[ebp+12]
	push	eax
	mov	ecx, DWORD PTR _hdcMask$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetDIBits@28
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4899 :     SelectObject(hdcMask, hgdiobjOld);

	mov	esi, esp
	mov	eax, DWORD PTR _hgdiobjOld$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hdcMask$[ebp]
	push	ecx
	call	DWORD PTR __imp__SelectObject@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4900 : 
; 4901 :     if (!bBWCursor)

	movzx	eax, BYTE PTR _bBWCursor$[ebp]
	test	eax, eax
	jne	$LN25@DXUTSetDev

; 4902 :     {
; 4903 :         pcrArrayColor = new DWORD[dwWidth * dwHeightDest];

	mov	eax, DWORD PTR _dwWidth$[ebp]
	imul	eax, DWORD PTR _dwHeightDest$[ebp]
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _pcrArrayColor$[ebp], eax

; 4904 :         hdcColor = CreateCompatibleDC( hdcScreen );

	mov	esi, esp
	mov	eax, DWORD PTR _hdcScreen$[ebp]
	push	eax
	call	DWORD PTR __imp__CreateCompatibleDC@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hdcColor$[ebp], eax

; 4905 :         if( hdcColor == NULL )

	cmp	DWORD PTR _hdcColor$[ebp], 0
	jne	SHORT $LN24@DXUTSetDev

; 4906 :         {
; 4907 :             hr = E_FAIL;

	mov	DWORD PTR _hr$[ebp], -2147467259	; 80004005H

; 4908 :             goto End;

	jmp	$End$46
	jmp	$End$46
$LN24@DXUTSetDev:

; 4909 :         }
; 4910 :         SelectObject(hdcColor, iconinfo.hbmColor);

	mov	esi, esp
	mov	eax, DWORD PTR _iconinfo$[ebp+16]
	push	eax
	mov	ecx, DWORD PTR _hdcColor$[ebp]
	push	ecx
	call	DWORD PTR __imp__SelectObject@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4911 :         GetDIBits(hdcColor, iconinfo.hbmColor, 0, dwHeightDest, 
; 4912 :             pcrArrayColor, &bmi, DIB_RGB_COLORS);

	mov	esi, esp
	push	0
	lea	eax, DWORD PTR _bmi$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pcrArrayColor$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwHeightDest$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _iconinfo$[ebp+16]
	push	eax
	mov	ecx, DWORD PTR _hdcColor$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetDIBits@28
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN25@DXUTSetDev:

; 4913 :     }
; 4914 : 
; 4915 :     // Transfer cursor image into the surface
; 4916 :     D3DLOCKED_RECT lr;
; 4917 :     pCursorSurface->LockRect( &lr, NULL, 0 );

	mov	esi, esp
	push	0
	push	0
	lea	eax, DWORD PTR _lr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCursorSurface$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pCursorSurface$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+52]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4918 :     pBitmap = (DWORD*)lr.pBits;

	mov	eax, DWORD PTR _lr$[ebp+4]
	mov	DWORD PTR _pBitmap$[ebp], eax

; 4919 :     for( y = 0; y < dwHeightDest; y++ )

	mov	DWORD PTR _y$[ebp], 0
	jmp	SHORT $LN22@DXUTSetDev
$LN21@DXUTSetDev:
	mov	eax, DWORD PTR _y$[ebp]
	add	eax, 1
	mov	DWORD PTR _y$[ebp], eax
$LN22@DXUTSetDev:
	mov	eax, DWORD PTR _y$[ebp]
	cmp	eax, DWORD PTR _dwHeightDest$[ebp]
	jae	$LN20@DXUTSetDev

; 4920 :     {
; 4921 :         for( x = 0; x < dwWidth; x++ )

	mov	DWORD PTR _x$[ebp], 0
	jmp	SHORT $LN19@DXUTSetDev
$LN18@DXUTSetDev:
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, 1
	mov	DWORD PTR _x$[ebp], eax
$LN19@DXUTSetDev:
	mov	eax, DWORD PTR _x$[ebp]
	cmp	eax, DWORD PTR _dwWidth$[ebp]
	jae	$LN17@DXUTSetDev

; 4922 :         {
; 4923 :             if (bBWCursor)

	movzx	eax, BYTE PTR _bBWCursor$[ebp]
	test	eax, eax
	je	SHORT $LN16@DXUTSetDev

; 4924 :             {
; 4925 :                 crColor = pcrArrayMask[dwWidth*(dwHeightDest-1-y) + x];

	mov	eax, DWORD PTR _dwHeightDest$[ebp]
	sub	eax, 1
	sub	eax, DWORD PTR _y$[ebp]
	imul	eax, DWORD PTR _dwWidth$[ebp]
	add	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _pcrArrayMask$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _crColor$[ebp], edx

; 4926 :                 crMask = pcrArrayMask[dwWidth*(dwHeightSrc-1-y) + x];

	mov	eax, DWORD PTR _dwHeightSrc$[ebp]
	sub	eax, 1
	sub	eax, DWORD PTR _y$[ebp]
	imul	eax, DWORD PTR _dwWidth$[ebp]
	add	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _pcrArrayMask$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _crMask$[ebp], edx

; 4927 :             }
; 4928 :             else

	jmp	SHORT $LN15@DXUTSetDev
$LN16@DXUTSetDev:

; 4929 :             {
; 4930 :                 crColor = pcrArrayColor[dwWidth*(dwHeightDest-1-y) + x];

	mov	eax, DWORD PTR _dwHeightDest$[ebp]
	sub	eax, 1
	sub	eax, DWORD PTR _y$[ebp]
	imul	eax, DWORD PTR _dwWidth$[ebp]
	add	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _pcrArrayColor$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _crColor$[ebp], edx

; 4931 :                 crMask = pcrArrayMask[dwWidth*(dwHeightDest-1-y) + x];

	mov	eax, DWORD PTR _dwHeightDest$[ebp]
	sub	eax, 1
	sub	eax, DWORD PTR _y$[ebp]
	imul	eax, DWORD PTR _dwWidth$[ebp]
	add	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _pcrArrayMask$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _crMask$[ebp], edx
$LN15@DXUTSetDev:

; 4932 :             }
; 4933 :             if (crMask == 0)

	cmp	DWORD PTR _crMask$[ebp], 0
	jne	SHORT $LN14@DXUTSetDev

; 4934 :                 pBitmap[dwWidth*y + x] = 0xff000000 | crColor;

	mov	eax, DWORD PTR _crColor$[ebp]
	or	eax, -16777216				; ff000000H
	mov	ecx, DWORD PTR _dwWidth$[ebp]
	imul	ecx, DWORD PTR _y$[ebp]
	add	ecx, DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR _pBitmap$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 4935 :             else

	jmp	SHORT $LN13@DXUTSetDev
$LN14@DXUTSetDev:

; 4936 :                 pBitmap[dwWidth*y + x] = 0x00000000;

	mov	eax, DWORD PTR _dwWidth$[ebp]
	imul	eax, DWORD PTR _y$[ebp]
	add	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _pBitmap$[ebp]
	mov	DWORD PTR [ecx+eax*4], 0
$LN13@DXUTSetDev:

; 4937 : 
; 4938 :             // It may be helpful to make the D3D cursor look slightly 
; 4939 :             // different from the Windows cursor so you can distinguish 
; 4940 :             // between the two when developing/testing code.  When
; 4941 :             // bAddWatermark is TRUE, the following code adds some
; 4942 :             // small grey "D3D" characters to the upper-left corner of
; 4943 :             // the D3D cursor image.
; 4944 :             if( bAddWatermark && x < 12 && y < 5 )

	movzx	eax, BYTE PTR _bAddWatermark$[ebp]
	test	eax, eax
	je	$LN12@DXUTSetDev
	cmp	DWORD PTR _x$[ebp], 12			; 0000000cH
	jae	$LN12@DXUTSetDev
	cmp	DWORD PTR _y$[ebp], 5
	jae	$LN12@DXUTSetDev

; 4945 :             {
; 4946 :                 // 11.. 11.. 11.. .... CCC0
; 4947 :                 // 1.1. ..1. 1.1. .... A2A0
; 4948 :                 // 1.1. .1.. 1.1. .... A4A0
; 4949 :                 // 1.1. ..1. 1.1. .... A2A0
; 4950 :                 // 11.. 11.. 11.. .... CCC0
; 4951 : 
; 4952 :                 const WORD wMask[5] = { 0xccc0, 0xa2a0, 0xa4a0, 0xa2a0, 0xccc0 };

	mov	eax, 52416				; 0000ccc0H
	mov	WORD PTR _wMask$5[ebp], ax
	mov	eax, 41632				; 0000a2a0H
	mov	WORD PTR _wMask$5[ebp+2], ax
	mov	eax, 42144				; 0000a4a0H
	mov	WORD PTR _wMask$5[ebp+4], ax
	mov	eax, 41632				; 0000a2a0H
	mov	WORD PTR _wMask$5[ebp+6], ax
	mov	eax, 52416				; 0000ccc0H
	mov	WORD PTR _wMask$5[ebp+8], ax

; 4953 :                 if( wMask[y] & (1 << (15 - x)) )

	mov	eax, DWORD PTR _y$[ebp]
	movzx	edx, WORD PTR _wMask$5[ebp+eax*2]
	mov	ecx, 15					; 0000000fH
	sub	ecx, DWORD PTR _x$[ebp]
	mov	eax, 1
	shl	eax, cl
	and	edx, eax
	je	SHORT $LN12@DXUTSetDev

; 4954 :                 {
; 4955 :                     pBitmap[dwWidth*y + x] |= 0xff808080;

	mov	eax, DWORD PTR _dwWidth$[ebp]
	imul	eax, DWORD PTR _y$[ebp]
	add	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _pBitmap$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	or	edx, -8355712				; ff808080H
	mov	eax, DWORD PTR _dwWidth$[ebp]
	imul	eax, DWORD PTR _y$[ebp]
	add	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _pBitmap$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx
$LN12@DXUTSetDev:

; 4956 :                 }
; 4957 :             }
; 4958 :         }

	jmp	$LN18@DXUTSetDev
$LN17@DXUTSetDev:

; 4959 :     }

	jmp	$LN21@DXUTSetDev
$LN20@DXUTSetDev:

; 4960 :     pCursorSurface->UnlockRect();

	mov	eax, DWORD PTR _pCursorSurface$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR _pCursorSurface$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+56]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4961 : 
; 4962 :     // Set the device cursor
; 4963 :     if( FAILED( hr = pd3dDevice->SetCursorProperties( iconinfo.xHotspot, 
; 4964 :         iconinfo.yHotspot, pCursorSurface ) ) )

	mov	esi, esp
	mov	eax, DWORD PTR _pCursorSurface$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iconinfo$[ebp+8]
	push	ecx
	mov	edx, DWORD PTR _iconinfo$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _pd3dDevice$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pd3dDevice$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+40]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN10@DXUTSetDev

; 4965 :     {
; 4966 :         goto End;

	jmp	SHORT $End$46
	jmp	SHORT $End$46
$LN10@DXUTSetDev:

; 4967 :     }
; 4968 : 
; 4969 :     hr = S_OK;

	mov	DWORD PTR _hr$[ebp], 0
$End$46:

; 4970 : 
; 4971 : End:
; 4972 :     if( iconinfo.hbmMask != NULL )

	cmp	DWORD PTR _iconinfo$[ebp+12], 0
	je	SHORT $LN8@DXUTSetDev

; 4973 :         DeleteObject( iconinfo.hbmMask );

	mov	esi, esp
	mov	eax, DWORD PTR _iconinfo$[ebp+12]
	push	eax
	call	DWORD PTR __imp__DeleteObject@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN8@DXUTSetDev:

; 4974 :     if( iconinfo.hbmColor != NULL )

	cmp	DWORD PTR _iconinfo$[ebp+16], 0
	je	SHORT $LN7@DXUTSetDev

; 4975 :         DeleteObject( iconinfo.hbmColor );

	mov	esi, esp
	mov	eax, DWORD PTR _iconinfo$[ebp+16]
	push	eax
	call	DWORD PTR __imp__DeleteObject@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@DXUTSetDev:

; 4976 :     if( hdcScreen != NULL )

	cmp	DWORD PTR _hdcScreen$[ebp], 0
	je	SHORT $LN6@DXUTSetDev

; 4977 :         ReleaseDC( NULL, hdcScreen );

	mov	esi, esp
	mov	eax, DWORD PTR _hdcScreen$[ebp]
	push	eax
	push	0
	call	DWORD PTR __imp__ReleaseDC@8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@DXUTSetDev:

; 4978 :     if( hdcColor != NULL )

	cmp	DWORD PTR _hdcColor$[ebp], 0
	je	SHORT $LN5@DXUTSetDev

; 4979 :         DeleteDC( hdcColor );

	mov	esi, esp
	mov	eax, DWORD PTR _hdcColor$[ebp]
	push	eax
	call	DWORD PTR __imp__DeleteDC@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@DXUTSetDev:

; 4980 :     if( hdcMask != NULL )

	cmp	DWORD PTR _hdcMask$[ebp], 0
	je	SHORT $LN4@DXUTSetDev

; 4981 :         DeleteDC( hdcMask );

	mov	esi, esp
	mov	eax, DWORD PTR _hdcMask$[ebp]
	push	eax
	call	DWORD PTR __imp__DeleteDC@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@DXUTSetDev:

; 4982 :     SAFE_DELETE_ARRAY( pcrArrayColor );

	cmp	DWORD PTR _pcrArrayColor$[ebp], 0
	je	SHORT $LN3@DXUTSetDev
	mov	eax, DWORD PTR _pcrArrayColor$[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR _pcrArrayColor$[ebp], 0
$LN3@DXUTSetDev:

; 4983 :     SAFE_DELETE_ARRAY( pcrArrayMask );

	cmp	DWORD PTR _pcrArrayMask$[ebp], 0
	je	SHORT $LN2@DXUTSetDev
	mov	eax, DWORD PTR _pcrArrayMask$[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	ecx, DWORD PTR $T4[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR _pcrArrayMask$[ebp], 0
$LN2@DXUTSetDev:

; 4984 :     SAFE_RELEASE( pCursorSurface );

	cmp	DWORD PTR _pCursorSurface$[ebp], 0
	je	SHORT $LN1@DXUTSetDev
	mov	eax, DWORD PTR _pCursorSurface$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR _pCursorSurface$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pCursorSurface$[ebp], 0
$LN1@DXUTSetDev:

; 4985 :     return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 4986 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN45@DXUTSetDev
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 596				; 00000254H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN45@DXUTSetDev:
	DD	6
	DD	$LN44@DXUTSetDev
$LN44@DXUTSetDev:
	DD	-40					; ffffffd8H
	DD	20					; 00000014H
	DD	$LN38@DXUTSetDev
	DD	-64					; ffffffc0H
	DD	4
	DD	$LN39@DXUTSetDev
	DD	-132					; ffffff7cH
	DD	24					; 00000018H
	DD	$LN40@DXUTSetDev
	DD	-268					; fffffef4H
	DD	44					; 0000002cH
	DD	$LN41@DXUTSetDev
	DD	-332					; fffffeb4H
	DD	8
	DD	$LN42@DXUTSetDev
	DD	-352					; fffffea0H
	DD	10					; 0000000aH
	DD	$LN43@DXUTSetDev
$LN43@DXUTSetDev:
	DB	119					; 00000077H
	DB	77					; 0000004dH
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	107					; 0000006bH
	DB	0
$LN42@DXUTSetDev:
	DB	108					; 0000006cH
	DB	114					; 00000072H
	DB	0
$LN41@DXUTSetDev:
	DB	98					; 00000062H
	DB	109					; 0000006dH
	DB	105					; 00000069H
	DB	0
$LN40@DXUTSetDev:
	DB	98					; 00000062H
	DB	109					; 0000006dH
	DB	0
$LN39@DXUTSetDev:
	DB	112					; 00000070H
	DB	67					; 00000043H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	115					; 00000073H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	83					; 00000053H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	102					; 00000066H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	0
$LN38@DXUTSetDev:
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	102					; 00000066H
	DB	111					; 0000006fH
	DB	0
?DXUTSetDeviceCursor@@YAJPAUIDirect3DDevice9@@PAUHICON__@@_N@Z ENDP ; DXUTSetDeviceCursor
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTInitHWCursor@@YAXXZ
_TEXT	SEGMENT
tv79 = -236						; size = 4
_rcWindow$1 = -36					; size = 16
_hCursor$2 = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
?DXUTInitHWCursor@@YAXXZ PROC				; DXUTInitHWCursor, COMDAT

; 4807 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 236				; 000000ecH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-236]
	mov	ecx, 59					; 0000003bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4808 :     // Set up the full screen cursor 
; 4809 :     if( !DXUTIsWindowed() )

	call	?DXUTIsWindowed@@YA_NXZ			; DXUTIsWindowed
	movzx	eax, al
	test	eax, eax
	jne	$LN2@DXUTInitHW

; 4810 :     {
; 4811 :         HCURSOR hCursor = (HCURSOR)(ULONG_PTR)GetClassLongPtr( DXUTGetHWNDDeviceFullScreen(), GCLP_HCURSOR );

	mov	esi, esp
	push	-12					; fffffff4H
	call	?DXUTGetHWNDDeviceFullScreen@@YAPAUHWND__@@XZ ; DXUTGetHWNDDeviceFullScreen
	push	eax
	call	DWORD PTR __imp__GetClassLongA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hCursor$2[ebp], eax

; 4812 :         DXUTSetDeviceCursor( GetDXUTState().GetD3DDevice(), hCursor, false );

	push	0
	mov	eax, DWORD PTR _hCursor$2[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetD3DDevice@DXUTState@@QAEPAUIDirect3DDevice9@@XZ ; DXUTState::GetD3DDevice
	push	eax
	call	?DXUTSetDeviceCursor@@YAJPAUIDirect3DDevice9@@PAUHICON__@@_N@Z ; DXUTSetDeviceCursor
	add	esp, 12					; 0000000cH

; 4813 :         DXUTGetD3DDevice()->ShowCursor( true );

	call	?DXUTGetD3DDevice@@YAPAUIDirect3DDevice9@@XZ ; DXUTGetD3DDevice
	mov	DWORD PTR tv79[ebp], eax
	mov	esi, esp
	push	1
	mov	eax, DWORD PTR tv79[ebp]
	push	eax
	mov	ecx, DWORD PTR tv79[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4814 : 
; 4815 :         // Confine cursor to full screen window
; 4816 :         RECT rcWindow;
; 4817 :         GetWindowRect( DXUTGetHWNDDeviceFullScreen(), &rcWindow );

	mov	esi, esp
	lea	eax, DWORD PTR _rcWindow$1[ebp]
	push	eax
	call	?DXUTGetHWNDDeviceFullScreen@@YAPAUHWND__@@XZ ; DXUTGetHWNDDeviceFullScreen
	push	eax
	call	DWORD PTR __imp__GetWindowRect@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4818 :         ClipCursor( &rcWindow );

	mov	esi, esp
	lea	eax, DWORD PTR _rcWindow$1[ebp]
	push	eax
	call	DWORD PTR __imp__ClipCursor@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4819 :     }
; 4820 :     else

	jmp	SHORT $LN3@DXUTInitHW
$LN2@DXUTInitHW:

; 4821 :     {
; 4822 :         ClipCursor( NULL );

	mov	esi, esp
	push	0
	call	DWORD PTR __imp__ClipCursor@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@DXUTInitHW:

; 4823 :     }
; 4824 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@DXUTInitHW
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 236				; 000000ecH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN7@DXUTInitHW:
	DD	1
	DD	$LN6@DXUTInitHW
$LN6@DXUTInitHW:
	DD	-36					; ffffffdcH
	DD	16					; 00000010H
	DD	$LN5@DXUTInitHW
$LN5@DXUTInitHW:
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	87					; 00000057H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	111					; 0000006fH
	DB	119					; 00000077H
	DB	0
?DXUTInitHWCursor@@YAXXZ ENDP				; DXUTInitHWCursor
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTUpdateBackBufferDesc@@YAXXZ
_TEXT	SEGMENT
tv68 = -232						; size = 4
_pBBufferSurfaceDesc$ = -32				; size = 4
_pBackBuffer$ = -20					; size = 4
_hr$ = -8						; size = 4
?DXUTUpdateBackBufferDesc@@YAXXZ PROC			; DXUTUpdateBackBufferDesc, COMDAT

; 4412 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4413 :     HRESULT hr;
; 4414 :     IDirect3DSurface9* pBackBuffer;
; 4415 :     hr = GetDXUTState().GetD3DDevice()->GetBackBuffer( 0, 0, D3DBACKBUFFER_TYPE_MONO, &pBackBuffer );

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetD3DDevice@DXUTState@@QAEPAUIDirect3DDevice9@@XZ ; DXUTState::GetD3DDevice
	mov	DWORD PTR tv68[ebp], eax
	mov	esi, esp
	lea	eax, DWORD PTR _pBackBuffer$[ebp]
	push	eax
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR tv68[ebp]
	push	ecx
	mov	edx, DWORD PTR tv68[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+72]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 4416 :     D3DSURFACE_DESC* pBBufferSurfaceDesc = GetDXUTState().GetBackBufferSurfaceDesc();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetBackBufferSurfaceDesc@DXUTState@@QAEPAU_D3DSURFACE_DESC@@XZ ; DXUTState::GetBackBufferSurfaceDesc
	mov	DWORD PTR _pBBufferSurfaceDesc$[ebp], eax

; 4417 :     ZeroMemory( pBBufferSurfaceDesc, sizeof(D3DSURFACE_DESC) );

	push	32					; 00000020H
	push	0
	mov	eax, DWORD PTR _pBBufferSurfaceDesc$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 4418 :     if( SUCCEEDED(hr) )

	cmp	DWORD PTR _hr$[ebp], 0
	jl	SHORT $LN3@DXUTUpdate

; 4419 :     {
; 4420 :         pBackBuffer->GetDesc( pBBufferSurfaceDesc );

	mov	esi, esp
	mov	eax, DWORD PTR _pBBufferSurfaceDesc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBackBuffer$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pBackBuffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+48]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4421 :         SAFE_RELEASE( pBackBuffer );

	cmp	DWORD PTR _pBackBuffer$[ebp], 0
	je	SHORT $LN3@DXUTUpdate
	mov	eax, DWORD PTR _pBackBuffer$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR _pBackBuffer$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pBackBuffer$[ebp], 0
$LN3@DXUTUpdate:

; 4422 :     }
; 4423 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@DXUTUpdate
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN7@DXUTUpdate:
	DD	1
	DD	$LN6@DXUTUpdate
$LN6@DXUTUpdate:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN5@DXUTUpdate
$LN5@DXUTUpdate:
	DB	112					; 00000070H
	DB	66					; 00000042H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
?DXUTUpdateBackBufferDesc@@YAXXZ ENDP			; DXUTUpdateBackBufferDesc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTAllowShortcutKeys@@YAX_N@Z
_TEXT	SEGMENT
_bAllowKeys$ = 8					; size = 1
?DXUTAllowShortcutKeys@@YAX_N@Z PROC			; DXUTAllowShortcutKeys, COMDAT

; 3124 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3125 :     GetDXUTState().SetAllowShortcutKeys( bAllowKeys );

	movzx	eax, BYTE PTR _bAllowKeys$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetAllowShortcutKeys@DXUTState@@QAEX_N@Z ; DXUTState::SetAllowShortcutKeys

; 3126 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTAllowShortcutKeys@@YAX_N@Z ENDP			; DXUTAllowShortcutKeys
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTGetAdapterOrdinalFromMonitor@@YAJPAUHMONITOR__@@PAI@Z
_TEXT	SEGMENT
_hAdapterMonitor$1 = -68				; size = 4
_pAdapterInfo$2 = -56					; size = 4
_iAdapter$3 = -44					; size = 4
_pAdapterList$ = -32					; size = 4
_pD3D$ = -20						; size = 4
_pd3dEnum$ = -8						; size = 4
_hMonitor$ = 8						; size = 4
_pAdapterOrdinal$ = 12					; size = 4
?DXUTGetAdapterOrdinalFromMonitor@@YAJPAUHMONITOR__@@PAI@Z PROC ; DXUTGetAdapterOrdinalFromMonitor, COMDAT

; 4765 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4766 :     *pAdapterOrdinal = 0;

	mov	eax, DWORD PTR _pAdapterOrdinal$[ebp]
	mov	DWORD PTR [eax], 0

; 4767 : 
; 4768 :     CD3DEnumeration* pd3dEnum = DXUTPrepareEnumerationObject();

	push	0
	call	?DXUTPrepareEnumerationObject@@YAPAVCD3DEnumeration@@_N@Z ; DXUTPrepareEnumerationObject
	add	esp, 4
	mov	DWORD PTR _pd3dEnum$[ebp], eax

; 4769 :     IDirect3D9*      pD3D     = DXUTGetD3DObject();

	call	?DXUTGetD3DObject@@YAPAUIDirect3D9@@XZ	; DXUTGetD3DObject
	mov	DWORD PTR _pD3D$[ebp], eax

; 4770 : 
; 4771 :     CGrowableArray<CD3DEnumAdapterInfo*>* pAdapterList = pd3dEnum->GetAdapterInfoList();

	mov	ecx, DWORD PTR _pd3dEnum$[ebp]
	call	?GetAdapterInfoList@CD3DEnumeration@@QAEPAV?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@XZ ; CD3DEnumeration::GetAdapterInfoList
	mov	DWORD PTR _pAdapterList$[ebp], eax

; 4772 :     for( int iAdapter=0; iAdapter<pAdapterList->GetSize(); iAdapter++ )

	mov	DWORD PTR _iAdapter$3[ebp], 0
	jmp	SHORT $LN4@DXUTGetAda
$LN3@DXUTGetAda:
	mov	eax, DWORD PTR _iAdapter$3[ebp]
	add	eax, 1
	mov	DWORD PTR _iAdapter$3[ebp], eax
$LN4@DXUTGetAda:
	mov	ecx, DWORD PTR _pAdapterList$[ebp]
	call	?GetSize@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QBEHXZ ; CGrowableArray<CD3DEnumAdapterInfo *>::GetSize
	cmp	DWORD PTR _iAdapter$3[ebp], eax
	jge	SHORT $LN2@DXUTGetAda

; 4773 :     {
; 4774 :         CD3DEnumAdapterInfo* pAdapterInfo = pAdapterList->GetAt(iAdapter);

	mov	eax, DWORD PTR _iAdapter$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _pAdapterList$[ebp]
	call	?GetAt@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAEAAPAVCD3DEnumAdapterInfo@@H@Z ; CGrowableArray<CD3DEnumAdapterInfo *>::GetAt
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pAdapterInfo$2[ebp], ecx

; 4775 :         HMONITOR hAdapterMonitor = pD3D->GetAdapterMonitor( pAdapterInfo->AdapterOrdinal );

	mov	esi, esp
	mov	eax, DWORD PTR _pAdapterInfo$2[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _pD3D$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pD3D$[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+60]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hAdapterMonitor$1[ebp], eax

; 4776 :         if( hAdapterMonitor == hMonitor )

	mov	eax, DWORD PTR _hAdapterMonitor$1[ebp]
	cmp	eax, DWORD PTR _hMonitor$[ebp]
	jne	SHORT $LN1@DXUTGetAda

; 4777 :         {
; 4778 :             *pAdapterOrdinal = pAdapterInfo->AdapterOrdinal;

	mov	eax, DWORD PTR _pAdapterOrdinal$[ebp]
	mov	ecx, DWORD PTR _pAdapterInfo$2[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 4779 :             return S_OK;

	xor	eax, eax
	jmp	SHORT $LN5@DXUTGetAda
$LN1@DXUTGetAda:

; 4780 :         }
; 4781 :     }

	jmp	SHORT $LN3@DXUTGetAda
$LN2@DXUTGetAda:

; 4782 : 
; 4783 :     return E_FAIL;

	mov	eax, -2147467259			; 80004005H
$LN5@DXUTGetAda:

; 4784 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTGetAdapterOrdinalFromMonitor@@YAJPAUHMONITOR__@@PAI@Z ENDP ; DXUTGetAdapterOrdinalFromMonitor
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTCheckForWindowChangingMonitors@@YAXXZ
_TEXT	SEGMENT
$T1 = -548						; size = 72
$T2 = -468						; size = 72
_matchOptions$3 = -196					; size = 60
_deviceSettings$4 = -128				; size = 72
_newOrdinal$5 = -48					; size = 4
_hAdapterMonitor$ = -36					; size = 4
_hWindowMonitor$ = -24					; size = 4
_hr$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?DXUTCheckForWindowChangingMonitors@@YAXXZ PROC		; DXUTCheckForWindowChangingMonitors, COMDAT

; 4697 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 552				; 00000228H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-552]
	mov	ecx, 138				; 0000008aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4698 :     // Skip this check for various reasons
; 4699 :     if( !GetDXUTState().GetAutoChangeAdapter() || 
; 4700 :          GetDXUTState().GetIgnoreSizeChange() ||
; 4701 :         !GetDXUTState().GetDeviceCreated() ||
; 4702 :         !GetDXUTState().GetCurrentDeviceSettings()->pp.Windowed )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetAutoChangeAdapter@DXUTState@@QAE_NXZ ; DXUTState::GetAutoChangeAdapter
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@DXUTCheckF
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetIgnoreSizeChange@DXUTState@@QAE_NXZ	; DXUTState::GetIgnoreSizeChange
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN7@DXUTCheckF
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetDeviceCreated@DXUTState@@QAE_NXZ	; DXUTState::GetDeviceCreated
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@DXUTCheckF
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetCurrentDeviceSettings@DXUTState@@QAEPAUDXUTDeviceSettings@@XZ ; DXUTState::GetCurrentDeviceSettings
	cmp	DWORD PTR [eax+48], 0
	jne	SHORT $LN8@DXUTCheckF
$LN7@DXUTCheckF:

; 4703 :     {
; 4704 :         return;

	jmp	$LN9@DXUTCheckF
$LN8@DXUTCheckF:

; 4705 :     }
; 4706 : 
; 4707 :     HRESULT hr;
; 4708 :     HMONITOR hWindowMonitor = MonitorFromWindow( DXUTGetHWND(), MONITOR_DEFAULTTOPRIMARY );

	push	1
	call	?DXUTGetHWND@@YAPAUHWND__@@XZ		; DXUTGetHWND
	push	eax
	call	_xMonitorFromWindow@8
	mov	DWORD PTR _hWindowMonitor$[ebp], eax

; 4709 :     HMONITOR hAdapterMonitor = GetDXUTState().GetAdapterMonitor();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetAdapterMonitor@DXUTState@@QAEPAUHMONITOR__@@XZ ; DXUTState::GetAdapterMonitor
	mov	DWORD PTR _hAdapterMonitor$[ebp], eax

; 4710 :     if( hWindowMonitor != hAdapterMonitor )

	mov	eax, DWORD PTR _hWindowMonitor$[ebp]
	cmp	eax, DWORD PTR _hAdapterMonitor$[ebp]
	je	$LN9@DXUTCheckF

; 4711 :     {
; 4712 :         UINT newOrdinal;
; 4713 :         if( SUCCEEDED( DXUTGetAdapterOrdinalFromMonitor( hWindowMonitor, &newOrdinal ) ) )

	lea	eax, DWORD PTR _newOrdinal$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _hWindowMonitor$[ebp]
	push	ecx
	call	?DXUTGetAdapterOrdinalFromMonitor@@YAJPAUHMONITOR__@@PAI@Z ; DXUTGetAdapterOrdinalFromMonitor
	add	esp, 8
	test	eax, eax
	jl	$LN9@DXUTCheckF

; 4714 :         {
; 4715 :             // Find the closest valid device settings with the new ordinal
; 4716 :             DXUTDeviceSettings deviceSettings = DXUTGetDeviceSettings();

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?DXUTGetDeviceSettings@@YA?AUDXUTDeviceSettings@@XZ ; DXUTGetDeviceSettings
	add	esp, 4
	mov	ecx, 18					; 00000012H
	mov	esi, eax
	lea	edi, DWORD PTR $T1[ebp]
	rep movsd
	mov	ecx, 18					; 00000012H
	lea	esi, DWORD PTR $T1[ebp]
	lea	edi, DWORD PTR _deviceSettings$4[ebp]
	rep movsd

; 4717 :             deviceSettings.AdapterOrdinal = newOrdinal;

	mov	eax, DWORD PTR _newOrdinal$5[ebp]
	mov	DWORD PTR _deviceSettings$4[ebp], eax

; 4718 :             
; 4719 :             DXUTMatchOptions matchOptions;
; 4720 :             matchOptions.eAdapterOrdinal     = DXUTMT_PRESERVE_INPUT;

	mov	DWORD PTR _matchOptions$3[ebp], 1

; 4721 :             matchOptions.eDeviceType         = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$3[ebp+4], 2

; 4722 :             matchOptions.eWindowed           = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$3[ebp+8], 2

; 4723 :             matchOptions.eAdapterFormat      = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$3[ebp+12], 2

; 4724 :             matchOptions.eVertexProcessing   = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$3[ebp+16], 2

; 4725 :             matchOptions.eResolution         = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$3[ebp+20], 2

; 4726 :             matchOptions.eBackBufferFormat   = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$3[ebp+24], 2

; 4727 :             matchOptions.eBackBufferCount    = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$3[ebp+28], 2

; 4728 :             matchOptions.eMultiSample        = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$3[ebp+32], 2

; 4729 :             matchOptions.eSwapEffect         = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$3[ebp+36], 2

; 4730 :             matchOptions.eDepthFormat        = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$3[ebp+40], 2

; 4731 :             matchOptions.eStencilFormat      = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$3[ebp+44], 2

; 4732 :             matchOptions.ePresentFlags       = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$3[ebp+48], 2

; 4733 :             matchOptions.eRefreshRate        = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$3[ebp+52], 2

; 4734 :             matchOptions.ePresentInterval    = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$3[ebp+56], 2

; 4735 : 
; 4736 :             hr = DXUTFindValidDeviceSettings( &deviceSettings, &deviceSettings, &matchOptions );

	lea	eax, DWORD PTR _matchOptions$3[ebp]
	push	eax
	lea	ecx, DWORD PTR _deviceSettings$4[ebp]
	push	ecx
	lea	edx, DWORD PTR _deviceSettings$4[ebp]
	push	edx
	call	?DXUTFindValidDeviceSettings@@YAJPAUDXUTDeviceSettings@@0PAUDXUTMatchOptions@@@Z ; DXUTFindValidDeviceSettings
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _hr$[ebp], eax

; 4737 :             if( SUCCEEDED(hr) ) 

	cmp	DWORD PTR _hr$[ebp], 0
	jl	SHORT $LN9@DXUTCheckF

; 4738 :             {
; 4739 :                 // Create a Direct3D device using the new device settings.  
; 4740 :                 // If there is an existing device, then it will either reset or recreate the scene.
; 4741 :                 hr = DXUTChangeDevice( &deviceSettings, NULL, false, false );

	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _deviceSettings$4[ebp]
	push	eax
	call	?DXUTChangeDevice@@YAJPAUDXUTDeviceSettings@@PAUIDirect3DDevice9@@_N2@Z ; DXUTChangeDevice
	add	esp, 16					; 00000010H
	mov	DWORD PTR _hr$[ebp], eax

; 4742 : 
; 4743 :                 // If hr == E_ABORT, this means the app rejected the device settings in the ModifySettingsCallback
; 4744 :                 if( hr == E_ABORT )

	cmp	DWORD PTR _hr$[ebp], -2147467260	; 80004004H
	jne	SHORT $LN3@DXUTCheckF

; 4745 :                 {
; 4746 :                     // so nothing changed and keep from attempting to switch adapters next time
; 4747 :                     GetDXUTState().SetAutoChangeAdapter( false );

	push	0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetAutoChangeAdapter@DXUTState@@QAEX_N@Z ; DXUTState::SetAutoChangeAdapter
	jmp	SHORT $LN9@DXUTCheckF
$LN3@DXUTCheckF:

; 4748 :                 }
; 4749 :                 else if( FAILED(hr) )

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN9@DXUTCheckF

; 4750 :                 {
; 4751 :                     DXUTShutdown();

	push	0
	call	?DXUTShutdown@@YAXH@Z			; DXUTShutdown
	add	esp, 4

; 4752 :                     DXUTPause( false, false );

	push	0
	push	0
	call	?DXUTPause@@YAX_N0@Z			; DXUTPause
	add	esp, 8
$LN9@DXUTCheckF:

; 4753 :                     return;
; 4754 :                 }
; 4755 :             }
; 4756 :         }
; 4757 :     }    
; 4758 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN15@DXUTCheckF
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 552				; 00000228H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN15@DXUTCheckF:
	DD	3
	DD	$LN14@DXUTCheckF
$LN14@DXUTCheckF:
	DD	-48					; ffffffd0H
	DD	4
	DD	$LN11@DXUTCheckF
	DD	-128					; ffffff80H
	DD	72					; 00000048H
	DD	$LN12@DXUTCheckF
	DD	-196					; ffffff3cH
	DD	60					; 0000003cH
	DD	$LN13@DXUTCheckF
$LN13@DXUTCheckF:
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	79					; 0000004fH
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	115					; 00000073H
	DB	0
$LN12@DXUTCheckF:
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	118					; 00000076H
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	83					; 00000053H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	115					; 00000073H
	DB	0
$LN11@DXUTCheckF:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	79					; 0000004fH
	DB	114					; 00000072H
	DB	100					; 00000064H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	0
?DXUTCheckForWindowChangingMonitors@@YAXXZ ENDP		; DXUTCheckForWindowChangingMonitors
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTCheckForWindowSizeChange@@YAXXZ
_TEXT	SEGMENT
$T1 = -456						; size = 72
$T2 = -376						; size = 72
_deviceSettings$3 = -104				; size = 72
_rcCurrentClient$ = -24					; size = 16
__$ArrayPad$ = -4					; size = 4
?DXUTCheckForWindowSizeChange@@YAXXZ PROC		; DXUTCheckForWindowSizeChange, COMDAT

; 3383 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 460				; 000001ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-460]
	mov	ecx, 115				; 00000073H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3384 :     // Skip the check for various reasons
; 3385 :     if( GetDXUTState().GetIgnoreSizeChange() || 
; 3386 :         !GetDXUTState().GetDeviceCreated() || 
; 3387 :         !GetDXUTState().GetCurrentDeviceSettings()->pp.Windowed )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetIgnoreSizeChange@DXUTState@@QAE_NXZ	; DXUTState::GetIgnoreSizeChange
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@DXUTCheckF
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetDeviceCreated@DXUTState@@QAE_NXZ	; DXUTState::GetDeviceCreated
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@DXUTCheckF
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetCurrentDeviceSettings@DXUTState@@QAEPAUDXUTDeviceSettings@@XZ ; DXUTState::GetCurrentDeviceSettings
	cmp	DWORD PTR [eax+48], 0
	jne	SHORT $LN4@DXUTCheckF
$LN3@DXUTCheckF:

; 3388 :         return;

	jmp	$LN5@DXUTCheckF
$LN4@DXUTCheckF:

; 3389 : 
; 3390 :     RECT rcCurrentClient;
; 3391 :     GetClientRect( DXUTGetHWND(), &rcCurrentClient );

	mov	esi, esp
	lea	eax, DWORD PTR _rcCurrentClient$[ebp]
	push	eax
	call	?DXUTGetHWND@@YAPAUHWND__@@XZ		; DXUTGetHWND
	push	eax
	call	DWORD PTR __imp__GetClientRect@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3392 :     
; 3393 :     if( (UINT)rcCurrentClient.right != GetDXUTState().GetCurrentDeviceSettings()->pp.BackBufferWidth ||
; 3394 :         (UINT)rcCurrentClient.bottom != GetDXUTState().GetCurrentDeviceSettings()->pp.BackBufferHeight )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetCurrentDeviceSettings@DXUTState@@QAEPAUDXUTDeviceSettings@@XZ ; DXUTState::GetCurrentDeviceSettings
	mov	ecx, DWORD PTR _rcCurrentClient$[ebp+8]
	cmp	ecx, DWORD PTR [eax+16]
	jne	SHORT $LN1@DXUTCheckF
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetCurrentDeviceSettings@DXUTState@@QAEPAUDXUTDeviceSettings@@XZ ; DXUTState::GetCurrentDeviceSettings
	mov	ecx, DWORD PTR _rcCurrentClient$[ebp+12]
	cmp	ecx, DWORD PTR [eax+20]
	je	SHORT $LN5@DXUTCheckF
$LN1@DXUTCheckF:

; 3395 :     {
; 3396 :         // A new window size will require a new backbuffer size
; 3397 :         // size, so the device must be reset and the D3D structures updated accordingly.
; 3398 : 
; 3399 :         // Tell DXUTChangeDevice and D3D to size according to the HWND's client rect
; 3400 :         DXUTDeviceSettings deviceSettings = DXUTGetDeviceSettings();

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?DXUTGetDeviceSettings@@YA?AUDXUTDeviceSettings@@XZ ; DXUTGetDeviceSettings
	add	esp, 4
	mov	ecx, 18					; 00000012H
	mov	esi, eax
	lea	edi, DWORD PTR $T1[ebp]
	rep movsd
	mov	ecx, 18					; 00000012H
	lea	esi, DWORD PTR $T1[ebp]
	lea	edi, DWORD PTR _deviceSettings$3[ebp]
	rep movsd

; 3401 :         deviceSettings.pp.BackBufferWidth  = 0; 

	mov	DWORD PTR _deviceSettings$3[ebp+16], 0

; 3402 :         deviceSettings.pp.BackBufferHeight = 0;

	mov	DWORD PTR _deviceSettings$3[ebp+20], 0

; 3403 :         DXUTChangeDevice( &deviceSettings, NULL, false, false );

	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _deviceSettings$3[ebp]
	push	eax
	call	?DXUTChangeDevice@@YAJPAUDXUTDeviceSettings@@PAUIDirect3DDevice9@@_N2@Z ; DXUTChangeDevice
	add	esp, 16					; 00000010H
$LN5@DXUTCheckF:

; 3404 :     }
; 3405 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@DXUTCheckF
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 460				; 000001ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN10@DXUTCheckF:
	DD	2
	DD	$LN9@DXUTCheckF
$LN9@DXUTCheckF:
	DD	-24					; ffffffe8H
	DD	16					; 00000010H
	DD	$LN7@DXUTCheckF
	DD	-104					; ffffff98H
	DD	72					; 00000048H
	DD	$LN8@DXUTCheckF
$LN8@DXUTCheckF:
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	118					; 00000076H
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	83					; 00000053H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	115					; 00000073H
	DB	0
$LN7@DXUTCheckF:
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	67					; 00000043H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	67					; 00000043H
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
?DXUTCheckForWindowSizeChange@@YAXXZ ENDP		; DXUTCheckForWindowSizeChange
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTDisplayErrorMessage@@YAXJ@Z
_TEXT	SEGMENT
tv64 = -756						; size = 4
_bShowMsgBoxOnError$ = -553				; size = 1
_bFound$ = -541						; size = 1
_nExitCode$ = -532					; size = 4
_strBuffer$ = -520					; size = 512
__$ArrayPad$ = -4					; size = 4
_hr$ = 8						; size = 4
?DXUTDisplayErrorMessage@@YAXJ@Z PROC			; DXUTDisplayErrorMessage, COMDAT

; 4640 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 756				; 000002f4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-756]
	mov	ecx, 189				; 000000bdH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4641 :     TCHAR strBuffer[512];
; 4642 : 
; 4643 :     int nExitCode;
; 4644 :     bool bFound = true; 

	mov	BYTE PTR _bFound$[ebp], 1

; 4645 :     switch( hr )

	mov	eax, DWORD PTR _hr$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	add	ecx, 2147219199				; 7ffbf6ffH
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 8
	ja	$LN4@DXUTDispla
	mov	edx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN23@DXUTDispla[edx*4]
$LN15@DXUTDispla:

; 4646 :     {
; 4647 :         case DXUTERR_NODIRECT3D:             nExitCode = 2; StringCchCopy( strBuffer, 512, "Could not initialize Direct3D. You may want to check that the latest version of DirectX is correctly installed on your system.  Also make sure that this program was compiled with header files that match the installed DirectX DLLs." ); break;

	mov	DWORD PTR _nExitCode$[ebp], 2
	push	OFFSET ??_C@_0OH@FLJPMJOG@Could?5not?5initialize?5Direct3D?4?5Y@
	push	512					; 00000200H
	lea	eax, DWORD PTR _strBuffer$[ebp]
	push	eax
	call	?StringCchCopyA@@YGJPADIPBD@Z		; StringCchCopyA
	jmp	$LN16@DXUTDispla
$LN14@DXUTDispla:

; 4648 :         case DXUTERR_INCORRECTVERSION:       nExitCode = 10; StringCchCopy( strBuffer, 512, "Incorrect version of Direct3D and/or D3DX." ); break;

	mov	DWORD PTR _nExitCode$[ebp], 10		; 0000000aH
	push	OFFSET ??_C@_0CL@IGPDECHP@Incorrect?5version?5of?5Direct3D?5an@
	push	512					; 00000200H
	lea	eax, DWORD PTR _strBuffer$[ebp]
	push	eax
	call	?StringCchCopyA@@YGJPADIPBD@Z		; StringCchCopyA
	jmp	$LN16@DXUTDispla
$LN13@DXUTDispla:

; 4649 :         case DXUTERR_MEDIANOTFOUND:          nExitCode = 4; StringCchCopy( strBuffer, 512, "Could not find required media. Ensure that the DirectX SDK is correctly installed." ); break;

	mov	DWORD PTR _nExitCode$[ebp], 4
	push	OFFSET ??_C@_0FD@EJIIMMAA@Could?5not?5find?5required?5media?4?5E@
	push	512					; 00000200H
	lea	eax, DWORD PTR _strBuffer$[ebp]
	push	eax
	call	?StringCchCopyA@@YGJPADIPBD@Z		; StringCchCopyA
	jmp	$LN16@DXUTDispla
$LN12@DXUTDispla:

; 4650 :         case DXUTERR_NONZEROREFCOUNT:        nExitCode = 5; StringCchCopy( strBuffer, 512, "The D3D device has a non-zero reference count, meaning some objects were not released." ); break;

	mov	DWORD PTR _nExitCode$[ebp], 5
	push	OFFSET ??_C@_0FH@GHOOFLN@The?5D3D?5device?5has?5a?5non?9zero?5re@
	push	512					; 00000200H
	lea	eax, DWORD PTR _strBuffer$[ebp]
	push	eax
	call	?StringCchCopyA@@YGJPADIPBD@Z		; StringCchCopyA
	jmp	$LN16@DXUTDispla
$LN11@DXUTDispla:

; 4651 :         case DXUTERR_CREATINGDEVICE:         nExitCode = 6; StringCchCopy( strBuffer, 512, "Failed creating the Direct3D device." ); break;

	mov	DWORD PTR _nExitCode$[ebp], 6
	push	OFFSET ??_C@_0CF@CPEKMMJN@Failed?5creating?5the?5Direct3D?5dev@
	push	512					; 00000200H
	lea	eax, DWORD PTR _strBuffer$[ebp]
	push	eax
	call	?StringCchCopyA@@YGJPADIPBD@Z		; StringCchCopyA
	jmp	$LN16@DXUTDispla
$LN10@DXUTDispla:

; 4652 :         case DXUTERR_RESETTINGDEVICE:        nExitCode = 7; StringCchCopy( strBuffer, 512, "Failed resetting the Direct3D device." ); break;

	mov	DWORD PTR _nExitCode$[ebp], 7
	push	OFFSET ??_C@_0CG@NKKNAJJN@Failed?5resetting?5the?5Direct3D?5de@
	push	512					; 00000200H
	lea	eax, DWORD PTR _strBuffer$[ebp]
	push	eax
	call	?StringCchCopyA@@YGJPADIPBD@Z		; StringCchCopyA
	jmp	$LN16@DXUTDispla
$LN9@DXUTDispla:

; 4653 :         case DXUTERR_CREATINGDEVICEOBJECTS:  nExitCode = 8; StringCchCopy( strBuffer, 512, "Failed creating Direct3D device objects." ); break;

	mov	DWORD PTR _nExitCode$[ebp], 8
	push	OFFSET ??_C@_0CJ@NGDMEEIH@Failed?5creating?5Direct3D?5device?5@
	push	512					; 00000200H
	lea	eax, DWORD PTR _strBuffer$[ebp]
	push	eax
	call	?StringCchCopyA@@YGJPADIPBD@Z		; StringCchCopyA
	jmp	$LN16@DXUTDispla
$LN8@DXUTDispla:

; 4654 :         case DXUTERR_RESETTINGDEVICEOBJECTS: nExitCode = 9; StringCchCopy( strBuffer, 512, "Failed resetting Direct3D device objects." ); break;

	mov	DWORD PTR _nExitCode$[ebp], 9
	push	OFFSET ??_C@_0CK@JNLAHDJE@Failed?5resetting?5Direct3D?5device@
	push	512					; 00000200H
	lea	eax, DWORD PTR _strBuffer$[ebp]
	push	eax
	call	?StringCchCopyA@@YGJPADIPBD@Z		; StringCchCopyA
	jmp	SHORT $LN16@DXUTDispla
$LN7@DXUTDispla:

; 4655 :         case DXUTERR_NOCOMPATIBLEDEVICES:    
; 4656 :             nExitCode = 3; 

	mov	DWORD PTR _nExitCode$[ebp], 3

; 4657 :             if( GetSystemMetrics(SM_REMOTESESSION) != 0 )

	mov	esi, esp
	push	4096					; 00001000H
	call	DWORD PTR __imp__GetSystemMetrics@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN6@DXUTDispla

; 4658 :                 StringCchCopy( strBuffer, 512, "Direct3D does not work over a remote session." ); 

	push	OFFSET ??_C@_0CO@JDBEDMFP@Direct3D?5does?5not?5work?5over?5a?5re@
	push	512					; 00000200H
	lea	eax, DWORD PTR _strBuffer$[ebp]
	push	eax
	call	?StringCchCopyA@@YGJPADIPBD@Z		; StringCchCopyA

; 4659 :             else

	jmp	SHORT $LN5@DXUTDispla
$LN6@DXUTDispla:

; 4660 :                 StringCchCopy( strBuffer, 512, "Could not find any compatible Direct3D devices." ); 

	push	OFFSET ??_C@_0DA@IAMFMDGP@Could?5not?5find?5any?5compatible?5Di@
	push	512					; 00000200H
	lea	eax, DWORD PTR _strBuffer$[ebp]
	push	eax
	call	?StringCchCopyA@@YGJPADIPBD@Z		; StringCchCopyA
$LN5@DXUTDispla:

; 4661 :             break;

	jmp	SHORT $LN16@DXUTDispla
$LN4@DXUTDispla:

; 4662 :         default: bFound = false; nExitCode = 1;break;

	mov	BYTE PTR _bFound$[ebp], 0
	mov	DWORD PTR _nExitCode$[ebp], 1
$LN16@DXUTDispla:

; 4663 :     }   
; 4664 : 
; 4665 :     GetDXUTState().SetExitCode(nExitCode);

	mov	eax, DWORD PTR _nExitCode$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetExitCode@DXUTState@@QAEXH@Z		; DXUTState::SetExitCode

; 4666 : 
; 4667 :     bool bShowMsgBoxOnError = GetDXUTState().GetShowMsgBoxOnError();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetShowMsgBoxOnError@DXUTState@@QAE_NXZ ; DXUTState::GetShowMsgBoxOnError
	mov	BYTE PTR _bShowMsgBoxOnError$[ebp], al

; 4668 :     if( bFound && bShowMsgBoxOnError )

	movzx	eax, BYTE PTR _bFound$[ebp]
	test	eax, eax
	je	SHORT $LN18@DXUTDispla
	movzx	eax, BYTE PTR _bShowMsgBoxOnError$[ebp]
	test	eax, eax
	je	SHORT $LN18@DXUTDispla

; 4669 :     {
; 4670 :         if( DXUTGetWindowTitle()[0] == 0 )

	call	?DXUTGetWindowTitle@@YAPBDXZ		; DXUTGetWindowTitle
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR [eax+edx]
	test	eax, eax
	jne	SHORT $LN2@DXUTDispla

; 4671 :             MessageBox( DXUTGetHWND(), strBuffer, "DirectX Application", MB_ICONERROR|MB_OK );

	mov	esi, esp
	push	16					; 00000010H
	push	OFFSET ??_C@_0BE@BDKDCPJA@DirectX?5Application?$AA@
	lea	eax, DWORD PTR _strBuffer$[ebp]
	push	eax
	call	?DXUTGetHWND@@YAPAUHWND__@@XZ		; DXUTGetHWND
	push	eax
	call	DWORD PTR __imp__MessageBoxA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4672 :         else

	jmp	SHORT $LN18@DXUTDispla
$LN2@DXUTDispla:

; 4673 :             MessageBox( DXUTGetHWND(), strBuffer, DXUTGetWindowTitle(), MB_ICONERROR|MB_OK );

	mov	esi, esp
	push	16					; 00000010H
	call	?DXUTGetWindowTitle@@YAPBDXZ		; DXUTGetWindowTitle
	push	eax
	lea	eax, DWORD PTR _strBuffer$[ebp]
	push	eax
	call	?DXUTGetHWND@@YAPAUHWND__@@XZ		; DXUTGetHWND
	push	eax
	call	DWORD PTR __imp__MessageBoxA@16
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN18@DXUTDispla:

; 4674 :     }
; 4675 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN22@DXUTDispla
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 756				; 000002f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@DXUTDispla:
	DD	1
	DD	$LN21@DXUTDispla
$LN21@DXUTDispla:
	DD	-520					; fffffdf8H
	DD	512					; 00000200H
	DD	$LN20@DXUTDispla
$LN20@DXUTDispla:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
	npad	2
$LN23@DXUTDispla:
	DD	$LN15@DXUTDispla
	DD	$LN7@DXUTDispla
	DD	$LN13@DXUTDispla
	DD	$LN12@DXUTDispla
	DD	$LN11@DXUTDispla
	DD	$LN10@DXUTDispla
	DD	$LN9@DXUTDispla
	DD	$LN8@DXUTDispla
	DD	$LN14@DXUTDispla
?DXUTDisplayErrorMessage@@YAXJ@Z ENDP			; DXUTDisplayErrorMessage
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTGetCmdParam@@YA_NAAPADPADH@Z
_TEXT	SEGMENT
_strSpace$1 = -8					; size = 4
_strCmdLine$ = 8					; size = 4
_strFlag$ = 12						; size = 4
_nFlagLen$ = 16						; size = 4
?DXUTGetCmdParam@@YA_NAAPADPADH@Z PROC			; DXUTGetCmdParam, COMDAT

; 740  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 741  :     strCmdLine += nFlagLen;

	mov	eax, DWORD PTR _strCmdLine$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _nFlagLen$[ebp]
	mov	edx, DWORD PTR _strCmdLine$[ebp]
	mov	DWORD PTR [edx], ecx

; 742  :     if( *strCmdLine == L':' )

	mov	eax, DWORD PTR _strCmdLine$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 58					; 0000003aH
	jne	SHORT $LN4@DXUTGetCmd

; 743  :     {       
; 744  :         strCmdLine++; // Skip ':'

	mov	eax, DWORD PTR _strCmdLine$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _strCmdLine$[ebp]
	mov	DWORD PTR [edx], ecx

; 745  : 
; 746  :         // Place NULL terminator in strFlag after current token
; 747  :         StringCchCopy( strFlag, 256, strCmdLine );

	mov	eax, DWORD PTR _strCmdLine$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	256					; 00000100H
	mov	edx, DWORD PTR _strFlag$[ebp]
	push	edx
	call	?StringCchCopyA@@YGJPADIPBD@Z		; StringCchCopyA

; 748  :         TCHAR* strSpace = strFlag;

	mov	eax, DWORD PTR _strFlag$[ebp]
	mov	DWORD PTR _strSpace$1[ebp], eax
$LN3@DXUTGetCmd:

; 749  :         while (*strSpace && (*strSpace > L' '))

	mov	eax, DWORD PTR _strSpace$1[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN2@DXUTGetCmd
	mov	eax, DWORD PTR _strSpace$1[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jle	SHORT $LN2@DXUTGetCmd

; 750  :             strSpace++;

	mov	eax, DWORD PTR _strSpace$1[ebp]
	add	eax, 1
	mov	DWORD PTR _strSpace$1[ebp], eax
	jmp	SHORT $LN3@DXUTGetCmd
$LN2@DXUTGetCmd:

; 751  :         *strSpace = 0;

	mov	eax, DWORD PTR _strSpace$1[ebp]
	mov	BYTE PTR [eax], 0

; 752  :     
; 753  :         // Update strCmdLine
; 754  :         strCmdLine += strlen(strFlag);

	mov	eax, DWORD PTR _strFlag$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _strCmdLine$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _strCmdLine$[ebp]
	mov	DWORD PTR [edx], eax

; 755  :         return true;

	mov	al, 1
	jmp	SHORT $LN5@DXUTGetCmd

; 756  :     }
; 757  :     else

	jmp	SHORT $LN5@DXUTGetCmd
$LN4@DXUTGetCmd:

; 758  :     {
; 759  :         strFlag[0] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _strFlag$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 760  :         return false;

	xor	al, al
$LN5@DXUTGetCmd:

; 761  :     }
; 762  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTGetCmdParam@@YA_NAAPADPADH@Z ENDP			; DXUTGetCmdParam
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTHandleTimers@@YAXXZ
_TEXT	SEGMENT
_DXUTTimer$1 = -60					; size = 17
_i$2 = -32						; size = 4
_pTimerList$ = -20					; size = 4
_fElapsedTime$ = -8					; size = 4
?DXUTHandleTimers@@YAXXZ PROC				; DXUTHandleTimers, COMDAT

; 4489 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4490 :     float fElapsedTime = DXUTGetElapsedTime();

	call	?DXUTGetElapsedTime@@YAMXZ		; DXUTGetElapsedTime
	fstp	DWORD PTR _fElapsedTime$[ebp]

; 4491 : 
; 4492 :     CGrowableArray<DXUT_TIMER>* pTimerList = GetDXUTState().GetTimerList();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetTimerList@DXUTState@@QAEPAV?$CGrowableArray@UDXUT_TIMER@@@@XZ ; DXUTState::GetTimerList
	mov	DWORD PTR _pTimerList$[ebp], eax

; 4493 :     if( pTimerList == NULL )

	cmp	DWORD PTR _pTimerList$[ebp], 0
	jne	SHORT $LN6@DXUTHandle

; 4494 :         return;

	jmp	$LN7@DXUTHandle
$LN6@DXUTHandle:

; 4495 : 
; 4496 :     // Walk through the list of timer callbacks
; 4497 :     for( int i=0; i<pTimerList->GetSize(); i++ )

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN5@DXUTHandle
$LN4@DXUTHandle:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN5@DXUTHandle:
	mov	ecx, DWORD PTR _pTimerList$[ebp]
	call	?GetSize@?$CGrowableArray@UDXUT_TIMER@@@@QBEHXZ ; CGrowableArray<DXUT_TIMER>::GetSize
	cmp	DWORD PTR _i$2[ebp], eax
	jge	$LN3@DXUTHandle

; 4498 :     {
; 4499 :         DXUT_TIMER DXUTTimer = pTimerList->GetAt(i);

	mov	eax, DWORD PTR _i$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTimerList$[ebp]
	call	?GetAt@?$CGrowableArray@UDXUT_TIMER@@@@QAEAAUDXUT_TIMER@@H@Z ; CGrowableArray<DXUT_TIMER>::GetAt
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _DXUTTimer$1[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _DXUTTimer$1[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _DXUTTimer$1[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _DXUTTimer$1[ebp+12], edx
	mov	al, BYTE PTR [eax+16]
	mov	BYTE PTR _DXUTTimer$1[ebp+16], al

; 4500 :         if( DXUTTimer.bEnabled )

	movzx	eax, BYTE PTR _DXUTTimer$1[ebp+16]
	test	eax, eax
	je	SHORT $LN2@DXUTHandle

; 4501 :         {
; 4502 :             DXUTTimer.fCountdown -= fElapsedTime;

	movss	xmm0, DWORD PTR _DXUTTimer$1[ebp+12]
	subss	xmm0, DWORD PTR _fElapsedTime$[ebp]
	movss	DWORD PTR _DXUTTimer$1[ebp+12], xmm0

; 4503 : 
; 4504 :             // Call the callback if count down expired
; 4505 :             if( DXUTTimer.fCountdown < 0 )

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _DXUTTimer$1[ebp+12]
	jbe	SHORT $LN1@DXUTHandle

; 4506 :             {
; 4507 :                 DXUTTimer.pCallbackTimer( i, DXUTTimer.pCallbackUserContext );

	mov	esi, esp
	mov	eax, DWORD PTR _DXUTTimer$1[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _i$2[ebp]
	push	ecx
	call	DWORD PTR _DXUTTimer$1[ebp]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4508 :                 DXUTTimer.fCountdown = DXUTTimer.fTimeoutInSecs;

	movss	xmm0, DWORD PTR _DXUTTimer$1[ebp+8]
	movss	DWORD PTR _DXUTTimer$1[ebp+12], xmm0
$LN1@DXUTHandle:

; 4509 :             }
; 4510 :             pTimerList->SetAt(i, DXUTTimer);

	lea	eax, DWORD PTR _DXUTTimer$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pTimerList$[ebp]
	call	?SetAt@?$CGrowableArray@UDXUT_TIMER@@@@QAEJHABUDXUT_TIMER@@@Z ; CGrowableArray<DXUT_TIMER>::SetAt
$LN2@DXUTHandle:

; 4511 :         }
; 4512 :     }

	jmp	$LN4@DXUTHandle
$LN3@DXUTHandle:
$LN7@DXUTHandle:

; 4513 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@DXUTHandle
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN11@DXUTHandle:
	DD	1
	DD	$LN10@DXUTHandle
$LN10@DXUTHandle:
	DD	-60					; ffffffc4H
	DD	17					; 00000011H
	DD	$LN9@DXUTHandle
$LN9@DXUTHandle:
	DB	68					; 00000044H
	DB	88					; 00000058H
	DB	85					; 00000055H
	DB	84					; 00000054H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
?DXUTHandleTimers@@YAXXZ ENDP				; DXUTHandleTimers
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTUpdateStaticFrameStats@@YAXXZ
_TEXT	SEGMENT
tv156 = -596						; size = 4
$T1 = -588						; size = 4
_pstrStaticFrameStats$ = -384				; size = 4
_strMultiSample$ = -372					; size = 100
_strDepthFmt$ = -264					; size = 100
_pPP$ = -156						; size = 4
_strFmt$ = -144						; size = 100
_pDeviceSettingsCombo$ = -36				; size = 4
_pd3dEnum$ = -24					; size = 4
_pDeviceSettings$ = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
?DXUTUpdateStaticFrameStats@@YAXXZ PROC			; DXUTUpdateStaticFrameStats, COMDAT

; 3816 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 596				; 00000254H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-596]
	mov	ecx, 149				; 00000095H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3817 :     DXUTDeviceSettings* pDeviceSettings = GetDXUTState().GetCurrentDeviceSettings();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetCurrentDeviceSettings@DXUTState@@QAEPAUDXUTDeviceSettings@@XZ ; DXUTState::GetCurrentDeviceSettings
	mov	DWORD PTR _pDeviceSettings$[ebp], eax

; 3818 :     if( NULL == pDeviceSettings )

	cmp	DWORD PTR _pDeviceSettings$[ebp], 0
	jne	SHORT $LN12@DXUTUpdate

; 3819 :         return;

	jmp	$LN14@DXUTUpdate
$LN12@DXUTUpdate:

; 3820 :     CD3DEnumeration* pd3dEnum = DXUTPrepareEnumerationObject();

	push	0
	call	?DXUTPrepareEnumerationObject@@YAPAVCD3DEnumeration@@_N@Z ; DXUTPrepareEnumerationObject
	add	esp, 4
	mov	DWORD PTR _pd3dEnum$[ebp], eax

; 3821 :     if( NULL == pd3dEnum )

	cmp	DWORD PTR _pd3dEnum$[ebp], 0
	jne	SHORT $LN11@DXUTUpdate

; 3822 :         return;

	jmp	$LN14@DXUTUpdate
$LN11@DXUTUpdate:

; 3823 : 
; 3824 :     CD3DEnumDeviceSettingsCombo* pDeviceSettingsCombo = pd3dEnum->GetDeviceSettingsCombo( pDeviceSettings->AdapterOrdinal, pDeviceSettings->DeviceType, pDeviceSettings->AdapterFormat, pDeviceSettings->pp.BackBufferFormat, pDeviceSettings->pp.Windowed );

	mov	eax, DWORD PTR _pDeviceSettings$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	mov	edx, DWORD PTR _pDeviceSettings$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _pDeviceSettings$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _pDeviceSettings$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _pDeviceSettings$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pd3dEnum$[ebp]
	call	?GetDeviceSettingsCombo@CD3DEnumeration@@QAEPAUCD3DEnumDeviceSettingsCombo@@IW4_D3DDEVTYPE@@W4_D3DFORMAT@@1H@Z ; CD3DEnumeration::GetDeviceSettingsCombo
	mov	DWORD PTR _pDeviceSettingsCombo$[ebp], eax

; 3825 :     if( NULL == pDeviceSettingsCombo )

	cmp	DWORD PTR _pDeviceSettingsCombo$[ebp], 0
	jne	SHORT $LN10@DXUTUpdate

; 3826 :         return;

	jmp	$LN14@DXUTUpdate
$LN10@DXUTUpdate:

; 3827 : 
; 3828 :     TCHAR strFmt[100];
; 3829 :     D3DPRESENT_PARAMETERS* pPP = &pDeviceSettings->pp;

	mov	eax, DWORD PTR _pDeviceSettings$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _pPP$[ebp], eax

; 3830 : 
; 3831 :     if( pDeviceSettingsCombo->AdapterFormat == pDeviceSettingsCombo->BackBufferFormat )

	mov	eax, DWORD PTR _pDeviceSettingsCombo$[ebp]
	mov	ecx, DWORD PTR _pDeviceSettingsCombo$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN9@DXUTUpdate

; 3832 :     {
; 3833 :         StringCchCopy( strFmt, 100, DXUTD3DFormatToString( pDeviceSettingsCombo->AdapterFormat, false ) );

	push	0
	mov	eax, DWORD PTR _pDeviceSettingsCombo$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	?DXUTD3DFormatToString@@YAPBDW4_D3DFORMAT@@_N@Z ; DXUTD3DFormatToString
	add	esp, 8
	push	eax
	push	100					; 00000064H
	lea	edx, DWORD PTR _strFmt$[ebp]
	push	edx
	call	?StringCchCopyA@@YGJPADIPBD@Z		; StringCchCopyA

; 3834 :     }
; 3835 :     else

	jmp	SHORT $LN8@DXUTUpdate
$LN9@DXUTUpdate:

; 3836 :     {
; 3837 :         StringCchPrintf( strFmt, 100, "backbuf %s, adapter %s", 
; 3838 :             DXUTD3DFormatToString( pDeviceSettingsCombo->BackBufferFormat, false ), 
; 3839 :             DXUTD3DFormatToString( pDeviceSettingsCombo->AdapterFormat, false ) );

	push	0
	mov	eax, DWORD PTR _pDeviceSettingsCombo$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	?DXUTD3DFormatToString@@YAPBDW4_D3DFORMAT@@_N@Z ; DXUTD3DFormatToString
	add	esp, 8
	push	eax
	push	0
	mov	edx, DWORD PTR _pDeviceSettingsCombo$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	?DXUTD3DFormatToString@@YAPBDW4_D3DFORMAT@@_N@Z ; DXUTD3DFormatToString
	add	esp, 8
	push	eax
	push	OFFSET ??_C@_0BH@CNBHLFAO@backbuf?5?$CFs?0?5adapter?5?$CFs?$AA@
	push	100					; 00000064H
	lea	ecx, DWORD PTR _strFmt$[ebp]
	push	ecx
	call	?StringCchPrintfA@@YAJPADIPBDZZ		; StringCchPrintfA
	add	esp, 20					; 00000014H
$LN8@DXUTUpdate:

; 3840 :     }
; 3841 : 
; 3842 :     TCHAR strDepthFmt[100];
; 3843 :     if( pPP->EnableAutoDepthStencil )

	mov	eax, DWORD PTR _pPP$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN7@DXUTUpdate

; 3844 :     {
; 3845 :         StringCchPrintf( strDepthFmt, 100, " (%s)", DXUTD3DFormatToString( pPP->AutoDepthStencilFormat, false ) );

	push	0
	mov	eax, DWORD PTR _pPP$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	call	?DXUTD3DFormatToString@@YAPBDW4_D3DFORMAT@@_N@Z ; DXUTD3DFormatToString
	add	esp, 8
	push	eax
	push	OFFSET ??_C@_05DNDNCJEB@?5?$CI?$CFs?$CJ?$AA@
	push	100					; 00000064H
	lea	edx, DWORD PTR _strDepthFmt$[ebp]
	push	edx
	call	?StringCchPrintfA@@YAJPADIPBDZZ		; StringCchPrintfA
	add	esp, 16					; 00000010H

; 3846 :     }
; 3847 :     else

	jmp	SHORT $LN6@DXUTUpdate
$LN7@DXUTUpdate:

; 3848 :     {
; 3849 :         // No depth buffer
; 3850 :         strDepthFmt[0] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 100			; 00000064H
	jae	SHORT $LN15@DXUTUpdate
	jmp	SHORT $LN16@DXUTUpdate
$LN15@DXUTUpdate:
	call	___report_rangecheckfailure
$LN16@DXUTUpdate:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _strDepthFmt$[ebp+edx], 0
$LN6@DXUTUpdate:

; 3851 :     }
; 3852 : 
; 3853 :     TCHAR strMultiSample[100];
; 3854 :     switch( pPP->MultiSampleType )

	mov	eax, DWORD PTR _pPP$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv156[ebp], ecx
	cmp	DWORD PTR tv156[ebp], 0
	je	SHORT $LN2@DXUTUpdate
	cmp	DWORD PTR tv156[ebp], 1
	je	SHORT $LN3@DXUTUpdate
	jmp	SHORT $LN1@DXUTUpdate
$LN3@DXUTUpdate:

; 3855 :     {
; 3856 :         case D3DMULTISAMPLE_NONMASKABLE: StringCchCopy( strMultiSample, 100, " (Nonmaskable Multisample)" ); break;

	push	OFFSET ??_C@_0BL@OEMADDMG@?5?$CINonmaskable?5Multisample?$CJ?$AA@
	push	100					; 00000064H
	lea	eax, DWORD PTR _strMultiSample$[ebp]
	push	eax
	call	?StringCchCopyA@@YGJPADIPBD@Z		; StringCchCopyA
	jmp	SHORT $LN4@DXUTUpdate
$LN2@DXUTUpdate:

; 3857 :         case D3DMULTISAMPLE_NONE:        StringCchCopy( strMultiSample, 100, "" ); break;

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	100					; 00000064H
	lea	eax, DWORD PTR _strMultiSample$[ebp]
	push	eax
	call	?StringCchCopyA@@YGJPADIPBD@Z		; StringCchCopyA
	jmp	SHORT $LN4@DXUTUpdate
$LN1@DXUTUpdate:

; 3858 :         default:                         StringCchPrintf( strMultiSample, 100, " (%dx Multisample)", pPP->MultiSampleType ); break;

	mov	eax, DWORD PTR _pPP$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	push	OFFSET ??_C@_0BD@FAEAMFBM@?5?$CI?$CFdx?5Multisample?$CJ?$AA@
	push	100					; 00000064H
	lea	edx, DWORD PTR _strMultiSample$[ebp]
	push	edx
	call	?StringCchPrintfA@@YAJPADIPBDZZ		; StringCchPrintfA
	add	esp, 16					; 00000010H
$LN4@DXUTUpdate:

; 3859 :     }
; 3860 : 
; 3861 :     TCHAR* pstrStaticFrameStats = GetDXUTState().GetStaticFrameStats();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetStaticFrameStats@DXUTState@@QAEPADXZ ; DXUTState::GetStaticFrameStats
	mov	DWORD PTR _pstrStaticFrameStats$[ebp], eax

; 3862 :     StringCchPrintf( pstrStaticFrameStats, 256, "%%.02f fps (%dx%d), %s%s%s", 
; 3863 :                 pPP->BackBufferWidth, pPP->BackBufferHeight,
; 3864 :                 strFmt, strDepthFmt, strMultiSample );

	lea	eax, DWORD PTR _strMultiSample$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strDepthFmt$[ebp]
	push	ecx
	lea	edx, DWORD PTR _strFmt$[ebp]
	push	edx
	mov	eax, DWORD PTR _pPP$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _pPP$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	OFFSET ??_C@_0BL@ELHDMKOG@?$CF?$CF?402f?5fps?5?$CI?$CFdx?$CFd?$CJ?0?5?$CFs?$CFs?$CFs?$AA@
	push	256					; 00000100H
	mov	ecx, DWORD PTR _pstrStaticFrameStats$[ebp]
	push	ecx
	call	?StringCchPrintfA@@YAJPADIPBDZZ		; StringCchPrintfA
	add	esp, 32					; 00000020H
$LN14@DXUTUpdate:

; 3865 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN21@DXUTUpdate
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 596				; 00000254H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@DXUTUpdate:
	DD	3
	DD	$LN20@DXUTUpdate
$LN20@DXUTUpdate:
	DD	-144					; ffffff70H
	DD	100					; 00000064H
	DD	$LN17@DXUTUpdate
	DD	-264					; fffffef8H
	DD	100					; 00000064H
	DD	$LN18@DXUTUpdate
	DD	-372					; fffffe8cH
	DD	100					; 00000064H
	DD	$LN19@DXUTUpdate
$LN19@DXUTUpdate:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	77					; 0000004dH
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	83					; 00000053H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
$LN18@DXUTUpdate:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	68					; 00000044H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	70					; 00000046H
	DB	109					; 0000006dH
	DB	116					; 00000074H
	DB	0
$LN17@DXUTUpdate:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	70					; 00000046H
	DB	109					; 0000006dH
	DB	116					; 00000074H
	DB	0
?DXUTUpdateStaticFrameStats@@YAXXZ ENDP			; DXUTUpdateStaticFrameStats
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTUpdateDeviceStats@@YAXW4_D3DDEVTYPE@@KPAU_D3DADAPTER_IDENTIFIER9@@@Z
_TEXT	SEGMENT
$T1 = -784						; size = 4
_szDescription$2 = -580					; size = 512
_cchDesc$3 = -60					; size = 4
_pDeviceSettingsCombo$4 = -48				; size = 4
_pd3dEnum$5 = -36					; size = 4
_pDeviceSettings$6 = -24				; size = 4
_pstrDeviceStats$ = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
_DeviceType$ = 8					; size = 4
_BehaviorFlags$ = 12					; size = 4
_pAdapterIdentifier$ = 16				; size = 4
?DXUTUpdateDeviceStats@@YAXW4_D3DDEVTYPE@@KPAU_D3DADAPTER_IDENTIFIER9@@@Z PROC ; DXUTUpdateDeviceStats, COMDAT

; 3721 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 788				; 00000314H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-788]
	mov	ecx, 197				; 000000c5H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3722 :     // Store device description
; 3723 :     TCHAR* pstrDeviceStats = GetDXUTState().GetDeviceStats();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetDeviceStats@DXUTState@@QAEPADXZ	; DXUTState::GetDeviceStats
	mov	DWORD PTR _pstrDeviceStats$[ebp], eax

; 3724 :     if( DeviceType == D3DDEVTYPE_REF )

	cmp	DWORD PTR _DeviceType$[ebp], 2
	jne	SHORT $LN21@DXUTUpdate

; 3725 :         StringCchCopy( pstrDeviceStats, 256, "REF" );

	push	OFFSET ??_C@_03GPMNEAGC@REF?$AA@
	push	256					; 00000100H
	mov	eax, DWORD PTR _pstrDeviceStats$[ebp]
	push	eax
	call	?StringCchCopyA@@YGJPADIPBD@Z		; StringCchCopyA
	jmp	SHORT $LN20@DXUTUpdate
$LN21@DXUTUpdate:

; 3726 :     else if( DeviceType == D3DDEVTYPE_HAL )

	cmp	DWORD PTR _DeviceType$[ebp], 1
	jne	SHORT $LN19@DXUTUpdate

; 3727 :         StringCchCopy( pstrDeviceStats, 256, "HA" );

	push	OFFSET ??_C@_02JHFFIENB@HA?$AA@
	push	256					; 00000100H
	mov	eax, DWORD PTR _pstrDeviceStats$[ebp]
	push	eax
	call	?StringCchCopyA@@YGJPADIPBD@Z		; StringCchCopyA
	jmp	SHORT $LN20@DXUTUpdate
$LN19@DXUTUpdate:

; 3728 :     else if( DeviceType == D3DDEVTYPE_SW )

	cmp	DWORD PTR _DeviceType$[ebp], 3
	jne	SHORT $LN20@DXUTUpdate

; 3729 :         StringCchCopy( pstrDeviceStats, 256, "SW" );

	push	OFFSET ??_C@_02JLLOHNJH@SW?$AA@
	push	256					; 00000100H
	mov	eax, DWORD PTR _pstrDeviceStats$[ebp]
	push	eax
	call	?StringCchCopyA@@YGJPADIPBD@Z		; StringCchCopyA
$LN20@DXUTUpdate:

; 3730 : 
; 3731 :     if( BehaviorFlags & D3DCREATE_HARDWARE_VERTEXPROCESSING &&
; 3732 :         BehaviorFlags & D3DCREATE_PUREDEVICE )

	mov	eax, DWORD PTR _BehaviorFlags$[ebp]
	and	eax, 64					; 00000040H
	je	SHORT $LN16@DXUTUpdate
	mov	eax, DWORD PTR _BehaviorFlags$[ebp]
	and	eax, 16					; 00000010H
	je	SHORT $LN16@DXUTUpdate

; 3733 :     {
; 3734 :         if( DeviceType == D3DDEVTYPE_HAL )

	cmp	DWORD PTR _DeviceType$[ebp], 1
	jne	SHORT $LN15@DXUTUpdate

; 3735 :             StringCchCat( pstrDeviceStats, 256, " (pure hw vp)" );

	push	OFFSET ??_C@_0O@INAAPCCB@?5?$CIpure?5hw?5vp?$CJ?$AA@
	push	256					; 00000100H
	mov	eax, DWORD PTR _pstrDeviceStats$[ebp]
	push	eax
	call	?StringCchCatA@@YGJPADIPBD@Z		; StringCchCatA

; 3736 :         else

	jmp	SHORT $LN14@DXUTUpdate
$LN15@DXUTUpdate:

; 3737 :             StringCchCat( pstrDeviceStats, 256, " (simulated pure hw vp)" );

	push	OFFSET ??_C@_0BI@KADHBMJM@?5?$CIsimulated?5pure?5hw?5vp?$CJ?$AA@
	push	256					; 00000100H
	mov	eax, DWORD PTR _pstrDeviceStats$[ebp]
	push	eax
	call	?StringCchCatA@@YGJPADIPBD@Z		; StringCchCatA
$LN14@DXUTUpdate:
	jmp	$LN13@DXUTUpdate
$LN16@DXUTUpdate:

; 3738 :     }
; 3739 :     else if( BehaviorFlags & D3DCREATE_HARDWARE_VERTEXPROCESSING )

	mov	eax, DWORD PTR _BehaviorFlags$[ebp]
	and	eax, 64					; 00000040H
	je	SHORT $LN12@DXUTUpdate

; 3740 :     {
; 3741 :         if( DeviceType == D3DDEVTYPE_HAL )

	cmp	DWORD PTR _DeviceType$[ebp], 1
	jne	SHORT $LN11@DXUTUpdate

; 3742 :             StringCchCat( pstrDeviceStats, 256, " (hw vp)" );

	push	OFFSET ??_C@_08IAMIAIBF@?5?$CIhw?5vp?$CJ?$AA@
	push	256					; 00000100H
	mov	eax, DWORD PTR _pstrDeviceStats$[ebp]
	push	eax
	call	?StringCchCatA@@YGJPADIPBD@Z		; StringCchCatA

; 3743 :         else

	jmp	SHORT $LN10@DXUTUpdate
$LN11@DXUTUpdate:

; 3744 :             StringCchCat( pstrDeviceStats, 256, " (simulated hw vp)" );

	push	OFFSET ??_C@_0BD@NNKCKNKM@?5?$CIsimulated?5hw?5vp?$CJ?$AA@
	push	256					; 00000100H
	mov	eax, DWORD PTR _pstrDeviceStats$[ebp]
	push	eax
	call	?StringCchCatA@@YGJPADIPBD@Z		; StringCchCatA
$LN10@DXUTUpdate:
	jmp	SHORT $LN13@DXUTUpdate
$LN12@DXUTUpdate:

; 3745 :     }
; 3746 :     else if( BehaviorFlags & D3DCREATE_MIXED_VERTEXPROCESSING )

	mov	eax, DWORD PTR _BehaviorFlags$[ebp]
	and	eax, 128				; 00000080H
	je	SHORT $LN8@DXUTUpdate

; 3747 :     {
; 3748 :         if( DeviceType == D3DDEVTYPE_HAL )

	cmp	DWORD PTR _DeviceType$[ebp], 1
	jne	SHORT $LN7@DXUTUpdate

; 3749 :             StringCchCat( pstrDeviceStats, 256, " (mixed vp)" );

	push	OFFSET ??_C@_0M@NOOBLHBB@?5?$CImixed?5vp?$CJ?$AA@
	push	256					; 00000100H
	mov	eax, DWORD PTR _pstrDeviceStats$[ebp]
	push	eax
	call	?StringCchCatA@@YGJPADIPBD@Z		; StringCchCatA

; 3750 :         else

	jmp	SHORT $LN6@DXUTUpdate
$LN7@DXUTUpdate:

; 3751 :             StringCchCat( pstrDeviceStats, 256, " (simulated mixed vp)" );

	push	OFFSET ??_C@_0BG@GKHJLCDJ@?5?$CIsimulated?5mixed?5vp?$CJ?$AA@
	push	256					; 00000100H
	mov	eax, DWORD PTR _pstrDeviceStats$[ebp]
	push	eax
	call	?StringCchCatA@@YGJPADIPBD@Z		; StringCchCatA
$LN6@DXUTUpdate:
	jmp	SHORT $LN13@DXUTUpdate
$LN8@DXUTUpdate:

; 3752 :     }
; 3753 :     else if( BehaviorFlags & D3DCREATE_SOFTWARE_VERTEXPROCESSING )

	mov	eax, DWORD PTR _BehaviorFlags$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN13@DXUTUpdate

; 3754 :     {
; 3755 :         StringCchCat( pstrDeviceStats, 256, " (sw vp)" );

	push	OFFSET ??_C@_08OFBBMACB@?5?$CIsw?5vp?$CJ?$AA@
	push	256					; 00000100H
	mov	eax, DWORD PTR _pstrDeviceStats$[ebp]
	push	eax
	call	?StringCchCatA@@YGJPADIPBD@Z		; StringCchCatA
$LN13@DXUTUpdate:

; 3756 :     }
; 3757 : 
; 3758 :     if( DeviceType == D3DDEVTYPE_HAL )

	cmp	DWORD PTR _DeviceType$[ebp], 1
	jne	$LN23@DXUTUpdate

; 3759 :     {
; 3760 :         // Be sure not to overflow m_strDeviceStats when appending the adapter 
; 3761 :         // description, since it can be long.  
; 3762 :         StringCchCat( pstrDeviceStats, 256, ": " );

	push	OFFSET ??_C@_02LMMGGCAJ@?3?5?$AA@
	push	256					; 00000100H
	mov	eax, DWORD PTR _pstrDeviceStats$[ebp]
	push	eax
	call	?StringCchCatA@@YGJPADIPBD@Z		; StringCchCatA

; 3763 : 
; 3764 :         // Try to get a unique description from the CD3DEnumDeviceSettingsCombo
; 3765 :         DXUTDeviceSettings* pDeviceSettings = GetDXUTState().GetCurrentDeviceSettings();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetCurrentDeviceSettings@DXUTState@@QAEPAUDXUTDeviceSettings@@XZ ; DXUTState::GetCurrentDeviceSettings
	mov	DWORD PTR _pDeviceSettings$6[ebp], eax

; 3766 :         CD3DEnumeration* pd3dEnum = DXUTPrepareEnumerationObject();

	push	0
	call	?DXUTPrepareEnumerationObject@@YAPAVCD3DEnumeration@@_N@Z ; DXUTPrepareEnumerationObject
	add	esp, 4
	mov	DWORD PTR _pd3dEnum$5[ebp], eax

; 3767 :         CD3DEnumDeviceSettingsCombo* pDeviceSettingsCombo = pd3dEnum->GetDeviceSettingsCombo( pDeviceSettings->AdapterOrdinal, pDeviceSettings->DeviceType, pDeviceSettings->AdapterFormat, pDeviceSettings->pp.BackBufferFormat, pDeviceSettings->pp.Windowed );

	mov	eax, DWORD PTR _pDeviceSettings$6[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	mov	edx, DWORD PTR _pDeviceSettings$6[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _pDeviceSettings$6[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _pDeviceSettings$6[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _pDeviceSettings$6[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pd3dEnum$5[ebp]
	call	?GetDeviceSettingsCombo@CD3DEnumeration@@QAEPAUCD3DEnumDeviceSettingsCombo@@IW4_D3DDEVTYPE@@W4_D3DFORMAT@@1H@Z ; CD3DEnumeration::GetDeviceSettingsCombo
	mov	DWORD PTR _pDeviceSettingsCombo$4[ebp], eax

; 3768 :         if( pDeviceSettingsCombo )

	cmp	DWORD PTR _pDeviceSettingsCombo$4[ebp], 0
	je	SHORT $LN2@DXUTUpdate

; 3769 :         {
; 3770 :             StringCchCat( pstrDeviceStats, 256, pDeviceSettingsCombo->pAdapterInfo->szUniqueDescription );

	mov	eax, DWORD PTR _pDeviceSettingsCombo$4[ebp]
	mov	ecx, DWORD PTR [eax+80]
	add	ecx, 1104				; 00000450H
	push	ecx
	push	256					; 00000100H
	mov	edx, DWORD PTR _pstrDeviceStats$[ebp]
	push	edx
	call	?StringCchCatA@@YGJPADIPBD@Z		; StringCchCatA

; 3771 :         }
; 3772 :         else

	jmp	SHORT $LN23@DXUTUpdate
$LN2@DXUTUpdate:

; 3773 :         {
; 3774 :             const int cchDesc = sizeof(pAdapterIdentifier->Description);

	mov	DWORD PTR _cchDesc$3[ebp], 512		; 00000200H

; 3775 :             TCHAR szDescription[cchDesc];
; 3776 :             strcpy(szDescription, pAdapterIdentifier->Description);

	mov	eax, DWORD PTR _pAdapterIdentifier$[ebp]
	add	eax, 512				; 00000200H
	push	eax
	lea	ecx, DWORD PTR _szDescription$2[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 3777 :             szDescription[cchDesc-1] = 0;

	mov	eax, 1
	imul	ecx, eax, 511
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 512			; 00000200H
	jae	SHORT $LN24@DXUTUpdate
	jmp	SHORT $LN25@DXUTUpdate
$LN24@DXUTUpdate:
	call	___report_rangecheckfailure
$LN25@DXUTUpdate:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _szDescription$2[ebp+edx], 0

; 3778 :             StringCchCat( pstrDeviceStats, 256, szDescription );

	lea	eax, DWORD PTR _szDescription$2[ebp]
	push	eax
	push	256					; 00000100H
	mov	ecx, DWORD PTR _pstrDeviceStats$[ebp]
	push	ecx
	call	?StringCchCatA@@YGJPADIPBD@Z		; StringCchCatA
$LN23@DXUTUpdate:

; 3779 :         }
; 3780 :     }
; 3781 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN28@DXUTUpdate
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 788				; 00000314H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@DXUTUpdate:
	DD	1
	DD	$LN27@DXUTUpdate
$LN27@DXUTUpdate:
	DD	-580					; fffffdbcH
	DD	512					; 00000200H
	DD	$LN26@DXUTUpdate
$LN26@DXUTUpdate:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	68					; 00000044H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	99					; 00000063H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
?DXUTUpdateDeviceStats@@YAXW4_D3DDEVTYPE@@KPAU_D3DADAPTER_IDENTIFIER9@@@Z ENDP ; DXUTUpdateDeviceStats
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTUpdateFrameStats@@YAXXZ
_TEXT	SEGMENT
tv151 = -276						; size = 4
_pstrStaticFrameStats$1 = -76				; size = 4
_pstrFrameStats$2 = -64					; size = 4
_fFPS$3 = -52						; size = 4
_fTime$ = -40						; size = 8
_dwFrames$ = -24					; size = 4
_fLastTime$ = -12					; size = 8
?DXUTUpdateFrameStats@@YAXXZ PROC			; DXUTUpdateFrameStats, COMDAT

; 3788 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-276]
	mov	ecx, 69					; 00000045H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3789 :     // Keep track of the frame count
; 3790 :     double fLastTime = GetDXUTState().GetLastStatsUpdateTime();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetLastStatsUpdateTime@DXUTState@@QAENXZ ; DXUTState::GetLastStatsUpdateTime
	fstp	QWORD PTR _fLastTime$[ebp]

; 3791 :     DWORD dwFrames  = GetDXUTState().GetLastStatsUpdateFrames();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetLastStatsUpdateFrames@DXUTState@@QAEKXZ ; DXUTState::GetLastStatsUpdateFrames
	mov	DWORD PTR _dwFrames$[ebp], eax

; 3792 :     double fTime = DXUTGetGlobalTimer()->GetAbsoluteTime();

	call	?DXUTGetGlobalTimer@@YAPAVCDXUTTimer@@XZ ; DXUTGetGlobalTimer
	mov	ecx, eax
	call	?GetAbsoluteTime@CDXUTTimer@@QAENXZ	; CDXUTTimer::GetAbsoluteTime
	fstp	QWORD PTR _fTime$[ebp]

; 3793 :     dwFrames++;

	mov	eax, DWORD PTR _dwFrames$[ebp]
	add	eax, 1
	mov	DWORD PTR _dwFrames$[ebp], eax

; 3794 :     GetDXUTState().SetLastStatsUpdateFrames( dwFrames );

	mov	eax, DWORD PTR _dwFrames$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetLastStatsUpdateFrames@DXUTState@@QAEXK@Z ; DXUTState::SetLastStatsUpdateFrames

; 3795 : 
; 3796 :     // Update the scene stats once per second
; 3797 :     if( fTime - fLastTime > 1.0f )

	movsd	xmm0, QWORD PTR _fTime$[ebp]
	subsd	xmm0, QWORD PTR _fLastTime$[ebp]
	comisd	xmm0, QWORD PTR __real@3ff0000000000000
	jbe	$LN1@DXUTUpdate

; 3798 :     {
; 3799 :         float fFPS = (float) (dwFrames / (fTime - fLastTime));

	mov	eax, DWORD PTR _dwFrames$[ebp]
	mov	DWORD PTR tv151[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv151[ebp]
	mov	ecx, DWORD PTR tv151[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	xmm1, QWORD PTR _fTime$[ebp]
	subsd	xmm1, QWORD PTR _fLastTime$[ebp]
	divsd	xmm0, xmm1
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _fFPS$3[ebp], xmm0

; 3800 :         GetDXUTState().SetFPS( fFPS );

	push	ecx
	movss	xmm0, DWORD PTR _fFPS$3[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetFPS@DXUTState@@QAEXM@Z		; DXUTState::SetFPS

; 3801 :         GetDXUTState().SetLastStatsUpdateTime( fTime );

	sub	esp, 8
	movsd	xmm0, QWORD PTR _fTime$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetLastStatsUpdateTime@DXUTState@@QAEXN@Z ; DXUTState::SetLastStatsUpdateTime

; 3802 :         GetDXUTState().SetLastStatsUpdateFrames( 0 );

	push	0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetLastStatsUpdateFrames@DXUTState@@QAEXK@Z ; DXUTState::SetLastStatsUpdateFrames

; 3803 : 
; 3804 :         TCHAR* pstrFrameStats = GetDXUTState().GetFrameStats();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetFrameStats@DXUTState@@QAEPADXZ	; DXUTState::GetFrameStats
	mov	DWORD PTR _pstrFrameStats$2[ebp], eax

; 3805 :         TCHAR* pstrStaticFrameStats = GetDXUTState().GetStaticFrameStats();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetStaticFrameStats@DXUTState@@QAEPADXZ ; DXUTState::GetStaticFrameStats
	mov	DWORD PTR _pstrStaticFrameStats$1[ebp], eax

; 3806 :         StringCchPrintf( pstrFrameStats, 256, pstrStaticFrameStats, fFPS );

	cvtss2sd xmm0, DWORD PTR _fFPS$3[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _pstrStaticFrameStats$1[ebp]
	push	eax
	push	256					; 00000100H
	mov	ecx, DWORD PTR _pstrFrameStats$2[ebp]
	push	ecx
	call	?StringCchPrintfA@@YAJPADIPBDZZ		; StringCchPrintfA
	add	esp, 20					; 00000014H

; 3807 :         pstrFrameStats[255] = 0;

	mov	eax, 1
	imul	ecx, eax, 255
	mov	edx, DWORD PTR _pstrFrameStats$2[ebp]
	mov	BYTE PTR [edx+ecx], 0
$LN1@DXUTUpdate:

; 3808 :     }
; 3809 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTUpdateFrameStats@@YAXXZ ENDP			; DXUTUpdateFrameStats
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTCreate3DEnvironment@@YAJPAUIDirect3DDevice9@@@Z
_TEXT	SEGMENT
tv250 = -304						; size = 4
tv206 = -304						; size = 4
tv172 = -304						; size = 4
_pCallbackDeviceReset$ = -104				; size = 4
_pCallbackDeviceCreated$ = -92				; size = 4
_pbackBufferSurfaceDesc$ = -80				; size = 4
_pAdapterInfo$ = -68					; size = 4
_pd3dEnum$ = -56					; size = 4
_pD3D$1 = -44						; size = 4
_pNewDeviceSettings$ = -32				; size = 4
_pd3dDevice$ = -20					; size = 4
_hr$ = -8						; size = 4
_pd3dDeviceFromApp$ = 8					; size = 4
?DXUTCreate3DEnvironment@@YAJPAUIDirect3DDevice9@@@Z PROC ; DXUTCreate3DEnvironment, COMDAT

; 3176 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 304				; 00000130H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-304]
	mov	ecx, 76					; 0000004cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3177 :     HRESULT hr = S_OK;

	mov	DWORD PTR _hr$[ebp], 0

; 3178 : 
; 3179 :     IDirect3DDevice9* pd3dDevice = NULL;

	mov	DWORD PTR _pd3dDevice$[ebp], 0

; 3180 :     DXUTDeviceSettings* pNewDeviceSettings = GetDXUTState().GetCurrentDeviceSettings();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetCurrentDeviceSettings@DXUTState@@QAEPAUDXUTDeviceSettings@@XZ ; DXUTState::GetCurrentDeviceSettings
	mov	DWORD PTR _pNewDeviceSettings$[ebp], eax

; 3181 : 
; 3182 :     // Only create a Direct3D device if one hasn't been supplied by the app
; 3183 :     if( pd3dDeviceFromApp == NULL )

	cmp	DWORD PTR _pd3dDeviceFromApp$[ebp], 0
	jne	SHORT $LN14@DXUTCreate

; 3184 :     {
; 3185 :         // Try to create the device with the chosen settings
; 3186 :         IDirect3D9* pD3D = DXUTGetD3DObject();

	call	?DXUTGetD3DObject@@YAPAUIDirect3D9@@XZ	; DXUTGetD3DObject
	mov	DWORD PTR _pD3D$1[ebp], eax

; 3187 :         hr = pD3D->CreateDevice( pNewDeviceSettings->AdapterOrdinal, pNewDeviceSettings->DeviceType, 
; 3188 :                                 DXUTGetHWNDFocus(), pNewDeviceSettings->BehaviorFlags,
; 3189 :                                 &pNewDeviceSettings->pp, &pd3dDevice );

	mov	esi, esp
	lea	eax, DWORD PTR _pd3dDevice$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pNewDeviceSettings$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	mov	edx, DWORD PTR _pNewDeviceSettings$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	?DXUTGetHWNDFocus@@YAPAUHWND__@@XZ	; DXUTGetHWNDFocus
	push	eax
	mov	ecx, DWORD PTR _pNewDeviceSettings$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _pNewDeviceSettings$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _pD3D$1[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pD3D$1[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+64]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 3190 :         if( FAILED(hr) )

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN13@DXUTCreate

; 3191 :         {
; 3192 :             DXUT_ERR( "CreateDevice", hr );

	push	0
	push	OFFSET ??_C@_0N@JIIFLKLP@CreateDevice?$AA@
	mov	eax, DWORD PTR _hr$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??DXUTCreate3DEnvironment@@YAJPAUIDirect3DDevice9@@@Z@4JA
	add	ecx, 16					; 00000010H
	push	ecx
	push	OFFSET ??_C@_0CL@KBAHBIDF@z?3?2sampsrc?202xu1?2saco?2d3d9?2commo@
	call	?DXUTTrace@@YGJPBDKJ0_N@Z		; DXUTTrace

; 3193 :             return DXUTERR_CREATINGDEVICE;

	mov	eax, -2147219195			; 80040905H
	jmp	$LN15@DXUTCreate
$LN13@DXUTCreate:

; 3194 :         }
; 3195 :     }
; 3196 :     else

	jmp	SHORT $LN12@DXUTCreate
$LN14@DXUTCreate:

; 3197 :     {
; 3198 :         pd3dDeviceFromApp->AddRef();

	mov	eax, DWORD PTR _pd3dDeviceFromApp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR _pd3dDeviceFromApp$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3199 :         pd3dDevice = pd3dDeviceFromApp;

	mov	eax, DWORD PTR _pd3dDeviceFromApp$[ebp]
	mov	DWORD PTR _pd3dDevice$[ebp], eax
$LN12@DXUTCreate:

; 3200 :     }
; 3201 : 
; 3202 :     GetDXUTState().SetD3DDevice( pd3dDevice );

	mov	eax, DWORD PTR _pd3dDevice$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetD3DDevice@DXUTState@@QAEXPAUIDirect3DDevice9@@@Z ; DXUTState::SetD3DDevice

; 3203 : 
; 3204 :     // If switching to REF, set the exit code to 11.  If switching to HAL and exit code was 11, then set it back to 0.
; 3205 :     if( pNewDeviceSettings->DeviceType == D3DDEVTYPE_REF && GetDXUTState().GetExitCode() == 0 )

	mov	eax, DWORD PTR _pNewDeviceSettings$[ebp]
	cmp	DWORD PTR [eax+4], 2
	jne	SHORT $LN11@DXUTCreate
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetExitCode@DXUTState@@QAEHXZ		; DXUTState::GetExitCode
	test	eax, eax
	jne	SHORT $LN11@DXUTCreate

; 3206 :         GetDXUTState().SetExitCode(11);

	push	11					; 0000000bH
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetExitCode@DXUTState@@QAEXH@Z		; DXUTState::SetExitCode
	jmp	SHORT $LN10@DXUTCreate
$LN11@DXUTCreate:

; 3207 :     else if( pNewDeviceSettings->DeviceType == D3DDEVTYPE_HAL && GetDXUTState().GetExitCode() == 11 )

	mov	eax, DWORD PTR _pNewDeviceSettings$[ebp]
	cmp	DWORD PTR [eax+4], 1
	jne	SHORT $LN10@DXUTCreate
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetExitCode@DXUTState@@QAEHXZ		; DXUTState::GetExitCode
	cmp	eax, 11					; 0000000bH
	jne	SHORT $LN10@DXUTCreate

; 3208 :         GetDXUTState().SetExitCode(0);

	push	0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetExitCode@DXUTState@@QAEXH@Z		; DXUTState::SetExitCode
$LN10@DXUTCreate:

; 3209 : 
; 3210 :     // Update back buffer desc before calling app's device callbacks
; 3211 :     DXUTUpdateBackBufferDesc();

	call	?DXUTUpdateBackBufferDesc@@YAXXZ	; DXUTUpdateBackBufferDesc

; 3212 : 
; 3213 :     // Update the device stats text
; 3214 :     CD3DEnumeration* pd3dEnum = DXUTPrepareEnumerationObject();

	push	0
	call	?DXUTPrepareEnumerationObject@@YAPAVCD3DEnumeration@@_N@Z ; DXUTPrepareEnumerationObject
	add	esp, 4
	mov	DWORD PTR _pd3dEnum$[ebp], eax

; 3215 :     CD3DEnumAdapterInfo* pAdapterInfo = pd3dEnum->GetAdapterInfo( pNewDeviceSettings->AdapterOrdinal );

	mov	eax, DWORD PTR _pNewDeviceSettings$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _pd3dEnum$[ebp]
	call	?GetAdapterInfo@CD3DEnumeration@@QAEPAVCD3DEnumAdapterInfo@@I@Z ; CD3DEnumeration::GetAdapterInfo
	mov	DWORD PTR _pAdapterInfo$[ebp], eax

; 3216 :     DXUTUpdateDeviceStats( pNewDeviceSettings->DeviceType, 
; 3217 :                         pNewDeviceSettings->BehaviorFlags, 
; 3218 :                         &pAdapterInfo->AdapterIdentifier );

	mov	eax, DWORD PTR _pAdapterInfo$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _pNewDeviceSettings$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _pNewDeviceSettings$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?DXUTUpdateDeviceStats@@YAXW4_D3DDEVTYPE@@KPAU_D3DADAPTER_IDENTIFIER9@@@Z ; DXUTUpdateDeviceStats
	add	esp, 12					; 0000000cH

; 3219 : 
; 3220 :     // Call the resource cache created function
; 3221 :     hr = DXUTGetGlobalResourceCache().OnCreateDevice( pd3dDevice );

	mov	eax, DWORD PTR _pd3dDevice$[ebp]
	push	eax
	call	?DXUTGetGlobalResourceCache@@YAAAVCDXUTResourceCache@@XZ ; DXUTGetGlobalResourceCache
	mov	ecx, eax
	call	?OnCreateDevice@CDXUTResourceCache@@QAEJPAUIDirect3DDevice9@@@Z ; CDXUTResourceCache::OnCreateDevice
	mov	DWORD PTR _hr$[ebp], eax

; 3222 :     if( FAILED(hr) )

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN8@DXUTCreate

; 3223 :         return DXUT_ERR( "OnCreateDevice", ( hr == DXUTERR_MEDIANOTFOUND ) ? DXUTERR_MEDIANOTFOUND : DXUTERR_CREATINGDEVICEOBJECTS );

	cmp	DWORD PTR _hr$[ebp], -2147219197	; 80040903H
	jne	SHORT $LN17@DXUTCreate
	mov	DWORD PTR tv172[ebp], -2147219197	; 80040903H
	jmp	SHORT $LN18@DXUTCreate
$LN17@DXUTCreate:
	mov	DWORD PTR tv172[ebp], -2147219193	; 80040907H
$LN18@DXUTCreate:
	push	0
	push	OFFSET ??_C@_0P@JJBHJNJD@OnCreateDevice?$AA@
	mov	eax, DWORD PTR tv172[ebp]
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??DXUTCreate3DEnvironment@@YAJPAUIDirect3DDevice9@@@Z@4JA
	add	ecx, 47					; 0000002fH
	push	ecx
	push	OFFSET ??_C@_0CL@KBAHBIDF@z?3?2sampsrc?202xu1?2saco?2d3d9?2commo@
	call	?DXUTTrace@@YGJPBDKJ0_N@Z		; DXUTTrace
	jmp	$LN15@DXUTCreate
$LN8@DXUTCreate:

; 3224 : 
; 3225 :     // Call the app's device created callback if non-NULL
; 3226 :     const D3DSURFACE_DESC* pbackBufferSurfaceDesc = DXUTGetBackBufferSurfaceDesc();

	call	?DXUTGetBackBufferSurfaceDesc@@YAPBU_D3DSURFACE_DESC@@XZ ; DXUTGetBackBufferSurfaceDesc
	mov	DWORD PTR _pbackBufferSurfaceDesc$[ebp], eax

; 3227 :     GetDXUTState().SetInsideDeviceCallback( true );

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetInsideDeviceCallback@DXUTState@@QAEX_N@Z ; DXUTState::SetInsideDeviceCallback

; 3228 :     LPDXUTCALLBACKDEVICECREATED pCallbackDeviceCreated = GetDXUTState().GetDeviceCreatedFunc();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetDeviceCreatedFunc@DXUTState@@QAEP6GJPAUIDirect3DDevice9@@PBU_D3DSURFACE_DESC@@PAX@ZXZ ; DXUTState::GetDeviceCreatedFunc
	mov	DWORD PTR _pCallbackDeviceCreated$[ebp], eax

; 3229 :     hr = S_OK;

	mov	DWORD PTR _hr$[ebp], 0

; 3230 :     if( pCallbackDeviceCreated != NULL )

	cmp	DWORD PTR _pCallbackDeviceCreated$[ebp], 0
	je	SHORT $LN7@DXUTCreate

; 3231 :         hr = pCallbackDeviceCreated( DXUTGetD3DDevice(), pbackBufferSurfaceDesc, GetDXUTState().GetDeviceCreatedFuncUserContext() );

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetDeviceCreatedFuncUserContext@DXUTState@@QAEPAXXZ ; DXUTState::GetDeviceCreatedFuncUserContext
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _pbackBufferSurfaceDesc$[ebp]
	push	eax
	call	?DXUTGetD3DDevice@@YAPAUIDirect3DDevice9@@XZ ; DXUTGetD3DDevice
	push	eax
	call	DWORD PTR _pCallbackDeviceCreated$[ebp]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax
$LN7@DXUTCreate:

; 3232 :     GetDXUTState().SetInsideDeviceCallback( false );

	push	0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetInsideDeviceCallback@DXUTState@@QAEX_N@Z ; DXUTState::SetInsideDeviceCallback

; 3233 :     if( DXUTGetD3DDevice() == NULL ) // Handle DXUTShutdown from inside callback

	call	?DXUTGetD3DDevice@@YAPAUIDirect3DDevice9@@XZ ; DXUTGetD3DDevice
	test	eax, eax
	jne	SHORT $LN6@DXUTCreate

; 3234 :         return E_FAIL;

	mov	eax, -2147467259			; 80004005H
	jmp	$LN15@DXUTCreate
$LN6@DXUTCreate:

; 3235 :     if( FAILED(hr) )  

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN5@DXUTCreate

; 3236 :     {
; 3237 :         DXUT_ERR( "DeviceCreated callback", hr );        

	push	0
	push	OFFSET ??_C@_0BH@PGNAKDOD@DeviceCreated?5callback?$AA@
	mov	eax, DWORD PTR _hr$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??DXUTCreate3DEnvironment@@YAJPAUIDirect3DDevice9@@@Z@4JA
	add	ecx, 61					; 0000003dH
	push	ecx
	push	OFFSET ??_C@_0CL@KBAHBIDF@z?3?2sampsrc?202xu1?2saco?2d3d9?2commo@
	call	?DXUTTrace@@YGJPBDKJ0_N@Z		; DXUTTrace

; 3238 :         return ( hr == DXUTERR_MEDIANOTFOUND ) ? DXUTERR_MEDIANOTFOUND : DXUTERR_CREATINGDEVICEOBJECTS;

	cmp	DWORD PTR _hr$[ebp], -2147219197	; 80040903H
	jne	SHORT $LN19@DXUTCreate
	mov	DWORD PTR tv206[ebp], -2147219197	; 80040903H
	jmp	SHORT $LN20@DXUTCreate
$LN19@DXUTCreate:
	mov	DWORD PTR tv206[ebp], -2147219193	; 80040907H
$LN20@DXUTCreate:
	mov	eax, DWORD PTR tv206[ebp]
	jmp	$LN15@DXUTCreate
$LN5@DXUTCreate:

; 3239 :     }
; 3240 :     GetDXUTState().SetDeviceObjectsCreated( true );

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetDeviceObjectsCreated@DXUTState@@QAEX_N@Z ; DXUTState::SetDeviceObjectsCreated

; 3241 : 
; 3242 :     // Call the resource cache device reset function
; 3243 :     hr = DXUTGetGlobalResourceCache().OnResetDevice( pd3dDevice );

	mov	eax, DWORD PTR _pd3dDevice$[ebp]
	push	eax
	call	?DXUTGetGlobalResourceCache@@YAAAVCDXUTResourceCache@@XZ ; DXUTGetGlobalResourceCache
	mov	ecx, eax
	call	?OnResetDevice@CDXUTResourceCache@@QAEJPAUIDirect3DDevice9@@@Z ; CDXUTResourceCache::OnResetDevice
	mov	DWORD PTR _hr$[ebp], eax

; 3244 :     if( FAILED(hr) )

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN4@DXUTCreate

; 3245 :         return DXUT_ERR( "OnResetDevice", DXUTERR_RESETTINGDEVICEOBJECTS );

	push	0
	push	OFFSET ??_C@_0O@JFPFAANM@OnResetDevice?$AA@
	push	-2147219192				; 80040908H
	mov	eax, DWORD PTR ?__LINE__Var@?1??DXUTCreate3DEnvironment@@YAJPAUIDirect3DDevice9@@@Z@4JA
	add	eax, 69					; 00000045H
	push	eax
	push	OFFSET ??_C@_0CL@KBAHBIDF@z?3?2sampsrc?202xu1?2saco?2d3d9?2commo@
	call	?DXUTTrace@@YGJPBDKJ0_N@Z		; DXUTTrace
	jmp	$LN15@DXUTCreate
$LN4@DXUTCreate:

; 3246 : 
; 3247 :     // Call the app's device reset callback if non-NULL
; 3248 :     GetDXUTState().SetInsideDeviceCallback( true );

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetInsideDeviceCallback@DXUTState@@QAEX_N@Z ; DXUTState::SetInsideDeviceCallback

; 3249 :     LPDXUTCALLBACKDEVICERESET pCallbackDeviceReset = GetDXUTState().GetDeviceResetFunc();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetDeviceResetFunc@DXUTState@@QAEP6GJPAUIDirect3DDevice9@@PBU_D3DSURFACE_DESC@@PAX@ZXZ ; DXUTState::GetDeviceResetFunc
	mov	DWORD PTR _pCallbackDeviceReset$[ebp], eax

; 3250 :     hr = S_OK;

	mov	DWORD PTR _hr$[ebp], 0

; 3251 :     if( pCallbackDeviceReset != NULL )

	cmp	DWORD PTR _pCallbackDeviceReset$[ebp], 0
	je	SHORT $LN3@DXUTCreate

; 3252 :         hr = pCallbackDeviceReset( DXUTGetD3DDevice(), pbackBufferSurfaceDesc, GetDXUTState().GetDeviceResetFuncUserContext() );

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetDeviceResetFuncUserContext@DXUTState@@QAEPAXXZ ; DXUTState::GetDeviceResetFuncUserContext
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _pbackBufferSurfaceDesc$[ebp]
	push	eax
	call	?DXUTGetD3DDevice@@YAPAUIDirect3DDevice9@@XZ ; DXUTGetD3DDevice
	push	eax
	call	DWORD PTR _pCallbackDeviceReset$[ebp]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax
$LN3@DXUTCreate:

; 3253 :     GetDXUTState().SetInsideDeviceCallback( false );

	push	0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetInsideDeviceCallback@DXUTState@@QAEX_N@Z ; DXUTState::SetInsideDeviceCallback

; 3254 :     if( DXUTGetD3DDevice() == NULL ) // Handle DXUTShutdown from inside callback

	call	?DXUTGetD3DDevice@@YAPAUIDirect3DDevice9@@XZ ; DXUTGetD3DDevice
	test	eax, eax
	jne	SHORT $LN2@DXUTCreate

; 3255 :         return E_FAIL;

	mov	eax, -2147467259			; 80004005H
	jmp	SHORT $LN15@DXUTCreate
$LN2@DXUTCreate:

; 3256 :     if( FAILED(hr) )

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN1@DXUTCreate

; 3257 :     {
; 3258 :         DXUT_ERR( "DeviceReset callback", hr );

	push	0
	push	OFFSET ??_C@_0BF@LLKHGPAB@DeviceReset?5callback?$AA@
	mov	eax, DWORD PTR _hr$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??DXUTCreate3DEnvironment@@YAJPAUIDirect3DDevice9@@@Z@4JA
	add	ecx, 82					; 00000052H
	push	ecx
	push	OFFSET ??_C@_0CL@KBAHBIDF@z?3?2sampsrc?202xu1?2saco?2d3d9?2commo@
	call	?DXUTTrace@@YGJPBDKJ0_N@Z		; DXUTTrace

; 3259 :         return ( hr == DXUTERR_MEDIANOTFOUND ) ? DXUTERR_MEDIANOTFOUND : DXUTERR_RESETTINGDEVICEOBJECTS;

	cmp	DWORD PTR _hr$[ebp], -2147219197	; 80040903H
	jne	SHORT $LN21@DXUTCreate
	mov	DWORD PTR tv250[ebp], -2147219197	; 80040903H
	jmp	SHORT $LN22@DXUTCreate
$LN21@DXUTCreate:
	mov	DWORD PTR tv250[ebp], -2147219192	; 80040908H
$LN22@DXUTCreate:
	mov	eax, DWORD PTR tv250[ebp]
	jmp	SHORT $LN15@DXUTCreate
$LN1@DXUTCreate:

; 3260 :     }
; 3261 :     GetDXUTState().SetDeviceObjectsReset( true );

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetDeviceObjectsReset@DXUTState@@QAEX_N@Z ; DXUTState::SetDeviceObjectsReset

; 3262 : 
; 3263 :     return S_OK;

	xor	eax, eax
$LN15@DXUTCreate:

; 3264 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN25@DXUTCreate
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 304				; 00000130H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@DXUTCreate:
	DD	1
	DD	$LN24@DXUTCreate
$LN24@DXUTCreate:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN23@DXUTCreate
$LN23@DXUTCreate:
	DB	112					; 00000070H
	DB	100					; 00000064H
	DB	51					; 00000033H
	DB	100					; 00000064H
	DB	68					; 00000044H
	DB	101					; 00000065H
	DB	118					; 00000076H
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	0
?DXUTCreate3DEnvironment@@YAJPAUIDirect3DDevice9@@@Z ENDP ; DXUTCreate3DEnvironment
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTUpdateDeviceSettingsWithOverrides@@YAXPAUDXUTDeviceSettings@@@Z
_TEXT	SEGMENT
_pDeviceSettings$ = 8					; size = 4
?DXUTUpdateDeviceSettingsWithOverrides@@YAXPAUDXUTDeviceSettings@@@Z PROC ; DXUTUpdateDeviceSettingsWithOverrides, COMDAT

; 3132 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3133 :     if( GetDXUTState().GetOverrideAdapterOrdinal() != -1 )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetOverrideAdapterOrdinal@DXUTState@@QAEHXZ ; DXUTState::GetOverrideAdapterOrdinal
	cmp	eax, -1
	je	SHORT $LN13@DXUTUpdate

; 3134 :         pDeviceSettings->AdapterOrdinal = GetDXUTState().GetOverrideAdapterOrdinal();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetOverrideAdapterOrdinal@DXUTState@@QAEHXZ ; DXUTState::GetOverrideAdapterOrdinal
	mov	ecx, DWORD PTR _pDeviceSettings$[ebp]
	mov	DWORD PTR [ecx], eax
$LN13@DXUTUpdate:

; 3135 : 
; 3136 :     if( GetDXUTState().GetOverrideFullScreen() )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetOverrideFullScreen@DXUTState@@QAE_NXZ ; DXUTState::GetOverrideFullScreen
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN12@DXUTUpdate

; 3137 :         pDeviceSettings->pp.Windowed = false;

	mov	eax, DWORD PTR _pDeviceSettings$[ebp]
	mov	DWORD PTR [eax+48], 0
$LN12@DXUTUpdate:

; 3138 :     if( GetDXUTState().GetOverrideWindowed() )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetOverrideWindowed@DXUTState@@QAE_NXZ	; DXUTState::GetOverrideWindowed
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN11@DXUTUpdate

; 3139 :         pDeviceSettings->pp.Windowed = true;

	mov	eax, DWORD PTR _pDeviceSettings$[ebp]
	mov	DWORD PTR [eax+48], 1
$LN11@DXUTUpdate:

; 3140 : 
; 3141 :     if( GetDXUTState().GetOverrideForceREF() )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetOverrideForceREF@DXUTState@@QAE_NXZ	; DXUTState::GetOverrideForceREF
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@DXUTUpdate

; 3142 :         pDeviceSettings->DeviceType = D3DDEVTYPE_REF;

	mov	eax, DWORD PTR _pDeviceSettings$[ebp]
	mov	DWORD PTR [eax+4], 2
	jmp	SHORT $LN9@DXUTUpdate
$LN10@DXUTUpdate:

; 3143 :     else if( GetDXUTState().GetOverrideForceHAL() )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetOverrideForceHAL@DXUTState@@QAE_NXZ	; DXUTState::GetOverrideForceHAL
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@DXUTUpdate

; 3144 :         pDeviceSettings->DeviceType = D3DDEVTYPE_HAL;

	mov	eax, DWORD PTR _pDeviceSettings$[ebp]
	mov	DWORD PTR [eax+4], 1
$LN9@DXUTUpdate:

; 3145 : 
; 3146 :     if( GetDXUTState().GetOverrideWidth() != 0 )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetOverrideWidth@DXUTState@@QAEHXZ	; DXUTState::GetOverrideWidth
	test	eax, eax
	je	SHORT $LN7@DXUTUpdate

; 3147 :         pDeviceSettings->pp.BackBufferWidth = GetDXUTState().GetOverrideWidth();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetOverrideWidth@DXUTState@@QAEHXZ	; DXUTState::GetOverrideWidth
	mov	ecx, DWORD PTR _pDeviceSettings$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN7@DXUTUpdate:

; 3148 :     if( GetDXUTState().GetOverrideHeight() != 0 )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetOverrideHeight@DXUTState@@QAEHXZ	; DXUTState::GetOverrideHeight
	test	eax, eax
	je	SHORT $LN6@DXUTUpdate

; 3149 :         pDeviceSettings->pp.BackBufferHeight = GetDXUTState().GetOverrideHeight();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetOverrideHeight@DXUTState@@QAEHXZ	; DXUTState::GetOverrideHeight
	mov	ecx, DWORD PTR _pDeviceSettings$[ebp]
	mov	DWORD PTR [ecx+20], eax
$LN6@DXUTUpdate:

; 3150 : 
; 3151 :     if( GetDXUTState().GetOverrideForcePureHWVP() )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetOverrideForcePureHWVP@DXUTState@@QAE_NXZ ; DXUTState::GetOverrideForcePureHWVP
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@DXUTUpdate

; 3152 :     {
; 3153 :         pDeviceSettings->BehaviorFlags &= ~D3DCREATE_SOFTWARE_VERTEXPROCESSING;

	mov	eax, DWORD PTR _pDeviceSettings$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, -33				; ffffffdfH
	mov	edx, DWORD PTR _pDeviceSettings$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 3154 :         pDeviceSettings->BehaviorFlags |= D3DCREATE_HARDWARE_VERTEXPROCESSING;

	mov	eax, DWORD PTR _pDeviceSettings$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	or	ecx, 64					; 00000040H
	mov	edx, DWORD PTR _pDeviceSettings$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 3155 :         pDeviceSettings->BehaviorFlags |= D3DCREATE_PUREDEVICE;

	mov	eax, DWORD PTR _pDeviceSettings$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _pDeviceSettings$[ebp]
	mov	DWORD PTR [edx+12], ecx
	jmp	$LN14@DXUTUpdate
$LN5@DXUTUpdate:

; 3156 :     }
; 3157 :     else if( GetDXUTState().GetOverrideForceHWVP() )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetOverrideForceHWVP@DXUTState@@QAE_NXZ ; DXUTState::GetOverrideForceHWVP
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@DXUTUpdate

; 3158 :     {
; 3159 :         pDeviceSettings->BehaviorFlags &= ~D3DCREATE_SOFTWARE_VERTEXPROCESSING;

	mov	eax, DWORD PTR _pDeviceSettings$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, -33				; ffffffdfH
	mov	edx, DWORD PTR _pDeviceSettings$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 3160 :         pDeviceSettings->BehaviorFlags &= ~D3DCREATE_PUREDEVICE;

	mov	eax, DWORD PTR _pDeviceSettings$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _pDeviceSettings$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 3161 :         pDeviceSettings->BehaviorFlags |= D3DCREATE_HARDWARE_VERTEXPROCESSING;

	mov	eax, DWORD PTR _pDeviceSettings$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	or	ecx, 64					; 00000040H
	mov	edx, DWORD PTR _pDeviceSettings$[ebp]
	mov	DWORD PTR [edx+12], ecx
	jmp	SHORT $LN14@DXUTUpdate
$LN3@DXUTUpdate:

; 3162 :     }
; 3163 :     else if( GetDXUTState().GetOverrideForceSWVP() )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetOverrideForceSWVP@DXUTState@@QAE_NXZ ; DXUTState::GetOverrideForceSWVP
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN14@DXUTUpdate

; 3164 :     {
; 3165 :         pDeviceSettings->BehaviorFlags &= ~D3DCREATE_HARDWARE_VERTEXPROCESSING;

	mov	eax, DWORD PTR _pDeviceSettings$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, -65				; ffffffbfH
	mov	edx, DWORD PTR _pDeviceSettings$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 3166 :         pDeviceSettings->BehaviorFlags &= ~D3DCREATE_PUREDEVICE;

	mov	eax, DWORD PTR _pDeviceSettings$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _pDeviceSettings$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 3167 :         pDeviceSettings->BehaviorFlags |= D3DCREATE_SOFTWARE_VERTEXPROCESSING;

	mov	eax, DWORD PTR _pDeviceSettings$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _pDeviceSettings$[ebp]
	mov	DWORD PTR [edx+12], ecx
$LN14@DXUTUpdate:

; 3168 :     }
; 3169 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTUpdateDeviceSettingsWithOverrides@@YAXPAUDXUTDeviceSettings@@@Z ENDP ; DXUTUpdateDeviceSettingsWithOverrides
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTChangeDevice@@YAJPAUDXUTDeviceSettings@@PAUIDirect3DDevice9@@_N2@Z
_TEXT	SEGMENT
tv678 = -1696						; size = 4
tv601 = -1696						; size = 4
tv543 = -1696						; size = 4
tv497 = -1696						; size = 4
tv434 = -1696						; size = 4
tv348 = -1696						; size = 4
tv150 = -1696						; size = 4
tv331 = -1693						; size = 1
$T1 = -1688						; size = 4
$T2 = -1676						; size = 4
$T3 = -1664						; size = 4
$T4 = -1652						; size = 4
$T5 = -1640						; size = 4
$T6 = -1628						; size = 4
$T7 = -1616						; size = 4
$T8 = -1604						; size = 72
$T9 = -1524						; size = 72
$T10 = -1444						; size = 4
$T11 = -1432						; size = 4
_deviceSettings$12 = -1228				; size = 72
_nClientHeight$13 = -1148				; size = 4
_nClientWidth$14 = -1136				; size = 4
_rcClient$15 = -1124					; size = 16
_cy$16 = -1100						; size = 4
_cx$17 = -1088						; size = 4
_rcWindow$18 = -1076					; size = 16
_nWindowOffsetY$19 = -1052				; size = 4
_nWindowOffsetX$20 = -1040				; size = 4
_nWindowHeight$21 = -1028				; size = 4
_nWindowWidth$22 = -1016				; size = 4
_rcResizedWindow$23 = -1004				; size = 16
_rcWindow$24 = -980					; size = 16
_nClientHeight$25 = -956				; size = 4
_nClientWidth$26 = -944					; size = 4
_nAdapterMonitorHeight$27 = -932			; size = 4
_nAdapterMonitorWidth$28 = -920				; size = 4
_miWindow$29 = -908					; size = 40
_miAdapter$30 = -860					; size = 40
_rcWindow$31 = -812					; size = 16
_hWindowMonitor$32 = -788				; size = 4
_hAdapterMonitor$33 = -776				; size = 4
_miAdapter$34 = -764					; size = 40
_rcClient$35 = -716					; size = 16
_nFrameHeight$36 = -692					; size = 4
_nFrameWidth$37 = -680					; size = 4
_rcFrame$38 = -668					; size = 16
_rcClient$39 = -644					; size = 16
_wp$40 = -620						; size = 44
_nClientHeight$41 = -568				; size = 4
_nClientWidth$42 = -556					; size = 4
_bNeedToResize$ = -541					; size = 1
_pwp$43 = -532						; size = 4
_pd3dCaps$ = -520					; size = 4
_hAdapterMonitor$ = -508				; size = 4
_pD3D$ = -496						; size = 4
_wpFullscreen$44 = -484					; size = 44
_hMenu$45 = -432					; size = 4
_dwStyle$46 = -420					; size = 4
_pwp$47 = -408						; size = 4
_bKeepCurrentWindowSize$ = -393				; size = 1
_bContinue$48 = -381					; size = 1
_pD3D$49 = -372						; size = 4
_caps$50 = -360						; size = 304
_pCallbackModifyDeviceSettings$ = -48			; size = 4
_pNewDeviceSettingsOnHeap$ = -36			; size = 4
_pOldDeviceSettings$ = -24				; size = 4
_hr$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_pNewDeviceSettings$ = 8				; size = 4
_pd3dDeviceFromApp$ = 12				; size = 4
_bForceRecreate$ = 16					; size = 1
_bClipWindowToSingleAdapter$ = 20			; size = 1
?DXUTChangeDevice@@YAJPAUDXUTDeviceSettings@@PAUIDirect3DDevice9@@_N2@Z PROC ; DXUTChangeDevice, COMDAT

; 2628 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1696				; 000006a0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-1696]
	mov	ecx, 424				; 000001a8H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2629 :     HRESULT hr;
; 2630 :     DXUTDeviceSettings* pOldDeviceSettings = GetDXUTState().GetCurrentDeviceSettings();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetCurrentDeviceSettings@DXUTState@@QAEPAUDXUTDeviceSettings@@XZ ; DXUTState::GetCurrentDeviceSettings
	mov	DWORD PTR _pOldDeviceSettings$[ebp], eax

; 2631 : 
; 2632 :     if( DXUTGetD3DObject() == NULL )

	call	?DXUTGetD3DObject@@YAPAUIDirect3D9@@XZ	; DXUTGetD3DObject
	test	eax, eax
	jne	SHORT $LN66@DXUTChange

; 2633 :         return S_FALSE;

	mov	eax, 1
	jmp	$LN67@DXUTChange
$LN66@DXUTChange:

; 2634 : 
; 2635 :     // Make a copy of the pNewDeviceSettings on the heap
; 2636 :     DXUTDeviceSettings* pNewDeviceSettingsOnHeap = new DXUTDeviceSettings;

	push	72					; 00000048H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _pNewDeviceSettingsOnHeap$[ebp], eax

; 2637 :     if( pNewDeviceSettingsOnHeap == NULL )

	cmp	DWORD PTR _pNewDeviceSettingsOnHeap$[ebp], 0
	jne	SHORT $LN65@DXUTChange

; 2638 :         return E_OUTOFMEMORY;

	mov	eax, -2147024882			; 8007000eH
	jmp	$LN67@DXUTChange
$LN65@DXUTChange:

; 2639 :     memcpy( pNewDeviceSettingsOnHeap, pNewDeviceSettings, sizeof(DXUTDeviceSettings) );

	push	72					; 00000048H
	mov	eax, DWORD PTR _pNewDeviceSettings$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pNewDeviceSettingsOnHeap$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2640 :     pNewDeviceSettings = pNewDeviceSettingsOnHeap;

	mov	eax, DWORD PTR _pNewDeviceSettingsOnHeap$[ebp]
	mov	DWORD PTR _pNewDeviceSettings$[ebp], eax

; 2641 : 
; 2642 :     // If the ModifyDeviceSettings callback is non-NULL, then call it to let the app 
; 2643 :     // change the settings or reject the device change by returning false.
; 2644 :     LPDXUTCALLBACKMODIFYDEVICESETTINGS pCallbackModifyDeviceSettings = GetDXUTState().GetModifyDeviceSettingsFunc();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetModifyDeviceSettingsFunc@DXUTState@@QAEP6G_NPAUDXUTDeviceSettings@@PBU_D3DCAPS9@@PAX@ZXZ ; DXUTState::GetModifyDeviceSettingsFunc
	mov	DWORD PTR _pCallbackModifyDeviceSettings$[ebp], eax

; 2645 :     if( pCallbackModifyDeviceSettings )

	cmp	DWORD PTR _pCallbackModifyDeviceSettings$[ebp], 0
	je	$LN64@DXUTChange

; 2646 :     {
; 2647 :         D3DCAPS9 caps;
; 2648 :         IDirect3D9* pD3D = DXUTGetD3DObject();

	call	?DXUTGetD3DObject@@YAPAUIDirect3D9@@XZ	; DXUTGetD3DObject
	mov	DWORD PTR _pD3D$49[ebp], eax

; 2649 :         pD3D->GetDeviceCaps( pNewDeviceSettings->AdapterOrdinal, pNewDeviceSettings->DeviceType, &caps );

	mov	esi, esp
	lea	eax, DWORD PTR _caps$50[ebp]
	push	eax
	mov	ecx, DWORD PTR _pNewDeviceSettings$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _pNewDeviceSettings$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _pD3D$49[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pD3D$49[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+56]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2650 : 
; 2651 :         bool bContinue = pCallbackModifyDeviceSettings( pNewDeviceSettings, &caps, GetDXUTState().GetModifyDeviceSettingsFuncUserContext() );

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetModifyDeviceSettingsFuncUserContext@DXUTState@@QAEPAXXZ ; DXUTState::GetModifyDeviceSettingsFuncUserContext
	mov	esi, esp
	push	eax
	lea	eax, DWORD PTR _caps$50[ebp]
	push	eax
	mov	ecx, DWORD PTR _pNewDeviceSettings$[ebp]
	push	ecx
	call	DWORD PTR _pCallbackModifyDeviceSettings$[ebp]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	BYTE PTR _bContinue$48[ebp], al

; 2652 :         if( !bContinue )

	movzx	eax, BYTE PTR _bContinue$48[ebp]
	test	eax, eax
	jne	SHORT $LN63@DXUTChange

; 2653 :         {
; 2654 :             // The app rejected the device change by returning false, so just use the current device if there is one.
; 2655 :             if( pOldDeviceSettings == NULL )

	cmp	DWORD PTR _pOldDeviceSettings$[ebp], 0
	jne	SHORT $LN62@DXUTChange

; 2656 :                 DXUTDisplayErrorMessage( DXUTERR_NOCOMPATIBLEDEVICES );

	push	-2147219198				; 80040902H
	call	?DXUTDisplayErrorMessage@@YAXJ@Z	; DXUTDisplayErrorMessage
	add	esp, 4
$LN62@DXUTChange:

; 2657 :             SAFE_DELETE( pNewDeviceSettings );

	cmp	DWORD PTR _pNewDeviceSettings$[ebp], 0
	je	SHORT $LN61@DXUTChange
	mov	eax, DWORD PTR _pNewDeviceSettings$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	DWORD PTR _pNewDeviceSettings$[ebp], 0
$LN61@DXUTChange:

; 2658 :             return E_ABORT;

	mov	eax, -2147467260			; 80004004H
	jmp	$LN67@DXUTChange
$LN63@DXUTChange:

; 2659 :         }
; 2660 :         if( GetDXUTState().GetD3D() == NULL )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetD3D@DXUTState@@QAEPAUIDirect3D9@@XZ	; DXUTState::GetD3D
	test	eax, eax
	jne	SHORT $LN64@DXUTChange

; 2661 :         {
; 2662 :             SAFE_DELETE( pNewDeviceSettings );

	cmp	DWORD PTR _pNewDeviceSettings$[ebp], 0
	je	SHORT $LN59@DXUTChange
	mov	eax, DWORD PTR _pNewDeviceSettings$[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	DWORD PTR _pNewDeviceSettings$[ebp], 0
$LN59@DXUTChange:

; 2663 :             return S_FALSE;

	mov	eax, 1
	jmp	$LN67@DXUTChange
$LN64@DXUTChange:

; 2664 :         }
; 2665 :     }
; 2666 : 
; 2667 :     GetDXUTState().SetCurrentDeviceSettings( pNewDeviceSettings );

	mov	eax, DWORD PTR _pNewDeviceSettings$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetCurrentDeviceSettings@DXUTState@@QAEXPAUDXUTDeviceSettings@@@Z ; DXUTState::SetCurrentDeviceSettings

; 2668 : 
; 2669 :     DXUTPause( true, true );

	push	1
	push	1
	call	?DXUTPause@@YAX_N0@Z			; DXUTPause
	add	esp, 8

; 2670 : 
; 2671 :     // When a WM_SIZE message is received, it calls DXUTCheckForWindowSizeChange().
; 2672 :     // A WM_SIZE message might be sent when adjusting the window, so tell 
; 2673 :     // DXUTCheckForWindowSizeChange() to ignore size changes temporarily
; 2674 :     GetDXUTState().SetIgnoreSizeChange( true );

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetIgnoreSizeChange@DXUTState@@QAEX_N@Z ; DXUTState::SetIgnoreSizeChange

; 2675 : 
; 2676 :     // Update thread safety on/off depending on Direct3D device's thread safety
; 2677 :     g_bThreadSafe = ((pNewDeviceSettings->BehaviorFlags & D3DCREATE_MULTITHREADED) != 0 );

	mov	eax, DWORD PTR _pNewDeviceSettings$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 4
	je	SHORT $LN69@DXUTChange
	mov	DWORD PTR tv150[ebp], 1
	jmp	SHORT $LN70@DXUTChange
$LN69@DXUTChange:
	mov	DWORD PTR tv150[ebp], 0
$LN70@DXUTChange:
	mov	dl, BYTE PTR tv150[ebp]
	mov	BYTE PTR ?g_bThreadSafe@@3_NA, dl	; g_bThreadSafe

; 2678 : 
; 2679 :     // Only apply the cmd line overrides if this is the first device created
; 2680 :     // and DXUTSetDevice() isn't used
; 2681 :     if( NULL == pd3dDeviceFromApp && NULL == pOldDeviceSettings )

	cmp	DWORD PTR _pd3dDeviceFromApp$[ebp], 0
	jne	SHORT $LN58@DXUTChange
	cmp	DWORD PTR _pOldDeviceSettings$[ebp], 0
	jne	SHORT $LN58@DXUTChange

; 2682 :     {
; 2683 :         // Updates the device settings struct based on the cmd line args.  
; 2684 :         // Warning: if the device doesn't support these new settings then CreateDevice() will fail.
; 2685 :         DXUTUpdateDeviceSettingsWithOverrides( pNewDeviceSettings );

	mov	eax, DWORD PTR _pNewDeviceSettings$[ebp]
	push	eax
	call	?DXUTUpdateDeviceSettingsWithOverrides@@YAXPAUDXUTDeviceSettings@@@Z ; DXUTUpdateDeviceSettingsWithOverrides
	add	esp, 4
$LN58@DXUTChange:

; 2686 :     }
; 2687 : 
; 2688 :     // Take note if the backbuffer width & height are 0 now as they will change after pd3dDevice->Reset()
; 2689 :     bool bKeepCurrentWindowSize = false;

	mov	BYTE PTR _bKeepCurrentWindowSize$[ebp], 0

; 2690 :     if( pNewDeviceSettings->pp.BackBufferWidth == 0 && pNewDeviceSettings->pp.BackBufferHeight == 0 )

	mov	eax, DWORD PTR _pNewDeviceSettings$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN57@DXUTChange
	mov	eax, DWORD PTR _pNewDeviceSettings$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN57@DXUTChange

; 2691 :         bKeepCurrentWindowSize = true;

	mov	BYTE PTR _bKeepCurrentWindowSize$[ebp], 1
$LN57@DXUTChange:

; 2692 : 
; 2693 :     //////////////////////////
; 2694 :     // Before reset
; 2695 :     /////////////////////////
; 2696 :     if( pNewDeviceSettings->pp.Windowed )

	mov	eax, DWORD PTR _pNewDeviceSettings$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	$LN56@DXUTChange

; 2697 :     {
; 2698 :         // Going to windowed mode
; 2699 : 
; 2700 :         if( pOldDeviceSettings && !pOldDeviceSettings->pp.Windowed )

	cmp	DWORD PTR _pOldDeviceSettings$[ebp], 0
	je	SHORT $LN55@DXUTChange
	mov	eax, DWORD PTR _pOldDeviceSettings$[ebp]
	cmp	DWORD PTR [eax+48], 0
	jne	SHORT $LN55@DXUTChange

; 2701 :         {
; 2702 :             // Going from fullscreen -> windowed
; 2703 :             GetDXUTState().SetFullScreenBackBufferWidthAtModeChange( pOldDeviceSettings->pp.BackBufferWidth );

	mov	eax, DWORD PTR _pOldDeviceSettings$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetFullScreenBackBufferWidthAtModeChange@DXUTState@@QAEXI@Z ; DXUTState::SetFullScreenBackBufferWidthAtModeChange

; 2704 :             GetDXUTState().SetFullScreenBackBufferHeightAtModeChange( pOldDeviceSettings->pp.BackBufferHeight );

	mov	eax, DWORD PTR _pOldDeviceSettings$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetFullScreenBackBufferHeightAtModeChange@DXUTState@@QAEXI@Z ; DXUTState::SetFullScreenBackBufferHeightAtModeChange

; 2705 : 
; 2706 :             // Restore windowed mode style
; 2707 :             SetWindowLong( DXUTGetHWNDDeviceWindowed(), GWL_STYLE, GetDXUTState().GetWindowedStyleAtModeChange() );

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetWindowedStyleAtModeChange@DXUTState@@QAEKXZ ; DXUTState::GetWindowedStyleAtModeChange
	mov	esi, esp
	push	eax
	push	-16					; fffffff0H
	call	?DXUTGetHWNDDeviceWindowed@@YAPAUHWND__@@XZ ; DXUTGetHWNDDeviceWindowed
	push	eax
	call	DWORD PTR __imp__SetWindowLongA@12
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN55@DXUTChange:

; 2708 :         }
; 2709 : 
; 2710 :         // If different device windows are used for windowed mode and fullscreen mode,
; 2711 :         // hide the fullscreen window so that it doesn't obscure the screen.
; 2712 :         if( DXUTGetHWNDDeviceFullScreen() != DXUTGetHWNDDeviceWindowed() )

	call	?DXUTGetHWNDDeviceFullScreen@@YAPAUHWND__@@XZ ; DXUTGetHWNDDeviceFullScreen
	mov	esi, eax
	call	?DXUTGetHWNDDeviceWindowed@@YAPAUHWND__@@XZ ; DXUTGetHWNDDeviceWindowed
	cmp	esi, eax
	je	SHORT $LN54@DXUTChange

; 2713 :             ShowWindow( DXUTGetHWNDDeviceFullScreen(), SW_HIDE );

	mov	esi, esp
	push	0
	call	?DXUTGetHWNDDeviceFullScreen@@YAPAUHWND__@@XZ ; DXUTGetHWNDDeviceFullScreen
	push	eax
	call	DWORD PTR __imp__ShowWindow@8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN54@DXUTChange:

; 2714 : 
; 2715 :         // If using the same window for windowed and fullscreen mode, reattach menu if one exists
; 2716 :         if( DXUTGetHWNDDeviceFullScreen() == DXUTGetHWNDDeviceWindowed() )

	call	?DXUTGetHWNDDeviceFullScreen@@YAPAUHWND__@@XZ ; DXUTGetHWNDDeviceFullScreen
	mov	esi, eax
	call	?DXUTGetHWNDDeviceWindowed@@YAPAUHWND__@@XZ ; DXUTGetHWNDDeviceWindowed
	cmp	esi, eax
	jne	SHORT $LN53@DXUTChange

; 2717 :         {
; 2718 :             if( GetDXUTState().GetMenu() != NULL )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetMenu@DXUTState@@QAEPAUHMENU__@@XZ	; DXUTState::GetMenu
	test	eax, eax
	je	SHORT $LN53@DXUTChange

; 2719 :                 SetMenu( DXUTGetHWNDDeviceWindowed(), GetDXUTState().GetMenu() );

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetMenu@DXUTState@@QAEPAUHMENU__@@XZ	; DXUTState::GetMenu
	mov	esi, esp
	push	eax
	call	?DXUTGetHWNDDeviceWindowed@@YAPAUHWND__@@XZ ; DXUTGetHWNDDeviceWindowed
	push	eax
	call	DWORD PTR __imp__SetMenu@8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN53@DXUTChange:

; 2720 :         }
; 2721 :     }
; 2722 :     else 

	jmp	$LN51@DXUTChange
$LN56@DXUTChange:

; 2723 :     {
; 2724 :         // Going to fullscreen mode
; 2725 : 
; 2726 :         if( pOldDeviceSettings == NULL || (pOldDeviceSettings && pOldDeviceSettings->pp.Windowed) )

	cmp	DWORD PTR _pOldDeviceSettings$[ebp], 0
	je	SHORT $LN49@DXUTChange
	cmp	DWORD PTR _pOldDeviceSettings$[ebp], 0
	je	$LN50@DXUTChange
	mov	eax, DWORD PTR _pOldDeviceSettings$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	$LN50@DXUTChange
$LN49@DXUTChange:

; 2727 :         {
; 2728 :             // Transistioning to full screen mode from a standard window so 
; 2729 :             // save current window position/size/style now in case the user toggles to windowed mode later 
; 2730 :             WINDOWPLACEMENT* pwp = GetDXUTState().GetWindowedPlacement();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetWindowedPlacement@DXUTState@@QAEPAUtagWINDOWPLACEMENT@@XZ ; DXUTState::GetWindowedPlacement
	mov	DWORD PTR _pwp$47[ebp], eax

; 2731 :             ZeroMemory( pwp, sizeof(WINDOWPLACEMENT) );

	push	44					; 0000002cH
	push	0
	mov	eax, DWORD PTR _pwp$47[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2732 :             pwp->length = sizeof(WINDOWPLACEMENT);

	mov	eax, DWORD PTR _pwp$47[ebp]
	mov	DWORD PTR [eax], 44			; 0000002cH

; 2733 :             GetWindowPlacement( DXUTGetHWNDDeviceWindowed(), pwp );

	mov	esi, esp
	mov	eax, DWORD PTR _pwp$47[ebp]
	push	eax
	call	?DXUTGetHWNDDeviceWindowed@@YAPAUHWND__@@XZ ; DXUTGetHWNDDeviceWindowed
	push	eax
	call	DWORD PTR __imp__GetWindowPlacement@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2734 :             DWORD dwStyle = GetWindowLong( DXUTGetHWNDDeviceWindowed(), GWL_STYLE );

	mov	esi, esp
	push	-16					; fffffff0H
	call	?DXUTGetHWNDDeviceWindowed@@YAPAUHWND__@@XZ ; DXUTGetHWNDDeviceWindowed
	push	eax
	call	DWORD PTR __imp__GetWindowLongA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _dwStyle$46[ebp], eax

; 2735 :             dwStyle &= ~WS_MAXIMIZE & ~WS_MINIMIZE; // remove minimize/maximize style

	mov	eax, DWORD PTR _dwStyle$46[ebp]
	and	eax, -553648129				; deffffffH
	mov	DWORD PTR _dwStyle$46[ebp], eax

; 2736 :             GetDXUTState().SetWindowedStyleAtModeChange( dwStyle );

	mov	eax, DWORD PTR _dwStyle$46[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetWindowedStyleAtModeChange@DXUTState@@QAEXK@Z ; DXUTState::SetWindowedStyleAtModeChange

; 2737 :             if( pOldDeviceSettings )

	cmp	DWORD PTR _pOldDeviceSettings$[ebp], 0
	je	SHORT $LN50@DXUTChange

; 2738 :             {
; 2739 :                 GetDXUTState().SetWindowBackBufferWidthAtModeChange( pOldDeviceSettings->pp.BackBufferWidth );

	mov	eax, DWORD PTR _pOldDeviceSettings$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetWindowBackBufferWidthAtModeChange@DXUTState@@QAEXI@Z ; DXUTState::SetWindowBackBufferWidthAtModeChange

; 2740 :                 GetDXUTState().SetWindowBackBufferHeightAtModeChange( pOldDeviceSettings->pp.BackBufferHeight );

	mov	eax, DWORD PTR _pOldDeviceSettings$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetWindowBackBufferHeightAtModeChange@DXUTState@@QAEXI@Z ; DXUTState::SetWindowBackBufferHeightAtModeChange
$LN50@DXUTChange:

; 2741 :             }
; 2742 :         }
; 2743 : 
; 2744 :         // Hide the window to avoid animation of blank windows
; 2745 :         ShowWindow( DXUTGetHWNDDeviceFullScreen(), SW_HIDE );

	mov	esi, esp
	push	0
	call	?DXUTGetHWNDDeviceFullScreen@@YAPAUHWND__@@XZ ; DXUTGetHWNDDeviceFullScreen
	push	eax
	call	DWORD PTR __imp__ShowWindow@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2746 : 
; 2747 :         // Set FS window style
; 2748 :         SetWindowLong( DXUTGetHWNDDeviceFullScreen(), GWL_STYLE, WS_POPUP|WS_SYSMENU );

	mov	esi, esp
	push	-2146959360				; 80080000H
	push	-16					; fffffff0H
	call	?DXUTGetHWNDDeviceFullScreen@@YAPAUHWND__@@XZ ; DXUTGetHWNDDeviceFullScreen
	push	eax
	call	DWORD PTR __imp__SetWindowLongA@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2749 : 
; 2750 :         // If using the same window for windowed and fullscreen mode, save and remove menu 
; 2751 :         if( DXUTGetHWNDDeviceFullScreen() == DXUTGetHWNDDeviceWindowed() )

	call	?DXUTGetHWNDDeviceFullScreen@@YAPAUHWND__@@XZ ; DXUTGetHWNDDeviceFullScreen
	mov	esi, eax
	call	?DXUTGetHWNDDeviceWindowed@@YAPAUHWND__@@XZ ; DXUTGetHWNDDeviceWindowed
	cmp	esi, eax
	jne	SHORT $LN47@DXUTChange

; 2752 :         {
; 2753 :             HMENU hMenu = GetMenu( DXUTGetHWNDDeviceFullScreen() );

	call	?DXUTGetHWNDDeviceFullScreen@@YAPAUHWND__@@XZ ; DXUTGetHWNDDeviceFullScreen
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__GetMenu@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hMenu$45[ebp], eax

; 2754 :             GetDXUTState().SetMenu( hMenu );

	mov	eax, DWORD PTR _hMenu$45[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetMenu@DXUTState@@QAEXPAUHMENU__@@@Z	; DXUTState::SetMenu

; 2755 :             SetMenu( DXUTGetHWNDDeviceFullScreen(), NULL );

	mov	esi, esp
	push	0
	call	?DXUTGetHWNDDeviceFullScreen@@YAPAUHWND__@@XZ ; DXUTGetHWNDDeviceFullScreen
	push	eax
	call	DWORD PTR __imp__SetMenu@8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN47@DXUTChange:

; 2756 :         }
; 2757 : 
; 2758 :         // Restore the window to normal.  Note that if the window was maximized then minimized, the
; 2759 :         // WPF_RESTORETOMAXIMIZED flag will be set which will cause SW_RESTORE to restore the 
; 2760 :         // window from minimized to maxmized which isn't what we want right now.
; 2761 :         WINDOWPLACEMENT wpFullscreen;
; 2762 :         ZeroMemory( &wpFullscreen, sizeof(WINDOWPLACEMENT) );

	push	44					; 0000002cH
	push	0
	lea	eax, DWORD PTR _wpFullscreen$44[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2763 :         wpFullscreen.length = sizeof(WINDOWPLACEMENT);

	mov	DWORD PTR _wpFullscreen$44[ebp], 44	; 0000002cH

; 2764 :         GetWindowPlacement( DXUTGetHWNDDeviceFullScreen(), &wpFullscreen );

	mov	esi, esp
	lea	eax, DWORD PTR _wpFullscreen$44[ebp]
	push	eax
	call	?DXUTGetHWNDDeviceFullScreen@@YAPAUHWND__@@XZ ; DXUTGetHWNDDeviceFullScreen
	push	eax
	call	DWORD PTR __imp__GetWindowPlacement@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2765 :         wpFullscreen.flags &= ~WPF_RESTORETOMAXIMIZED;

	mov	eax, DWORD PTR _wpFullscreen$44[ebp+4]
	and	eax, -3					; fffffffdH
	mov	DWORD PTR _wpFullscreen$44[ebp+4], eax

; 2766 :         wpFullscreen.showCmd = SW_RESTORE;

	mov	DWORD PTR _wpFullscreen$44[ebp+8], 9

; 2767 :         SetWindowPlacement( DXUTGetHWNDDeviceFullScreen(), &wpFullscreen );

	mov	esi, esp
	lea	eax, DWORD PTR _wpFullscreen$44[ebp]
	push	eax
	call	?DXUTGetHWNDDeviceFullScreen@@YAPAUHWND__@@XZ ; DXUTGetHWNDDeviceFullScreen
	push	eax
	call	DWORD PTR __imp__SetWindowPlacement@8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN51@DXUTChange:

; 2768 :     }
; 2769 : 
; 2770 :     // If AdapterOrdinal and DeviceType are the same, we can just do a Reset().
; 2771 :     // If they've changed, we need to do a complete device tear down/rebuild.
; 2772 :     // Also only allow a reset if pd3dDevice is the same as the current device 
; 2773 :     if( !bForceRecreate && 
; 2774 :         (pd3dDeviceFromApp == NULL || pd3dDeviceFromApp == DXUTGetD3DDevice()) && 
; 2775 :         pOldDeviceSettings &&
; 2776 :         pOldDeviceSettings->AdapterOrdinal == pNewDeviceSettings->AdapterOrdinal &&
; 2777 :         pOldDeviceSettings->DeviceType == pNewDeviceSettings->DeviceType &&
; 2778 :         pOldDeviceSettings->BehaviorFlags == pNewDeviceSettings->BehaviorFlags )

	movzx	eax, BYTE PTR _bForceRecreate$[ebp]
	test	eax, eax
	jne	$LN46@DXUTChange
	cmp	DWORD PTR _pd3dDeviceFromApp$[ebp], 0
	je	SHORT $LN45@DXUTChange
	call	?DXUTGetD3DDevice@@YAPAUIDirect3DDevice9@@XZ ; DXUTGetD3DDevice
	cmp	DWORD PTR _pd3dDeviceFromApp$[ebp], eax
	jne	$LN46@DXUTChange
$LN45@DXUTChange:
	cmp	DWORD PTR _pOldDeviceSettings$[ebp], 0
	je	$LN46@DXUTChange
	mov	eax, DWORD PTR _pOldDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _pNewDeviceSettings$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	$LN46@DXUTChange
	mov	eax, DWORD PTR _pOldDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _pNewDeviceSettings$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jne	$LN46@DXUTChange
	mov	eax, DWORD PTR _pOldDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _pNewDeviceSettings$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+12]
	jne	$LN46@DXUTChange

; 2779 :     {
; 2780 :         // Reset the Direct3D device and call the app's device callbacks
; 2781 :         hr = DXUTReset3DEnvironment();

	call	?DXUTReset3DEnvironment@@YAJXZ		; DXUTReset3DEnvironment
	mov	DWORD PTR _hr$[ebp], eax

; 2782 :         if( FAILED(hr) )

	cmp	DWORD PTR _hr$[ebp], 0
	jge	$LN44@DXUTChange

; 2783 :         {
; 2784 :             if( D3DERR_DEVICELOST == hr )

	cmp	DWORD PTR _hr$[ebp], -2005530520	; 88760868H
	jne	SHORT $LN43@DXUTChange

; 2785 :             {
; 2786 :                 // The device is lost, just mark it as so and continue on with 
; 2787 :                 // capturing the state and resizing the window/etc.
; 2788 :                 GetDXUTState().SetDeviceLost( true );

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetDeviceLost@DXUTState@@QAEX_N@Z	; DXUTState::SetDeviceLost

; 2789 :             }
; 2790 :             else if( DXUTERR_RESETTINGDEVICEOBJECTS == hr || 

	jmp	$LN44@DXUTChange
$LN43@DXUTChange:

; 2791 :                      DXUTERR_MEDIANOTFOUND == hr )

	cmp	DWORD PTR _hr$[ebp], -2147219192	; 80040908H
	je	SHORT $LN40@DXUTChange
	cmp	DWORD PTR _hr$[ebp], -2147219197	; 80040903H
	jne	SHORT $LN41@DXUTChange
$LN40@DXUTChange:

; 2792 :             {
; 2793 :                 // Something bad happened in the app callbacks
; 2794 :                 SAFE_DELETE( pOldDeviceSettings );

	cmp	DWORD PTR _pOldDeviceSettings$[ebp], 0
	je	SHORT $LN39@DXUTChange
	mov	eax, DWORD PTR _pOldDeviceSettings$[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	ecx, DWORD PTR $T4[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	DWORD PTR _pOldDeviceSettings$[ebp], 0
$LN39@DXUTChange:

; 2795 :                 DXUTDisplayErrorMessage( hr );

	mov	eax, DWORD PTR _hr$[ebp]
	push	eax
	call	?DXUTDisplayErrorMessage@@YAXJ@Z	; DXUTDisplayErrorMessage
	add	esp, 4

; 2796 :                 DXUTShutdown();

	push	0
	call	?DXUTShutdown@@YAXH@Z			; DXUTShutdown
	add	esp, 4

; 2797 :                 return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	jmp	$LN67@DXUTChange

; 2798 :             }
; 2799 :             else // DXUTERR_RESETTINGDEVICE

	jmp	$LN44@DXUTChange
$LN41@DXUTChange:

; 2800 :             {
; 2801 :                 // Reset failed and the device wasn't lost and it wasn't the apps fault, 
; 2802 :                 // so recreate the device to try to recover
; 2803 :                 GetDXUTState().SetCurrentDeviceSettings( pOldDeviceSettings );

	mov	eax, DWORD PTR _pOldDeviceSettings$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetCurrentDeviceSettings@DXUTState@@QAEXPAUDXUTDeviceSettings@@@Z ; DXUTState::SetCurrentDeviceSettings

; 2804 :                 if( FAILED( DXUTChangeDevice( pNewDeviceSettings, pd3dDeviceFromApp, true, bClipWindowToSingleAdapter ) ) )

	movzx	eax, BYTE PTR _bClipWindowToSingleAdapter$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _pd3dDeviceFromApp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pNewDeviceSettings$[ebp]
	push	edx
	call	?DXUTChangeDevice@@YAJPAUDXUTDeviceSettings@@PAUIDirect3DDevice9@@_N2@Z ; DXUTChangeDevice
	add	esp, 16					; 00000010H
	test	eax, eax
	jge	SHORT $LN37@DXUTChange

; 2805 :                 {
; 2806 :                     // If that fails, then shutdown
; 2807 :                     SAFE_DELETE( pOldDeviceSettings );

	cmp	DWORD PTR _pOldDeviceSettings$[ebp], 0
	je	SHORT $LN36@DXUTChange
	mov	eax, DWORD PTR _pOldDeviceSettings$[ebp]
	mov	DWORD PTR $T5[ebp], eax
	mov	ecx, DWORD PTR $T5[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	DWORD PTR _pOldDeviceSettings$[ebp], 0
$LN36@DXUTChange:

; 2808 :                     DXUTShutdown();

	push	0
	call	?DXUTShutdown@@YAXH@Z			; DXUTShutdown
	add	esp, 4

; 2809 :                     return DXUTERR_CREATINGDEVICE;

	mov	eax, -2147219195			; 80040905H
	jmp	$LN67@DXUTChange

; 2810 :                 }
; 2811 :                 else

	jmp	SHORT $LN44@DXUTChange
$LN37@DXUTChange:

; 2812 :                 {
; 2813 :                     SAFE_DELETE( pOldDeviceSettings );

	cmp	DWORD PTR _pOldDeviceSettings$[ebp], 0
	je	SHORT $LN34@DXUTChange
	mov	eax, DWORD PTR _pOldDeviceSettings$[ebp]
	mov	DWORD PTR $T6[ebp], eax
	mov	ecx, DWORD PTR $T6[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	DWORD PTR _pOldDeviceSettings$[ebp], 0
$LN34@DXUTChange:

; 2814 :                     return S_OK;

	xor	eax, eax
	jmp	$LN67@DXUTChange
$LN44@DXUTChange:

; 2815 :                 }
; 2816 :             }
; 2817 :         }
; 2818 :     }
; 2819 :     else

	jmp	$LN33@DXUTChange
$LN46@DXUTChange:

; 2820 :     {
; 2821 :         // Cleanup if not first device created
; 2822 :         if( pOldDeviceSettings )

	cmp	DWORD PTR _pOldDeviceSettings$[ebp], 0
	je	SHORT $LN32@DXUTChange

; 2823 :             DXUTCleanup3DEnvironment( false );

	push	0
	call	?DXUTCleanup3DEnvironment@@YAX_N@Z	; DXUTCleanup3DEnvironment
	add	esp, 4
$LN32@DXUTChange:

; 2824 : 
; 2825 :         // Create the D3D device and call the app's device callbacks
; 2826 :         hr = DXUTCreate3DEnvironment( pd3dDeviceFromApp );

	mov	eax, DWORD PTR _pd3dDeviceFromApp$[ebp]
	push	eax
	call	?DXUTCreate3DEnvironment@@YAJPAUIDirect3DDevice9@@@Z ; DXUTCreate3DEnvironment
	add	esp, 4
	mov	DWORD PTR _hr$[ebp], eax

; 2827 :         if( FAILED(hr) )

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN33@DXUTChange

; 2828 :         {
; 2829 :             SAFE_DELETE( pOldDeviceSettings );

	cmp	DWORD PTR _pOldDeviceSettings$[ebp], 0
	je	SHORT $LN30@DXUTChange
	mov	eax, DWORD PTR _pOldDeviceSettings$[ebp]
	mov	DWORD PTR $T7[ebp], eax
	mov	ecx, DWORD PTR $T7[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	DWORD PTR _pOldDeviceSettings$[ebp], 0
$LN30@DXUTChange:

; 2830 :             DXUTCleanup3DEnvironment();

	push	1
	call	?DXUTCleanup3DEnvironment@@YAX_N@Z	; DXUTCleanup3DEnvironment
	add	esp, 4

; 2831 :             DXUTDisplayErrorMessage( hr );

	mov	eax, DWORD PTR _hr$[ebp]
	push	eax
	call	?DXUTDisplayErrorMessage@@YAXJ@Z	; DXUTDisplayErrorMessage
	add	esp, 4

; 2832 :             DXUTPause( false, false );

	push	0
	push	0
	call	?DXUTPause@@YAX_N0@Z			; DXUTPause
	add	esp, 8

; 2833 :             GetDXUTState().SetIgnoreSizeChange( false );

	push	0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetIgnoreSizeChange@DXUTState@@QAEX_N@Z ; DXUTState::SetIgnoreSizeChange

; 2834 :             return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	jmp	$LN67@DXUTChange
$LN33@DXUTChange:

; 2835 :         }
; 2836 :     }
; 2837 : 
; 2838 :     // Enable/disable StickKeys shortcut, ToggleKeys shortcut, FilterKeys shortcut, and Windows key 
; 2839 :     // to prevent accidental task switching
; 2840 :     DXUTAllowShortcutKeys( ( pNewDeviceSettings->pp.Windowed  ) ? GetDXUTState().GetAllowShortcutKeysWhenWindowed() : GetDXUTState().GetAllowShortcutKeysWhenFullscreen() );

	mov	eax, DWORD PTR _pNewDeviceSettings$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN71@DXUTChange
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetAllowShortcutKeysWhenWindowed@DXUTState@@QAE_NXZ ; DXUTState::GetAllowShortcutKeysWhenWindowed
	mov	BYTE PTR tv331[ebp], al
	jmp	SHORT $LN72@DXUTChange
$LN71@DXUTChange:
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetAllowShortcutKeysWhenFullscreen@DXUTState@@QAE_NXZ ; DXUTState::GetAllowShortcutKeysWhenFullscreen
	mov	BYTE PTR tv331[ebp], al
$LN72@DXUTChange:
	movzx	ecx, BYTE PTR tv331[ebp]
	push	ecx
	call	?DXUTAllowShortcutKeys@@YAX_N@Z		; DXUTAllowShortcutKeys
	add	esp, 4

; 2841 : 
; 2842 :     IDirect3D9* pD3D = DXUTGetD3DObject();

	call	?DXUTGetD3DObject@@YAPAUIDirect3D9@@XZ	; DXUTGetD3DObject
	mov	DWORD PTR _pD3D$[ebp], eax

; 2843 :     HMONITOR hAdapterMonitor = pD3D->GetAdapterMonitor( pNewDeviceSettings->AdapterOrdinal );

	mov	esi, esp
	mov	eax, DWORD PTR _pNewDeviceSettings$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _pD3D$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pD3D$[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+60]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hAdapterMonitor$[ebp], eax

; 2844 :     GetDXUTState().SetAdapterMonitor( hAdapterMonitor );

	mov	eax, DWORD PTR _hAdapterMonitor$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetAdapterMonitor@DXUTState@@QAEXPAUHMONITOR__@@@Z ; DXUTState::SetAdapterMonitor

; 2845 : 
; 2846 :     // Update the device stats text
; 2847 :     DXUTUpdateStaticFrameStats();

	call	?DXUTUpdateStaticFrameStats@@YAXXZ	; DXUTUpdateStaticFrameStats

; 2848 : 
; 2849 :     // Update GetDXUTState()'s copy of D3D caps 
; 2850 :     D3DCAPS9* pd3dCaps = GetDXUTState().GetCaps();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetCaps@DXUTState@@QAEPAU_D3DCAPS9@@XZ	; DXUTState::GetCaps
	mov	DWORD PTR _pd3dCaps$[ebp], eax

; 2851 :     DXUTGetD3DDevice()->GetDeviceCaps( pd3dCaps );

	call	?DXUTGetD3DDevice@@YAPAUIDirect3DDevice9@@XZ ; DXUTGetD3DDevice
	mov	DWORD PTR tv348[ebp], eax
	mov	esi, esp
	mov	eax, DWORD PTR _pd3dCaps$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv348[ebp]
	push	ecx
	mov	edx, DWORD PTR tv348[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+28]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2852 : 
; 2853 :     if( pOldDeviceSettings && !pOldDeviceSettings->pp.Windowed && pNewDeviceSettings->pp.Windowed )

	cmp	DWORD PTR _pOldDeviceSettings$[ebp], 0
	je	SHORT $LN29@DXUTChange
	mov	eax, DWORD PTR _pOldDeviceSettings$[ebp]
	cmp	DWORD PTR [eax+48], 0
	jne	SHORT $LN29@DXUTChange
	mov	eax, DWORD PTR _pNewDeviceSettings$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN29@DXUTChange

; 2854 :     {
; 2855 :         // Going from fullscreen -> windowed
; 2856 : 
; 2857 :         // Restore the show state, and positions/size of the window to what it was
; 2858 :         // It is important to adjust the window size 
; 2859 :         // after resetting the device rather than beforehand to ensure 
; 2860 :         // that the monitor resolution is correct and does not limit the size of the new window.
; 2861 :         WINDOWPLACEMENT* pwp = GetDXUTState().GetWindowedPlacement();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetWindowedPlacement@DXUTState@@QAEPAUtagWINDOWPLACEMENT@@XZ ; DXUTState::GetWindowedPlacement
	mov	DWORD PTR _pwp$43[ebp], eax

; 2862 :         SetWindowPlacement( DXUTGetHWNDDeviceWindowed(), pwp );

	mov	esi, esp
	mov	eax, DWORD PTR _pwp$43[ebp]
	push	eax
	call	?DXUTGetHWNDDeviceWindowed@@YAPAUHWND__@@XZ ; DXUTGetHWNDDeviceWindowed
	push	eax
	call	DWORD PTR __imp__SetWindowPlacement@8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN29@DXUTChange:

; 2863 :     }
; 2864 : 
; 2865 :     // Check to see if the window needs to be resized.  
; 2866 :     // Handle cases where the window is minimized and maxmimized as well.
; 2867 :     bool bNeedToResize = false;

	mov	BYTE PTR _bNeedToResize$[ebp], 0

; 2868 :     if( pNewDeviceSettings->pp.Windowed && // only resize if in windowed mode
; 2869 :         !bKeepCurrentWindowSize )          // only resize if pp.BackbufferWidth/Height were not 0

	mov	eax, DWORD PTR _pNewDeviceSettings$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	$LN28@DXUTChange
	movzx	eax, BYTE PTR _bKeepCurrentWindowSize$[ebp]
	test	eax, eax
	jne	$LN28@DXUTChange

; 2870 :     {
; 2871 :         UINT nClientWidth;
; 2872 :         UINT nClientHeight;    
; 2873 :         if( IsIconic(DXUTGetHWNDDeviceWindowed()) )

	call	?DXUTGetHWNDDeviceWindowed@@YAPAUHWND__@@XZ ; DXUTGetHWNDDeviceWindowed
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__IsIconic@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	$LN27@DXUTChange

; 2874 :         {
; 2875 :             // Window is currently minimized. To tell if it needs to resize, 
; 2876 :             // get the client rect of window when its restored the 
; 2877 :             // hard way using GetWindowPlacement()
; 2878 :             WINDOWPLACEMENT wp;
; 2879 :             ZeroMemory( &wp, sizeof(WINDOWPLACEMENT) );

	push	44					; 0000002cH
	push	0
	lea	eax, DWORD PTR _wp$40[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2880 :             wp.length = sizeof(WINDOWPLACEMENT);

	mov	DWORD PTR _wp$40[ebp], 44		; 0000002cH

; 2881 :             GetWindowPlacement( DXUTGetHWNDDeviceWindowed(), &wp );

	mov	esi, esp
	lea	eax, DWORD PTR _wp$40[ebp]
	push	eax
	call	?DXUTGetHWNDDeviceWindowed@@YAPAUHWND__@@XZ ; DXUTGetHWNDDeviceWindowed
	push	eax
	call	DWORD PTR __imp__GetWindowPlacement@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2882 : 
; 2883 :             if( (wp.flags & WPF_RESTORETOMAXIMIZED) != 0 && wp.showCmd == SW_SHOWMINIMIZED )

	mov	eax, DWORD PTR _wp$40[ebp+4]
	and	eax, 2
	je	SHORT $LN26@DXUTChange
	cmp	DWORD PTR _wp$40[ebp+8], 2
	jne	SHORT $LN26@DXUTChange

; 2884 :             {
; 2885 :                 // WPF_RESTORETOMAXIMIZED means that when the window is restored it will
; 2886 :                 // be maximized.  So maximize the window temporarily to get the client rect 
; 2887 :                 // when the window is maximized.  GetSystemMetrics( SM_CXMAXIMIZED ) will give this 
; 2888 :                 // information if the window is on the primary but this will work on multimon.
; 2889 :                 ShowWindow( DXUTGetHWNDDeviceWindowed(), SW_RESTORE );

	mov	esi, esp
	push	9
	call	?DXUTGetHWNDDeviceWindowed@@YAPAUHWND__@@XZ ; DXUTGetHWNDDeviceWindowed
	push	eax
	call	DWORD PTR __imp__ShowWindow@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2890 :                 RECT rcClient;
; 2891 :                 GetClientRect( DXUTGetHWNDDeviceWindowed(), &rcClient );

	mov	esi, esp
	lea	eax, DWORD PTR _rcClient$39[ebp]
	push	eax
	call	?DXUTGetHWNDDeviceWindowed@@YAPAUHWND__@@XZ ; DXUTGetHWNDDeviceWindowed
	push	eax
	call	DWORD PTR __imp__GetClientRect@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2892 :                 nClientWidth  = (UINT)(rcClient.right - rcClient.left);

	mov	eax, DWORD PTR _rcClient$39[ebp+8]
	sub	eax, DWORD PTR _rcClient$39[ebp]
	mov	DWORD PTR _nClientWidth$42[ebp], eax

; 2893 :                 nClientHeight = (UINT)(rcClient.bottom - rcClient.top);

	mov	eax, DWORD PTR _rcClient$39[ebp+12]
	sub	eax, DWORD PTR _rcClient$39[ebp+4]
	mov	DWORD PTR _nClientHeight$41[ebp], eax

; 2894 :                 ShowWindow( DXUTGetHWNDDeviceWindowed(), SW_MINIMIZE );

	mov	esi, esp
	push	6
	call	?DXUTGetHWNDDeviceWindowed@@YAPAUHWND__@@XZ ; DXUTGetHWNDDeviceWindowed
	push	eax
	call	DWORD PTR __imp__ShowWindow@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2895 :             }
; 2896 :             else

	jmp	$LN25@DXUTChange
$LN26@DXUTChange:

; 2897 :             {
; 2898 :                 // Use wp.rcNormalPosition to get the client rect, but wp.rcNormalPosition 
; 2899 :                 // includes the window frame so subtract it
; 2900 :                 RECT rcFrame = {0};

	mov	DWORD PTR _rcFrame$38[ebp], 0
	xor	eax, eax
	mov	DWORD PTR _rcFrame$38[ebp+4], eax
	mov	DWORD PTR _rcFrame$38[ebp+8], eax
	mov	DWORD PTR _rcFrame$38[ebp+12], eax

; 2901 :                 AdjustWindowRect( &rcFrame, GetDXUTState().GetWindowedStyleAtModeChange(), GetDXUTState().GetMenu() != NULL );

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetMenu@DXUTState@@QAEPAUHMENU__@@XZ	; DXUTState::GetMenu
	test	eax, eax
	je	SHORT $LN73@DXUTChange
	mov	DWORD PTR tv434[ebp], 1
	jmp	SHORT $LN74@DXUTChange
$LN73@DXUTChange:
	mov	DWORD PTR tv434[ebp], 0
$LN74@DXUTChange:
	mov	esi, esp
	mov	eax, DWORD PTR tv434[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetWindowedStyleAtModeChange@DXUTState@@QAEKXZ ; DXUTState::GetWindowedStyleAtModeChange
	push	eax
	lea	ecx, DWORD PTR _rcFrame$38[ebp]
	push	ecx
	call	DWORD PTR __imp__AdjustWindowRect@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2902 :                 LONG nFrameWidth = rcFrame.right - rcFrame.left;

	mov	eax, DWORD PTR _rcFrame$38[ebp+8]
	sub	eax, DWORD PTR _rcFrame$38[ebp]
	mov	DWORD PTR _nFrameWidth$37[ebp], eax

; 2903 :                 LONG nFrameHeight = rcFrame.bottom - rcFrame.top;

	mov	eax, DWORD PTR _rcFrame$38[ebp+12]
	sub	eax, DWORD PTR _rcFrame$38[ebp+4]
	mov	DWORD PTR _nFrameHeight$36[ebp], eax

; 2904 :                 nClientWidth  = (UINT)(wp.rcNormalPosition.right - wp.rcNormalPosition.left - nFrameWidth);

	mov	eax, DWORD PTR _wp$40[ebp+36]
	sub	eax, DWORD PTR _wp$40[ebp+28]
	sub	eax, DWORD PTR _nFrameWidth$37[ebp]
	mov	DWORD PTR _nClientWidth$42[ebp], eax

; 2905 :                 nClientHeight = (UINT)(wp.rcNormalPosition.bottom - wp.rcNormalPosition.top - nFrameHeight);

	mov	eax, DWORD PTR _wp$40[ebp+40]
	sub	eax, DWORD PTR _wp$40[ebp+32]
	sub	eax, DWORD PTR _nFrameHeight$36[ebp]
	mov	DWORD PTR _nClientHeight$41[ebp], eax
$LN25@DXUTChange:

; 2906 :             }
; 2907 :         }
; 2908 :         else

	jmp	SHORT $LN24@DXUTChange
$LN27@DXUTChange:

; 2909 :         {
; 2910 :             // Window is restored or maximized so just get its client rect
; 2911 :             RECT rcClient;
; 2912 :             GetClientRect( DXUTGetHWNDDeviceWindowed(), &rcClient );

	mov	esi, esp
	lea	eax, DWORD PTR _rcClient$35[ebp]
	push	eax
	call	?DXUTGetHWNDDeviceWindowed@@YAPAUHWND__@@XZ ; DXUTGetHWNDDeviceWindowed
	push	eax
	call	DWORD PTR __imp__GetClientRect@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2913 :             nClientWidth  = (UINT)(rcClient.right - rcClient.left);

	mov	eax, DWORD PTR _rcClient$35[ebp+8]
	sub	eax, DWORD PTR _rcClient$35[ebp]
	mov	DWORD PTR _nClientWidth$42[ebp], eax

; 2914 :             nClientHeight = (UINT)(rcClient.bottom - rcClient.top);

	mov	eax, DWORD PTR _rcClient$35[ebp+12]
	sub	eax, DWORD PTR _rcClient$35[ebp+4]
	mov	DWORD PTR _nClientHeight$41[ebp], eax
$LN24@DXUTChange:

; 2915 :         }
; 2916 : 
; 2917 :         // Now that we know the client rect, compare it against the back buffer size
; 2918 :         // to see if the client rect is already the right size
; 2919 :         if( nClientWidth  != pNewDeviceSettings->pp.BackBufferWidth ||
; 2920 :             nClientHeight != pNewDeviceSettings->pp.BackBufferHeight )

	mov	eax, DWORD PTR _pNewDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _nClientWidth$42[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jne	SHORT $LN22@DXUTChange
	mov	eax, DWORD PTR _pNewDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _nClientHeight$41[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	je	SHORT $LN23@DXUTChange
$LN22@DXUTChange:

; 2921 :         {
; 2922 :             bNeedToResize = true;

	mov	BYTE PTR _bNeedToResize$[ebp], 1
$LN23@DXUTChange:

; 2923 :         }       
; 2924 : 
; 2925 :         if( bClipWindowToSingleAdapter && !IsIconic(DXUTGetHWNDDeviceWindowed()) )

	movzx	eax, BYTE PTR _bClipWindowToSingleAdapter$[ebp]
	test	eax, eax
	je	$LN28@DXUTChange
	call	?DXUTGetHWNDDeviceWindowed@@YAPAUHWND__@@XZ ; DXUTGetHWNDDeviceWindowed
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__IsIconic@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	$LN28@DXUTChange

; 2926 :         {
; 2927 :             // Get the rect of the monitor attached to the adapter
; 2928 :             MONITORINFO miAdapter;
; 2929 :             miAdapter.cbSize = sizeof(MONITORINFO);

	mov	DWORD PTR _miAdapter$34[ebp], 40	; 00000028H

; 2930 :             HMONITOR hAdapterMonitor = DXUTGetD3DObject()->GetAdapterMonitor( pNewDeviceSettings->AdapterOrdinal );

	call	?DXUTGetD3DObject@@YAPAUIDirect3D9@@XZ	; DXUTGetD3DObject
	mov	DWORD PTR tv497[ebp], eax
	mov	esi, esp
	mov	eax, DWORD PTR _pNewDeviceSettings$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR tv497[ebp]
	push	edx
	mov	eax, DWORD PTR tv497[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+60]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hAdapterMonitor$33[ebp], eax

; 2931 :             GetMonitorInfo( hAdapterMonitor, &miAdapter );

	lea	eax, DWORD PTR _miAdapter$34[ebp]
	push	eax
	mov	ecx, DWORD PTR _hAdapterMonitor$33[ebp]
	push	ecx
	call	_xGetMonitorInfo@8

; 2932 :             HMONITOR hWindowMonitor = MonitorFromWindow( DXUTGetHWND(), MONITOR_DEFAULTTOPRIMARY );

	push	1
	call	?DXUTGetHWND@@YAPAUHWND__@@XZ		; DXUTGetHWND
	push	eax
	call	_xMonitorFromWindow@8
	mov	DWORD PTR _hWindowMonitor$32[ebp], eax

; 2933 : 
; 2934 :             // Get the rect of the window
; 2935 :             RECT rcWindow;
; 2936 :             GetWindowRect( DXUTGetHWNDDeviceWindowed(), &rcWindow );

	mov	esi, esp
	lea	eax, DWORD PTR _rcWindow$31[ebp]
	push	eax
	call	?DXUTGetHWNDDeviceWindowed@@YAPAUHWND__@@XZ ; DXUTGetHWNDDeviceWindowed
	push	eax
	call	DWORD PTR __imp__GetWindowRect@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2937 : 
; 2938 :             // Check if the window rect is fully inside the adapter's vitural screen rect
; 2939 :             if( (rcWindow.left   < miAdapter.rcWork.left  ||
; 2940 :                  rcWindow.right  > miAdapter.rcWork.right ||
; 2941 :                  rcWindow.top    < miAdapter.rcWork.top   ||
; 2942 :                  rcWindow.bottom > miAdapter.rcWork.bottom) )

	mov	eax, DWORD PTR _rcWindow$31[ebp]
	cmp	eax, DWORD PTR _miAdapter$34[ebp+20]
	jl	SHORT $LN19@DXUTChange
	mov	eax, DWORD PTR _rcWindow$31[ebp+8]
	cmp	eax, DWORD PTR _miAdapter$34[ebp+28]
	jg	SHORT $LN19@DXUTChange
	mov	eax, DWORD PTR _rcWindow$31[ebp+4]
	cmp	eax, DWORD PTR _miAdapter$34[ebp+24]
	jl	SHORT $LN19@DXUTChange
	mov	eax, DWORD PTR _rcWindow$31[ebp+12]
	cmp	eax, DWORD PTR _miAdapter$34[ebp+32]
	jle	SHORT $LN28@DXUTChange
$LN19@DXUTChange:

; 2943 :             {
; 2944 :                 if( hWindowMonitor == hAdapterMonitor && IsZoomed(DXUTGetHWNDDeviceWindowed()) )

	mov	eax, DWORD PTR _hWindowMonitor$32[ebp]
	cmp	eax, DWORD PTR _hAdapterMonitor$33[ebp]
	jne	SHORT $LN18@DXUTChange
	call	?DXUTGetHWNDDeviceWindowed@@YAPAUHWND__@@XZ ; DXUTGetHWNDDeviceWindowed
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__IsZoomed@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN18@DXUTChange

; 2945 :                 {
; 2946 :                     // If the window is maximized and on the same monitor as the adapter, then 
; 2947 :                     // no need to clip to single adapter as the window is already clipped 
; 2948 :                     // even though the rcWindow rect is outside of the miAdapter.rcWork
; 2949 :                 }
; 2950 :                 else

	jmp	SHORT $LN28@DXUTChange
$LN18@DXUTChange:

; 2951 :                 {
; 2952 :                     bNeedToResize = true;

	mov	BYTE PTR _bNeedToResize$[ebp], 1
$LN28@DXUTChange:

; 2953 :                 }
; 2954 :             }
; 2955 :         }
; 2956 :     }
; 2957 : 
; 2958 :     // Only resize window if needed 
; 2959 :     if( bNeedToResize ) 

	movzx	eax, BYTE PTR _bNeedToResize$[ebp]
	test	eax, eax
	je	$LN16@DXUTChange

; 2960 :     {
; 2961 :         // Need to resize, so if window is maximized or minimized then restore the window
; 2962 :         if( IsIconic(DXUTGetHWNDDeviceWindowed()) ) 

	call	?DXUTGetHWNDDeviceWindowed@@YAPAUHWND__@@XZ ; DXUTGetHWNDDeviceWindowed
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__IsIconic@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN15@DXUTChange

; 2963 :             ShowWindow( DXUTGetHWNDDeviceWindowed(), SW_RESTORE );

	mov	esi, esp
	push	9
	call	?DXUTGetHWNDDeviceWindowed@@YAPAUHWND__@@XZ ; DXUTGetHWNDDeviceWindowed
	push	eax
	call	DWORD PTR __imp__ShowWindow@8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN15@DXUTChange:

; 2964 :         if( IsZoomed(DXUTGetHWNDDeviceWindowed()) ) // doing the IsIconic() check first also handles the WPF_RESTORETOMAXIMIZED case

	call	?DXUTGetHWNDDeviceWindowed@@YAPAUHWND__@@XZ ; DXUTGetHWNDDeviceWindowed
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__IsZoomed@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN14@DXUTChange

; 2965 :             ShowWindow( DXUTGetHWNDDeviceWindowed(), SW_RESTORE );

	mov	esi, esp
	push	9
	call	?DXUTGetHWNDDeviceWindowed@@YAPAUHWND__@@XZ ; DXUTGetHWNDDeviceWindowed
	push	eax
	call	DWORD PTR __imp__ShowWindow@8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN14@DXUTChange:

; 2966 : 
; 2967 :         if( bClipWindowToSingleAdapter )

	movzx	eax, BYTE PTR _bClipWindowToSingleAdapter$[ebp]
	test	eax, eax
	je	$LN13@DXUTChange

; 2968 :         {
; 2969 :             // Get the rect of the monitor attached to the adapter
; 2970 :             MONITORINFO miAdapter;
; 2971 :             miAdapter.cbSize = sizeof(MONITORINFO);

	mov	DWORD PTR _miAdapter$30[ebp], 40	; 00000028H

; 2972 :             GetMonitorInfo( DXUTGetD3DObject()->GetAdapterMonitor( pNewDeviceSettings->AdapterOrdinal ), &miAdapter );

	call	?DXUTGetD3DObject@@YAPAUIDirect3D9@@XZ	; DXUTGetD3DObject
	mov	DWORD PTR tv543[ebp], eax
	lea	eax, DWORD PTR _miAdapter$30[ebp]
	push	eax
	mov	esi, esp
	mov	ecx, DWORD PTR _pNewDeviceSettings$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR tv543[ebp]
	push	eax
	mov	ecx, DWORD PTR tv543[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+60]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	_xGetMonitorInfo@8

; 2973 : 
; 2974 :             // Get the rect of the monitor attached to the window
; 2975 :             MONITORINFO miWindow;
; 2976 :             miWindow.cbSize = sizeof(MONITORINFO);

	mov	DWORD PTR _miWindow$29[ebp], 40		; 00000028H

; 2977 :             GetMonitorInfo( MonitorFromWindow( DXUTGetHWND(), MONITOR_DEFAULTTOPRIMARY ), &miWindow );

	lea	eax, DWORD PTR _miWindow$29[ebp]
	push	eax
	push	1
	call	?DXUTGetHWND@@YAPAUHWND__@@XZ		; DXUTGetHWND
	push	eax
	call	_xMonitorFromWindow@8
	push	eax
	call	_xGetMonitorInfo@8

; 2978 : 
; 2979 :             // Do something reasonable if the BackBuffer size is greater than the monitor size
; 2980 :             int nAdapterMonitorWidth = miAdapter.rcWork.right - miAdapter.rcWork.left;

	mov	eax, DWORD PTR _miAdapter$30[ebp+28]
	sub	eax, DWORD PTR _miAdapter$30[ebp+20]
	mov	DWORD PTR _nAdapterMonitorWidth$28[ebp], eax

; 2981 :             int nAdapterMonitorHeight = miAdapter.rcWork.bottom - miAdapter.rcWork.top;

	mov	eax, DWORD PTR _miAdapter$30[ebp+32]
	sub	eax, DWORD PTR _miAdapter$30[ebp+24]
	mov	DWORD PTR _nAdapterMonitorHeight$27[ebp], eax

; 2982 : 
; 2983 :             int nClientWidth = pNewDeviceSettings->pp.BackBufferWidth;

	mov	eax, DWORD PTR _pNewDeviceSettings$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _nClientWidth$26[ebp], ecx

; 2984 :             int nClientHeight = pNewDeviceSettings->pp.BackBufferHeight;

	mov	eax, DWORD PTR _pNewDeviceSettings$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _nClientHeight$25[ebp], ecx

; 2985 : 
; 2986 :             // Get the rect of the window
; 2987 :             RECT rcWindow;
; 2988 :             GetWindowRect( DXUTGetHWNDDeviceWindowed(), &rcWindow );

	mov	esi, esp
	lea	eax, DWORD PTR _rcWindow$24[ebp]
	push	eax
	call	?DXUTGetHWNDDeviceWindowed@@YAPAUHWND__@@XZ ; DXUTGetHWNDDeviceWindowed
	push	eax
	call	DWORD PTR __imp__GetWindowRect@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2989 : 
; 2990 :             // Make a window rect with a client rect that is the same size as the backbuffer
; 2991 :             RECT rcResizedWindow;
; 2992 :             rcResizedWindow.left = 0;

	mov	DWORD PTR _rcResizedWindow$23[ebp], 0

; 2993 :             rcResizedWindow.right = nClientWidth;

	mov	eax, DWORD PTR _nClientWidth$26[ebp]
	mov	DWORD PTR _rcResizedWindow$23[ebp+8], eax

; 2994 :             rcResizedWindow.top = 0;

	mov	DWORD PTR _rcResizedWindow$23[ebp+4], 0

; 2995 :             rcResizedWindow.bottom = nClientHeight;

	mov	eax, DWORD PTR _nClientHeight$25[ebp]
	mov	DWORD PTR _rcResizedWindow$23[ebp+12], eax

; 2996 :             AdjustWindowRect( &rcResizedWindow, GetWindowLong( DXUTGetHWNDDeviceWindowed(), GWL_STYLE ), GetDXUTState().GetMenu() != NULL );

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetMenu@DXUTState@@QAEPAUHMENU__@@XZ	; DXUTState::GetMenu
	test	eax, eax
	je	SHORT $LN75@DXUTChange
	mov	DWORD PTR tv601[ebp], 1
	jmp	SHORT $LN76@DXUTChange
$LN75@DXUTChange:
	mov	DWORD PTR tv601[ebp], 0
$LN76@DXUTChange:
	mov	esi, esp
	mov	eax, DWORD PTR tv601[ebp]
	push	eax
	mov	edi, esp
	push	-16					; fffffff0H
	call	?DXUTGetHWNDDeviceWindowed@@YAPAUHWND__@@XZ ; DXUTGetHWNDDeviceWindowed
	push	eax
	call	DWORD PTR __imp__GetWindowLongA@8
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	lea	ecx, DWORD PTR _rcResizedWindow$23[ebp]
	push	ecx
	call	DWORD PTR __imp__AdjustWindowRect@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2997 : 
; 2998 :             int nWindowWidth = rcResizedWindow.right - rcResizedWindow.left;

	mov	eax, DWORD PTR _rcResizedWindow$23[ebp+8]
	sub	eax, DWORD PTR _rcResizedWindow$23[ebp]
	mov	DWORD PTR _nWindowWidth$22[ebp], eax

; 2999 :             int nWindowHeight = rcResizedWindow.bottom - rcResizedWindow.top;

	mov	eax, DWORD PTR _rcResizedWindow$23[ebp+12]
	sub	eax, DWORD PTR _rcResizedWindow$23[ebp+4]
	mov	DWORD PTR _nWindowHeight$21[ebp], eax

; 3000 : 
; 3001 :             if( nWindowWidth > nAdapterMonitorWidth )

	mov	eax, DWORD PTR _nWindowWidth$22[ebp]
	cmp	eax, DWORD PTR _nAdapterMonitorWidth$28[ebp]
	jle	SHORT $LN12@DXUTChange

; 3002 :                 nWindowWidth = (nAdapterMonitorWidth - 0);

	mov	eax, DWORD PTR _nAdapterMonitorWidth$28[ebp]
	mov	DWORD PTR _nWindowWidth$22[ebp], eax
$LN12@DXUTChange:

; 3003 :             if( nWindowHeight > nAdapterMonitorHeight )

	mov	eax, DWORD PTR _nWindowHeight$21[ebp]
	cmp	eax, DWORD PTR _nAdapterMonitorHeight$27[ebp]
	jle	SHORT $LN11@DXUTChange

; 3004 :                 nWindowHeight = (nAdapterMonitorHeight - 0);

	mov	eax, DWORD PTR _nAdapterMonitorHeight$27[ebp]
	mov	DWORD PTR _nWindowHeight$21[ebp], eax
$LN11@DXUTChange:

; 3005 : 
; 3006 :             if( rcResizedWindow.left < miAdapter.rcWork.left ||
; 3007 :                 rcResizedWindow.top < miAdapter.rcWork.top ||
; 3008 :                 rcResizedWindow.right > miAdapter.rcWork.right ||
; 3009 :                 rcResizedWindow.bottom > miAdapter.rcWork.bottom )

	mov	eax, DWORD PTR _rcResizedWindow$23[ebp]
	cmp	eax, DWORD PTR _miAdapter$30[ebp+20]
	jl	SHORT $LN9@DXUTChange
	mov	eax, DWORD PTR _rcResizedWindow$23[ebp+4]
	cmp	eax, DWORD PTR _miAdapter$30[ebp+24]
	jl	SHORT $LN9@DXUTChange
	mov	eax, DWORD PTR _rcResizedWindow$23[ebp+8]
	cmp	eax, DWORD PTR _miAdapter$30[ebp+28]
	jg	SHORT $LN9@DXUTChange
	mov	eax, DWORD PTR _rcResizedWindow$23[ebp+12]
	cmp	eax, DWORD PTR _miAdapter$30[ebp+32]
	jle	$LN10@DXUTChange
$LN9@DXUTChange:

; 3010 :             {
; 3011 :                 int nWindowOffsetX = (nAdapterMonitorWidth - nWindowWidth) / 2;

	mov	eax, DWORD PTR _nAdapterMonitorWidth$28[ebp]
	sub	eax, DWORD PTR _nWindowWidth$22[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _nWindowOffsetX$20[ebp], eax

; 3012 :                 int nWindowOffsetY = (nAdapterMonitorHeight - nWindowHeight) / 2;

	mov	eax, DWORD PTR _nAdapterMonitorHeight$27[ebp]
	sub	eax, DWORD PTR _nWindowHeight$21[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _nWindowOffsetY$19[ebp], eax

; 3013 : 
; 3014 :                 rcResizedWindow.left = miAdapter.rcWork.left + nWindowOffsetX;

	mov	eax, DWORD PTR _miAdapter$30[ebp+20]
	add	eax, DWORD PTR _nWindowOffsetX$20[ebp]
	mov	DWORD PTR _rcResizedWindow$23[ebp], eax

; 3015 :                 rcResizedWindow.top = miAdapter.rcWork.top + nWindowOffsetY;

	mov	eax, DWORD PTR _miAdapter$30[ebp+24]
	add	eax, DWORD PTR _nWindowOffsetY$19[ebp]
	mov	DWORD PTR _rcResizedWindow$23[ebp+4], eax

; 3016 :                 rcResizedWindow.right = miAdapter.rcWork.left + nWindowOffsetX + nWindowWidth;

	mov	eax, DWORD PTR _miAdapter$30[ebp+20]
	add	eax, DWORD PTR _nWindowOffsetX$20[ebp]
	add	eax, DWORD PTR _nWindowWidth$22[ebp]
	mov	DWORD PTR _rcResizedWindow$23[ebp+8], eax

; 3017 :                 rcResizedWindow.bottom = miAdapter.rcWork.top + nWindowOffsetY + nWindowHeight;

	mov	eax, DWORD PTR _miAdapter$30[ebp+24]
	add	eax, DWORD PTR _nWindowOffsetY$19[ebp]
	add	eax, DWORD PTR _nWindowHeight$21[ebp]
	mov	DWORD PTR _rcResizedWindow$23[ebp+12], eax
$LN10@DXUTChange:

; 3018 :             }
; 3019 : 
; 3020 :             // Resize the window.  It is important to adjust the window size 
; 3021 :             // after resetting the device rather than beforehand to ensure 
; 3022 :             // that the monitor resolution is correct and does not limit the size of the new window.
; 3023 :             SetWindowPos( DXUTGetHWNDDeviceWindowed(), 0, rcResizedWindow.left, rcResizedWindow.top, nWindowWidth, nWindowHeight, SWP_NOZORDER );

	mov	esi, esp
	push	4
	mov	eax, DWORD PTR _nWindowHeight$21[ebp]
	push	eax
	mov	ecx, DWORD PTR _nWindowWidth$22[ebp]
	push	ecx
	mov	edx, DWORD PTR _rcResizedWindow$23[ebp+4]
	push	edx
	mov	eax, DWORD PTR _rcResizedWindow$23[ebp]
	push	eax
	push	0
	call	?DXUTGetHWNDDeviceWindowed@@YAPAUHWND__@@XZ ; DXUTGetHWNDDeviceWindowed
	push	eax
	call	DWORD PTR __imp__SetWindowPos@28
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3024 :         }        
; 3025 :         else

	jmp	$LN8@DXUTChange
$LN13@DXUTChange:

; 3026 :         {      
; 3027 :             // Make a window rect with a client rect that is the same size as the backbuffer
; 3028 :             RECT rcWindow = {0};

	mov	DWORD PTR _rcWindow$18[ebp], 0
	xor	eax, eax
	mov	DWORD PTR _rcWindow$18[ebp+4], eax
	mov	DWORD PTR _rcWindow$18[ebp+8], eax
	mov	DWORD PTR _rcWindow$18[ebp+12], eax

; 3029 :             rcWindow.right = (long)(pNewDeviceSettings->pp.BackBufferWidth);

	mov	eax, DWORD PTR _pNewDeviceSettings$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _rcWindow$18[ebp+8], ecx

; 3030 :             rcWindow.bottom = (long)(pNewDeviceSettings->pp.BackBufferHeight);

	mov	eax, DWORD PTR _pNewDeviceSettings$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _rcWindow$18[ebp+12], ecx

; 3031 :             AdjustWindowRect( &rcWindow, GetWindowLong( DXUTGetHWNDDeviceWindowed(), GWL_STYLE ), GetDXUTState().GetMenu() != NULL );

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetMenu@DXUTState@@QAEPAUHMENU__@@XZ	; DXUTState::GetMenu
	test	eax, eax
	je	SHORT $LN77@DXUTChange
	mov	DWORD PTR tv678[ebp], 1
	jmp	SHORT $LN78@DXUTChange
$LN77@DXUTChange:
	mov	DWORD PTR tv678[ebp], 0
$LN78@DXUTChange:
	mov	esi, esp
	mov	eax, DWORD PTR tv678[ebp]
	push	eax
	mov	edi, esp
	push	-16					; fffffff0H
	call	?DXUTGetHWNDDeviceWindowed@@YAPAUHWND__@@XZ ; DXUTGetHWNDDeviceWindowed
	push	eax
	call	DWORD PTR __imp__GetWindowLongA@8
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	lea	ecx, DWORD PTR _rcWindow$18[ebp]
	push	ecx
	call	DWORD PTR __imp__AdjustWindowRect@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3032 : 
; 3033 :             // Resize the window.  It is important to adjust the window size 
; 3034 :             // after resetting the device rather than beforehand to ensure 
; 3035 :             // that the monitor resolution is correct and does not limit the size of the new window.
; 3036 :             int cx = (int)(rcWindow.right - rcWindow.left);

	mov	eax, DWORD PTR _rcWindow$18[ebp+8]
	sub	eax, DWORD PTR _rcWindow$18[ebp]
	mov	DWORD PTR _cx$17[ebp], eax

; 3037 :             int cy = (int)(rcWindow.bottom - rcWindow.top);

	mov	eax, DWORD PTR _rcWindow$18[ebp+12]
	sub	eax, DWORD PTR _rcWindow$18[ebp+4]
	mov	DWORD PTR _cy$16[ebp], eax

; 3038 :             SetWindowPos( DXUTGetHWNDDeviceWindowed(), 0, 0, 0, cx, cy, SWP_NOZORDER|SWP_NOMOVE );

	mov	esi, esp
	push	6
	mov	eax, DWORD PTR _cy$16[ebp]
	push	eax
	mov	ecx, DWORD PTR _cx$17[ebp]
	push	ecx
	push	0
	push	0
	push	0
	call	?DXUTGetHWNDDeviceWindowed@@YAPAUHWND__@@XZ ; DXUTGetHWNDDeviceWindowed
	push	eax
	call	DWORD PTR __imp__SetWindowPos@28
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN8@DXUTChange:

; 3039 :         }
; 3040 : 
; 3041 :         // Its possible that the new window size is not what we asked for.  
; 3042 :         // No window can be sized larger than the desktop, so see see if the Windows OS resized the 
; 3043 :         // window to something smaller to fit on the desktop.  Also if WM_GETMINMAXINFO
; 3044 :         // will put a limit on the smallest/largest window size.
; 3045 :         RECT rcClient;
; 3046 :         GetClientRect( DXUTGetHWNDDeviceWindowed(), &rcClient );

	mov	esi, esp
	lea	eax, DWORD PTR _rcClient$15[ebp]
	push	eax
	call	?DXUTGetHWNDDeviceWindowed@@YAPAUHWND__@@XZ ; DXUTGetHWNDDeviceWindowed
	push	eax
	call	DWORD PTR __imp__GetClientRect@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3047 :         UINT nClientWidth  = (UINT)(rcClient.right - rcClient.left);

	mov	eax, DWORD PTR _rcClient$15[ebp+8]
	sub	eax, DWORD PTR _rcClient$15[ebp]
	mov	DWORD PTR _nClientWidth$14[ebp], eax

; 3048 :         UINT nClientHeight = (UINT)(rcClient.bottom - rcClient.top);

	mov	eax, DWORD PTR _rcClient$15[ebp+12]
	sub	eax, DWORD PTR _rcClient$15[ebp+4]
	mov	DWORD PTR _nClientHeight$13[ebp], eax

; 3049 :         if( nClientWidth  != pNewDeviceSettings->pp.BackBufferWidth ||
; 3050 :             nClientHeight != pNewDeviceSettings->pp.BackBufferHeight )

	mov	eax, DWORD PTR _pNewDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _nClientWidth$14[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jne	SHORT $LN6@DXUTChange
	mov	eax, DWORD PTR _pNewDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _nClientHeight$13[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	je	$LN16@DXUTChange
$LN6@DXUTChange:

; 3051 :         {
; 3052 :             // If its different, then resize the backbuffer again.  This time create a backbuffer that matches the 
; 3053 :             // client rect of the current window w/o resizing the window.
; 3054 :             DXUTDeviceSettings deviceSettings = DXUTGetDeviceSettings();

	lea	eax, DWORD PTR $T9[ebp]
	push	eax
	call	?DXUTGetDeviceSettings@@YA?AUDXUTDeviceSettings@@XZ ; DXUTGetDeviceSettings
	add	esp, 4
	mov	ecx, 18					; 00000012H
	mov	esi, eax
	lea	edi, DWORD PTR $T8[ebp]
	rep movsd
	mov	ecx, 18					; 00000012H
	lea	esi, DWORD PTR $T8[ebp]
	lea	edi, DWORD PTR _deviceSettings$12[ebp]
	rep movsd

; 3055 :             deviceSettings.pp.BackBufferWidth  = 0; 

	mov	DWORD PTR _deviceSettings$12[ebp+16], 0

; 3056 :             deviceSettings.pp.BackBufferHeight = 0;

	mov	DWORD PTR _deviceSettings$12[ebp+20], 0

; 3057 :             hr = DXUTChangeDevice( &deviceSettings, NULL, false, bClipWindowToSingleAdapter );

	movzx	eax, BYTE PTR _bClipWindowToSingleAdapter$[ebp]
	push	eax
	push	0
	push	0
	lea	ecx, DWORD PTR _deviceSettings$12[ebp]
	push	ecx
	call	?DXUTChangeDevice@@YAJPAUDXUTDeviceSettings@@PAUIDirect3DDevice9@@_N2@Z ; DXUTChangeDevice
	add	esp, 16					; 00000010H
	mov	DWORD PTR _hr$[ebp], eax

; 3058 :             if( FAILED( hr ) )

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN16@DXUTChange

; 3059 :             {
; 3060 :                 SAFE_DELETE( pOldDeviceSettings );

	cmp	DWORD PTR _pOldDeviceSettings$[ebp], 0
	je	SHORT $LN4@DXUTChange
	mov	eax, DWORD PTR _pOldDeviceSettings$[ebp]
	mov	DWORD PTR $T10[ebp], eax
	mov	ecx, DWORD PTR $T10[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	DWORD PTR _pOldDeviceSettings$[ebp], 0
$LN4@DXUTChange:

; 3061 :                 DXUTCleanup3DEnvironment();

	push	1
	call	?DXUTCleanup3DEnvironment@@YAX_N@Z	; DXUTCleanup3DEnvironment
	add	esp, 4

; 3062 :                 DXUTPause( false, false );

	push	0
	push	0
	call	?DXUTPause@@YAX_N0@Z			; DXUTPause
	add	esp, 8

; 3063 :                 GetDXUTState().SetIgnoreSizeChange( false );

	push	0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetIgnoreSizeChange@DXUTState@@QAEX_N@Z ; DXUTState::SetIgnoreSizeChange

; 3064 :                 return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	jmp	$LN67@DXUTChange
$LN16@DXUTChange:

; 3065 :             }
; 3066 :         }
; 3067 :     }
; 3068 : 
; 3069 :     // Make the window visible
; 3070 :     if( !IsWindowVisible( DXUTGetHWND() ) )

	call	?DXUTGetHWND@@YAPAUHWND__@@XZ		; DXUTGetHWND
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__IsWindowVisible@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN3@DXUTChange

; 3071 :         ShowWindow( DXUTGetHWND(), SW_SHOW );

	mov	esi, esp
	push	5
	call	?DXUTGetHWND@@YAPAUHWND__@@XZ		; DXUTGetHWND
	push	eax
	call	DWORD PTR __imp__ShowWindow@8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@DXUTChange:

; 3072 : 
; 3073 :     // Show/hide the HW cursor after the window is its proper place if the application requested it
; 3074 :     if( GetDXUTState().GetShowCursorWhenFullScreen() )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetShowCursorWhenFullScreen@DXUTState@@QAE_NXZ ; DXUTState::GetShowCursorWhenFullScreen
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@DXUTChange

; 3075 :         DXUTInitHWCursor();

	call	?DXUTInitHWCursor@@YAXXZ		; DXUTInitHWCursor
$LN2@DXUTChange:

; 3076 : 
; 3077 :     SAFE_DELETE( pOldDeviceSettings );

	cmp	DWORD PTR _pOldDeviceSettings$[ebp], 0
	je	SHORT $LN1@DXUTChange
	mov	eax, DWORD PTR _pOldDeviceSettings$[ebp]
	mov	DWORD PTR $T11[ebp], eax
	mov	ecx, DWORD PTR $T11[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	DWORD PTR _pOldDeviceSettings$[ebp], 0
$LN1@DXUTChange:

; 3078 :     GetDXUTState().SetIgnoreSizeChange( false );

	push	0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetIgnoreSizeChange@DXUTState@@QAEX_N@Z ; DXUTState::SetIgnoreSizeChange

; 3079 :     DXUTPause( false, false );

	push	0
	push	0
	call	?DXUTPause@@YAX_N0@Z			; DXUTPause
	add	esp, 8

; 3080 :     GetDXUTState().SetDeviceCreated( true );

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetDeviceCreated@DXUTState@@QAEX_N@Z	; DXUTState::SetDeviceCreated

; 3081 : 
; 3082 :     return S_OK;

	xor	eax, eax
$LN67@DXUTChange:

; 3083 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN95@DXUTChange
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 1696				; 000006a0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN95@DXUTChange:
	DD	15					; 0000000fH
	DD	$LN94@DXUTChange
$LN94@DXUTChange:
	DD	-360					; fffffe98H
	DD	304					; 00000130H
	DD	$LN79@DXUTChange
	DD	-484					; fffffe1cH
	DD	44					; 0000002cH
	DD	$LN80@DXUTChange
	DD	-620					; fffffd94H
	DD	44					; 0000002cH
	DD	$LN81@DXUTChange
	DD	-644					; fffffd7cH
	DD	16					; 00000010H
	DD	$LN82@DXUTChange
	DD	-668					; fffffd64H
	DD	16					; 00000010H
	DD	$LN83@DXUTChange
	DD	-716					; fffffd34H
	DD	16					; 00000010H
	DD	$LN84@DXUTChange
	DD	-764					; fffffd04H
	DD	40					; 00000028H
	DD	$LN85@DXUTChange
	DD	-812					; fffffcd4H
	DD	16					; 00000010H
	DD	$LN86@DXUTChange
	DD	-860					; fffffca4H
	DD	40					; 00000028H
	DD	$LN87@DXUTChange
	DD	-908					; fffffc74H
	DD	40					; 00000028H
	DD	$LN88@DXUTChange
	DD	-980					; fffffc2cH
	DD	16					; 00000010H
	DD	$LN89@DXUTChange
	DD	-1004					; fffffc14H
	DD	16					; 00000010H
	DD	$LN90@DXUTChange
	DD	-1076					; fffffbccH
	DD	16					; 00000010H
	DD	$LN91@DXUTChange
	DD	-1124					; fffffb9cH
	DD	16					; 00000010H
	DD	$LN92@DXUTChange
	DD	-1228					; fffffb34H
	DD	72					; 00000048H
	DD	$LN93@DXUTChange
$LN93@DXUTChange:
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	118					; 00000076H
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	83					; 00000053H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	115					; 00000073H
	DB	0
$LN92@DXUTChange:
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	67					; 00000043H
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
$LN91@DXUTChange:
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	87					; 00000057H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	111					; 0000006fH
	DB	119					; 00000077H
	DB	0
$LN90@DXUTChange:
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	82					; 00000052H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	87					; 00000057H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	111					; 0000006fH
	DB	119					; 00000077H
	DB	0
$LN89@DXUTChange:
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	87					; 00000057H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	111					; 0000006fH
	DB	119					; 00000077H
	DB	0
$LN88@DXUTChange:
	DB	109					; 0000006dH
	DB	105					; 00000069H
	DB	87					; 00000057H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	111					; 0000006fH
	DB	119					; 00000077H
	DB	0
$LN87@DXUTChange:
	DB	109					; 0000006dH
	DB	105					; 00000069H
	DB	65					; 00000041H
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$LN86@DXUTChange:
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	87					; 00000057H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	111					; 0000006fH
	DB	119					; 00000077H
	DB	0
$LN85@DXUTChange:
	DB	109					; 0000006dH
	DB	105					; 00000069H
	DB	65					; 00000041H
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$LN84@DXUTChange:
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	67					; 00000043H
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
$LN83@DXUTChange:
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	70					; 00000046H
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$LN82@DXUTChange:
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	67					; 00000043H
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
$LN81@DXUTChange:
	DB	119					; 00000077H
	DB	112					; 00000070H
	DB	0
$LN80@DXUTChange:
	DB	119					; 00000077H
	DB	112					; 00000070H
	DB	70					; 00000046H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	115					; 00000073H
	DB	99					; 00000063H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$LN79@DXUTChange:
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	115					; 00000073H
	DB	0
?DXUTChangeDevice@@YAJPAUDXUTDeviceSettings@@PAUIDirect3DDevice9@@_N2@Z ENDP ; DXUTChangeDevice
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTFindAdapterFormat@@YAJIW4_D3DDEVTYPE@@W4_D3DFORMAT@@HPAW42@@Z
_TEXT	SEGMENT
_pDeviceSettingsCombo$1 = -44				; size = 4
_iDeviceCombo$2 = -32					; size = 4
_pDeviceInfo$ = -20					; size = 4
_pd3dEnum$ = -8						; size = 4
_AdapterOrdinal$ = 8					; size = 4
_DeviceType$ = 12					; size = 4
_BackBufferFormat$ = 16					; size = 4
_Windowed$ = 20						; size = 4
_pAdapterFormat$ = 24					; size = 4
?DXUTFindAdapterFormat@@YAJIW4_D3DDEVTYPE@@W4_D3DFORMAT@@HPAW42@@Z PROC ; DXUTFindAdapterFormat, COMDAT

; 2598 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2599 :     CD3DEnumeration* pd3dEnum = DXUTPrepareEnumerationObject();

	push	0
	call	?DXUTPrepareEnumerationObject@@YAPAVCD3DEnumeration@@_N@Z ; DXUTPrepareEnumerationObject
	add	esp, 4
	mov	DWORD PTR _pd3dEnum$[ebp], eax

; 2600 :     CD3DEnumDeviceInfo* pDeviceInfo = pd3dEnum->GetDeviceInfo( AdapterOrdinal, DeviceType );

	mov	eax, DWORD PTR _DeviceType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _AdapterOrdinal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pd3dEnum$[ebp]
	call	?GetDeviceInfo@CD3DEnumeration@@QAEPAVCD3DEnumDeviceInfo@@IW4_D3DDEVTYPE@@@Z ; CD3DEnumeration::GetDeviceInfo
	mov	DWORD PTR _pDeviceInfo$[ebp], eax

; 2601 :     if( pDeviceInfo )

	cmp	DWORD PTR _pDeviceInfo$[ebp], 0
	je	SHORT $LN5@DXUTFindAd

; 2602 :     {
; 2603 :         for( int iDeviceCombo=0; iDeviceCombo<pDeviceInfo->deviceSettingsComboList.GetSize(); iDeviceCombo++ )

	mov	DWORD PTR _iDeviceCombo$2[ebp], 0
	jmp	SHORT $LN4@DXUTFindAd
$LN3@DXUTFindAd:
	mov	eax, DWORD PTR _iDeviceCombo$2[ebp]
	add	eax, 1
	mov	DWORD PTR _iDeviceCombo$2[ebp], eax
$LN4@DXUTFindAd:
	mov	ecx, DWORD PTR _pDeviceInfo$[ebp]
	add	ecx, 312				; 00000138H
	call	?GetSize@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QBEHXZ ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::GetSize
	cmp	DWORD PTR _iDeviceCombo$2[ebp], eax
	jge	SHORT $LN5@DXUTFindAd

; 2604 :         {
; 2605 :             CD3DEnumDeviceSettingsCombo* pDeviceSettingsCombo = pDeviceInfo->deviceSettingsComboList.GetAt(iDeviceCombo);

	mov	eax, DWORD PTR _iDeviceCombo$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeviceInfo$[ebp]
	add	ecx, 312				; 00000138H
	call	?GetAt@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QAEAAPAUCD3DEnumDeviceSettingsCombo@@H@Z ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::GetAt
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pDeviceSettingsCombo$1[ebp], ecx

; 2606 :             if( pDeviceSettingsCombo->BackBufferFormat == BackBufferFormat &&
; 2607 :                 pDeviceSettingsCombo->Windowed == Windowed )

	mov	eax, DWORD PTR _pDeviceSettingsCombo$1[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR _BackBufferFormat$[ebp]
	jne	SHORT $LN1@DXUTFindAd
	mov	eax, DWORD PTR _pDeviceSettingsCombo$1[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR _Windowed$[ebp]
	jne	SHORT $LN1@DXUTFindAd

; 2608 :             {
; 2609 :                 // Return the adapter format from the first match
; 2610 :                 *pAdapterFormat = pDeviceSettingsCombo->AdapterFormat;

	mov	eax, DWORD PTR _pAdapterFormat$[ebp]
	mov	ecx, DWORD PTR _pDeviceSettingsCombo$1[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], edx

; 2611 :                 return S_OK;

	xor	eax, eax
	jmp	SHORT $LN6@DXUTFindAd
$LN1@DXUTFindAd:

; 2612 :             }
; 2613 :         }

	jmp	SHORT $LN3@DXUTFindAd
$LN5@DXUTFindAd:

; 2614 :     }
; 2615 : 
; 2616 :     *pAdapterFormat = BackBufferFormat;

	mov	eax, DWORD PTR _pAdapterFormat$[ebp]
	mov	ecx, DWORD PTR _BackBufferFormat$[ebp]
	mov	DWORD PTR [eax], ecx

; 2617 :     return E_FAIL;

	mov	eax, -2147467259			; 80004005H
$LN6@DXUTFindAd:

; 2618 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTFindAdapterFormat@@YAJIW4_D3DDEVTYPE@@W4_D3DFORMAT@@HPAW42@@Z ENDP ; DXUTFindAdapterFormat
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTFindValidResolution@@YAJPAUCD3DEnumDeviceSettingsCombo@@U_D3DDISPLAYMODE@@PAU2@@Z
_TEXT	SEGMENT
_displayMode$1 = -96					; size = 16
_iDisplayMode$2 = -72					; size = 4
_pDisplayModeList$3 = -60				; size = 4
_nCurRanking$4 = -48					; size = 4
_nBestRanking$5 = -36					; size = 4
_bestDisplayMode$ = -24					; size = 16
__$ArrayPad$ = -4					; size = 4
_pBestDeviceSettingsCombo$ = 8				; size = 4
_displayModeIn$ = 12					; size = 16
_pBestDisplayMode$ = 28					; size = 4
?DXUTFindValidResolution@@YAJPAUCD3DEnumDeviceSettingsCombo@@U_D3DDISPLAYMODE@@PAU2@@Z PROC ; DXUTFindValidResolution, COMDAT

; 2541 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-292]
	mov	ecx, 73					; 00000049H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2542 :     D3DDISPLAYMODE bestDisplayMode;
; 2543 :     ZeroMemory( &bestDisplayMode, sizeof(D3DDISPLAYMODE) );

	push	16					; 00000010H
	push	0
	lea	eax, DWORD PTR _bestDisplayMode$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2544 :     
; 2545 :     if( pBestDeviceSettingsCombo->Windowed )

	mov	eax, DWORD PTR _pBestDeviceSettingsCombo$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN9@DXUTFindVa

; 2546 :     {
; 2547 :         // In windowed mode, all resolutions are valid but restritions still apply 
; 2548 :         // on the size of the window.  See DXUTChangeDevice() for details
; 2549 :         *pBestDisplayMode = displayModeIn;

	mov	eax, DWORD PTR _pBestDisplayMode$[ebp]
	mov	ecx, DWORD PTR _displayModeIn$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _displayModeIn$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _displayModeIn$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _displayModeIn$[ebp+12]
	mov	DWORD PTR [eax+12], edx

; 2550 :     }
; 2551 :     else

	jmp	$LN8@DXUTFindVa
$LN9@DXUTFindVa:

; 2552 :     {
; 2553 :         int nBestRanking = 100000;

	mov	DWORD PTR _nBestRanking$5[ebp], 100000	; 000186a0H

; 2554 :         int nCurRanking;
; 2555 :         CGrowableArray<D3DDISPLAYMODE>* pDisplayModeList = &pBestDeviceSettingsCombo->pAdapterInfo->displayModeList;

	mov	eax, DWORD PTR _pBestDeviceSettingsCombo$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	add	ecx, 1360				; 00000550H
	mov	DWORD PTR _pDisplayModeList$3[ebp], ecx

; 2556 :         for( int iDisplayMode=0; iDisplayMode<pDisplayModeList->GetSize(); iDisplayMode++ )

	mov	DWORD PTR _iDisplayMode$2[ebp], 0
	jmp	SHORT $LN7@DXUTFindVa
$LN6@DXUTFindVa:
	mov	eax, DWORD PTR _iDisplayMode$2[ebp]
	add	eax, 1
	mov	DWORD PTR _iDisplayMode$2[ebp], eax
$LN7@DXUTFindVa:
	mov	ecx, DWORD PTR _pDisplayModeList$3[ebp]
	call	?GetSize@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QBEHXZ ; CGrowableArray<_D3DDISPLAYMODE>::GetSize
	cmp	DWORD PTR _iDisplayMode$2[ebp], eax
	jge	$LN5@DXUTFindVa

; 2557 :         {
; 2558 :             D3DDISPLAYMODE displayMode = pDisplayModeList->GetAt(iDisplayMode);

	mov	eax, DWORD PTR _iDisplayMode$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDisplayModeList$3[ebp]
	call	?GetAt@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAEAAU_D3DDISPLAYMODE@@H@Z ; CGrowableArray<_D3DDISPLAYMODE>::GetAt
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _displayMode$1[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _displayMode$1[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _displayMode$1[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _displayMode$1[ebp+12], edx

; 2559 : 
; 2560 :             // Skip display modes that don't match the combo's adapter format
; 2561 :             if( displayMode.Format != pBestDeviceSettingsCombo->AdapterFormat )

	mov	eax, DWORD PTR _pBestDeviceSettingsCombo$[ebp]
	mov	ecx, DWORD PTR _displayMode$1[ebp+12]
	cmp	ecx, DWORD PTR [eax+8]
	je	SHORT $LN4@DXUTFindVa

; 2562 :                 continue;

	jmp	SHORT $LN6@DXUTFindVa
$LN4@DXUTFindVa:

; 2563 : 
; 2564 :             // Find the delta between the current width/height and the optimal width/height
; 2565 :             nCurRanking = abs((int)displayMode.Width - (int)displayModeIn.Width) + 
; 2566 :                           abs((int)displayMode.Height- (int)displayModeIn.Height);

	mov	eax, DWORD PTR _displayMode$1[ebp]
	sub	eax, DWORD PTR _displayModeIn$[ebp]
	push	eax
	call	_abs
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _displayMode$1[ebp+4]
	sub	ecx, DWORD PTR _displayModeIn$[ebp+4]
	push	ecx
	call	_abs
	add	esp, 4
	add	esi, eax
	mov	DWORD PTR _nCurRanking$4[ebp], esi

; 2567 : 
; 2568 :             if( nCurRanking < nBestRanking )

	mov	eax, DWORD PTR _nCurRanking$4[ebp]
	cmp	eax, DWORD PTR _nBestRanking$5[ebp]
	jge	SHORT $LN3@DXUTFindVa

; 2569 :             {
; 2570 :                 bestDisplayMode = displayMode;

	mov	eax, DWORD PTR _displayMode$1[ebp]
	mov	DWORD PTR _bestDisplayMode$[ebp], eax
	mov	ecx, DWORD PTR _displayMode$1[ebp+4]
	mov	DWORD PTR _bestDisplayMode$[ebp+4], ecx
	mov	edx, DWORD PTR _displayMode$1[ebp+8]
	mov	DWORD PTR _bestDisplayMode$[ebp+8], edx
	mov	eax, DWORD PTR _displayMode$1[ebp+12]
	mov	DWORD PTR _bestDisplayMode$[ebp+12], eax

; 2571 :                 nBestRanking = nCurRanking;

	mov	eax, DWORD PTR _nCurRanking$4[ebp]
	mov	DWORD PTR _nBestRanking$5[ebp], eax

; 2572 : 
; 2573 :                 // Stop if perfect match found
; 2574 :                 if( nBestRanking == 0 )

	cmp	DWORD PTR _nBestRanking$5[ebp], 0
	jne	SHORT $LN3@DXUTFindVa

; 2575 :                     break;

	jmp	SHORT $LN5@DXUTFindVa
$LN3@DXUTFindVa:

; 2576 :             }
; 2577 :         }

	jmp	$LN6@DXUTFindVa
$LN5@DXUTFindVa:

; 2578 : 
; 2579 :         if( bestDisplayMode.Width == 0 )

	cmp	DWORD PTR _bestDisplayMode$[ebp], 0
	jne	SHORT $LN1@DXUTFindVa

; 2580 :         {
; 2581 :             *pBestDisplayMode = displayModeIn;

	mov	eax, DWORD PTR _pBestDisplayMode$[ebp]
	mov	ecx, DWORD PTR _displayModeIn$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _displayModeIn$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _displayModeIn$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _displayModeIn$[ebp+12]
	mov	DWORD PTR [eax+12], edx

; 2582 :             return E_FAIL; // No valid display modes found

	mov	eax, -2147467259			; 80004005H
	jmp	SHORT $LN10@DXUTFindVa
$LN1@DXUTFindVa:

; 2583 :         }
; 2584 : 
; 2585 :         *pBestDisplayMode = bestDisplayMode;

	mov	eax, DWORD PTR _pBestDisplayMode$[ebp]
	mov	ecx, DWORD PTR _bestDisplayMode$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _bestDisplayMode$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _bestDisplayMode$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _bestDisplayMode$[ebp+12]
	mov	DWORD PTR [eax+12], edx
$LN8@DXUTFindVa:

; 2586 :     }
; 2587 : 
; 2588 :     return S_OK;

	xor	eax, eax
$LN10@DXUTFindVa:

; 2589 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN15@DXUTFindVa
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 292				; 00000124H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN15@DXUTFindVa:
	DD	2
	DD	$LN14@DXUTFindVa
$LN14@DXUTFindVa:
	DD	-24					; ffffffe8H
	DD	16					; 00000010H
	DD	$LN12@DXUTFindVa
	DD	-96					; ffffffa0H
	DD	16					; 00000010H
	DD	$LN13@DXUTFindVa
$LN13@DXUTFindVa:
	DB	100					; 00000064H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	77					; 0000004dH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
$LN12@DXUTFindVa:
	DB	98					; 00000062H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	68					; 00000044H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	77					; 0000004dH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
?DXUTFindValidResolution@@YAJPAUCD3DEnumDeviceSettingsCombo@@U_D3DDISPLAYMODE@@PAU2@@Z ENDP ; DXUTFindValidResolution
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTBuildValidDeviceSettings@@YAXPAUDXUTDeviceSettings@@PAUCD3DEnumDeviceSettingsCombo@@0PAUDXUTMatchOptions@@@Z
_TEXT	SEGMENT
tv438 = -724						; size = 4
tv214 = -724						; size = 4
_bestPresentInterval$ = -524				; size = 4
_nCurRanking$2 = -512					; size = 4
_displayMode$3 = -500					; size = 16
_iDisplayMode$4 = -476					; size = 4
_pDisplayModeList$5 = -464				; size = 4
_nBestRefreshRanking$6 = -452				; size = 4
_refreshRateMatch$7 = -440				; size = 4
_dwBestFlags$ = -428					; size = 4
_nRanking$8 = -416					; size = 4
_i$9 = -404						; size = 4
_nBestIndex$ = -392					; size = 4
_nBestRanking$ = -380					; size = 4
_dwCurStencilBitDepth$10 = -368				; size = 4
_nRanking$11 = -356					; size = 4
_curDepthStencilFmt$12 = -344				; size = 4
_i$13 = -332						; size = 4
_dwInputStencilBitDepth$ = -320				; size = 4
_nRanking$14 = -308					; size = 4
_dwCurDepthBitDepth$15 = -296				; size = 4
_curDepthStencilFmt$16 = -284				; size = 4
_i$17 = -272						; size = 4
_dwInputDepthBitDepth$ = -260				; size = 4
_dwBackBufferBitDepth$ = -248				; size = 4
_depthStencilRanking$ = -236				; size = 12
_bestEnableAutoDepthStencil$ = -216			; size = 4
_bestDepthStencilFormat$ = -204				; size = 4
_bestSwapEffect$ = -192					; size = 4
_qualityLevels$18 = -180				; size = 4
_type$19 = -168						; size = 4
_i$20 = -156						; size = 4
_bestMultiSampleQuality$ = -144				; size = 4
_bestMultiSampleType$ = -132				; size = 4
_bestBackBufferCount$ = -120				; size = 4
_displayModeIn$21 = -108				; size = 16
_bestDisplayMode$ = -84					; size = 16
_dwBestBehaviorFlags$ = -60				; size = 4
_adapterDesktopDisplayMode$ = -48			; size = 16
_pD3D$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pValidDeviceSettings$ = 8				; size = 4
_pBestDeviceSettingsCombo$ = 12				; size = 4
_pDeviceSettingsIn$ = 16				; size = 4
_pMatchOptions$ = 20					; size = 4
?DXUTBuildValidDeviceSettings@@YAXPAUDXUTDeviceSettings@@PAUCD3DEnumDeviceSettingsCombo@@0PAUDXUTMatchOptions@@@Z PROC ; DXUTBuildValidDeviceSettings, COMDAT

; 2088 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DXUTBuildValidDeviceSettings@@YAXPAUDXUTDeviceSettings@@PAUCD3DEnumDeviceSettingsCombo@@0PAUDXUTMatchOptions@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 712				; 000002c8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-724]
	mov	ecx, 178				; 000000b2H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 2089 :     IDirect3D9* pD3D = DXUTGetD3DObject();

	call	?DXUTGetD3DObject@@YAPAUIDirect3D9@@XZ	; DXUTGetD3DObject
	mov	DWORD PTR _pD3D$[ebp], eax

; 2090 :     D3DDISPLAYMODE adapterDesktopDisplayMode;
; 2091 :     pD3D->GetAdapterDisplayMode( pBestDeviceSettingsCombo->AdapterOrdinal, &adapterDesktopDisplayMode );

	mov	esi, esp
	lea	eax, DWORD PTR _adapterDesktopDisplayMode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBestDeviceSettingsCombo$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pD3D$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pD3D$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+32]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2092 : 
; 2093 :     // For each setting pick the best, taking into account the match options and 
; 2094 :     // what's supported by the device
; 2095 : 
; 2096 :     //---------------------
; 2097 :     // Adapter Ordinal
; 2098 :     //---------------------
; 2099 :     // Just using pBestDeviceSettingsCombo->AdapterOrdinal
; 2100 : 
; 2101 :     //---------------------
; 2102 :     // Device Type
; 2103 :     //---------------------
; 2104 :     // Just using pBestDeviceSettingsCombo->DeviceType
; 2105 : 
; 2106 :     //---------------------
; 2107 :     // Windowed 
; 2108 :     //---------------------
; 2109 :     // Just using pBestDeviceSettingsCombo->Windowed
; 2110 : 
; 2111 :     //---------------------
; 2112 :     // Adapter Format
; 2113 :     //---------------------
; 2114 :     // Just using pBestDeviceSettingsCombo->AdapterFormat
; 2115 : 
; 2116 :     //---------------------
; 2117 :     // Vertex processing
; 2118 :     //---------------------
; 2119 :     DWORD dwBestBehaviorFlags = 0;

	mov	DWORD PTR _dwBestBehaviorFlags$[ebp], 0

; 2120 :     if( pMatchOptions->eVertexProcessing == DXUTMT_PRESERVE_INPUT )   

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+16], 1
	jne	SHORT $LN96@DXUTBuildV

; 2121 :     {
; 2122 :         dwBestBehaviorFlags = pDeviceSettingsIn->BehaviorFlags;

	mov	eax, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _dwBestBehaviorFlags$[ebp], ecx
	jmp	$LN95@DXUTBuildV
$LN96@DXUTBuildV:

; 2123 :     }
; 2124 :     else if( pMatchOptions->eVertexProcessing == DXUTMT_IGNORE_INPUT )    

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN94@DXUTBuildV

; 2125 :     {
; 2126 :         // The framework defaults to HWVP if available otherwise use SWVP
; 2127 :         if ((pBestDeviceSettingsCombo->pDeviceInfo->Caps.DevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT) != 0)

	mov	eax, DWORD PTR _pBestDeviceSettingsCombo$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, 65536				; 00010000H
	je	SHORT $LN93@DXUTBuildV

; 2128 :             dwBestBehaviorFlags |= D3DCREATE_HARDWARE_VERTEXPROCESSING;

	mov	eax, DWORD PTR _dwBestBehaviorFlags$[ebp]
	or	eax, 64					; 00000040H
	mov	DWORD PTR _dwBestBehaviorFlags$[ebp], eax

; 2129 :         else

	jmp	SHORT $LN92@DXUTBuildV
$LN93@DXUTBuildV:

; 2130 :             dwBestBehaviorFlags |= D3DCREATE_SOFTWARE_VERTEXPROCESSING;

	mov	eax, DWORD PTR _dwBestBehaviorFlags$[ebp]
	or	eax, 32					; 00000020H
	mov	DWORD PTR _dwBestBehaviorFlags$[ebp], eax
$LN92@DXUTBuildV:

; 2131 :     }
; 2132 :     else // if( pMatchOptions->eVertexProcessing == DXUTMT_CLOSEST_TO_INPUT )    

	jmp	$LN95@DXUTBuildV
$LN94@DXUTBuildV:

; 2133 :     {
; 2134 :         // Default to input, and fallback to SWVP if HWVP not available 
; 2135 :         dwBestBehaviorFlags = pDeviceSettingsIn->BehaviorFlags;

	mov	eax, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _dwBestBehaviorFlags$[ebp], ecx

; 2136 :         if ((pBestDeviceSettingsCombo->pDeviceInfo->Caps.DevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT) == 0 && 
; 2137 :             ( (dwBestBehaviorFlags & D3DCREATE_HARDWARE_VERTEXPROCESSING) != 0 || 
; 2138 :               (dwBestBehaviorFlags & D3DCREATE_MIXED_VERTEXPROCESSING) != 0) )

	mov	eax, DWORD PTR _pBestDeviceSettingsCombo$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, 65536				; 00010000H
	jne	SHORT $LN90@DXUTBuildV
	mov	eax, DWORD PTR _dwBestBehaviorFlags$[ebp]
	and	eax, 64					; 00000040H
	jne	SHORT $LN89@DXUTBuildV
	mov	eax, DWORD PTR _dwBestBehaviorFlags$[ebp]
	and	eax, 128				; 00000080H
	je	SHORT $LN90@DXUTBuildV
$LN89@DXUTBuildV:

; 2139 :         {
; 2140 :             dwBestBehaviorFlags &= ~D3DCREATE_HARDWARE_VERTEXPROCESSING;

	mov	eax, DWORD PTR _dwBestBehaviorFlags$[ebp]
	and	eax, -65				; ffffffbfH
	mov	DWORD PTR _dwBestBehaviorFlags$[ebp], eax

; 2141 :             dwBestBehaviorFlags &= ~D3DCREATE_MIXED_VERTEXPROCESSING;

	mov	eax, DWORD PTR _dwBestBehaviorFlags$[ebp]
	and	eax, -129				; ffffff7fH
	mov	DWORD PTR _dwBestBehaviorFlags$[ebp], eax

; 2142 :             dwBestBehaviorFlags |= D3DCREATE_SOFTWARE_VERTEXPROCESSING;

	mov	eax, DWORD PTR _dwBestBehaviorFlags$[ebp]
	or	eax, 32					; 00000020H
	mov	DWORD PTR _dwBestBehaviorFlags$[ebp], eax
$LN90@DXUTBuildV:

; 2143 :         }
; 2144 : 
; 2145 :         // One of these must be selected
; 2146 :         if( (dwBestBehaviorFlags & D3DCREATE_HARDWARE_VERTEXPROCESSING) == 0 &&
; 2147 :             (dwBestBehaviorFlags & D3DCREATE_MIXED_VERTEXPROCESSING) == 0 &&
; 2148 :             (dwBestBehaviorFlags & D3DCREATE_SOFTWARE_VERTEXPROCESSING) == 0 )

	mov	eax, DWORD PTR _dwBestBehaviorFlags$[ebp]
	and	eax, 64					; 00000040H
	jne	SHORT $LN95@DXUTBuildV
	mov	eax, DWORD PTR _dwBestBehaviorFlags$[ebp]
	and	eax, 128				; 00000080H
	jne	SHORT $LN95@DXUTBuildV
	mov	eax, DWORD PTR _dwBestBehaviorFlags$[ebp]
	and	eax, 32					; 00000020H
	jne	SHORT $LN95@DXUTBuildV

; 2149 :         {
; 2150 :             if ((pBestDeviceSettingsCombo->pDeviceInfo->Caps.DevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT) != 0)

	mov	eax, DWORD PTR _pBestDeviceSettingsCombo$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, 65536				; 00010000H
	je	SHORT $LN87@DXUTBuildV

; 2151 :                 dwBestBehaviorFlags |= D3DCREATE_HARDWARE_VERTEXPROCESSING;

	mov	eax, DWORD PTR _dwBestBehaviorFlags$[ebp]
	or	eax, 64					; 00000040H
	mov	DWORD PTR _dwBestBehaviorFlags$[ebp], eax

; 2152 :             else

	jmp	SHORT $LN95@DXUTBuildV
$LN87@DXUTBuildV:

; 2153 :                 dwBestBehaviorFlags |= D3DCREATE_SOFTWARE_VERTEXPROCESSING;

	mov	eax, DWORD PTR _dwBestBehaviorFlags$[ebp]
	or	eax, 32					; 00000020H
	mov	DWORD PTR _dwBestBehaviorFlags$[ebp], eax
$LN95@DXUTBuildV:

; 2154 :         }
; 2155 :     }
; 2156 : 
; 2157 :     //---------------------
; 2158 :     // Resolution
; 2159 :     //---------------------
; 2160 :     D3DDISPLAYMODE bestDisplayMode;  
; 2161 :     if( pMatchOptions->eResolution == DXUTMT_PRESERVE_INPUT )   

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+20], 1
	jne	SHORT $LN85@DXUTBuildV

; 2162 :     {
; 2163 :         bestDisplayMode.Width = pDeviceSettingsIn->pp.BackBufferWidth;

	mov	eax, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _bestDisplayMode$[ebp], ecx

; 2164 :         bestDisplayMode.Height = pDeviceSettingsIn->pp.BackBufferHeight;

	mov	eax, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _bestDisplayMode$[ebp+4], ecx

; 2165 :     }
; 2166 :     else 

	jmp	SHORT $LN84@DXUTBuildV
$LN85@DXUTBuildV:

; 2167 :     {
; 2168 :         D3DDISPLAYMODE displayModeIn;  
; 2169 :         if( pMatchOptions->eResolution == DXUTMT_CLOSEST_TO_INPUT &&
; 2170 :             pDeviceSettingsIn )   

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+20], 2
	jne	SHORT $LN83@DXUTBuildV
	cmp	DWORD PTR _pDeviceSettingsIn$[ebp], 0
	je	SHORT $LN83@DXUTBuildV

; 2171 :         {
; 2172 :             displayModeIn.Width = pDeviceSettingsIn->pp.BackBufferWidth;

	mov	eax, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _displayModeIn$21[ebp], ecx

; 2173 :             displayModeIn.Height = pDeviceSettingsIn->pp.BackBufferHeight;

	mov	eax, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _displayModeIn$21[ebp+4], ecx

; 2174 :         }
; 2175 :         else // if( pMatchOptions->eResolution == DXUTMT_IGNORE_INPUT )   

	jmp	SHORT $LN82@DXUTBuildV
$LN83@DXUTBuildV:

; 2176 :         {
; 2177 :             if( pBestDeviceSettingsCombo->Windowed )

	mov	eax, DWORD PTR _pBestDeviceSettingsCombo$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN81@DXUTBuildV

; 2178 :             {
; 2179 :                 // The framework defaults to 640x480 for windowed
; 2180 :                 displayModeIn.Width = 640;

	mov	DWORD PTR _displayModeIn$21[ebp], 640	; 00000280H

; 2181 :                 displayModeIn.Height = 480;

	mov	DWORD PTR _displayModeIn$21[ebp+4], 480	; 000001e0H

; 2182 :             }
; 2183 :             else

	jmp	SHORT $LN82@DXUTBuildV
$LN81@DXUTBuildV:

; 2184 :             {
; 2185 :                 // The framework defaults to desktop resolution for fullscreen to try to avoid slow mode change
; 2186 :                 displayModeIn.Width = adapterDesktopDisplayMode.Width;

	mov	eax, DWORD PTR _adapterDesktopDisplayMode$[ebp]
	mov	DWORD PTR _displayModeIn$21[ebp], eax

; 2187 :                 displayModeIn.Height = adapterDesktopDisplayMode.Height;

	mov	eax, DWORD PTR _adapterDesktopDisplayMode$[ebp+4]
	mov	DWORD PTR _displayModeIn$21[ebp+4], eax
$LN82@DXUTBuildV:

; 2188 :             }
; 2189 :         }
; 2190 : 
; 2191 :         // Call a helper function to find the closest valid display mode to the optimal 
; 2192 :         DXUTFindValidResolution( pBestDeviceSettingsCombo, displayModeIn, &bestDisplayMode );

	lea	eax, DWORD PTR _bestDisplayMode$[ebp]
	push	eax
	sub	esp, 16					; 00000010H
	mov	ecx, esp
	mov	edx, DWORD PTR _displayModeIn$21[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _displayModeIn$21[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _displayModeIn$21[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _displayModeIn$21[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR _pBestDeviceSettingsCombo$[ebp]
	push	ecx
	call	?DXUTFindValidResolution@@YAJPAUCD3DEnumDeviceSettingsCombo@@U_D3DDISPLAYMODE@@PAU2@@Z ; DXUTFindValidResolution
	add	esp, 24					; 00000018H
$LN84@DXUTBuildV:

; 2193 :     }
; 2194 : 
; 2195 :     //---------------------
; 2196 :     // Back Buffer Format
; 2197 :     //---------------------
; 2198 :     // Just using pBestDeviceSettingsCombo->BackBufferFormat
; 2199 : 
; 2200 :     //---------------------
; 2201 :     // Back buffer count
; 2202 :     //---------------------
; 2203 :     UINT bestBackBufferCount;
; 2204 :     if( pMatchOptions->eBackBufferCount == DXUTMT_PRESERVE_INPUT )   

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+28], 1
	jne	SHORT $LN79@DXUTBuildV

; 2205 :     {
; 2206 :         bestBackBufferCount = pDeviceSettingsIn->pp.BackBufferCount;

	mov	eax, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _bestBackBufferCount$[ebp], ecx
	jmp	SHORT $LN78@DXUTBuildV
$LN79@DXUTBuildV:

; 2207 :     }
; 2208 :     else if( pMatchOptions->eBackBufferCount == DXUTMT_IGNORE_INPUT )   

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+28], 0
	jne	SHORT $LN77@DXUTBuildV

; 2209 :     {
; 2210 :         // The framework defaults to triple buffering 
; 2211 :         bestBackBufferCount = 2;

	mov	DWORD PTR _bestBackBufferCount$[ebp], 2

; 2212 :     }
; 2213 :     else // if( pMatchOptions->eBackBufferCount == DXUTMT_CLOSEST_TO_INPUT )   

	jmp	SHORT $LN78@DXUTBuildV
$LN77@DXUTBuildV:

; 2214 :     {
; 2215 :         bestBackBufferCount = pDeviceSettingsIn->pp.BackBufferCount;

	mov	eax, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _bestBackBufferCount$[ebp], ecx

; 2216 :         if( bestBackBufferCount > 3 )

	cmp	DWORD PTR _bestBackBufferCount$[ebp], 3
	jbe	SHORT $LN75@DXUTBuildV

; 2217 :             bestBackBufferCount = 3;

	mov	DWORD PTR _bestBackBufferCount$[ebp], 3
$LN75@DXUTBuildV:

; 2218 :         if( bestBackBufferCount < 1 )

	cmp	DWORD PTR _bestBackBufferCount$[ebp], 1
	jae	SHORT $LN78@DXUTBuildV

; 2219 :             bestBackBufferCount = 1;

	mov	DWORD PTR _bestBackBufferCount$[ebp], 1
$LN78@DXUTBuildV:

; 2220 :     }
; 2221 :     
; 2222 :     //---------------------
; 2223 :     // Multisample
; 2224 :     //---------------------
; 2225 :     D3DMULTISAMPLE_TYPE bestMultiSampleType;
; 2226 :     DWORD bestMultiSampleQuality;
; 2227 :     if( pDeviceSettingsIn && pDeviceSettingsIn->pp.SwapEffect != D3DSWAPEFFECT_DISCARD )

	cmp	DWORD PTR _pDeviceSettingsIn$[ebp], 0
	je	SHORT $LN73@DXUTBuildV
	mov	eax, DWORD PTR _pDeviceSettingsIn$[ebp]
	cmp	DWORD PTR [eax+40], 1
	je	SHORT $LN73@DXUTBuildV

; 2228 :     {
; 2229 :         // Swap effect is not set to discard so multisampling has to off
; 2230 :         bestMultiSampleType = D3DMULTISAMPLE_NONE;

	mov	DWORD PTR _bestMultiSampleType$[ebp], 0

; 2231 :         bestMultiSampleQuality = 0;

	mov	DWORD PTR _bestMultiSampleQuality$[ebp], 0

; 2232 :     }
; 2233 :     else

	jmp	$LN72@DXUTBuildV
$LN73@DXUTBuildV:

; 2234 :     {
; 2235 :         if( pMatchOptions->eBackBufferCount == DXUTMT_PRESERVE_INPUT )   

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+28], 1
	jne	SHORT $LN71@DXUTBuildV

; 2236 :         {
; 2237 :             bestMultiSampleType    = pDeviceSettingsIn->pp.MultiSampleType;

	mov	eax, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _bestMultiSampleType$[ebp], ecx

; 2238 :             bestMultiSampleQuality = pDeviceSettingsIn->pp.MultiSampleQuality;

	mov	eax, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR _bestMultiSampleQuality$[ebp], ecx
	jmp	$LN72@DXUTBuildV
$LN71@DXUTBuildV:

; 2239 :         }
; 2240 :         else if( pMatchOptions->eBackBufferCount == DXUTMT_IGNORE_INPUT )   

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+28], 0
	jne	SHORT $LN69@DXUTBuildV

; 2241 :         {
; 2242 :             // Default to no multisampling (always supported)
; 2243 :             bestMultiSampleType = D3DMULTISAMPLE_NONE;

	mov	DWORD PTR _bestMultiSampleType$[ebp], 0

; 2244 :             bestMultiSampleQuality = 0;

	mov	DWORD PTR _bestMultiSampleQuality$[ebp], 0
	jmp	$LN72@DXUTBuildV
$LN69@DXUTBuildV:

; 2245 :         }
; 2246 :         else if( pMatchOptions->eBackBufferCount == DXUTMT_CLOSEST_TO_INPUT )   

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+28], 2
	jne	$LN67@DXUTBuildV

; 2247 :         {
; 2248 :             // Default to no multisampling (always supported)
; 2249 :             bestMultiSampleType = D3DMULTISAMPLE_NONE;

	mov	DWORD PTR _bestMultiSampleType$[ebp], 0

; 2250 :             bestMultiSampleQuality = 0;

	mov	DWORD PTR _bestMultiSampleQuality$[ebp], 0

; 2251 : 
; 2252 :             for( int i=0; i < pBestDeviceSettingsCombo->multiSampleTypeList.GetSize(); i++ )

	mov	DWORD PTR _i$20[ebp], 0
	jmp	SHORT $LN66@DXUTBuildV
$LN65@DXUTBuildV:
	mov	eax, DWORD PTR _i$20[ebp]
	add	eax, 1
	mov	DWORD PTR _i$20[ebp], eax
$LN66@DXUTBuildV:
	mov	ecx, DWORD PTR _pBestDeviceSettingsCombo$[ebp]
	add	ecx, 32					; 00000020H
	call	?GetSize@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QBEHXZ ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::GetSize
	cmp	DWORD PTR _i$20[ebp], eax
	jge	$LN64@DXUTBuildV

; 2253 :             {
; 2254 :                 D3DMULTISAMPLE_TYPE type = pBestDeviceSettingsCombo->multiSampleTypeList.GetAt(i);

	mov	eax, DWORD PTR _i$20[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBestDeviceSettingsCombo$[ebp]
	add	ecx, 32					; 00000020H
	call	?GetAt@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEAAW4_D3DMULTISAMPLE_TYPE@@H@Z ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::GetAt
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _type$19[ebp], ecx

; 2255 :                 DWORD qualityLevels = pBestDeviceSettingsCombo->multiSampleQualityList.GetAt(i);

	mov	eax, DWORD PTR _i$20[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBestDeviceSettingsCombo$[ebp]
	add	ecx, 44					; 0000002cH
	call	?GetAt@?$CGrowableArray@K@@QAEAAKH@Z	; CGrowableArray<unsigned long>::GetAt
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _qualityLevels$18[ebp], ecx

; 2256 :                 
; 2257 :                 // Check whether supported type is closer to the input than our current best
; 2258 :                 if( abs(type - pDeviceSettingsIn->pp.MultiSampleType) < abs(bestMultiSampleType - pDeviceSettingsIn->pp.MultiSampleType) )

	mov	eax, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	ecx, DWORD PTR _type$19[ebp]
	sub	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_abs
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	eax, DWORD PTR _bestMultiSampleType$[ebp]
	sub	eax, DWORD PTR [edx+32]
	push	eax
	call	_abs
	add	esp, 4
	cmp	esi, eax
	jge	SHORT $LN63@DXUTBuildV

; 2259 :                 {
; 2260 :                     bestMultiSampleType = type; 

	mov	eax, DWORD PTR _type$19[ebp]
	mov	DWORD PTR _bestMultiSampleType$[ebp], eax

; 2261 :                     bestMultiSampleQuality = __min( qualityLevels-1, pDeviceSettingsIn->pp.MultiSampleQuality );

	mov	eax, DWORD PTR _qualityLevels$18[ebp]
	sub	eax, 1
	mov	ecx, DWORD PTR _pDeviceSettingsIn$[ebp]
	cmp	eax, DWORD PTR [ecx+36]
	jae	SHORT $LN99@DXUTBuildV
	mov	edx, DWORD PTR _qualityLevels$18[ebp]
	sub	edx, 1
	mov	DWORD PTR tv214[ebp], edx
	jmp	SHORT $LN100@DXUTBuildV
$LN99@DXUTBuildV:
	mov	eax, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR tv214[ebp], ecx
$LN100@DXUTBuildV:
	mov	edx, DWORD PTR tv214[ebp]
	mov	DWORD PTR _bestMultiSampleQuality$[ebp], edx
$LN63@DXUTBuildV:

; 2262 :                 }
; 2263 :             }

	jmp	$LN65@DXUTBuildV
$LN64@DXUTBuildV:

; 2264 :         }
; 2265 :         else

	jmp	SHORT $LN72@DXUTBuildV
$LN67@DXUTBuildV:

; 2266 :         {
; 2267 :             // Error case
; 2268 :             bestMultiSampleType = D3DMULTISAMPLE_NONE;

	mov	DWORD PTR _bestMultiSampleType$[ebp], 0

; 2269 :             bestMultiSampleQuality = 0;

	mov	DWORD PTR _bestMultiSampleQuality$[ebp], 0
$LN72@DXUTBuildV:

; 2270 :         }
; 2271 :     }
; 2272 : 
; 2273 :     //---------------------
; 2274 :     // Swap effect
; 2275 :     //---------------------
; 2276 :     D3DSWAPEFFECT bestSwapEffect;
; 2277 :     if( pMatchOptions->eSwapEffect == DXUTMT_PRESERVE_INPUT )   

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+36], 1
	jne	SHORT $LN61@DXUTBuildV

; 2278 :     {
; 2279 :         bestSwapEffect = pDeviceSettingsIn->pp.SwapEffect;

	mov	eax, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _bestSwapEffect$[ebp], ecx
	jmp	SHORT $LN60@DXUTBuildV
$LN61@DXUTBuildV:

; 2280 :     }
; 2281 :     else if( pMatchOptions->eSwapEffect == DXUTMT_IGNORE_INPUT )   

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+36], 0
	jne	SHORT $LN59@DXUTBuildV

; 2282 :     {
; 2283 :         bestSwapEffect = D3DSWAPEFFECT_DISCARD;

	mov	DWORD PTR _bestSwapEffect$[ebp], 1

; 2284 :     }
; 2285 :     else // if( pMatchOptions->eSwapEffect == DXUTMT_CLOSEST_TO_INPUT )   

	jmp	SHORT $LN60@DXUTBuildV
$LN59@DXUTBuildV:

; 2286 :     {
; 2287 :         bestSwapEffect = pDeviceSettingsIn->pp.SwapEffect;

	mov	eax, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _bestSwapEffect$[ebp], ecx

; 2288 : 
; 2289 :         // Swap effect has to be one of these 3
; 2290 :         if( bestSwapEffect != D3DSWAPEFFECT_DISCARD &&
; 2291 :             bestSwapEffect != D3DSWAPEFFECT_FLIP &&
; 2292 :             bestSwapEffect != D3DSWAPEFFECT_COPY )

	cmp	DWORD PTR _bestSwapEffect$[ebp], 1
	je	SHORT $LN60@DXUTBuildV
	cmp	DWORD PTR _bestSwapEffect$[ebp], 2
	je	SHORT $LN60@DXUTBuildV
	cmp	DWORD PTR _bestSwapEffect$[ebp], 3
	je	SHORT $LN60@DXUTBuildV

; 2293 :         {
; 2294 :             bestSwapEffect = D3DSWAPEFFECT_DISCARD;

	mov	DWORD PTR _bestSwapEffect$[ebp], 1
$LN60@DXUTBuildV:

; 2295 :         }
; 2296 :     }
; 2297 : 
; 2298 :     //---------------------
; 2299 :     // Depth stencil 
; 2300 :     //---------------------
; 2301 :     D3DFORMAT bestDepthStencilFormat;
; 2302 :     BOOL bestEnableAutoDepthStencil;
; 2303 : 
; 2304 :     CGrowableArray< int > depthStencilRanking;

	lea	ecx, DWORD PTR _depthStencilRanking$[ebp]
	call	??0?$CGrowableArray@H@@QAE@XZ		; CGrowableArray<int>::CGrowableArray<int>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2305 :     depthStencilRanking.SetSize( pBestDeviceSettingsCombo->depthStencilFormatList.GetSize() );

	mov	ecx, DWORD PTR _pBestDeviceSettingsCombo$[ebp]
	add	ecx, 20					; 00000014H
	call	?GetSize@?$CGrowableArray@W4_D3DFORMAT@@@@QBEHXZ ; CGrowableArray<enum _D3DFORMAT>::GetSize
	push	eax
	lea	ecx, DWORD PTR _depthStencilRanking$[ebp]
	call	?SetSize@?$CGrowableArray@H@@QAEJH@Z	; CGrowableArray<int>::SetSize

; 2306 : 
; 2307 :     UINT dwBackBufferBitDepth = DXUTColorChannelBits( pBestDeviceSettingsCombo->BackBufferFormat );       

	mov	eax, DWORD PTR _pBestDeviceSettingsCombo$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	?DXUTColorChannelBits@@YAIW4_D3DFORMAT@@@Z ; DXUTColorChannelBits
	add	esp, 4
	mov	DWORD PTR _dwBackBufferBitDepth$[ebp], eax

; 2308 :     UINT dwInputDepthBitDepth = 0;

	mov	DWORD PTR _dwInputDepthBitDepth$[ebp], 0

; 2309 :     if( pDeviceSettingsIn )

	cmp	DWORD PTR _pDeviceSettingsIn$[ebp], 0
	je	SHORT $LN56@DXUTBuildV

; 2310 :         dwInputDepthBitDepth = DXUTDepthBits( pDeviceSettingsIn->pp.AutoDepthStencilFormat );

	mov	eax, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?DXUTDepthBits@@YAIW4_D3DFORMAT@@@Z	; DXUTDepthBits
	add	esp, 4
	mov	DWORD PTR _dwInputDepthBitDepth$[ebp], eax
$LN56@DXUTBuildV:

; 2311 : 
; 2312 :     for( int i=0; i<pBestDeviceSettingsCombo->depthStencilFormatList.GetSize(); i++ )

	mov	DWORD PTR _i$17[ebp], 0
	jmp	SHORT $LN55@DXUTBuildV
$LN54@DXUTBuildV:
	mov	eax, DWORD PTR _i$17[ebp]
	add	eax, 1
	mov	DWORD PTR _i$17[ebp], eax
$LN55@DXUTBuildV:
	mov	ecx, DWORD PTR _pBestDeviceSettingsCombo$[ebp]
	add	ecx, 20					; 00000014H
	call	?GetSize@?$CGrowableArray@W4_D3DFORMAT@@@@QBEHXZ ; CGrowableArray<enum _D3DFORMAT>::GetSize
	cmp	DWORD PTR _i$17[ebp], eax
	jge	$LN53@DXUTBuildV

; 2313 :     {
; 2314 :         D3DFORMAT curDepthStencilFmt = pBestDeviceSettingsCombo->depthStencilFormatList.GetAt(i);

	mov	eax, DWORD PTR _i$17[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBestDeviceSettingsCombo$[ebp]
	add	ecx, 20					; 00000014H
	call	?GetAt@?$CGrowableArray@W4_D3DFORMAT@@@@QAEAAW4_D3DFORMAT@@H@Z ; CGrowableArray<enum _D3DFORMAT>::GetAt
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _curDepthStencilFmt$16[ebp], ecx

; 2315 :         DWORD dwCurDepthBitDepth = DXUTDepthBits( curDepthStencilFmt );

	mov	eax, DWORD PTR _curDepthStencilFmt$16[ebp]
	push	eax
	call	?DXUTDepthBits@@YAIW4_D3DFORMAT@@@Z	; DXUTDepthBits
	add	esp, 4
	mov	DWORD PTR _dwCurDepthBitDepth$15[ebp], eax

; 2316 :         int nRanking;
; 2317 : 
; 2318 :         if( pMatchOptions->eDepthFormat == DXUTMT_PRESERVE_INPUT )

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+40], 1
	jne	SHORT $LN52@DXUTBuildV

; 2319 :         {                       
; 2320 :             // Need to match bit depth of input
; 2321 :             if(dwCurDepthBitDepth == dwInputDepthBitDepth)

	mov	eax, DWORD PTR _dwCurDepthBitDepth$15[ebp]
	cmp	eax, DWORD PTR _dwInputDepthBitDepth$[ebp]
	jne	SHORT $LN51@DXUTBuildV

; 2322 :                 nRanking = 0;

	mov	DWORD PTR _nRanking$14[ebp], 0

; 2323 :             else

	jmp	SHORT $LN50@DXUTBuildV
$LN51@DXUTBuildV:

; 2324 :                 nRanking = 10000;

	mov	DWORD PTR _nRanking$14[ebp], 10000	; 00002710H
$LN50@DXUTBuildV:
	jmp	SHORT $LN49@DXUTBuildV
$LN52@DXUTBuildV:

; 2325 :         }
; 2326 :         else if( pMatchOptions->eDepthFormat == DXUTMT_IGNORE_INPUT )

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $LN48@DXUTBuildV

; 2327 :         {
; 2328 :             // Prefer match of backbuffer bit depth
; 2329 :             nRanking = abs((int)dwCurDepthBitDepth - (int)dwBackBufferBitDepth*4);

	mov	eax, DWORD PTR _dwBackBufferBitDepth$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR _dwCurDepthBitDepth$15[ebp]
	sub	ecx, eax
	push	ecx
	call	_abs
	add	esp, 4
	mov	DWORD PTR _nRanking$14[ebp], eax

; 2330 :         }
; 2331 :         else // if( pMatchOptions->eDepthFormat == DXUTMT_CLOSEST_TO_INPUT )

	jmp	SHORT $LN49@DXUTBuildV
$LN48@DXUTBuildV:

; 2332 :         {
; 2333 :             // Prefer match of input depth format bit depth
; 2334 :             nRanking = abs((int)dwCurDepthBitDepth - (int)dwInputDepthBitDepth);

	mov	eax, DWORD PTR _dwCurDepthBitDepth$15[ebp]
	sub	eax, DWORD PTR _dwInputDepthBitDepth$[ebp]
	push	eax
	call	_abs
	add	esp, 4
	mov	DWORD PTR _nRanking$14[ebp], eax
$LN49@DXUTBuildV:

; 2335 :         }
; 2336 : 
; 2337 :         depthStencilRanking.Add( nRanking );

	lea	eax, DWORD PTR _nRanking$14[ebp]
	push	eax
	lea	ecx, DWORD PTR _depthStencilRanking$[ebp]
	call	?Add@?$CGrowableArray@H@@QAEJABH@Z	; CGrowableArray<int>::Add

; 2338 :     }

	jmp	$LN54@DXUTBuildV
$LN53@DXUTBuildV:

; 2339 : 
; 2340 :     UINT dwInputStencilBitDepth = 0;

	mov	DWORD PTR _dwInputStencilBitDepth$[ebp], 0

; 2341 :     if( pDeviceSettingsIn )

	cmp	DWORD PTR _pDeviceSettingsIn$[ebp], 0
	je	SHORT $LN46@DXUTBuildV

; 2342 :         dwInputStencilBitDepth = DXUTStencilBits( pDeviceSettingsIn->pp.AutoDepthStencilFormat );

	mov	eax, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?DXUTStencilBits@@YAIW4_D3DFORMAT@@@Z	; DXUTStencilBits
	add	esp, 4
	mov	DWORD PTR _dwInputStencilBitDepth$[ebp], eax
$LN46@DXUTBuildV:

; 2343 : 
; 2344 :     for( int i=0; i<pBestDeviceSettingsCombo->depthStencilFormatList.GetSize(); i++ )

	mov	DWORD PTR _i$13[ebp], 0
	jmp	SHORT $LN45@DXUTBuildV
$LN44@DXUTBuildV:
	mov	eax, DWORD PTR _i$13[ebp]
	add	eax, 1
	mov	DWORD PTR _i$13[ebp], eax
$LN45@DXUTBuildV:
	mov	ecx, DWORD PTR _pBestDeviceSettingsCombo$[ebp]
	add	ecx, 20					; 00000014H
	call	?GetSize@?$CGrowableArray@W4_D3DFORMAT@@@@QBEHXZ ; CGrowableArray<enum _D3DFORMAT>::GetSize
	cmp	DWORD PTR _i$13[ebp], eax
	jge	$LN43@DXUTBuildV

; 2345 :     {
; 2346 :         D3DFORMAT curDepthStencilFmt = pBestDeviceSettingsCombo->depthStencilFormatList.GetAt(i);

	mov	eax, DWORD PTR _i$13[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBestDeviceSettingsCombo$[ebp]
	add	ecx, 20					; 00000014H
	call	?GetAt@?$CGrowableArray@W4_D3DFORMAT@@@@QAEAAW4_D3DFORMAT@@H@Z ; CGrowableArray<enum _D3DFORMAT>::GetAt
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _curDepthStencilFmt$12[ebp], ecx

; 2347 :         int nRanking = depthStencilRanking.GetAt(i);

	mov	eax, DWORD PTR _i$13[ebp]
	push	eax
	lea	ecx, DWORD PTR _depthStencilRanking$[ebp]
	call	?GetAt@?$CGrowableArray@H@@QAEAAHH@Z	; CGrowableArray<int>::GetAt
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _nRanking$11[ebp], ecx

; 2348 :         DWORD dwCurStencilBitDepth = DXUTStencilBits( curDepthStencilFmt );

	mov	eax, DWORD PTR _curDepthStencilFmt$12[ebp]
	push	eax
	call	?DXUTStencilBits@@YAIW4_D3DFORMAT@@@Z	; DXUTStencilBits
	add	esp, 4
	mov	DWORD PTR _dwCurStencilBitDepth$10[ebp], eax

; 2349 : 
; 2350 :         if( pMatchOptions->eStencilFormat == DXUTMT_PRESERVE_INPUT )

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+44], 1
	jne	SHORT $LN42@DXUTBuildV

; 2351 :         {                       
; 2352 :             // Need to match bit depth of input
; 2353 :             if(dwCurStencilBitDepth == dwInputStencilBitDepth)

	mov	eax, DWORD PTR _dwCurStencilBitDepth$10[ebp]
	cmp	eax, DWORD PTR _dwInputStencilBitDepth$[ebp]
	jne	SHORT $LN41@DXUTBuildV

; 2354 :                 nRanking += 0;

	mov	eax, DWORD PTR _nRanking$11[ebp]
	mov	DWORD PTR _nRanking$11[ebp], eax

; 2355 :             else

	jmp	SHORT $LN40@DXUTBuildV
$LN41@DXUTBuildV:

; 2356 :                 nRanking += 10000;

	mov	eax, DWORD PTR _nRanking$11[ebp]
	add	eax, 10000				; 00002710H
	mov	DWORD PTR _nRanking$11[ebp], eax
$LN40@DXUTBuildV:
	jmp	SHORT $LN39@DXUTBuildV
$LN42@DXUTBuildV:

; 2357 :         }
; 2358 :         else if( pMatchOptions->eStencilFormat == DXUTMT_IGNORE_INPUT )

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+44], 0
	jne	SHORT $LN38@DXUTBuildV

; 2359 :         {
; 2360 :             // Prefer 0 stencil bit depth
; 2361 :             nRanking += dwCurStencilBitDepth;

	mov	eax, DWORD PTR _nRanking$11[ebp]
	add	eax, DWORD PTR _dwCurStencilBitDepth$10[ebp]
	mov	DWORD PTR _nRanking$11[ebp], eax

; 2362 :         }
; 2363 :         else // if( pMatchOptions->eStencilFormat == DXUTMT_CLOSEST_TO_INPUT )

	jmp	SHORT $LN39@DXUTBuildV
$LN38@DXUTBuildV:

; 2364 :         {
; 2365 :             // Prefer match of input stencil format bit depth
; 2366 :             nRanking += abs((int)dwCurStencilBitDepth - (int)dwInputStencilBitDepth);

	mov	eax, DWORD PTR _dwCurStencilBitDepth$10[ebp]
	sub	eax, DWORD PTR _dwInputStencilBitDepth$[ebp]
	push	eax
	call	_abs
	add	esp, 4
	add	eax, DWORD PTR _nRanking$11[ebp]
	mov	DWORD PTR _nRanking$11[ebp], eax
$LN39@DXUTBuildV:

; 2367 :         }
; 2368 : 
; 2369 :         depthStencilRanking.SetAt( i, nRanking );

	lea	eax, DWORD PTR _nRanking$11[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$13[ebp]
	push	ecx
	lea	ecx, DWORD PTR _depthStencilRanking$[ebp]
	call	?SetAt@?$CGrowableArray@H@@QAEJHABH@Z	; CGrowableArray<int>::SetAt

; 2370 :     }

	jmp	$LN44@DXUTBuildV
$LN43@DXUTBuildV:

; 2371 : 
; 2372 :     int nBestRanking = 100000;

	mov	DWORD PTR _nBestRanking$[ebp], 100000	; 000186a0H

; 2373 :     int nBestIndex = -1;

	mov	DWORD PTR _nBestIndex$[ebp], -1

; 2374 :     for( int i=0; i<pBestDeviceSettingsCombo->depthStencilFormatList.GetSize(); i++ )

	mov	DWORD PTR _i$9[ebp], 0
	jmp	SHORT $LN36@DXUTBuildV
$LN35@DXUTBuildV:
	mov	eax, DWORD PTR _i$9[ebp]
	add	eax, 1
	mov	DWORD PTR _i$9[ebp], eax
$LN36@DXUTBuildV:
	mov	ecx, DWORD PTR _pBestDeviceSettingsCombo$[ebp]
	add	ecx, 20					; 00000014H
	call	?GetSize@?$CGrowableArray@W4_D3DFORMAT@@@@QBEHXZ ; CGrowableArray<enum _D3DFORMAT>::GetSize
	cmp	DWORD PTR _i$9[ebp], eax
	jge	SHORT $LN34@DXUTBuildV

; 2375 :     {
; 2376 :         int nRanking = depthStencilRanking.GetAt(i);

	mov	eax, DWORD PTR _i$9[ebp]
	push	eax
	lea	ecx, DWORD PTR _depthStencilRanking$[ebp]
	call	?GetAt@?$CGrowableArray@H@@QAEAAHH@Z	; CGrowableArray<int>::GetAt
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _nRanking$8[ebp], ecx

; 2377 :         if( nRanking < nBestRanking )

	mov	eax, DWORD PTR _nRanking$8[ebp]
	cmp	eax, DWORD PTR _nBestRanking$[ebp]
	jge	SHORT $LN33@DXUTBuildV

; 2378 :         {
; 2379 :             nBestRanking = nRanking;

	mov	eax, DWORD PTR _nRanking$8[ebp]
	mov	DWORD PTR _nBestRanking$[ebp], eax

; 2380 :             nBestIndex = i;

	mov	eax, DWORD PTR _i$9[ebp]
	mov	DWORD PTR _nBestIndex$[ebp], eax
$LN33@DXUTBuildV:

; 2381 :         }
; 2382 :     }

	jmp	SHORT $LN35@DXUTBuildV
$LN34@DXUTBuildV:

; 2383 : 
; 2384 :     if( nBestIndex >= 0 )

	cmp	DWORD PTR _nBestIndex$[ebp], 0
	jl	SHORT $LN32@DXUTBuildV

; 2385 :     {
; 2386 :         bestDepthStencilFormat = pBestDeviceSettingsCombo->depthStencilFormatList.GetAt(nBestIndex);

	mov	eax, DWORD PTR _nBestIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBestDeviceSettingsCombo$[ebp]
	add	ecx, 20					; 00000014H
	call	?GetAt@?$CGrowableArray@W4_D3DFORMAT@@@@QAEAAW4_D3DFORMAT@@H@Z ; CGrowableArray<enum _D3DFORMAT>::GetAt
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _bestDepthStencilFormat$[ebp], ecx

; 2387 :         bestEnableAutoDepthStencil = true;

	mov	DWORD PTR _bestEnableAutoDepthStencil$[ebp], 1

; 2388 :     }
; 2389 :     else

	jmp	SHORT $LN31@DXUTBuildV
$LN32@DXUTBuildV:

; 2390 :     {
; 2391 :         bestDepthStencilFormat = D3DFMT_UNKNOWN;

	mov	DWORD PTR _bestDepthStencilFormat$[ebp], 0

; 2392 :         bestEnableAutoDepthStencil = false;

	mov	DWORD PTR _bestEnableAutoDepthStencil$[ebp], 0
$LN31@DXUTBuildV:

; 2393 :     }
; 2394 : 
; 2395 : 
; 2396 :     //---------------------
; 2397 :     // Present flags
; 2398 :     //---------------------
; 2399 :     DWORD dwBestFlags;
; 2400 :     if( pMatchOptions->ePresentFlags == DXUTMT_PRESERVE_INPUT )   

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+48], 1
	jne	SHORT $LN30@DXUTBuildV

; 2401 :     {
; 2402 :         dwBestFlags = pDeviceSettingsIn->pp.Flags;

	mov	eax, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR _dwBestFlags$[ebp], ecx
	jmp	SHORT $LN29@DXUTBuildV
$LN30@DXUTBuildV:

; 2403 :     }
; 2404 :     else if( pMatchOptions->ePresentFlags == DXUTMT_IGNORE_INPUT )   

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+48], 0
	jne	SHORT $LN28@DXUTBuildV

; 2405 :     {
; 2406 :         dwBestFlags = 0;

	mov	DWORD PTR _dwBestFlags$[ebp], 0

; 2407 :         if( bestEnableAutoDepthStencil )

	cmp	DWORD PTR _bestEnableAutoDepthStencil$[ebp], 0
	je	SHORT $LN27@DXUTBuildV

; 2408 :             dwBestFlags = D3DPRESENTFLAG_DISCARD_DEPTHSTENCIL;            

	mov	DWORD PTR _dwBestFlags$[ebp], 2
$LN27@DXUTBuildV:

; 2409 :     }
; 2410 :     else // if( pMatchOptions->ePresentFlags == DXUTMT_CLOSEST_TO_INPUT )   

	jmp	SHORT $LN29@DXUTBuildV
$LN28@DXUTBuildV:

; 2411 :     {
; 2412 :         dwBestFlags = pDeviceSettingsIn->pp.Flags;

	mov	eax, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR _dwBestFlags$[ebp], ecx

; 2413 :         if( bestEnableAutoDepthStencil )

	cmp	DWORD PTR _bestEnableAutoDepthStencil$[ebp], 0
	je	SHORT $LN29@DXUTBuildV

; 2414 :             dwBestFlags |= D3DPRESENTFLAG_DISCARD_DEPTHSTENCIL;

	mov	eax, DWORD PTR _dwBestFlags$[ebp]
	or	eax, 2
	mov	DWORD PTR _dwBestFlags$[ebp], eax
$LN29@DXUTBuildV:

; 2415 :     }
; 2416 : 
; 2417 :     //---------------------
; 2418 :     // Refresh rate
; 2419 :     //---------------------
; 2420 :     if( pBestDeviceSettingsCombo->Windowed )

	mov	eax, DWORD PTR _pBestDeviceSettingsCombo$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN24@DXUTBuildV

; 2421 :     {
; 2422 :         // Must be 0 for windowed
; 2423 :         bestDisplayMode.RefreshRate = 0;

	mov	DWORD PTR _bestDisplayMode$[ebp+8], 0

; 2424 :     }
; 2425 :     else

	jmp	$LN23@DXUTBuildV
$LN24@DXUTBuildV:

; 2426 :     {
; 2427 :         if( pMatchOptions->eRefreshRate == DXUTMT_PRESERVE_INPUT )   

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+52], 1
	jne	SHORT $LN22@DXUTBuildV

; 2428 :         {
; 2429 :             bestDisplayMode.RefreshRate = pDeviceSettingsIn->pp.FullScreen_RefreshRateInHz;

	mov	eax, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR _bestDisplayMode$[ebp+8], ecx

; 2430 :         }
; 2431 :         else 

	jmp	$LN23@DXUTBuildV
$LN22@DXUTBuildV:

; 2432 :         {
; 2433 :             UINT refreshRateMatch;
; 2434 :             if( pMatchOptions->eRefreshRate == DXUTMT_CLOSEST_TO_INPUT )   

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+52], 2
	jne	SHORT $LN20@DXUTBuildV

; 2435 :             {
; 2436 :                 refreshRateMatch = pDeviceSettingsIn->pp.FullScreen_RefreshRateInHz;

	mov	eax, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR _refreshRateMatch$7[ebp], ecx

; 2437 :             }
; 2438 :             else // if( pMatchOptions->eRefreshRate == DXUTMT_IGNORE_INPUT )   

	jmp	SHORT $LN19@DXUTBuildV
$LN20@DXUTBuildV:

; 2439 :             {
; 2440 :                 refreshRateMatch = adapterDesktopDisplayMode.RefreshRate;

	mov	eax, DWORD PTR _adapterDesktopDisplayMode$[ebp+8]
	mov	DWORD PTR _refreshRateMatch$7[ebp], eax
$LN19@DXUTBuildV:

; 2441 :             }
; 2442 : 
; 2443 :             bestDisplayMode.RefreshRate = 0;

	mov	DWORD PTR _bestDisplayMode$[ebp+8], 0

; 2444 : 
; 2445 :             if( refreshRateMatch != 0 )

	cmp	DWORD PTR _refreshRateMatch$7[ebp], 0
	je	$LN23@DXUTBuildV

; 2446 :             {
; 2447 :                 int nBestRefreshRanking = 100000;

	mov	DWORD PTR _nBestRefreshRanking$6[ebp], 100000 ; 000186a0H

; 2448 :                 CGrowableArray<D3DDISPLAYMODE>* pDisplayModeList = &pBestDeviceSettingsCombo->pAdapterInfo->displayModeList;

	mov	eax, DWORD PTR _pBestDeviceSettingsCombo$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	add	ecx, 1360				; 00000550H
	mov	DWORD PTR _pDisplayModeList$5[ebp], ecx

; 2449 :                 for( int iDisplayMode=0; iDisplayMode<pDisplayModeList->GetSize(); iDisplayMode++ )

	mov	DWORD PTR _iDisplayMode$4[ebp], 0
	jmp	SHORT $LN17@DXUTBuildV
$LN16@DXUTBuildV:
	mov	eax, DWORD PTR _iDisplayMode$4[ebp]
	add	eax, 1
	mov	DWORD PTR _iDisplayMode$4[ebp], eax
$LN17@DXUTBuildV:
	mov	ecx, DWORD PTR _pDisplayModeList$5[ebp]
	call	?GetSize@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QBEHXZ ; CGrowableArray<_D3DDISPLAYMODE>::GetSize
	cmp	DWORD PTR _iDisplayMode$4[ebp], eax
	jge	$LN23@DXUTBuildV

; 2450 :                 {
; 2451 :                     D3DDISPLAYMODE displayMode = pDisplayModeList->GetAt(iDisplayMode);                

	mov	eax, DWORD PTR _iDisplayMode$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDisplayModeList$5[ebp]
	call	?GetAt@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAEAAU_D3DDISPLAYMODE@@H@Z ; CGrowableArray<_D3DDISPLAYMODE>::GetAt
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _displayMode$3[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _displayMode$3[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _displayMode$3[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _displayMode$3[ebp+12], edx

; 2452 :                     if( displayMode.Format != pBestDeviceSettingsCombo->AdapterFormat || 
; 2453 :                         displayMode.Height != bestDisplayMode.Height ||
; 2454 :                         displayMode.Width != bestDisplayMode.Width )

	mov	eax, DWORD PTR _pBestDeviceSettingsCombo$[ebp]
	mov	ecx, DWORD PTR _displayMode$3[ebp+12]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN13@DXUTBuildV
	mov	eax, DWORD PTR _displayMode$3[ebp+4]
	cmp	eax, DWORD PTR _bestDisplayMode$[ebp+4]
	jne	SHORT $LN13@DXUTBuildV
	mov	eax, DWORD PTR _displayMode$3[ebp]
	cmp	eax, DWORD PTR _bestDisplayMode$[ebp]
	je	SHORT $LN14@DXUTBuildV
$LN13@DXUTBuildV:

; 2455 :                         continue; // Skip display modes that don't match 

	jmp	$LN16@DXUTBuildV
$LN14@DXUTBuildV:

; 2456 : 
; 2457 :                     // Find the delta between the current refresh rate and the optimal refresh rate 
; 2458 :                     int nCurRanking = abs((int)displayMode.RefreshRate - (int)refreshRateMatch);

	mov	eax, DWORD PTR _displayMode$3[ebp+8]
	sub	eax, DWORD PTR _refreshRateMatch$7[ebp]
	push	eax
	call	_abs
	add	esp, 4
	mov	DWORD PTR _nCurRanking$2[ebp], eax

; 2459 :                                         
; 2460 :                     if( nCurRanking < nBestRefreshRanking )

	mov	eax, DWORD PTR _nCurRanking$2[ebp]
	cmp	eax, DWORD PTR _nBestRefreshRanking$6[ebp]
	jge	SHORT $LN12@DXUTBuildV

; 2461 :                     {
; 2462 :                         bestDisplayMode.RefreshRate = displayMode.RefreshRate;

	mov	eax, DWORD PTR _displayMode$3[ebp+8]
	mov	DWORD PTR _bestDisplayMode$[ebp+8], eax

; 2463 :                         nBestRefreshRanking = nCurRanking;

	mov	eax, DWORD PTR _nCurRanking$2[ebp]
	mov	DWORD PTR _nBestRefreshRanking$6[ebp], eax

; 2464 : 
; 2465 :                         // Stop if perfect match found
; 2466 :                         if( nBestRefreshRanking == 0 )

	cmp	DWORD PTR _nBestRefreshRanking$6[ebp], 0
	jne	SHORT $LN12@DXUTBuildV

; 2467 :                             break;

	jmp	SHORT $LN23@DXUTBuildV
$LN12@DXUTBuildV:

; 2468 :                     }
; 2469 :                 }

	jmp	$LN16@DXUTBuildV
$LN23@DXUTBuildV:

; 2470 :             }
; 2471 :         }
; 2472 :     }
; 2473 : 
; 2474 :     //---------------------
; 2475 :     // Present interval
; 2476 :     //---------------------
; 2477 :     UINT bestPresentInterval;
; 2478 :     if( pMatchOptions->ePresentInterval == DXUTMT_PRESERVE_INPUT )   

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+56], 1
	jne	SHORT $LN10@DXUTBuildV

; 2479 :     {
; 2480 :         bestPresentInterval = pDeviceSettingsIn->pp.PresentationInterval;

	mov	eax, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	DWORD PTR _bestPresentInterval$[ebp], ecx
	jmp	SHORT $LN9@DXUTBuildV
$LN10@DXUTBuildV:

; 2481 :     }
; 2482 :     else if( pMatchOptions->ePresentInterval == DXUTMT_IGNORE_INPUT )   

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+56], 0
	jne	SHORT $LN8@DXUTBuildV

; 2483 :     {
; 2484 :         if( pBestDeviceSettingsCombo->Windowed )

	mov	eax, DWORD PTR _pBestDeviceSettingsCombo$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN7@DXUTBuildV

; 2485 :         {
; 2486 :             // For windowed, the framework defaults to D3DPRESENT_INTERVAL_IMMEDIATE
; 2487 :             // which will wait not for the vertical retrace period to prevent tearing, 
; 2488 :             // but may introduce tearing
; 2489 :             bestPresentInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

	mov	DWORD PTR _bestPresentInterval$[ebp], -2147483648 ; 80000000H

; 2490 :         }
; 2491 :         else

	jmp	SHORT $LN6@DXUTBuildV
$LN7@DXUTBuildV:

; 2492 :         {
; 2493 :             // For full screen, the framework defaults to D3DPRESENT_INTERVAL_DEFAULT 
; 2494 :             // which will wait for the vertical retrace period to prevent tearing
; 2495 :             bestPresentInterval = D3DPRESENT_INTERVAL_DEFAULT;

	mov	DWORD PTR _bestPresentInterval$[ebp], 0
$LN6@DXUTBuildV:

; 2496 :         }
; 2497 :     }
; 2498 :     else // if( pMatchOptions->ePresentInterval == DXUTMT_CLOSEST_TO_INPUT )   

	jmp	SHORT $LN9@DXUTBuildV
$LN8@DXUTBuildV:

; 2499 :     {
; 2500 :         if( pBestDeviceSettingsCombo->presentIntervalList.Contains( pDeviceSettingsIn->pp.PresentationInterval ) )

	mov	eax, DWORD PTR _pDeviceSettingsIn$[ebp]
	add	eax, 68					; 00000044H
	push	eax
	mov	ecx, DWORD PTR _pBestDeviceSettingsCombo$[ebp]
	add	ecx, 56					; 00000038H
	call	?Contains@?$CGrowableArray@I@@QAE_NABI@Z ; CGrowableArray<unsigned int>::Contains
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@DXUTBuildV

; 2501 :         {
; 2502 :             bestPresentInterval = pDeviceSettingsIn->pp.PresentationInterval;

	mov	eax, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	DWORD PTR _bestPresentInterval$[ebp], ecx

; 2503 :         }
; 2504 :         else

	jmp	SHORT $LN9@DXUTBuildV
$LN4@DXUTBuildV:

; 2505 :         {
; 2506 :             if( pBestDeviceSettingsCombo->Windowed )

	mov	eax, DWORD PTR _pBestDeviceSettingsCombo$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN2@DXUTBuildV

; 2507 :                 bestPresentInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

	mov	DWORD PTR _bestPresentInterval$[ebp], -2147483648 ; 80000000H

; 2508 :             else

	jmp	SHORT $LN9@DXUTBuildV
$LN2@DXUTBuildV:

; 2509 :                 bestPresentInterval = D3DPRESENT_INTERVAL_DEFAULT;

	mov	DWORD PTR _bestPresentInterval$[ebp], 0
$LN9@DXUTBuildV:

; 2510 :         }
; 2511 :     }
; 2512 : 
; 2513 :     // Fill the device settings struct
; 2514 :     ZeroMemory( pValidDeviceSettings, sizeof(DXUTDeviceSettings) );

	push	72					; 00000048H
	push	0
	mov	eax, DWORD PTR _pValidDeviceSettings$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2515 :     pValidDeviceSettings->AdapterOrdinal                 = pBestDeviceSettingsCombo->AdapterOrdinal;

	mov	eax, DWORD PTR _pValidDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _pBestDeviceSettingsCombo$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 2516 :     pValidDeviceSettings->DeviceType                     = pBestDeviceSettingsCombo->DeviceType;

	mov	eax, DWORD PTR _pValidDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _pBestDeviceSettingsCombo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 2517 :     pValidDeviceSettings->AdapterFormat                  = pBestDeviceSettingsCombo->AdapterFormat;

	mov	eax, DWORD PTR _pValidDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _pBestDeviceSettingsCombo$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 2518 :     pValidDeviceSettings->BehaviorFlags                  = dwBestBehaviorFlags;

	mov	eax, DWORD PTR _pValidDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _dwBestBehaviorFlags$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 2519 :     pValidDeviceSettings->pp.BackBufferWidth             = bestDisplayMode.Width;

	mov	eax, DWORD PTR _pValidDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _bestDisplayMode$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 2520 :     pValidDeviceSettings->pp.BackBufferHeight            = bestDisplayMode.Height;

	mov	eax, DWORD PTR _pValidDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _bestDisplayMode$[ebp+4]
	mov	DWORD PTR [eax+20], ecx

; 2521 :     pValidDeviceSettings->pp.BackBufferFormat            = pBestDeviceSettingsCombo->BackBufferFormat;

	mov	eax, DWORD PTR _pValidDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _pBestDeviceSettingsCombo$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+24], edx

; 2522 :     pValidDeviceSettings->pp.BackBufferCount             = bestBackBufferCount;

	mov	eax, DWORD PTR _pValidDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _bestBackBufferCount$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 2523 :     pValidDeviceSettings->pp.MultiSampleType             = bestMultiSampleType;  

	mov	eax, DWORD PTR _pValidDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _bestMultiSampleType$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 2524 :     pValidDeviceSettings->pp.MultiSampleQuality          = bestMultiSampleQuality;

	mov	eax, DWORD PTR _pValidDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _bestMultiSampleQuality$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 2525 :     pValidDeviceSettings->pp.SwapEffect                  = bestSwapEffect;

	mov	eax, DWORD PTR _pValidDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _bestSwapEffect$[ebp]
	mov	DWORD PTR [eax+40], ecx

; 2526 :     pValidDeviceSettings->pp.hDeviceWindow               = pBestDeviceSettingsCombo->Windowed ? DXUTGetHWNDDeviceWindowed() : DXUTGetHWNDDeviceFullScreen();

	mov	eax, DWORD PTR _pBestDeviceSettingsCombo$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN101@DXUTBuildV
	call	?DXUTGetHWNDDeviceWindowed@@YAPAUHWND__@@XZ ; DXUTGetHWNDDeviceWindowed
	mov	DWORD PTR tv438[ebp], eax
	jmp	SHORT $LN102@DXUTBuildV
$LN101@DXUTBuildV:
	call	?DXUTGetHWNDDeviceFullScreen@@YAPAUHWND__@@XZ ; DXUTGetHWNDDeviceFullScreen
	mov	DWORD PTR tv438[ebp], eax
$LN102@DXUTBuildV:
	mov	ecx, DWORD PTR _pValidDeviceSettings$[ebp]
	mov	edx, DWORD PTR tv438[ebp]
	mov	DWORD PTR [ecx+44], edx

; 2527 :     pValidDeviceSettings->pp.Windowed                    = pBestDeviceSettingsCombo->Windowed;

	mov	eax, DWORD PTR _pValidDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _pBestDeviceSettingsCombo$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+48], edx

; 2528 :     pValidDeviceSettings->pp.EnableAutoDepthStencil      = bestEnableAutoDepthStencil;  

	mov	eax, DWORD PTR _pValidDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _bestEnableAutoDepthStencil$[ebp]
	mov	DWORD PTR [eax+52], ecx

; 2529 :     pValidDeviceSettings->pp.AutoDepthStencilFormat      = bestDepthStencilFormat;

	mov	eax, DWORD PTR _pValidDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _bestDepthStencilFormat$[ebp]
	mov	DWORD PTR [eax+56], ecx

; 2530 :     pValidDeviceSettings->pp.Flags                       = dwBestFlags;                   

	mov	eax, DWORD PTR _pValidDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _dwBestFlags$[ebp]
	mov	DWORD PTR [eax+60], ecx

; 2531 :     pValidDeviceSettings->pp.FullScreen_RefreshRateInHz  = bestDisplayMode.RefreshRate;

	mov	eax, DWORD PTR _pValidDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _bestDisplayMode$[ebp+8]
	mov	DWORD PTR [eax+64], ecx

; 2532 :     pValidDeviceSettings->pp.PresentationInterval        = bestPresentInterval;

	mov	eax, DWORD PTR _pValidDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _bestPresentInterval$[ebp]
	mov	DWORD PTR [eax+68], ecx

; 2533 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _depthStencilRanking$[ebp]
	call	??1?$CGrowableArray@H@@QAE@XZ		; CGrowableArray<int>::~CGrowableArray<int>
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN113@DXUTBuildV
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 724				; 000002d4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN113@DXUTBuildV:
	DD	7
	DD	$LN112@DXUTBuildV
$LN112@DXUTBuildV:
	DD	-48					; ffffffd0H
	DD	16					; 00000010H
	DD	$LN104@DXUTBuildV
	DD	-84					; ffffffacH
	DD	16					; 00000010H
	DD	$LN105@DXUTBuildV
	DD	-108					; ffffff94H
	DD	16					; 00000010H
	DD	$LN106@DXUTBuildV
	DD	-236					; ffffff14H
	DD	12					; 0000000cH
	DD	$LN107@DXUTBuildV
	DD	-308					; fffffeccH
	DD	4
	DD	$LN108@DXUTBuildV
	DD	-356					; fffffe9cH
	DD	4
	DD	$LN109@DXUTBuildV
	DD	-500					; fffffe0cH
	DD	16					; 00000010H
	DD	$LN110@DXUTBuildV
$LN110@DXUTBuildV:
	DB	100					; 00000064H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	77					; 0000004dH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
$LN109@DXUTBuildV:
	DB	110					; 0000006eH
	DB	82					; 00000052H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	0
$LN108@DXUTBuildV:
	DB	110					; 0000006eH
	DB	82					; 00000052H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	0
$LN107@DXUTBuildV:
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	82					; 00000052H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	0
$LN106@DXUTBuildV:
	DB	100					; 00000064H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	77					; 0000004dH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	0
$LN105@DXUTBuildV:
	DB	98					; 00000062H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	68					; 00000044H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	77					; 0000004dH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
$LN104@DXUTBuildV:
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	68					; 00000044H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	107					; 0000006bH
	DB	116					; 00000074H
	DB	111					; 0000006fH
	DB	112					; 00000070H
	DB	68					; 00000044H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	77					; 0000004dH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DXUTBuildValidDeviceSettings@@YAXPAUDXUTDeviceSettings@@PAUCD3DEnumDeviceSettingsCombo@@0PAUDXUTMatchOptions@@@Z$0:
	lea	ecx, DWORD PTR _depthStencilRanking$[ebp]
	jmp	??1?$CGrowableArray@H@@QAE@XZ		; CGrowableArray<int>::~CGrowableArray<int>
__ehhandler$?DXUTBuildValidDeviceSettings@@YAXPAUDXUTDeviceSettings@@PAUCD3DEnumDeviceSettingsCombo@@0PAUDXUTMatchOptions@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-728]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DXUTBuildValidDeviceSettings@@YAXPAUDXUTDeviceSettings@@PAUCD3DEnumDeviceSettingsCombo@@0PAUDXUTMatchOptions@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DXUTBuildValidDeviceSettings@@YAXPAUDXUTDeviceSettings@@PAUCD3DEnumDeviceSettingsCombo@@0PAUDXUTMatchOptions@@@Z ENDP ; DXUTBuildValidDeviceSettings
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTRankDeviceCombo@@YAMPAUCD3DEnumDeviceSettingsCombo@@PAUDXUTDeviceSettings@@PAU_D3DDISPLAYMODE@@@Z
_TEXT	SEGMENT
tv226 = -560						; size = 4
tv220 = -560						; size = 4
tv150 = -560						; size = 4
tv146 = -560						; size = 4
tv134 = -560						; size = 4
_displayMode$1 = -360					; size = 16
_idm$2 = -336						; size = 4
_bRefreshFound$ = -321					; size = 1
_msQuality$3 = -312					; size = 4
_msType$4 = -300					; size = 4
_i$5 = -288						; size = 4
_bMultiSampleFound$ = -273				; size = 1
_bAdapterMatchesBB$ = -261				; size = 1
_fScale$6 = -252					; size = 4
_nBitDepthDelta$7 = -240				; size = 4
_displayMode$8 = -228					; size = 16
_idm$9 = -204						; size = 4
_bResolutionFound$ = -189				; size = 1
_bAdapterOptimalMatch$10 = -177				; size = 1
_fScale$11 = -168					; size = 4
_nBitDepthDelta$12 = -156				; size = 4
_fPresentIntervalWeight$ = -144				; size = 4
_fRefreshRateWeight$ = -132				; size = 4
_fDepthStencilWeight$ = -120				; size = 4
_fMultiSampleWeight$ = -108				; size = 4
_fBackBufferFormatWeight$ = -96				; size = 4
_fResolutionWeight$ = -84				; size = 4
_fVertexProcessingWeight$ = -72				; size = 4
_fAdapterFormatWeight$ = -60				; size = 4
_fWindowWeight$ = -48					; size = 4
_fDeviceTypeWeight$ = -36				; size = 4
_fAdapterOrdinalWeight$ = -24				; size = 4
_fCurRanking$ = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
_pDeviceSettingsCombo$ = 8				; size = 4
_pOptimalDeviceSettings$ = 12				; size = 4
_pAdapterDesktopDisplayMode$ = 16			; size = 4
?DXUTRankDeviceCombo@@YAMPAUCD3DEnumDeviceSettingsCombo@@PAUDXUTDeviceSettings@@PAU_D3DDISPLAYMODE@@@Z PROC ; DXUTRankDeviceCombo, COMDAT

; 1899 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 560				; 00000230H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-560]
	mov	ecx, 140				; 0000008cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1900 :     float fCurRanking = 0.0f; 

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _fCurRanking$[ebp], xmm0

; 1901 : 
; 1902 :     // Arbitrary weights.  Gives preference to the ordinal, device type, and windowed
; 1903 :     const float fAdapterOrdinalWeight   = 1000.0f;

	movss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR _fAdapterOrdinalWeight$[ebp], xmm0

; 1904 :     const float fDeviceTypeWeight       = 100.0f;

	movss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR _fDeviceTypeWeight$[ebp], xmm0

; 1905 :     const float fWindowWeight           = 10.0f;

	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR _fWindowWeight$[ebp], xmm0

; 1906 :     const float fAdapterFormatWeight    = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _fAdapterFormatWeight$[ebp], xmm0

; 1907 :     const float fVertexProcessingWeight = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _fVertexProcessingWeight$[ebp], xmm0

; 1908 :     const float fResolutionWeight       = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _fResolutionWeight$[ebp], xmm0

; 1909 :     const float fBackBufferFormatWeight = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _fBackBufferFormatWeight$[ebp], xmm0

; 1910 :     const float fMultiSampleWeight      = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _fMultiSampleWeight$[ebp], xmm0

; 1911 :     const float fDepthStencilWeight     = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _fDepthStencilWeight$[ebp], xmm0

; 1912 :     const float fRefreshRateWeight      = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _fRefreshRateWeight$[ebp], xmm0

; 1913 :     const float fPresentIntervalWeight  = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _fPresentIntervalWeight$[ebp], xmm0

; 1914 : 
; 1915 :     //---------------------
; 1916 :     // Adapter ordinal
; 1917 :     //---------------------
; 1918 :     if( pDeviceSettingsCombo->AdapterOrdinal == pOptimalDeviceSettings->AdapterOrdinal )

	mov	eax, DWORD PTR _pDeviceSettingsCombo$[ebp]
	mov	ecx, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN36@DXUTRankDe

; 1919 :         fCurRanking += fAdapterOrdinalWeight;

	movss	xmm0, DWORD PTR _fCurRanking$[ebp]
	addss	xmm0, DWORD PTR _fAdapterOrdinalWeight$[ebp]
	movss	DWORD PTR _fCurRanking$[ebp], xmm0
$LN36@DXUTRankDe:

; 1920 : 
; 1921 :     //---------------------
; 1922 :     // Device type
; 1923 :     //---------------------
; 1924 :     if( pDeviceSettingsCombo->DeviceType == pOptimalDeviceSettings->DeviceType )

	mov	eax, DWORD PTR _pDeviceSettingsCombo$[ebp]
	mov	ecx, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN35@DXUTRankDe

; 1925 :         fCurRanking += fDeviceTypeWeight;

	movss	xmm0, DWORD PTR _fCurRanking$[ebp]
	addss	xmm0, DWORD PTR _fDeviceTypeWeight$[ebp]
	movss	DWORD PTR _fCurRanking$[ebp], xmm0
$LN35@DXUTRankDe:

; 1926 :     // Slightly prefer HAL 
; 1927 :     if( pDeviceSettingsCombo->DeviceType == D3DDEVTYPE_HAL )

	mov	eax, DWORD PTR _pDeviceSettingsCombo$[ebp]
	cmp	DWORD PTR [eax+4], 1
	jne	SHORT $LN34@DXUTRankDe

; 1928 :         fCurRanking += 0.1f; 

	movss	xmm0, DWORD PTR _fCurRanking$[ebp]
	addss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _fCurRanking$[ebp], xmm0
$LN34@DXUTRankDe:

; 1929 : 
; 1930 :     //---------------------
; 1931 :     // Windowed
; 1932 :     //---------------------
; 1933 :     if( pDeviceSettingsCombo->Windowed == pOptimalDeviceSettings->pp.Windowed )

	mov	eax, DWORD PTR _pDeviceSettingsCombo$[ebp]
	mov	ecx, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	edx, DWORD PTR [eax+16]
	cmp	edx, DWORD PTR [ecx+48]
	jne	SHORT $LN33@DXUTRankDe

; 1934 :         fCurRanking += fWindowWeight;

	movss	xmm0, DWORD PTR _fCurRanking$[ebp]
	addss	xmm0, DWORD PTR _fWindowWeight$[ebp]
	movss	DWORD PTR _fCurRanking$[ebp], xmm0
$LN33@DXUTRankDe:

; 1935 : 
; 1936 :     //---------------------
; 1937 :     // Adapter format
; 1938 :     //---------------------
; 1939 :     if( pDeviceSettingsCombo->AdapterFormat == pOptimalDeviceSettings->AdapterFormat )

	mov	eax, DWORD PTR _pDeviceSettingsCombo$[ebp]
	mov	ecx, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN32@DXUTRankDe

; 1940 :     {
; 1941 :         fCurRanking += fAdapterFormatWeight;

	movss	xmm0, DWORD PTR _fCurRanking$[ebp]
	addss	xmm0, DWORD PTR _fAdapterFormatWeight$[ebp]
	movss	DWORD PTR _fCurRanking$[ebp], xmm0

; 1942 :     }
; 1943 :     else

	jmp	$LN31@DXUTRankDe
$LN32@DXUTRankDe:

; 1944 :     {
; 1945 :         int nBitDepthDelta = abs( (long) DXUTColorChannelBits(pDeviceSettingsCombo->AdapterFormat) -
; 1946 :                                   (long) DXUTColorChannelBits(pOptimalDeviceSettings->AdapterFormat) );

	mov	eax, DWORD PTR _pDeviceSettingsCombo$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	?DXUTColorChannelBits@@YAIW4_D3DFORMAT@@@Z ; DXUTColorChannelBits
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?DXUTColorChannelBits@@YAIW4_D3DFORMAT@@@Z ; DXUTColorChannelBits
	add	esp, 4
	sub	esi, eax
	push	esi
	call	?abs@@YAJJ@Z				; abs
	add	esp, 4
	mov	DWORD PTR _nBitDepthDelta$12[ebp], eax

; 1947 :         float fScale = __max(0.9f - (float)nBitDepthDelta*0.2f, 0.0f);

	cvtsi2ss xmm0, DWORD PTR _nBitDepthDelta$12[ebp]
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	movss	xmm1, DWORD PTR __real@3f666666
	subss	xmm1, xmm0
	comiss	xmm1, DWORD PTR __real@00000000
	jbe	SHORT $LN39@DXUTRankDe
	cvtsi2ss xmm0, DWORD PTR _nBitDepthDelta$12[ebp]
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	movss	xmm1, DWORD PTR __real@3f666666
	subss	xmm1, xmm0
	movss	DWORD PTR tv134[ebp], xmm1
	jmp	SHORT $LN40@DXUTRankDe
$LN39@DXUTRankDe:
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv134[ebp], xmm0
$LN40@DXUTRankDe:
	movss	xmm0, DWORD PTR tv134[ebp]
	movss	DWORD PTR _fScale$11[ebp], xmm0

; 1948 :         fCurRanking += fScale * fAdapterFormatWeight;

	movss	xmm0, DWORD PTR _fScale$11[ebp]
	mulss	xmm0, DWORD PTR _fAdapterFormatWeight$[ebp]
	addss	xmm0, DWORD PTR _fCurRanking$[ebp]
	movss	DWORD PTR _fCurRanking$[ebp], xmm0
$LN31@DXUTRankDe:

; 1949 :     }
; 1950 : 
; 1951 :     if( !pDeviceSettingsCombo->Windowed )

	mov	eax, DWORD PTR _pDeviceSettingsCombo$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	$LN27@DXUTRankDe

; 1952 :     {
; 1953 :         // Slightly prefer when it matches the desktop format or is D3DFMT_X8R8G8B8
; 1954 :         bool bAdapterOptimalMatch;
; 1955 :         if( DXUTColorChannelBits(pAdapterDesktopDisplayMode->Format) >= 8 )

	mov	eax, DWORD PTR _pAdapterDesktopDisplayMode$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	?DXUTColorChannelBits@@YAIW4_D3DFORMAT@@@Z ; DXUTColorChannelBits
	add	esp, 4
	cmp	eax, 8
	jb	SHORT $LN29@DXUTRankDe

; 1956 :             bAdapterOptimalMatch = (pDeviceSettingsCombo->AdapterFormat == pAdapterDesktopDisplayMode->Format);

	mov	eax, DWORD PTR _pDeviceSettingsCombo$[ebp]
	mov	ecx, DWORD PTR _pAdapterDesktopDisplayMode$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN41@DXUTRankDe
	mov	DWORD PTR tv146[ebp], 1
	jmp	SHORT $LN42@DXUTRankDe
$LN41@DXUTRankDe:
	mov	DWORD PTR tv146[ebp], 0
$LN42@DXUTRankDe:
	mov	al, BYTE PTR tv146[ebp]
	mov	BYTE PTR _bAdapterOptimalMatch$10[ebp], al

; 1957 :         else

	jmp	SHORT $LN28@DXUTRankDe
$LN29@DXUTRankDe:

; 1958 :             bAdapterOptimalMatch = (pDeviceSettingsCombo->AdapterFormat == D3DFMT_X8R8G8B8);

	mov	eax, DWORD PTR _pDeviceSettingsCombo$[ebp]
	cmp	DWORD PTR [eax+8], 22			; 00000016H
	jne	SHORT $LN43@DXUTRankDe
	mov	DWORD PTR tv150[ebp], 1
	jmp	SHORT $LN44@DXUTRankDe
$LN43@DXUTRankDe:
	mov	DWORD PTR tv150[ebp], 0
$LN44@DXUTRankDe:
	mov	cl, BYTE PTR tv150[ebp]
	mov	BYTE PTR _bAdapterOptimalMatch$10[ebp], cl
$LN28@DXUTRankDe:

; 1959 : 
; 1960 :         if( bAdapterOptimalMatch )

	movzx	eax, BYTE PTR _bAdapterOptimalMatch$10[ebp]
	test	eax, eax
	je	SHORT $LN27@DXUTRankDe

; 1961 :             fCurRanking += 0.1f;

	movss	xmm0, DWORD PTR _fCurRanking$[ebp]
	addss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _fCurRanking$[ebp], xmm0
$LN27@DXUTRankDe:

; 1962 :     }
; 1963 : 
; 1964 :     //---------------------
; 1965 :     // Vertex processing
; 1966 :     //---------------------
; 1967 :     if( (pOptimalDeviceSettings->BehaviorFlags & D3DCREATE_HARDWARE_VERTEXPROCESSING) != 0 || 
; 1968 :         (pOptimalDeviceSettings->BehaviorFlags & D3DCREATE_MIXED_VERTEXPROCESSING) != 0 )

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 64					; 00000040H
	jne	SHORT $LN25@DXUTRankDe
	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 128				; 00000080H
	je	SHORT $LN24@DXUTRankDe
$LN25@DXUTRankDe:

; 1969 :     {
; 1970 :         if( (pDeviceSettingsCombo->pDeviceInfo->Caps.DevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT) != 0 )

	mov	eax, DWORD PTR _pDeviceSettingsCombo$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, 65536				; 00010000H
	je	SHORT $LN24@DXUTRankDe

; 1971 :             fCurRanking += fVertexProcessingWeight;

	movss	xmm0, DWORD PTR _fCurRanking$[ebp]
	addss	xmm0, DWORD PTR _fVertexProcessingWeight$[ebp]
	movss	DWORD PTR _fCurRanking$[ebp], xmm0
$LN24@DXUTRankDe:

; 1972 :     }
; 1973 :     // Slightly prefer HW T&L
; 1974 :     if( (pDeviceSettingsCombo->pDeviceInfo->Caps.DevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT) != 0 )

	mov	eax, DWORD PTR _pDeviceSettingsCombo$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, 65536				; 00010000H
	je	SHORT $LN23@DXUTRankDe

; 1975 :         fCurRanking += 0.1f;

	movss	xmm0, DWORD PTR _fCurRanking$[ebp]
	addss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _fCurRanking$[ebp], xmm0
$LN23@DXUTRankDe:

; 1976 : 
; 1977 :     //---------------------
; 1978 :     // Resolution
; 1979 :     //---------------------
; 1980 :     bool bResolutionFound = false;

	mov	BYTE PTR _bResolutionFound$[ebp], 0

; 1981 :     for( int idm = 0; idm < pDeviceSettingsCombo->pAdapterInfo->displayModeList.GetSize(); idm++ )

	mov	DWORD PTR _idm$9[ebp], 0
	jmp	SHORT $LN22@DXUTRankDe
$LN21@DXUTRankDe:
	mov	eax, DWORD PTR _idm$9[ebp]
	add	eax, 1
	mov	DWORD PTR _idm$9[ebp], eax
$LN22@DXUTRankDe:
	mov	eax, DWORD PTR _pDeviceSettingsCombo$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	add	ecx, 1360				; 00000550H
	call	?GetSize@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QBEHXZ ; CGrowableArray<_D3DDISPLAYMODE>::GetSize
	cmp	DWORD PTR _idm$9[ebp], eax
	jge	SHORT $LN20@DXUTRankDe

; 1982 :     {
; 1983 :         D3DDISPLAYMODE displayMode = pDeviceSettingsCombo->pAdapterInfo->displayModeList.GetAt( idm );

	mov	eax, DWORD PTR _idm$9[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeviceSettingsCombo$[ebp]
	mov	ecx, DWORD PTR [ecx+80]
	add	ecx, 1360				; 00000550H
	call	?GetAt@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAEAAU_D3DDISPLAYMODE@@H@Z ; CGrowableArray<_D3DDISPLAYMODE>::GetAt
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _displayMode$8[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _displayMode$8[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _displayMode$8[ebp+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR _displayMode$8[ebp+12], eax

; 1984 :         if( displayMode.Format != pDeviceSettingsCombo->AdapterFormat )

	mov	eax, DWORD PTR _pDeviceSettingsCombo$[ebp]
	mov	ecx, DWORD PTR _displayMode$8[ebp+12]
	cmp	ecx, DWORD PTR [eax+8]
	je	SHORT $LN19@DXUTRankDe

; 1985 :             continue;

	jmp	SHORT $LN21@DXUTRankDe
$LN19@DXUTRankDe:

; 1986 :         if( displayMode.Width == pOptimalDeviceSettings->pp.BackBufferWidth &&
; 1987 :             displayMode.Height == pOptimalDeviceSettings->pp.BackBufferHeight )

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _displayMode$8[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jne	SHORT $LN18@DXUTRankDe
	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _displayMode$8[ebp+4]
	cmp	ecx, DWORD PTR [eax+20]
	jne	SHORT $LN18@DXUTRankDe

; 1988 :             bResolutionFound = true;

	mov	BYTE PTR _bResolutionFound$[ebp], 1
$LN18@DXUTRankDe:

; 1989 :     }

	jmp	$LN21@DXUTRankDe
$LN20@DXUTRankDe:

; 1990 :     if( bResolutionFound )

	movzx	eax, BYTE PTR _bResolutionFound$[ebp]
	test	eax, eax
	je	SHORT $LN17@DXUTRankDe

; 1991 :         fCurRanking += fResolutionWeight;

	movss	xmm0, DWORD PTR _fCurRanking$[ebp]
	addss	xmm0, DWORD PTR _fResolutionWeight$[ebp]
	movss	DWORD PTR _fCurRanking$[ebp], xmm0
$LN17@DXUTRankDe:

; 1992 : 
; 1993 :     //---------------------
; 1994 :     // Back buffer format
; 1995 :     //---------------------
; 1996 :     if( pDeviceSettingsCombo->BackBufferFormat == pOptimalDeviceSettings->pp.BackBufferFormat )

	mov	eax, DWORD PTR _pDeviceSettingsCombo$[ebp]
	mov	ecx, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+24]
	jne	SHORT $LN16@DXUTRankDe

; 1997 :     {
; 1998 :         fCurRanking += fBackBufferFormatWeight;

	movss	xmm0, DWORD PTR _fCurRanking$[ebp]
	addss	xmm0, DWORD PTR _fBackBufferFormatWeight$[ebp]
	movss	DWORD PTR _fCurRanking$[ebp], xmm0

; 1999 :     }
; 2000 :     else

	jmp	$LN15@DXUTRankDe
$LN16@DXUTRankDe:

; 2001 :     {
; 2002 :         int nBitDepthDelta = abs( (long) DXUTColorChannelBits(pDeviceSettingsCombo->BackBufferFormat) -
; 2003 :                                   (long) DXUTColorChannelBits(pOptimalDeviceSettings->pp.BackBufferFormat) );

	mov	eax, DWORD PTR _pDeviceSettingsCombo$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	?DXUTColorChannelBits@@YAIW4_D3DFORMAT@@@Z ; DXUTColorChannelBits
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	?DXUTColorChannelBits@@YAIW4_D3DFORMAT@@@Z ; DXUTColorChannelBits
	add	esp, 4
	sub	esi, eax
	push	esi
	call	?abs@@YAJJ@Z				; abs
	add	esp, 4
	mov	DWORD PTR _nBitDepthDelta$7[ebp], eax

; 2004 :         float fScale = __max(0.9f - (float)nBitDepthDelta*0.2f, 0.0f);

	cvtsi2ss xmm0, DWORD PTR _nBitDepthDelta$7[ebp]
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	movss	xmm1, DWORD PTR __real@3f666666
	subss	xmm1, xmm0
	comiss	xmm1, DWORD PTR __real@00000000
	jbe	SHORT $LN45@DXUTRankDe
	cvtsi2ss xmm0, DWORD PTR _nBitDepthDelta$7[ebp]
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	movss	xmm1, DWORD PTR __real@3f666666
	subss	xmm1, xmm0
	movss	DWORD PTR tv220[ebp], xmm1
	jmp	SHORT $LN46@DXUTRankDe
$LN45@DXUTRankDe:
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv220[ebp], xmm0
$LN46@DXUTRankDe:
	movss	xmm0, DWORD PTR tv220[ebp]
	movss	DWORD PTR _fScale$6[ebp], xmm0

; 2005 :         fCurRanking += fScale * fBackBufferFormatWeight;

	movss	xmm0, DWORD PTR _fScale$6[ebp]
	mulss	xmm0, DWORD PTR _fBackBufferFormatWeight$[ebp]
	addss	xmm0, DWORD PTR _fCurRanking$[ebp]
	movss	DWORD PTR _fCurRanking$[ebp], xmm0
$LN15@DXUTRankDe:

; 2006 :     }
; 2007 : 
; 2008 :     // Check if this back buffer format is the same as 
; 2009 :     // the adapter format since this is preferred.
; 2010 :     bool bAdapterMatchesBB = (pDeviceSettingsCombo->BackBufferFormat == pDeviceSettingsCombo->AdapterFormat);

	mov	eax, DWORD PTR _pDeviceSettingsCombo$[ebp]
	mov	ecx, DWORD PTR _pDeviceSettingsCombo$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN47@DXUTRankDe
	mov	DWORD PTR tv226[ebp], 1
	jmp	SHORT $LN48@DXUTRankDe
$LN47@DXUTRankDe:
	mov	DWORD PTR tv226[ebp], 0
$LN48@DXUTRankDe:
	mov	al, BYTE PTR tv226[ebp]
	mov	BYTE PTR _bAdapterMatchesBB$[ebp], al

; 2011 :     if( bAdapterMatchesBB )

	movzx	eax, BYTE PTR _bAdapterMatchesBB$[ebp]
	test	eax, eax
	je	SHORT $LN14@DXUTRankDe

; 2012 :         fCurRanking += 0.1f;

	movss	xmm0, DWORD PTR _fCurRanking$[ebp]
	addss	xmm0, DWORD PTR __real@3dcccccd
	movss	DWORD PTR _fCurRanking$[ebp], xmm0
$LN14@DXUTRankDe:

; 2013 : 
; 2014 :     //---------------------
; 2015 :     // Back buffer count
; 2016 :     //---------------------
; 2017 :     // No caps for the back buffer count
; 2018 : 
; 2019 :     //---------------------
; 2020 :     // Multisample
; 2021 :     //---------------------
; 2022 :     bool bMultiSampleFound = false;

	mov	BYTE PTR _bMultiSampleFound$[ebp], 0

; 2023 :     for( int i=0; i<pDeviceSettingsCombo->multiSampleTypeList.GetSize(); i++ )

	mov	DWORD PTR _i$5[ebp], 0
	jmp	SHORT $LN13@DXUTRankDe
$LN12@DXUTRankDe:
	mov	eax, DWORD PTR _i$5[ebp]
	add	eax, 1
	mov	DWORD PTR _i$5[ebp], eax
$LN13@DXUTRankDe:
	mov	ecx, DWORD PTR _pDeviceSettingsCombo$[ebp]
	add	ecx, 32					; 00000020H
	call	?GetSize@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QBEHXZ ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::GetSize
	cmp	DWORD PTR _i$5[ebp], eax
	jge	SHORT $LN11@DXUTRankDe

; 2024 :     {
; 2025 :         D3DMULTISAMPLE_TYPE msType = pDeviceSettingsCombo->multiSampleTypeList.GetAt(i);

	mov	eax, DWORD PTR _i$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeviceSettingsCombo$[ebp]
	add	ecx, 32					; 00000020H
	call	?GetAt@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEAAW4_D3DMULTISAMPLE_TYPE@@H@Z ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::GetAt
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _msType$4[ebp], ecx

; 2026 :         DWORD msQuality  = pDeviceSettingsCombo->multiSampleQualityList.GetAt(i);

	mov	eax, DWORD PTR _i$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeviceSettingsCombo$[ebp]
	add	ecx, 44					; 0000002cH
	call	?GetAt@?$CGrowableArray@K@@QAEAAKH@Z	; CGrowableArray<unsigned long>::GetAt
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _msQuality$3[ebp], ecx

; 2027 : 
; 2028 :         if( msType == pOptimalDeviceSettings->pp.MultiSampleType &&
; 2029 :             msQuality >= pOptimalDeviceSettings->pp.MultiSampleQuality )

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _msType$4[ebp]
	cmp	ecx, DWORD PTR [eax+32]
	jne	SHORT $LN10@DXUTRankDe
	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _msQuality$3[ebp]
	cmp	ecx, DWORD PTR [eax+36]
	jb	SHORT $LN10@DXUTRankDe

; 2030 :         {
; 2031 :             bMultiSampleFound = true;

	mov	BYTE PTR _bMultiSampleFound$[ebp], 1

; 2032 :             break;

	jmp	SHORT $LN11@DXUTRankDe
$LN10@DXUTRankDe:

; 2033 :         }
; 2034 :     }

	jmp	SHORT $LN12@DXUTRankDe
$LN11@DXUTRankDe:

; 2035 :     if( bMultiSampleFound )

	movzx	eax, BYTE PTR _bMultiSampleFound$[ebp]
	test	eax, eax
	je	SHORT $LN9@DXUTRankDe

; 2036 :         fCurRanking += fMultiSampleWeight;

	movss	xmm0, DWORD PTR _fCurRanking$[ebp]
	addss	xmm0, DWORD PTR _fMultiSampleWeight$[ebp]
	movss	DWORD PTR _fCurRanking$[ebp], xmm0
$LN9@DXUTRankDe:

; 2037 :         
; 2038 :     //---------------------
; 2039 :     // Swap effect
; 2040 :     //---------------------
; 2041 :     // No caps for swap effects
; 2042 : 
; 2043 :     //---------------------
; 2044 :     // Depth stencil 
; 2045 :     //---------------------
; 2046 :     if( pDeviceSettingsCombo->depthStencilFormatList.Contains( pOptimalDeviceSettings->pp.AutoDepthStencilFormat ) )

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	add	eax, 56					; 00000038H
	push	eax
	mov	ecx, DWORD PTR _pDeviceSettingsCombo$[ebp]
	add	ecx, 20					; 00000014H
	call	?Contains@?$CGrowableArray@W4_D3DFORMAT@@@@QAE_NABW4_D3DFORMAT@@@Z ; CGrowableArray<enum _D3DFORMAT>::Contains
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN8@DXUTRankDe

; 2047 :         fCurRanking += fDepthStencilWeight;

	movss	xmm0, DWORD PTR _fCurRanking$[ebp]
	addss	xmm0, DWORD PTR _fDepthStencilWeight$[ebp]
	movss	DWORD PTR _fCurRanking$[ebp], xmm0
$LN8@DXUTRankDe:

; 2048 : 
; 2049 :     //---------------------
; 2050 :     // Present flags
; 2051 :     //---------------------
; 2052 :     // No caps for the present flags
; 2053 : 
; 2054 :     //---------------------
; 2055 :     // Refresh rate
; 2056 :     //---------------------
; 2057 :     bool bRefreshFound = false;

	mov	BYTE PTR _bRefreshFound$[ebp], 0

; 2058 :     for( int idm = 0; idm < pDeviceSettingsCombo->pAdapterInfo->displayModeList.GetSize(); idm++ )

	mov	DWORD PTR _idm$2[ebp], 0
	jmp	SHORT $LN7@DXUTRankDe
$LN6@DXUTRankDe:
	mov	eax, DWORD PTR _idm$2[ebp]
	add	eax, 1
	mov	DWORD PTR _idm$2[ebp], eax
$LN7@DXUTRankDe:
	mov	eax, DWORD PTR _pDeviceSettingsCombo$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	add	ecx, 1360				; 00000550H
	call	?GetSize@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QBEHXZ ; CGrowableArray<_D3DDISPLAYMODE>::GetSize
	cmp	DWORD PTR _idm$2[ebp], eax
	jge	SHORT $LN5@DXUTRankDe

; 2059 :     {
; 2060 :         D3DDISPLAYMODE displayMode = pDeviceSettingsCombo->pAdapterInfo->displayModeList.GetAt( idm );

	mov	eax, DWORD PTR _idm$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeviceSettingsCombo$[ebp]
	mov	ecx, DWORD PTR [ecx+80]
	add	ecx, 1360				; 00000550H
	call	?GetAt@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAEAAU_D3DDISPLAYMODE@@H@Z ; CGrowableArray<_D3DDISPLAYMODE>::GetAt
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _displayMode$1[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _displayMode$1[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _displayMode$1[ebp+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR _displayMode$1[ebp+12], eax

; 2061 :         if( displayMode.Format != pDeviceSettingsCombo->AdapterFormat )

	mov	eax, DWORD PTR _pDeviceSettingsCombo$[ebp]
	mov	ecx, DWORD PTR _displayMode$1[ebp+12]
	cmp	ecx, DWORD PTR [eax+8]
	je	SHORT $LN4@DXUTRankDe

; 2062 :             continue;

	jmp	SHORT $LN6@DXUTRankDe
$LN4@DXUTRankDe:

; 2063 :         if( displayMode.RefreshRate == pOptimalDeviceSettings->pp.FullScreen_RefreshRateInHz )

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _displayMode$1[ebp+8]
	cmp	ecx, DWORD PTR [eax+64]
	jne	SHORT $LN3@DXUTRankDe

; 2064 :             bRefreshFound = true;

	mov	BYTE PTR _bRefreshFound$[ebp], 1
$LN3@DXUTRankDe:

; 2065 :     }

	jmp	$LN6@DXUTRankDe
$LN5@DXUTRankDe:

; 2066 :     if( bRefreshFound )

	movzx	eax, BYTE PTR _bRefreshFound$[ebp]
	test	eax, eax
	je	SHORT $LN2@DXUTRankDe

; 2067 :         fCurRanking += fRefreshRateWeight;

	movss	xmm0, DWORD PTR _fCurRanking$[ebp]
	addss	xmm0, DWORD PTR _fRefreshRateWeight$[ebp]
	movss	DWORD PTR _fCurRanking$[ebp], xmm0
$LN2@DXUTRankDe:

; 2068 : 
; 2069 :     //---------------------
; 2070 :     // Present interval
; 2071 :     //---------------------
; 2072 :     // If keep present interval then check that the present interval is supported by this combo
; 2073 :     if( pDeviceSettingsCombo->presentIntervalList.Contains( pOptimalDeviceSettings->pp.PresentationInterval ) )

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	add	eax, 68					; 00000044H
	push	eax
	mov	ecx, DWORD PTR _pDeviceSettingsCombo$[ebp]
	add	ecx, 56					; 00000038H
	call	?Contains@?$CGrowableArray@I@@QAE_NABI@Z ; CGrowableArray<unsigned int>::Contains
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@DXUTRankDe

; 2074 :         fCurRanking += fPresentIntervalWeight;

	movss	xmm0, DWORD PTR _fCurRanking$[ebp]
	addss	xmm0, DWORD PTR _fPresentIntervalWeight$[ebp]
	movss	DWORD PTR _fCurRanking$[ebp], xmm0
$LN1@DXUTRankDe:

; 2075 : 
; 2076 :     return fCurRanking;

	fld	DWORD PTR _fCurRanking$[ebp]

; 2077 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN52@DXUTRankDe
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 560				; 00000230H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN52@DXUTRankDe:
	DD	2
	DD	$LN51@DXUTRankDe
$LN51@DXUTRankDe:
	DD	-228					; ffffff1cH
	DD	16					; 00000010H
	DD	$LN49@DXUTRankDe
	DD	-360					; fffffe98H
	DD	16					; 00000010H
	DD	$LN50@DXUTRankDe
$LN50@DXUTRankDe:
	DB	100					; 00000064H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	77					; 0000004dH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
$LN49@DXUTRankDe:
	DB	100					; 00000064H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	77					; 0000004dH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
?DXUTRankDeviceCombo@@YAMPAUCD3DEnumDeviceSettingsCombo@@PAUDXUTDeviceSettings@@PAU_D3DDISPLAYMODE@@@Z ENDP ; DXUTRankDeviceCombo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTDoesDeviceComboMatchPreserveOptions@@YA_NPAUCD3DEnumDeviceSettingsCombo@@PAUDXUTDeviceSettings@@PAUDXUTMatchOptions@@@Z
_TEXT	SEGMENT
_displayMode$1 = -264					; size = 16
_i$2 = -240						; size = 4
_bFound$3 = -225					; size = 1
_dwCurStencilBits$4 = -216				; size = 4
_depthStencilFmt$5 = -204				; size = 4
_i$6 = -192						; size = 4
_dwStencilBits$7 = -180					; size = 4
_bFound$8 = -165					; size = 1
_dwCurDepthBits$9 = -156				; size = 4
_depthStencilFmt$10 = -144				; size = 4
_i$11 = -132						; size = 4
_dwDepthBits$12 = -120					; size = 4
_bFound$13 = -105					; size = 1
_msQuality$14 = -96					; size = 4
_msType$15 = -84					; size = 4
_i$16 = -72						; size = 4
_bFound$17 = -57					; size = 1
_displayMode$18 = -48					; size = 16
_i$19 = -24						; size = 4
_bFound$20 = -9						; size = 1
__$ArrayPad$ = -4					; size = 4
_pDeviceSettingsCombo$ = 8				; size = 4
_pDeviceSettingsIn$ = 12				; size = 4
_pMatchOptions$ = 16					; size = 4
?DXUTDoesDeviceComboMatchPreserveOptions@@YA_NPAUCD3DEnumDeviceSettingsCombo@@PAUDXUTDeviceSettings@@PAUDXUTMatchOptions@@@Z PROC ; DXUTDoesDeviceComboMatchPreserveOptions, COMDAT

; 1698 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 460				; 000001ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-460]
	mov	ecx, 115				; 00000073H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1699 :     //---------------------
; 1700 :     // Adapter ordinal
; 1701 :     //---------------------
; 1702 :     if( pMatchOptions->eAdapterOrdinal == DXUTMT_PRESERVE_INPUT && 
; 1703 :         (pDeviceSettingsCombo->AdapterOrdinal != pDeviceSettingsIn->AdapterOrdinal) )

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN41@DXUTDoesDe
	mov	eax, DWORD PTR _pDeviceSettingsCombo$[ebp]
	mov	ecx, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	je	SHORT $LN41@DXUTDoesDe

; 1704 :         return false;

	xor	al, al
	jmp	$LN42@DXUTDoesDe
$LN41@DXUTDoesDe:

; 1705 : 
; 1706 :     //---------------------
; 1707 :     // Device type
; 1708 :     //---------------------
; 1709 :     if( pMatchOptions->eDeviceType == DXUTMT_PRESERVE_INPUT && 
; 1710 :         (pDeviceSettingsCombo->DeviceType != pDeviceSettingsIn->DeviceType) )

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+4], 1
	jne	SHORT $LN40@DXUTDoesDe
	mov	eax, DWORD PTR _pDeviceSettingsCombo$[ebp]
	mov	ecx, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	je	SHORT $LN40@DXUTDoesDe

; 1711 :         return false;

	xor	al, al
	jmp	$LN42@DXUTDoesDe
$LN40@DXUTDoesDe:

; 1712 : 
; 1713 :     //---------------------
; 1714 :     // Windowed
; 1715 :     //---------------------
; 1716 :     if( pMatchOptions->eWindowed == DXUTMT_PRESERVE_INPUT && 
; 1717 :         (pDeviceSettingsCombo->Windowed != pDeviceSettingsIn->pp.Windowed) )

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+8], 1
	jne	SHORT $LN39@DXUTDoesDe
	mov	eax, DWORD PTR _pDeviceSettingsCombo$[ebp]
	mov	ecx, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	edx, DWORD PTR [eax+16]
	cmp	edx, DWORD PTR [ecx+48]
	je	SHORT $LN39@DXUTDoesDe

; 1718 :         return false;

	xor	al, al
	jmp	$LN42@DXUTDoesDe
$LN39@DXUTDoesDe:

; 1719 : 
; 1720 :     //---------------------
; 1721 :     // Adapter format
; 1722 :     //---------------------
; 1723 :     if( pMatchOptions->eAdapterFormat == DXUTMT_PRESERVE_INPUT && 
; 1724 :         (pDeviceSettingsCombo->AdapterFormat != pDeviceSettingsIn->AdapterFormat) )

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+12], 1
	jne	SHORT $LN38@DXUTDoesDe
	mov	eax, DWORD PTR _pDeviceSettingsCombo$[ebp]
	mov	ecx, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN38@DXUTDoesDe

; 1725 :         return false;

	xor	al, al
	jmp	$LN42@DXUTDoesDe
$LN38@DXUTDoesDe:

; 1726 : 
; 1727 :     //---------------------
; 1728 :     // Vertex processing
; 1729 :     //---------------------
; 1730 :     // If keep VP and input has HWVP, then skip if this combo doesn't have HWTL 
; 1731 :     if( pMatchOptions->eVertexProcessing == DXUTMT_PRESERVE_INPUT && 
; 1732 :         ((pDeviceSettingsIn->BehaviorFlags & D3DCREATE_HARDWARE_VERTEXPROCESSING) != 0) && 
; 1733 :         ((pDeviceSettingsCombo->pDeviceInfo->Caps.DevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT) == 0) )

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+16], 1
	jne	SHORT $LN37@DXUTDoesDe
	mov	eax, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 64					; 00000040H
	je	SHORT $LN37@DXUTDoesDe
	mov	eax, DWORD PTR _pDeviceSettingsCombo$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, 65536				; 00010000H
	jne	SHORT $LN37@DXUTDoesDe

; 1734 :         return false;

	xor	al, al
	jmp	$LN42@DXUTDoesDe
$LN37@DXUTDoesDe:

; 1735 : 
; 1736 :     //---------------------
; 1737 :     // Resolution
; 1738 :     //---------------------
; 1739 :     // If keep resolution then check that width and height supported by this combo
; 1740 :     if( pMatchOptions->eResolution == DXUTMT_PRESERVE_INPUT )

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+20], 1
	jne	$LN36@DXUTDoesDe

; 1741 :     {
; 1742 :         bool bFound = false;

	mov	BYTE PTR _bFound$20[ebp], 0

; 1743 :         for( int i=0; i< pDeviceSettingsCombo->pAdapterInfo->displayModeList.GetSize(); i++ )

	mov	DWORD PTR _i$19[ebp], 0
	jmp	SHORT $LN35@DXUTDoesDe
$LN34@DXUTDoesDe:
	mov	eax, DWORD PTR _i$19[ebp]
	add	eax, 1
	mov	DWORD PTR _i$19[ebp], eax
$LN35@DXUTDoesDe:
	mov	eax, DWORD PTR _pDeviceSettingsCombo$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	add	ecx, 1360				; 00000550H
	call	?GetSize@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QBEHXZ ; CGrowableArray<_D3DDISPLAYMODE>::GetSize
	cmp	DWORD PTR _i$19[ebp], eax
	jge	SHORT $LN33@DXUTDoesDe

; 1744 :         {
; 1745 :             D3DDISPLAYMODE displayMode = pDeviceSettingsCombo->pAdapterInfo->displayModeList.GetAt( i );

	mov	eax, DWORD PTR _i$19[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeviceSettingsCombo$[ebp]
	mov	ecx, DWORD PTR [ecx+80]
	add	ecx, 1360				; 00000550H
	call	?GetAt@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAEAAU_D3DDISPLAYMODE@@H@Z ; CGrowableArray<_D3DDISPLAYMODE>::GetAt
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _displayMode$18[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _displayMode$18[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _displayMode$18[ebp+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR _displayMode$18[ebp+12], eax

; 1746 :             if( displayMode.Format != pDeviceSettingsCombo->AdapterFormat )

	mov	eax, DWORD PTR _pDeviceSettingsCombo$[ebp]
	mov	ecx, DWORD PTR _displayMode$18[ebp+12]
	cmp	ecx, DWORD PTR [eax+8]
	je	SHORT $LN32@DXUTDoesDe

; 1747 :                 continue; // Skip this display mode if it doesn't match the combo's adapter format

	jmp	SHORT $LN34@DXUTDoesDe
$LN32@DXUTDoesDe:

; 1748 : 
; 1749 :             if( displayMode.Width == pDeviceSettingsIn->pp.BackBufferWidth &&
; 1750 :                 displayMode.Height == pDeviceSettingsIn->pp.BackBufferHeight )

	mov	eax, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	ecx, DWORD PTR _displayMode$18[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jne	SHORT $LN31@DXUTDoesDe
	mov	eax, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	ecx, DWORD PTR _displayMode$18[ebp+4]
	cmp	ecx, DWORD PTR [eax+20]
	jne	SHORT $LN31@DXUTDoesDe

; 1751 :             {
; 1752 :                 bFound = true;

	mov	BYTE PTR _bFound$20[ebp], 1

; 1753 :                 break;

	jmp	SHORT $LN33@DXUTDoesDe
$LN31@DXUTDoesDe:

; 1754 :             }
; 1755 :         }

	jmp	SHORT $LN34@DXUTDoesDe
$LN33@DXUTDoesDe:

; 1756 : 
; 1757 :         // If the width and height are not supported by this combo, return false
; 1758 :         if( !bFound )

	movzx	eax, BYTE PTR _bFound$20[ebp]
	test	eax, eax
	jne	SHORT $LN36@DXUTDoesDe

; 1759 :             return false;

	xor	al, al
	jmp	$LN42@DXUTDoesDe
$LN36@DXUTDoesDe:

; 1760 :     }
; 1761 : 
; 1762 :     //---------------------
; 1763 :     // Back buffer format
; 1764 :     //---------------------
; 1765 :     if( pMatchOptions->eBackBufferFormat == DXUTMT_PRESERVE_INPUT && 
; 1766 :         pDeviceSettingsCombo->BackBufferFormat != pDeviceSettingsIn->pp.BackBufferFormat )

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+24], 1
	jne	SHORT $LN29@DXUTDoesDe
	mov	eax, DWORD PTR _pDeviceSettingsCombo$[ebp]
	mov	ecx, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+24]
	je	SHORT $LN29@DXUTDoesDe

; 1767 :         return false;

	xor	al, al
	jmp	$LN42@DXUTDoesDe
$LN29@DXUTDoesDe:

; 1768 : 
; 1769 :     //---------------------
; 1770 :     // Back buffer count
; 1771 :     //---------------------
; 1772 :     // No caps for the back buffer count
; 1773 : 
; 1774 :     //---------------------
; 1775 :     // Multisample
; 1776 :     //---------------------
; 1777 :     if( pMatchOptions->eMultiSample == DXUTMT_PRESERVE_INPUT )

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+32], 1
	jne	SHORT $LN28@DXUTDoesDe

; 1778 :     {
; 1779 :         bool bFound = false;

	mov	BYTE PTR _bFound$17[ebp], 0

; 1780 :         for( int i=0; i<pDeviceSettingsCombo->multiSampleTypeList.GetSize(); i++ )

	mov	DWORD PTR _i$16[ebp], 0
	jmp	SHORT $LN27@DXUTDoesDe
$LN26@DXUTDoesDe:
	mov	eax, DWORD PTR _i$16[ebp]
	add	eax, 1
	mov	DWORD PTR _i$16[ebp], eax
$LN27@DXUTDoesDe:
	mov	ecx, DWORD PTR _pDeviceSettingsCombo$[ebp]
	add	ecx, 32					; 00000020H
	call	?GetSize@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QBEHXZ ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::GetSize
	cmp	DWORD PTR _i$16[ebp], eax
	jge	SHORT $LN25@DXUTDoesDe

; 1781 :         {
; 1782 :             D3DMULTISAMPLE_TYPE msType = pDeviceSettingsCombo->multiSampleTypeList.GetAt(i);

	mov	eax, DWORD PTR _i$16[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeviceSettingsCombo$[ebp]
	add	ecx, 32					; 00000020H
	call	?GetAt@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEAAW4_D3DMULTISAMPLE_TYPE@@H@Z ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::GetAt
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _msType$15[ebp], ecx

; 1783 :             DWORD msQuality  = pDeviceSettingsCombo->multiSampleQualityList.GetAt(i);

	mov	eax, DWORD PTR _i$16[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeviceSettingsCombo$[ebp]
	add	ecx, 44					; 0000002cH
	call	?GetAt@?$CGrowableArray@K@@QAEAAKH@Z	; CGrowableArray<unsigned long>::GetAt
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _msQuality$14[ebp], ecx

; 1784 : 
; 1785 :             if( msType == pDeviceSettingsIn->pp.MultiSampleType &&
; 1786 :                 msQuality >= pDeviceSettingsIn->pp.MultiSampleQuality )

	mov	eax, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	ecx, DWORD PTR _msType$15[ebp]
	cmp	ecx, DWORD PTR [eax+32]
	jne	SHORT $LN24@DXUTDoesDe
	mov	eax, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	ecx, DWORD PTR _msQuality$14[ebp]
	cmp	ecx, DWORD PTR [eax+36]
	jb	SHORT $LN24@DXUTDoesDe

; 1787 :             {
; 1788 :                 bFound = true;

	mov	BYTE PTR _bFound$17[ebp], 1

; 1789 :                 break;

	jmp	SHORT $LN25@DXUTDoesDe
$LN24@DXUTDoesDe:

; 1790 :             }
; 1791 :         }

	jmp	SHORT $LN26@DXUTDoesDe
$LN25@DXUTDoesDe:

; 1792 : 
; 1793 :         // If multisample type/quality not supported by this combo, then return false
; 1794 :         if( !bFound )

	movzx	eax, BYTE PTR _bFound$17[ebp]
	test	eax, eax
	jne	SHORT $LN28@DXUTDoesDe

; 1795 :             return false;

	xor	al, al
	jmp	$LN42@DXUTDoesDe
$LN28@DXUTDoesDe:

; 1796 :     }
; 1797 :         
; 1798 :     //---------------------
; 1799 :     // Swap effect
; 1800 :     //---------------------
; 1801 :     // No caps for swap effects
; 1802 : 
; 1803 :     //---------------------
; 1804 :     // Depth stencil 
; 1805 :     //---------------------
; 1806 :     // If keep depth stencil format then check that the depth stencil format is supported by this combo
; 1807 :     if( pMatchOptions->eDepthFormat == DXUTMT_PRESERVE_INPUT &&
; 1808 :         pMatchOptions->eStencilFormat == DXUTMT_PRESERVE_INPUT )

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+40], 1
	jne	SHORT $LN22@DXUTDoesDe
	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+44], 1
	jne	SHORT $LN22@DXUTDoesDe

; 1809 :     {
; 1810 :         if( pDeviceSettingsIn->pp.AutoDepthStencilFormat != D3DFMT_UNKNOWN &&
; 1811 :             !pDeviceSettingsCombo->depthStencilFormatList.Contains( pDeviceSettingsIn->pp.AutoDepthStencilFormat ) )

	mov	eax, DWORD PTR _pDeviceSettingsIn$[ebp]
	cmp	DWORD PTR [eax+56], 0
	je	SHORT $LN22@DXUTDoesDe
	mov	eax, DWORD PTR _pDeviceSettingsIn$[ebp]
	add	eax, 56					; 00000038H
	push	eax
	mov	ecx, DWORD PTR _pDeviceSettingsCombo$[ebp]
	add	ecx, 20					; 00000014H
	call	?Contains@?$CGrowableArray@W4_D3DFORMAT@@@@QAE_NABW4_D3DFORMAT@@@Z ; CGrowableArray<enum _D3DFORMAT>::Contains
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN22@DXUTDoesDe

; 1812 :             return false;

	xor	al, al
	jmp	$LN42@DXUTDoesDe
$LN22@DXUTDoesDe:

; 1813 :     }
; 1814 : 
; 1815 :     // If keep depth format then check that the depth format is supported by this combo
; 1816 :     if( pMatchOptions->eDepthFormat == DXUTMT_PRESERVE_INPUT &&
; 1817 :         pDeviceSettingsIn->pp.AutoDepthStencilFormat != D3DFMT_UNKNOWN )

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+40], 1
	jne	$LN20@DXUTDoesDe
	mov	eax, DWORD PTR _pDeviceSettingsIn$[ebp]
	cmp	DWORD PTR [eax+56], 0
	je	$LN20@DXUTDoesDe

; 1818 :     {
; 1819 :         bool bFound = false;

	mov	BYTE PTR _bFound$13[ebp], 0

; 1820 :         UINT dwDepthBits = DXUTDepthBits( pDeviceSettingsIn->pp.AutoDepthStencilFormat );

	mov	eax, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?DXUTDepthBits@@YAIW4_D3DFORMAT@@@Z	; DXUTDepthBits
	add	esp, 4
	mov	DWORD PTR _dwDepthBits$12[ebp], eax

; 1821 :         for( int i=0; i<pDeviceSettingsCombo->depthStencilFormatList.GetSize(); i++ )

	mov	DWORD PTR _i$11[ebp], 0
	jmp	SHORT $LN19@DXUTDoesDe
$LN18@DXUTDoesDe:
	mov	eax, DWORD PTR _i$11[ebp]
	add	eax, 1
	mov	DWORD PTR _i$11[ebp], eax
$LN19@DXUTDoesDe:
	mov	ecx, DWORD PTR _pDeviceSettingsCombo$[ebp]
	add	ecx, 20					; 00000014H
	call	?GetSize@?$CGrowableArray@W4_D3DFORMAT@@@@QBEHXZ ; CGrowableArray<enum _D3DFORMAT>::GetSize
	cmp	DWORD PTR _i$11[ebp], eax
	jge	SHORT $LN17@DXUTDoesDe

; 1822 :         {
; 1823 :             D3DFORMAT depthStencilFmt = pDeviceSettingsCombo->depthStencilFormatList.GetAt(i);

	mov	eax, DWORD PTR _i$11[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeviceSettingsCombo$[ebp]
	add	ecx, 20					; 00000014H
	call	?GetAt@?$CGrowableArray@W4_D3DFORMAT@@@@QAEAAW4_D3DFORMAT@@H@Z ; CGrowableArray<enum _D3DFORMAT>::GetAt
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _depthStencilFmt$10[ebp], ecx

; 1824 :             UINT dwCurDepthBits = DXUTDepthBits( depthStencilFmt );

	mov	eax, DWORD PTR _depthStencilFmt$10[ebp]
	push	eax
	call	?DXUTDepthBits@@YAIW4_D3DFORMAT@@@Z	; DXUTDepthBits
	add	esp, 4
	mov	DWORD PTR _dwCurDepthBits$9[ebp], eax

; 1825 :             if( dwCurDepthBits - dwDepthBits == 0)

	mov	eax, DWORD PTR _dwCurDepthBits$9[ebp]
	sub	eax, DWORD PTR _dwDepthBits$12[ebp]
	jne	SHORT $LN16@DXUTDoesDe

; 1826 :                 bFound = true;

	mov	BYTE PTR _bFound$13[ebp], 1
$LN16@DXUTDoesDe:

; 1827 :         }

	jmp	SHORT $LN18@DXUTDoesDe
$LN17@DXUTDoesDe:

; 1828 : 
; 1829 :         if( !bFound )

	movzx	eax, BYTE PTR _bFound$13[ebp]
	test	eax, eax
	jne	SHORT $LN20@DXUTDoesDe

; 1830 :             return false;

	xor	al, al
	jmp	$LN42@DXUTDoesDe
$LN20@DXUTDoesDe:

; 1831 :     }
; 1832 : 
; 1833 :     // If keep depth format then check that the depth format is supported by this combo
; 1834 :     if( pMatchOptions->eStencilFormat == DXUTMT_PRESERVE_INPUT &&
; 1835 :         pDeviceSettingsIn->pp.AutoDepthStencilFormat != D3DFMT_UNKNOWN )

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+44], 1
	jne	$LN14@DXUTDoesDe
	mov	eax, DWORD PTR _pDeviceSettingsIn$[ebp]
	cmp	DWORD PTR [eax+56], 0
	je	$LN14@DXUTDoesDe

; 1836 :     {
; 1837 :         bool bFound = false;

	mov	BYTE PTR _bFound$8[ebp], 0

; 1838 :         UINT dwStencilBits = DXUTStencilBits( pDeviceSettingsIn->pp.AutoDepthStencilFormat );

	mov	eax, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	call	?DXUTStencilBits@@YAIW4_D3DFORMAT@@@Z	; DXUTStencilBits
	add	esp, 4
	mov	DWORD PTR _dwStencilBits$7[ebp], eax

; 1839 :         for( int i=0; i<pDeviceSettingsCombo->depthStencilFormatList.GetSize(); i++ )

	mov	DWORD PTR _i$6[ebp], 0
	jmp	SHORT $LN13@DXUTDoesDe
$LN12@DXUTDoesDe:
	mov	eax, DWORD PTR _i$6[ebp]
	add	eax, 1
	mov	DWORD PTR _i$6[ebp], eax
$LN13@DXUTDoesDe:
	mov	ecx, DWORD PTR _pDeviceSettingsCombo$[ebp]
	add	ecx, 20					; 00000014H
	call	?GetSize@?$CGrowableArray@W4_D3DFORMAT@@@@QBEHXZ ; CGrowableArray<enum _D3DFORMAT>::GetSize
	cmp	DWORD PTR _i$6[ebp], eax
	jge	SHORT $LN11@DXUTDoesDe

; 1840 :         {
; 1841 :             D3DFORMAT depthStencilFmt = pDeviceSettingsCombo->depthStencilFormatList.GetAt(i);

	mov	eax, DWORD PTR _i$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeviceSettingsCombo$[ebp]
	add	ecx, 20					; 00000014H
	call	?GetAt@?$CGrowableArray@W4_D3DFORMAT@@@@QAEAAW4_D3DFORMAT@@H@Z ; CGrowableArray<enum _D3DFORMAT>::GetAt
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _depthStencilFmt$5[ebp], ecx

; 1842 :             UINT dwCurStencilBits = DXUTStencilBits( depthStencilFmt );

	mov	eax, DWORD PTR _depthStencilFmt$5[ebp]
	push	eax
	call	?DXUTStencilBits@@YAIW4_D3DFORMAT@@@Z	; DXUTStencilBits
	add	esp, 4
	mov	DWORD PTR _dwCurStencilBits$4[ebp], eax

; 1843 :             if( dwCurStencilBits - dwStencilBits == 0)

	mov	eax, DWORD PTR _dwCurStencilBits$4[ebp]
	sub	eax, DWORD PTR _dwStencilBits$7[ebp]
	jne	SHORT $LN10@DXUTDoesDe

; 1844 :                 bFound = true;

	mov	BYTE PTR _bFound$8[ebp], 1
$LN10@DXUTDoesDe:

; 1845 :         }

	jmp	SHORT $LN12@DXUTDoesDe
$LN11@DXUTDoesDe:

; 1846 : 
; 1847 :         if( !bFound )

	movzx	eax, BYTE PTR _bFound$8[ebp]
	test	eax, eax
	jne	SHORT $LN14@DXUTDoesDe

; 1848 :             return false;

	xor	al, al
	jmp	$LN42@DXUTDoesDe
$LN14@DXUTDoesDe:

; 1849 :     }
; 1850 : 
; 1851 :     //---------------------
; 1852 :     // Present flags
; 1853 :     //---------------------
; 1854 :     // No caps for the present flags
; 1855 : 
; 1856 :     //---------------------
; 1857 :     // Refresh rate
; 1858 :     //---------------------
; 1859 :     // If keep refresh rate then check that the resolution is supported by this combo
; 1860 :     if( pMatchOptions->eRefreshRate == DXUTMT_PRESERVE_INPUT )

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+52], 1
	jne	$LN8@DXUTDoesDe

; 1861 :     {
; 1862 :         bool bFound = false;

	mov	BYTE PTR _bFound$3[ebp], 0

; 1863 :         for( int i=0; i<pDeviceSettingsCombo->pAdapterInfo->displayModeList.GetSize(); i++ )

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN7@DXUTDoesDe
$LN6@DXUTDoesDe:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN7@DXUTDoesDe:
	mov	eax, DWORD PTR _pDeviceSettingsCombo$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	add	ecx, 1360				; 00000550H
	call	?GetSize@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QBEHXZ ; CGrowableArray<_D3DDISPLAYMODE>::GetSize
	cmp	DWORD PTR _i$2[ebp], eax
	jge	SHORT $LN5@DXUTDoesDe

; 1864 :         {
; 1865 :             D3DDISPLAYMODE displayMode = pDeviceSettingsCombo->pAdapterInfo->displayModeList.GetAt( i );

	mov	eax, DWORD PTR _i$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeviceSettingsCombo$[ebp]
	mov	ecx, DWORD PTR [ecx+80]
	add	ecx, 1360				; 00000550H
	call	?GetAt@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAEAAU_D3DDISPLAYMODE@@H@Z ; CGrowableArray<_D3DDISPLAYMODE>::GetAt
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _displayMode$1[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _displayMode$1[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _displayMode$1[ebp+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR _displayMode$1[ebp+12], eax

; 1866 :             if( displayMode.Format != pDeviceSettingsCombo->AdapterFormat )

	mov	eax, DWORD PTR _pDeviceSettingsCombo$[ebp]
	mov	ecx, DWORD PTR _displayMode$1[ebp+12]
	cmp	ecx, DWORD PTR [eax+8]
	je	SHORT $LN4@DXUTDoesDe

; 1867 :                 continue;

	jmp	SHORT $LN6@DXUTDoesDe
$LN4@DXUTDoesDe:

; 1868 :             if( displayMode.RefreshRate == pDeviceSettingsIn->pp.FullScreen_RefreshRateInHz )

	mov	eax, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	ecx, DWORD PTR _displayMode$1[ebp+8]
	cmp	ecx, DWORD PTR [eax+64]
	jne	SHORT $LN3@DXUTDoesDe

; 1869 :             {
; 1870 :                 bFound = true;

	mov	BYTE PTR _bFound$3[ebp], 1

; 1871 :                 break;

	jmp	SHORT $LN5@DXUTDoesDe
$LN3@DXUTDoesDe:

; 1872 :             }
; 1873 :         }

	jmp	$LN6@DXUTDoesDe
$LN5@DXUTDoesDe:

; 1874 : 
; 1875 :         // If refresh rate not supported by this combo, then return false
; 1876 :         if( !bFound )

	movzx	eax, BYTE PTR _bFound$3[ebp]
	test	eax, eax
	jne	SHORT $LN8@DXUTDoesDe

; 1877 :             return false;

	xor	al, al
	jmp	SHORT $LN42@DXUTDoesDe
$LN8@DXUTDoesDe:

; 1878 :     }
; 1879 : 
; 1880 :     //---------------------
; 1881 :     // Present interval
; 1882 :     //---------------------
; 1883 :     // If keep present interval then check that the present interval is supported by this combo
; 1884 :     if( pMatchOptions->ePresentInterval == DXUTMT_PRESERVE_INPUT &&
; 1885 :         !pDeviceSettingsCombo->presentIntervalList.Contains( pDeviceSettingsIn->pp.PresentationInterval ) )

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+56], 1
	jne	SHORT $LN1@DXUTDoesDe
	mov	eax, DWORD PTR _pDeviceSettingsIn$[ebp]
	add	eax, 68					; 00000044H
	push	eax
	mov	ecx, DWORD PTR _pDeviceSettingsCombo$[ebp]
	add	ecx, 56					; 00000038H
	call	?Contains@?$CGrowableArray@I@@QAE_NABI@Z ; CGrowableArray<unsigned int>::Contains
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@DXUTDoesDe

; 1886 :         return false;

	xor	al, al
	jmp	SHORT $LN42@DXUTDoesDe
$LN1@DXUTDoesDe:

; 1887 : 
; 1888 :     return true;

	mov	al, 1
$LN42@DXUTDoesDe:

; 1889 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN47@DXUTDoesDe
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 460				; 000001ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN47@DXUTDoesDe:
	DD	2
	DD	$LN46@DXUTDoesDe
$LN46@DXUTDoesDe:
	DD	-48					; ffffffd0H
	DD	16					; 00000010H
	DD	$LN44@DXUTDoesDe
	DD	-264					; fffffef8H
	DD	16					; 00000010H
	DD	$LN45@DXUTDoesDe
$LN45@DXUTDoesDe:
	DB	100					; 00000064H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	77					; 0000004dH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
$LN44@DXUTDoesDe:
	DB	100					; 00000064H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	77					; 0000004dH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
?DXUTDoesDeviceComboMatchPreserveOptions@@YA_NPAUCD3DEnumDeviceSettingsCombo@@PAUDXUTDeviceSettings@@PAUDXUTMatchOptions@@@Z ENDP ; DXUTDoesDeviceComboMatchPreserveOptions
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTBuildOptimalDeviceSettings@@YAXPAUDXUTDeviceSettings@@0PAUDXUTMatchOptions@@@Z
_TEXT	SEGMENT
_nBackBufferBits$1 = -48				; size = 4
_adapterDesktopDisplayMode$ = -36			; size = 16
_pD3D$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_pOptimalDeviceSettings$ = 8				; size = 4
_pDeviceSettingsIn$ = 12				; size = 4
_pMatchOptions$ = 16					; size = 4
?DXUTBuildOptimalDeviceSettings@@YAXPAUDXUTDeviceSettings@@0PAUDXUTMatchOptions@@@Z PROC ; DXUTBuildOptimalDeviceSettings, COMDAT

; 1515 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1516 :     IDirect3D9* pD3D = DXUTGetD3DObject();

	call	?DXUTGetD3DObject@@YAPAUIDirect3D9@@XZ	; DXUTGetD3DObject
	mov	DWORD PTR _pD3D$[ebp], eax

; 1517 :     D3DDISPLAYMODE adapterDesktopDisplayMode;
; 1518 : 
; 1519 :     ZeroMemory( pOptimalDeviceSettings, sizeof(DXUTDeviceSettings) ); 

	push	72					; 00000048H
	push	0
	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1520 : 
; 1521 :     //---------------------
; 1522 :     // Adapter ordinal
; 1523 :     //---------------------    
; 1524 :     if( pMatchOptions->eAdapterOrdinal == DXUTMT_IGNORE_INPUT )

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN37@DXUTBuildO

; 1525 :         pOptimalDeviceSettings->AdapterOrdinal = D3DADAPTER_DEFAULT; 

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	DWORD PTR [eax], 0

; 1526 :     else

	jmp	SHORT $LN36@DXUTBuildO
$LN37@DXUTBuildO:

; 1527 :         pOptimalDeviceSettings->AdapterOrdinal = pDeviceSettingsIn->AdapterOrdinal;      

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN36@DXUTBuildO:

; 1528 : 
; 1529 :     //---------------------
; 1530 :     // Device type
; 1531 :     //---------------------
; 1532 :     if( pMatchOptions->eDeviceType == DXUTMT_IGNORE_INPUT )

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN35@DXUTBuildO

; 1533 :         pOptimalDeviceSettings->DeviceType = D3DDEVTYPE_HAL; 

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	DWORD PTR [eax+4], 1

; 1534 :     else

	jmp	SHORT $LN34@DXUTBuildO
$LN35@DXUTBuildO:

; 1535 :         pOptimalDeviceSettings->DeviceType = pDeviceSettingsIn->DeviceType;

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
$LN34@DXUTBuildO:

; 1536 : 
; 1537 :     //---------------------
; 1538 :     // Windowed
; 1539 :     //---------------------
; 1540 :     if( pMatchOptions->eWindowed == DXUTMT_IGNORE_INPUT )

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN33@DXUTBuildO

; 1541 :         pOptimalDeviceSettings->pp.Windowed = TRUE; 

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	DWORD PTR [eax+48], 1

; 1542 :     else

	jmp	SHORT $LN32@DXUTBuildO
$LN33@DXUTBuildO:

; 1543 :         pOptimalDeviceSettings->pp.Windowed = pDeviceSettingsIn->pp.Windowed;

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+48], edx
$LN32@DXUTBuildO:

; 1544 : 
; 1545 :     //---------------------
; 1546 :     // Adapter format
; 1547 :     //---------------------
; 1548 :     if( pMatchOptions->eAdapterFormat == DXUTMT_IGNORE_INPUT )

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN31@DXUTBuildO

; 1549 :     {
; 1550 :         // If windowed, default to the desktop display mode
; 1551 :         // If fullscreen, default to the desktop display mode for quick mode change or 
; 1552 :         // default to D3DFMT_X8R8G8B8 if the desktop display mode is < 32bit
; 1553 :         pD3D->GetAdapterDisplayMode( pOptimalDeviceSettings->AdapterOrdinal, &adapterDesktopDisplayMode );

	mov	esi, esp
	lea	eax, DWORD PTR _adapterDesktopDisplayMode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pD3D$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pD3D$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+32]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1554 :         if( pOptimalDeviceSettings->pp.Windowed || DXUTColorChannelBits(adapterDesktopDisplayMode.Format) >= 8 )

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	cmp	DWORD PTR [eax+48], 0
	jne	SHORT $LN29@DXUTBuildO
	mov	eax, DWORD PTR _adapterDesktopDisplayMode$[ebp+12]
	push	eax
	call	?DXUTColorChannelBits@@YAIW4_D3DFORMAT@@@Z ; DXUTColorChannelBits
	add	esp, 4
	cmp	eax, 8
	jb	SHORT $LN30@DXUTBuildO
$LN29@DXUTBuildO:

; 1555 :             pOptimalDeviceSettings->AdapterFormat = adapterDesktopDisplayMode.Format;

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _adapterDesktopDisplayMode$[ebp+12]
	mov	DWORD PTR [eax+8], ecx

; 1556 :         else

	jmp	SHORT $LN28@DXUTBuildO
$LN30@DXUTBuildO:

; 1557 :             pOptimalDeviceSettings->AdapterFormat = D3DFMT_X8R8G8B8;

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	DWORD PTR [eax+8], 22			; 00000016H
$LN28@DXUTBuildO:

; 1558 :     }
; 1559 :     else

	jmp	SHORT $LN27@DXUTBuildO
$LN31@DXUTBuildO:

; 1560 :     {
; 1561 :         pOptimalDeviceSettings->AdapterFormat = pDeviceSettingsIn->AdapterFormat;

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
$LN27@DXUTBuildO:

; 1562 :     }
; 1563 : 
; 1564 :     //---------------------
; 1565 :     // Vertex processing
; 1566 :     //---------------------
; 1567 :     if( pMatchOptions->eVertexProcessing == DXUTMT_IGNORE_INPUT )

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN26@DXUTBuildO

; 1568 :         pOptimalDeviceSettings->BehaviorFlags = D3DCREATE_HARDWARE_VERTEXPROCESSING; 

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	DWORD PTR [eax+12], 64			; 00000040H

; 1569 :     else

	jmp	SHORT $LN25@DXUTBuildO
$LN26@DXUTBuildO:

; 1570 :         pOptimalDeviceSettings->BehaviorFlags = pDeviceSettingsIn->BehaviorFlags;

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
$LN25@DXUTBuildO:

; 1571 : 
; 1572 :     //---------------------
; 1573 :     // Resolution
; 1574 :     //---------------------
; 1575 :     if( pMatchOptions->eResolution == DXUTMT_IGNORE_INPUT )

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN24@DXUTBuildO

; 1576 :     {
; 1577 :         // If windowed, default to 640x480
; 1578 :         // If fullscreen, default to the desktop res for quick mode change
; 1579 :         if( pOptimalDeviceSettings->pp.Windowed )

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN23@DXUTBuildO

; 1580 :         {
; 1581 :             pOptimalDeviceSettings->pp.BackBufferWidth = 640;

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	DWORD PTR [eax+16], 640			; 00000280H

; 1582 :             pOptimalDeviceSettings->pp.BackBufferHeight = 480;

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	DWORD PTR [eax+20], 480			; 000001e0H

; 1583 :         }
; 1584 :         else

	jmp	SHORT $LN22@DXUTBuildO
$LN23@DXUTBuildO:

; 1585 :         {
; 1586 :             pD3D->GetAdapterDisplayMode( pOptimalDeviceSettings->AdapterOrdinal, &adapterDesktopDisplayMode );

	mov	esi, esp
	lea	eax, DWORD PTR _adapterDesktopDisplayMode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pD3D$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pD3D$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+32]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1587 :             pOptimalDeviceSettings->pp.BackBufferWidth = adapterDesktopDisplayMode.Width;

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _adapterDesktopDisplayMode$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 1588 :             pOptimalDeviceSettings->pp.BackBufferHeight = adapterDesktopDisplayMode.Height;

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _adapterDesktopDisplayMode$[ebp+4]
	mov	DWORD PTR [eax+20], ecx
$LN22@DXUTBuildO:

; 1589 :         }
; 1590 :     }
; 1591 :     else

	jmp	SHORT $LN21@DXUTBuildO
$LN24@DXUTBuildO:

; 1592 :     {
; 1593 :         pOptimalDeviceSettings->pp.BackBufferWidth = pDeviceSettingsIn->pp.BackBufferWidth;

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 1594 :         pOptimalDeviceSettings->pp.BackBufferHeight = pDeviceSettingsIn->pp.BackBufferHeight;

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx
$LN21@DXUTBuildO:

; 1595 :     }
; 1596 : 
; 1597 :     //---------------------
; 1598 :     // Back buffer format
; 1599 :     //---------------------
; 1600 :     if( pMatchOptions->eBackBufferFormat == DXUTMT_IGNORE_INPUT )

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN20@DXUTBuildO

; 1601 :         pOptimalDeviceSettings->pp.BackBufferFormat = pOptimalDeviceSettings->AdapterFormat; // Default to match the adapter format

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+24], edx

; 1602 :     else

	jmp	SHORT $LN19@DXUTBuildO
$LN20@DXUTBuildO:

; 1603 :         pOptimalDeviceSettings->pp.BackBufferFormat = pDeviceSettingsIn->pp.BackBufferFormat;

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx
$LN19@DXUTBuildO:

; 1604 : 
; 1605 :     //---------------------
; 1606 :     // Back buffer count
; 1607 :     //---------------------
; 1608 :     if( pMatchOptions->eBackBufferCount == DXUTMT_IGNORE_INPUT )

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+28], 0
	jne	SHORT $LN18@DXUTBuildO

; 1609 :         pOptimalDeviceSettings->pp.BackBufferCount = 2; // Default to triple buffering for perf gain

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	DWORD PTR [eax+28], 2

; 1610 :     else

	jmp	SHORT $LN17@DXUTBuildO
$LN18@DXUTBuildO:

; 1611 :         pOptimalDeviceSettings->pp.BackBufferCount = pDeviceSettingsIn->pp.BackBufferCount;

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], edx
$LN17@DXUTBuildO:

; 1612 :    
; 1613 :     //---------------------
; 1614 :     // Multisample
; 1615 :     //---------------------
; 1616 :     if( pMatchOptions->eMultiSample == DXUTMT_IGNORE_INPUT )

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $LN16@DXUTBuildO

; 1617 :     {
; 1618 :         // Default to no multisampling 
; 1619 :         pOptimalDeviceSettings->pp.MultiSampleType = D3DMULTISAMPLE_NONE;

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	DWORD PTR [eax+32], 0

; 1620 :         pOptimalDeviceSettings->pp.MultiSampleQuality = 0; 

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	DWORD PTR [eax+36], 0

; 1621 :     }
; 1622 :     else

	jmp	SHORT $LN15@DXUTBuildO
$LN16@DXUTBuildO:

; 1623 :     {
; 1624 :         pOptimalDeviceSettings->pp.MultiSampleType = pDeviceSettingsIn->pp.MultiSampleType;

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+32], edx

; 1625 :         pOptimalDeviceSettings->pp.MultiSampleQuality = pDeviceSettingsIn->pp.MultiSampleQuality;

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+36], edx
$LN15@DXUTBuildO:

; 1626 :     }
; 1627 : 
; 1628 :     //---------------------
; 1629 :     // Swap effect
; 1630 :     //---------------------
; 1631 :     if( pMatchOptions->eSwapEffect == DXUTMT_IGNORE_INPUT )

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+36], 0
	jne	SHORT $LN14@DXUTBuildO

; 1632 :         pOptimalDeviceSettings->pp.SwapEffect = D3DSWAPEFFECT_DISCARD; 

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	DWORD PTR [eax+40], 1

; 1633 :     else

	jmp	SHORT $LN13@DXUTBuildO
$LN14@DXUTBuildO:

; 1634 :         pOptimalDeviceSettings->pp.SwapEffect = pDeviceSettingsIn->pp.SwapEffect;

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+40], edx
$LN13@DXUTBuildO:

; 1635 : 
; 1636 :     //---------------------
; 1637 :     // Depth stencil 
; 1638 :     //---------------------
; 1639 :     if( pMatchOptions->eDepthFormat == DXUTMT_IGNORE_INPUT &&
; 1640 :         pMatchOptions->eStencilFormat == DXUTMT_IGNORE_INPUT )

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $LN12@DXUTBuildO
	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+44], 0
	jne	SHORT $LN12@DXUTBuildO

; 1641 :     {
; 1642 :         UINT nBackBufferBits = DXUTColorChannelBits( pOptimalDeviceSettings->pp.BackBufferFormat );

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?DXUTColorChannelBits@@YAIW4_D3DFORMAT@@@Z ; DXUTColorChannelBits
	add	esp, 4
	mov	DWORD PTR _nBackBufferBits$1[ebp], eax

; 1643 :         if( nBackBufferBits >= 8 )

	cmp	DWORD PTR _nBackBufferBits$1[ebp], 8
	jb	SHORT $LN11@DXUTBuildO

; 1644 :             pOptimalDeviceSettings->pp.AutoDepthStencilFormat = D3DFMT_D32; 

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	DWORD PTR [eax+56], 71			; 00000047H

; 1645 :         else

	jmp	SHORT $LN10@DXUTBuildO
$LN11@DXUTBuildO:

; 1646 :             pOptimalDeviceSettings->pp.AutoDepthStencilFormat = D3DFMT_D16; 

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	DWORD PTR [eax+56], 80			; 00000050H
$LN10@DXUTBuildO:

; 1647 :     }
; 1648 :     else

	jmp	SHORT $LN9@DXUTBuildO
$LN12@DXUTBuildO:

; 1649 :     {
; 1650 :         pOptimalDeviceSettings->pp.AutoDepthStencilFormat = pDeviceSettingsIn->pp.AutoDepthStencilFormat;

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR [eax+56], edx
$LN9@DXUTBuildO:

; 1651 :     }
; 1652 : 
; 1653 :     //---------------------
; 1654 :     // Present flags
; 1655 :     //---------------------
; 1656 :     if( pMatchOptions->ePresentFlags == DXUTMT_IGNORE_INPUT )

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+48], 0
	jne	SHORT $LN8@DXUTBuildO

; 1657 :         pOptimalDeviceSettings->pp.Flags = D3DPRESENTFLAG_DISCARD_DEPTHSTENCIL;

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	DWORD PTR [eax+60], 2

; 1658 :     else

	jmp	SHORT $LN7@DXUTBuildO
$LN8@DXUTBuildO:

; 1659 :         pOptimalDeviceSettings->pp.Flags = pDeviceSettingsIn->pp.Flags;

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR [eax+60], edx
$LN7@DXUTBuildO:

; 1660 : 
; 1661 :     //---------------------
; 1662 :     // Refresh rate
; 1663 :     //---------------------
; 1664 :     if( pMatchOptions->eRefreshRate == DXUTMT_IGNORE_INPUT )

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+52], 0
	jne	SHORT $LN6@DXUTBuildO

; 1665 :         pOptimalDeviceSettings->pp.FullScreen_RefreshRateInHz = 0;

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	DWORD PTR [eax+64], 0

; 1666 :     else

	jmp	SHORT $LN5@DXUTBuildO
$LN6@DXUTBuildO:

; 1667 :         pOptimalDeviceSettings->pp.FullScreen_RefreshRateInHz = pDeviceSettingsIn->pp.FullScreen_RefreshRateInHz;

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR [eax+64], edx
$LN5@DXUTBuildO:

; 1668 : 
; 1669 :     //---------------------
; 1670 :     // Present interval
; 1671 :     //---------------------
; 1672 :     if( pMatchOptions->ePresentInterval == DXUTMT_IGNORE_INPUT )

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	cmp	DWORD PTR [eax+56], 0
	jne	SHORT $LN4@DXUTBuildO

; 1673 :     {
; 1674 :         // For windowed, default to D3DPRESENT_INTERVAL_IMMEDIATE
; 1675 :         // which will wait not for the vertical retrace period to prevent tearing, 
; 1676 :         // but may introduce tearing.
; 1677 :         // For full screen, default to D3DPRESENT_INTERVAL_DEFAULT 
; 1678 :         // which will wait for the vertical retrace period to prevent tearing.
; 1679 :         if( pOptimalDeviceSettings->pp.Windowed )

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN3@DXUTBuildO

; 1680 :             pOptimalDeviceSettings->pp.PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	DWORD PTR [eax+68], -2147483648		; 80000000H

; 1681 :         else

	jmp	SHORT $LN2@DXUTBuildO
$LN3@DXUTBuildO:

; 1682 :             pOptimalDeviceSettings->pp.PresentationInterval = D3DPRESENT_INTERVAL_DEFAULT;

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	DWORD PTR [eax+68], 0
$LN2@DXUTBuildO:

; 1683 :     }
; 1684 :     else

	jmp	SHORT $LN38@DXUTBuildO
$LN4@DXUTBuildO:

; 1685 :     {
; 1686 :         pOptimalDeviceSettings->pp.PresentationInterval = pDeviceSettingsIn->pp.PresentationInterval;

	mov	eax, DWORD PTR _pOptimalDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _pDeviceSettingsIn$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR [eax+68], edx
$LN38@DXUTBuildO:

; 1687 :     }
; 1688 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN42@DXUTBuildO
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN42@DXUTBuildO:
	DD	1
	DD	$LN41@DXUTBuildO
$LN41@DXUTBuildO:
	DD	-36					; ffffffdcH
	DD	16					; 00000010H
	DD	$LN40@DXUTBuildO
$LN40@DXUTBuildO:
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	68					; 00000044H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	107					; 0000006bH
	DB	116					; 00000074H
	DB	111					; 0000006fH
	DB	112					; 00000070H
	DB	68					; 00000044H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	77					; 0000004dH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
?DXUTBuildOptimalDeviceSettings@@YAXPAUDXUTDeviceSettings@@0PAUDXUTMatchOptions@@@Z ENDP ; DXUTBuildOptimalDeviceSettings
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTPrepareEnumerationObject@@YAPAVCD3DEnumeration@@_N@Z
_TEXT	SEGMENT
_pD3D$1 = -20						; size = 4
_pd3dEnum$ = -8						; size = 4
_bEnumerate$ = 8					; size = 1
?DXUTPrepareEnumerationObject@@YAPAVCD3DEnumeration@@_N@Z PROC ; DXUTPrepareEnumerationObject, COMDAT

; 1365 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1366 :     // Create a new CD3DEnumeration object and enumerate all devices unless its already been done
; 1367 :     CD3DEnumeration* pd3dEnum = GetDXUTState().GetD3DEnumeration();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetD3DEnumeration@DXUTState@@QAEPAVCD3DEnumeration@@XZ ; DXUTState::GetD3DEnumeration
	mov	DWORD PTR _pd3dEnum$[ebp], eax

; 1368 :     if( pd3dEnum == NULL )

	cmp	DWORD PTR _pd3dEnum$[ebp], 0
	jne	SHORT $LN2@DXUTPrepar

; 1369 :     {
; 1370 :         pd3dEnum = DXUTGetEnumeration(); 

	call	?DXUTGetEnumeration@@YAPAVCD3DEnumeration@@XZ ; DXUTGetEnumeration
	mov	DWORD PTR _pd3dEnum$[ebp], eax

; 1371 :         GetDXUTState().SetD3DEnumeration( pd3dEnum );

	mov	eax, DWORD PTR _pd3dEnum$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetD3DEnumeration@DXUTState@@QAEXPAVCD3DEnumeration@@@Z ; DXUTState::SetD3DEnumeration

; 1372 : 
; 1373 :         bEnumerate = true;

	mov	BYTE PTR _bEnumerate$[ebp], 1
$LN2@DXUTPrepar:

; 1374 :     }
; 1375 : 
; 1376 :     if( bEnumerate )

	movzx	eax, BYTE PTR _bEnumerate$[ebp]
	test	eax, eax
	je	SHORT $LN1@DXUTPrepar

; 1377 :     {
; 1378 :         // Enumerate for each adapter all of the supported display modes, 
; 1379 :         // device types, adapter formats, back buffer formats, window/full screen support, 
; 1380 :         // depth stencil formats, multisampling types/qualities, and presentations intervals.
; 1381 :         //
; 1382 :         // For each combination of device type (HAL/REF), adapter format, back buffer format, and
; 1383 :         // IsWindowed it will call the app's ConfirmDevice callback.  This allows the app
; 1384 :         // to reject or allow that combination based on its caps/etc.  It also allows the 
; 1385 :         // app to change the BehaviorFlags.  The BehaviorFlags defaults non-pure HWVP 
; 1386 :         // if supported otherwise it will default to SWVP, however the app can change this 
; 1387 :         // through the ConfirmDevice callback.
; 1388 :         IDirect3D9* pD3D = DXUTGetD3DObject();

	call	?DXUTGetD3DObject@@YAPAUIDirect3D9@@XZ	; DXUTGetD3DObject
	mov	DWORD PTR _pD3D$1[ebp], eax

; 1389 :         pd3dEnum->Enumerate( pD3D, GetDXUTState().GetIsDeviceAcceptableFunc(), GetDXUTState().GetIsDeviceAcceptableFuncUserContext() );

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetIsDeviceAcceptableFuncUserContext@DXUTState@@QAEPAXXZ ; DXUTState::GetIsDeviceAcceptableFuncUserContext
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetIsDeviceAcceptableFunc@DXUTState@@QAEP6G_NPAU_D3DCAPS9@@W4_D3DFORMAT@@1_NPAX@ZXZ ; DXUTState::GetIsDeviceAcceptableFunc
	push	eax
	mov	eax, DWORD PTR _pD3D$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _pd3dEnum$[ebp]
	call	?Enumerate@CD3DEnumeration@@QAEJPAUIDirect3D9@@P6G_NPAU_D3DCAPS9@@W4_D3DFORMAT@@2_NPAX@Z4@Z ; CD3DEnumeration::Enumerate
$LN1@DXUTPrepar:

; 1390 :     }
; 1391 :     
; 1392 :     return pd3dEnum;

	mov	eax, DWORD PTR _pd3dEnum$[ebp]

; 1393 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTPrepareEnumerationObject@@YAPAVCD3DEnumeration@@_N@Z ENDP ; DXUTPrepareEnumerationObject
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTParseCommandLine@@YAXXZ
_TEXT	SEGMENT
_strSpace$1 = -384					; size = 4
_nFrame$2 = -372					; size = 4
_fTimePerFrame$3 = -360					; size = 4
_nY$4 = -348						; size = 4
_nX$5 = -336						; size = 4
_nHeight$6 = -324					; size = 4
_nWidth$7 = -312					; size = 4
_nAdapter$8 = -300					; size = 4
_nFlagLen$9 = -288					; size = 4
_strFlag$10 = -276					; size = 256
_strCmdLine$ = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
?DXUTParseCommandLine@@YAXXZ PROC			; DXUTParseCommandLine, COMDAT

; 527  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-580]
	mov	ecx, 145				; 00000091H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 528  :     TCHAR* strCmdLine = GetCommandLine();

	mov	esi, esp
	call	DWORD PTR __imp__GetCommandLineA@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _strCmdLine$[ebp], eax

; 529  : 
; 530  :     // Skip past program name (first token in command line).
; 531  :     if (*strCmdLine == L'"')  // Check for and handle quoted program name

	mov	eax, DWORD PTR _strCmdLine$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 34					; 00000022H
	jne	SHORT $LN40@DXUTParseC

; 532  :     {
; 533  :         strCmdLine++;

	mov	eax, DWORD PTR _strCmdLine$[ebp]
	add	eax, 1
	mov	DWORD PTR _strCmdLine$[ebp], eax
$LN39@DXUTParseC:

; 534  : 
; 535  :         // Skip over until another double-quote or a null 
; 536  :         while (*strCmdLine && (*strCmdLine != L'"'))

	mov	eax, DWORD PTR _strCmdLine$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN38@DXUTParseC
	mov	eax, DWORD PTR _strCmdLine$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 34					; 00000022H
	je	SHORT $LN38@DXUTParseC

; 537  :             strCmdLine++;

	mov	eax, DWORD PTR _strCmdLine$[ebp]
	add	eax, 1
	mov	DWORD PTR _strCmdLine$[ebp], eax
	jmp	SHORT $LN39@DXUTParseC
$LN38@DXUTParseC:

; 538  : 
; 539  :         // Skip over double-quote
; 540  :         if (*strCmdLine == L'"')            

	mov	eax, DWORD PTR _strCmdLine$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 34					; 00000022H
	jne	SHORT $LN37@DXUTParseC

; 541  :             strCmdLine++;    

	mov	eax, DWORD PTR _strCmdLine$[ebp]
	add	eax, 1
	mov	DWORD PTR _strCmdLine$[ebp], eax
$LN37@DXUTParseC:

; 542  :     }
; 543  :     else   

	jmp	SHORT $LN34@DXUTParseC
$LN40@DXUTParseC:

; 544  :     {
; 545  :         // First token wasn't a quote
; 546  :         while (*strCmdLine > L' ')

	mov	eax, DWORD PTR _strCmdLine$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jle	SHORT $LN34@DXUTParseC

; 547  :             strCmdLine++;

	mov	eax, DWORD PTR _strCmdLine$[ebp]
	add	eax, 1
	mov	DWORD PTR _strCmdLine$[ebp], eax
	jmp	SHORT $LN40@DXUTParseC
$LN34@DXUTParseC:

; 548  :     }
; 549  : 
; 550  :     for(;;)
; 551  :     {
; 552  :         // Skip past any white space preceding the next token
; 553  :         while (*strCmdLine && (*strCmdLine <= L' '))

	mov	eax, DWORD PTR _strCmdLine$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN30@DXUTParseC
	mov	eax, DWORD PTR _strCmdLine$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jg	SHORT $LN30@DXUTParseC

; 554  :             strCmdLine++;

	mov	eax, DWORD PTR _strCmdLine$[ebp]
	add	eax, 1
	mov	DWORD PTR _strCmdLine$[ebp], eax
	jmp	SHORT $LN34@DXUTParseC
$LN30@DXUTParseC:

; 555  :         if( *strCmdLine == 0 )

	mov	eax, DWORD PTR _strCmdLine$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN29@DXUTParseC

; 556  :             break;

	jmp	$LN32@DXUTParseC
$LN29@DXUTParseC:

; 557  : 
; 558  :         TCHAR strFlag[256];
; 559  :         int nFlagLen = 0;

	mov	DWORD PTR _nFlagLen$9[ebp], 0

; 560  : 
; 561  :         // Skip past the flag marker
; 562  :         if( *strCmdLine == L'/' ||
; 563  :             *strCmdLine == L'-' )

	mov	eax, DWORD PTR _strCmdLine$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	je	SHORT $LN27@DXUTParseC
	mov	eax, DWORD PTR _strCmdLine$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN28@DXUTParseC
$LN27@DXUTParseC:

; 564  :             strCmdLine++;

	mov	eax, DWORD PTR _strCmdLine$[ebp]
	add	eax, 1
	mov	DWORD PTR _strCmdLine$[ebp], eax
$LN28@DXUTParseC:

; 565  : 
; 566  :         // Compare the first N letters w/o regard to case
; 567  :         StringCchCopy( strFlag, 256, "adapter" ); nFlagLen = (int) strlen(strFlag);

	push	OFFSET ??_C@_07HEFHPBAB@adapter?$AA@
	push	256					; 00000100H
	lea	eax, DWORD PTR _strFlag$10[ebp]
	push	eax
	call	?StringCchCopyA@@YGJPADIPBD@Z		; StringCchCopyA
	lea	eax, DWORD PTR _strFlag$10[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _nFlagLen$9[ebp], eax

; 568  :         if( _strnicmp( strCmdLine, strFlag, nFlagLen ) == 0 )

	mov	eax, DWORD PTR _nFlagLen$9[ebp]
	push	eax
	lea	ecx, DWORD PTR _strFlag$10[ebp]
	push	ecx
	mov	edx, DWORD PTR _strCmdLine$[ebp]
	push	edx
	call	__strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN26@DXUTParseC

; 569  :         {
; 570  :             if( DXUTGetCmdParam( strCmdLine, strFlag, nFlagLen ) )

	mov	eax, DWORD PTR _nFlagLen$9[ebp]
	push	eax
	lea	ecx, DWORD PTR _strFlag$10[ebp]
	push	ecx
	lea	edx, DWORD PTR _strCmdLine$[ebp]
	push	edx
	call	?DXUTGetCmdParam@@YA_NAAPADPADH@Z	; DXUTGetCmdParam
	add	esp, 12					; 0000000cH
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN25@DXUTParseC

; 571  :             {
; 572  :                 int nAdapter = atoi(strFlag);

	lea	eax, DWORD PTR _strFlag$10[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	DWORD PTR _nAdapter$8[ebp], eax

; 573  :                 GetDXUTState().SetOverrideAdapterOrdinal( nAdapter );

	mov	eax, DWORD PTR _nAdapter$8[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetOverrideAdapterOrdinal@DXUTState@@QAEXH@Z ; DXUTState::SetOverrideAdapterOrdinal
$LN25@DXUTParseC:

; 574  :             }
; 575  :             continue;

	jmp	$LN34@DXUTParseC
$LN26@DXUTParseC:

; 576  :         }
; 577  : 
; 578  :         StringCchCopy( strFlag, 256, "windowed" ); nFlagLen = (int) strlen(strFlag);

	push	OFFSET ??_C@_08KIHLFLPI@windowed?$AA@
	push	256					; 00000100H
	lea	eax, DWORD PTR _strFlag$10[ebp]
	push	eax
	call	?StringCchCopyA@@YGJPADIPBD@Z		; StringCchCopyA
	lea	eax, DWORD PTR _strFlag$10[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _nFlagLen$9[ebp], eax

; 579  :         if( _strnicmp( strCmdLine, strFlag, nFlagLen ) == 0 )

	mov	eax, DWORD PTR _nFlagLen$9[ebp]
	push	eax
	lea	ecx, DWORD PTR _strFlag$10[ebp]
	push	ecx
	mov	edx, DWORD PTR _strCmdLine$[ebp]
	push	edx
	call	__strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN24@DXUTParseC

; 580  :         {
; 581  :             GetDXUTState().SetOverrideWindowed( true );

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetOverrideWindowed@DXUTState@@QAEX_N@Z ; DXUTState::SetOverrideWindowed

; 582  :             strCmdLine += nFlagLen;

	mov	eax, DWORD PTR _strCmdLine$[ebp]
	add	eax, DWORD PTR _nFlagLen$9[ebp]
	mov	DWORD PTR _strCmdLine$[ebp], eax

; 583  :             continue;

	jmp	$LN34@DXUTParseC
$LN24@DXUTParseC:

; 584  :         }
; 585  : 
; 586  :         StringCchCopy( strFlag, 256, "fullscreen" ); nFlagLen = (int) strlen(strFlag);

	push	OFFSET ??_C@_0L@GIACNHMO@fullscreen?$AA@
	push	256					; 00000100H
	lea	eax, DWORD PTR _strFlag$10[ebp]
	push	eax
	call	?StringCchCopyA@@YGJPADIPBD@Z		; StringCchCopyA
	lea	eax, DWORD PTR _strFlag$10[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _nFlagLen$9[ebp], eax

; 587  :         if( _strnicmp( strCmdLine, strFlag, nFlagLen ) == 0 )

	mov	eax, DWORD PTR _nFlagLen$9[ebp]
	push	eax
	lea	ecx, DWORD PTR _strFlag$10[ebp]
	push	ecx
	mov	edx, DWORD PTR _strCmdLine$[ebp]
	push	edx
	call	__strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN23@DXUTParseC

; 588  :         {
; 589  :             GetDXUTState().SetOverrideFullScreen( true );

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetOverrideFullScreen@DXUTState@@QAEX_N@Z ; DXUTState::SetOverrideFullScreen

; 590  :             strCmdLine += nFlagLen;

	mov	eax, DWORD PTR _strCmdLine$[ebp]
	add	eax, DWORD PTR _nFlagLen$9[ebp]
	mov	DWORD PTR _strCmdLine$[ebp], eax

; 591  :             continue;

	jmp	$LN34@DXUTParseC
$LN23@DXUTParseC:

; 592  :         }
; 593  : 
; 594  :         StringCchCopy( strFlag, 256, "forcehal" ); nFlagLen = (int) strlen(strFlag);

	push	OFFSET ??_C@_08OFMOLPPD@forcehal?$AA@
	push	256					; 00000100H
	lea	eax, DWORD PTR _strFlag$10[ebp]
	push	eax
	call	?StringCchCopyA@@YGJPADIPBD@Z		; StringCchCopyA
	lea	eax, DWORD PTR _strFlag$10[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _nFlagLen$9[ebp], eax

; 595  :         if( _strnicmp( strCmdLine, strFlag, nFlagLen ) == 0 )

	mov	eax, DWORD PTR _nFlagLen$9[ebp]
	push	eax
	lea	ecx, DWORD PTR _strFlag$10[ebp]
	push	ecx
	mov	edx, DWORD PTR _strCmdLine$[ebp]
	push	edx
	call	__strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN22@DXUTParseC

; 596  :         {
; 597  :             GetDXUTState().SetOverrideForceHAL( true );

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetOverrideForceHAL@DXUTState@@QAEX_N@Z ; DXUTState::SetOverrideForceHAL

; 598  :             strCmdLine += nFlagLen;

	mov	eax, DWORD PTR _strCmdLine$[ebp]
	add	eax, DWORD PTR _nFlagLen$9[ebp]
	mov	DWORD PTR _strCmdLine$[ebp], eax

; 599  :             continue;

	jmp	$LN34@DXUTParseC
$LN22@DXUTParseC:

; 600  :         }
; 601  : 
; 602  :         StringCchCopy( strFlag, 256, "forceref" ); nFlagLen = (int) strlen(strFlag);

	push	OFFSET ??_C@_08CHIMEIFO@forceref?$AA@
	push	256					; 00000100H
	lea	eax, DWORD PTR _strFlag$10[ebp]
	push	eax
	call	?StringCchCopyA@@YGJPADIPBD@Z		; StringCchCopyA
	lea	eax, DWORD PTR _strFlag$10[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _nFlagLen$9[ebp], eax

; 603  :         if( _strnicmp( strCmdLine, strFlag, nFlagLen ) == 0 )

	mov	eax, DWORD PTR _nFlagLen$9[ebp]
	push	eax
	lea	ecx, DWORD PTR _strFlag$10[ebp]
	push	ecx
	mov	edx, DWORD PTR _strCmdLine$[ebp]
	push	edx
	call	__strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN21@DXUTParseC

; 604  :         {
; 605  :             GetDXUTState().SetOverrideForceREF( true );

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetOverrideForceREF@DXUTState@@QAEX_N@Z ; DXUTState::SetOverrideForceREF

; 606  :             strCmdLine += nFlagLen;

	mov	eax, DWORD PTR _strCmdLine$[ebp]
	add	eax, DWORD PTR _nFlagLen$9[ebp]
	mov	DWORD PTR _strCmdLine$[ebp], eax

; 607  :             continue;

	jmp	$LN34@DXUTParseC
$LN21@DXUTParseC:

; 608  :         }
; 609  : 
; 610  :         StringCchCopy( strFlag, 256, "forcepurehwvp" ); nFlagLen = (int) strlen(strFlag);

	push	OFFSET ??_C@_0O@FCGFKHNN@forcepurehwvp?$AA@
	push	256					; 00000100H
	lea	eax, DWORD PTR _strFlag$10[ebp]
	push	eax
	call	?StringCchCopyA@@YGJPADIPBD@Z		; StringCchCopyA
	lea	eax, DWORD PTR _strFlag$10[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _nFlagLen$9[ebp], eax

; 611  :         if( _strnicmp( strCmdLine, strFlag, nFlagLen ) == 0 )

	mov	eax, DWORD PTR _nFlagLen$9[ebp]
	push	eax
	lea	ecx, DWORD PTR _strFlag$10[ebp]
	push	ecx
	mov	edx, DWORD PTR _strCmdLine$[ebp]
	push	edx
	call	__strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN20@DXUTParseC

; 612  :         {
; 613  :             GetDXUTState().SetOverrideForcePureHWVP( true );

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetOverrideForcePureHWVP@DXUTState@@QAEX_N@Z ; DXUTState::SetOverrideForcePureHWVP

; 614  :             strCmdLine += nFlagLen;

	mov	eax, DWORD PTR _strCmdLine$[ebp]
	add	eax, DWORD PTR _nFlagLen$9[ebp]
	mov	DWORD PTR _strCmdLine$[ebp], eax

; 615  :             continue;

	jmp	$LN34@DXUTParseC
$LN20@DXUTParseC:

; 616  :         }
; 617  : 
; 618  :         StringCchCopy( strFlag, 256, "forcehwvp" ); nFlagLen = (int) strlen(strFlag);

	push	OFFSET ??_C@_09GPKNDKAK@forcehwvp?$AA@
	push	256					; 00000100H
	lea	eax, DWORD PTR _strFlag$10[ebp]
	push	eax
	call	?StringCchCopyA@@YGJPADIPBD@Z		; StringCchCopyA
	lea	eax, DWORD PTR _strFlag$10[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _nFlagLen$9[ebp], eax

; 619  :         if( _strnicmp( strCmdLine, strFlag, nFlagLen ) == 0 )

	mov	eax, DWORD PTR _nFlagLen$9[ebp]
	push	eax
	lea	ecx, DWORD PTR _strFlag$10[ebp]
	push	ecx
	mov	edx, DWORD PTR _strCmdLine$[ebp]
	push	edx
	call	__strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN19@DXUTParseC

; 620  :         {
; 621  :             GetDXUTState().SetOverrideForceHWVP( true );

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetOverrideForceHWVP@DXUTState@@QAEX_N@Z ; DXUTState::SetOverrideForceHWVP

; 622  :             strCmdLine += nFlagLen;

	mov	eax, DWORD PTR _strCmdLine$[ebp]
	add	eax, DWORD PTR _nFlagLen$9[ebp]
	mov	DWORD PTR _strCmdLine$[ebp], eax

; 623  :             continue;

	jmp	$LN34@DXUTParseC
$LN19@DXUTParseC:

; 624  :         }
; 625  : 
; 626  :         StringCchCopy( strFlag, 256, "forceswvp" ); nFlagLen = (int) strlen(strFlag);

	push	OFFSET ??_C@_09HIJNJMJJ@forceswvp?$AA@
	push	256					; 00000100H
	lea	eax, DWORD PTR _strFlag$10[ebp]
	push	eax
	call	?StringCchCopyA@@YGJPADIPBD@Z		; StringCchCopyA
	lea	eax, DWORD PTR _strFlag$10[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _nFlagLen$9[ebp], eax

; 627  :         if( _strnicmp( strCmdLine, strFlag, nFlagLen ) == 0 )

	mov	eax, DWORD PTR _nFlagLen$9[ebp]
	push	eax
	lea	ecx, DWORD PTR _strFlag$10[ebp]
	push	ecx
	mov	edx, DWORD PTR _strCmdLine$[ebp]
	push	edx
	call	__strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN18@DXUTParseC

; 628  :         {
; 629  :             GetDXUTState().SetOverrideForceSWVP( true );

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetOverrideForceSWVP@DXUTState@@QAEX_N@Z ; DXUTState::SetOverrideForceSWVP

; 630  :             strCmdLine += nFlagLen;

	mov	eax, DWORD PTR _strCmdLine$[ebp]
	add	eax, DWORD PTR _nFlagLen$9[ebp]
	mov	DWORD PTR _strCmdLine$[ebp], eax

; 631  :             continue;

	jmp	$LN34@DXUTParseC
$LN18@DXUTParseC:

; 632  :         }
; 633  : 
; 634  :         StringCchCopy( strFlag, 256, "width" ); nFlagLen = (int) strlen(strFlag);

	push	OFFSET ??_C@_05IGKADHGO@width?$AA@
	push	256					; 00000100H
	lea	eax, DWORD PTR _strFlag$10[ebp]
	push	eax
	call	?StringCchCopyA@@YGJPADIPBD@Z		; StringCchCopyA
	lea	eax, DWORD PTR _strFlag$10[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _nFlagLen$9[ebp], eax

; 635  :         if( _strnicmp( strCmdLine, strFlag, nFlagLen ) == 0 )

	mov	eax, DWORD PTR _nFlagLen$9[ebp]
	push	eax
	lea	ecx, DWORD PTR _strFlag$10[ebp]
	push	ecx
	mov	edx, DWORD PTR _strCmdLine$[ebp]
	push	edx
	call	__strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN17@DXUTParseC

; 636  :         {
; 637  :             if( DXUTGetCmdParam( strCmdLine, strFlag, nFlagLen ) )

	mov	eax, DWORD PTR _nFlagLen$9[ebp]
	push	eax
	lea	ecx, DWORD PTR _strFlag$10[ebp]
	push	ecx
	lea	edx, DWORD PTR _strCmdLine$[ebp]
	push	edx
	call	?DXUTGetCmdParam@@YA_NAAPADPADH@Z	; DXUTGetCmdParam
	add	esp, 12					; 0000000cH
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN16@DXUTParseC

; 638  :             {
; 639  :                 int nWidth = atoi(strFlag);

	lea	eax, DWORD PTR _strFlag$10[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	DWORD PTR _nWidth$7[ebp], eax

; 640  :                 GetDXUTState().SetOverrideWidth( nWidth );

	mov	eax, DWORD PTR _nWidth$7[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetOverrideWidth@DXUTState@@QAEXH@Z	; DXUTState::SetOverrideWidth
$LN16@DXUTParseC:

; 641  :             }
; 642  :             continue;

	jmp	$LN34@DXUTParseC
$LN17@DXUTParseC:

; 643  :         }
; 644  : 
; 645  :         StringCchCopy( strFlag, 256, "height" ); nFlagLen = (int) strlen(strFlag);

	push	OFFSET ??_C@_06LNLHEAAG@height?$AA@
	push	256					; 00000100H
	lea	eax, DWORD PTR _strFlag$10[ebp]
	push	eax
	call	?StringCchCopyA@@YGJPADIPBD@Z		; StringCchCopyA
	lea	eax, DWORD PTR _strFlag$10[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _nFlagLen$9[ebp], eax

; 646  :         if( _strnicmp( strCmdLine, strFlag, nFlagLen ) == 0 )

	mov	eax, DWORD PTR _nFlagLen$9[ebp]
	push	eax
	lea	ecx, DWORD PTR _strFlag$10[ebp]
	push	ecx
	mov	edx, DWORD PTR _strCmdLine$[ebp]
	push	edx
	call	__strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN15@DXUTParseC

; 647  :         {
; 648  :             if( DXUTGetCmdParam( strCmdLine, strFlag, nFlagLen ) )

	mov	eax, DWORD PTR _nFlagLen$9[ebp]
	push	eax
	lea	ecx, DWORD PTR _strFlag$10[ebp]
	push	ecx
	lea	edx, DWORD PTR _strCmdLine$[ebp]
	push	edx
	call	?DXUTGetCmdParam@@YA_NAAPADPADH@Z	; DXUTGetCmdParam
	add	esp, 12					; 0000000cH
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN14@DXUTParseC

; 649  :             {
; 650  :                 int nHeight = atoi(strFlag);

	lea	eax, DWORD PTR _strFlag$10[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	DWORD PTR _nHeight$6[ebp], eax

; 651  :                 GetDXUTState().SetOverrideHeight( nHeight );

	mov	eax, DWORD PTR _nHeight$6[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetOverrideHeight@DXUTState@@QAEXH@Z	; DXUTState::SetOverrideHeight
$LN14@DXUTParseC:

; 652  :             }
; 653  :             continue;

	jmp	$LN34@DXUTParseC
$LN15@DXUTParseC:

; 654  :         }
; 655  : 
; 656  :         StringCchCopy( strFlag, 256, "startx" );

	push	OFFSET ??_C@_06PONKKAHI@startx?$AA@
	push	256					; 00000100H
	lea	eax, DWORD PTR _strFlag$10[ebp]
	push	eax
	call	?StringCchCopyA@@YGJPADIPBD@Z		; StringCchCopyA

; 657  :         nFlagLen = (int) strlen(strFlag);

	lea	eax, DWORD PTR _strFlag$10[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _nFlagLen$9[ebp], eax

; 658  :         if( _strnicmp( strCmdLine, strFlag, nFlagLen ) == 0 )

	mov	eax, DWORD PTR _nFlagLen$9[ebp]
	push	eax
	lea	ecx, DWORD PTR _strFlag$10[ebp]
	push	ecx
	mov	edx, DWORD PTR _strCmdLine$[ebp]
	push	edx
	call	__strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN13@DXUTParseC

; 659  :         {
; 660  :             if( DXUTGetCmdParam( strCmdLine, strFlag, nFlagLen ) )

	mov	eax, DWORD PTR _nFlagLen$9[ebp]
	push	eax
	lea	ecx, DWORD PTR _strFlag$10[ebp]
	push	ecx
	lea	edx, DWORD PTR _strCmdLine$[ebp]
	push	edx
	call	?DXUTGetCmdParam@@YA_NAAPADPADH@Z	; DXUTGetCmdParam
	add	esp, 12					; 0000000cH
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN12@DXUTParseC

; 661  :             {
; 662  :                 int nX = atoi(strFlag);

	lea	eax, DWORD PTR _strFlag$10[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	DWORD PTR _nX$5[ebp], eax

; 663  :                 GetDXUTState().SetOverrideStartX( nX );

	mov	eax, DWORD PTR _nX$5[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetOverrideStartX@DXUTState@@QAEXH@Z	; DXUTState::SetOverrideStartX
$LN12@DXUTParseC:

; 664  :             }
; 665  :             continue;

	jmp	$LN34@DXUTParseC
$LN13@DXUTParseC:

; 666  :         }
; 667  : 
; 668  :         StringCchCopy( strFlag, 256, "starty" );

	push	OFFSET ??_C@_06OHMBJBDJ@starty?$AA@
	push	256					; 00000100H
	lea	eax, DWORD PTR _strFlag$10[ebp]
	push	eax
	call	?StringCchCopyA@@YGJPADIPBD@Z		; StringCchCopyA

; 669  :         nFlagLen = (int) strlen(strFlag);

	lea	eax, DWORD PTR _strFlag$10[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _nFlagLen$9[ebp], eax

; 670  :         if( _strnicmp( strCmdLine, strFlag, nFlagLen ) == 0 )

	mov	eax, DWORD PTR _nFlagLen$9[ebp]
	push	eax
	lea	ecx, DWORD PTR _strFlag$10[ebp]
	push	ecx
	mov	edx, DWORD PTR _strCmdLine$[ebp]
	push	edx
	call	__strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN11@DXUTParseC

; 671  :         {
; 672  :             if( DXUTGetCmdParam( strCmdLine, strFlag, nFlagLen ) )

	mov	eax, DWORD PTR _nFlagLen$9[ebp]
	push	eax
	lea	ecx, DWORD PTR _strFlag$10[ebp]
	push	ecx
	lea	edx, DWORD PTR _strCmdLine$[ebp]
	push	edx
	call	?DXUTGetCmdParam@@YA_NAAPADPADH@Z	; DXUTGetCmdParam
	add	esp, 12					; 0000000cH
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@DXUTParseC

; 673  :             {
; 674  :                 int nY = atoi(strFlag);

	lea	eax, DWORD PTR _strFlag$10[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	DWORD PTR _nY$4[ebp], eax

; 675  :                 GetDXUTState().SetOverrideStartY( nY );

	mov	eax, DWORD PTR _nY$4[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetOverrideStartY@DXUTState@@QAEXH@Z	; DXUTState::SetOverrideStartY
$LN10@DXUTParseC:

; 676  :             }
; 677  :             continue;

	jmp	$LN34@DXUTParseC
$LN11@DXUTParseC:

; 678  :         }
; 679  : 
; 680  :         StringCchCopy( strFlag, 256, "constantframetime" ); nFlagLen = (int) strlen(strFlag);

	push	OFFSET ??_C@_0BC@DPFOJONK@constantframetime?$AA@
	push	256					; 00000100H
	lea	eax, DWORD PTR _strFlag$10[ebp]
	push	eax
	call	?StringCchCopyA@@YGJPADIPBD@Z		; StringCchCopyA
	lea	eax, DWORD PTR _strFlag$10[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _nFlagLen$9[ebp], eax

; 681  :         if( _strnicmp( strCmdLine, strFlag, nFlagLen ) == 0 )

	mov	eax, DWORD PTR _nFlagLen$9[ebp]
	push	eax
	lea	ecx, DWORD PTR _strFlag$10[ebp]
	push	ecx
	mov	edx, DWORD PTR _strCmdLine$[ebp]
	push	edx
	call	__strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN9@DXUTParseC

; 682  :         {
; 683  :             float fTimePerFrame;
; 684  :             if( DXUTGetCmdParam( strCmdLine, strFlag, nFlagLen ) )

	mov	eax, DWORD PTR _nFlagLen$9[ebp]
	push	eax
	lea	ecx, DWORD PTR _strFlag$10[ebp]
	push	ecx
	lea	edx, DWORD PTR _strCmdLine$[ebp]
	push	edx
	call	?DXUTGetCmdParam@@YA_NAAPADPADH@Z	; DXUTGetCmdParam
	add	esp, 12					; 0000000cH
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@DXUTParseC

; 685  :                 fTimePerFrame = (float)strtod( strFlag, NULL );

	push	0
	lea	eax, DWORD PTR _strFlag$10[ebp]
	push	eax
	call	_strtod
	add	esp, 8
	fstp	DWORD PTR _fTimePerFrame$3[ebp]

; 686  :             else

	jmp	SHORT $LN7@DXUTParseC
$LN8@DXUTParseC:

; 687  :                 fTimePerFrame = 0.0333f;

	movss	xmm0, DWORD PTR __real@3d086595
	movss	DWORD PTR _fTimePerFrame$3[ebp], xmm0
$LN7@DXUTParseC:

; 688  :             GetDXUTState().SetOverrideConstantFrameTime( true );

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetOverrideConstantFrameTime@DXUTState@@QAEX_N@Z ; DXUTState::SetOverrideConstantFrameTime

; 689  :             GetDXUTState().SetOverrideConstantTimePerFrame( fTimePerFrame );

	push	ecx
	movss	xmm0, DWORD PTR _fTimePerFrame$3[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetOverrideConstantTimePerFrame@DXUTState@@QAEXM@Z ; DXUTState::SetOverrideConstantTimePerFrame

; 690  :             DXUTSetConstantFrameTime( true, fTimePerFrame );

	push	ecx
	movss	xmm0, DWORD PTR _fTimePerFrame$3[ebp]
	movss	DWORD PTR [esp], xmm0
	push	1
	call	?DXUTSetConstantFrameTime@@YAX_NM@Z	; DXUTSetConstantFrameTime
	add	esp, 8

; 691  :             continue;

	jmp	$LN34@DXUTParseC
$LN9@DXUTParseC:

; 692  :         }
; 693  : 
; 694  :         StringCchCopy( strFlag, 256, "quitafterframe" ); nFlagLen = (int) strlen(strFlag);

	push	OFFSET ??_C@_0P@NCNNICJN@quitafterframe?$AA@
	push	256					; 00000100H
	lea	eax, DWORD PTR _strFlag$10[ebp]
	push	eax
	call	?StringCchCopyA@@YGJPADIPBD@Z		; StringCchCopyA
	lea	eax, DWORD PTR _strFlag$10[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _nFlagLen$9[ebp], eax

; 695  :         if( _strnicmp( strCmdLine, strFlag, nFlagLen ) == 0 )

	mov	eax, DWORD PTR _nFlagLen$9[ebp]
	push	eax
	lea	ecx, DWORD PTR _strFlag$10[ebp]
	push	ecx
	mov	edx, DWORD PTR _strCmdLine$[ebp]
	push	edx
	call	__strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@DXUTParseC

; 696  :         {
; 697  :             if( DXUTGetCmdParam( strCmdLine, strFlag, nFlagLen ) )

	mov	eax, DWORD PTR _nFlagLen$9[ebp]
	push	eax
	lea	ecx, DWORD PTR _strFlag$10[ebp]
	push	ecx
	lea	edx, DWORD PTR _strCmdLine$[ebp]
	push	edx
	call	?DXUTGetCmdParam@@YA_NAAPADPADH@Z	; DXUTGetCmdParam
	add	esp, 12					; 0000000cH
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@DXUTParseC

; 698  :             {
; 699  :                 int nFrame = atoi(strFlag);

	lea	eax, DWORD PTR _strFlag$10[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	DWORD PTR _nFrame$2[ebp], eax

; 700  :                 GetDXUTState().SetOverrideQuitAfterFrame( nFrame );

	mov	eax, DWORD PTR _nFrame$2[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetOverrideQuitAfterFrame@DXUTState@@QAEXH@Z ; DXUTState::SetOverrideQuitAfterFrame
$LN5@DXUTParseC:

; 701  :             }
; 702  :             continue;

	jmp	$LN34@DXUTParseC
$LN6@DXUTParseC:

; 703  :         }      
; 704  :         
; 705  :         StringCchCopy( strFlag, 256, "noerrormsgboxes" ); nFlagLen = (int) strlen(strFlag);

	push	OFFSET ??_C@_0BA@EMDPCOOI@noerrormsgboxes?$AA@
	push	256					; 00000100H
	lea	eax, DWORD PTR _strFlag$10[ebp]
	push	eax
	call	?StringCchCopyA@@YGJPADIPBD@Z		; StringCchCopyA
	lea	eax, DWORD PTR _strFlag$10[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _nFlagLen$9[ebp], eax

; 706  :         if( _strnicmp( strCmdLine, strFlag, nFlagLen ) == 0 )

	mov	eax, DWORD PTR _nFlagLen$9[ebp]
	push	eax
	lea	ecx, DWORD PTR _strFlag$10[ebp]
	push	ecx
	mov	edx, DWORD PTR _strCmdLine$[ebp]
	push	edx
	call	__strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN4@DXUTParseC

; 707  :         {
; 708  :             GetDXUTState().SetShowMsgBoxOnError( false );

	push	0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetShowMsgBoxOnError@DXUTState@@QAEX_N@Z ; DXUTState::SetShowMsgBoxOnError

; 709  :             strCmdLine += nFlagLen;

	mov	eax, DWORD PTR _strCmdLine$[ebp]
	add	eax, DWORD PTR _nFlagLen$9[ebp]
	mov	DWORD PTR _strCmdLine$[ebp], eax

; 710  :             continue;

	jmp	$LN34@DXUTParseC
$LN4@DXUTParseC:

; 711  :         }        
; 712  : 
; 713  :         StringCchCopy( strFlag, 256, "automation" ); nFlagLen = (int) strlen(strFlag);

	push	OFFSET ??_C@_0L@GKIGKMJB@automation?$AA@
	push	256					; 00000100H
	lea	eax, DWORD PTR _strFlag$10[ebp]
	push	eax
	call	?StringCchCopyA@@YGJPADIPBD@Z		; StringCchCopyA
	lea	eax, DWORD PTR _strFlag$10[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _nFlagLen$9[ebp], eax

; 714  :         if( _strnicmp( strCmdLine, strFlag, nFlagLen ) == 0 )

	mov	eax, DWORD PTR _nFlagLen$9[ebp]
	push	eax
	lea	ecx, DWORD PTR _strFlag$10[ebp]
	push	ecx
	mov	edx, DWORD PTR _strCmdLine$[ebp]
	push	edx
	call	__strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN3@DXUTParseC

; 715  :         {
; 716  :             GetDXUTState().SetAutomation( true );

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetAutomation@DXUTState@@QAEX_N@Z	; DXUTState::SetAutomation

; 717  :             strCmdLine += nFlagLen;

	mov	eax, DWORD PTR _strCmdLine$[ebp]
	add	eax, DWORD PTR _nFlagLen$9[ebp]
	mov	DWORD PTR _strCmdLine$[ebp], eax

; 718  :             continue;

	jmp	$LN34@DXUTParseC
$LN3@DXUTParseC:

; 719  :         }
; 720  : 
; 721  :         // Unrecognized flag
; 722  :         StringCchCopy( strFlag, 256, strCmdLine ); 

	mov	eax, DWORD PTR _strCmdLine$[ebp]
	push	eax
	push	256					; 00000100H
	lea	ecx, DWORD PTR _strFlag$10[ebp]
	push	ecx
	call	?StringCchCopyA@@YGJPADIPBD@Z		; StringCchCopyA

; 723  :         TCHAR* strSpace = strFlag;

	lea	eax, DWORD PTR _strFlag$10[ebp]
	mov	DWORD PTR _strSpace$1[ebp], eax
$LN2@DXUTParseC:

; 724  :         while (*strSpace && (*strSpace > L' '))

	mov	eax, DWORD PTR _strSpace$1[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN1@DXUTParseC
	mov	eax, DWORD PTR _strSpace$1[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jle	SHORT $LN1@DXUTParseC

; 725  :             strSpace++;

	mov	eax, DWORD PTR _strSpace$1[ebp]
	add	eax, 1
	mov	DWORD PTR _strSpace$1[ebp], eax
	jmp	SHORT $LN2@DXUTParseC
$LN1@DXUTParseC:

; 726  :         *strSpace = 0;

	mov	eax, DWORD PTR _strSpace$1[ebp]
	mov	BYTE PTR [eax], 0

; 727  : 
; 728  :         DXUTOutputDebugString( "Unrecognized flag: %s", strFlag );

	lea	eax, DWORD PTR _strFlag$10[ebp]
	push	eax
	push	OFFSET ??_C@_0BG@BAGONEII@Unrecognized?5flag?3?5?$CFs?$AA@
	call	?DXUTOutputDebugStringA@@YAXPBDZZ	; DXUTOutputDebugStringA
	add	esp, 8

; 729  :         strCmdLine += strlen(strFlag);

	lea	eax, DWORD PTR _strFlag$10[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, DWORD PTR _strCmdLine$[ebp]
	mov	DWORD PTR _strCmdLine$[ebp], eax

; 730  :     }

	jmp	$LN34@DXUTParseC
$LN32@DXUTParseC:

; 731  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN62@DXUTParseC
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 580				; 00000244H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN62@DXUTParseC:
	DD	2
	DD	$LN61@DXUTParseC
$LN61@DXUTParseC:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN59@DXUTParseC
	DD	-276					; fffffeecH
	DD	256					; 00000100H
	DD	$LN60@DXUTParseC
$LN60@DXUTParseC:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	70					; 00000046H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	103					; 00000067H
	DB	0
$LN59@DXUTParseC:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	67					; 00000043H
	DB	109					; 0000006dH
	DB	100					; 00000064H
	DB	76					; 0000004cH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	0
?DXUTParseCommandLine@@YAXXZ ENDP			; DXUTParseCommandLine
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTMapButtonToArrayIndex@@YAHE@Z
_TEXT	SEGMENT
tv65 = -196						; size = 4
_vButton$ = 8						; size = 1
?DXUTMapButtonToArrayIndex@@YAHE@Z PROC			; DXUTMapButtonToArrayIndex, COMDAT

; 4791 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4792 :     switch( vButton )

	mov	al, BYTE PTR _vButton$[ebp]
	mov	BYTE PTR tv65[ebp], al
	cmp	BYTE PTR tv65[ebp], 1
	je	SHORT $LN3@DXUTMapBut
	cmp	BYTE PTR tv65[ebp], 2
	je	SHORT $LN1@DXUTMapBut
	cmp	BYTE PTR tv65[ebp], 16			; 00000010H
	je	SHORT $LN2@DXUTMapBut
	jmp	SHORT $LN4@DXUTMapBut
$LN3@DXUTMapBut:

; 4793 :     {
; 4794 :         case MK_LBUTTON: return 0;

	xor	eax, eax
	jmp	SHORT $LN6@DXUTMapBut
$LN2@DXUTMapBut:

; 4795 :         case MK_MBUTTON: return 1;

	mov	eax, 1
	jmp	SHORT $LN6@DXUTMapBut
$LN1@DXUTMapBut:

; 4796 :         case MK_RBUTTON: return 2;

	mov	eax, 2
	jmp	SHORT $LN6@DXUTMapBut
$LN4@DXUTMapBut:

; 4797 :      }
; 4798 : 
; 4799 :     return 0;

	xor	eax, eax
$LN6@DXUTMapBut:

; 4800 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTMapButtonToArrayIndex@@YAHE@Z ENDP			; DXUTMapButtonToArrayIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__Fstate@?1??GetDXUTState@@YAAAVDXUTState@@XZ@YAXXZ
text$yd	SEGMENT
??__Fstate@?1??GetDXUTState@@YAAAVDXUTState@@XZ@YAXXZ PROC ; `GetDXUTState'::`2'::`dynamic atexit destructor for 'state'', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?state@?1??GetDXUTState@@YAAAVDXUTState@@XZ@4V2@A
	call	??1DXUTState@@QAE@XZ			; DXUTState::~DXUTState
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__Fstate@?1??GetDXUTState@@YAAAVDXUTState@@XZ@YAXXZ ENDP ; `GetDXUTState'::`2'::`dynamic atexit destructor for 'state''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetDXUTState@@YAAAVDXUTState@@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?GetDXUTState@@YAAAVDXUTState@@XZ PROC			; GetDXUTState, COMDAT

; 356  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetDXUTState@@YAAAVDXUTState@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 357  :     // Using an accessor function gives control of the construction order
; 358  :     static DXUTState state;

	mov	eax, DWORD PTR ?$S1@?1??GetDXUTState@@YAAAVDXUTState@@XZ@4IA
	and	eax, 1
	jne	SHORT $LN1@GetDXUTSta
	mov	eax, DWORD PTR ?$S1@?1??GetDXUTState@@YAAAVDXUTState@@XZ@4IA
	or	eax, 1
	mov	DWORD PTR ?$S1@?1??GetDXUTState@@YAAAVDXUTState@@XZ@4IA, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, OFFSET ?state@?1??GetDXUTState@@YAAAVDXUTState@@XZ@4V2@A
	call	??0DXUTState@@QAE@XZ			; DXUTState::DXUTState
	push	OFFSET ??__Fstate@?1??GetDXUTState@@YAAAVDXUTState@@XZ@YAXXZ ; `GetDXUTState'::`2'::`dynamic atexit destructor for 'state''
	call	_atexit
	add	esp, 4
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN1@GetDXUTSta:

; 359  :     return state;

	mov	eax, OFFSET ?state@?1??GetDXUTState@@YAAAVDXUTState@@XZ@4V2@A

; 360  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetDXUTState@@YAAAVDXUTState@@XZ$0:
	mov	eax, DWORD PTR ?$S1@?1??GetDXUTState@@YAAAVDXUTState@@XZ@4IA
	and	eax, -2					; fffffffeH
	mov	DWORD PTR ?$S1@?1??GetDXUTState@@YAAAVDXUTState@@XZ@4IA, eax
	ret	0
__ehhandler$?GetDXUTState@@YAAAVDXUTState@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetDXUTState@@YAAAVDXUTState@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetDXUTState@@YAAAVDXUTState@@XZ ENDP			; GetDXUTState
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetWindowTitle@DXUTState@@QAEPADXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetWindowTitle@DXUTState@@QAEPADXZ PROC		; DXUTState::GetWindowTitle, COMDAT
; _this$ = ecx

; 348  :     GET_ACCESSOR( TCHAR*, WindowTitle );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1725				; 000006bdH
	mov	DWORD PTR $T1[ebp], eax
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetWindowT
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@GetWindowT:
	DD	1
	DD	$LN5@GetWindowT
$LN5@GetWindowT:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetWindowT
$LN4@GetWindowT:
	DB	108					; 0000006cH
	DB	0
?GetWindowTitle@DXUTState@@QAEPADXZ ENDP		; DXUTState::GetWindowTitle
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetDeviceStats@DXUTState@@QAEPADXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetDeviceStats@DXUTState@@QAEPADXZ PROC		; DXUTState::GetDeviceStats, COMDAT
; _this$ = ecx

; 347  :     GET_ACCESSOR( TCHAR*, DeviceStats );    

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1469				; 000005bdH
	mov	DWORD PTR $T1[ebp], eax
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetDeviceS
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@GetDeviceS:
	DD	1
	DD	$LN5@GetDeviceS
$LN5@GetDeviceS:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetDeviceS
$LN4@GetDeviceS:
	DB	108					; 0000006cH
	DB	0
?GetDeviceStats@DXUTState@@QAEPADXZ ENDP		; DXUTState::GetDeviceStats
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetFrameStats@DXUTState@@QAEPADXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetFrameStats@DXUTState@@QAEPADXZ PROC			; DXUTState::GetFrameStats, COMDAT
; _this$ = ecx

; 346  :     GET_ACCESSOR( TCHAR*, FrameStats );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1213				; 000004bdH
	mov	DWORD PTR $T1[ebp], eax
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetFrameSt
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@GetFrameSt:
	DD	1
	DD	$LN5@GetFrameSt
$LN5@GetFrameSt:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetFrameSt
$LN4@GetFrameSt:
	DB	108					; 0000006cH
	DB	0
?GetFrameStats@DXUTState@@QAEPADXZ ENDP			; DXUTState::GetFrameStats
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetStaticFrameStats@DXUTState@@QAEPADXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetStaticFrameStats@DXUTState@@QAEPADXZ PROC		; DXUTState::GetStaticFrameStats, COMDAT
; _this$ = ecx

; 345  :     GET_ACCESSOR( TCHAR*, StaticFrameStats );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 957				; 000003bdH
	mov	DWORD PTR $T1[ebp], eax
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetStaticF
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@GetStaticF:
	DD	1
	DD	$LN5@GetStaticF
$LN5@GetStaticF:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetStaticF
$LN4@GetStaticF:
	DB	108					; 0000006cH
	DB	0
?GetStaticFrameStats@DXUTState@@QAEPADXZ ENDP		; DXUTState::GetStaticFrameStats
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetMouseButtons@DXUTState@@QAEPA_NXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetMouseButtons@DXUTState@@QAEPA_NXZ PROC		; DXUTState::GetMouseButtons, COMDAT
; _this$ = ecx

; 344  :     GET_ACCESSOR( bool*, MouseButtons );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 948				; 000003b4H
	mov	DWORD PTR $T1[ebp], eax
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetMouseBu
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@GetMouseBu:
	DD	1
	DD	$LN5@GetMouseBu
$LN5@GetMouseBu:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetMouseBu
$LN4@GetMouseBu:
	DB	108					; 0000006cH
	DB	0
?GetMouseButtons@DXUTState@@QAEPA_NXZ ENDP		; DXUTState::GetMouseButtons
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetKeys@DXUTState@@QAEPA_NXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetKeys@DXUTState@@QAEPA_NXZ PROC			; DXUTState::GetKeys, COMDAT
; _this$ = ecx

; 343  :     GET_ACCESSOR( bool*, Keys );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 692				; 000002b4H
	mov	DWORD PTR $T1[ebp], eax
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetKeys
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@GetKeys:
	DD	1
	DD	$LN5@GetKeys
$LN5@GetKeys:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetKeys
$LN4@GetKeys:
	DB	108					; 0000006cH
	DB	0
?GetKeys@DXUTState@@QAEPA_NXZ ENDP			; DXUTState::GetKeys
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetTimerList@DXUTState@@QAEPAV?$CGrowableArray@UDXUT_TIMER@@@@XZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetTimerList@DXUTState@@QAEPAV?$CGrowableArray@UDXUT_TIMER@@@@XZ PROC ; DXUTState::GetTimerList, COMDAT
; _this$ = ecx

; 342  :     GET_SET_ACCESSOR( CGrowableArray<DXUT_TIMER>*, TimerList );   

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+953]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetTimerLi
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetTimerLi:
	DD	1
	DD	$LN5@GetTimerLi
$LN5@GetTimerLi:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetTimerLi
$LN4@GetTimerLi:
	DB	108					; 0000006cH
	DB	0
?GetTimerList@DXUTState@@QAEPAV?$CGrowableArray@UDXUT_TIMER@@@@XZ ENDP ; DXUTState::GetTimerList
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetTimerList@DXUTState@@QAEXPAV?$CGrowableArray@UDXUT_TIMER@@@@@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetTimerList@DXUTState@@QAEXPAV?$CGrowableArray@UDXUT_TIMER@@@@@Z PROC ; DXUTState::SetTimerList, COMDAT
; _this$ = ecx

; 342  :     GET_SET_ACCESSOR( CGrowableArray<DXUT_TIMER>*, TimerList );   

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+953], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetTimerLi
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetTimerLi:
	DD	1
	DD	$LN5@SetTimerLi
$LN5@SetTimerLi:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetTimerLi
$LN4@SetTimerLi:
	DB	108					; 0000006cH
	DB	0
?SetTimerList@DXUTState@@QAEXPAV?$CGrowableArray@UDXUT_TIMER@@@@@Z ENDP ; DXUTState::SetTimerList
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetWindowMsgFuncUserContext@DXUTState@@QAEXPAX@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetWindowMsgFuncUserContext@DXUTState@@QAEXPAX@Z PROC	; DXUTState::SetWindowMsgFuncUserContext, COMDAT
; _this$ = ecx

; 340  :     GET_SET_ACCESSOR( void*, WindowMsgFuncUserContext );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+688], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetWindowM
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetWindowM:
	DD	1
	DD	$LN5@SetWindowM
$LN5@SetWindowM:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetWindowM
$LN4@SetWindowM:
	DB	108					; 0000006cH
	DB	0
?SetWindowMsgFuncUserContext@DXUTState@@QAEXPAX@Z ENDP	; DXUTState::SetWindowMsgFuncUserContext
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetMouseFuncUserContext@DXUTState@@QAEPAXXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetMouseFuncUserContext@DXUTState@@QAEPAXXZ PROC	; DXUTState::GetMouseFuncUserContext, COMDAT
; _this$ = ecx

; 339  :     GET_SET_ACCESSOR( void*, MouseFuncUserContext );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetMouseFu
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetMouseFu:
	DD	1
	DD	$LN5@GetMouseFu
$LN5@GetMouseFu:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetMouseFu
$LN4@GetMouseFu:
	DB	108					; 0000006cH
	DB	0
?GetMouseFuncUserContext@DXUTState@@QAEPAXXZ ENDP	; DXUTState::GetMouseFuncUserContext
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetMouseFuncUserContext@DXUTState@@QAEXPAX@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetMouseFuncUserContext@DXUTState@@QAEXPAX@Z PROC	; DXUTState::SetMouseFuncUserContext, COMDAT
; _this$ = ecx

; 339  :     GET_SET_ACCESSOR( void*, MouseFuncUserContext );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+684], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetMouseFu
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetMouseFu:
	DD	1
	DD	$LN5@SetMouseFu
$LN5@SetMouseFu:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetMouseFu
$LN4@SetMouseFu:
	DB	108					; 0000006cH
	DB	0
?SetMouseFuncUserContext@DXUTState@@QAEXPAX@Z ENDP	; DXUTState::SetMouseFuncUserContext
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetKeyboardFuncUserContext@DXUTState@@QAEPAXXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetKeyboardFuncUserContext@DXUTState@@QAEPAXXZ PROC	; DXUTState::GetKeyboardFuncUserContext, COMDAT
; _this$ = ecx

; 338  :     GET_SET_ACCESSOR( void*, KeyboardFuncUserContext );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+680]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetKeyboar
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetKeyboar:
	DD	1
	DD	$LN5@GetKeyboar
$LN5@GetKeyboar:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetKeyboar
$LN4@GetKeyboar:
	DB	108					; 0000006cH
	DB	0
?GetKeyboardFuncUserContext@DXUTState@@QAEPAXXZ ENDP	; DXUTState::GetKeyboardFuncUserContext
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetKeyboardFuncUserContext@DXUTState@@QAEXPAX@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetKeyboardFuncUserContext@DXUTState@@QAEXPAX@Z PROC	; DXUTState::SetKeyboardFuncUserContext, COMDAT
; _this$ = ecx

; 338  :     GET_SET_ACCESSOR( void*, KeyboardFuncUserContext );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+680], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetKeyboar
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetKeyboar:
	DD	1
	DD	$LN5@SetKeyboar
$LN5@SetKeyboar:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetKeyboar
$LN4@SetKeyboar:
	DB	108					; 0000006cH
	DB	0
?SetKeyboardFuncUserContext@DXUTState@@QAEXPAX@Z ENDP	; DXUTState::SetKeyboardFuncUserContext
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetFrameRenderFuncUserContext@DXUTState@@QAEPAXXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetFrameRenderFuncUserContext@DXUTState@@QAEPAXXZ PROC	; DXUTState::GetFrameRenderFuncUserContext, COMDAT
; _this$ = ecx

; 337  :     GET_SET_ACCESSOR( void*, FrameRenderFuncUserContext );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+676]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetFrameRe
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetFrameRe:
	DD	1
	DD	$LN5@GetFrameRe
$LN5@GetFrameRe:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetFrameRe
$LN4@GetFrameRe:
	DB	108					; 0000006cH
	DB	0
?GetFrameRenderFuncUserContext@DXUTState@@QAEPAXXZ ENDP	; DXUTState::GetFrameRenderFuncUserContext
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetFrameRenderFuncUserContext@DXUTState@@QAEXPAX@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetFrameRenderFuncUserContext@DXUTState@@QAEXPAX@Z PROC ; DXUTState::SetFrameRenderFuncUserContext, COMDAT
; _this$ = ecx

; 337  :     GET_SET_ACCESSOR( void*, FrameRenderFuncUserContext );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+676], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetFrameRe
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetFrameRe:
	DD	1
	DD	$LN5@SetFrameRe
$LN5@SetFrameRe:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetFrameRe
$LN4@SetFrameRe:
	DB	108					; 0000006cH
	DB	0
?SetFrameRenderFuncUserContext@DXUTState@@QAEXPAX@Z ENDP ; DXUTState::SetFrameRenderFuncUserContext
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetFrameMoveFuncUserContext@DXUTState@@QAEPAXXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetFrameMoveFuncUserContext@DXUTState@@QAEPAXXZ PROC	; DXUTState::GetFrameMoveFuncUserContext, COMDAT
; _this$ = ecx

; 336  :     GET_SET_ACCESSOR( void*, FrameMoveFuncUserContext );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetFrameMo
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetFrameMo:
	DD	1
	DD	$LN5@GetFrameMo
$LN5@GetFrameMo:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetFrameMo
$LN4@GetFrameMo:
	DB	108					; 0000006cH
	DB	0
?GetFrameMoveFuncUserContext@DXUTState@@QAEPAXXZ ENDP	; DXUTState::GetFrameMoveFuncUserContext
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetFrameMoveFuncUserContext@DXUTState@@QAEXPAX@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetFrameMoveFuncUserContext@DXUTState@@QAEXPAX@Z PROC	; DXUTState::SetFrameMoveFuncUserContext, COMDAT
; _this$ = ecx

; 336  :     GET_SET_ACCESSOR( void*, FrameMoveFuncUserContext );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+672], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetFrameMo
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetFrameMo:
	DD	1
	DD	$LN5@SetFrameMo
$LN5@SetFrameMo:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetFrameMo
$LN4@SetFrameMo:
	DB	108					; 0000006cH
	DB	0
?SetFrameMoveFuncUserContext@DXUTState@@QAEXPAX@Z ENDP	; DXUTState::SetFrameMoveFuncUserContext
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetDeviceDestroyedFuncUserContext@DXUTState@@QAEPAXXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetDeviceDestroyedFuncUserContext@DXUTState@@QAEPAXXZ PROC ; DXUTState::GetDeviceDestroyedFuncUserContext, COMDAT
; _this$ = ecx

; 335  :     GET_SET_ACCESSOR( void*, DeviceDestroyedFuncUserContext );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+668]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetDeviceD
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetDeviceD:
	DD	1
	DD	$LN5@GetDeviceD
$LN5@GetDeviceD:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetDeviceD
$LN4@GetDeviceD:
	DB	108					; 0000006cH
	DB	0
?GetDeviceDestroyedFuncUserContext@DXUTState@@QAEPAXXZ ENDP ; DXUTState::GetDeviceDestroyedFuncUserContext
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetDeviceDestroyedFuncUserContext@DXUTState@@QAEXPAX@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetDeviceDestroyedFuncUserContext@DXUTState@@QAEXPAX@Z PROC ; DXUTState::SetDeviceDestroyedFuncUserContext, COMDAT
; _this$ = ecx

; 335  :     GET_SET_ACCESSOR( void*, DeviceDestroyedFuncUserContext );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+668], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetDeviceD
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetDeviceD:
	DD	1
	DD	$LN5@SetDeviceD
$LN5@SetDeviceD:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetDeviceD
$LN4@SetDeviceD:
	DB	108					; 0000006cH
	DB	0
?SetDeviceDestroyedFuncUserContext@DXUTState@@QAEXPAX@Z ENDP ; DXUTState::SetDeviceDestroyedFuncUserContext
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetDeviceLostFuncUserContext@DXUTState@@QAEPAXXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetDeviceLostFuncUserContext@DXUTState@@QAEPAXXZ PROC	; DXUTState::GetDeviceLostFuncUserContext, COMDAT
; _this$ = ecx

; 334  :     GET_SET_ACCESSOR( void*, DeviceLostFuncUserContext );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+664]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetDeviceL
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetDeviceL:
	DD	1
	DD	$LN5@GetDeviceL
$LN5@GetDeviceL:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetDeviceL
$LN4@GetDeviceL:
	DB	108					; 0000006cH
	DB	0
?GetDeviceLostFuncUserContext@DXUTState@@QAEPAXXZ ENDP	; DXUTState::GetDeviceLostFuncUserContext
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetDeviceLostFuncUserContext@DXUTState@@QAEXPAX@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetDeviceLostFuncUserContext@DXUTState@@QAEXPAX@Z PROC	; DXUTState::SetDeviceLostFuncUserContext, COMDAT
; _this$ = ecx

; 334  :     GET_SET_ACCESSOR( void*, DeviceLostFuncUserContext );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+664], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetDeviceL
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetDeviceL:
	DD	1
	DD	$LN5@SetDeviceL
$LN5@SetDeviceL:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetDeviceL
$LN4@SetDeviceL:
	DB	108					; 0000006cH
	DB	0
?SetDeviceLostFuncUserContext@DXUTState@@QAEXPAX@Z ENDP	; DXUTState::SetDeviceLostFuncUserContext
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetDeviceResetFuncUserContext@DXUTState@@QAEPAXXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetDeviceResetFuncUserContext@DXUTState@@QAEPAXXZ PROC	; DXUTState::GetDeviceResetFuncUserContext, COMDAT
; _this$ = ecx

; 333  :     GET_SET_ACCESSOR( void*, DeviceResetFuncUserContext );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+660]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetDeviceR
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetDeviceR:
	DD	1
	DD	$LN5@GetDeviceR
$LN5@GetDeviceR:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetDeviceR
$LN4@GetDeviceR:
	DB	108					; 0000006cH
	DB	0
?GetDeviceResetFuncUserContext@DXUTState@@QAEPAXXZ ENDP	; DXUTState::GetDeviceResetFuncUserContext
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetDeviceResetFuncUserContext@DXUTState@@QAEXPAX@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetDeviceResetFuncUserContext@DXUTState@@QAEXPAX@Z PROC ; DXUTState::SetDeviceResetFuncUserContext, COMDAT
; _this$ = ecx

; 333  :     GET_SET_ACCESSOR( void*, DeviceResetFuncUserContext );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+660], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetDeviceR
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetDeviceR:
	DD	1
	DD	$LN5@SetDeviceR
$LN5@SetDeviceR:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetDeviceR
$LN4@SetDeviceR:
	DB	108					; 0000006cH
	DB	0
?SetDeviceResetFuncUserContext@DXUTState@@QAEXPAX@Z ENDP ; DXUTState::SetDeviceResetFuncUserContext
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetDeviceCreatedFuncUserContext@DXUTState@@QAEPAXXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetDeviceCreatedFuncUserContext@DXUTState@@QAEPAXXZ PROC ; DXUTState::GetDeviceCreatedFuncUserContext, COMDAT
; _this$ = ecx

; 332  :     GET_SET_ACCESSOR( void*, DeviceCreatedFuncUserContext );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+656]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetDeviceC
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetDeviceC:
	DD	1
	DD	$LN5@GetDeviceC
$LN5@GetDeviceC:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetDeviceC
$LN4@GetDeviceC:
	DB	108					; 0000006cH
	DB	0
?GetDeviceCreatedFuncUserContext@DXUTState@@QAEPAXXZ ENDP ; DXUTState::GetDeviceCreatedFuncUserContext
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetDeviceCreatedFuncUserContext@DXUTState@@QAEXPAX@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetDeviceCreatedFuncUserContext@DXUTState@@QAEXPAX@Z PROC ; DXUTState::SetDeviceCreatedFuncUserContext, COMDAT
; _this$ = ecx

; 332  :     GET_SET_ACCESSOR( void*, DeviceCreatedFuncUserContext );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+656], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetDeviceC
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetDeviceC:
	DD	1
	DD	$LN5@SetDeviceC
$LN5@SetDeviceC:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetDeviceC
$LN4@SetDeviceC:
	DB	108					; 0000006cH
	DB	0
?SetDeviceCreatedFuncUserContext@DXUTState@@QAEXPAX@Z ENDP ; DXUTState::SetDeviceCreatedFuncUserContext
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetModifyDeviceSettingsFuncUserContext@DXUTState@@QAEPAXXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetModifyDeviceSettingsFuncUserContext@DXUTState@@QAEPAXXZ PROC ; DXUTState::GetModifyDeviceSettingsFuncUserContext, COMDAT
; _this$ = ecx

; 331  :     GET_SET_ACCESSOR( void*, ModifyDeviceSettingsFuncUserContext );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+648]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetModifyD
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetModifyD:
	DD	1
	DD	$LN5@GetModifyD
$LN5@GetModifyD:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetModifyD
$LN4@GetModifyD:
	DB	108					; 0000006cH
	DB	0
?GetModifyDeviceSettingsFuncUserContext@DXUTState@@QAEPAXXZ ENDP ; DXUTState::GetModifyDeviceSettingsFuncUserContext
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetModifyDeviceSettingsFuncUserContext@DXUTState@@QAEXPAX@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetModifyDeviceSettingsFuncUserContext@DXUTState@@QAEXPAX@Z PROC ; DXUTState::SetModifyDeviceSettingsFuncUserContext, COMDAT
; _this$ = ecx

; 331  :     GET_SET_ACCESSOR( void*, ModifyDeviceSettingsFuncUserContext );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+648], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetModifyD
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetModifyD:
	DD	1
	DD	$LN5@SetModifyD
$LN5@SetModifyD:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetModifyD
$LN4@SetModifyD:
	DB	108					; 0000006cH
	DB	0
?SetModifyDeviceSettingsFuncUserContext@DXUTState@@QAEXPAX@Z ENDP ; DXUTState::SetModifyDeviceSettingsFuncUserContext
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetIsDeviceAcceptableFuncUserContext@DXUTState@@QAEPAXXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetIsDeviceAcceptableFuncUserContext@DXUTState@@QAEPAXXZ PROC ; DXUTState::GetIsDeviceAcceptableFuncUserContext, COMDAT
; _this$ = ecx

; 330  :     GET_SET_ACCESSOR( void*, IsDeviceAcceptableFuncUserContext );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+644]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetIsDevic
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetIsDevic:
	DD	1
	DD	$LN5@GetIsDevic
$LN5@GetIsDevic:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetIsDevic
$LN4@GetIsDevic:
	DB	108					; 0000006cH
	DB	0
?GetIsDeviceAcceptableFuncUserContext@DXUTState@@QAEPAXXZ ENDP ; DXUTState::GetIsDeviceAcceptableFuncUserContext
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetIsDeviceAcceptableFuncUserContext@DXUTState@@QAEXPAX@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetIsDeviceAcceptableFuncUserContext@DXUTState@@QAEXPAX@Z PROC ; DXUTState::SetIsDeviceAcceptableFuncUserContext, COMDAT
; _this$ = ecx

; 330  :     GET_SET_ACCESSOR( void*, IsDeviceAcceptableFuncUserContext );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+644], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetIsDevic
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetIsDevic:
	DD	1
	DD	$LN5@SetIsDevic
$LN5@SetIsDevic:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetIsDevic
$LN4@SetIsDevic:
	DB	108					; 0000006cH
	DB	0
?SetIsDeviceAcceptableFuncUserContext@DXUTState@@QAEXPAX@Z ENDP ; DXUTState::SetIsDeviceAcceptableFuncUserContext
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetWindowMsgFunc@DXUTState@@QAEXP6GJPAUHWND__@@IIJPA_NPAX@Z@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetWindowMsgFunc@DXUTState@@QAEXP6GJPAUHWND__@@IIJPA_NPAX@Z@Z PROC ; DXUTState::SetWindowMsgFunc, COMDAT
; _this$ = ecx

; 328  :     GET_SET_ACCESSOR( LPDXUTCALLBACKMSGPROC, WindowMsgFunc );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+640], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetWindowM
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetWindowM:
	DD	1
	DD	$LN5@SetWindowM
$LN5@SetWindowM:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetWindowM
$LN4@SetWindowM:
	DB	108					; 0000006cH
	DB	0
?SetWindowMsgFunc@DXUTState@@QAEXP6GJPAUHWND__@@IIJPA_NPAX@Z@Z ENDP ; DXUTState::SetWindowMsgFunc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetMouseFunc@DXUTState@@QAEP6GX_N0000HHHPAX@ZXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetMouseFunc@DXUTState@@QAEP6GX_N0000HHHPAX@ZXZ PROC	; DXUTState::GetMouseFunc, COMDAT
; _this$ = ecx

; 327  :     GET_SET_ACCESSOR( LPDXUTCALLBACKMOUSE, MouseFunc );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+636]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetMouseFu
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetMouseFu:
	DD	1
	DD	$LN5@GetMouseFu
$LN5@GetMouseFu:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetMouseFu
$LN4@GetMouseFu:
	DB	108					; 0000006cH
	DB	0
?GetMouseFunc@DXUTState@@QAEP6GX_N0000HHHPAX@ZXZ ENDP	; DXUTState::GetMouseFunc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetMouseFunc@DXUTState@@QAEXP6GX_N0000HHHPAX@Z@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetMouseFunc@DXUTState@@QAEXP6GX_N0000HHHPAX@Z@Z PROC	; DXUTState::SetMouseFunc, COMDAT
; _this$ = ecx

; 327  :     GET_SET_ACCESSOR( LPDXUTCALLBACKMOUSE, MouseFunc );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+636], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetMouseFu
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetMouseFu:
	DD	1
	DD	$LN5@SetMouseFu
$LN5@SetMouseFu:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetMouseFu
$LN4@SetMouseFu:
	DB	108					; 0000006cH
	DB	0
?SetMouseFunc@DXUTState@@QAEXP6GX_N0000HHHPAX@Z@Z ENDP	; DXUTState::SetMouseFunc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetKeyboardFunc@DXUTState@@QAEP6GXI_N0PAX@ZXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetKeyboardFunc@DXUTState@@QAEP6GXI_N0PAX@ZXZ PROC	; DXUTState::GetKeyboardFunc, COMDAT
; _this$ = ecx

; 326  :     GET_SET_ACCESSOR( LPDXUTCALLBACKKEYBOARD, KeyboardFunc );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+632]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetKeyboar
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetKeyboar:
	DD	1
	DD	$LN5@GetKeyboar
$LN5@GetKeyboar:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetKeyboar
$LN4@GetKeyboar:
	DB	108					; 0000006cH
	DB	0
?GetKeyboardFunc@DXUTState@@QAEP6GXI_N0PAX@ZXZ ENDP	; DXUTState::GetKeyboardFunc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetKeyboardFunc@DXUTState@@QAEXP6GXI_N0PAX@Z@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetKeyboardFunc@DXUTState@@QAEXP6GXI_N0PAX@Z@Z PROC	; DXUTState::SetKeyboardFunc, COMDAT
; _this$ = ecx

; 326  :     GET_SET_ACCESSOR( LPDXUTCALLBACKKEYBOARD, KeyboardFunc );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+632], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetKeyboar
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetKeyboar:
	DD	1
	DD	$LN5@SetKeyboar
$LN5@SetKeyboar:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetKeyboar
$LN4@SetKeyboar:
	DB	108					; 0000006cH
	DB	0
?SetKeyboardFunc@DXUTState@@QAEXP6GXI_N0PAX@Z@Z ENDP	; DXUTState::SetKeyboardFunc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetFrameRenderFunc@DXUTState@@QAEP6GXPAUIDirect3DDevice9@@NMPAX@ZXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetFrameRenderFunc@DXUTState@@QAEP6GXPAUIDirect3DDevice9@@NMPAX@ZXZ PROC ; DXUTState::GetFrameRenderFunc, COMDAT
; _this$ = ecx

; 325  :     GET_SET_ACCESSOR( LPDXUTCALLBACKFRAMERENDER, FrameRenderFunc );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+628]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetFrameRe
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetFrameRe:
	DD	1
	DD	$LN5@GetFrameRe
$LN5@GetFrameRe:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetFrameRe
$LN4@GetFrameRe:
	DB	108					; 0000006cH
	DB	0
?GetFrameRenderFunc@DXUTState@@QAEP6GXPAUIDirect3DDevice9@@NMPAX@ZXZ ENDP ; DXUTState::GetFrameRenderFunc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetFrameRenderFunc@DXUTState@@QAEXP6GXPAUIDirect3DDevice9@@NMPAX@Z@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetFrameRenderFunc@DXUTState@@QAEXP6GXPAUIDirect3DDevice9@@NMPAX@Z@Z PROC ; DXUTState::SetFrameRenderFunc, COMDAT
; _this$ = ecx

; 325  :     GET_SET_ACCESSOR( LPDXUTCALLBACKFRAMERENDER, FrameRenderFunc );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+628], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetFrameRe
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetFrameRe:
	DD	1
	DD	$LN5@SetFrameRe
$LN5@SetFrameRe:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetFrameRe
$LN4@SetFrameRe:
	DB	108					; 0000006cH
	DB	0
?SetFrameRenderFunc@DXUTState@@QAEXP6GXPAUIDirect3DDevice9@@NMPAX@Z@Z ENDP ; DXUTState::SetFrameRenderFunc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetFrameMoveFunc@DXUTState@@QAEP6GXPAUIDirect3DDevice9@@NMPAX@ZXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetFrameMoveFunc@DXUTState@@QAEP6GXPAUIDirect3DDevice9@@NMPAX@ZXZ PROC ; DXUTState::GetFrameMoveFunc, COMDAT
; _this$ = ecx

; 324  :     GET_SET_ACCESSOR( LPDXUTCALLBACKFRAMEMOVE, FrameMoveFunc );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+624]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetFrameMo
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetFrameMo:
	DD	1
	DD	$LN5@GetFrameMo
$LN5@GetFrameMo:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetFrameMo
$LN4@GetFrameMo:
	DB	108					; 0000006cH
	DB	0
?GetFrameMoveFunc@DXUTState@@QAEP6GXPAUIDirect3DDevice9@@NMPAX@ZXZ ENDP ; DXUTState::GetFrameMoveFunc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetFrameMoveFunc@DXUTState@@QAEXP6GXPAUIDirect3DDevice9@@NMPAX@Z@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetFrameMoveFunc@DXUTState@@QAEXP6GXPAUIDirect3DDevice9@@NMPAX@Z@Z PROC ; DXUTState::SetFrameMoveFunc, COMDAT
; _this$ = ecx

; 324  :     GET_SET_ACCESSOR( LPDXUTCALLBACKFRAMEMOVE, FrameMoveFunc );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+624], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetFrameMo
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetFrameMo:
	DD	1
	DD	$LN5@SetFrameMo
$LN5@SetFrameMo:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetFrameMo
$LN4@SetFrameMo:
	DB	108					; 0000006cH
	DB	0
?SetFrameMoveFunc@DXUTState@@QAEXP6GXPAUIDirect3DDevice9@@NMPAX@Z@Z ENDP ; DXUTState::SetFrameMoveFunc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetDeviceDestroyedFunc@DXUTState@@QAEP6GXPAX@ZXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetDeviceDestroyedFunc@DXUTState@@QAEP6GXPAX@ZXZ PROC	; DXUTState::GetDeviceDestroyedFunc, COMDAT
; _this$ = ecx

; 323  :     GET_SET_ACCESSOR( LPDXUTCALLBACKDEVICEDESTROYED, DeviceDestroyedFunc );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+620]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetDeviceD
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetDeviceD:
	DD	1
	DD	$LN5@GetDeviceD
$LN5@GetDeviceD:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetDeviceD
$LN4@GetDeviceD:
	DB	108					; 0000006cH
	DB	0
?GetDeviceDestroyedFunc@DXUTState@@QAEP6GXPAX@ZXZ ENDP	; DXUTState::GetDeviceDestroyedFunc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetDeviceDestroyedFunc@DXUTState@@QAEXP6GXPAX@Z@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetDeviceDestroyedFunc@DXUTState@@QAEXP6GXPAX@Z@Z PROC	; DXUTState::SetDeviceDestroyedFunc, COMDAT
; _this$ = ecx

; 323  :     GET_SET_ACCESSOR( LPDXUTCALLBACKDEVICEDESTROYED, DeviceDestroyedFunc );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+620], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetDeviceD
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetDeviceD:
	DD	1
	DD	$LN5@SetDeviceD
$LN5@SetDeviceD:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetDeviceD
$LN4@SetDeviceD:
	DB	108					; 0000006cH
	DB	0
?SetDeviceDestroyedFunc@DXUTState@@QAEXP6GXPAX@Z@Z ENDP	; DXUTState::SetDeviceDestroyedFunc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetDeviceLostFunc@DXUTState@@QAEP6GXPAX@ZXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetDeviceLostFunc@DXUTState@@QAEP6GXPAX@ZXZ PROC	; DXUTState::GetDeviceLostFunc, COMDAT
; _this$ = ecx

; 322  :     GET_SET_ACCESSOR( LPDXUTCALLBACKDEVICELOST, DeviceLostFunc );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+616]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetDeviceL
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetDeviceL:
	DD	1
	DD	$LN5@GetDeviceL
$LN5@GetDeviceL:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetDeviceL
$LN4@GetDeviceL:
	DB	108					; 0000006cH
	DB	0
?GetDeviceLostFunc@DXUTState@@QAEP6GXPAX@ZXZ ENDP	; DXUTState::GetDeviceLostFunc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetDeviceLostFunc@DXUTState@@QAEXP6GXPAX@Z@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetDeviceLostFunc@DXUTState@@QAEXP6GXPAX@Z@Z PROC	; DXUTState::SetDeviceLostFunc, COMDAT
; _this$ = ecx

; 322  :     GET_SET_ACCESSOR( LPDXUTCALLBACKDEVICELOST, DeviceLostFunc );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+616], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetDeviceL
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetDeviceL:
	DD	1
	DD	$LN5@SetDeviceL
$LN5@SetDeviceL:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetDeviceL
$LN4@SetDeviceL:
	DB	108					; 0000006cH
	DB	0
?SetDeviceLostFunc@DXUTState@@QAEXP6GXPAX@Z@Z ENDP	; DXUTState::SetDeviceLostFunc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetDeviceResetFunc@DXUTState@@QAEP6GJPAUIDirect3DDevice9@@PBU_D3DSURFACE_DESC@@PAX@ZXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetDeviceResetFunc@DXUTState@@QAEP6GJPAUIDirect3DDevice9@@PBU_D3DSURFACE_DESC@@PAX@ZXZ PROC ; DXUTState::GetDeviceResetFunc, COMDAT
; _this$ = ecx

; 321  :     GET_SET_ACCESSOR( LPDXUTCALLBACKDEVICERESET, DeviceResetFunc );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+612]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetDeviceR
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetDeviceR:
	DD	1
	DD	$LN5@GetDeviceR
$LN5@GetDeviceR:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetDeviceR
$LN4@GetDeviceR:
	DB	108					; 0000006cH
	DB	0
?GetDeviceResetFunc@DXUTState@@QAEP6GJPAUIDirect3DDevice9@@PBU_D3DSURFACE_DESC@@PAX@ZXZ ENDP ; DXUTState::GetDeviceResetFunc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetDeviceResetFunc@DXUTState@@QAEXP6GJPAUIDirect3DDevice9@@PBU_D3DSURFACE_DESC@@PAX@Z@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetDeviceResetFunc@DXUTState@@QAEXP6GJPAUIDirect3DDevice9@@PBU_D3DSURFACE_DESC@@PAX@Z@Z PROC ; DXUTState::SetDeviceResetFunc, COMDAT
; _this$ = ecx

; 321  :     GET_SET_ACCESSOR( LPDXUTCALLBACKDEVICERESET, DeviceResetFunc );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+612], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetDeviceR
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetDeviceR:
	DD	1
	DD	$LN5@SetDeviceR
$LN5@SetDeviceR:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetDeviceR
$LN4@SetDeviceR:
	DB	108					; 0000006cH
	DB	0
?SetDeviceResetFunc@DXUTState@@QAEXP6GJPAUIDirect3DDevice9@@PBU_D3DSURFACE_DESC@@PAX@Z@Z ENDP ; DXUTState::SetDeviceResetFunc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetDeviceCreatedFunc@DXUTState@@QAEP6GJPAUIDirect3DDevice9@@PBU_D3DSURFACE_DESC@@PAX@ZXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetDeviceCreatedFunc@DXUTState@@QAEP6GJPAUIDirect3DDevice9@@PBU_D3DSURFACE_DESC@@PAX@ZXZ PROC ; DXUTState::GetDeviceCreatedFunc, COMDAT
; _this$ = ecx

; 320  :     GET_SET_ACCESSOR( LPDXUTCALLBACKDEVICECREATED, DeviceCreatedFunc );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+608]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetDeviceC
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetDeviceC:
	DD	1
	DD	$LN5@GetDeviceC
$LN5@GetDeviceC:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetDeviceC
$LN4@GetDeviceC:
	DB	108					; 0000006cH
	DB	0
?GetDeviceCreatedFunc@DXUTState@@QAEP6GJPAUIDirect3DDevice9@@PBU_D3DSURFACE_DESC@@PAX@ZXZ ENDP ; DXUTState::GetDeviceCreatedFunc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetDeviceCreatedFunc@DXUTState@@QAEXP6GJPAUIDirect3DDevice9@@PBU_D3DSURFACE_DESC@@PAX@Z@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetDeviceCreatedFunc@DXUTState@@QAEXP6GJPAUIDirect3DDevice9@@PBU_D3DSURFACE_DESC@@PAX@Z@Z PROC ; DXUTState::SetDeviceCreatedFunc, COMDAT
; _this$ = ecx

; 320  :     GET_SET_ACCESSOR( LPDXUTCALLBACKDEVICECREATED, DeviceCreatedFunc );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+608], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetDeviceC
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetDeviceC:
	DD	1
	DD	$LN5@SetDeviceC
$LN5@SetDeviceC:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetDeviceC
$LN4@SetDeviceC:
	DB	108					; 0000006cH
	DB	0
?SetDeviceCreatedFunc@DXUTState@@QAEXP6GJPAUIDirect3DDevice9@@PBU_D3DSURFACE_DESC@@PAX@Z@Z ENDP ; DXUTState::SetDeviceCreatedFunc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetModifyDeviceSettingsFunc@DXUTState@@QAEP6G_NPAUDXUTDeviceSettings@@PBU_D3DCAPS9@@PAX@ZXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetModifyDeviceSettingsFunc@DXUTState@@QAEP6G_NPAUDXUTDeviceSettings@@PBU_D3DCAPS9@@PAX@ZXZ PROC ; DXUTState::GetModifyDeviceSettingsFunc, COMDAT
; _this$ = ecx

; 319  :     GET_SET_ACCESSOR( LPDXUTCALLBACKMODIFYDEVICESETTINGS, ModifyDeviceSettingsFunc );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+604]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetModifyD
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetModifyD:
	DD	1
	DD	$LN5@GetModifyD
$LN5@GetModifyD:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetModifyD
$LN4@GetModifyD:
	DB	108					; 0000006cH
	DB	0
?GetModifyDeviceSettingsFunc@DXUTState@@QAEP6G_NPAUDXUTDeviceSettings@@PBU_D3DCAPS9@@PAX@ZXZ ENDP ; DXUTState::GetModifyDeviceSettingsFunc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetModifyDeviceSettingsFunc@DXUTState@@QAEXP6G_NPAUDXUTDeviceSettings@@PBU_D3DCAPS9@@PAX@Z@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetModifyDeviceSettingsFunc@DXUTState@@QAEXP6G_NPAUDXUTDeviceSettings@@PBU_D3DCAPS9@@PAX@Z@Z PROC ; DXUTState::SetModifyDeviceSettingsFunc, COMDAT
; _this$ = ecx

; 319  :     GET_SET_ACCESSOR( LPDXUTCALLBACKMODIFYDEVICESETTINGS, ModifyDeviceSettingsFunc );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+604], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetModifyD
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetModifyD:
	DD	1
	DD	$LN5@SetModifyD
$LN5@SetModifyD:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetModifyD
$LN4@SetModifyD:
	DB	108					; 0000006cH
	DB	0
?SetModifyDeviceSettingsFunc@DXUTState@@QAEXP6G_NPAUDXUTDeviceSettings@@PBU_D3DCAPS9@@PAX@Z@Z ENDP ; DXUTState::SetModifyDeviceSettingsFunc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetIsDeviceAcceptableFunc@DXUTState@@QAEP6G_NPAU_D3DCAPS9@@W4_D3DFORMAT@@1_NPAX@ZXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetIsDeviceAcceptableFunc@DXUTState@@QAEP6G_NPAU_D3DCAPS9@@W4_D3DFORMAT@@1_NPAX@ZXZ PROC ; DXUTState::GetIsDeviceAcceptableFunc, COMDAT
; _this$ = ecx

; 318  :     GET_SET_ACCESSOR( LPDXUTCALLBACKISDEVICEACCEPTABLE, IsDeviceAcceptableFunc );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+600]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetIsDevic
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetIsDevic:
	DD	1
	DD	$LN5@GetIsDevic
$LN5@GetIsDevic:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetIsDevic
$LN4@GetIsDevic:
	DB	108					; 0000006cH
	DB	0
?GetIsDeviceAcceptableFunc@DXUTState@@QAEP6G_NPAU_D3DCAPS9@@W4_D3DFORMAT@@1_NPAX@ZXZ ENDP ; DXUTState::GetIsDeviceAcceptableFunc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetIsDeviceAcceptableFunc@DXUTState@@QAEXP6G_NPAU_D3DCAPS9@@W4_D3DFORMAT@@1_NPAX@Z@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetIsDeviceAcceptableFunc@DXUTState@@QAEXP6G_NPAU_D3DCAPS9@@W4_D3DFORMAT@@1_NPAX@Z@Z PROC ; DXUTState::SetIsDeviceAcceptableFunc, COMDAT
; _this$ = ecx

; 318  :     GET_SET_ACCESSOR( LPDXUTCALLBACKISDEVICEACCEPTABLE, IsDeviceAcceptableFunc );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+600], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetIsDevic
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetIsDevic:
	DD	1
	DD	$LN5@SetIsDevic
$LN5@SetIsDevic:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetIsDevic
$LN4@SetIsDevic:
	DB	108					; 0000006cH
	DB	0
?SetIsDeviceAcceptableFunc@DXUTState@@QAEXP6G_NPAU_D3DCAPS9@@W4_D3DFORMAT@@1_NPAX@Z@Z ENDP ; DXUTState::SetIsDeviceAcceptableFunc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetOverrideQuitAfterFrame@DXUTState@@QAEHXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetOverrideQuitAfterFrame@DXUTState@@QAEHXZ PROC	; DXUTState::GetOverrideQuitAfterFrame, COMDAT
; _this$ = ecx

; 316  :     GET_SET_ACCESSOR( int, OverrideQuitAfterFrame );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+596]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetOverrid
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetOverrid:
	DD	1
	DD	$LN5@GetOverrid
$LN5@GetOverrid:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetOverrid
$LN4@GetOverrid:
	DB	108					; 0000006cH
	DB	0
?GetOverrideQuitAfterFrame@DXUTState@@QAEHXZ ENDP	; DXUTState::GetOverrideQuitAfterFrame
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetOverrideQuitAfterFrame@DXUTState@@QAEXH@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetOverrideQuitAfterFrame@DXUTState@@QAEXH@Z PROC	; DXUTState::SetOverrideQuitAfterFrame, COMDAT
; _this$ = ecx

; 316  :     GET_SET_ACCESSOR( int, OverrideQuitAfterFrame );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+596], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetOverrid
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetOverrid:
	DD	1
	DD	$LN5@SetOverrid
$LN5@SetOverrid:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetOverrid
$LN4@SetOverrid:
	DB	108					; 0000006cH
	DB	0
?SetOverrideQuitAfterFrame@DXUTState@@QAEXH@Z ENDP	; DXUTState::SetOverrideQuitAfterFrame
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetOverrideConstantTimePerFrame@DXUTState@@QAEMXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetOverrideConstantTimePerFrame@DXUTState@@QAEMXZ PROC	; DXUTState::GetOverrideConstantTimePerFrame, COMDAT
; _this$ = ecx

; 315  :     GET_SET_ACCESSOR( float, OverrideConstantTimePerFrame );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+592]
	movss	DWORD PTR $T1[ebp], xmm0
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	fld	DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetOverrid
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetOverrid:
	DD	1
	DD	$LN5@GetOverrid
$LN5@GetOverrid:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetOverrid
$LN4@GetOverrid:
	DB	108					; 0000006cH
	DB	0
?GetOverrideConstantTimePerFrame@DXUTState@@QAEMXZ ENDP	; DXUTState::GetOverrideConstantTimePerFrame
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetOverrideConstantTimePerFrame@DXUTState@@QAEXM@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetOverrideConstantTimePerFrame@DXUTState@@QAEXM@Z PROC ; DXUTState::SetOverrideConstantTimePerFrame, COMDAT
; _this$ = ecx

; 315  :     GET_SET_ACCESSOR( float, OverrideConstantTimePerFrame );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _t$[ebp]
	movss	DWORD PTR [eax+592], xmm0
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetOverrid
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetOverrid:
	DD	1
	DD	$LN5@SetOverrid
$LN5@SetOverrid:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetOverrid
$LN4@SetOverrid:
	DB	108					; 0000006cH
	DB	0
?SetOverrideConstantTimePerFrame@DXUTState@@QAEXM@Z ENDP ; DXUTState::SetOverrideConstantTimePerFrame
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetOverrideConstantFrameTime@DXUTState@@QAE_NXZ
_TEXT	SEGMENT
$T1 = -221						; size = 1
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetOverrideConstantFrameTime@DXUTState@@QAE_NXZ PROC	; DXUTState::GetOverrideConstantFrameTime, COMDAT
; _this$ = ecx

; 314  :     GET_SET_ACCESSOR( bool, OverrideConstantFrameTime );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+591]
	mov	BYTE PTR $T1[ebp], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	al, BYTE PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetOverrid
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetOverrid:
	DD	1
	DD	$LN5@GetOverrid
$LN5@GetOverrid:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetOverrid
$LN4@GetOverrid:
	DB	108					; 0000006cH
	DB	0
?GetOverrideConstantFrameTime@DXUTState@@QAE_NXZ ENDP	; DXUTState::GetOverrideConstantFrameTime
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetOverrideConstantFrameTime@DXUTState@@QAEX_N@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 1
?SetOverrideConstantFrameTime@DXUTState@@QAEX_N@Z PROC	; DXUTState::SetOverrideConstantFrameTime, COMDAT
; _this$ = ecx

; 314  :     GET_SET_ACCESSOR( bool, OverrideConstantFrameTime );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+591], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetOverrid
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetOverrid:
	DD	1
	DD	$LN5@SetOverrid
$LN5@SetOverrid:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetOverrid
$LN4@SetOverrid:
	DB	108					; 0000006cH
	DB	0
?SetOverrideConstantFrameTime@DXUTState@@QAEX_N@Z ENDP	; DXUTState::SetOverrideConstantFrameTime
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetOverrideForceSWVP@DXUTState@@QAE_NXZ
_TEXT	SEGMENT
$T1 = -221						; size = 1
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetOverrideForceSWVP@DXUTState@@QAE_NXZ PROC		; DXUTState::GetOverrideForceSWVP, COMDAT
; _this$ = ecx

; 313  :     GET_SET_ACCESSOR( bool, OverrideForceSWVP );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+590]
	mov	BYTE PTR $T1[ebp], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	al, BYTE PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetOverrid
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetOverrid:
	DD	1
	DD	$LN5@GetOverrid
$LN5@GetOverrid:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetOverrid
$LN4@GetOverrid:
	DB	108					; 0000006cH
	DB	0
?GetOverrideForceSWVP@DXUTState@@QAE_NXZ ENDP		; DXUTState::GetOverrideForceSWVP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetOverrideForceSWVP@DXUTState@@QAEX_N@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 1
?SetOverrideForceSWVP@DXUTState@@QAEX_N@Z PROC		; DXUTState::SetOverrideForceSWVP, COMDAT
; _this$ = ecx

; 313  :     GET_SET_ACCESSOR( bool, OverrideForceSWVP );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+590], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetOverrid
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetOverrid:
	DD	1
	DD	$LN5@SetOverrid
$LN5@SetOverrid:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetOverrid
$LN4@SetOverrid:
	DB	108					; 0000006cH
	DB	0
?SetOverrideForceSWVP@DXUTState@@QAEX_N@Z ENDP		; DXUTState::SetOverrideForceSWVP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetOverrideForceHWVP@DXUTState@@QAE_NXZ
_TEXT	SEGMENT
$T1 = -221						; size = 1
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetOverrideForceHWVP@DXUTState@@QAE_NXZ PROC		; DXUTState::GetOverrideForceHWVP, COMDAT
; _this$ = ecx

; 312  :     GET_SET_ACCESSOR( bool, OverrideForceHWVP );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+589]
	mov	BYTE PTR $T1[ebp], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	al, BYTE PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetOverrid
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetOverrid:
	DD	1
	DD	$LN5@GetOverrid
$LN5@GetOverrid:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetOverrid
$LN4@GetOverrid:
	DB	108					; 0000006cH
	DB	0
?GetOverrideForceHWVP@DXUTState@@QAE_NXZ ENDP		; DXUTState::GetOverrideForceHWVP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetOverrideForceHWVP@DXUTState@@QAEX_N@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 1
?SetOverrideForceHWVP@DXUTState@@QAEX_N@Z PROC		; DXUTState::SetOverrideForceHWVP, COMDAT
; _this$ = ecx

; 312  :     GET_SET_ACCESSOR( bool, OverrideForceHWVP );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+589], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetOverrid
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetOverrid:
	DD	1
	DD	$LN5@SetOverrid
$LN5@SetOverrid:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetOverrid
$LN4@SetOverrid:
	DB	108					; 0000006cH
	DB	0
?SetOverrideForceHWVP@DXUTState@@QAEX_N@Z ENDP		; DXUTState::SetOverrideForceHWVP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetOverrideForcePureHWVP@DXUTState@@QAE_NXZ
_TEXT	SEGMENT
$T1 = -221						; size = 1
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetOverrideForcePureHWVP@DXUTState@@QAE_NXZ PROC	; DXUTState::GetOverrideForcePureHWVP, COMDAT
; _this$ = ecx

; 311  :     GET_SET_ACCESSOR( bool, OverrideForcePureHWVP );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+588]
	mov	BYTE PTR $T1[ebp], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	al, BYTE PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetOverrid
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetOverrid:
	DD	1
	DD	$LN5@GetOverrid
$LN5@GetOverrid:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetOverrid
$LN4@GetOverrid:
	DB	108					; 0000006cH
	DB	0
?GetOverrideForcePureHWVP@DXUTState@@QAE_NXZ ENDP	; DXUTState::GetOverrideForcePureHWVP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetOverrideForcePureHWVP@DXUTState@@QAEX_N@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 1
?SetOverrideForcePureHWVP@DXUTState@@QAEX_N@Z PROC	; DXUTState::SetOverrideForcePureHWVP, COMDAT
; _this$ = ecx

; 311  :     GET_SET_ACCESSOR( bool, OverrideForcePureHWVP );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+588], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetOverrid
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetOverrid:
	DD	1
	DD	$LN5@SetOverrid
$LN5@SetOverrid:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetOverrid
$LN4@SetOverrid:
	DB	108					; 0000006cH
	DB	0
?SetOverrideForcePureHWVP@DXUTState@@QAEX_N@Z ENDP	; DXUTState::SetOverrideForcePureHWVP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetOverrideForceREF@DXUTState@@QAE_NXZ
_TEXT	SEGMENT
$T1 = -221						; size = 1
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetOverrideForceREF@DXUTState@@QAE_NXZ PROC		; DXUTState::GetOverrideForceREF, COMDAT
; _this$ = ecx

; 310  :     GET_SET_ACCESSOR( bool, OverrideForceREF );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+587]
	mov	BYTE PTR $T1[ebp], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	al, BYTE PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetOverrid
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetOverrid:
	DD	1
	DD	$LN5@GetOverrid
$LN5@GetOverrid:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetOverrid
$LN4@GetOverrid:
	DB	108					; 0000006cH
	DB	0
?GetOverrideForceREF@DXUTState@@QAE_NXZ ENDP		; DXUTState::GetOverrideForceREF
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetOverrideForceREF@DXUTState@@QAEX_N@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 1
?SetOverrideForceREF@DXUTState@@QAEX_N@Z PROC		; DXUTState::SetOverrideForceREF, COMDAT
; _this$ = ecx

; 310  :     GET_SET_ACCESSOR( bool, OverrideForceREF );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+587], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetOverrid
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetOverrid:
	DD	1
	DD	$LN5@SetOverrid
$LN5@SetOverrid:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetOverrid
$LN4@SetOverrid:
	DB	108					; 0000006cH
	DB	0
?SetOverrideForceREF@DXUTState@@QAEX_N@Z ENDP		; DXUTState::SetOverrideForceREF
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetOverrideForceHAL@DXUTState@@QAE_NXZ
_TEXT	SEGMENT
$T1 = -221						; size = 1
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetOverrideForceHAL@DXUTState@@QAE_NXZ PROC		; DXUTState::GetOverrideForceHAL, COMDAT
; _this$ = ecx

; 309  :     GET_SET_ACCESSOR( bool, OverrideForceHAL );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+586]
	mov	BYTE PTR $T1[ebp], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	al, BYTE PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetOverrid
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetOverrid:
	DD	1
	DD	$LN5@GetOverrid
$LN5@GetOverrid:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetOverrid
$LN4@GetOverrid:
	DB	108					; 0000006cH
	DB	0
?GetOverrideForceHAL@DXUTState@@QAE_NXZ ENDP		; DXUTState::GetOverrideForceHAL
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetOverrideForceHAL@DXUTState@@QAEX_N@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 1
?SetOverrideForceHAL@DXUTState@@QAEX_N@Z PROC		; DXUTState::SetOverrideForceHAL, COMDAT
; _this$ = ecx

; 309  :     GET_SET_ACCESSOR( bool, OverrideForceHAL );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+586], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetOverrid
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetOverrid:
	DD	1
	DD	$LN5@SetOverrid
$LN5@SetOverrid:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetOverrid
$LN4@SetOverrid:
	DB	108					; 0000006cH
	DB	0
?SetOverrideForceHAL@DXUTState@@QAEX_N@Z ENDP		; DXUTState::SetOverrideForceHAL
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetOverrideHeight@DXUTState@@QAEHXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetOverrideHeight@DXUTState@@QAEHXZ PROC		; DXUTState::GetOverrideHeight, COMDAT
; _this$ = ecx

; 308  :     GET_SET_ACCESSOR( int, OverrideHeight );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+582]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetOverrid
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetOverrid:
	DD	1
	DD	$LN5@GetOverrid
$LN5@GetOverrid:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetOverrid
$LN4@GetOverrid:
	DB	108					; 0000006cH
	DB	0
?GetOverrideHeight@DXUTState@@QAEHXZ ENDP		; DXUTState::GetOverrideHeight
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetOverrideHeight@DXUTState@@QAEXH@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetOverrideHeight@DXUTState@@QAEXH@Z PROC		; DXUTState::SetOverrideHeight, COMDAT
; _this$ = ecx

; 308  :     GET_SET_ACCESSOR( int, OverrideHeight );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+582], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetOverrid
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetOverrid:
	DD	1
	DD	$LN5@SetOverrid
$LN5@SetOverrid:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetOverrid
$LN4@SetOverrid:
	DB	108					; 0000006cH
	DB	0
?SetOverrideHeight@DXUTState@@QAEXH@Z ENDP		; DXUTState::SetOverrideHeight
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetOverrideWidth@DXUTState@@QAEHXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetOverrideWidth@DXUTState@@QAEHXZ PROC		; DXUTState::GetOverrideWidth, COMDAT
; _this$ = ecx

; 307  :     GET_SET_ACCESSOR( int, OverrideWidth );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+578]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetOverrid
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetOverrid:
	DD	1
	DD	$LN5@GetOverrid
$LN5@GetOverrid:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetOverrid
$LN4@GetOverrid:
	DB	108					; 0000006cH
	DB	0
?GetOverrideWidth@DXUTState@@QAEHXZ ENDP		; DXUTState::GetOverrideWidth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetOverrideWidth@DXUTState@@QAEXH@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetOverrideWidth@DXUTState@@QAEXH@Z PROC		; DXUTState::SetOverrideWidth, COMDAT
; _this$ = ecx

; 307  :     GET_SET_ACCESSOR( int, OverrideWidth );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+578], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetOverrid
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetOverrid:
	DD	1
	DD	$LN5@SetOverrid
$LN5@SetOverrid:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetOverrid
$LN4@SetOverrid:
	DB	108					; 0000006cH
	DB	0
?SetOverrideWidth@DXUTState@@QAEXH@Z ENDP		; DXUTState::SetOverrideWidth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetOverrideStartY@DXUTState@@QAEHXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetOverrideStartY@DXUTState@@QAEHXZ PROC		; DXUTState::GetOverrideStartY, COMDAT
; _this$ = ecx

; 306  :     GET_SET_ACCESSOR( int, OverrideStartY );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+574]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetOverrid
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetOverrid:
	DD	1
	DD	$LN5@GetOverrid
$LN5@GetOverrid:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetOverrid
$LN4@GetOverrid:
	DB	108					; 0000006cH
	DB	0
?GetOverrideStartY@DXUTState@@QAEHXZ ENDP		; DXUTState::GetOverrideStartY
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetOverrideStartY@DXUTState@@QAEXH@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetOverrideStartY@DXUTState@@QAEXH@Z PROC		; DXUTState::SetOverrideStartY, COMDAT
; _this$ = ecx

; 306  :     GET_SET_ACCESSOR( int, OverrideStartY );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+574], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetOverrid
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetOverrid:
	DD	1
	DD	$LN5@SetOverrid
$LN5@SetOverrid:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetOverrid
$LN4@SetOverrid:
	DB	108					; 0000006cH
	DB	0
?SetOverrideStartY@DXUTState@@QAEXH@Z ENDP		; DXUTState::SetOverrideStartY
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetOverrideStartX@DXUTState@@QAEHXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetOverrideStartX@DXUTState@@QAEHXZ PROC		; DXUTState::GetOverrideStartX, COMDAT
; _this$ = ecx

; 305  :     GET_SET_ACCESSOR( int, OverrideStartX );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+570]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetOverrid
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetOverrid:
	DD	1
	DD	$LN5@GetOverrid
$LN5@GetOverrid:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetOverrid
$LN4@GetOverrid:
	DB	108					; 0000006cH
	DB	0
?GetOverrideStartX@DXUTState@@QAEHXZ ENDP		; DXUTState::GetOverrideStartX
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetOverrideStartX@DXUTState@@QAEXH@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetOverrideStartX@DXUTState@@QAEXH@Z PROC		; DXUTState::SetOverrideStartX, COMDAT
; _this$ = ecx

; 305  :     GET_SET_ACCESSOR( int, OverrideStartX );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+570], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetOverrid
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetOverrid:
	DD	1
	DD	$LN5@SetOverrid
$LN5@SetOverrid:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetOverrid
$LN4@SetOverrid:
	DB	108					; 0000006cH
	DB	0
?SetOverrideStartX@DXUTState@@QAEXH@Z ENDP		; DXUTState::SetOverrideStartX
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetOverrideFullScreen@DXUTState@@QAE_NXZ
_TEXT	SEGMENT
$T1 = -221						; size = 1
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetOverrideFullScreen@DXUTState@@QAE_NXZ PROC		; DXUTState::GetOverrideFullScreen, COMDAT
; _this$ = ecx

; 304  :     GET_SET_ACCESSOR( bool, OverrideFullScreen );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+569]
	mov	BYTE PTR $T1[ebp], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	al, BYTE PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetOverrid
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetOverrid:
	DD	1
	DD	$LN5@GetOverrid
$LN5@GetOverrid:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetOverrid
$LN4@GetOverrid:
	DB	108					; 0000006cH
	DB	0
?GetOverrideFullScreen@DXUTState@@QAE_NXZ ENDP		; DXUTState::GetOverrideFullScreen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetOverrideFullScreen@DXUTState@@QAEX_N@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 1
?SetOverrideFullScreen@DXUTState@@QAEX_N@Z PROC		; DXUTState::SetOverrideFullScreen, COMDAT
; _this$ = ecx

; 304  :     GET_SET_ACCESSOR( bool, OverrideFullScreen );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+569], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetOverrid
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetOverrid:
	DD	1
	DD	$LN5@SetOverrid
$LN5@SetOverrid:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetOverrid
$LN4@SetOverrid:
	DB	108					; 0000006cH
	DB	0
?SetOverrideFullScreen@DXUTState@@QAEX_N@Z ENDP		; DXUTState::SetOverrideFullScreen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetOverrideWindowed@DXUTState@@QAE_NXZ
_TEXT	SEGMENT
$T1 = -221						; size = 1
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetOverrideWindowed@DXUTState@@QAE_NXZ PROC		; DXUTState::GetOverrideWindowed, COMDAT
; _this$ = ecx

; 303  :     GET_SET_ACCESSOR( bool, OverrideWindowed );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+568]
	mov	BYTE PTR $T1[ebp], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	al, BYTE PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetOverrid
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetOverrid:
	DD	1
	DD	$LN5@GetOverrid
$LN5@GetOverrid:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetOverrid
$LN4@GetOverrid:
	DB	108					; 0000006cH
	DB	0
?GetOverrideWindowed@DXUTState@@QAE_NXZ ENDP		; DXUTState::GetOverrideWindowed
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetOverrideWindowed@DXUTState@@QAEX_N@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 1
?SetOverrideWindowed@DXUTState@@QAEX_N@Z PROC		; DXUTState::SetOverrideWindowed, COMDAT
; _this$ = ecx

; 303  :     GET_SET_ACCESSOR( bool, OverrideWindowed );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+568], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetOverrid
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetOverrid:
	DD	1
	DD	$LN5@SetOverrid
$LN5@SetOverrid:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetOverrid
$LN4@SetOverrid:
	DB	108					; 0000006cH
	DB	0
?SetOverrideWindowed@DXUTState@@QAEX_N@Z ENDP		; DXUTState::SetOverrideWindowed
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetOverrideAdapterOrdinal@DXUTState@@QAEHXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetOverrideAdapterOrdinal@DXUTState@@QAEHXZ PROC	; DXUTState::GetOverrideAdapterOrdinal, COMDAT
; _this$ = ecx

; 302  :     GET_SET_ACCESSOR( int, OverrideAdapterOrdinal );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+564]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetOverrid
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetOverrid:
	DD	1
	DD	$LN5@GetOverrid
$LN5@GetOverrid:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetOverrid
$LN4@GetOverrid:
	DB	108					; 0000006cH
	DB	0
?GetOverrideAdapterOrdinal@DXUTState@@QAEHXZ ENDP	; DXUTState::GetOverrideAdapterOrdinal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetOverrideAdapterOrdinal@DXUTState@@QAEXH@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetOverrideAdapterOrdinal@DXUTState@@QAEXH@Z PROC	; DXUTState::SetOverrideAdapterOrdinal, COMDAT
; _this$ = ecx

; 302  :     GET_SET_ACCESSOR( int, OverrideAdapterOrdinal );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+564], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetOverrid
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetOverrid:
	DD	1
	DD	$LN5@SetOverrid
$LN5@SetOverrid:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetOverrid
$LN4@SetOverrid:
	DB	108					; 0000006cH
	DB	0
?SetOverrideAdapterOrdinal@DXUTState@@QAEXH@Z ENDP	; DXUTState::SetOverrideAdapterOrdinal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetInSizeMove@DXUTState@@QAE_NXZ
_TEXT	SEGMENT
$T1 = -221						; size = 1
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetInSizeMove@DXUTState@@QAE_NXZ PROC			; DXUTState::GetInSizeMove, COMDAT
; _this$ = ecx

; 300  :     GET_SET_ACCESSOR( bool, InSizeMove );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+563]
	mov	BYTE PTR $T1[ebp], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	al, BYTE PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetInSizeM
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetInSizeM:
	DD	1
	DD	$LN5@GetInSizeM
$LN5@GetInSizeM:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetInSizeM
$LN4@GetInSizeM:
	DB	108					; 0000006cH
	DB	0
?GetInSizeMove@DXUTState@@QAE_NXZ ENDP			; DXUTState::GetInSizeMove
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetInSizeMove@DXUTState@@QAEX_N@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 1
?SetInSizeMove@DXUTState@@QAEX_N@Z PROC			; DXUTState::SetInSizeMove, COMDAT
; _this$ = ecx

; 300  :     GET_SET_ACCESSOR( bool, InSizeMove );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+563], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetInSizeM
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetInSizeM:
	DD	1
	DD	$LN5@SetInSizeM
$LN5@SetInSizeM:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetInSizeM
$LN4@SetInSizeM:
	DB	108					; 0000006cH
	DB	0
?SetInSizeMove@DXUTState@@QAEX_N@Z ENDP			; DXUTState::SetInSizeMove
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetAutomation@DXUTState@@QAE_NXZ
_TEXT	SEGMENT
$T1 = -221						; size = 1
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetAutomation@DXUTState@@QAE_NXZ PROC			; DXUTState::GetAutomation, COMDAT
; _this$ = ecx

; 299  :     GET_SET_ACCESSOR( bool, Automation );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+562]
	mov	BYTE PTR $T1[ebp], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	al, BYTE PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetAutomat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetAutomat:
	DD	1
	DD	$LN5@GetAutomat
$LN5@GetAutomat:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetAutomat
$LN4@GetAutomat:
	DB	108					; 0000006cH
	DB	0
?GetAutomation@DXUTState@@QAE_NXZ ENDP			; DXUTState::GetAutomation
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetAutomation@DXUTState@@QAEX_N@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 1
?SetAutomation@DXUTState@@QAEX_N@Z PROC			; DXUTState::SetAutomation, COMDAT
; _this$ = ecx

; 299  :     GET_SET_ACCESSOR( bool, Automation );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+562], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetAutomat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetAutomat:
	DD	1
	DD	$LN5@SetAutomat
$LN5@SetAutomat:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetAutomat
$LN4@SetAutomat:
	DB	108					; 0000006cH
	DB	0
?SetAutomation@DXUTState@@QAEX_N@Z ENDP			; DXUTState::SetAutomation
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetNotifyOnMouseMove@DXUTState@@QAE_NXZ
_TEXT	SEGMENT
$T1 = -221						; size = 1
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetNotifyOnMouseMove@DXUTState@@QAE_NXZ PROC		; DXUTState::GetNotifyOnMouseMove, COMDAT
; _this$ = ecx

; 298  :     GET_SET_ACCESSOR( bool, NotifyOnMouseMove );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+561]
	mov	BYTE PTR $T1[ebp], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	al, BYTE PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetNotifyO
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetNotifyO:
	DD	1
	DD	$LN5@GetNotifyO
$LN5@GetNotifyO:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetNotifyO
$LN4@GetNotifyO:
	DB	108					; 0000006cH
	DB	0
?GetNotifyOnMouseMove@DXUTState@@QAE_NXZ ENDP		; DXUTState::GetNotifyOnMouseMove
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetNotifyOnMouseMove@DXUTState@@QAEX_N@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 1
?SetNotifyOnMouseMove@DXUTState@@QAEX_N@Z PROC		; DXUTState::SetNotifyOnMouseMove, COMDAT
; _this$ = ecx

; 298  :     GET_SET_ACCESSOR( bool, NotifyOnMouseMove );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+561], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetNotifyO
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetNotifyO:
	DD	1
	DD	$LN5@SetNotifyO
$LN5@SetNotifyO:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetNotifyO
$LN4@SetNotifyO:
	DB	108					; 0000006cH
	DB	0
?SetNotifyOnMouseMove@DXUTState@@QAEX_N@Z ENDP		; DXUTState::SetNotifyOnMouseMove
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetDeviceLost@DXUTState@@QAE_NXZ
_TEXT	SEGMENT
$T1 = -221						; size = 1
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetDeviceLost@DXUTState@@QAE_NXZ PROC			; DXUTState::GetDeviceLost, COMDAT
; _this$ = ecx

; 297  :     GET_SET_ACCESSOR( bool, DeviceLost );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+560]
	mov	BYTE PTR $T1[ebp], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	al, BYTE PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetDeviceL
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetDeviceL:
	DD	1
	DD	$LN5@GetDeviceL
$LN5@GetDeviceL:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetDeviceL
$LN4@GetDeviceL:
	DB	108					; 0000006cH
	DB	0
?GetDeviceLost@DXUTState@@QAE_NXZ ENDP			; DXUTState::GetDeviceLost
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetDeviceLost@DXUTState@@QAEX_N@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 1
?SetDeviceLost@DXUTState@@QAEX_N@Z PROC			; DXUTState::SetDeviceLost, COMDAT
; _this$ = ecx

; 297  :     GET_SET_ACCESSOR( bool, DeviceLost );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+560], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetDeviceL
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetDeviceL:
	DD	1
	DD	$LN5@SetDeviceL
$LN5@SetDeviceL:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetDeviceL
$LN4@SetDeviceL:
	DB	108					; 0000006cH
	DB	0
?SetDeviceLost@DXUTState@@QAEX_N@Z ENDP			; DXUTState::SetDeviceLost
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetPauseTimeCount@DXUTState@@QAEHXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetPauseTimeCount@DXUTState@@QAEHXZ PROC		; DXUTState::GetPauseTimeCount, COMDAT
; _this$ = ecx

; 296  :     GET_SET_ACCESSOR( int, PauseTimeCount );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+556]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetPauseTi
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetPauseTi:
	DD	1
	DD	$LN5@GetPauseTi
$LN5@GetPauseTi:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetPauseTi
$LN4@GetPauseTi:
	DB	108					; 0000006cH
	DB	0
?GetPauseTimeCount@DXUTState@@QAEHXZ ENDP		; DXUTState::GetPauseTimeCount
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetPauseTimeCount@DXUTState@@QAEXH@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetPauseTimeCount@DXUTState@@QAEXH@Z PROC		; DXUTState::SetPauseTimeCount, COMDAT
; _this$ = ecx

; 296  :     GET_SET_ACCESSOR( int, PauseTimeCount );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+556], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetPauseTi
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetPauseTi:
	DD	1
	DD	$LN5@SetPauseTi
$LN5@SetPauseTi:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetPauseTi
$LN4@SetPauseTi:
	DB	108					; 0000006cH
	DB	0
?SetPauseTimeCount@DXUTState@@QAEXH@Z ENDP		; DXUTState::SetPauseTimeCount
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetPauseRenderingCount@DXUTState@@QAEHXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetPauseRenderingCount@DXUTState@@QAEHXZ PROC		; DXUTState::GetPauseRenderingCount, COMDAT
; _this$ = ecx

; 295  :     GET_SET_ACCESSOR( int, PauseRenderingCount );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+552]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetPauseRe
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetPauseRe:
	DD	1
	DD	$LN5@GetPauseRe
$LN5@GetPauseRe:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetPauseRe
$LN4@GetPauseRe:
	DB	108					; 0000006cH
	DB	0
?GetPauseRenderingCount@DXUTState@@QAEHXZ ENDP		; DXUTState::GetPauseRenderingCount
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetPauseRenderingCount@DXUTState@@QAEXH@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetPauseRenderingCount@DXUTState@@QAEXH@Z PROC		; DXUTState::SetPauseRenderingCount, COMDAT
; _this$ = ecx

; 295  :     GET_SET_ACCESSOR( int, PauseRenderingCount );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+552], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetPauseRe
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetPauseRe:
	DD	1
	DD	$LN5@SetPauseRe
$LN5@SetPauseRe:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetPauseRe
$LN4@SetPauseRe:
	DB	108					; 0000006cH
	DB	0
?SetPauseRenderingCount@DXUTState@@QAEXH@Z ENDP		; DXUTState::SetPauseRenderingCount
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetTimePaused@DXUTState@@QAEX_N@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 1
?SetTimePaused@DXUTState@@QAEX_N@Z PROC			; DXUTState::SetTimePaused, COMDAT
; _this$ = ecx

; 294  :     GET_SET_ACCESSOR( bool, TimePaused );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+550], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetTimePau
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetTimePau:
	DD	1
	DD	$LN5@SetTimePau
$LN5@SetTimePau:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetTimePau
$LN4@SetTimePau:
	DB	108					; 0000006cH
	DB	0
?SetTimePaused@DXUTState@@QAEX_N@Z ENDP			; DXUTState::SetTimePaused
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetRenderingPaused@DXUTState@@QAE_NXZ
_TEXT	SEGMENT
$T1 = -221						; size = 1
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetRenderingPaused@DXUTState@@QAE_NXZ PROC		; DXUTState::GetRenderingPaused, COMDAT
; _this$ = ecx

; 293  :     GET_SET_ACCESSOR( bool, RenderingPaused );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+551]
	mov	BYTE PTR $T1[ebp], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	al, BYTE PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetRenderi
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetRenderi:
	DD	1
	DD	$LN5@GetRenderi
$LN5@GetRenderi:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetRenderi
$LN4@GetRenderi:
	DB	108					; 0000006cH
	DB	0
?GetRenderingPaused@DXUTState@@QAE_NXZ ENDP		; DXUTState::GetRenderingPaused
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetRenderingPaused@DXUTState@@QAEX_N@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 1
?SetRenderingPaused@DXUTState@@QAEX_N@Z PROC		; DXUTState::SetRenderingPaused, COMDAT
; _this$ = ecx

; 293  :     GET_SET_ACCESSOR( bool, RenderingPaused );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+551], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetRenderi
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetRenderi:
	DD	1
	DD	$LN5@SetRenderi
$LN5@SetRenderi:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetRenderi
$LN4@SetRenderi:
	DB	108					; 0000006cH
	DB	0
?SetRenderingPaused@DXUTState@@QAEX_N@Z ENDP		; DXUTState::SetRenderingPaused
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetActive@DXUTState@@QAE_NXZ
_TEXT	SEGMENT
$T1 = -221						; size = 1
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetActive@DXUTState@@QAE_NXZ PROC			; DXUTState::GetActive, COMDAT
; _this$ = ecx

; 292  :     GET_SET_ACCESSOR( bool, Active );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+549]
	mov	BYTE PTR $T1[ebp], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	al, BYTE PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetActive
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetActive:
	DD	1
	DD	$LN5@GetActive
$LN5@GetActive:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetActive
$LN4@GetActive:
	DB	108					; 0000006cH
	DB	0
?GetActive@DXUTState@@QAE_NXZ ENDP			; DXUTState::GetActive
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetActive@DXUTState@@QAEX_N@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 1
?SetActive@DXUTState@@QAEX_N@Z PROC			; DXUTState::SetActive, COMDAT
; _this$ = ecx

; 292  :     GET_SET_ACCESSOR( bool, Active );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+549], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetActive
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetActive:
	DD	1
	DD	$LN5@SetActive
$LN5@SetActive:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetActive
$LN4@SetActive:
	DB	108					; 0000006cH
	DB	0
?SetActive@DXUTState@@QAEX_N@Z ENDP			; DXUTState::SetActive
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetDeviceObjectsReset@DXUTState@@QAE_NXZ
_TEXT	SEGMENT
$T1 = -221						; size = 1
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetDeviceObjectsReset@DXUTState@@QAE_NXZ PROC		; DXUTState::GetDeviceObjectsReset, COMDAT
; _this$ = ecx

; 291  :     GET_SET_ACCESSOR( bool, DeviceObjectsReset );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+546]
	mov	BYTE PTR $T1[ebp], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	al, BYTE PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetDeviceO
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetDeviceO:
	DD	1
	DD	$LN5@GetDeviceO
$LN5@GetDeviceO:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetDeviceO
$LN4@GetDeviceO:
	DB	108					; 0000006cH
	DB	0
?GetDeviceObjectsReset@DXUTState@@QAE_NXZ ENDP		; DXUTState::GetDeviceObjectsReset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetDeviceObjectsReset@DXUTState@@QAEX_N@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 1
?SetDeviceObjectsReset@DXUTState@@QAEX_N@Z PROC		; DXUTState::SetDeviceObjectsReset, COMDAT
; _this$ = ecx

; 291  :     GET_SET_ACCESSOR( bool, DeviceObjectsReset );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+546], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetDeviceO
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetDeviceO:
	DD	1
	DD	$LN5@SetDeviceO
$LN5@SetDeviceO:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetDeviceO
$LN4@SetDeviceO:
	DB	108					; 0000006cH
	DB	0
?SetDeviceObjectsReset@DXUTState@@QAEX_N@Z ENDP		; DXUTState::SetDeviceObjectsReset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetDeviceObjectsCreated@DXUTState@@QAE_NXZ
_TEXT	SEGMENT
$T1 = -221						; size = 1
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetDeviceObjectsCreated@DXUTState@@QAE_NXZ PROC	; DXUTState::GetDeviceObjectsCreated, COMDAT
; _this$ = ecx

; 290  :     GET_SET_ACCESSOR( bool, DeviceObjectsCreated );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+545]
	mov	BYTE PTR $T1[ebp], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	al, BYTE PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetDeviceO
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetDeviceO:
	DD	1
	DD	$LN5@GetDeviceO
$LN5@GetDeviceO:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetDeviceO
$LN4@GetDeviceO:
	DB	108					; 0000006cH
	DB	0
?GetDeviceObjectsCreated@DXUTState@@QAE_NXZ ENDP	; DXUTState::GetDeviceObjectsCreated
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetDeviceObjectsCreated@DXUTState@@QAEX_N@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 1
?SetDeviceObjectsCreated@DXUTState@@QAEX_N@Z PROC	; DXUTState::SetDeviceObjectsCreated, COMDAT
; _this$ = ecx

; 290  :     GET_SET_ACCESSOR( bool, DeviceObjectsCreated );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+545], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetDeviceO
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetDeviceO:
	DD	1
	DD	$LN5@SetDeviceO
$LN5@SetDeviceO:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetDeviceO
$LN4@SetDeviceO:
	DB	108					; 0000006cH
	DB	0
?SetDeviceObjectsCreated@DXUTState@@QAEX_N@Z ENDP	; DXUTState::SetDeviceObjectsCreated
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetInsideMainloop@DXUTState@@QAE_NXZ
_TEXT	SEGMENT
$T1 = -221						; size = 1
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetInsideMainloop@DXUTState@@QAE_NXZ PROC		; DXUTState::GetInsideMainloop, COMDAT
; _this$ = ecx

; 289  :     GET_SET_ACCESSOR( bool, InsideMainloop );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+548]
	mov	BYTE PTR $T1[ebp], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	al, BYTE PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetInsideM
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetInsideM:
	DD	1
	DD	$LN5@GetInsideM
$LN5@GetInsideM:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetInsideM
$LN4@GetInsideM:
	DB	108					; 0000006cH
	DB	0
?GetInsideMainloop@DXUTState@@QAE_NXZ ENDP		; DXUTState::GetInsideMainloop
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetInsideMainloop@DXUTState@@QAEX_N@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 1
?SetInsideMainloop@DXUTState@@QAEX_N@Z PROC		; DXUTState::SetInsideMainloop, COMDAT
; _this$ = ecx

; 289  :     GET_SET_ACCESSOR( bool, InsideMainloop );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+548], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetInsideM
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetInsideM:
	DD	1
	DD	$LN5@SetInsideM
$LN5@SetInsideM:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetInsideM
$LN4@SetInsideM:
	DB	108					; 0000006cH
	DB	0
?SetInsideMainloop@DXUTState@@QAEX_N@Z ENDP		; DXUTState::SetInsideMainloop
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetInsideDeviceCallback@DXUTState@@QAE_NXZ
_TEXT	SEGMENT
$T1 = -221						; size = 1
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetInsideDeviceCallback@DXUTState@@QAE_NXZ PROC	; DXUTState::GetInsideDeviceCallback, COMDAT
; _this$ = ecx

; 288  :     GET_SET_ACCESSOR( bool, InsideDeviceCallback );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+547]
	mov	BYTE PTR $T1[ebp], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	al, BYTE PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetInsideD
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetInsideD:
	DD	1
	DD	$LN5@GetInsideD
$LN5@GetInsideD:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetInsideD
$LN4@GetInsideD:
	DB	108					; 0000006cH
	DB	0
?GetInsideDeviceCallback@DXUTState@@QAE_NXZ ENDP	; DXUTState::GetInsideDeviceCallback
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetInsideDeviceCallback@DXUTState@@QAEX_N@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 1
?SetInsideDeviceCallback@DXUTState@@QAEX_N@Z PROC	; DXUTState::SetInsideDeviceCallback, COMDAT
; _this$ = ecx

; 288  :     GET_SET_ACCESSOR( bool, InsideDeviceCallback );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+547], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetInsideD
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetInsideD:
	DD	1
	DD	$LN5@SetInsideD
$LN5@SetInsideD:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetInsideD
$LN4@SetInsideD:
	DB	108					; 0000006cH
	DB	0
?SetInsideDeviceCallback@DXUTState@@QAEX_N@Z ENDP	; DXUTState::SetInsideDeviceCallback
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetDeviceCreateCalled@DXUTState@@QAE_NXZ
_TEXT	SEGMENT
$T1 = -221						; size = 1
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetDeviceCreateCalled@DXUTState@@QAE_NXZ PROC		; DXUTState::GetDeviceCreateCalled, COMDAT
; _this$ = ecx

; 287  :     GET_SET_ACCESSOR( bool, DeviceCreateCalled );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+544]
	mov	BYTE PTR $T1[ebp], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	al, BYTE PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetDeviceC
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetDeviceC:
	DD	1
	DD	$LN5@GetDeviceC
$LN5@GetDeviceC:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetDeviceC
$LN4@GetDeviceC:
	DB	108					; 0000006cH
	DB	0
?GetDeviceCreateCalled@DXUTState@@QAE_NXZ ENDP		; DXUTState::GetDeviceCreateCalled
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetDeviceCreateCalled@DXUTState@@QAEX_N@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 1
?SetDeviceCreateCalled@DXUTState@@QAEX_N@Z PROC		; DXUTState::SetDeviceCreateCalled, COMDAT
; _this$ = ecx

; 287  :     GET_SET_ACCESSOR( bool, DeviceCreateCalled );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+544], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetDeviceC
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetDeviceC:
	DD	1
	DD	$LN5@SetDeviceC
$LN5@SetDeviceC:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetDeviceC
$LN4@SetDeviceC:
	DB	108					; 0000006cH
	DB	0
?SetDeviceCreateCalled@DXUTState@@QAEX_N@Z ENDP		; DXUTState::SetDeviceCreateCalled
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetWindowCreateCalled@DXUTState@@QAE_NXZ
_TEXT	SEGMENT
$T1 = -221						; size = 1
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetWindowCreateCalled@DXUTState@@QAE_NXZ PROC		; DXUTState::GetWindowCreateCalled, COMDAT
; _this$ = ecx

; 286  :     GET_SET_ACCESSOR( bool, WindowCreateCalled );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+543]
	mov	BYTE PTR $T1[ebp], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	al, BYTE PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetWindowC
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetWindowC:
	DD	1
	DD	$LN5@GetWindowC
$LN5@GetWindowC:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetWindowC
$LN4@GetWindowC:
	DB	108					; 0000006cH
	DB	0
?GetWindowCreateCalled@DXUTState@@QAE_NXZ ENDP		; DXUTState::GetWindowCreateCalled
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetWindowCreateCalled@DXUTState@@QAEX_N@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 1
?SetWindowCreateCalled@DXUTState@@QAEX_N@Z PROC		; DXUTState::SetWindowCreateCalled, COMDAT
; _this$ = ecx

; 286  :     GET_SET_ACCESSOR( bool, WindowCreateCalled );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+543], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetWindowC
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetWindowC:
	DD	1
	DD	$LN5@SetWindowC
$LN5@SetWindowC:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetWindowC
$LN4@SetWindowC:
	DB	108					; 0000006cH
	DB	0
?SetWindowCreateCalled@DXUTState@@QAEX_N@Z ENDP		; DXUTState::SetWindowCreateCalled
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetDXUTInitCalled@DXUTState@@QAE_NXZ
_TEXT	SEGMENT
$T1 = -221						; size = 1
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetDXUTInitCalled@DXUTState@@QAE_NXZ PROC		; DXUTState::GetDXUTInitCalled, COMDAT
; _this$ = ecx

; 285  :     GET_SET_ACCESSOR( bool, DXUTInitCalled );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+542]
	mov	BYTE PTR $T1[ebp], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	al, BYTE PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetDXUTIni
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetDXUTIni:
	DD	1
	DD	$LN5@GetDXUTIni
$LN5@GetDXUTIni:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetDXUTIni
$LN4@GetDXUTIni:
	DB	108					; 0000006cH
	DB	0
?GetDXUTInitCalled@DXUTState@@QAE_NXZ ENDP		; DXUTState::GetDXUTInitCalled
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetDXUTInitCalled@DXUTState@@QAEX_N@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 1
?SetDXUTInitCalled@DXUTState@@QAEX_N@Z PROC		; DXUTState::SetDXUTInitCalled, COMDAT
; _this$ = ecx

; 285  :     GET_SET_ACCESSOR( bool, DXUTInitCalled );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+542], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetDXUTIni
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetDXUTIni:
	DD	1
	DD	$LN5@SetDXUTIni
$LN5@SetDXUTIni:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetDXUTIni
$LN4@SetDXUTIni:
	DB	108					; 0000006cH
	DB	0
?SetDXUTInitCalled@DXUTState@@QAEX_N@Z ENDP		; DXUTState::SetDXUTInitCalled
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetDeviceCreated@DXUTState@@QAE_NXZ
_TEXT	SEGMENT
$T1 = -221						; size = 1
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetDeviceCreated@DXUTState@@QAE_NXZ PROC		; DXUTState::GetDeviceCreated, COMDAT
; _this$ = ecx

; 284  :     GET_SET_ACCESSOR( bool, DeviceCreated );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+541]
	mov	BYTE PTR $T1[ebp], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	al, BYTE PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetDeviceC
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetDeviceC:
	DD	1
	DD	$LN5@GetDeviceC
$LN5@GetDeviceC:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetDeviceC
$LN4@GetDeviceC:
	DB	108					; 0000006cH
	DB	0
?GetDeviceCreated@DXUTState@@QAE_NXZ ENDP		; DXUTState::GetDeviceCreated
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetDeviceCreated@DXUTState@@QAEX_N@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 1
?SetDeviceCreated@DXUTState@@QAEX_N@Z PROC		; DXUTState::SetDeviceCreated, COMDAT
; _this$ = ecx

; 284  :     GET_SET_ACCESSOR( bool, DeviceCreated );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+541], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetDeviceC
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetDeviceC:
	DD	1
	DD	$LN5@SetDeviceC
$LN5@SetDeviceC:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetDeviceC
$LN4@SetDeviceC:
	DB	108					; 0000006cH
	DB	0
?SetDeviceCreated@DXUTState@@QAEX_N@Z ENDP		; DXUTState::SetDeviceCreated
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetWindowCreated@DXUTState@@QAE_NXZ
_TEXT	SEGMENT
$T1 = -221						; size = 1
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetWindowCreated@DXUTState@@QAE_NXZ PROC		; DXUTState::GetWindowCreated, COMDAT
; _this$ = ecx

; 283  :     GET_SET_ACCESSOR( bool, WindowCreated );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+540]
	mov	BYTE PTR $T1[ebp], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	al, BYTE PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetWindowC
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetWindowC:
	DD	1
	DD	$LN5@GetWindowC
$LN5@GetWindowC:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetWindowC
$LN4@GetWindowC:
	DB	108					; 0000006cH
	DB	0
?GetWindowCreated@DXUTState@@QAE_NXZ ENDP		; DXUTState::GetWindowCreated
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetWindowCreated@DXUTState@@QAEX_N@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 1
?SetWindowCreated@DXUTState@@QAEX_N@Z PROC		; DXUTState::SetWindowCreated, COMDAT
; _this$ = ecx

; 283  :     GET_SET_ACCESSOR( bool, WindowCreated );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+540], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetWindowC
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetWindowC:
	DD	1
	DD	$LN5@SetWindowC
$LN5@SetWindowC:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetWindowC
$LN4@SetWindowC:
	DB	108					; 0000006cH
	DB	0
?SetWindowCreated@DXUTState@@QAEX_N@Z ENDP		; DXUTState::SetWindowCreated
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetDXUTInited@DXUTState@@QAE_NXZ
_TEXT	SEGMENT
$T1 = -221						; size = 1
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetDXUTInited@DXUTState@@QAE_NXZ PROC			; DXUTState::GetDXUTInited, COMDAT
; _this$ = ecx

; 282  :     GET_SET_ACCESSOR( bool, DXUTInited );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+539]
	mov	BYTE PTR $T1[ebp], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	al, BYTE PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetDXUTIni
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetDXUTIni:
	DD	1
	DD	$LN5@GetDXUTIni
$LN5@GetDXUTIni:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetDXUTIni
$LN4@GetDXUTIni:
	DB	108					; 0000006cH
	DB	0
?GetDXUTInited@DXUTState@@QAE_NXZ ENDP			; DXUTState::GetDXUTInited
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetDXUTInited@DXUTState@@QAEX_N@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 1
?SetDXUTInited@DXUTState@@QAEX_N@Z PROC			; DXUTState::SetDXUTInited, COMDAT
; _this$ = ecx

; 282  :     GET_SET_ACCESSOR( bool, DXUTInited );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+539], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetDXUTIni
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetDXUTIni:
	DD	1
	DD	$LN5@SetDXUTIni
$LN5@SetDXUTIni:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetDXUTIni
$LN4@SetDXUTIni:
	DB	108					; 0000006cH
	DB	0
?SetDXUTInited@DXUTState@@QAEX_N@Z ENDP			; DXUTState::SetDXUTInited
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetExitCode@DXUTState@@QAEHXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetExitCode@DXUTState@@QAEHXZ PROC			; DXUTState::GetExitCode, COMDAT
; _this$ = ecx

; 280  :     GET_SET_ACCESSOR( int, ExitCode );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+535]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetExitCod
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetExitCod:
	DD	1
	DD	$LN5@GetExitCod
$LN5@GetExitCod:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetExitCod
$LN4@GetExitCod:
	DB	108					; 0000006cH
	DB	0
?GetExitCode@DXUTState@@QAEHXZ ENDP			; DXUTState::GetExitCode
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetExitCode@DXUTState@@QAEXH@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetExitCode@DXUTState@@QAEXH@Z PROC			; DXUTState::SetExitCode, COMDAT
; _this$ = ecx

; 280  :     GET_SET_ACCESSOR( int, ExitCode );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+535], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetExitCod
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetExitCod:
	DD	1
	DD	$LN5@SetExitCod
$LN5@SetExitCod:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetExitCod
$LN4@SetExitCod:
	DB	108					; 0000006cH
	DB	0
?SetExitCode@DXUTState@@QAEXH@Z ENDP			; DXUTState::SetExitCode
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetWindowCreatedWithDefaultPositions@DXUTState@@QAEX_N@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 1
?SetWindowCreatedWithDefaultPositions@DXUTState@@QAEX_N@Z PROC ; DXUTState::SetWindowCreatedWithDefaultPositions, COMDAT
; _this$ = ecx

; 279  :     GET_SET_ACCESSOR( bool, WindowCreatedWithDefaultPositions );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+534], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetWindowC
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetWindowC:
	DD	1
	DD	$LN5@SetWindowC
$LN5@SetWindowC:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetWindowC
$LN4@SetWindowC:
	DB	108					; 0000006cH
	DB	0
?SetWindowCreatedWithDefaultPositions@DXUTState@@QAEX_N@Z ENDP ; DXUTState::SetWindowCreatedWithDefaultPositions
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetAutoChangeAdapter@DXUTState@@QAE_NXZ
_TEXT	SEGMENT
$T1 = -221						; size = 1
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetAutoChangeAdapter@DXUTState@@QAE_NXZ PROC		; DXUTState::GetAutoChangeAdapter, COMDAT
; _this$ = ecx

; 278  :     GET_SET_ACCESSOR( bool, AutoChangeAdapter );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+533]
	mov	BYTE PTR $T1[ebp], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	al, BYTE PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetAutoCha
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetAutoCha:
	DD	1
	DD	$LN5@GetAutoCha
$LN5@GetAutoCha:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetAutoCha
$LN4@GetAutoCha:
	DB	108					; 0000006cH
	DB	0
?GetAutoChangeAdapter@DXUTState@@QAE_NXZ ENDP		; DXUTState::GetAutoChangeAdapter
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetAutoChangeAdapter@DXUTState@@QAEX_N@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 1
?SetAutoChangeAdapter@DXUTState@@QAEX_N@Z PROC		; DXUTState::SetAutoChangeAdapter, COMDAT
; _this$ = ecx

; 278  :     GET_SET_ACCESSOR( bool, AutoChangeAdapter );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+533], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetAutoCha
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetAutoCha:
	DD	1
	DD	$LN5@SetAutoCha
$LN5@SetAutoCha:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetAutoCha
$LN4@SetAutoCha:
	DB	108					; 0000006cH
	DB	0
?SetAutoChangeAdapter@DXUTState@@QAEX_N@Z ENDP		; DXUTState::SetAutoChangeAdapter
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetWireframeMode@DXUTState@@QAE_NXZ
_TEXT	SEGMENT
$T1 = -221						; size = 1
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetWireframeMode@DXUTState@@QAE_NXZ PROC		; DXUTState::GetWireframeMode, COMDAT
; _this$ = ecx

; 277  :     GET_SET_ACCESSOR( bool, WireframeMode );   

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+532]
	mov	BYTE PTR $T1[ebp], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	al, BYTE PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetWirefra
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetWirefra:
	DD	1
	DD	$LN5@GetWirefra
$LN5@GetWirefra:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetWirefra
$LN4@GetWirefra:
	DB	108					; 0000006cH
	DB	0
?GetWireframeMode@DXUTState@@QAE_NXZ ENDP		; DXUTState::GetWireframeMode
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetWireframeMode@DXUTState@@QAEX_N@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 1
?SetWireframeMode@DXUTState@@QAEX_N@Z PROC		; DXUTState::SetWireframeMode, COMDAT
; _this$ = ecx

; 277  :     GET_SET_ACCESSOR( bool, WireframeMode );   

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+532], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetWirefra
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetWirefra:
	DD	1
	DD	$LN5@SetWirefra
$LN5@SetWirefra:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetWirefra
$LN4@SetWirefra:
	DB	108					; 0000006cH
	DB	0
?SetWireframeMode@DXUTState@@QAEX_N@Z ENDP		; DXUTState::SetWireframeMode
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetTimePerFrame@DXUTState@@QAEMXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetTimePerFrame@DXUTState@@QAEMXZ PROC			; DXUTState::GetTimePerFrame, COMDAT
; _this$ = ecx

; 276  :     GET_SET_ACCESSOR( float, TimePerFrame );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+528]
	movss	DWORD PTR $T1[ebp], xmm0
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	fld	DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetTimePer
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetTimePer:
	DD	1
	DD	$LN5@GetTimePer
$LN5@GetTimePer:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetTimePer
$LN4@GetTimePer:
	DB	108					; 0000006cH
	DB	0
?GetTimePerFrame@DXUTState@@QAEMXZ ENDP			; DXUTState::GetTimePerFrame
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetTimePerFrame@DXUTState@@QAEXM@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetTimePerFrame@DXUTState@@QAEXM@Z PROC		; DXUTState::SetTimePerFrame, COMDAT
; _this$ = ecx

; 276  :     GET_SET_ACCESSOR( float, TimePerFrame );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _t$[ebp]
	movss	DWORD PTR [eax+528], xmm0
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetTimePer
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetTimePer:
	DD	1
	DD	$LN5@SetTimePer
$LN5@SetTimePer:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetTimePer
$LN4@SetTimePer:
	DB	108					; 0000006cH
	DB	0
?SetTimePerFrame@DXUTState@@QAEXM@Z ENDP		; DXUTState::SetTimePerFrame
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetConstantFrameTime@DXUTState@@QAE_NXZ
_TEXT	SEGMENT
$T1 = -221						; size = 1
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetConstantFrameTime@DXUTState@@QAE_NXZ PROC		; DXUTState::GetConstantFrameTime, COMDAT
; _this$ = ecx

; 275  :     GET_SET_ACCESSOR( bool, ConstantFrameTime );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+527]
	mov	BYTE PTR $T1[ebp], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	al, BYTE PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetConstan
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetConstan:
	DD	1
	DD	$LN5@GetConstan
$LN5@GetConstan:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetConstan
$LN4@GetConstan:
	DB	108					; 0000006cH
	DB	0
?GetConstantFrameTime@DXUTState@@QAE_NXZ ENDP		; DXUTState::GetConstantFrameTime
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetConstantFrameTime@DXUTState@@QAEX_N@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 1
?SetConstantFrameTime@DXUTState@@QAEX_N@Z PROC		; DXUTState::SetConstantFrameTime, COMDAT
; _this$ = ecx

; 275  :     GET_SET_ACCESSOR( bool, ConstantFrameTime );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+527], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetConstan
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetConstan:
	DD	1
	DD	$LN5@SetConstan
$LN5@SetConstan:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetConstan
$LN4@SetConstan:
	DB	108					; 0000006cH
	DB	0
?SetConstantFrameTime@DXUTState@@QAEX_N@Z ENDP		; DXUTState::SetConstantFrameTime
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetShowCursorWhenFullScreen@DXUTState@@QAE_NXZ
_TEXT	SEGMENT
$T1 = -221						; size = 1
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetShowCursorWhenFullScreen@DXUTState@@QAE_NXZ PROC	; DXUTState::GetShowCursorWhenFullScreen, COMDAT
; _this$ = ecx

; 274  :     GET_SET_ACCESSOR( bool, ShowCursorWhenFullScreen );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+526]
	mov	BYTE PTR $T1[ebp], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	al, BYTE PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetShowCur
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetShowCur:
	DD	1
	DD	$LN5@GetShowCur
$LN5@GetShowCur:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetShowCur
$LN4@GetShowCur:
	DB	108					; 0000006cH
	DB	0
?GetShowCursorWhenFullScreen@DXUTState@@QAE_NXZ ENDP	; DXUTState::GetShowCursorWhenFullScreen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetShowCursorWhenFullScreen@DXUTState@@QAEX_N@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 1
?SetShowCursorWhenFullScreen@DXUTState@@QAEX_N@Z PROC	; DXUTState::SetShowCursorWhenFullScreen, COMDAT
; _this$ = ecx

; 274  :     GET_SET_ACCESSOR( bool, ShowCursorWhenFullScreen );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+526], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetShowCur
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetShowCur:
	DD	1
	DD	$LN5@SetShowCur
$LN5@SetShowCur:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetShowCur
$LN4@SetShowCur:
	DB	108					; 0000006cH
	DB	0
?SetShowCursorWhenFullScreen@DXUTState@@QAEX_N@Z ENDP	; DXUTState::SetShowCursorWhenFullScreen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetClipCursorWhenFullScreen@DXUTState@@QAE_NXZ
_TEXT	SEGMENT
$T1 = -221						; size = 1
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetClipCursorWhenFullScreen@DXUTState@@QAE_NXZ PROC	; DXUTState::GetClipCursorWhenFullScreen, COMDAT
; _this$ = ecx

; 273  :     GET_SET_ACCESSOR( bool, ClipCursorWhenFullScreen );   

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+525]
	mov	BYTE PTR $T1[ebp], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	al, BYTE PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetClipCur
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetClipCur:
	DD	1
	DD	$LN5@GetClipCur
$LN5@GetClipCur:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetClipCur
$LN4@GetClipCur:
	DB	108					; 0000006cH
	DB	0
?GetClipCursorWhenFullScreen@DXUTState@@QAE_NXZ ENDP	; DXUTState::GetClipCursorWhenFullScreen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetClipCursorWhenFullScreen@DXUTState@@QAEX_N@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 1
?SetClipCursorWhenFullScreen@DXUTState@@QAEX_N@Z PROC	; DXUTState::SetClipCursorWhenFullScreen, COMDAT
; _this$ = ecx

; 273  :     GET_SET_ACCESSOR( bool, ClipCursorWhenFullScreen );   

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+525], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetClipCur
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetClipCur:
	DD	1
	DD	$LN5@SetClipCur
$LN5@SetClipCur:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetClipCur
$LN4@SetClipCur:
	DB	108					; 0000006cH
	DB	0
?SetClipCursorWhenFullScreen@DXUTState@@QAEX_N@Z ENDP	; DXUTState::SetClipCursorWhenFullScreen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetShowMsgBoxOnError@DXUTState@@QAE_NXZ
_TEXT	SEGMENT
$T1 = -221						; size = 1
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetShowMsgBoxOnError@DXUTState@@QAE_NXZ PROC		; DXUTState::GetShowMsgBoxOnError, COMDAT
; _this$ = ecx

; 272  :     GET_SET_ACCESSOR( bool, ShowMsgBoxOnError );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+524]
	mov	BYTE PTR $T1[ebp], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	al, BYTE PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetShowMsg
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetShowMsg:
	DD	1
	DD	$LN5@GetShowMsg
$LN5@GetShowMsg:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetShowMsg
$LN4@GetShowMsg:
	DB	108					; 0000006cH
	DB	0
?GetShowMsgBoxOnError@DXUTState@@QAE_NXZ ENDP		; DXUTState::GetShowMsgBoxOnError
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetShowMsgBoxOnError@DXUTState@@QAEX_N@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 1
?SetShowMsgBoxOnError@DXUTState@@QAEX_N@Z PROC		; DXUTState::SetShowMsgBoxOnError, COMDAT
; _this$ = ecx

; 272  :     GET_SET_ACCESSOR( bool, ShowMsgBoxOnError );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+524], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetShowMsg
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetShowMsg:
	DD	1
	DD	$LN5@SetShowMsg
$LN5@SetShowMsg:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetShowMsg
$LN4@SetShowMsg:
	DB	108					; 0000006cH
	DB	0
?SetShowMsgBoxOnError@DXUTState@@QAEX_N@Z ENDP		; DXUTState::SetShowMsgBoxOnError
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetHandleDefaultHotkeys@DXUTState@@QAE_NXZ
_TEXT	SEGMENT
$T1 = -221						; size = 1
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetHandleDefaultHotkeys@DXUTState@@QAE_NXZ PROC	; DXUTState::GetHandleDefaultHotkeys, COMDAT
; _this$ = ecx

; 271  :     GET_SET_ACCESSOR( bool, HandleDefaultHotkeys );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+523]
	mov	BYTE PTR $T1[ebp], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	al, BYTE PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetHandleD
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetHandleD:
	DD	1
	DD	$LN5@GetHandleD
$LN5@GetHandleD:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetHandleD
$LN4@GetHandleD:
	DB	108					; 0000006cH
	DB	0
?GetHandleDefaultHotkeys@DXUTState@@QAE_NXZ ENDP	; DXUTState::GetHandleDefaultHotkeys
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetHandleDefaultHotkeys@DXUTState@@QAEX_N@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 1
?SetHandleDefaultHotkeys@DXUTState@@QAEX_N@Z PROC	; DXUTState::SetHandleDefaultHotkeys, COMDAT
; _this$ = ecx

; 271  :     GET_SET_ACCESSOR( bool, HandleDefaultHotkeys );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+523], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetHandleD
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetHandleD:
	DD	1
	DD	$LN5@SetHandleD
$LN5@SetHandleD:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetHandleD
$LN4@SetHandleD:
	DB	108					; 0000006cH
	DB	0
?SetHandleDefaultHotkeys@DXUTState@@QAEX_N@Z ENDP	; DXUTState::SetHandleDefaultHotkeys
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetStartupFilterKeys@DXUTState@@QAEXUtagFILTERKEYS@@@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 24
?SetStartupFilterKeys@DXUTState@@QAEXUtagFILTERKEYS@@@Z PROC ; DXUTState::SetStartupFilterKeys, COMDAT
; _this$ = ecx

; 269  :     GET_SET_ACCESSOR( FILTERKEYS, StartupFilterKeys );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 499				; 000001f3H
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _t$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _t$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _t$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _t$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR _t$[ebp+20]
	mov	DWORD PTR [eax+20], edx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetStartup
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
	npad	3
$LN6@SetStartup:
	DD	1
	DD	$LN5@SetStartup
$LN5@SetStartup:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetStartup
$LN4@SetStartup:
	DB	108					; 0000006cH
	DB	0
?SetStartupFilterKeys@DXUTState@@QAEXUtagFILTERKEYS@@@Z ENDP ; DXUTState::SetStartupFilterKeys
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetStartupToggleKeys@DXUTState@@QAEXUtagTOGGLEKEYS@@@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 8
?SetStartupToggleKeys@DXUTState@@QAEXUtagTOGGLEKEYS@@@Z PROC ; DXUTState::SetStartupToggleKeys, COMDAT
; _this$ = ecx

; 268  :     GET_SET_ACCESSOR( TOGGLEKEYS, StartupToggleKeys );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+491], ecx
	mov	edx, DWORD PTR _t$[ebp+4]
	mov	DWORD PTR [eax+495], edx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetStartup
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN6@SetStartup:
	DD	1
	DD	$LN5@SetStartup
$LN5@SetStartup:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetStartup
$LN4@SetStartup:
	DB	108					; 0000006cH
	DB	0
?SetStartupToggleKeys@DXUTState@@QAEXUtagTOGGLEKEYS@@@Z ENDP ; DXUTState::SetStartupToggleKeys
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetStartupStickyKeys@DXUTState@@QAEXUtagSTICKYKEYS@@@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 8
?SetStartupStickyKeys@DXUTState@@QAEXUtagSTICKYKEYS@@@Z PROC ; DXUTState::SetStartupStickyKeys, COMDAT
; _this$ = ecx

; 267  :     GET_SET_ACCESSOR( STICKYKEYS, StartupStickyKeys );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+483], ecx
	mov	edx, DWORD PTR _t$[ebp+4]
	mov	DWORD PTR [eax+487], edx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetStartup
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN6@SetStartup:
	DD	1
	DD	$LN5@SetStartup
$LN5@SetStartup:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetStartup
$LN4@SetStartup:
	DB	108					; 0000006cH
	DB	0
?SetStartupStickyKeys@DXUTState@@QAEXUtagSTICKYKEYS@@@Z ENDP ; DXUTState::SetStartupStickyKeys
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetAllowShortcutKeys@DXUTState@@QAEX_N@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 1
?SetAllowShortcutKeys@DXUTState@@QAEX_N@Z PROC		; DXUTState::SetAllowShortcutKeys, COMDAT
; _this$ = ecx

; 266  :     GET_SET_ACCESSOR( bool, AllowShortcutKeys );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+482], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetAllowSh
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetAllowSh:
	DD	1
	DD	$LN5@SetAllowSh
$LN5@SetAllowSh:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetAllowSh
$LN4@SetAllowSh:
	DB	108					; 0000006cH
	DB	0
?SetAllowShortcutKeys@DXUTState@@QAEX_N@Z ENDP		; DXUTState::SetAllowShortcutKeys
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetAllowShortcutKeysWhenWindowed@DXUTState@@QAE_NXZ
_TEXT	SEGMENT
$T1 = -221						; size = 1
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetAllowShortcutKeysWhenWindowed@DXUTState@@QAE_NXZ PROC ; DXUTState::GetAllowShortcutKeysWhenWindowed, COMDAT
; _this$ = ecx

; 265  :     GET_SET_ACCESSOR( bool, AllowShortcutKeysWhenWindowed );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+481]
	mov	BYTE PTR $T1[ebp], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	al, BYTE PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetAllowSh
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetAllowSh:
	DD	1
	DD	$LN5@GetAllowSh
$LN5@GetAllowSh:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetAllowSh
$LN4@GetAllowSh:
	DB	108					; 0000006cH
	DB	0
?GetAllowShortcutKeysWhenWindowed@DXUTState@@QAE_NXZ ENDP ; DXUTState::GetAllowShortcutKeysWhenWindowed
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetAllowShortcutKeysWhenWindowed@DXUTState@@QAEX_N@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 1
?SetAllowShortcutKeysWhenWindowed@DXUTState@@QAEX_N@Z PROC ; DXUTState::SetAllowShortcutKeysWhenWindowed, COMDAT
; _this$ = ecx

; 265  :     GET_SET_ACCESSOR( bool, AllowShortcutKeysWhenWindowed );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+481], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetAllowSh
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetAllowSh:
	DD	1
	DD	$LN5@SetAllowSh
$LN5@SetAllowSh:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetAllowSh
$LN4@SetAllowSh:
	DB	108					; 0000006cH
	DB	0
?SetAllowShortcutKeysWhenWindowed@DXUTState@@QAEX_N@Z ENDP ; DXUTState::SetAllowShortcutKeysWhenWindowed
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetAllowShortcutKeysWhenFullscreen@DXUTState@@QAE_NXZ
_TEXT	SEGMENT
$T1 = -221						; size = 1
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetAllowShortcutKeysWhenFullscreen@DXUTState@@QAE_NXZ PROC ; DXUTState::GetAllowShortcutKeysWhenFullscreen, COMDAT
; _this$ = ecx

; 264  :     GET_SET_ACCESSOR( bool, AllowShortcutKeysWhenFullscreen );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+480]
	mov	BYTE PTR $T1[ebp], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	al, BYTE PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetAllowSh
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetAllowSh:
	DD	1
	DD	$LN5@GetAllowSh
$LN5@GetAllowSh:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetAllowSh
$LN4@GetAllowSh:
	DB	108					; 0000006cH
	DB	0
?GetAllowShortcutKeysWhenFullscreen@DXUTState@@QAE_NXZ ENDP ; DXUTState::GetAllowShortcutKeysWhenFullscreen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetAllowShortcutKeysWhenFullscreen@DXUTState@@QAEX_N@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 1
?SetAllowShortcutKeysWhenFullscreen@DXUTState@@QAEX_N@Z PROC ; DXUTState::SetAllowShortcutKeysWhenFullscreen, COMDAT
; _this$ = ecx

; 264  :     GET_SET_ACCESSOR( bool, AllowShortcutKeysWhenFullscreen );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+480], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetAllowSh
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetAllowSh:
	DD	1
	DD	$LN5@SetAllowSh
$LN5@SetAllowSh:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetAllowSh
$LN4@SetAllowSh:
	DB	108					; 0000006cH
	DB	0
?SetAllowShortcutKeysWhenFullscreen@DXUTState@@QAEX_N@Z ENDP ; DXUTState::SetAllowShortcutKeysWhenFullscreen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetKeyboardHook@DXUTState@@QAEPAUHHOOK__@@XZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetKeyboardHook@DXUTState@@QAEPAUHHOOK__@@XZ PROC	; DXUTState::GetKeyboardHook, COMDAT
; _this$ = ecx

; 263  :     GET_SET_ACCESSOR( HHOOK, KeyboardHook );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+476]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetKeyboar
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetKeyboar:
	DD	1
	DD	$LN5@GetKeyboar
$LN5@GetKeyboar:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetKeyboar
$LN4@GetKeyboar:
	DB	108					; 0000006cH
	DB	0
?GetKeyboardHook@DXUTState@@QAEPAUHHOOK__@@XZ ENDP	; DXUTState::GetKeyboardHook
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetCurrentFrameNumber@DXUTState@@QAEHXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetCurrentFrameNumber@DXUTState@@QAEHXZ PROC		; DXUTState::GetCurrentFrameNumber, COMDAT
; _this$ = ecx

; 262  :     GET_SET_ACCESSOR( int, CurrentFrameNumber );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+472]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetCurrent
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetCurrent:
	DD	1
	DD	$LN5@GetCurrent
$LN5@GetCurrent:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetCurrent
$LN4@GetCurrent:
	DB	108					; 0000006cH
	DB	0
?GetCurrentFrameNumber@DXUTState@@QAEHXZ ENDP		; DXUTState::GetCurrentFrameNumber
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetCurrentFrameNumber@DXUTState@@QAEXH@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetCurrentFrameNumber@DXUTState@@QAEXH@Z PROC		; DXUTState::SetCurrentFrameNumber, COMDAT
; _this$ = ecx

; 262  :     GET_SET_ACCESSOR( int, CurrentFrameNumber );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+472], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetCurrent
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetCurrent:
	DD	1
	DD	$LN5@SetCurrent
$LN5@SetCurrent:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetCurrent
$LN4@SetCurrent:
	DB	108					; 0000006cH
	DB	0
?SetCurrentFrameNumber@DXUTState@@QAEXH@Z ENDP		; DXUTState::SetCurrentFrameNumber
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetFPS@DXUTState@@QAEMXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetFPS@DXUTState@@QAEMXZ PROC				; DXUTState::GetFPS, COMDAT
; _this$ = ecx

; 261  :     GET_SET_ACCESSOR( float, FPS );    

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+468]
	movss	DWORD PTR $T1[ebp], xmm0
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	fld	DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetFPS
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetFPS:
	DD	1
	DD	$LN5@GetFPS
$LN5@GetFPS:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetFPS
$LN4@GetFPS:
	DB	108					; 0000006cH
	DB	0
?GetFPS@DXUTState@@QAEMXZ ENDP				; DXUTState::GetFPS
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetFPS@DXUTState@@QAEXM@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetFPS@DXUTState@@QAEXM@Z PROC				; DXUTState::SetFPS, COMDAT
; _this$ = ecx

; 261  :     GET_SET_ACCESSOR( float, FPS );    

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _t$[ebp]
	movss	DWORD PTR [eax+468], xmm0
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetFPS
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetFPS:
	DD	1
	DD	$LN5@SetFPS
$LN5@SetFPS:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetFPS
$LN4@SetFPS:
	DB	108					; 0000006cH
	DB	0
?SetFPS@DXUTState@@QAEXM@Z ENDP				; DXUTState::SetFPS
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetLastStatsUpdateFrames@DXUTState@@QAEKXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetLastStatsUpdateFrames@DXUTState@@QAEKXZ PROC	; DXUTState::GetLastStatsUpdateFrames, COMDAT
; _this$ = ecx

; 260  :     GET_SET_ACCESSOR( DWORD, LastStatsUpdateFrames );   

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+464]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetLastSta
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetLastSta:
	DD	1
	DD	$LN5@GetLastSta
$LN5@GetLastSta:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetLastSta
$LN4@GetLastSta:
	DB	108					; 0000006cH
	DB	0
?GetLastStatsUpdateFrames@DXUTState@@QAEKXZ ENDP	; DXUTState::GetLastStatsUpdateFrames
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetLastStatsUpdateFrames@DXUTState@@QAEXK@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetLastStatsUpdateFrames@DXUTState@@QAEXK@Z PROC	; DXUTState::SetLastStatsUpdateFrames, COMDAT
; _this$ = ecx

; 260  :     GET_SET_ACCESSOR( DWORD, LastStatsUpdateFrames );   

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+464], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetLastSta
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetLastSta:
	DD	1
	DD	$LN5@SetLastSta
$LN5@SetLastSta:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetLastSta
$LN4@SetLastSta:
	DB	108					; 0000006cH
	DB	0
?SetLastStatsUpdateFrames@DXUTState@@QAEXK@Z ENDP	; DXUTState::SetLastStatsUpdateFrames
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetLastStatsUpdateTime@DXUTState@@QAENXZ
_TEXT	SEGMENT
$T1 = -228						; size = 8
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetLastStatsUpdateTime@DXUTState@@QAENXZ PROC		; DXUTState::GetLastStatsUpdateTime, COMDAT
; _this$ = ecx

; 259  :     GET_SET_ACCESSOR( double, LastStatsUpdateTime );   

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [eax+456]
	movsd	QWORD PTR $T1[ebp], xmm0
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	fld	QWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetLastSta
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetLastSta:
	DD	1
	DD	$LN5@GetLastSta
$LN5@GetLastSta:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetLastSta
$LN4@GetLastSta:
	DB	108					; 0000006cH
	DB	0
?GetLastStatsUpdateTime@DXUTState@@QAENXZ ENDP		; DXUTState::GetLastStatsUpdateTime
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetLastStatsUpdateTime@DXUTState@@QAEXN@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 8
?SetLastStatsUpdateTime@DXUTState@@QAEXN@Z PROC		; DXUTState::SetLastStatsUpdateTime, COMDAT
; _this$ = ecx

; 259  :     GET_SET_ACCESSOR( double, LastStatsUpdateTime );   

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR _t$[ebp]
	movsd	QWORD PTR [eax+456], xmm0
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetLastSta
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN6@SetLastSta:
	DD	1
	DD	$LN5@SetLastSta
$LN5@SetLastSta:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetLastSta
$LN4@SetLastSta:
	DB	108					; 0000006cH
	DB	0
?SetLastStatsUpdateTime@DXUTState@@QAEXN@Z ENDP		; DXUTState::SetLastStatsUpdateTime
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetHInstance@DXUTState@@QAEPAUHINSTANCE__@@XZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetHInstance@DXUTState@@QAEPAUHINSTANCE__@@XZ PROC	; DXUTState::GetHInstance, COMDAT
; _this$ = ecx

; 258  :     GET_SET_ACCESSOR( HINSTANCE, HInstance );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+452]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetHInstan
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetHInstan:
	DD	1
	DD	$LN5@GetHInstan
$LN5@GetHInstan:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetHInstan
$LN4@GetHInstan:
	DB	108					; 0000006cH
	DB	0
?GetHInstance@DXUTState@@QAEPAUHINSTANCE__@@XZ ENDP	; DXUTState::GetHInstance
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetHInstance@DXUTState@@QAEXPAUHINSTANCE__@@@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetHInstance@DXUTState@@QAEXPAUHINSTANCE__@@@Z PROC	; DXUTState::SetHInstance, COMDAT
; _this$ = ecx

; 258  :     GET_SET_ACCESSOR( HINSTANCE, HInstance );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+452], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetHInstan
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetHInstan:
	DD	1
	DD	$LN5@SetHInstan
$LN5@SetHInstan:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetHInstan
$LN4@SetHInstan:
	DB	108					; 0000006cH
	DB	0
?SetHInstance@DXUTState@@QAEXPAUHINSTANCE__@@@Z ENDP	; DXUTState::SetHInstance
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetElapsedTime@DXUTState@@QAEMXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetElapsedTime@DXUTState@@QAEMXZ PROC			; DXUTState::GetElapsedTime, COMDAT
; _this$ = ecx

; 256  :     GET_SET_ACCESSOR( float, ElapsedTime );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+448]
	movss	DWORD PTR $T1[ebp], xmm0
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	fld	DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetElapsed
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetElapsed:
	DD	1
	DD	$LN5@GetElapsed
$LN5@GetElapsed:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetElapsed
$LN4@GetElapsed:
	DB	108					; 0000006cH
	DB	0
?GetElapsedTime@DXUTState@@QAEMXZ ENDP			; DXUTState::GetElapsedTime
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetElapsedTime@DXUTState@@QAEXM@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetElapsedTime@DXUTState@@QAEXM@Z PROC			; DXUTState::SetElapsedTime, COMDAT
; _this$ = ecx

; 256  :     GET_SET_ACCESSOR( float, ElapsedTime );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _t$[ebp]
	movss	DWORD PTR [eax+448], xmm0
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetElapsed
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetElapsed:
	DD	1
	DD	$LN5@SetElapsed
$LN5@SetElapsed:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetElapsed
$LN4@SetElapsed:
	DB	108					; 0000006cH
	DB	0
?SetElapsedTime@DXUTState@@QAEXM@Z ENDP			; DXUTState::SetElapsedTime
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetTime@DXUTState@@QAENXZ
_TEXT	SEGMENT
$T1 = -228						; size = 8
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetTime@DXUTState@@QAENXZ PROC				; DXUTState::GetTime, COMDAT
; _this$ = ecx

; 255  :     GET_SET_ACCESSOR( double, Time );

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [eax+440]
	movsd	QWORD PTR $T1[ebp], xmm0
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	fld	QWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetTime
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetTime:
	DD	1
	DD	$LN5@GetTime
$LN5@GetTime:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetTime
$LN4@GetTime:
	DB	108					; 0000006cH
	DB	0
?GetTime@DXUTState@@QAENXZ ENDP				; DXUTState::GetTime
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetTime@DXUTState@@QAEXN@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 8
?SetTime@DXUTState@@QAEXN@Z PROC			; DXUTState::SetTime, COMDAT
; _this$ = ecx

; 255  :     GET_SET_ACCESSOR( double, Time );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR _t$[ebp]
	movsd	QWORD PTR [eax+440], xmm0
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetTime
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN6@SetTime:
	DD	1
	DD	$LN5@SetTime
$LN5@SetTime:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetTime
$LN4@SetTime:
	DB	108					; 0000006cH
	DB	0
?SetTime@DXUTState@@QAEXN@Z ENDP			; DXUTState::SetTime
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetIgnoreSizeChange@DXUTState@@QAE_NXZ
_TEXT	SEGMENT
$T1 = -221						; size = 1
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetIgnoreSizeChange@DXUTState@@QAE_NXZ PROC		; DXUTState::GetIgnoreSizeChange, COMDAT
; _this$ = ecx

; 253  :     GET_SET_ACCESSOR( bool, IgnoreSizeChange );   

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+439]
	mov	BYTE PTR $T1[ebp], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	al, BYTE PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetIgnoreS
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetIgnoreS:
	DD	1
	DD	$LN5@GetIgnoreS
$LN5@GetIgnoreS:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetIgnoreS
$LN4@GetIgnoreS:
	DB	108					; 0000006cH
	DB	0
?GetIgnoreSizeChange@DXUTState@@QAE_NXZ ENDP		; DXUTState::GetIgnoreSizeChange
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetIgnoreSizeChange@DXUTState@@QAEX_N@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 1
?SetIgnoreSizeChange@DXUTState@@QAEX_N@Z PROC		; DXUTState::SetIgnoreSizeChange, COMDAT
; _this$ = ecx

; 253  :     GET_SET_ACCESSOR( bool, IgnoreSizeChange );   

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+439], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetIgnoreS
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetIgnoreS:
	DD	1
	DD	$LN5@SetIgnoreS
$LN5@SetIgnoreS:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetIgnoreS
$LN4@SetIgnoreS:
	DB	108					; 0000006cH
	DB	0
?SetIgnoreSizeChange@DXUTState@@QAEX_N@Z ENDP		; DXUTState::SetIgnoreSizeChange
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetMinimizedWhileFullscreen@DXUTState@@QAE_NXZ
_TEXT	SEGMENT
$T1 = -221						; size = 1
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetMinimizedWhileFullscreen@DXUTState@@QAE_NXZ PROC	; DXUTState::GetMinimizedWhileFullscreen, COMDAT
; _this$ = ecx

; 252  :     GET_SET_ACCESSOR( bool, MinimizedWhileFullscreen );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+438]
	mov	BYTE PTR $T1[ebp], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	al, BYTE PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetMinimiz
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetMinimiz:
	DD	1
	DD	$LN5@GetMinimiz
$LN5@GetMinimiz:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetMinimiz
$LN4@GetMinimiz:
	DB	108					; 0000006cH
	DB	0
?GetMinimizedWhileFullscreen@DXUTState@@QAE_NXZ ENDP	; DXUTState::GetMinimizedWhileFullscreen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetMinimizedWhileFullscreen@DXUTState@@QAEX_N@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 1
?SetMinimizedWhileFullscreen@DXUTState@@QAEX_N@Z PROC	; DXUTState::SetMinimizedWhileFullscreen, COMDAT
; _this$ = ecx

; 252  :     GET_SET_ACCESSOR( bool, MinimizedWhileFullscreen );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+438], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetMinimiz
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetMinimiz:
	DD	1
	DD	$LN5@SetMinimiz
$LN5@SetMinimiz:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetMinimiz
$LN4@SetMinimiz:
	DB	108					; 0000006cH
	DB	0
?SetMinimizedWhileFullscreen@DXUTState@@QAEX_N@Z ENDP	; DXUTState::SetMinimizedWhileFullscreen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetMaximized@DXUTState@@QAE_NXZ
_TEXT	SEGMENT
$T1 = -221						; size = 1
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetMaximized@DXUTState@@QAE_NXZ PROC			; DXUTState::GetMaximized, COMDAT
; _this$ = ecx

; 251  :     GET_SET_ACCESSOR( bool, Maximized );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+437]
	mov	BYTE PTR $T1[ebp], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	al, BYTE PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetMaximiz
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetMaximiz:
	DD	1
	DD	$LN5@GetMaximiz
$LN5@GetMaximiz:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetMaximiz
$LN4@GetMaximiz:
	DB	108					; 0000006cH
	DB	0
?GetMaximized@DXUTState@@QAE_NXZ ENDP			; DXUTState::GetMaximized
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetMaximized@DXUTState@@QAEX_N@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 1
?SetMaximized@DXUTState@@QAEX_N@Z PROC			; DXUTState::SetMaximized, COMDAT
; _this$ = ecx

; 251  :     GET_SET_ACCESSOR( bool, Maximized );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+437], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetMaximiz
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetMaximiz:
	DD	1
	DD	$LN5@SetMaximiz
$LN5@SetMaximiz:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetMaximiz
$LN4@SetMaximiz:
	DB	108					; 0000006cH
	DB	0
?SetMaximized@DXUTState@@QAEX_N@Z ENDP			; DXUTState::SetMaximized
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetMinimized@DXUTState@@QAE_NXZ
_TEXT	SEGMENT
$T1 = -221						; size = 1
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetMinimized@DXUTState@@QAE_NXZ PROC			; DXUTState::GetMinimized, COMDAT
; _this$ = ecx

; 250  :     GET_SET_ACCESSOR( bool, Minimized );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+436]
	mov	BYTE PTR $T1[ebp], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	al, BYTE PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetMinimiz
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetMinimiz:
	DD	1
	DD	$LN5@GetMinimiz
$LN5@GetMinimiz:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetMinimiz
$LN4@GetMinimiz:
	DB	108					; 0000006cH
	DB	0
?GetMinimized@DXUTState@@QAE_NXZ ENDP			; DXUTState::GetMinimized
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetMinimized@DXUTState@@QAEX_N@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 1
?SetMinimized@DXUTState@@QAEX_N@Z PROC			; DXUTState::SetMinimized, COMDAT
; _this$ = ecx

; 250  :     GET_SET_ACCESSOR( bool, Minimized );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _t$[ebp]
	mov	BYTE PTR [eax+436], cl
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetMinimiz
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetMinimiz:
	DD	1
	DD	$LN5@SetMinimiz
$LN5@SetMinimiz:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetMinimiz
$LN4@SetMinimiz:
	DB	108					; 0000006cH
	DB	0
?SetMinimized@DXUTState@@QAEX_N@Z ENDP			; DXUTState::SetMinimized
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetWindowedStyleAtModeChange@DXUTState@@QAEKXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetWindowedStyleAtModeChange@DXUTState@@QAEKXZ PROC	; DXUTState::GetWindowedStyleAtModeChange, COMDAT
; _this$ = ecx

; 249  :     GET_SET_ACCESSOR( DWORD, WindowedStyleAtModeChange );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+388]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetWindowe
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetWindowe:
	DD	1
	DD	$LN5@GetWindowe
$LN5@GetWindowe:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetWindowe
$LN4@GetWindowe:
	DB	108					; 0000006cH
	DB	0
?GetWindowedStyleAtModeChange@DXUTState@@QAEKXZ ENDP	; DXUTState::GetWindowedStyleAtModeChange
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetWindowedStyleAtModeChange@DXUTState@@QAEXK@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetWindowedStyleAtModeChange@DXUTState@@QAEXK@Z PROC	; DXUTState::SetWindowedStyleAtModeChange, COMDAT
; _this$ = ecx

; 249  :     GET_SET_ACCESSOR( DWORD, WindowedStyleAtModeChange );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+388], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetWindowe
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetWindowe:
	DD	1
	DD	$LN5@SetWindowe
$LN5@SetWindowe:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetWindowe
$LN4@SetWindowe:
	DB	108					; 0000006cH
	DB	0
?SetWindowedStyleAtModeChange@DXUTState@@QAEXK@Z ENDP	; DXUTState::SetWindowedStyleAtModeChange
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetWindowedPlacement@DXUTState@@QAEPAUtagWINDOWPLACEMENT@@XZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetWindowedPlacement@DXUTState@@QAEPAUtagWINDOWPLACEMENT@@XZ PROC ; DXUTState::GetWindowedPlacement, COMDAT
; _this$ = ecx

; 248  :     GETP_SETP_ACCESSOR( WINDOWPLACEMENT, WindowedPlacement );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 392				; 00000188H
	mov	DWORD PTR $T1[ebp], eax
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetWindowe
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@GetWindowe:
	DD	1
	DD	$LN5@GetWindowe
$LN5@GetWindowe:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetWindowe
$LN4@GetWindowe:
	DB	108					; 0000006cH
	DB	0
?GetWindowedPlacement@DXUTState@@QAEPAUtagWINDOWPLACEMENT@@XZ ENDP ; DXUTState::GetWindowedPlacement
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetWindowBackBufferHeightAtModeChange@DXUTState@@QAEIXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetWindowBackBufferHeightAtModeChange@DXUTState@@QAEIXZ PROC ; DXUTState::GetWindowBackBufferHeightAtModeChange, COMDAT
; _this$ = ecx

; 247  :     GET_SET_ACCESSOR( UINT, WindowBackBufferHeightAtModeChange );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+384]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetWindowB
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetWindowB:
	DD	1
	DD	$LN5@GetWindowB
$LN5@GetWindowB:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetWindowB
$LN4@GetWindowB:
	DB	108					; 0000006cH
	DB	0
?GetWindowBackBufferHeightAtModeChange@DXUTState@@QAEIXZ ENDP ; DXUTState::GetWindowBackBufferHeightAtModeChange
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetWindowBackBufferHeightAtModeChange@DXUTState@@QAEXI@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetWindowBackBufferHeightAtModeChange@DXUTState@@QAEXI@Z PROC ; DXUTState::SetWindowBackBufferHeightAtModeChange, COMDAT
; _this$ = ecx

; 247  :     GET_SET_ACCESSOR( UINT, WindowBackBufferHeightAtModeChange );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+384], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetWindowB
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetWindowB:
	DD	1
	DD	$LN5@SetWindowB
$LN5@SetWindowB:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetWindowB
$LN4@SetWindowB:
	DB	108					; 0000006cH
	DB	0
?SetWindowBackBufferHeightAtModeChange@DXUTState@@QAEXI@Z ENDP ; DXUTState::SetWindowBackBufferHeightAtModeChange
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetWindowBackBufferWidthAtModeChange@DXUTState@@QAEIXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetWindowBackBufferWidthAtModeChange@DXUTState@@QAEIXZ PROC ; DXUTState::GetWindowBackBufferWidthAtModeChange, COMDAT
; _this$ = ecx

; 246  :     GET_SET_ACCESSOR( UINT, WindowBackBufferWidthAtModeChange );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+380]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetWindowB
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetWindowB:
	DD	1
	DD	$LN5@GetWindowB
$LN5@GetWindowB:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetWindowB
$LN4@GetWindowB:
	DB	108					; 0000006cH
	DB	0
?GetWindowBackBufferWidthAtModeChange@DXUTState@@QAEIXZ ENDP ; DXUTState::GetWindowBackBufferWidthAtModeChange
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetWindowBackBufferWidthAtModeChange@DXUTState@@QAEXI@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetWindowBackBufferWidthAtModeChange@DXUTState@@QAEXI@Z PROC ; DXUTState::SetWindowBackBufferWidthAtModeChange, COMDAT
; _this$ = ecx

; 246  :     GET_SET_ACCESSOR( UINT, WindowBackBufferWidthAtModeChange );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+380], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetWindowB
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetWindowB:
	DD	1
	DD	$LN5@SetWindowB
$LN5@SetWindowB:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetWindowB
$LN4@SetWindowB:
	DB	108					; 0000006cH
	DB	0
?SetWindowBackBufferWidthAtModeChange@DXUTState@@QAEXI@Z ENDP ; DXUTState::SetWindowBackBufferWidthAtModeChange
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetFullScreenBackBufferHeightAtModeChange@DXUTState@@QAEIXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetFullScreenBackBufferHeightAtModeChange@DXUTState@@QAEIXZ PROC ; DXUTState::GetFullScreenBackBufferHeightAtModeChange, COMDAT
; _this$ = ecx

; 245  :     GET_SET_ACCESSOR( UINT, FullScreenBackBufferHeightAtModeChange );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+376]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetFullScr
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetFullScr:
	DD	1
	DD	$LN5@GetFullScr
$LN5@GetFullScr:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetFullScr
$LN4@GetFullScr:
	DB	108					; 0000006cH
	DB	0
?GetFullScreenBackBufferHeightAtModeChange@DXUTState@@QAEIXZ ENDP ; DXUTState::GetFullScreenBackBufferHeightAtModeChange
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetFullScreenBackBufferHeightAtModeChange@DXUTState@@QAEXI@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetFullScreenBackBufferHeightAtModeChange@DXUTState@@QAEXI@Z PROC ; DXUTState::SetFullScreenBackBufferHeightAtModeChange, COMDAT
; _this$ = ecx

; 245  :     GET_SET_ACCESSOR( UINT, FullScreenBackBufferHeightAtModeChange );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+376], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetFullScr
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetFullScr:
	DD	1
	DD	$LN5@SetFullScr
$LN5@SetFullScr:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetFullScr
$LN4@SetFullScr:
	DB	108					; 0000006cH
	DB	0
?SetFullScreenBackBufferHeightAtModeChange@DXUTState@@QAEXI@Z ENDP ; DXUTState::SetFullScreenBackBufferHeightAtModeChange
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetFullScreenBackBufferWidthAtModeChange@DXUTState@@QAEIXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetFullScreenBackBufferWidthAtModeChange@DXUTState@@QAEIXZ PROC ; DXUTState::GetFullScreenBackBufferWidthAtModeChange, COMDAT
; _this$ = ecx

; 244  :     GET_SET_ACCESSOR( UINT, FullScreenBackBufferWidthAtModeChange );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+372]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetFullScr
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetFullScr:
	DD	1
	DD	$LN5@GetFullScr
$LN5@GetFullScr:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetFullScr
$LN4@GetFullScr:
	DB	108					; 0000006cH
	DB	0
?GetFullScreenBackBufferWidthAtModeChange@DXUTState@@QAEIXZ ENDP ; DXUTState::GetFullScreenBackBufferWidthAtModeChange
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetFullScreenBackBufferWidthAtModeChange@DXUTState@@QAEXI@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetFullScreenBackBufferWidthAtModeChange@DXUTState@@QAEXI@Z PROC ; DXUTState::SetFullScreenBackBufferWidthAtModeChange, COMDAT
; _this$ = ecx

; 244  :     GET_SET_ACCESSOR( UINT, FullScreenBackBufferWidthAtModeChange );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+372], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetFullScr
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetFullScr:
	DD	1
	DD	$LN5@SetFullScr
$LN5@SetFullScr:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetFullScr
$LN4@SetFullScr:
	DB	108					; 0000006cH
	DB	0
?SetFullScreenBackBufferWidthAtModeChange@DXUTState@@QAEXI@Z ENDP ; DXUTState::SetFullScreenBackBufferWidthAtModeChange
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetMenu@DXUTState@@QAEPAUHMENU__@@XZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetMenu@DXUTState@@QAEPAUHMENU__@@XZ PROC		; DXUTState::GetMenu, COMDAT
; _this$ = ecx

; 242  :     GET_SET_ACCESSOR( HMENU, Menu );   

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+368]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetMenu
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetMenu:
	DD	1
	DD	$LN5@GetMenu
$LN5@GetMenu:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetMenu
$LN4@GetMenu:
	DB	108					; 0000006cH
	DB	0
?GetMenu@DXUTState@@QAEPAUHMENU__@@XZ ENDP		; DXUTState::GetMenu
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetMenu@DXUTState@@QAEXPAUHMENU__@@@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetMenu@DXUTState@@QAEXPAUHMENU__@@@Z PROC		; DXUTState::SetMenu, COMDAT
; _this$ = ecx

; 242  :     GET_SET_ACCESSOR( HMENU, Menu );   

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+368], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetMenu
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetMenu:
	DD	1
	DD	$LN5@SetMenu
$LN5@SetMenu:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetMenu
$LN4@SetMenu:
	DB	108					; 0000006cH
	DB	0
?SetMenu@DXUTState@@QAEXPAUHMENU__@@@Z ENDP		; DXUTState::SetMenu
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetAdapterMonitor@DXUTState@@QAEPAUHMONITOR__@@XZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetAdapterMonitor@DXUTState@@QAEPAUHMONITOR__@@XZ PROC	; DXUTState::GetAdapterMonitor, COMDAT
; _this$ = ecx

; 241  :     GET_SET_ACCESSOR( HMONITOR, AdapterMonitor );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+364]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetAdapter
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetAdapter:
	DD	1
	DD	$LN5@GetAdapter
$LN5@GetAdapter:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetAdapter
$LN4@GetAdapter:
	DB	108					; 0000006cH
	DB	0
?GetAdapterMonitor@DXUTState@@QAEPAUHMONITOR__@@XZ ENDP	; DXUTState::GetAdapterMonitor
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetAdapterMonitor@DXUTState@@QAEXPAUHMONITOR__@@@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetAdapterMonitor@DXUTState@@QAEXPAUHMONITOR__@@@Z PROC ; DXUTState::SetAdapterMonitor, COMDAT
; _this$ = ecx

; 241  :     GET_SET_ACCESSOR( HMONITOR, AdapterMonitor );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+364], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetAdapter
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetAdapter:
	DD	1
	DD	$LN5@SetAdapter
$LN5@SetAdapter:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetAdapter
$LN4@SetAdapter:
	DB	108					; 0000006cH
	DB	0
?SetAdapterMonitor@DXUTState@@QAEXPAUHMONITOR__@@@Z ENDP ; DXUTState::SetAdapterMonitor
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetHWNDDeviceWindowed@DXUTState@@QAEPAUHWND__@@XZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetHWNDDeviceWindowed@DXUTState@@QAEPAUHWND__@@XZ PROC	; DXUTState::GetHWNDDeviceWindowed, COMDAT
; _this$ = ecx

; 240  :     GET_SET_ACCESSOR( HWND, HWNDDeviceWindowed );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+360]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetHWNDDev
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetHWNDDev:
	DD	1
	DD	$LN5@GetHWNDDev
$LN5@GetHWNDDev:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetHWNDDev
$LN4@GetHWNDDev:
	DB	108					; 0000006cH
	DB	0
?GetHWNDDeviceWindowed@DXUTState@@QAEPAUHWND__@@XZ ENDP	; DXUTState::GetHWNDDeviceWindowed
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetHWNDDeviceWindowed@DXUTState@@QAEXPAUHWND__@@@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetHWNDDeviceWindowed@DXUTState@@QAEXPAUHWND__@@@Z PROC ; DXUTState::SetHWNDDeviceWindowed, COMDAT
; _this$ = ecx

; 240  :     GET_SET_ACCESSOR( HWND, HWNDDeviceWindowed );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+360], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetHWNDDev
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetHWNDDev:
	DD	1
	DD	$LN5@SetHWNDDev
$LN5@SetHWNDDev:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetHWNDDev
$LN4@SetHWNDDev:
	DB	108					; 0000006cH
	DB	0
?SetHWNDDeviceWindowed@DXUTState@@QAEXPAUHWND__@@@Z ENDP ; DXUTState::SetHWNDDeviceWindowed
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetHWNDDeviceFullScreen@DXUTState@@QAEPAUHWND__@@XZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetHWNDDeviceFullScreen@DXUTState@@QAEPAUHWND__@@XZ PROC ; DXUTState::GetHWNDDeviceFullScreen, COMDAT
; _this$ = ecx

; 239  :     GET_SET_ACCESSOR( HWND, HWNDDeviceFullScreen );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+356]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetHWNDDev
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetHWNDDev:
	DD	1
	DD	$LN5@GetHWNDDev
$LN5@GetHWNDDev:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetHWNDDev
$LN4@GetHWNDDev:
	DB	108					; 0000006cH
	DB	0
?GetHWNDDeviceFullScreen@DXUTState@@QAEPAUHWND__@@XZ ENDP ; DXUTState::GetHWNDDeviceFullScreen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetHWNDDeviceFullScreen@DXUTState@@QAEXPAUHWND__@@@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetHWNDDeviceFullScreen@DXUTState@@QAEXPAUHWND__@@@Z PROC ; DXUTState::SetHWNDDeviceFullScreen, COMDAT
; _this$ = ecx

; 239  :     GET_SET_ACCESSOR( HWND, HWNDDeviceFullScreen );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+356], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetHWNDDev
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetHWNDDev:
	DD	1
	DD	$LN5@SetHWNDDev
$LN5@SetHWNDDev:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetHWNDDev
$LN4@SetHWNDDev:
	DB	108					; 0000006cH
	DB	0
?SetHWNDDeviceFullScreen@DXUTState@@QAEXPAUHWND__@@@Z ENDP ; DXUTState::SetHWNDDeviceFullScreen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetHWNDFocus@DXUTState@@QAEPAUHWND__@@XZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetHWNDFocus@DXUTState@@QAEPAUHWND__@@XZ PROC		; DXUTState::GetHWNDFocus, COMDAT
; _this$ = ecx

; 238  :     GET_SET_ACCESSOR( HWND, HWNDFocus );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+352]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetHWNDFoc
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetHWNDFoc:
	DD	1
	DD	$LN5@GetHWNDFoc
$LN5@GetHWNDFoc:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetHWNDFoc
$LN4@GetHWNDFoc:
	DB	108					; 0000006cH
	DB	0
?GetHWNDFocus@DXUTState@@QAEPAUHWND__@@XZ ENDP		; DXUTState::GetHWNDFocus
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetHWNDFocus@DXUTState@@QAEXPAUHWND__@@@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetHWNDFocus@DXUTState@@QAEXPAUHWND__@@@Z PROC		; DXUTState::SetHWNDFocus, COMDAT
; _this$ = ecx

; 238  :     GET_SET_ACCESSOR( HWND, HWNDFocus );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+352], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetHWNDFoc
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetHWNDFoc:
	DD	1
	DD	$LN5@SetHWNDFoc
$LN5@SetHWNDFoc:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetHWNDFoc
$LN4@SetHWNDFoc:
	DB	108					; 0000006cH
	DB	0
?SetHWNDFocus@DXUTState@@QAEXPAUHWND__@@@Z ENDP		; DXUTState::SetHWNDFocus
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetCaps@DXUTState@@QAEPAU_D3DCAPS9@@XZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetCaps@DXUTState@@QAEPAU_D3DCAPS9@@XZ PROC		; DXUTState::GetCaps, COMDAT
; _this$ = ecx

; 236  :     GETP_SETP_ACCESSOR( D3DCAPS9, Caps );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 48					; 00000030H
	mov	DWORD PTR $T1[ebp], eax
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetCaps
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN6@GetCaps:
	DD	1
	DD	$LN5@GetCaps
$LN5@GetCaps:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetCaps
$LN4@GetCaps:
	DB	108					; 0000006cH
	DB	0
?GetCaps@DXUTState@@QAEPAU_D3DCAPS9@@XZ ENDP		; DXUTState::GetCaps
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetBackBufferSurfaceDesc@DXUTState@@QAEPAU_D3DSURFACE_DESC@@XZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetBackBufferSurfaceDesc@DXUTState@@QAEPAU_D3DSURFACE_DESC@@XZ PROC ; DXUTState::GetBackBufferSurfaceDesc, COMDAT
; _this$ = ecx

; 235  :     GETP_SETP_ACCESSOR( D3DSURFACE_DESC, BackBufferSurfaceDesc );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T1[ebp], eax
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetBackBuf
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN6@GetBackBuf:
	DD	1
	DD	$LN5@GetBackBuf
$LN5@GetBackBuf:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetBackBuf
$LN4@GetBackBuf:
	DB	108					; 0000006cH
	DB	0
?GetBackBufferSurfaceDesc@DXUTState@@QAEPAU_D3DSURFACE_DESC@@XZ ENDP ; DXUTState::GetBackBufferSurfaceDesc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetCurrentDeviceSettings@DXUTState@@QAEPAUDXUTDeviceSettings@@XZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetCurrentDeviceSettings@DXUTState@@QAEPAUDXUTDeviceSettings@@XZ PROC ; DXUTState::GetCurrentDeviceSettings, COMDAT
; _this$ = ecx

; 234  :     GET_SET_ACCESSOR( DXUTDeviceSettings*, CurrentDeviceSettings );   

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetCurrent
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN6@GetCurrent:
	DD	1
	DD	$LN5@GetCurrent
$LN5@GetCurrent:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetCurrent
$LN4@GetCurrent:
	DB	108					; 0000006cH
	DB	0
?GetCurrentDeviceSettings@DXUTState@@QAEPAUDXUTDeviceSettings@@XZ ENDP ; DXUTState::GetCurrentDeviceSettings
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetCurrentDeviceSettings@DXUTState@@QAEXPAUDXUTDeviceSettings@@@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetCurrentDeviceSettings@DXUTState@@QAEXPAUDXUTDeviceSettings@@@Z PROC ; DXUTState::SetCurrentDeviceSettings, COMDAT
; _this$ = ecx

; 234  :     GET_SET_ACCESSOR( DXUTDeviceSettings*, CurrentDeviceSettings );   

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+12], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetCurrent
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN6@SetCurrent:
	DD	1
	DD	$LN5@SetCurrent
$LN5@SetCurrent:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetCurrent
$LN4@SetCurrent:
	DB	108					; 0000006cH
	DB	0
?SetCurrentDeviceSettings@DXUTState@@QAEXPAUDXUTDeviceSettings@@@Z ENDP ; DXUTState::SetCurrentDeviceSettings
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetD3DEnumeration@DXUTState@@QAEPAVCD3DEnumeration@@XZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetD3DEnumeration@DXUTState@@QAEPAVCD3DEnumeration@@XZ PROC ; DXUTState::GetD3DEnumeration, COMDAT
; _this$ = ecx

; 233  :     GET_SET_ACCESSOR( CD3DEnumeration*, D3DEnumeration );   

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetD3DEnum
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN6@GetD3DEnum:
	DD	1
	DD	$LN5@GetD3DEnum
$LN5@GetD3DEnum:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetD3DEnum
$LN4@GetD3DEnum:
	DB	108					; 0000006cH
	DB	0
?GetD3DEnumeration@DXUTState@@QAEPAVCD3DEnumeration@@XZ ENDP ; DXUTState::GetD3DEnumeration
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetD3DEnumeration@DXUTState@@QAEXPAVCD3DEnumeration@@@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetD3DEnumeration@DXUTState@@QAEXPAVCD3DEnumeration@@@Z PROC ; DXUTState::SetD3DEnumeration, COMDAT
; _this$ = ecx

; 233  :     GET_SET_ACCESSOR( CD3DEnumeration*, D3DEnumeration );   

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+8], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetD3DEnum
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN6@SetD3DEnum:
	DD	1
	DD	$LN5@SetD3DEnum
$LN5@SetD3DEnum:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetD3DEnum
$LN4@SetD3DEnum:
	DB	108					; 0000006cH
	DB	0
?SetD3DEnumeration@DXUTState@@QAEXPAVCD3DEnumeration@@@Z ENDP ; DXUTState::SetD3DEnumeration
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetD3DDevice@DXUTState@@QAEPAUIDirect3DDevice9@@XZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetD3DDevice@DXUTState@@QAEPAUIDirect3DDevice9@@XZ PROC ; DXUTState::GetD3DDevice, COMDAT
; _this$ = ecx

; 232  :     GET_SET_ACCESSOR( IDirect3DDevice9*, D3DDevice );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetD3DDevi
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN6@GetD3DDevi:
	DD	1
	DD	$LN5@GetD3DDevi
$LN5@GetD3DDevi:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetD3DDevi
$LN4@GetD3DDevi:
	DB	108					; 0000006cH
	DB	0
?GetD3DDevice@DXUTState@@QAEPAUIDirect3DDevice9@@XZ ENDP ; DXUTState::GetD3DDevice
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetD3DDevice@DXUTState@@QAEXPAUIDirect3DDevice9@@@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetD3DDevice@DXUTState@@QAEXPAUIDirect3DDevice9@@@Z PROC ; DXUTState::SetD3DDevice, COMDAT
; _this$ = ecx

; 232  :     GET_SET_ACCESSOR( IDirect3DDevice9*, D3DDevice );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+4], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetD3DDevi
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN6@SetD3DDevi:
	DD	1
	DD	$LN5@SetD3DDevi
$LN5@SetD3DDevi:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetD3DDevi
$LN4@SetD3DDevi:
	DB	108					; 0000006cH
	DB	0
?SetD3DDevice@DXUTState@@QAEXPAUIDirect3DDevice9@@@Z ENDP ; DXUTState::SetD3DDevice
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?GetD3D@DXUTState@@QAEPAUIDirect3D9@@XZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_l$ = -17						; size = 1
_this$ = -8						; size = 4
?GetD3D@DXUTState@@QAEPAUIDirect3D9@@XZ PROC		; DXUTState::GetD3D, COMDAT
; _this$ = ecx

; 230  :     GET_SET_ACCESSOR( IDirect3D9*, D3D );

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetD3D
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetD3D:
	DD	1
	DD	$LN5@GetD3D
$LN5@GetD3D:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetD3D
$LN4@GetD3D:
	DB	108					; 0000006cH
	DB	0
?GetD3D@DXUTState@@QAEPAUIDirect3D9@@XZ ENDP		; DXUTState::GetD3D
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?SetD3D@DXUTState@@QAEXPAUIDirect3D9@@@Z
_TEXT	SEGMENT
_l$ = -17						; size = 1
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?SetD3D@DXUTState@@QAEXPAUIDirect3D9@@@Z PROC		; DXUTState::SetD3D, COMDAT
; _this$ = ecx

; 230  :     GET_SET_ACCESSOR( IDirect3D9*, D3D );

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0DXUTLock@@QAE@XZ			; DXUTLock::DXUTLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax], ecx
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1DXUTLock@@QAE@XZ			; DXUTLock::~DXUTLock
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@SetD3D
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN6@SetD3D:
	DD	1
	DD	$LN5@SetD3D
$LN5@SetD3D:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@SetD3D
$LN4@SetD3D:
	DB	108					; 0000006cH
	DB	0
?SetD3D@DXUTState@@QAEXPAUIDirect3D9@@@Z ENDP		; DXUTState::SetD3D
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?Destroy@DXUTState@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Destroy@DXUTState@@QAEXXZ PROC				; DXUTState::Destroy, COMDAT
; _this$ = ecx

; 224  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 225  :         DXUTShutdown();

	push	0
	call	?DXUTShutdown@@YAXH@Z			; DXUTShutdown
	add	esp, 4

; 226  :         DeleteCriticalSection( &g_cs ); 

	mov	esi, esp
	push	OFFSET ?g_cs@@3U_RTL_CRITICAL_SECTION@@A ; g_cs
	call	DWORD PTR __imp__DeleteCriticalSection@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 227  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Destroy@DXUTState@@QAEXXZ ENDP				; DXUTState::Destroy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?Create@DXUTState@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Create@DXUTState@@QAEXXZ PROC				; DXUTState::Create, COMDAT
; _this$ = ecx

; 206  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 207  :         // Make sure these are created before DXUTState so they 
; 208  :         // destroyed last because DXUTState cleanup needs them
; 209  :         DXUTGetGlobalResourceCache();

	call	?DXUTGetGlobalResourceCache@@YAAAVCDXUTResourceCache@@XZ ; DXUTGetGlobalResourceCache

; 210  : 
; 211  :         ZeroMemory( &m_state, sizeof(STATE) ); 

	push	1981					; 000007bdH
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 212  :         g_bThreadSafe = true; 

	mov	BYTE PTR ?g_bThreadSafe@@3_NA, 1	; g_bThreadSafe

; 213  :         InitializeCriticalSection( &g_cs ); 

	mov	esi, esp
	push	OFFSET ?g_cs@@3U_RTL_CRITICAL_SECTION@@A ; g_cs
	call	DWORD PTR __imp__InitializeCriticalSection@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 214  :         m_state.m_OverrideStartX = -1; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+570], -1

; 215  :         m_state.m_OverrideStartY = -1; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+574], -1

; 216  :         m_state.m_OverrideAdapterOrdinal = -1; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+564], -1

; 217  :         m_state.m_AutoChangeAdapter = true; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+533], 1

; 218  :         m_state.m_ShowMsgBoxOnError = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+524], 1

; 219  :         m_state.m_AllowShortcutKeysWhenWindowed = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+481], 1

; 220  :         m_state.m_Active = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+549], 1

; 221  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Create@DXUTState@@QAEXXZ ENDP				; DXUTState::Create
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ??1DXUTState@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1DXUTState@@QAE@XZ PROC				; DXUTState::~DXUTState, COMDAT
; _this$ = ecx

; 203  :     ~DXUTState() { Destroy(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Destroy@DXUTState@@QAEXXZ		; DXUTState::Destroy
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1DXUTState@@QAE@XZ ENDP				; DXUTState::~DXUTState
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ??0DXUTState@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0DXUTState@@QAE@XZ PROC				; DXUTState::DXUTState, COMDAT
; _this$ = ecx

; 202  :     DXUTState()  { Create(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Create@DXUTState@@QAEXXZ		; DXUTState::Create
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0DXUTState@@QAE@XZ ENDP				; DXUTState::DXUTState
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ??1DXUTLock@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1DXUTLock@@QAE@XZ PROC				; DXUTLock::~DXUTLock, COMDAT
; _this$ = ecx

; 35   :     inline ~DXUTLock() { if( g_bThreadSafe ) LeaveCriticalSection( &g_cs ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	movzx	eax, BYTE PTR ?g_bThreadSafe@@3_NA	; g_bThreadSafe
	test	eax, eax
	je	SHORT $LN2@DXUTLock
	mov	esi, esp
	push	OFFSET ?g_cs@@3U_RTL_CRITICAL_SECTION@@A ; g_cs
	call	DWORD PTR __imp__LeaveCriticalSection@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@DXUTLock:
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1DXUTLock@@QAE@XZ ENDP				; DXUTLock::~DXUTLock
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ??0DXUTLock@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0DXUTLock@@QAE@XZ PROC				; DXUTLock::DXUTLock, COMDAT
; _this$ = ecx

; 34   :     inline DXUTLock()  { if( g_bThreadSafe ) EnterCriticalSection( &g_cs ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	movzx	eax, BYTE PTR ?g_bThreadSafe@@3_NA	; g_bThreadSafe
	test	eax, eax
	je	SHORT $LN2@DXUTLock
	mov	esi, esp
	push	OFFSET ?g_cs@@3U_RTL_CRITICAL_SECTION@@A ; g_cs
	call	DWORD PTR __imp__EnterCriticalSection@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@DXUTLock:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0DXUTLock@@QAE@XZ ENDP				; DXUTLock::DXUTLock
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\include\multimon.h
;	COMDAT _InitMultipleMonitorStubs
_TEXT	SEGMENT
tv66 = -208						; size = 4
_hUser32$ = -8						; size = 4
_InitMultipleMonitorStubs PROC				; COMDAT

; 177  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 178  :     HMODULE hUser32;
; 179  :     if (g_fMultiMonInitDone)

	cmp	DWORD PTR _g_fMultiMonInitDone, 0
	je	SHORT $LN3@InitMultip

; 180  :     {
; 181  :         return g_pfnGetMonitorInfo != NULL;

	cmp	DWORD PTR _g_pfnGetMonitorInfo, 0
	je	SHORT $LN6@InitMultip
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN7@InitMultip
$LN6@InitMultip:
	mov	DWORD PTR tv66[ebp], 0
$LN7@InitMultip:
	mov	eax, DWORD PTR tv66[ebp]
	jmp	$LN4@InitMultip
$LN3@InitMultip:

; 182  :     }
; 183  : 
; 184  :     g_fMultimonPlatformNT = IsPlatformNT();

	call	_IsPlatformNT
	mov	DWORD PTR _g_fMultimonPlatformNT, eax

; 185  :     hUser32 = GetModuleHandle(TEXT("USER32"));

	mov	esi, esp
	push	OFFSET ??_C@_06KDCOIDGA@USER32?$AA@
	call	DWORD PTR __imp__GetModuleHandleA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hUser32$[ebp], eax

; 186  :     if (hUser32 &&
; 187  :         (*(FARPROC*)&g_pfnGetSystemMetrics    = GetProcAddress(hUser32,"GetSystemMetrics")) != NULL &&
; 188  :         (*(FARPROC*)&g_pfnMonitorFromWindow   = GetProcAddress(hUser32,"MonitorFromWindow")) != NULL &&
; 189  :         (*(FARPROC*)&g_pfnMonitorFromRect     = GetProcAddress(hUser32,"MonitorFromRect")) != NULL &&
; 190  :         (*(FARPROC*)&g_pfnMonitorFromPoint    = GetProcAddress(hUser32,"MonitorFromPoint")) != NULL &&
; 191  :         (*(FARPROC*)&g_pfnEnumDisplayMonitors = GetProcAddress(hUser32,"EnumDisplayMonitors")) != NULL &&
; 192  : #ifdef UNICODE
; 193  :         (*(FARPROC*)&g_pfnEnumDisplayDevices  = GetProcAddress(hUser32,"EnumDisplayDevicesW")) != NULL &&
; 194  :         (*(FARPROC*)&g_pfnGetMonitorInfo      = g_fMultimonPlatformNT ? GetProcAddress(hUser32,"GetMonitorInfoW") : 
; 195  :                                                 GetProcAddress(hUser32,"GetMonitorInfoA")) != NULL
; 196  : #else
; 197  :         (*(FARPROC*)&g_pfnGetMonitorInfo      = GetProcAddress(hUser32,"GetMonitorInfoA")) != NULL &&
; 198  :         (*(FARPROC*)&g_pfnEnumDisplayDevices  = GetProcAddress(hUser32,"EnumDisplayDevicesA")) != NULL
; 199  : #endif
; 200  :     ) {

	cmp	DWORD PTR _hUser32$[ebp], 0
	je	$LN2@InitMultip
	mov	esi, esp
	push	OFFSET ??_C@_0BB@BFCABEPI@GetSystemMetrics?$AA@
	mov	eax, DWORD PTR _hUser32$[ebp]
	push	eax
	call	DWORD PTR __imp__GetProcAddress@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _g_pfnGetSystemMetrics, eax
	cmp	DWORD PTR _g_pfnGetSystemMetrics, 0
	je	$LN2@InitMultip
	mov	esi, esp
	push	OFFSET ??_C@_0BC@CHFENAPF@MonitorFromWindow?$AA@
	mov	eax, DWORD PTR _hUser32$[ebp]
	push	eax
	call	DWORD PTR __imp__GetProcAddress@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _g_pfnMonitorFromWindow, eax
	cmp	DWORD PTR _g_pfnMonitorFromWindow, 0
	je	$LN2@InitMultip
	mov	esi, esp
	push	OFFSET ??_C@_0BA@DPLKJPEB@MonitorFromRect?$AA@
	mov	eax, DWORD PTR _hUser32$[ebp]
	push	eax
	call	DWORD PTR __imp__GetProcAddress@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _g_pfnMonitorFromRect, eax
	cmp	DWORD PTR _g_pfnMonitorFromRect, 0
	je	$LN2@InitMultip
	mov	esi, esp
	push	OFFSET ??_C@_0BB@DDMDAIAD@MonitorFromPoint?$AA@
	mov	eax, DWORD PTR _hUser32$[ebp]
	push	eax
	call	DWORD PTR __imp__GetProcAddress@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _g_pfnMonitorFromPoint, eax
	cmp	DWORD PTR _g_pfnMonitorFromPoint, 0
	je	$LN2@InitMultip
	mov	esi, esp
	push	OFFSET ??_C@_0BE@OHNDFFJG@EnumDisplayMonitors?$AA@
	mov	eax, DWORD PTR _hUser32$[ebp]
	push	eax
	call	DWORD PTR __imp__GetProcAddress@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _g_pfnEnumDisplayMonitors, eax
	cmp	DWORD PTR _g_pfnEnumDisplayMonitors, 0
	je	SHORT $LN2@InitMultip
	mov	esi, esp
	push	OFFSET ??_C@_0BA@KIAMMEPJ@GetMonitorInfoA?$AA@
	mov	eax, DWORD PTR _hUser32$[ebp]
	push	eax
	call	DWORD PTR __imp__GetProcAddress@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _g_pfnGetMonitorInfo, eax
	cmp	DWORD PTR _g_pfnGetMonitorInfo, 0
	je	SHORT $LN2@InitMultip
	mov	esi, esp
	push	OFFSET ??_C@_0BE@NPEOLIBM@EnumDisplayDevicesA?$AA@
	mov	eax, DWORD PTR _hUser32$[ebp]
	push	eax
	call	DWORD PTR __imp__GetProcAddress@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _g_pfnEnumDisplayDevices, eax
	cmp	DWORD PTR _g_pfnEnumDisplayDevices, 0
	je	SHORT $LN2@InitMultip

; 201  :         g_fMultiMonInitDone = TRUE;

	mov	DWORD PTR _g_fMultiMonInitDone, 1

; 202  :         return TRUE;

	mov	eax, 1
	jmp	SHORT $LN4@InitMultip

; 203  :     }
; 204  :     else

	jmp	SHORT $LN4@InitMultip
$LN2@InitMultip:

; 205  :     {
; 206  :         g_pfnGetSystemMetrics    = NULL;

	mov	DWORD PTR _g_pfnGetSystemMetrics, 0

; 207  :         g_pfnMonitorFromWindow   = NULL;

	mov	DWORD PTR _g_pfnMonitorFromWindow, 0

; 208  :         g_pfnMonitorFromRect     = NULL;

	mov	DWORD PTR _g_pfnMonitorFromRect, 0

; 209  :         g_pfnMonitorFromPoint    = NULL;

	mov	DWORD PTR _g_pfnMonitorFromPoint, 0

; 210  :         g_pfnGetMonitorInfo      = NULL;

	mov	DWORD PTR _g_pfnGetMonitorInfo, 0

; 211  :         g_pfnEnumDisplayMonitors = NULL;

	mov	DWORD PTR _g_pfnEnumDisplayMonitors, 0

; 212  :         g_pfnEnumDisplayDevices  = NULL;

	mov	DWORD PTR _g_pfnEnumDisplayDevices, 0

; 213  : 
; 214  :         g_fMultiMonInitDone = TRUE;

	mov	DWORD PTR _g_fMultiMonInitDone, 1

; 215  :         return FALSE;

	xor	eax, eax
$LN4@InitMultip:

; 216  :     }
; 217  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_InitMultipleMonitorStubs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\include\multimon.h
;	COMDAT _IsPlatformNT
_TEXT	SEGMENT
tv69 = -356						; size = 4
_osvi$ = -156						; size = 148
__$ArrayPad$ = -4					; size = 4
_IsPlatformNT PROC					; COMDAT

; 169  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 356				; 00000164H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-356]
	mov	ecx, 89					; 00000059H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 170  :     OSVERSIONINFOA osvi = {0};

	mov	DWORD PTR _osvi$[ebp], 0
	push	144					; 00000090H
	push	0
	lea	eax, DWORD PTR _osvi$[ebp+4]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 171  :     osvi.dwOSVersionInfoSize = sizeof(osvi);

	mov	DWORD PTR _osvi$[ebp], 148		; 00000094H

; 172  :     GetVersionExA((OSVERSIONINFOA*)&osvi);

	mov	esi, esp
	lea	eax, DWORD PTR _osvi$[ebp]
	push	eax
	call	DWORD PTR __imp__GetVersionExA@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 173  :     return (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId);    

	cmp	DWORD PTR _osvi$[ebp+16], 2
	jne	SHORT $LN3@IsPlatform
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@IsPlatform
$LN3@IsPlatform:
	mov	DWORD PTR tv69[ebp], 0
$LN4@IsPlatform:
	mov	eax, DWORD PTR tv69[ebp]

; 174  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@IsPlatform
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 356				; 00000164H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@IsPlatform:
	DD	1
	DD	$LN6@IsPlatform
$LN6@IsPlatform:
	DD	-156					; ffffff64H
	DD	148					; 00000094H
	DD	$LN5@IsPlatform
$LN5@IsPlatform:
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	118					; 00000076H
	DB	105					; 00000069H
	DB	0
_IsPlatformNT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?SetSizeInternal@?$CGrowableArray@H@@IAEJH@Z
_TEXT	SEGMENT
tv91 = -232						; size = 4
tv85 = -232						; size = 4
_pDataNew$1 = -32					; size = 4
_nGrowBy$2 = -20					; size = 4
_this$ = -8						; size = 4
_nNewMaxSize$ = 8					; size = 4
?SetSizeInternal@?$CGrowableArray@H@@IAEJH@Z PROC	; CGrowableArray<int>::SetSizeInternal, COMDAT
; _this$ = ecx

; 670  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 671  :     if( nNewMaxSize < 0 )

	cmp	DWORD PTR _nNewMaxSize$[ebp], 0
	jge	SHORT $LN7@SetSizeInt

; 672  :     {
; 673  :         assert( false );

	xor	eax, eax
	jne	SHORT $LN10@SetSizeInt
	push	673					; 000002a1H
	push	OFFSET ??_C@_1FK@FIMIDMPE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
	push	OFFSET ??_C@_1M@HLGKFCJM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN10@SetSizeInt:

; 674  :         return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H
	jmp	$LN8@SetSizeInt
$LN7@SetSizeInt:

; 675  :     }
; 676  : 
; 677  :     if( nNewMaxSize == 0 )

	cmp	DWORD PTR _nNewMaxSize$[ebp], 0
	jne	SHORT $LN6@SetSizeInt

; 678  :     {
; 679  :         // Shrink to 0 size & cleanup
; 680  :         if( m_pData )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@SetSizeInt

; 681  :         {
; 682  :             free( m_pData );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_free
	add	esp, 4

; 683  :             m_pData = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN5@SetSizeInt:

; 684  :         }
; 685  : 
; 686  :         m_nMaxSize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 687  :         m_nSize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	jmp	$LN4@SetSizeInt
$LN6@SetSizeInt:

; 688  :     }
; 689  :     else if( m_pData == NULL || nNewMaxSize > m_nMaxSize )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@SetSizeInt
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nNewMaxSize$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jle	$LN4@SetSizeInt
$LN2@SetSizeInt:

; 690  :     {
; 691  :         // Grow array
; 692  :         int nGrowBy = ( m_nMaxSize == 0 ) ? 16 : m_nMaxSize;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN11@SetSizeInt
	mov	DWORD PTR tv85[ebp], 16			; 00000010H
	jmp	SHORT $LN12@SetSizeInt
$LN11@SetSizeInt:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv85[ebp], edx
$LN12@SetSizeInt:
	mov	eax, DWORD PTR tv85[ebp]
	mov	DWORD PTR _nGrowBy$2[ebp], eax

; 693  :         nNewMaxSize = __max( nNewMaxSize, m_nMaxSize + nGrowBy );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _nGrowBy$2[ebp]
	cmp	DWORD PTR _nNewMaxSize$[ebp], ecx
	jle	SHORT $LN13@SetSizeInt
	mov	edx, DWORD PTR _nNewMaxSize$[ebp]
	mov	DWORD PTR tv91[ebp], edx
	jmp	SHORT $LN14@SetSizeInt
$LN13@SetSizeInt:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _nGrowBy$2[ebp]
	mov	DWORD PTR tv91[ebp], ecx
$LN14@SetSizeInt:
	mov	edx, DWORD PTR tv91[ebp]
	mov	DWORD PTR _nNewMaxSize$[ebp], edx

; 694  : 
; 695  :         TYPE* pDataNew = (TYPE*) realloc( m_pData, nNewMaxSize * sizeof(TYPE) );

	mov	eax, DWORD PTR _nNewMaxSize$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_realloc
	add	esp, 8
	mov	DWORD PTR _pDataNew$1[ebp], eax

; 696  :         if( pDataNew == NULL )

	cmp	DWORD PTR _pDataNew$1[ebp], 0
	jne	SHORT $LN1@SetSizeInt

; 697  :             return E_OUTOFMEMORY;

	mov	eax, -2147024882			; 8007000eH
	jmp	SHORT $LN8@SetSizeInt
$LN1@SetSizeInt:

; 698  : 
; 699  :         m_pData = pDataNew;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pDataNew$1[ebp]
	mov	DWORD PTR [eax], ecx

; 700  :         m_nMaxSize = nNewMaxSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nNewMaxSize$[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN4@SetSizeInt:

; 701  :     }
; 702  : 
; 703  :     return S_OK;

	xor	eax, eax
$LN8@SetSizeInt:

; 704  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSizeInternal@?$CGrowableArray@H@@IAEJH@Z ENDP	; CGrowableArray<int>::SetSizeInternal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?RemoveAll@?$CGrowableArray@H@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?RemoveAll@?$CGrowableArray@H@@QAEXXZ PROC		; CGrowableArray<int>::RemoveAll, COMDAT
; _this$ = ecx

; 47   :     void    RemoveAll() { SetSize(0); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$CGrowableArray@H@@QAEJH@Z	; CGrowableArray<int>::SetSize
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CGrowableArray@H@@QAEXXZ ENDP		; CGrowableArray<int>::RemoveAll
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?GetAt@?$CGrowableArray@H@@QAEAAHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nIndex$ = 8						; size = 4
?GetAt@?$CGrowableArray@H@@QAEAAHH@Z PROC		; CGrowableArray<int>::GetAt, COMDAT
; _this$ = ecx

; 33   :     TYPE&   GetAt( int nIndex ) { assert( nIndex >= 0 && nIndex < m_nSize ); return m_pData[nIndex]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _nIndex$[ebp], 0
	jl	SHORT $LN3@GetAt
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jl	SHORT $LN4@GetAt
$LN3@GetAt:
	push	33					; 00000021H
	push	OFFSET ??_C@_1FK@FIMIDMPE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
	push	OFFSET ??_C@_1EA@JHMKKLFC@?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAm?$AA_?$AAn?$AAS?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@GetAt:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _nIndex$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetAt@?$CGrowableArray@H@@QAEAAHH@Z ENDP		; CGrowableArray<int>::GetAt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?SetAt@?$CGrowableArray@H@@QAEJHABH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nIndex$ = 8						; size = 4
_value$ = 12						; size = 4
?SetAt@?$CGrowableArray@H@@QAEJHABH@Z PROC		; CGrowableArray<int>::SetAt, COMDAT
; _this$ = ecx

; 791  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 792  :     // Validate arguments
; 793  :     if( nIndex < 0 ||
; 794  :         nIndex >= m_nSize )

	cmp	DWORD PTR _nIndex$[ebp], 0
	jl	SHORT $LN1@SetAt
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jl	SHORT $LN2@SetAt
$LN1@SetAt:

; 795  :     {
; 796  :         assert( false );

	xor	eax, eax
	jne	SHORT $LN5@SetAt
	push	796					; 0000031cH
	push	OFFSET ??_C@_1FK@FIMIDMPE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
	push	OFFSET ??_C@_1M@HLGKFCJM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN5@SetAt:

; 797  :         return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H
	jmp	SHORT $LN3@SetAt
$LN2@SetAt:

; 798  :     }
; 799  : 
; 800  :     m_pData[nIndex] = value;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _nIndex$[ebp]
	mov	eax, DWORD PTR _value$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+edx*4], eax

; 801  :     return S_OK;

	xor	eax, eax
$LN3@SetAt:

; 802  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?SetAt@?$CGrowableArray@H@@QAEJHABH@Z ENDP		; CGrowableArray<int>::SetAt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?Add@?$CGrowableArray@H@@QAEJABH@Z
_TEXT	SEGMENT
$T1 = -224						; size = 4
_hr$ = -20						; size = 4
_this$ = -8						; size = 4
_value$ = 8						; size = 4
?Add@?$CGrowableArray@H@@QAEJABH@Z PROC			; CGrowableArray<int>::Add, COMDAT
; _this$ = ecx

; 740  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 741  :     HRESULT hr;
; 742  :     if( FAILED( hr = SetSizeInternal( m_nSize + 1 ) ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSizeInternal@?$CGrowableArray@H@@IAEJH@Z ; CGrowableArray<int>::SetSizeInternal
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN1@Add

; 743  :         return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	jmp	SHORT $LN2@Add
$LN1@Add:

; 744  : 
; 745  :     // Construct the new element
; 746  :     ::new (&m_pData[m_nSize]) TYPE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*4]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax

; 747  : 
; 748  :     // Assign
; 749  :     m_pData[m_nSize] = value;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _value$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [eax+ecx*4], edx

; 750  :     ++m_nSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 751  : 
; 752  :     return S_OK;

	xor	eax, eax
$LN2@Add:

; 753  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Add@?$CGrowableArray@H@@QAEJABH@Z ENDP			; CGrowableArray<int>::Add
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?SetSize@?$CGrowableArray@H@@QAEJH@Z
_TEXT	SEGMENT
$T1 = -260						; size = 4
_i$2 = -56						; size = 4
_hr$ = -44						; size = 4
_i$3 = -32						; size = 4
_nOldSize$ = -20					; size = 4
_this$ = -8						; size = 4
_nNewMaxSize$ = 8					; size = 4
?SetSize@?$CGrowableArray@H@@QAEJH@Z PROC		; CGrowableArray<int>::SetSize, COMDAT
; _this$ = ecx

; 710  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 711  :     int nOldSize = m_nSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _nOldSize$[ebp], ecx

; 712  : 
; 713  :     if( nOldSize > nNewMaxSize )

	mov	eax, DWORD PTR _nOldSize$[ebp]
	cmp	eax, DWORD PTR _nNewMaxSize$[ebp]
	jle	SHORT $LN8@SetSize

; 714  :     {
; 715  :         // Removing elements. Call dtor.
; 716  : 
; 717  :         for( int i = nNewMaxSize; i < nOldSize; ++i )

	mov	eax, DWORD PTR _nNewMaxSize$[ebp]
	mov	DWORD PTR _i$3[ebp], eax
	jmp	SHORT $LN7@SetSize
$LN6@SetSize:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN7@SetSize:
	mov	eax, DWORD PTR _i$3[ebp]
	cmp	eax, DWORD PTR _nOldSize$[ebp]
	jge	SHORT $LN8@SetSize

; 718  :             m_pData[i].~TYPE();

	jmp	SHORT $LN6@SetSize
$LN8@SetSize:

; 719  :     }
; 720  : 
; 721  :     // Adjust buffer.  Note that there's no need to check for error
; 722  :     // since if it happens, nOldSize == nNewMaxSize will be true.)
; 723  :     HRESULT hr = SetSizeInternal( nNewMaxSize );

	mov	eax, DWORD PTR _nNewMaxSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSizeInternal@?$CGrowableArray@H@@IAEJH@Z ; CGrowableArray<int>::SetSizeInternal
	mov	DWORD PTR _hr$[ebp], eax

; 724  : 
; 725  :     if( nOldSize < nNewMaxSize )

	mov	eax, DWORD PTR _nOldSize$[ebp]
	cmp	eax, DWORD PTR _nNewMaxSize$[ebp]
	jge	SHORT $LN4@SetSize

; 726  :     {
; 727  :         // Adding elements. Call ctor.
; 728  : 
; 729  :         for( int i = nOldSize; i < nNewMaxSize; ++i )

	mov	eax, DWORD PTR _nOldSize$[ebp]
	mov	DWORD PTR _i$2[ebp], eax
	jmp	SHORT $LN3@SetSize
$LN2@SetSize:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN3@SetSize:
	mov	eax, DWORD PTR _i$2[ebp]
	cmp	eax, DWORD PTR _nNewMaxSize$[ebp]
	jge	SHORT $LN4@SetSize

; 730  :             ::new (&m_pData[i]) TYPE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$2[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	jmp	SHORT $LN2@SetSize
$LN4@SetSize:

; 731  :     }
; 732  : 
; 733  :     return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 734  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSize@?$CGrowableArray@H@@QAEJH@Z ENDP		; CGrowableArray<int>::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ??1?$CGrowableArray@H@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$CGrowableArray@H@@QAE@XZ PROC			; CGrowableArray<int>::~CGrowableArray<int>, COMDAT
; _this$ = ecx

; 22   :     ~CGrowableArray() { RemoveAll(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CGrowableArray@H@@QAEXXZ	; CGrowableArray<int>::RemoveAll
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CGrowableArray@H@@QAE@XZ ENDP			; CGrowableArray<int>::~CGrowableArray<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ??0?$CGrowableArray@H@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$CGrowableArray@H@@QAE@XZ PROC			; CGrowableArray<int>::CGrowableArray<int>, COMDAT
; _this$ = ecx

; 20   :     CGrowableArray()  { m_pData = NULL; m_nSize = 0; m_nMaxSize = 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CGrowableArray@H@@QAE@XZ ENDP			; CGrowableArray<int>::CGrowableArray<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?GetAt@?$CGrowableArray@K@@QAEAAKH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nIndex$ = 8						; size = 4
?GetAt@?$CGrowableArray@K@@QAEAAKH@Z PROC		; CGrowableArray<unsigned long>::GetAt, COMDAT
; _this$ = ecx

; 33   :     TYPE&   GetAt( int nIndex ) { assert( nIndex >= 0 && nIndex < m_nSize ); return m_pData[nIndex]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _nIndex$[ebp], 0
	jl	SHORT $LN3@GetAt
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jl	SHORT $LN4@GetAt
$LN3@GetAt:
	push	33					; 00000021H
	push	OFFSET ??_C@_1FK@FIMIDMPE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
	push	OFFSET ??_C@_1EA@JHMKKLFC@?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAm?$AA_?$AAn?$AAS?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@GetAt:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _nIndex$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetAt@?$CGrowableArray@K@@QAEAAKH@Z ENDP		; CGrowableArray<unsigned long>::GetAt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?GetSize@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetSize@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QBEHXZ PROC ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::GetSize, COMDAT
; _this$ = ecx

; 34   :     int     GetSize() const { return m_nSize; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSize@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QBEHXZ ENDP ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::GetSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?GetAt@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QAEAAPAUCD3DEnumDeviceSettingsCombo@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nIndex$ = 8						; size = 4
?GetAt@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QAEAAPAUCD3DEnumDeviceSettingsCombo@@H@Z PROC ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::GetAt, COMDAT
; _this$ = ecx

; 33   :     TYPE&   GetAt( int nIndex ) { assert( nIndex >= 0 && nIndex < m_nSize ); return m_pData[nIndex]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _nIndex$[ebp], 0
	jl	SHORT $LN3@GetAt
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jl	SHORT $LN4@GetAt
$LN3@GetAt:
	push	33					; 00000021H
	push	OFFSET ??_C@_1FK@FIMIDMPE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
	push	OFFSET ??_C@_1EA@JHMKKLFC@?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAm?$AA_?$AAn?$AAS?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@GetAt:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _nIndex$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetAt@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QAEAAPAUCD3DEnumDeviceSettingsCombo@@H@Z ENDP ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::GetAt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?GetSize@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetSize@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QBEHXZ PROC ; CGrowableArray<CD3DEnumDeviceInfo *>::GetSize, COMDAT
; _this$ = ecx

; 34   :     int     GetSize() const { return m_nSize; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSize@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QBEHXZ ENDP ; CGrowableArray<CD3DEnumDeviceInfo *>::GetSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?GetAt@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QAEAAPAVCD3DEnumDeviceInfo@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nIndex$ = 8						; size = 4
?GetAt@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QAEAAPAVCD3DEnumDeviceInfo@@H@Z PROC ; CGrowableArray<CD3DEnumDeviceInfo *>::GetAt, COMDAT
; _this$ = ecx

; 33   :     TYPE&   GetAt( int nIndex ) { assert( nIndex >= 0 && nIndex < m_nSize ); return m_pData[nIndex]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _nIndex$[ebp], 0
	jl	SHORT $LN3@GetAt
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jl	SHORT $LN4@GetAt
$LN3@GetAt:
	push	33					; 00000021H
	push	OFFSET ??_C@_1FK@FIMIDMPE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
	push	OFFSET ??_C@_1EA@JHMKKLFC@?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAm?$AA_?$AAn?$AAS?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@GetAt:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _nIndex$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetAt@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QAEAAPAVCD3DEnumDeviceInfo@@H@Z ENDP ; CGrowableArray<CD3DEnumDeviceInfo *>::GetAt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?GetSize@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetSize@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QBEHXZ PROC ; CGrowableArray<_D3DDISPLAYMODE>::GetSize, COMDAT
; _this$ = ecx

; 34   :     int     GetSize() const { return m_nSize; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSize@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QBEHXZ ENDP ; CGrowableArray<_D3DDISPLAYMODE>::GetSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?GetAt@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAEAAU_D3DDISPLAYMODE@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nIndex$ = 8						; size = 4
?GetAt@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAEAAU_D3DDISPLAYMODE@@H@Z PROC ; CGrowableArray<_D3DDISPLAYMODE>::GetAt, COMDAT
; _this$ = ecx

; 33   :     TYPE&   GetAt( int nIndex ) { assert( nIndex >= 0 && nIndex < m_nSize ); return m_pData[nIndex]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _nIndex$[ebp], 0
	jl	SHORT $LN3@GetAt
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jl	SHORT $LN4@GetAt
$LN3@GetAt:
	push	33					; 00000021H
	push	OFFSET ??_C@_1FK@FIMIDMPE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
	push	OFFSET ??_C@_1EA@JHMKKLFC@?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAm?$AA_?$AAn?$AAS?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@GetAt:
	mov	eax, DWORD PTR _nIndex$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetAt@?$CGrowableArray@U_D3DDISPLAYMODE@@@@QAEAAU_D3DDISPLAYMODE@@H@Z ENDP ; CGrowableArray<_D3DDISPLAYMODE>::GetAt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?GetSize@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetSize@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QBEHXZ PROC ; CGrowableArray<CD3DEnumAdapterInfo *>::GetSize, COMDAT
; _this$ = ecx

; 34   :     int     GetSize() const { return m_nSize; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSize@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QBEHXZ ENDP ; CGrowableArray<CD3DEnumAdapterInfo *>::GetSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?GetAt@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAEAAPAVCD3DEnumAdapterInfo@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nIndex$ = 8						; size = 4
?GetAt@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAEAAPAVCD3DEnumAdapterInfo@@H@Z PROC ; CGrowableArray<CD3DEnumAdapterInfo *>::GetAt, COMDAT
; _this$ = ecx

; 33   :     TYPE&   GetAt( int nIndex ) { assert( nIndex >= 0 && nIndex < m_nSize ); return m_pData[nIndex]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _nIndex$[ebp], 0
	jl	SHORT $LN3@GetAt
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jl	SHORT $LN4@GetAt
$LN3@GetAt:
	push	33					; 00000021H
	push	OFFSET ??_C@_1FK@FIMIDMPE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
	push	OFFSET ??_C@_1EA@JHMKKLFC@?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAm?$AA_?$AAn?$AAS?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@GetAt:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _nIndex$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetAt@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAEAAPAVCD3DEnumAdapterInfo@@H@Z ENDP ; CGrowableArray<CD3DEnumAdapterInfo *>::GetAt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?IndexOf@?$CGrowableArray@I@@QAEHABIHH@Z
_TEXT	SEGMENT
_i$1 = -20						; size = 4
_this$ = -8						; size = 4
_value$ = 8						; size = 4
_iStart$ = 12						; size = 4
_nNumElements$ = 16					; size = 4
?IndexOf@?$CGrowableArray@I@@QAEHABIHH@Z PROC		; CGrowableArray<unsigned int>::IndexOf, COMDAT
; _this$ = ecx

; 813  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 814  :     // Validate arguments
; 815  :     if( iStart < 0 || 
; 816  :         iStart >= m_nSize ||
; 817  :         nNumElements < 0 ||
; 818  :         iStart + nNumElements > m_nSize )

	cmp	DWORD PTR _iStart$[ebp], 0
	jl	SHORT $LN5@IndexOf
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iStart$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $LN5@IndexOf
	cmp	DWORD PTR _nNumElements$[ebp], 0
	jl	SHORT $LN5@IndexOf
	mov	eax, DWORD PTR _iStart$[ebp]
	add	eax, DWORD PTR _nNumElements$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [ecx+4]
	jle	SHORT $LN6@IndexOf
$LN5@IndexOf:

; 819  :     {
; 820  :         assert( false );

	xor	eax, eax
	jne	SHORT $LN9@IndexOf
	push	820					; 00000334H
	push	OFFSET ??_C@_1FK@FIMIDMPE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
	push	OFFSET ??_C@_1M@HLGKFCJM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN9@IndexOf:

; 821  :         return -1;

	or	eax, -1
	jmp	SHORT $LN7@IndexOf
$LN6@IndexOf:

; 822  :     }
; 823  : 
; 824  :     // Search
; 825  :     for( int i = iStart; i < (iStart + nNumElements); i++ )

	mov	eax, DWORD PTR _iStart$[ebp]
	mov	DWORD PTR _i$1[ebp], eax
	jmp	SHORT $LN4@IndexOf
$LN3@IndexOf:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@IndexOf:
	mov	eax, DWORD PTR _iStart$[ebp]
	add	eax, DWORD PTR _nNumElements$[ebp]
	cmp	DWORD PTR _i$1[ebp], eax
	jge	SHORT $LN2@IndexOf

; 826  :     {
; 827  :         if( value == m_pData[i] )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _value$[ebp]
	mov	eax, DWORD PTR _i$1[ebp]
	mov	edx, DWORD PTR [edx]
	cmp	edx, DWORD PTR [ecx+eax*4]
	jne	SHORT $LN1@IndexOf

; 828  :             return i;

	mov	eax, DWORD PTR _i$1[ebp]
	jmp	SHORT $LN7@IndexOf
$LN1@IndexOf:

; 829  :     }

	jmp	SHORT $LN3@IndexOf
$LN2@IndexOf:

; 830  : 
; 831  :     // Not found
; 832  :     return -1;

	or	eax, -1
$LN7@IndexOf:

; 833  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?IndexOf@?$CGrowableArray@I@@QAEHABIHH@Z ENDP		; CGrowableArray<unsigned int>::IndexOf
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?IndexOf@?$CGrowableArray@I@@QAEHABI@Z
_TEXT	SEGMENT
tv72 = -208						; size = 4
_this$ = -8						; size = 4
_value$ = 8						; size = 4
?IndexOf@?$CGrowableArray@I@@QAEHABI@Z PROC		; CGrowableArray<unsigned int>::IndexOf, COMDAT
; _this$ = ecx

; 38   :     int     IndexOf( const TYPE& value ) { return ( m_nSize > 0 ) ? IndexOf( value, 0, m_nSize ) : -1; }

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jle	SHORT $LN3@IndexOf
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	push	0
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IndexOf@?$CGrowableArray@I@@QAEHABIHH@Z ; CGrowableArray<unsigned int>::IndexOf
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@IndexOf
$LN3@IndexOf:
	mov	DWORD PTR tv72[ebp], -1
$LN4@IndexOf:
	mov	eax, DWORD PTR tv72[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?IndexOf@?$CGrowableArray@I@@QAEHABI@Z ENDP		; CGrowableArray<unsigned int>::IndexOf
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?Contains@?$CGrowableArray@I@@QAE_NABI@Z
_TEXT	SEGMENT
tv68 = -208						; size = 4
_this$ = -8						; size = 4
_value$ = 8						; size = 4
?Contains@?$CGrowableArray@I@@QAE_NABI@Z PROC		; CGrowableArray<unsigned int>::Contains, COMDAT
; _this$ = ecx

; 36   :     bool    Contains( const TYPE& value ){ return ( -1 != IndexOf( value ) ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IndexOf@?$CGrowableArray@I@@QAEHABI@Z	; CGrowableArray<unsigned int>::IndexOf
	cmp	eax, -1
	je	SHORT $LN3@Contains
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@Contains
$LN3@Contains:
	mov	DWORD PTR tv68[ebp], 0
$LN4@Contains:
	mov	al, BYTE PTR tv68[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Contains@?$CGrowableArray@I@@QAE_NABI@Z ENDP		; CGrowableArray<unsigned int>::Contains
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?GetSize@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetSize@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QBEHXZ PROC ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::GetSize, COMDAT
; _this$ = ecx

; 34   :     int     GetSize() const { return m_nSize; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSize@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QBEHXZ ENDP ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::GetSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?GetAt@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEAAW4_D3DMULTISAMPLE_TYPE@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nIndex$ = 8						; size = 4
?GetAt@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEAAW4_D3DMULTISAMPLE_TYPE@@H@Z PROC ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::GetAt, COMDAT
; _this$ = ecx

; 33   :     TYPE&   GetAt( int nIndex ) { assert( nIndex >= 0 && nIndex < m_nSize ); return m_pData[nIndex]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _nIndex$[ebp], 0
	jl	SHORT $LN3@GetAt
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jl	SHORT $LN4@GetAt
$LN3@GetAt:
	push	33					; 00000021H
	push	OFFSET ??_C@_1FK@FIMIDMPE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
	push	OFFSET ??_C@_1EA@JHMKKLFC@?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAm?$AA_?$AAn?$AAS?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@GetAt:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _nIndex$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetAt@?$CGrowableArray@W4_D3DMULTISAMPLE_TYPE@@@@QAEAAW4_D3DMULTISAMPLE_TYPE@@H@Z ENDP ; CGrowableArray<enum _D3DMULTISAMPLE_TYPE>::GetAt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?IndexOf@?$CGrowableArray@W4_D3DFORMAT@@@@QAEHABW4_D3DFORMAT@@HH@Z
_TEXT	SEGMENT
_i$1 = -20						; size = 4
_this$ = -8						; size = 4
_value$ = 8						; size = 4
_iStart$ = 12						; size = 4
_nNumElements$ = 16					; size = 4
?IndexOf@?$CGrowableArray@W4_D3DFORMAT@@@@QAEHABW4_D3DFORMAT@@HH@Z PROC ; CGrowableArray<enum _D3DFORMAT>::IndexOf, COMDAT
; _this$ = ecx

; 813  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 814  :     // Validate arguments
; 815  :     if( iStart < 0 || 
; 816  :         iStart >= m_nSize ||
; 817  :         nNumElements < 0 ||
; 818  :         iStart + nNumElements > m_nSize )

	cmp	DWORD PTR _iStart$[ebp], 0
	jl	SHORT $LN5@IndexOf
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iStart$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $LN5@IndexOf
	cmp	DWORD PTR _nNumElements$[ebp], 0
	jl	SHORT $LN5@IndexOf
	mov	eax, DWORD PTR _iStart$[ebp]
	add	eax, DWORD PTR _nNumElements$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [ecx+4]
	jle	SHORT $LN6@IndexOf
$LN5@IndexOf:

; 819  :     {
; 820  :         assert( false );

	xor	eax, eax
	jne	SHORT $LN9@IndexOf
	push	820					; 00000334H
	push	OFFSET ??_C@_1FK@FIMIDMPE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
	push	OFFSET ??_C@_1M@HLGKFCJM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN9@IndexOf:

; 821  :         return -1;

	or	eax, -1
	jmp	SHORT $LN7@IndexOf
$LN6@IndexOf:

; 822  :     }
; 823  : 
; 824  :     // Search
; 825  :     for( int i = iStart; i < (iStart + nNumElements); i++ )

	mov	eax, DWORD PTR _iStart$[ebp]
	mov	DWORD PTR _i$1[ebp], eax
	jmp	SHORT $LN4@IndexOf
$LN3@IndexOf:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@IndexOf:
	mov	eax, DWORD PTR _iStart$[ebp]
	add	eax, DWORD PTR _nNumElements$[ebp]
	cmp	DWORD PTR _i$1[ebp], eax
	jge	SHORT $LN2@IndexOf

; 826  :     {
; 827  :         if( value == m_pData[i] )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _value$[ebp]
	mov	eax, DWORD PTR _i$1[ebp]
	mov	edx, DWORD PTR [edx]
	cmp	edx, DWORD PTR [ecx+eax*4]
	jne	SHORT $LN1@IndexOf

; 828  :             return i;

	mov	eax, DWORD PTR _i$1[ebp]
	jmp	SHORT $LN7@IndexOf
$LN1@IndexOf:

; 829  :     }

	jmp	SHORT $LN3@IndexOf
$LN2@IndexOf:

; 830  : 
; 831  :     // Not found
; 832  :     return -1;

	or	eax, -1
$LN7@IndexOf:

; 833  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?IndexOf@?$CGrowableArray@W4_D3DFORMAT@@@@QAEHABW4_D3DFORMAT@@HH@Z ENDP ; CGrowableArray<enum _D3DFORMAT>::IndexOf
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?IndexOf@?$CGrowableArray@W4_D3DFORMAT@@@@QAEHABW4_D3DFORMAT@@@Z
_TEXT	SEGMENT
tv72 = -208						; size = 4
_this$ = -8						; size = 4
_value$ = 8						; size = 4
?IndexOf@?$CGrowableArray@W4_D3DFORMAT@@@@QAEHABW4_D3DFORMAT@@@Z PROC ; CGrowableArray<enum _D3DFORMAT>::IndexOf, COMDAT
; _this$ = ecx

; 38   :     int     IndexOf( const TYPE& value ) { return ( m_nSize > 0 ) ? IndexOf( value, 0, m_nSize ) : -1; }

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jle	SHORT $LN3@IndexOf
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	push	0
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IndexOf@?$CGrowableArray@W4_D3DFORMAT@@@@QAEHABW4_D3DFORMAT@@HH@Z ; CGrowableArray<enum _D3DFORMAT>::IndexOf
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@IndexOf
$LN3@IndexOf:
	mov	DWORD PTR tv72[ebp], -1
$LN4@IndexOf:
	mov	eax, DWORD PTR tv72[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?IndexOf@?$CGrowableArray@W4_D3DFORMAT@@@@QAEHABW4_D3DFORMAT@@@Z ENDP ; CGrowableArray<enum _D3DFORMAT>::IndexOf
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?Contains@?$CGrowableArray@W4_D3DFORMAT@@@@QAE_NABW4_D3DFORMAT@@@Z
_TEXT	SEGMENT
tv68 = -208						; size = 4
_this$ = -8						; size = 4
_value$ = 8						; size = 4
?Contains@?$CGrowableArray@W4_D3DFORMAT@@@@QAE_NABW4_D3DFORMAT@@@Z PROC ; CGrowableArray<enum _D3DFORMAT>::Contains, COMDAT
; _this$ = ecx

; 36   :     bool    Contains( const TYPE& value ){ return ( -1 != IndexOf( value ) ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IndexOf@?$CGrowableArray@W4_D3DFORMAT@@@@QAEHABW4_D3DFORMAT@@@Z ; CGrowableArray<enum _D3DFORMAT>::IndexOf
	cmp	eax, -1
	je	SHORT $LN3@Contains
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@Contains
$LN3@Contains:
	mov	DWORD PTR tv68[ebp], 0
$LN4@Contains:
	mov	al, BYTE PTR tv68[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Contains@?$CGrowableArray@W4_D3DFORMAT@@@@QAE_NABW4_D3DFORMAT@@@Z ENDP ; CGrowableArray<enum _D3DFORMAT>::Contains
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?GetSize@?$CGrowableArray@W4_D3DFORMAT@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetSize@?$CGrowableArray@W4_D3DFORMAT@@@@QBEHXZ PROC	; CGrowableArray<enum _D3DFORMAT>::GetSize, COMDAT
; _this$ = ecx

; 34   :     int     GetSize() const { return m_nSize; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSize@?$CGrowableArray@W4_D3DFORMAT@@@@QBEHXZ ENDP	; CGrowableArray<enum _D3DFORMAT>::GetSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxutmisc.h
;	COMDAT ?GetAt@?$CGrowableArray@W4_D3DFORMAT@@@@QAEAAW4_D3DFORMAT@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nIndex$ = 8						; size = 4
?GetAt@?$CGrowableArray@W4_D3DFORMAT@@@@QAEAAW4_D3DFORMAT@@H@Z PROC ; CGrowableArray<enum _D3DFORMAT>::GetAt, COMDAT
; _this$ = ecx

; 33   :     TYPE&   GetAt( int nIndex ) { assert( nIndex >= 0 && nIndex < m_nSize ); return m_pData[nIndex]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _nIndex$[ebp], 0
	jl	SHORT $LN3@GetAt
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jl	SHORT $LN4@GetAt
$LN3@GetAt:
	push	33					; 00000021H
	push	OFFSET ??_C@_1FK@FIMIDMPE@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
	push	OFFSET ??_C@_1EA@JHMKKLFC@?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAm?$AA_?$AAn?$AAS?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@GetAt:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _nIndex$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetAt@?$CGrowableArray@W4_D3DFORMAT@@@@QAEAAW4_D3DFORMAT@@H@Z ENDP ; CGrowableArray<enum _D3DFORMAT>::GetAt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTTrace@@YGJPBDKJ0_N@Z
_TEXT	SEGMENT
_bShowMsgBoxOnError$ = -5				; size = 1
_strFile$ = 8						; size = 4
_dwLine$ = 12						; size = 4
_hr$ = 16						; size = 4
_strMsg$ = 20						; size = 4
_bPopMsgBox$ = 24					; size = 1
?DXUTTrace@@YGJPBDKJ0_N@Z PROC				; DXUTTrace, COMDAT

; 4683 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4684 :     bool bShowMsgBoxOnError = GetDXUTState().GetShowMsgBoxOnError();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetShowMsgBoxOnError@DXUTState@@QAE_NXZ ; DXUTState::GetShowMsgBoxOnError
	mov	BYTE PTR _bShowMsgBoxOnError$[ebp], al

; 4685 :     if( bPopMsgBox && bShowMsgBoxOnError == false )

	movzx	eax, BYTE PTR _bPopMsgBox$[ebp]
	test	eax, eax
	je	SHORT $LN1@DXUTTrace
	movzx	eax, BYTE PTR _bShowMsgBoxOnError$[ebp]
	test	eax, eax
	jne	SHORT $LN1@DXUTTrace

; 4686 :         bPopMsgBox = false;

	mov	BYTE PTR _bPopMsgBox$[ebp], 0
$LN1@DXUTTrace:

; 4687 : 
; 4688 :     return DXTrace( strFile, dwLine, hr, strMsg, bPopMsgBox );

	movzx	eax, BYTE PTR _bPopMsgBox$[ebp]
	push	eax
	mov	ecx, DWORD PTR _strMsg$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hr$[ebp]
	push	edx
	mov	eax, DWORD PTR _dwLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _strFile$[ebp]
	push	ecx
	call	?DXTraceWrapper@@YGJPBDKJ0H@Z		; DXTraceWrapper

; 4689 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?DXUTTrace@@YGJPBDKJ0_N@Z ENDP				; DXUTTrace
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTCleanup3DEnvironment@@YAX_N@Z
_TEXT	SEGMENT
$T1 = -272						; size = 4
_pd3dCaps$2 = -68					; size = 4
_pbackBufferSurfaceDesc$3 = -56				; size = 4
_pOldDeviceSettings$4 = -44				; size = 4
_pCallbackDeviceDestroyed$5 = -32			; size = 4
_pCallbackDeviceLost$6 = -20				; size = 4
_pd3dDevice$ = -8					; size = 4
_bReleaseSettings$ = 8					; size = 1
?DXUTCleanup3DEnvironment@@YAX_N@Z PROC			; DXUTCleanup3DEnvironment, COMDAT

; 4346 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-276]
	mov	ecx, 69					; 00000045H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4347 :     IDirect3DDevice9* pd3dDevice = DXUTGetD3DDevice();

	call	?DXUTGetD3DDevice@@YAPAUIDirect3DDevice9@@XZ ; DXUTGetD3DDevice
	mov	DWORD PTR _pd3dDevice$[ebp], eax

; 4348 :     if( pd3dDevice != NULL )

	cmp	DWORD PTR _pd3dDevice$[ebp], 0
	je	$LN10@DXUTCleanu

; 4349 :     {
; 4350 :         GetDXUTState().SetInsideDeviceCallback( true );

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetInsideDeviceCallback@DXUTState@@QAEX_N@Z ; DXUTState::SetInsideDeviceCallback

; 4351 : 
; 4352 :         // Call the app's device lost callback
; 4353 :         if( GetDXUTState().GetDeviceObjectsReset() == true )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetDeviceObjectsReset@DXUTState@@QAE_NXZ ; DXUTState::GetDeviceObjectsReset
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN8@DXUTCleanu

; 4354 :         {
; 4355 :             LPDXUTCALLBACKDEVICELOST pCallbackDeviceLost = GetDXUTState().GetDeviceLostFunc();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetDeviceLostFunc@DXUTState@@QAEP6GXPAX@ZXZ ; DXUTState::GetDeviceLostFunc
	mov	DWORD PTR _pCallbackDeviceLost$6[ebp], eax

; 4356 :             if( pCallbackDeviceLost != NULL )

	cmp	DWORD PTR _pCallbackDeviceLost$6[ebp], 0
	je	SHORT $LN7@DXUTCleanu

; 4357 :                 pCallbackDeviceLost( GetDXUTState().GetDeviceLostFuncUserContext() );

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetDeviceLostFuncUserContext@DXUTState@@QAEPAXXZ ; DXUTState::GetDeviceLostFuncUserContext
	mov	esi, esp
	push	eax
	call	DWORD PTR _pCallbackDeviceLost$6[ebp]
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@DXUTCleanu:

; 4358 :             GetDXUTState().SetDeviceObjectsReset( false );

	push	0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetDeviceObjectsReset@DXUTState@@QAEX_N@Z ; DXUTState::SetDeviceObjectsReset

; 4359 : 
; 4360 :             // Call the resource cache device lost function
; 4361 :             DXUTGetGlobalResourceCache().OnLostDevice();

	call	?DXUTGetGlobalResourceCache@@YAAAVCDXUTResourceCache@@XZ ; DXUTGetGlobalResourceCache
	mov	ecx, eax
	call	?OnLostDevice@CDXUTResourceCache@@QAEJXZ ; CDXUTResourceCache::OnLostDevice
$LN8@DXUTCleanu:

; 4362 :         }
; 4363 : 
; 4364 :         // Call the app's device destroyed callback
; 4365 :         if( GetDXUTState().GetDeviceObjectsCreated() == true )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetDeviceObjectsCreated@DXUTState@@QAE_NXZ ; DXUTState::GetDeviceObjectsCreated
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN6@DXUTCleanu

; 4366 :         {
; 4367 :             LPDXUTCALLBACKDEVICEDESTROYED pCallbackDeviceDestroyed = GetDXUTState().GetDeviceDestroyedFunc();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetDeviceDestroyedFunc@DXUTState@@QAEP6GXPAX@ZXZ ; DXUTState::GetDeviceDestroyedFunc
	mov	DWORD PTR _pCallbackDeviceDestroyed$5[ebp], eax

; 4368 :             if( pCallbackDeviceDestroyed != NULL )

	cmp	DWORD PTR _pCallbackDeviceDestroyed$5[ebp], 0
	je	SHORT $LN5@DXUTCleanu

; 4369 :                 pCallbackDeviceDestroyed( GetDXUTState().GetDeviceDestroyedFuncUserContext() );

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetDeviceDestroyedFuncUserContext@DXUTState@@QAEPAXXZ ; DXUTState::GetDeviceDestroyedFuncUserContext
	mov	esi, esp
	push	eax
	call	DWORD PTR _pCallbackDeviceDestroyed$5[ebp]
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@DXUTCleanu:

; 4370 :             GetDXUTState().SetDeviceObjectsCreated( false );

	push	0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetDeviceObjectsCreated@DXUTState@@QAEX_N@Z ; DXUTState::SetDeviceObjectsCreated

; 4371 : 
; 4372 :             // Call the resource cache device destory function
; 4373 :             DXUTGetGlobalResourceCache().OnDestroyDevice();

	call	?DXUTGetGlobalResourceCache@@YAAAVCDXUTResourceCache@@XZ ; DXUTGetGlobalResourceCache
	mov	ecx, eax
	call	?OnDestroyDevice@CDXUTResourceCache@@QAEJXZ ; CDXUTResourceCache::OnDestroyDevice
$LN6@DXUTCleanu:

; 4374 :         }
; 4375 : 
; 4376 :         GetDXUTState().SetInsideDeviceCallback( false );

	push	0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetInsideDeviceCallback@DXUTState@@QAEX_N@Z ; DXUTState::SetInsideDeviceCallback

; 4377 : 
; 4378 :         // Release the D3D device and in debug configs, displays a message box if there 
; 4379 :         // are unrelease objects.
; 4380 :         if( pd3dDevice )

	cmp	DWORD PTR _pd3dDevice$[ebp], 0
	je	SHORT $LN4@DXUTCleanu

; 4381 :         {
; 4382 :             if( pd3dDevice->Release() > 0 )  

	mov	eax, DWORD PTR _pd3dDevice$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR _pd3dDevice$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jbe	SHORT $LN4@DXUTCleanu

; 4383 :             {
; 4384 :                 DXUTDisplayErrorMessage( DXUTERR_NONZEROREFCOUNT );

	push	-2147219196				; 80040904H
	call	?DXUTDisplayErrorMessage@@YAXJ@Z	; DXUTDisplayErrorMessage
	add	esp, 4

; 4385 :                 DXUT_ERR( "DXUTCleanup3DEnvironment", DXUTERR_NONZEROREFCOUNT );

	push	0
	push	OFFSET ??_C@_0BJ@MCGMIGD@DXUTCleanup3DEnvironment?$AA@
	push	-2147219196				; 80040904H
	mov	eax, DWORD PTR ?__LINE__Var@?1??DXUTCleanup3DEnvironment@@YAX_N@Z@4JA
	add	eax, 39					; 00000027H
	push	eax
	push	OFFSET ??_C@_0CL@KBAHBIDF@z?3?2sampsrc?202xu1?2saco?2d3d9?2commo@
	call	?DXUTTrace@@YGJPBDKJ0_N@Z		; DXUTTrace
$LN4@DXUTCleanu:

; 4386 :             }
; 4387 :         }
; 4388 :         GetDXUTState().SetD3DDevice( NULL );

	push	0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetD3DDevice@DXUTState@@QAEXPAUIDirect3DDevice9@@@Z ; DXUTState::SetD3DDevice

; 4389 : 
; 4390 :         if( bReleaseSettings )

	movzx	eax, BYTE PTR _bReleaseSettings$[ebp]
	test	eax, eax
	je	SHORT $LN2@DXUTCleanu

; 4391 :         {
; 4392 :             DXUTDeviceSettings* pOldDeviceSettings = GetDXUTState().GetCurrentDeviceSettings();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetCurrentDeviceSettings@DXUTState@@QAEPAUDXUTDeviceSettings@@XZ ; DXUTState::GetCurrentDeviceSettings
	mov	DWORD PTR _pOldDeviceSettings$4[ebp], eax

; 4393 :             SAFE_DELETE(pOldDeviceSettings);  

	cmp	DWORD PTR _pOldDeviceSettings$4[ebp], 0
	je	SHORT $LN1@DXUTCleanu
	mov	eax, DWORD PTR _pOldDeviceSettings$4[ebp]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	DWORD PTR _pOldDeviceSettings$4[ebp], 0
$LN1@DXUTCleanu:

; 4394 :             GetDXUTState().SetCurrentDeviceSettings( NULL );

	push	0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetCurrentDeviceSettings@DXUTState@@QAEXPAUDXUTDeviceSettings@@@Z ; DXUTState::SetCurrentDeviceSettings
$LN2@DXUTCleanu:

; 4395 :         }
; 4396 : 
; 4397 :         D3DSURFACE_DESC* pbackBufferSurfaceDesc = GetDXUTState().GetBackBufferSurfaceDesc();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetBackBufferSurfaceDesc@DXUTState@@QAEPAU_D3DSURFACE_DESC@@XZ ; DXUTState::GetBackBufferSurfaceDesc
	mov	DWORD PTR _pbackBufferSurfaceDesc$3[ebp], eax

; 4398 :         ZeroMemory( pbackBufferSurfaceDesc, sizeof(D3DSURFACE_DESC) );

	push	32					; 00000020H
	push	0
	mov	eax, DWORD PTR _pbackBufferSurfaceDesc$3[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 4399 : 
; 4400 :         D3DCAPS9* pd3dCaps = GetDXUTState().GetCaps();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetCaps@DXUTState@@QAEPAU_D3DCAPS9@@XZ	; DXUTState::GetCaps
	mov	DWORD PTR _pd3dCaps$2[ebp], eax

; 4401 :         ZeroMemory( pd3dCaps, sizeof(D3DCAPS9) );

	push	304					; 00000130H
	push	0
	mov	eax, DWORD PTR _pd3dCaps$2[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 4402 : 
; 4403 :         GetDXUTState().SetDeviceCreated( false );

	push	0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetDeviceCreated@DXUTState@@QAEX_N@Z	; DXUTState::SetDeviceCreated
$LN10@DXUTCleanu:

; 4404 :     }
; 4405 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTCleanup3DEnvironment@@YAX_N@Z ENDP			; DXUTCleanup3DEnvironment
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTReset3DEnvironment@@YAJXZ
_TEXT	SEGMENT
_pCallbackDeviceLost$1 = -80				; size = 4
_pCallbackDeviceReset$ = -68				; size = 4
_pbackBufferSurfaceDesc$ = -56				; size = 4
_pDeviceSettings$ = -44					; size = 4
_pCallbackDeviceLost$2 = -32				; size = 4
_pd3dDevice$ = -20					; size = 4
_hr$ = -8						; size = 4
?DXUTReset3DEnvironment@@YAJXZ PROC			; DXUTReset3DEnvironment, COMDAT

; 3276 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-276]
	mov	ecx, 69					; 00000045H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3277 :     HRESULT hr;
; 3278 : 
; 3279 :     IDirect3DDevice9* pd3dDevice = DXUTGetD3DDevice();

	call	?DXUTGetD3DDevice@@YAPAUIDirect3DDevice9@@XZ ; DXUTGetD3DDevice
	mov	DWORD PTR _pd3dDevice$[ebp], eax

; 3280 :     assert( pd3dDevice != NULL );

	cmp	DWORD PTR _pd3dDevice$[ebp], 0
	jne	SHORT $LN13@DXUTReset3
	mov	eax, DWORD PTR ?__LINE__Var@?1??DXUTReset3DEnvironment@@YAJXZ@4JA
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_1FG@OJNOEDOF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
	push	OFFSET ??_C@_1CG@LNDKPHPB@?$AAp?$AAd?$AA3?$AAd?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN13@DXUTReset3:

; 3281 : 
; 3282 :     // Call the app's device lost callback
; 3283 :     if( GetDXUTState().GetDeviceObjectsReset() == true )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetDeviceObjectsReset@DXUTState@@QAE_NXZ ; DXUTState::GetDeviceObjectsReset
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN10@DXUTReset3

; 3284 :     {
; 3285 :         GetDXUTState().SetInsideDeviceCallback( true );

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetInsideDeviceCallback@DXUTState@@QAEX_N@Z ; DXUTState::SetInsideDeviceCallback

; 3286 :         LPDXUTCALLBACKDEVICELOST pCallbackDeviceLost = GetDXUTState().GetDeviceLostFunc();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetDeviceLostFunc@DXUTState@@QAEP6GXPAX@ZXZ ; DXUTState::GetDeviceLostFunc
	mov	DWORD PTR _pCallbackDeviceLost$2[ebp], eax

; 3287 :         if( pCallbackDeviceLost != NULL )

	cmp	DWORD PTR _pCallbackDeviceLost$2[ebp], 0
	je	SHORT $LN9@DXUTReset3

; 3288 :             pCallbackDeviceLost( GetDXUTState().GetDeviceLostFuncUserContext() );

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetDeviceLostFuncUserContext@DXUTState@@QAEPAXXZ ; DXUTState::GetDeviceLostFuncUserContext
	mov	esi, esp
	push	eax
	call	DWORD PTR _pCallbackDeviceLost$2[ebp]
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN9@DXUTReset3:

; 3289 :         GetDXUTState().SetDeviceObjectsReset( false );

	push	0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetDeviceObjectsReset@DXUTState@@QAEX_N@Z ; DXUTState::SetDeviceObjectsReset

; 3290 :         GetDXUTState().SetInsideDeviceCallback( false );

	push	0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetInsideDeviceCallback@DXUTState@@QAEX_N@Z ; DXUTState::SetInsideDeviceCallback

; 3291 : 
; 3292 :         // Call the resource cache device lost function
; 3293 :         DXUTGetGlobalResourceCache().OnLostDevice();

	call	?DXUTGetGlobalResourceCache@@YAAAVCDXUTResourceCache@@XZ ; DXUTGetGlobalResourceCache
	mov	ecx, eax
	call	?OnLostDevice@CDXUTResourceCache@@QAEJXZ ; CDXUTResourceCache::OnLostDevice
$LN10@DXUTReset3:

; 3294 :     }
; 3295 : 
; 3296 :     // Reset the device
; 3297 :     DXUTDeviceSettings* pDeviceSettings = GetDXUTState().GetCurrentDeviceSettings();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetCurrentDeviceSettings@DXUTState@@QAEPAUDXUTDeviceSettings@@XZ ; DXUTState::GetCurrentDeviceSettings
	mov	DWORD PTR _pDeviceSettings$[ebp], eax

; 3298 :     hr = pd3dDevice->Reset( &pDeviceSettings->pp );

	mov	eax, DWORD PTR _pDeviceSettings$[ebp]
	add	eax, 16					; 00000010H
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _pd3dDevice$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pd3dDevice$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+64]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 3299 :     if( FAILED(hr) )  

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN8@DXUTReset3

; 3300 :     {
; 3301 :         if( hr == D3DERR_DEVICELOST )

	cmp	DWORD PTR _hr$[ebp], -2005530520	; 88760868H
	jne	SHORT $LN7@DXUTReset3

; 3302 :             return D3DERR_DEVICELOST; // Reset could legitimately fail if the device is lost

	mov	eax, -2005530520			; 88760868H
	jmp	$LN11@DXUTReset3

; 3303 :         else

	jmp	SHORT $LN8@DXUTReset3
$LN7@DXUTReset3:

; 3304 :             return DXUT_ERR( "Reset", DXUTERR_RESETTINGDEVICE );

	push	0
	push	OFFSET ??_C@_05CCGMLFNG@Reset?$AA@
	push	-2147219194				; 80040906H
	mov	eax, DWORD PTR ?__LINE__Var@?1??DXUTReset3DEnvironment@@YAJXZ@4JA
	add	eax, 28					; 0000001cH
	push	eax
	push	OFFSET ??_C@_0CL@KBAHBIDF@z?3?2sampsrc?202xu1?2saco?2d3d9?2commo@
	call	?DXUTTrace@@YGJPBDKJ0_N@Z		; DXUTTrace
	jmp	$LN11@DXUTReset3
$LN8@DXUTReset3:

; 3305 :     }
; 3306 : 
; 3307 :     // Update back buffer desc before calling app's device callbacks
; 3308 :     DXUTUpdateBackBufferDesc();

	call	?DXUTUpdateBackBufferDesc@@YAXXZ	; DXUTUpdateBackBufferDesc

; 3309 : 
; 3310 :     hr = DXUTGetGlobalResourceCache().OnResetDevice( pd3dDevice );

	mov	eax, DWORD PTR _pd3dDevice$[ebp]
	push	eax
	call	?DXUTGetGlobalResourceCache@@YAAAVCDXUTResourceCache@@XZ ; DXUTGetGlobalResourceCache
	mov	ecx, eax
	call	?OnResetDevice@CDXUTResourceCache@@QAEJPAUIDirect3DDevice9@@@Z ; CDXUTResourceCache::OnResetDevice
	mov	DWORD PTR _hr$[ebp], eax

; 3311 :     if( FAILED(hr) )

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN5@DXUTReset3

; 3312 :         return DXUT_ERR( "OnResetDevice", DXUTERR_RESETTINGDEVICEOBJECTS );

	push	0
	push	OFFSET ??_C@_0O@JFPFAANM@OnResetDevice?$AA@
	push	-2147219192				; 80040908H
	mov	eax, DWORD PTR ?__LINE__Var@?1??DXUTReset3DEnvironment@@YAJXZ@4JA
	add	eax, 36					; 00000024H
	push	eax
	push	OFFSET ??_C@_0CL@KBAHBIDF@z?3?2sampsrc?202xu1?2saco?2d3d9?2commo@
	call	?DXUTTrace@@YGJPBDKJ0_N@Z		; DXUTTrace
	jmp	$LN11@DXUTReset3
$LN5@DXUTReset3:

; 3313 : 
; 3314 :     // Call the app's OnDeviceReset callback
; 3315 :     GetDXUTState().SetInsideDeviceCallback( true );

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetInsideDeviceCallback@DXUTState@@QAEX_N@Z ; DXUTState::SetInsideDeviceCallback

; 3316 :     const D3DSURFACE_DESC* pbackBufferSurfaceDesc = DXUTGetBackBufferSurfaceDesc();

	call	?DXUTGetBackBufferSurfaceDesc@@YAPBU_D3DSURFACE_DESC@@XZ ; DXUTGetBackBufferSurfaceDesc
	mov	DWORD PTR _pbackBufferSurfaceDesc$[ebp], eax

; 3317 :     LPDXUTCALLBACKDEVICERESET pCallbackDeviceReset = GetDXUTState().GetDeviceResetFunc();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetDeviceResetFunc@DXUTState@@QAEP6GJPAUIDirect3DDevice9@@PBU_D3DSURFACE_DESC@@PAX@ZXZ ; DXUTState::GetDeviceResetFunc
	mov	DWORD PTR _pCallbackDeviceReset$[ebp], eax

; 3318 :     hr = S_OK;

	mov	DWORD PTR _hr$[ebp], 0

; 3319 :     if( pCallbackDeviceReset != NULL )

	cmp	DWORD PTR _pCallbackDeviceReset$[ebp], 0
	je	SHORT $LN4@DXUTReset3

; 3320 :         hr = pCallbackDeviceReset( pd3dDevice, pbackBufferSurfaceDesc, GetDXUTState().GetDeviceResetFuncUserContext() );

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetDeviceResetFuncUserContext@DXUTState@@QAEPAXXZ ; DXUTState::GetDeviceResetFuncUserContext
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _pbackBufferSurfaceDesc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pd3dDevice$[ebp]
	push	ecx
	call	DWORD PTR _pCallbackDeviceReset$[ebp]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax
$LN4@DXUTReset3:

; 3321 :     GetDXUTState().SetInsideDeviceCallback( false );

	push	0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetInsideDeviceCallback@DXUTState@@QAEX_N@Z ; DXUTState::SetInsideDeviceCallback

; 3322 :     if( FAILED(hr) )

	cmp	DWORD PTR _hr$[ebp], 0
	jge	$LN3@DXUTReset3

; 3323 :     {
; 3324 :         // If callback failed, cleanup
; 3325 :         DXUT_ERR( "DeviceResetCallback", hr );

	push	0
	push	OFFSET ??_C@_0BE@FGIMCOFA@DeviceResetCallback?$AA@
	mov	eax, DWORD PTR _hr$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??DXUTReset3DEnvironment@@YAJXZ@4JA
	add	ecx, 49					; 00000031H
	push	ecx
	push	OFFSET ??_C@_0CL@KBAHBIDF@z?3?2sampsrc?202xu1?2saco?2d3d9?2commo@
	call	?DXUTTrace@@YGJPBDKJ0_N@Z		; DXUTTrace

; 3326 :         if( hr != DXUTERR_MEDIANOTFOUND )

	cmp	DWORD PTR _hr$[ebp], -2147219197	; 80040903H
	je	SHORT $LN2@DXUTReset3

; 3327 :             hr = DXUTERR_RESETTINGDEVICEOBJECTS;

	mov	DWORD PTR _hr$[ebp], -2147219192	; 80040908H
$LN2@DXUTReset3:

; 3328 : 
; 3329 :         GetDXUTState().SetInsideDeviceCallback( true );

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetInsideDeviceCallback@DXUTState@@QAEX_N@Z ; DXUTState::SetInsideDeviceCallback

; 3330 :         LPDXUTCALLBACKDEVICELOST pCallbackDeviceLost = GetDXUTState().GetDeviceLostFunc();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetDeviceLostFunc@DXUTState@@QAEP6GXPAX@ZXZ ; DXUTState::GetDeviceLostFunc
	mov	DWORD PTR _pCallbackDeviceLost$1[ebp], eax

; 3331 :         if( pCallbackDeviceLost != NULL )

	cmp	DWORD PTR _pCallbackDeviceLost$1[ebp], 0
	je	SHORT $LN1@DXUTReset3

; 3332 :             pCallbackDeviceLost( GetDXUTState().GetDeviceLostFuncUserContext() );

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetDeviceLostFuncUserContext@DXUTState@@QAEPAXXZ ; DXUTState::GetDeviceLostFuncUserContext
	mov	esi, esp
	push	eax
	call	DWORD PTR _pCallbackDeviceLost$1[ebp]
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@DXUTReset3:

; 3333 :         GetDXUTState().SetInsideDeviceCallback( false );

	push	0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetInsideDeviceCallback@DXUTState@@QAEX_N@Z ; DXUTState::SetInsideDeviceCallback

; 3334 : 
; 3335 :         DXUTGetGlobalResourceCache().OnLostDevice();       

	call	?DXUTGetGlobalResourceCache@@YAAAVCDXUTResourceCache@@XZ ; DXUTGetGlobalResourceCache
	mov	ecx, eax
	call	?OnLostDevice@CDXUTResourceCache@@QAEJXZ ; CDXUTResourceCache::OnLostDevice

; 3336 :         return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	jmp	SHORT $LN11@DXUTReset3
$LN3@DXUTReset3:

; 3337 :     }
; 3338 : 
; 3339 :     // Success
; 3340 :     GetDXUTState().SetDeviceObjectsReset( true );

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetDeviceObjectsReset@DXUTState@@QAEX_N@Z ; DXUTState::SetDeviceObjectsReset

; 3341 : 
; 3342 :     return S_OK;

	xor	eax, eax
$LN11@DXUTReset3:

; 3343 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTReset3DEnvironment@@YAJXZ ENDP			; DXUTReset3DEnvironment
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTGetAutomation@@YA_NXZ
_TEXT	SEGMENT
?DXUTGetAutomation@@YA_NXZ PROC				; DXUTGetAutomation, COMDAT

; 4541 : bool DXUTGetAutomation()                            { return GetDXUTState().GetAutomation(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetAutomation@DXUTState@@QAE_NXZ	; DXUTState::GetAutomation
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTGetAutomation@@YA_NXZ ENDP				; DXUTGetAutomation
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTIsMouseButtonDown@@YA_NE@Z
_TEXT	SEGMENT
_nIndex$ = -20						; size = 4
_bMouseButtons$ = -8					; size = 4
_vButton$ = 8						; size = 1
?DXUTIsMouseButtonDown@@YA_NE@Z PROC			; DXUTIsMouseButtonDown, COMDAT

; 4553 : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4554 :     bool* bMouseButtons = GetDXUTState().GetMouseButtons(); 

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetMouseButtons@DXUTState@@QAEPA_NXZ	; DXUTState::GetMouseButtons
	mov	DWORD PTR _bMouseButtons$[ebp], eax

; 4555 :     int nIndex = DXUTMapButtonToArrayIndex(vButton); 

	movzx	eax, BYTE PTR _vButton$[ebp]
	push	eax
	call	?DXUTMapButtonToArrayIndex@@YAHE@Z	; DXUTMapButtonToArrayIndex
	add	esp, 4
	mov	DWORD PTR _nIndex$[ebp], eax

; 4556 :     return bMouseButtons[nIndex]; 

	mov	eax, DWORD PTR _bMouseButtons$[ebp]
	add	eax, DWORD PTR _nIndex$[ebp]
	mov	al, BYTE PTR [eax]

; 4557 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTIsMouseButtonDown@@YA_NE@Z ENDP			; DXUTIsMouseButtonDown
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTIsKeyDown@@YA_NE@Z
_TEXT	SEGMENT
tv76 = -208						; size = 4
_bKeys$ = -8						; size = 4
_vKey$ = 8						; size = 1
?DXUTIsKeyDown@@YA_NE@Z PROC				; DXUTIsKeyDown, COMDAT

; 4543 : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4544 :     bool* bKeys = GetDXUTState().GetKeys(); 

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetKeys@DXUTState@@QAEPA_NXZ		; DXUTState::GetKeys
	mov	DWORD PTR _bKeys$[ebp], eax

; 4545 :     if( vKey >= 0xA0 && vKey <= 0xA5 )  // VK_LSHIFT, VK_RSHIFT, VK_LCONTROL, VK_RCONTROL, VK_LMENU, VK_RMENU

	movzx	eax, BYTE PTR _vKey$[ebp]
	cmp	eax, 160				; 000000a0H
	jl	SHORT $LN4@DXUTIsKeyD
	movzx	eax, BYTE PTR _vKey$[ebp]
	cmp	eax, 165				; 000000a5H
	jg	SHORT $LN4@DXUTIsKeyD

; 4546 :         return GetAsyncKeyState( vKey ) != 0; // these keys only are tracked via GetAsyncKeyState()

	movzx	eax, BYTE PTR _vKey$[ebp]
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__GetAsyncKeyState@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN7@DXUTIsKeyD
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN8@DXUTIsKeyD
$LN7@DXUTIsKeyD:
	mov	DWORD PTR tv76[ebp], 0
$LN8@DXUTIsKeyD:
	mov	al, BYTE PTR tv76[ebp]
	jmp	SHORT $LN5@DXUTIsKeyD
	jmp	SHORT $LN5@DXUTIsKeyD
$LN4@DXUTIsKeyD:

; 4547 :     else if( vKey >= 0x01 && vKey <= 0x06 && vKey != 0x03 ) // mouse buttons (VK_*BUTTON)

	movzx	eax, BYTE PTR _vKey$[ebp]
	cmp	eax, 1
	jl	SHORT $LN2@DXUTIsKeyD
	movzx	eax, BYTE PTR _vKey$[ebp]
	cmp	eax, 6
	jg	SHORT $LN2@DXUTIsKeyD
	movzx	eax, BYTE PTR _vKey$[ebp]
	cmp	eax, 3
	je	SHORT $LN2@DXUTIsKeyD

; 4548 :         return DXUTIsMouseButtonDown(vKey);

	movzx	eax, BYTE PTR _vKey$[ebp]
	push	eax
	call	?DXUTIsMouseButtonDown@@YA_NE@Z		; DXUTIsMouseButtonDown
	add	esp, 4
	jmp	SHORT $LN5@DXUTIsKeyD

; 4549 :     else

	jmp	SHORT $LN5@DXUTIsKeyD
$LN2@DXUTIsKeyD:

; 4550 :         return bKeys[vKey];

	movzx	eax, BYTE PTR _vKey$[ebp]
	mov	ecx, DWORD PTR _bKeys$[ebp]
	mov	al, BYTE PTR [ecx+eax]
$LN5@DXUTIsKeyD:

; 4551 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTIsKeyDown@@YA_NE@Z ENDP				; DXUTIsKeyDown
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTGetShowMsgBoxOnError@@YA_NXZ
_TEXT	SEGMENT
?DXUTGetShowMsgBoxOnError@@YA_NXZ PROC			; DXUTGetShowMsgBoxOnError, COMDAT

; 4540 : bool DXUTGetShowMsgBoxOnError()                     { return GetDXUTState().GetShowMsgBoxOnError(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetShowMsgBoxOnError@DXUTState@@QAE_NXZ ; DXUTState::GetShowMsgBoxOnError
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTGetShowMsgBoxOnError@@YA_NXZ ENDP			; DXUTGetShowMsgBoxOnError
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTGetExitCode@@YAHXZ
_TEXT	SEGMENT
?DXUTGetExitCode@@YAHXZ PROC				; DXUTGetExitCode, COMDAT

; 4539 : int DXUTGetExitCode()                               { return GetDXUTState().GetExitCode(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetExitCode@DXUTState@@QAEHXZ		; DXUTState::GetExitCode
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTGetExitCode@@YAHXZ ENDP				; DXUTGetExitCode
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTIsTimePaused@@YA_NXZ
_TEXT	SEGMENT
tv68 = -196						; size = 4
?DXUTIsTimePaused@@YA_NXZ PROC				; DXUTIsTimePaused, COMDAT

; 4538 : bool DXUTIsTimePaused()                             { return GetDXUTState().GetPauseTimeCount() > 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetPauseTimeCount@DXUTState@@QAEHXZ	; DXUTState::GetPauseTimeCount
	test	eax, eax
	jle	SHORT $LN3@DXUTIsTime
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@DXUTIsTime
$LN3@DXUTIsTime:
	mov	DWORD PTR tv68[ebp], 0
$LN4@DXUTIsTime:
	mov	al, BYTE PTR tv68[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTIsTimePaused@@YA_NXZ ENDP				; DXUTIsTimePaused
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTIsRenderingPaused@@YA_NXZ
_TEXT	SEGMENT
tv68 = -196						; size = 4
?DXUTIsRenderingPaused@@YA_NXZ PROC			; DXUTIsRenderingPaused, COMDAT

; 4537 : bool DXUTIsRenderingPaused()                        { return GetDXUTState().GetPauseRenderingCount() > 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetPauseRenderingCount@DXUTState@@QAEHXZ ; DXUTState::GetPauseRenderingCount
	test	eax, eax
	jle	SHORT $LN3@DXUTIsRend
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@DXUTIsRend
$LN3@DXUTIsRend:
	mov	DWORD PTR tv68[ebp], 0
$LN4@DXUTIsRend:
	mov	al, BYTE PTR tv68[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTIsRenderingPaused@@YA_NXZ ENDP			; DXUTIsRenderingPaused
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTGetDeviceStats@@YAPBDXZ
_TEXT	SEGMENT
?DXUTGetDeviceStats@@YAPBDXZ PROC			; DXUTGetDeviceStats, COMDAT

; 4536 : LPCTSTR DXUTGetDeviceStats()                        { return GetDXUTState().GetDeviceStats(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetDeviceStats@DXUTState@@QAEPADXZ	; DXUTState::GetDeviceStats
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTGetDeviceStats@@YAPBDXZ ENDP			; DXUTGetDeviceStats
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTGetFrameStats@@YAPBDXZ
_TEXT	SEGMENT
?DXUTGetFrameStats@@YAPBDXZ PROC			; DXUTGetFrameStats, COMDAT

; 4535 : LPCTSTR DXUTGetFrameStats()                         { return GetDXUTState().GetFrameStats(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetFrameStats@DXUTState@@QAEPADXZ	; DXUTState::GetFrameStats
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTGetFrameStats@@YAPBDXZ ENDP			; DXUTGetFrameStats
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTGetWindowTitle@@YAPBDXZ
_TEXT	SEGMENT
?DXUTGetWindowTitle@@YAPBDXZ PROC			; DXUTGetWindowTitle, COMDAT

; 4534 : LPCTSTR DXUTGetWindowTitle()                        { return GetDXUTState().GetWindowTitle(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetWindowTitle@DXUTState@@QAEPADXZ	; DXUTState::GetWindowTitle
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTGetWindowTitle@@YAPBDXZ ENDP			; DXUTGetWindowTitle
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTGetFPS@@YAMXZ
_TEXT	SEGMENT
?DXUTGetFPS@@YAMXZ PROC					; DXUTGetFPS, COMDAT

; 4533 : float DXUTGetFPS()                                  { return GetDXUTState().GetFPS(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetFPS@DXUTState@@QAEMXZ		; DXUTState::GetFPS
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTGetFPS@@YAMXZ ENDP					; DXUTGetFPS
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTIsWindowed@@YA_NXZ
_TEXT	SEGMENT
tv71 = -208						; size = 4
_pDeviceSettings$ = -8					; size = 4
?DXUTIsWindowed@@YA_NXZ PROC				; DXUTIsWindowed, COMDAT

; 4583 : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4584 :     DXUTDeviceSettings* pDeviceSettings = GetDXUTState().GetCurrentDeviceSettings(); 

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetCurrentDeviceSettings@DXUTState@@QAEPAUDXUTDeviceSettings@@XZ ; DXUTState::GetCurrentDeviceSettings
	mov	DWORD PTR _pDeviceSettings$[ebp], eax

; 4585 :     if(pDeviceSettings) 

	cmp	DWORD PTR _pDeviceSettings$[ebp], 0
	je	SHORT $LN2@DXUTIsWind

; 4586 :         return (pDeviceSettings->pp.Windowed != 0); 

	mov	eax, DWORD PTR _pDeviceSettings$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN5@DXUTIsWind
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN6@DXUTIsWind
$LN5@DXUTIsWind:
	mov	DWORD PTR tv71[ebp], 0
$LN6@DXUTIsWind:
	mov	al, BYTE PTR tv71[ebp]
	jmp	SHORT $LN3@DXUTIsWind

; 4587 :     else 

	jmp	SHORT $LN3@DXUTIsWind
$LN2@DXUTIsWind:

; 4588 :         return false; 

	xor	al, al
$LN3@DXUTIsWind:

; 4589 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTIsWindowed@@YA_NXZ ENDP				; DXUTIsWindowed
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTGetElapsedTime@@YAMXZ
_TEXT	SEGMENT
?DXUTGetElapsedTime@@YAMXZ PROC				; DXUTGetElapsedTime, COMDAT

; 4532 : float DXUTGetElapsedTime()                          { return GetDXUTState().GetElapsedTime(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetElapsedTime@DXUTState@@QAEMXZ	; DXUTState::GetElapsedTime
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTGetElapsedTime@@YAMXZ ENDP				; DXUTGetElapsedTime
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTGetTime@@YANXZ
_TEXT	SEGMENT
?DXUTGetTime@@YANXZ PROC				; DXUTGetTime, COMDAT

; 4531 : double DXUTGetTime()                                { return GetDXUTState().GetTime(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetTime@DXUTState@@QAENXZ		; DXUTState::GetTime
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTGetTime@@YANXZ ENDP				; DXUTGetTime
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTGetFullsceenClientRectAtModeChange@@YA?AUtagRECT@@XZ
_TEXT	SEGMENT
_rc$ = -24						; size = 16
__$ArrayPad$ = -4					; size = 4
$T1 = 8							; size = 4
?DXUTGetFullsceenClientRectAtModeChange@@YA?AUtagRECT@@XZ PROC ; DXUTGetFullsceenClientRectAtModeChange, COMDAT

; 4530 : RECT DXUTGetFullsceenClientRectAtModeChange()       { RECT rc = { 0, 0, GetDXUTState().GetFullScreenBackBufferWidthAtModeChange(), GetDXUTState().GetFullScreenBackBufferHeightAtModeChange() }; return rc; }

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _rc$[ebp], 0
	mov	DWORD PTR _rc$[ebp+4], 0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetFullScreenBackBufferWidthAtModeChange@DXUTState@@QAEIXZ ; DXUTState::GetFullScreenBackBufferWidthAtModeChange
	mov	DWORD PTR _rc$[ebp+8], eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetFullScreenBackBufferHeightAtModeChange@DXUTState@@QAEIXZ ; DXUTState::GetFullScreenBackBufferHeightAtModeChange
	mov	DWORD PTR _rc$[ebp+12], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	ecx, DWORD PTR _rc$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _rc$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _rc$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _rc$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@DXUTGetFul
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@DXUTGetFul:
	DD	1
	DD	$LN4@DXUTGetFul
$LN4@DXUTGetFul:
	DD	-24					; ffffffe8H
	DD	16					; 00000010H
	DD	$LN3@DXUTGetFul
$LN3@DXUTGetFul:
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	0
?DXUTGetFullsceenClientRectAtModeChange@@YA?AUtagRECT@@XZ ENDP ; DXUTGetFullsceenClientRectAtModeChange
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTGetWindowClientRectAtModeChange@@YA?AUtagRECT@@XZ
_TEXT	SEGMENT
_rc$ = -24						; size = 16
__$ArrayPad$ = -4					; size = 4
$T1 = 8							; size = 4
?DXUTGetWindowClientRectAtModeChange@@YA?AUtagRECT@@XZ PROC ; DXUTGetWindowClientRectAtModeChange, COMDAT

; 4529 : RECT DXUTGetWindowClientRectAtModeChange()          { RECT rc = { 0, 0, GetDXUTState().GetWindowBackBufferWidthAtModeChange(), GetDXUTState().GetWindowBackBufferHeightAtModeChange() }; return rc; }

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _rc$[ebp], 0
	mov	DWORD PTR _rc$[ebp+4], 0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetWindowBackBufferWidthAtModeChange@DXUTState@@QAEIXZ ; DXUTState::GetWindowBackBufferWidthAtModeChange
	mov	DWORD PTR _rc$[ebp+8], eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetWindowBackBufferHeightAtModeChange@DXUTState@@QAEIXZ ; DXUTState::GetWindowBackBufferHeightAtModeChange
	mov	DWORD PTR _rc$[ebp+12], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	ecx, DWORD PTR _rc$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _rc$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _rc$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _rc$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@DXUTGetWin
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@DXUTGetWin:
	DD	1
	DD	$LN4@DXUTGetWin
$LN4@DXUTGetWin:
	DD	-24					; ffffffe8H
	DD	16					; 00000010H
	DD	$LN3@DXUTGetWin
$LN3@DXUTGetWin:
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	0
?DXUTGetWindowClientRectAtModeChange@@YA?AUtagRECT@@XZ ENDP ; DXUTGetWindowClientRectAtModeChange
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTGetWindowClientRect@@YA?AUtagRECT@@XZ
_TEXT	SEGMENT
_rc$ = -24						; size = 16
__$ArrayPad$ = -4					; size = 4
$T1 = 8							; size = 4
?DXUTGetWindowClientRect@@YA?AUtagRECT@@XZ PROC		; DXUTGetWindowClientRect, COMDAT

; 4528 : RECT DXUTGetWindowClientRect()                      { RECT rc; GetClientRect( DXUTGetHWND(), &rc ); return rc; }

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	esi, esp
	lea	eax, DWORD PTR _rc$[ebp]
	push	eax
	call	?DXUTGetHWND@@YAPAUHWND__@@XZ		; DXUTGetHWND
	push	eax
	call	DWORD PTR __imp__GetClientRect@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR $T1[ebp]
	mov	ecx, DWORD PTR _rc$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _rc$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _rc$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _rc$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@DXUTGetWin
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@DXUTGetWin:
	DD	1
	DD	$LN4@DXUTGetWin
$LN4@DXUTGetWin:
	DD	-24					; ffffffe8H
	DD	16					; 00000010H
	DD	$LN3@DXUTGetWin
$LN3@DXUTGetWin:
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	0
?DXUTGetWindowClientRect@@YA?AUtagRECT@@XZ ENDP		; DXUTGetWindowClientRect
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTGetHWNDDeviceWindowed@@YAPAUHWND__@@XZ
_TEXT	SEGMENT
?DXUTGetHWNDDeviceWindowed@@YAPAUHWND__@@XZ PROC	; DXUTGetHWNDDeviceWindowed, COMDAT

; 4527 : HWND DXUTGetHWNDDeviceWindowed()                    { return GetDXUTState().GetHWNDDeviceWindowed(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetHWNDDeviceWindowed@DXUTState@@QAEPAUHWND__@@XZ ; DXUTState::GetHWNDDeviceWindowed
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTGetHWNDDeviceWindowed@@YAPAUHWND__@@XZ ENDP	; DXUTGetHWNDDeviceWindowed
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTGetHWNDDeviceFullScreen@@YAPAUHWND__@@XZ
_TEXT	SEGMENT
?DXUTGetHWNDDeviceFullScreen@@YAPAUHWND__@@XZ PROC	; DXUTGetHWNDDeviceFullScreen, COMDAT

; 4526 : HWND DXUTGetHWNDDeviceFullScreen()                  { return GetDXUTState().GetHWNDDeviceFullScreen(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetHWNDDeviceFullScreen@DXUTState@@QAEPAUHWND__@@XZ ; DXUTState::GetHWNDDeviceFullScreen
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTGetHWNDDeviceFullScreen@@YAPAUHWND__@@XZ ENDP	; DXUTGetHWNDDeviceFullScreen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTGetHWNDFocus@@YAPAUHWND__@@XZ
_TEXT	SEGMENT
?DXUTGetHWNDFocus@@YAPAUHWND__@@XZ PROC			; DXUTGetHWNDFocus, COMDAT

; 4525 : HWND DXUTGetHWNDFocus()                             { return GetDXUTState().GetHWNDFocus(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetHWNDFocus@DXUTState@@QAEPAUHWND__@@XZ ; DXUTState::GetHWNDFocus
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTGetHWNDFocus@@YAPAUHWND__@@XZ ENDP			; DXUTGetHWNDFocus
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTGetHWND@@YAPAUHWND__@@XZ
_TEXT	SEGMENT
tv73 = -196						; size = 4
?DXUTGetHWND@@YAPAUHWND__@@XZ PROC			; DXUTGetHWND, COMDAT

; 4524 : HWND DXUTGetHWND()                                  { return DXUTIsWindowed() ? GetDXUTState().GetHWNDDeviceWindowed() : GetDXUTState().GetHWNDDeviceFullScreen(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	call	?DXUTIsWindowed@@YA_NXZ			; DXUTIsWindowed
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@DXUTGetHWN
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetHWNDDeviceWindowed@DXUTState@@QAEPAUHWND__@@XZ ; DXUTState::GetHWNDDeviceWindowed
	mov	DWORD PTR tv73[ebp], eax
	jmp	SHORT $LN4@DXUTGetHWN
$LN3@DXUTGetHWN:
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetHWNDDeviceFullScreen@DXUTState@@QAEPAUHWND__@@XZ ; DXUTState::GetHWNDDeviceFullScreen
	mov	DWORD PTR tv73[ebp], eax
$LN4@DXUTGetHWN:
	mov	eax, DWORD PTR tv73[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTGetHWND@@YAPAUHWND__@@XZ ENDP			; DXUTGetHWND
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTGetHINSTANCE@@YAPAUHINSTANCE__@@XZ
_TEXT	SEGMENT
?DXUTGetHINSTANCE@@YAPAUHINSTANCE__@@XZ PROC		; DXUTGetHINSTANCE, COMDAT

; 4523 : HINSTANCE DXUTGetHINSTANCE()                        { return GetDXUTState().GetHInstance(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetHInstance@DXUTState@@QAEPAUHINSTANCE__@@XZ ; DXUTState::GetHInstance
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTGetHINSTANCE@@YAPAUHINSTANCE__@@XZ ENDP		; DXUTGetHINSTANCE
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTGetDeviceCaps@@YAPBU_D3DCAPS9@@XZ
_TEXT	SEGMENT
?DXUTGetDeviceCaps@@YAPBU_D3DCAPS9@@XZ PROC		; DXUTGetDeviceCaps, COMDAT

; 4522 : const D3DCAPS9* DXUTGetDeviceCaps()                 { return GetDXUTState().GetCaps(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetCaps@DXUTState@@QAEPAU_D3DCAPS9@@XZ	; DXUTState::GetCaps
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTGetDeviceCaps@@YAPBU_D3DCAPS9@@XZ ENDP		; DXUTGetDeviceCaps
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTGetBackBufferSurfaceDesc@@YAPBU_D3DSURFACE_DESC@@XZ
_TEXT	SEGMENT
?DXUTGetBackBufferSurfaceDesc@@YAPBU_D3DSURFACE_DESC@@XZ PROC ; DXUTGetBackBufferSurfaceDesc, COMDAT

; 4521 : const D3DSURFACE_DESC* DXUTGetBackBufferSurfaceDesc() { return GetDXUTState().GetBackBufferSurfaceDesc(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetBackBufferSurfaceDesc@DXUTState@@QAEPAU_D3DSURFACE_DESC@@XZ ; DXUTState::GetBackBufferSurfaceDesc
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTGetBackBufferSurfaceDesc@@YAPBU_D3DSURFACE_DESC@@XZ ENDP ; DXUTGetBackBufferSurfaceDesc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTGetPresentParameters@@YA?AU_D3DPRESENT_PARAMETERS_@@XZ
_TEXT	SEGMENT
_pp$1 = -72						; size = 56
_pDS$ = -8						; size = 4
$T2 = 8							; size = 4
?DXUTGetPresentParameters@@YA?AU_D3DPRESENT_PARAMETERS_@@XZ PROC ; DXUTGetPresentParameters, COMDAT

; 4597 : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-268]
	mov	ecx, 67					; 00000043H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4598 :     DXUTDeviceSettings* pDS = GetDXUTState().GetCurrentDeviceSettings(); 

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetCurrentDeviceSettings@DXUTState@@QAEPAUDXUTDeviceSettings@@XZ ; DXUTState::GetCurrentDeviceSettings
	mov	DWORD PTR _pDS$[ebp], eax

; 4599 :     if( pDS ) 

	cmp	DWORD PTR _pDS$[ebp], 0
	je	SHORT $LN2@DXUTGetPre

; 4600 :     {
; 4601 :         return pDS->pp; 

	mov	esi, DWORD PTR _pDS$[ebp]
	add	esi, 16					; 00000010H
	mov	ecx, 14					; 0000000eH
	mov	edi, DWORD PTR $T2[ebp]
	rep movsd
	mov	eax, DWORD PTR $T2[ebp]
	jmp	SHORT $LN3@DXUTGetPre

; 4602 :     }
; 4603 :     else 

	jmp	SHORT $LN3@DXUTGetPre
$LN2@DXUTGetPre:

; 4604 :     {
; 4605 :         D3DPRESENT_PARAMETERS pp;
; 4606 :         ZeroMemory( &pp, sizeof(D3DPRESENT_PARAMETERS) );

	push	56					; 00000038H
	push	0
	lea	eax, DWORD PTR _pp$1[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 4607 :         return pp; 

	mov	ecx, 14					; 0000000eH
	lea	esi, DWORD PTR _pp$1[ebp]
	mov	edi, DWORD PTR $T2[ebp]
	rep movsd
	mov	eax, DWORD PTR $T2[ebp]
$LN3@DXUTGetPre:

; 4608 :     }
; 4609 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@DXUTGetPre
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 268				; 0000010cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN7@DXUTGetPre:
	DD	1
	DD	$LN6@DXUTGetPre
$LN6@DXUTGetPre:
	DD	-72					; ffffffb8H
	DD	56					; 00000038H
	DD	$LN5@DXUTGetPre
$LN5@DXUTGetPre:
	DB	112					; 00000070H
	DB	112					; 00000070H
	DB	0
?DXUTGetPresentParameters@@YA?AU_D3DPRESENT_PARAMETERS_@@XZ ENDP ; DXUTGetPresentParameters
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTGetDeviceSettings@@YA?AUDXUTDeviceSettings@@XZ
_TEXT	SEGMENT
_ds$1 = -88						; size = 72
_pDS$ = -8						; size = 4
$T2 = 8							; size = 4
?DXUTGetDeviceSettings@@YA?AUDXUTDeviceSettings@@XZ PROC ; DXUTGetDeviceSettings, COMDAT

; 4617 : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 284				; 0000011cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-284]
	mov	ecx, 71					; 00000047H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4618 :     DXUTDeviceSettings* pDS = GetDXUTState().GetCurrentDeviceSettings();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetCurrentDeviceSettings@DXUTState@@QAEPAUDXUTDeviceSettings@@XZ ; DXUTState::GetCurrentDeviceSettings
	mov	DWORD PTR _pDS$[ebp], eax

; 4619 :     if( pDS )

	cmp	DWORD PTR _pDS$[ebp], 0
	je	SHORT $LN2@DXUTGetDev

; 4620 :     {
; 4621 :         return *pDS;

	mov	ecx, 18					; 00000012H
	mov	esi, DWORD PTR _pDS$[ebp]
	mov	edi, DWORD PTR $T2[ebp]
	rep movsd
	mov	eax, DWORD PTR $T2[ebp]
	jmp	SHORT $LN3@DXUTGetDev

; 4622 :     }
; 4623 :     else

	jmp	SHORT $LN3@DXUTGetDev
$LN2@DXUTGetDev:

; 4624 :     {
; 4625 :         DXUTDeviceSettings ds;
; 4626 :         ZeroMemory( &ds, sizeof(DXUTDeviceSettings) );

	push	72					; 00000048H
	push	0
	lea	eax, DWORD PTR _ds$1[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 4627 :         return ds;

	mov	ecx, 18					; 00000012H
	lea	esi, DWORD PTR _ds$1[ebp]
	mov	edi, DWORD PTR $T2[ebp]
	rep movsd
	mov	eax, DWORD PTR $T2[ebp]
$LN3@DXUTGetDev:

; 4628 :     }
; 4629 : } 

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@DXUTGetDev
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 284				; 0000011cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@DXUTGetDev:
	DD	1
	DD	$LN6@DXUTGetDev
$LN6@DXUTGetDev:
	DD	-88					; ffffffa8H
	DD	72					; 00000048H
	DD	$LN5@DXUTGetDev
$LN5@DXUTGetDev:
	DB	100					; 00000064H
	DB	115					; 00000073H
	DB	0
?DXUTGetDeviceSettings@@YA?AUDXUTDeviceSettings@@XZ ENDP ; DXUTGetDeviceSettings
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTGetD3DDevice@@YAPAUIDirect3DDevice9@@XZ
_TEXT	SEGMENT
?DXUTGetD3DDevice@@YAPAUIDirect3DDevice9@@XZ PROC	; DXUTGetD3DDevice, COMDAT

; 4520 : IDirect3DDevice9* DXUTGetD3DDevice()                { return GetDXUTState().GetD3DDevice(); }  

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetD3DDevice@DXUTState@@QAEPAUIDirect3DDevice9@@XZ ; DXUTState::GetD3DDevice
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTGetD3DDevice@@YAPAUIDirect3DDevice9@@XZ ENDP	; DXUTGetD3DDevice
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTGetD3DObject@@YAPAUIDirect3D9@@XZ
_TEXT	SEGMENT
?DXUTGetD3DObject@@YAPAUIDirect3D9@@XZ PROC		; DXUTGetD3DObject, COMDAT

; 4519 : IDirect3D9* DXUTGetD3DObject()                      { return GetDXUTState().GetD3D(); }        

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetD3D@DXUTState@@QAEPAUIDirect3D9@@XZ	; DXUTState::GetD3D
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTGetD3DObject@@YAPAUIDirect3D9@@XZ ENDP		; DXUTGetD3DObject
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTShutdown@@YAXH@Z
_TEXT	SEGMENT
_pD3D$ = -20						; size = 4
_hWnd$ = -8						; size = 4
_nExitCode$ = 8						; size = 4
?DXUTShutdown@@YAXH@Z PROC				; DXUTShutdown, COMDAT

; 4312 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4313 :     HWND hWnd = DXUTGetHWND();

	call	?DXUTGetHWND@@YAPAUHWND__@@XZ		; DXUTGetHWND
	mov	DWORD PTR _hWnd$[ebp], eax

; 4314 :     if( hWnd != NULL )

	cmp	DWORD PTR _hWnd$[ebp], 0
	je	SHORT $LN2@DXUTShutdo

; 4315 :         SendMessage( hWnd, WM_CLOSE, 0, 0 );

	mov	esi, esp
	push	0
	push	0
	push	16					; 00000010H
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__SendMessageA@16
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@DXUTShutdo:

; 4316 : 
; 4317 :     GetDXUTState().SetExitCode(nExitCode);

	mov	eax, DWORD PTR _nExitCode$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetExitCode@DXUTState@@QAEXH@Z		; DXUTState::SetExitCode

; 4318 : 
; 4319 :     DXUTCleanup3DEnvironment( true );

	push	1
	call	?DXUTCleanup3DEnvironment@@YAX_N@Z	; DXUTCleanup3DEnvironment
	add	esp, 4

; 4320 : 
; 4321 :     // Restore shortcut keys (Windows key, accessibility shortcuts) to original state
; 4322 :     // This is important to call here if the shortcuts are disabled, 
; 4323 :     // because accessibility setting changes are permanent.
; 4324 :     // This means that if this is not done then the accessibility settings 
; 4325 :     // might not be the same as when the app was started. 
; 4326 :     // If the app crashes without restoring the settings, this is also true so it
; 4327 :     // would be wise to backup/restore the settings from a file so they can be 
; 4328 :     // restored when the crashed app is run again.
; 4329 :     DXUTAllowShortcutKeys( true );

	push	1
	call	?DXUTAllowShortcutKeys@@YAX_N@Z		; DXUTAllowShortcutKeys
	add	esp, 4

; 4330 :     
; 4331 :     GetDXUTState().SetD3DEnumeration( NULL );

	push	0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetD3DEnumeration@DXUTState@@QAEXPAVCD3DEnumeration@@@Z ; DXUTState::SetD3DEnumeration

; 4332 : 
; 4333 :     IDirect3D9* pD3D = DXUTGetD3DObject();

	call	?DXUTGetD3DObject@@YAPAUIDirect3D9@@XZ	; DXUTGetD3DObject
	mov	DWORD PTR _pD3D$[ebp], eax

; 4334 :     SAFE_RELEASE( pD3D );

	cmp	DWORD PTR _pD3D$[ebp], 0
	je	SHORT $LN1@DXUTShutdo
	mov	eax, DWORD PTR _pD3D$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR _pD3D$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pD3D$[ebp], 0
$LN1@DXUTShutdo:

; 4335 :     GetDXUTState().SetD3D( NULL );

	push	0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetD3D@DXUTState@@QAEXPAUIDirect3D9@@@Z ; DXUTState::SetD3D

; 4336 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTShutdown@@YAXH@Z ENDP				; DXUTShutdown
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTResetFrameworkState@@YAXXZ
_TEXT	SEGMENT
?DXUTResetFrameworkState@@YAXXZ PROC			; DXUTResetFrameworkState, COMDAT

; 4302 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4303 :     GetDXUTState().Destroy();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?Destroy@DXUTState@@QAEXXZ		; DXUTState::Destroy

; 4304 :     GetDXUTState().Create();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?Create@DXUTState@@QAEXXZ		; DXUTState::Create

; 4305 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTResetFrameworkState@@YAXXZ ENDP			; DXUTResetFrameworkState
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTPause@@YAX_N0@Z
_TEXT	SEGMENT
tv80 = -220						; size = 4
tv69 = -220						; size = 4
tv131 = -217						; size = 1
tv94 = -217						; size = 1
_nPauseRenderingCount$ = -20				; size = 4
_nPauseTimeCount$ = -8					; size = 4
_bPauseTime$ = 8					; size = 1
_bPauseRendering$ = 12					; size = 1
?DXUTPause@@YAX_N0@Z PROC				; DXUTPause, COMDAT

; 3350 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3351 :     int nPauseTimeCount = GetDXUTState().GetPauseTimeCount();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetPauseTimeCount@DXUTState@@QAEHXZ	; DXUTState::GetPauseTimeCount
	mov	DWORD PTR _nPauseTimeCount$[ebp], eax

; 3352 :     nPauseTimeCount += ( bPauseTime ? +1 : -1 );

	movzx	eax, BYTE PTR _bPauseTime$[ebp]
	test	eax, eax
	je	SHORT $LN7@DXUTPause
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN8@DXUTPause
$LN7@DXUTPause:
	mov	DWORD PTR tv69[ebp], -1
$LN8@DXUTPause:
	mov	ecx, DWORD PTR _nPauseTimeCount$[ebp]
	add	ecx, DWORD PTR tv69[ebp]
	mov	DWORD PTR _nPauseTimeCount$[ebp], ecx

; 3353 :     if( nPauseTimeCount < 0 )

	jns	SHORT $LN4@DXUTPause

; 3354 :         nPauseTimeCount = 0;

	mov	DWORD PTR _nPauseTimeCount$[ebp], 0
$LN4@DXUTPause:

; 3355 :     GetDXUTState().SetPauseTimeCount( nPauseTimeCount );

	mov	eax, DWORD PTR _nPauseTimeCount$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetPauseTimeCount@DXUTState@@QAEXH@Z	; DXUTState::SetPauseTimeCount

; 3356 : 
; 3357 :     int nPauseRenderingCount = GetDXUTState().GetPauseRenderingCount();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetPauseRenderingCount@DXUTState@@QAEHXZ ; DXUTState::GetPauseRenderingCount
	mov	DWORD PTR _nPauseRenderingCount$[ebp], eax

; 3358 :     nPauseRenderingCount += ( bPauseRendering ? +1 : -1 );

	movzx	eax, BYTE PTR _bPauseRendering$[ebp]
	test	eax, eax
	je	SHORT $LN9@DXUTPause
	mov	DWORD PTR tv80[ebp], 1
	jmp	SHORT $LN10@DXUTPause
$LN9@DXUTPause:
	mov	DWORD PTR tv80[ebp], -1
$LN10@DXUTPause:
	mov	ecx, DWORD PTR _nPauseRenderingCount$[ebp]
	add	ecx, DWORD PTR tv80[ebp]
	mov	DWORD PTR _nPauseRenderingCount$[ebp], ecx

; 3359 :     if( nPauseRenderingCount < 0 )

	jns	SHORT $LN3@DXUTPause

; 3360 :         nPauseRenderingCount = 0;

	mov	DWORD PTR _nPauseRenderingCount$[ebp], 0
$LN3@DXUTPause:

; 3361 :     GetDXUTState().SetPauseRenderingCount( nPauseRenderingCount );

	mov	eax, DWORD PTR _nPauseRenderingCount$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetPauseRenderingCount@DXUTState@@QAEXH@Z ; DXUTState::SetPauseRenderingCount

; 3362 : 
; 3363 :     if( nPauseTimeCount > 0 )

	cmp	DWORD PTR _nPauseTimeCount$[ebp], 0
	jle	SHORT $LN2@DXUTPause

; 3364 :     {
; 3365 :         // Stop the scene from animating
; 3366 :         DXUTGetGlobalTimer()->Stop();

	call	?DXUTGetGlobalTimer@@YAPAVCDXUTTimer@@XZ ; DXUTGetGlobalTimer
	mov	ecx, eax
	call	?Stop@CDXUTTimer@@QAEXXZ		; CDXUTTimer::Stop

; 3367 :     }
; 3368 :     else

	jmp	SHORT $LN1@DXUTPause
$LN2@DXUTPause:

; 3369 :     {
; 3370 :         // Restart the timer
; 3371 :         DXUTGetGlobalTimer()->Start();

	call	?DXUTGetGlobalTimer@@YAPAVCDXUTTimer@@XZ ; DXUTGetGlobalTimer
	mov	ecx, eax
	call	?Start@CDXUTTimer@@QAEXXZ		; CDXUTTimer::Start
$LN1@DXUTPause:

; 3372 :     }
; 3373 : 
; 3374 :     GetDXUTState().SetRenderingPaused( nPauseRenderingCount > 0 );

	cmp	DWORD PTR _nPauseRenderingCount$[ebp], 0
	jle	SHORT $LN11@DXUTPause
	mov	BYTE PTR tv94[ebp], 1
	jmp	SHORT $LN12@DXUTPause
$LN11@DXUTPause:
	mov	BYTE PTR tv94[ebp], 0
$LN12@DXUTPause:
	movzx	eax, BYTE PTR tv94[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetRenderingPaused@DXUTState@@QAEX_N@Z	; DXUTState::SetRenderingPaused

; 3375 :     GetDXUTState().SetTimePaused( nPauseTimeCount > 0 );

	cmp	DWORD PTR _nPauseTimeCount$[ebp], 0
	jle	SHORT $LN13@DXUTPause
	mov	BYTE PTR tv131[ebp], 1
	jmp	SHORT $LN14@DXUTPause
$LN13@DXUTPause:
	mov	BYTE PTR tv131[ebp], 0
$LN14@DXUTPause:
	movzx	eax, BYTE PTR tv131[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetTimePaused@DXUTState@@QAEX_N@Z	; DXUTState::SetTimePaused

; 3376 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTPause@@YAX_N0@Z ENDP				; DXUTPause
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTToggleREF@@YAJXZ
_TEXT	SEGMENT
$T1 = -524						; size = 72
$T2 = -444						; size = 72
_hr2$3 = -172						; size = 4
_matchOptions$ = -160					; size = 60
_deviceSettings$ = -92					; size = 72
_hr$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?DXUTToggleREF@@YAJXZ PROC				; DXUTToggleREF, COMDAT

; 1303 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 528				; 00000210H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-528]
	mov	ecx, 132				; 00000084H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1304 :     HRESULT hr;
; 1305 : 
; 1306 :     DXUTDeviceSettings deviceSettings = DXUTGetDeviceSettings();

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?DXUTGetDeviceSettings@@YA?AUDXUTDeviceSettings@@XZ ; DXUTGetDeviceSettings
	add	esp, 4
	mov	ecx, 18					; 00000012H
	mov	esi, eax
	lea	edi, DWORD PTR $T1[ebp]
	rep movsd
	mov	ecx, 18					; 00000012H
	lea	esi, DWORD PTR $T1[ebp]
	lea	edi, DWORD PTR _deviceSettings$[ebp]
	rep movsd

; 1307 :     if( deviceSettings.DeviceType == D3DDEVTYPE_HAL )

	cmp	DWORD PTR _deviceSettings$[ebp+4], 1
	jne	SHORT $LN9@DXUTToggle

; 1308 :         deviceSettings.DeviceType = D3DDEVTYPE_REF;

	mov	DWORD PTR _deviceSettings$[ebp+4], 2
	jmp	SHORT $LN8@DXUTToggle
$LN9@DXUTToggle:

; 1309 :     else if( deviceSettings.DeviceType == D3DDEVTYPE_REF )

	cmp	DWORD PTR _deviceSettings$[ebp+4], 2
	jne	SHORT $LN8@DXUTToggle

; 1310 :         deviceSettings.DeviceType = D3DDEVTYPE_HAL;

	mov	DWORD PTR _deviceSettings$[ebp+4], 1
$LN8@DXUTToggle:

; 1311 : 
; 1312 :     DXUTMatchOptions matchOptions;
; 1313 :     matchOptions.eAdapterOrdinal     = DXUTMT_PRESERVE_INPUT;

	mov	DWORD PTR _matchOptions$[ebp], 1

; 1314 :     matchOptions.eDeviceType         = DXUTMT_PRESERVE_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+4], 1

; 1315 :     matchOptions.eWindowed           = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+8], 2

; 1316 :     matchOptions.eAdapterFormat      = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+12], 2

; 1317 :     matchOptions.eVertexProcessing   = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+16], 2

; 1318 :     matchOptions.eResolution         = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+20], 2

; 1319 :     matchOptions.eBackBufferFormat   = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+24], 2

; 1320 :     matchOptions.eBackBufferCount    = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+28], 2

; 1321 :     matchOptions.eMultiSample        = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+32], 2

; 1322 :     matchOptions.eSwapEffect         = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+36], 2

; 1323 :     matchOptions.eDepthFormat        = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+40], 2

; 1324 :     matchOptions.eStencilFormat      = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+44], 2

; 1325 :     matchOptions.ePresentFlags       = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+48], 2

; 1326 :     matchOptions.eRefreshRate        = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+52], 2

; 1327 :     matchOptions.ePresentInterval    = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+56], 2

; 1328 :     
; 1329 :     hr = DXUTFindValidDeviceSettings( &deviceSettings, &deviceSettings, &matchOptions );

	lea	eax, DWORD PTR _matchOptions$[ebp]
	push	eax
	lea	ecx, DWORD PTR _deviceSettings$[ebp]
	push	ecx
	lea	edx, DWORD PTR _deviceSettings$[ebp]
	push	edx
	call	?DXUTFindValidDeviceSettings@@YAJPAUDXUTDeviceSettings@@0PAUDXUTMatchOptions@@@Z ; DXUTFindValidDeviceSettings
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _hr$[ebp], eax

; 1330 :     if( SUCCEEDED(hr) ) 

	cmp	DWORD PTR _hr$[ebp], 0
	jl	$LN6@DXUTToggle

; 1331 :     {
; 1332 :         // Create a Direct3D device using the new device settings.  
; 1333 :         // If there is an existing device, then it will either reset or recreate the scene.
; 1334 :         hr = DXUTChangeDevice( &deviceSettings, NULL, false, false );

	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _deviceSettings$[ebp]
	push	eax
	call	?DXUTChangeDevice@@YAJPAUDXUTDeviceSettings@@PAUIDirect3DDevice9@@_N2@Z ; DXUTChangeDevice
	add	esp, 16					; 00000010H
	mov	DWORD PTR _hr$[ebp], eax

; 1335 : 
; 1336 :         // If hr == E_ABORT, this means the app rejected the device settings in the ModifySettingsCallback so nothing changed
; 1337 :         if( FAILED( hr ) && (hr != E_ABORT) )

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN6@DXUTToggle
	cmp	DWORD PTR _hr$[ebp], -2147467260	; 80004004H
	je	SHORT $LN6@DXUTToggle

; 1338 :         {
; 1339 :             // Failed creating device, try to switch back.
; 1340 :             if( deviceSettings.DeviceType == D3DDEVTYPE_HAL )

	cmp	DWORD PTR _deviceSettings$[ebp+4], 1
	jne	SHORT $LN4@DXUTToggle

; 1341 :                 deviceSettings.DeviceType = D3DDEVTYPE_REF;

	mov	DWORD PTR _deviceSettings$[ebp+4], 2
	jmp	SHORT $LN3@DXUTToggle
$LN4@DXUTToggle:

; 1342 :             else if( deviceSettings.DeviceType == D3DDEVTYPE_REF )

	cmp	DWORD PTR _deviceSettings$[ebp+4], 2
	jne	SHORT $LN3@DXUTToggle

; 1343 :                 deviceSettings.DeviceType = D3DDEVTYPE_HAL;

	mov	DWORD PTR _deviceSettings$[ebp+4], 1
$LN3@DXUTToggle:

; 1344 : 
; 1345 :             DXUTFindValidDeviceSettings( &deviceSettings, &deviceSettings, &matchOptions );

	lea	eax, DWORD PTR _matchOptions$[ebp]
	push	eax
	lea	ecx, DWORD PTR _deviceSettings$[ebp]
	push	ecx
	lea	edx, DWORD PTR _deviceSettings$[ebp]
	push	edx
	call	?DXUTFindValidDeviceSettings@@YAJPAUDXUTDeviceSettings@@0PAUDXUTMatchOptions@@@Z ; DXUTFindValidDeviceSettings
	add	esp, 12					; 0000000cH

; 1346 : 
; 1347 :             HRESULT hr2 = DXUTChangeDevice( &deviceSettings, NULL, false, false );

	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _deviceSettings$[ebp]
	push	eax
	call	?DXUTChangeDevice@@YAJPAUDXUTDeviceSettings@@PAUIDirect3DDevice9@@_N2@Z ; DXUTChangeDevice
	add	esp, 16					; 00000010H
	mov	DWORD PTR _hr2$3[ebp], eax

; 1348 :             if( FAILED(hr2) )

	cmp	DWORD PTR _hr2$3[ebp], 0
	jge	SHORT $LN6@DXUTToggle

; 1349 :             {
; 1350 :                 // If this failed, then shutdown
; 1351 :                 DXUTShutdown();

	push	0
	call	?DXUTShutdown@@YAXH@Z			; DXUTShutdown
	add	esp, 4
$LN6@DXUTToggle:

; 1352 :             }
; 1353 :         }
; 1354 :     }
; 1355 : 
; 1356 :     return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 1357 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN15@DXUTToggle
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 528				; 00000210H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN15@DXUTToggle:
	DD	2
	DD	$LN14@DXUTToggle
$LN14@DXUTToggle:
	DD	-92					; ffffffa4H
	DD	72					; 00000048H
	DD	$LN12@DXUTToggle
	DD	-160					; ffffff60H
	DD	60					; 0000003cH
	DD	$LN13@DXUTToggle
$LN13@DXUTToggle:
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	79					; 0000004fH
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	115					; 00000073H
	DB	0
$LN12@DXUTToggle:
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	118					; 00000076H
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	83					; 00000053H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	115					; 00000073H
	DB	0
?DXUTToggleREF@@YAJXZ ENDP				; DXUTToggleREF
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTToggleFullScreen@@YAJXZ
_TEXT	SEGMENT
tv180 = -580						; size = 4
tv172 = -580						; size = 4
tv164 = -580						; size = 4
tv84 = -580						; size = 4
tv76 = -580						; size = 4
tv68 = -580						; size = 4
$T1 = -572						; size = 72
$T2 = -492						; size = 72
_hr2$3 = -220						; size = 4
_nHeight$4 = -208					; size = 4
_nWidth$5 = -196					; size = 4
_nHeight$ = -184					; size = 4
_nWidth$ = -172						; size = 4
_matchOptions$ = -160					; size = 60
_deviceSettings$ = -92					; size = 72
_hr$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?DXUTToggleFullScreen@@YAJXZ PROC			; DXUTToggleFullScreen, COMDAT

; 1219 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-580]
	mov	ecx, 145				; 00000091H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1220 :     HRESULT hr;
; 1221 : 
; 1222 :     // Get the current device settings and flip the windowed state then
; 1223 :     // find the closest valid device settings with this change
; 1224 :     DXUTDeviceSettings deviceSettings = DXUTGetDeviceSettings();

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?DXUTGetDeviceSettings@@YA?AUDXUTDeviceSettings@@XZ ; DXUTGetDeviceSettings
	add	esp, 4
	mov	ecx, 18					; 00000012H
	mov	esi, eax
	lea	edi, DWORD PTR $T1[ebp]
	rep movsd
	mov	ecx, 18					; 00000012H
	lea	esi, DWORD PTR $T1[ebp]
	lea	edi, DWORD PTR _deviceSettings$[ebp]
	rep movsd

; 1225 :     deviceSettings.pp.Windowed = !deviceSettings.pp.Windowed;

	cmp	DWORD PTR _deviceSettings$[ebp+48], 0
	jne	SHORT $LN10@DXUTToggle
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN11@DXUTToggle
$LN10@DXUTToggle:
	mov	DWORD PTR tv68[ebp], 0
$LN11@DXUTToggle:
	mov	eax, DWORD PTR tv68[ebp]
	mov	DWORD PTR _deviceSettings$[ebp+48], eax

; 1226 : 
; 1227 :     DXUTMatchOptions matchOptions;
; 1228 :     matchOptions.eAdapterOrdinal     = DXUTMT_PRESERVE_INPUT;

	mov	DWORD PTR _matchOptions$[ebp], 1

; 1229 :     matchOptions.eDeviceType         = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+4], 2

; 1230 :     matchOptions.eWindowed           = DXUTMT_PRESERVE_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+8], 1

; 1231 :     matchOptions.eAdapterFormat      = DXUTMT_IGNORE_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+12], 0

; 1232 :     matchOptions.eVertexProcessing   = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+16], 2

; 1233 :     matchOptions.eBackBufferFormat   = DXUTMT_IGNORE_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+24], 0

; 1234 :     matchOptions.eBackBufferCount    = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+28], 2

; 1235 :     matchOptions.eMultiSample        = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+32], 2

; 1236 :     matchOptions.eSwapEffect         = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+36], 2

; 1237 :     matchOptions.eDepthFormat        = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+40], 2

; 1238 :     matchOptions.eStencilFormat      = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+44], 2

; 1239 :     matchOptions.ePresentFlags       = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+48], 2

; 1240 :     matchOptions.eRefreshRate        = DXUTMT_IGNORE_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+52], 0

; 1241 :     matchOptions.ePresentInterval    = DXUTMT_IGNORE_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+56], 0

; 1242 : 
; 1243 :     // Go back to previous state
; 1244 : 
; 1245 :     UINT nWidth  = ( deviceSettings.pp.Windowed ) ? GetDXUTState().GetWindowBackBufferWidthAtModeChange() : GetDXUTState().GetFullScreenBackBufferWidthAtModeChange();

	cmp	DWORD PTR _deviceSettings$[ebp+48], 0
	je	SHORT $LN12@DXUTToggle
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetWindowBackBufferWidthAtModeChange@DXUTState@@QAEIXZ ; DXUTState::GetWindowBackBufferWidthAtModeChange
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN13@DXUTToggle
$LN12@DXUTToggle:
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetFullScreenBackBufferWidthAtModeChange@DXUTState@@QAEIXZ ; DXUTState::GetFullScreenBackBufferWidthAtModeChange
	mov	DWORD PTR tv76[ebp], eax
$LN13@DXUTToggle:
	mov	eax, DWORD PTR tv76[ebp]
	mov	DWORD PTR _nWidth$[ebp], eax

; 1246 :     UINT nHeight = ( deviceSettings.pp.Windowed ) ? GetDXUTState().GetWindowBackBufferHeightAtModeChange() : GetDXUTState().GetFullScreenBackBufferHeightAtModeChange();

	cmp	DWORD PTR _deviceSettings$[ebp+48], 0
	je	SHORT $LN14@DXUTToggle
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetWindowBackBufferHeightAtModeChange@DXUTState@@QAEIXZ ; DXUTState::GetWindowBackBufferHeightAtModeChange
	mov	DWORD PTR tv84[ebp], eax
	jmp	SHORT $LN15@DXUTToggle
$LN14@DXUTToggle:
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetFullScreenBackBufferHeightAtModeChange@DXUTState@@QAEIXZ ; DXUTState::GetFullScreenBackBufferHeightAtModeChange
	mov	DWORD PTR tv84[ebp], eax
$LN15@DXUTToggle:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR _nHeight$[ebp], eax

; 1247 :     if( nWidth > 0 && nHeight > 0 )

	cmp	DWORD PTR _nWidth$[ebp], 0
	jbe	SHORT $LN7@DXUTToggle
	cmp	DWORD PTR _nHeight$[ebp], 0
	jbe	SHORT $LN7@DXUTToggle

; 1248 :     {
; 1249 :         matchOptions.eResolution = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+20], 2

; 1250 :         deviceSettings.pp.BackBufferWidth = nWidth;

	mov	eax, DWORD PTR _nWidth$[ebp]
	mov	DWORD PTR _deviceSettings$[ebp+16], eax

; 1251 :         deviceSettings.pp.BackBufferHeight = nHeight;

	mov	eax, DWORD PTR _nHeight$[ebp]
	mov	DWORD PTR _deviceSettings$[ebp+20], eax

; 1252 :     }
; 1253 :     else

	jmp	SHORT $LN6@DXUTToggle
$LN7@DXUTToggle:

; 1254 :     {
; 1255 :         // No previous data, so just switch to defaults
; 1256 :         matchOptions.eResolution = DXUTMT_IGNORE_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+20], 0
$LN6@DXUTToggle:

; 1257 :     }
; 1258 :     
; 1259 :     hr = DXUTFindValidDeviceSettings( &deviceSettings, &deviceSettings, &matchOptions );

	lea	eax, DWORD PTR _matchOptions$[ebp]
	push	eax
	lea	ecx, DWORD PTR _deviceSettings$[ebp]
	push	ecx
	lea	edx, DWORD PTR _deviceSettings$[ebp]
	push	edx
	call	?DXUTFindValidDeviceSettings@@YAJPAUDXUTDeviceSettings@@0PAUDXUTMatchOptions@@@Z ; DXUTFindValidDeviceSettings
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _hr$[ebp], eax

; 1260 :     if( SUCCEEDED(hr) ) 

	cmp	DWORD PTR _hr$[ebp], 0
	jl	$LN5@DXUTToggle

; 1261 :     {
; 1262 :         // Create a Direct3D device using the new device settings.  
; 1263 :         // If there is an existing device, then it will either reset or recreate the scene.
; 1264 :         hr = DXUTChangeDevice( &deviceSettings, NULL, false, false );

	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _deviceSettings$[ebp]
	push	eax
	call	?DXUTChangeDevice@@YAJPAUDXUTDeviceSettings@@PAUIDirect3DDevice9@@_N2@Z ; DXUTChangeDevice
	add	esp, 16					; 00000010H
	mov	DWORD PTR _hr$[ebp], eax

; 1265 : 
; 1266 :         // If hr == E_ABORT, this means the app rejected the device settings in the ModifySettingsCallback so nothing changed
; 1267 :         if( FAILED(hr) && (hr != E_ABORT) )

	cmp	DWORD PTR _hr$[ebp], 0
	jge	$LN5@DXUTToggle
	cmp	DWORD PTR _hr$[ebp], -2147467260	; 80004004H
	je	$LN5@DXUTToggle

; 1268 :         {
; 1269 :             // Failed creating device, try to switch back.
; 1270 :             deviceSettings.pp.Windowed = !deviceSettings.pp.Windowed;

	cmp	DWORD PTR _deviceSettings$[ebp+48], 0
	jne	SHORT $LN16@DXUTToggle
	mov	DWORD PTR tv164[ebp], 1
	jmp	SHORT $LN17@DXUTToggle
$LN16@DXUTToggle:
	mov	DWORD PTR tv164[ebp], 0
$LN17@DXUTToggle:
	mov	eax, DWORD PTR tv164[ebp]
	mov	DWORD PTR _deviceSettings$[ebp+48], eax

; 1271 :             UINT nWidth  = ( deviceSettings.pp.Windowed ) ? GetDXUTState().GetWindowBackBufferWidthAtModeChange() : GetDXUTState().GetFullScreenBackBufferWidthAtModeChange();

	cmp	DWORD PTR _deviceSettings$[ebp+48], 0
	je	SHORT $LN18@DXUTToggle
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetWindowBackBufferWidthAtModeChange@DXUTState@@QAEIXZ ; DXUTState::GetWindowBackBufferWidthAtModeChange
	mov	DWORD PTR tv172[ebp], eax
	jmp	SHORT $LN19@DXUTToggle
$LN18@DXUTToggle:
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetFullScreenBackBufferWidthAtModeChange@DXUTState@@QAEIXZ ; DXUTState::GetFullScreenBackBufferWidthAtModeChange
	mov	DWORD PTR tv172[ebp], eax
$LN19@DXUTToggle:
	mov	eax, DWORD PTR tv172[ebp]
	mov	DWORD PTR _nWidth$5[ebp], eax

; 1272 :             UINT nHeight = ( deviceSettings.pp.Windowed ) ? GetDXUTState().GetWindowBackBufferHeightAtModeChange() : GetDXUTState().GetFullScreenBackBufferHeightAtModeChange();

	cmp	DWORD PTR _deviceSettings$[ebp+48], 0
	je	SHORT $LN20@DXUTToggle
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetWindowBackBufferHeightAtModeChange@DXUTState@@QAEIXZ ; DXUTState::GetWindowBackBufferHeightAtModeChange
	mov	DWORD PTR tv180[ebp], eax
	jmp	SHORT $LN21@DXUTToggle
$LN20@DXUTToggle:
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetFullScreenBackBufferHeightAtModeChange@DXUTState@@QAEIXZ ; DXUTState::GetFullScreenBackBufferHeightAtModeChange
	mov	DWORD PTR tv180[ebp], eax
$LN21@DXUTToggle:
	mov	eax, DWORD PTR tv180[ebp]
	mov	DWORD PTR _nHeight$4[ebp], eax

; 1273 :             if( nWidth > 0 && nHeight > 0 )

	cmp	DWORD PTR _nWidth$5[ebp], 0
	jbe	SHORT $LN3@DXUTToggle
	cmp	DWORD PTR _nHeight$4[ebp], 0
	jbe	SHORT $LN3@DXUTToggle

; 1274 :             {
; 1275 :                 matchOptions.eResolution = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+20], 2

; 1276 :                 deviceSettings.pp.BackBufferWidth = nWidth;

	mov	eax, DWORD PTR _nWidth$5[ebp]
	mov	DWORD PTR _deviceSettings$[ebp+16], eax

; 1277 :                 deviceSettings.pp.BackBufferHeight = nHeight;

	mov	eax, DWORD PTR _nHeight$4[ebp]
	mov	DWORD PTR _deviceSettings$[ebp+20], eax

; 1278 :             }
; 1279 :             else

	jmp	SHORT $LN2@DXUTToggle
$LN3@DXUTToggle:

; 1280 :             {
; 1281 :                 matchOptions.eResolution = DXUTMT_IGNORE_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+20], 0
$LN2@DXUTToggle:

; 1282 :             }
; 1283 :             
; 1284 :             DXUTFindValidDeviceSettings( &deviceSettings, &deviceSettings, &matchOptions );

	lea	eax, DWORD PTR _matchOptions$[ebp]
	push	eax
	lea	ecx, DWORD PTR _deviceSettings$[ebp]
	push	ecx
	lea	edx, DWORD PTR _deviceSettings$[ebp]
	push	edx
	call	?DXUTFindValidDeviceSettings@@YAJPAUDXUTDeviceSettings@@0PAUDXUTMatchOptions@@@Z ; DXUTFindValidDeviceSettings
	add	esp, 12					; 0000000cH

; 1285 : 
; 1286 :             HRESULT hr2 = DXUTChangeDevice( &deviceSettings, NULL, false, false );

	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _deviceSettings$[ebp]
	push	eax
	call	?DXUTChangeDevice@@YAJPAUDXUTDeviceSettings@@PAUIDirect3DDevice9@@_N2@Z ; DXUTChangeDevice
	add	esp, 16					; 00000010H
	mov	DWORD PTR _hr2$3[ebp], eax

; 1287 :             if( FAILED(hr2) )

	cmp	DWORD PTR _hr2$3[ebp], 0
	jge	SHORT $LN5@DXUTToggle

; 1288 :             {
; 1289 :                 // If this failed, then shutdown
; 1290 :                 DXUTShutdown();

	push	0
	call	?DXUTShutdown@@YAXH@Z			; DXUTShutdown
	add	esp, 4
$LN5@DXUTToggle:

; 1291 :             }
; 1292 :         }
; 1293 :     }
; 1294 : 
; 1295 :     return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 1296 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN25@DXUTToggle
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 580				; 00000244H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN25@DXUTToggle:
	DD	2
	DD	$LN24@DXUTToggle
$LN24@DXUTToggle:
	DD	-92					; ffffffa4H
	DD	72					; 00000048H
	DD	$LN22@DXUTToggle
	DD	-160					; ffffff60H
	DD	60					; 0000003cH
	DD	$LN23@DXUTToggle
$LN23@DXUTToggle:
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	79					; 0000004fH
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	115					; 00000073H
	DB	0
$LN22@DXUTToggle:
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	118					; 00000076H
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	83					; 00000053H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	115					; 00000073H
	DB	0
?DXUTToggleFullScreen@@YAJXZ ENDP			; DXUTToggleFullScreen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTKillTimer@@YAJI@Z
_TEXT	SEGMENT
_DXUTTimer$1 = -36					; size = 17
_pTimerList$ = -8					; size = 4
_nIDEvent$ = 8						; size = 4
?DXUTKillTimer@@YAJI@Z PROC				; DXUTKillTimer, COMDAT

; 4465 : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4466 :     CGrowableArray<DXUT_TIMER>* pTimerList = GetDXUTState().GetTimerList();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetTimerList@DXUTState@@QAEPAV?$CGrowableArray@UDXUT_TIMER@@@@XZ ; DXUTState::GetTimerList
	mov	DWORD PTR _pTimerList$[ebp], eax

; 4467 :     if( pTimerList == NULL )

	cmp	DWORD PTR _pTimerList$[ebp], 0
	jne	SHORT $LN3@DXUTKillTi

; 4468 :         return S_FALSE;

	mov	eax, 1
	jmp	SHORT $LN4@DXUTKillTi
$LN3@DXUTKillTi:

; 4469 : 
; 4470 :     if( nIDEvent < (UINT)pTimerList->GetSize() )

	mov	ecx, DWORD PTR _pTimerList$[ebp]
	call	?GetSize@?$CGrowableArray@UDXUT_TIMER@@@@QBEHXZ ; CGrowableArray<DXUT_TIMER>::GetSize
	cmp	DWORD PTR _nIDEvent$[ebp], eax
	jae	SHORT $LN2@DXUTKillTi

; 4471 :     {
; 4472 :         DXUT_TIMER DXUTTimer = pTimerList->GetAt(nIDEvent);

	mov	eax, DWORD PTR _nIDEvent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTimerList$[ebp]
	call	?GetAt@?$CGrowableArray@UDXUT_TIMER@@@@QAEAAUDXUT_TIMER@@H@Z ; CGrowableArray<DXUT_TIMER>::GetAt
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _DXUTTimer$1[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _DXUTTimer$1[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _DXUTTimer$1[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _DXUTTimer$1[ebp+12], edx
	mov	al, BYTE PTR [eax+16]
	mov	BYTE PTR _DXUTTimer$1[ebp+16], al

; 4473 :         DXUTTimer.bEnabled = false;

	mov	BYTE PTR _DXUTTimer$1[ebp+16], 0

; 4474 :         pTimerList->SetAt(nIDEvent, DXUTTimer);

	lea	eax, DWORD PTR _DXUTTimer$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _nIDEvent$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pTimerList$[ebp]
	call	?SetAt@?$CGrowableArray@UDXUT_TIMER@@@@QAEJHABUDXUT_TIMER@@@Z ; CGrowableArray<DXUT_TIMER>::SetAt

; 4475 :     }
; 4476 :     else

	jmp	SHORT $LN1@DXUTKillTi
$LN2@DXUTKillTi:

; 4477 :     {
; 4478 :         return DXUT_ERR_MSGBOX( "DXUTKillTimer", E_INVALIDARG );

	push	1
	push	OFFSET ??_C@_0O@INMLKDAF@DXUTKillTimer?$AA@
	push	-2147024809				; 80070057H
	mov	eax, DWORD PTR ?__LINE__Var@?1??DXUTKillTimer@@YAJI@Z@4JA
	add	eax, 13					; 0000000dH
	push	eax
	push	OFFSET ??_C@_0CL@KBAHBIDF@z?3?2sampsrc?202xu1?2saco?2d3d9?2commo@
	call	?DXUTTrace@@YGJPBDKJ0_N@Z		; DXUTTrace
	jmp	SHORT $LN4@DXUTKillTi
$LN1@DXUTKillTi:

; 4479 :     }
; 4480 : 
; 4481 :     return S_OK; 

	xor	eax, eax
$LN4@DXUTKillTi:

; 4482 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@DXUTKillTi
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN8@DXUTKillTi:
	DD	1
	DD	$LN7@DXUTKillTi
$LN7@DXUTKillTi:
	DD	-36					; ffffffdcH
	DD	17					; 00000011H
	DD	$LN6@DXUTKillTi
$LN6@DXUTKillTi:
	DB	68					; 00000044H
	DB	88					; 00000058H
	DB	85					; 00000055H
	DB	84					; 00000054H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
?DXUTKillTimer@@YAJI@Z ENDP				; DXUTKillTimer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTSetTimer@@YAJP6GXIPAX@ZMPAI0@Z
_TEXT	SEGMENT
tv83 = -284						; size = 4
$T2 = -276						; size = 4
$T3 = -264						; size = 4
_pTimerList$ = -60					; size = 4
_DXUTTimer$ = -48					; size = 17
_hr$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_pCallbackTimer$ = 8					; size = 4
_fTimeoutInSecs$ = 12					; size = 4
_pnIDEvent$ = 16					; size = 4
_pCallbackUserContext$ = 20				; size = 4
?DXUTSetTimer@@YAJP6GXIPAX@ZMPAI0@Z PROC		; DXUTSetTimer, COMDAT

; 4430 : { 

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DXUTSetTimer@@YAJP6GXIPAX@ZMPAI0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 272				; 00000110H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-284]
	mov	ecx, 68					; 00000044H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 4431 :     if( pCallbackTimer == NULL )

	cmp	DWORD PTR _pCallbackTimer$[ebp], 0
	jne	SHORT $LN5@DXUTSetTim

; 4432 :         return DXUT_ERR_MSGBOX( "DXUTSetTimer", E_INVALIDARG ); 

	push	1
	push	OFFSET ??_C@_0N@FMEJHMAO@DXUTSetTimer?$AA@
	push	-2147024809				; 80070057H
	mov	eax, DWORD PTR ?__LINE__Var@?1??DXUTSetTimer@@YAJP6GXIPAX@ZMPAI0@Z@4JA
	add	eax, 2
	push	eax
	push	OFFSET ??_C@_0CL@KBAHBIDF@z?3?2sampsrc?202xu1?2saco?2d3d9?2commo@
	call	?DXUTTrace@@YGJPBDKJ0_N@Z		; DXUTTrace
	jmp	$LN6@DXUTSetTim
$LN5@DXUTSetTim:

; 4433 : 
; 4434 :     HRESULT hr;
; 4435 :     DXUT_TIMER DXUTTimer;
; 4436 :     DXUTTimer.pCallbackTimer = pCallbackTimer;

	mov	eax, DWORD PTR _pCallbackTimer$[ebp]
	mov	DWORD PTR _DXUTTimer$[ebp], eax

; 4437 :     DXUTTimer.pCallbackUserContext = pCallbackUserContext;

	mov	eax, DWORD PTR _pCallbackUserContext$[ebp]
	mov	DWORD PTR _DXUTTimer$[ebp+4], eax

; 4438 :     DXUTTimer.fTimeoutInSecs = fTimeoutInSecs;

	movss	xmm0, DWORD PTR _fTimeoutInSecs$[ebp]
	movss	DWORD PTR _DXUTTimer$[ebp+8], xmm0

; 4439 :     DXUTTimer.fCountdown = fTimeoutInSecs;

	movss	xmm0, DWORD PTR _fTimeoutInSecs$[ebp]
	movss	DWORD PTR _DXUTTimer$[ebp+12], xmm0

; 4440 :     DXUTTimer.bEnabled = true;

	mov	BYTE PTR _DXUTTimer$[ebp+16], 1

; 4441 : 
; 4442 :     CGrowableArray<DXUT_TIMER>* pTimerList = GetDXUTState().GetTimerList();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetTimerList@DXUTState@@QAEPAV?$CGrowableArray@UDXUT_TIMER@@@@XZ ; DXUTState::GetTimerList
	mov	DWORD PTR _pTimerList$[ebp], eax

; 4443 :     if( pTimerList == NULL )

	cmp	DWORD PTR _pTimerList$[ebp], 0
	jne	SHORT $LN4@DXUTSetTim

; 4444 :     {
; 4445 :         pTimerList = new CGrowableArray<DXUT_TIMER>;

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN8@DXUTSetTim
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0?$CGrowableArray@UDXUT_TIMER@@@@QAE@XZ ; CGrowableArray<DXUT_TIMER>::CGrowableArray<DXUT_TIMER>
	mov	DWORD PTR tv83[ebp], eax
	jmp	SHORT $LN9@DXUTSetTim
$LN8@DXUTSetTim:
	mov	DWORD PTR tv83[ebp], 0
$LN9@DXUTSetTim:
	mov	eax, DWORD PTR tv83[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _pTimerList$[ebp], ecx

; 4446 :         if( pTimerList == NULL )

	cmp	DWORD PTR _pTimerList$[ebp], 0
	jne	SHORT $LN3@DXUTSetTim

; 4447 :             return E_OUTOFMEMORY; 

	mov	eax, -2147024882			; 8007000eH
	jmp	SHORT $LN6@DXUTSetTim
$LN3@DXUTSetTim:

; 4448 :         GetDXUTState().SetTimerList( pTimerList );

	mov	eax, DWORD PTR _pTimerList$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetTimerList@DXUTState@@QAEXPAV?$CGrowableArray@UDXUT_TIMER@@@@@Z ; DXUTState::SetTimerList
$LN4@DXUTSetTim:

; 4449 :     }
; 4450 : 
; 4451 :     if( FAILED( hr = pTimerList->Add( DXUTTimer ) ) )

	lea	eax, DWORD PTR _DXUTTimer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTimerList$[ebp]
	call	?Add@?$CGrowableArray@UDXUT_TIMER@@@@QAEJABUDXUT_TIMER@@@Z ; CGrowableArray<DXUT_TIMER>::Add
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN2@DXUTSetTim

; 4452 :         return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	jmp	SHORT $LN6@DXUTSetTim
$LN2@DXUTSetTim:

; 4453 : 
; 4454 :     if( pnIDEvent )

	cmp	DWORD PTR _pnIDEvent$[ebp], 0
	je	SHORT $LN1@DXUTSetTim

; 4455 :         *pnIDEvent = pTimerList->GetSize();

	mov	ecx, DWORD PTR _pTimerList$[ebp]
	call	?GetSize@?$CGrowableArray@UDXUT_TIMER@@@@QBEHXZ ; CGrowableArray<DXUT_TIMER>::GetSize
	mov	ecx, DWORD PTR _pnIDEvent$[ebp]
	mov	DWORD PTR [ecx], eax
$LN1@DXUTSetTim:

; 4456 : 
; 4457 :     return S_OK; 

	xor	eax, eax
$LN6@DXUTSetTim:

; 4458 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN14@DXUTSetTim
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 284				; 0000011cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN14@DXUTSetTim:
	DD	1
	DD	$LN13@DXUTSetTim
$LN13@DXUTSetTim:
	DD	-48					; ffffffd0H
	DD	17					; 00000011H
	DD	$LN11@DXUTSetTim
$LN11@DXUTSetTim:
	DB	68					; 00000044H
	DB	88					; 00000058H
	DB	85					; 00000055H
	DB	84					; 00000054H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DXUTSetTimer@@YAJP6GXIPAX@ZMPAI0@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?DXUTSetTimer@@YAJP6GXIPAX@ZMPAI0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-288]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DXUTSetTimer@@YAJP6GXIPAX@ZMPAI0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DXUTSetTimer@@YAJP6GXIPAX@ZMPAI0@Z ENDP		; DXUTSetTimer
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTSetConstantFrameTime@@YAX_NM@Z
_TEXT	SEGMENT
_bEnabled$ = 8						; size = 1
_fTimePerFrame$ = 12					; size = 4
?DXUTSetConstantFrameTime@@YAX_NM@Z PROC		; DXUTSetConstantFrameTime, COMDAT

; 4568 : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4569 :     if( GetDXUTState().GetOverrideConstantFrameTime() ) 

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetOverrideConstantFrameTime@DXUTState@@QAE_NXZ ; DXUTState::GetOverrideConstantFrameTime
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@DXUTSetCon

; 4570 :     { 
; 4571 :         bEnabled = GetDXUTState().GetOverrideConstantFrameTime(); 

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetOverrideConstantFrameTime@DXUTState@@QAE_NXZ ; DXUTState::GetOverrideConstantFrameTime
	mov	BYTE PTR _bEnabled$[ebp], al

; 4572 :         fTimePerFrame = GetDXUTState().GetOverrideConstantTimePerFrame(); 

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetOverrideConstantTimePerFrame@DXUTState@@QAEMXZ ; DXUTState::GetOverrideConstantTimePerFrame
	fstp	DWORD PTR _fTimePerFrame$[ebp]
$LN1@DXUTSetCon:

; 4573 :     } 
; 4574 :     GetDXUTState().SetConstantFrameTime(bEnabled); 

	movzx	eax, BYTE PTR _bEnabled$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetConstantFrameTime@DXUTState@@QAEX_N@Z ; DXUTState::SetConstantFrameTime

; 4575 :     GetDXUTState().SetTimePerFrame(fTimePerFrame); 

	push	ecx
	movss	xmm0, DWORD PTR _fTimePerFrame$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetTimePerFrame@DXUTState@@QAEXM@Z	; DXUTState::SetTimePerFrame

; 4576 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTSetConstantFrameTime@@YAX_NM@Z ENDP		; DXUTSetConstantFrameTime
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTSetShortcutKeySettings@@YAX_N0@Z
_TEXT	SEGMENT
_bAllowWhenFullscreen$ = 8				; size = 1
_bAllowWhenWindowed$ = 12				; size = 1
?DXUTSetShortcutKeySettings@@YAX_N0@Z PROC		; DXUTSetShortcutKeySettings, COMDAT

; 3104 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3105 :     GetDXUTState().SetAllowShortcutKeysWhenWindowed( bAllowWhenWindowed );

	movzx	eax, BYTE PTR _bAllowWhenWindowed$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetAllowShortcutKeysWhenWindowed@DXUTState@@QAEX_N@Z ; DXUTState::SetAllowShortcutKeysWhenWindowed

; 3106 :     GetDXUTState().SetAllowShortcutKeysWhenFullscreen( bAllowWhenFullscreen );

	movzx	eax, BYTE PTR _bAllowWhenFullscreen$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetAllowShortcutKeysWhenFullscreen@DXUTState@@QAEX_N@Z ; DXUTState::SetAllowShortcutKeysWhenFullscreen

; 3107 : 
; 3108 :     // DXUTInit() records initial accessibility states so don't change them until then
; 3109 :     if( GetDXUTState().GetDXUTInited() )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetDXUTInited@DXUTState@@QAE_NXZ	; DXUTState::GetDXUTInited
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@DXUTSetSho

; 3110 :     {
; 3111 :         if( DXUTIsWindowed() )

	call	?DXUTIsWindowed@@YA_NXZ			; DXUTIsWindowed
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@DXUTSetSho

; 3112 :             DXUTAllowShortcutKeys( GetDXUTState().GetAllowShortcutKeysWhenWindowed() );

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetAllowShortcutKeysWhenWindowed@DXUTState@@QAE_NXZ ; DXUTState::GetAllowShortcutKeysWhenWindowed
	movzx	eax, al
	push	eax
	call	?DXUTAllowShortcutKeys@@YAX_N@Z		; DXUTAllowShortcutKeys
	add	esp, 4

; 3113 :         else

	jmp	SHORT $LN4@DXUTSetSho
$LN2@DXUTSetSho:

; 3114 :             DXUTAllowShortcutKeys( GetDXUTState().GetAllowShortcutKeysWhenFullscreen() );

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetAllowShortcutKeysWhenFullscreen@DXUTState@@QAE_NXZ ; DXUTState::GetAllowShortcutKeysWhenFullscreen
	movzx	eax, al
	push	eax
	call	?DXUTAllowShortcutKeys@@YAX_N@Z		; DXUTAllowShortcutKeys
	add	esp, 4
$LN4@DXUTSetSho:

; 3115 :     }
; 3116 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTSetShortcutKeySettings@@YAX_N0@Z ENDP		; DXUTSetShortcutKeySettings
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTSetMultimonSettings@@YAX_N@Z
_TEXT	SEGMENT
_bAutoChangeAdapter$ = 8				; size = 1
?DXUTSetMultimonSettings@@YAX_N@Z PROC			; DXUTSetMultimonSettings, COMDAT

; 4559 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4560 :     GetDXUTState().SetAutoChangeAdapter( bAutoChangeAdapter );

	movzx	eax, BYTE PTR _bAutoChangeAdapter$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetAutoChangeAdapter@DXUTState@@QAEX_N@Z ; DXUTState::SetAutoChangeAdapter

; 4561 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTSetMultimonSettings@@YAX_N@Z ENDP			; DXUTSetMultimonSettings
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTSetCursorSettings@@YAX_N0@Z
_TEXT	SEGMENT
_bShowCursorWhenFullScreen$ = 8				; size = 1
_bClipCursorWhenFullScreen$ = 12			; size = 1
?DXUTSetCursorSettings@@YAX_N0@Z PROC			; DXUTSetCursorSettings, COMDAT

; 4563 : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4564 :     GetDXUTState().SetClipCursorWhenFullScreen(bClipCursorWhenFullScreen); 

	movzx	eax, BYTE PTR _bClipCursorWhenFullScreen$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetClipCursorWhenFullScreen@DXUTState@@QAEX_N@Z ; DXUTState::SetClipCursorWhenFullScreen

; 4565 :     GetDXUTState().SetShowCursorWhenFullScreen(bShowCursorWhenFullScreen); 

	movzx	eax, BYTE PTR _bShowCursorWhenFullScreen$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetShowCursorWhenFullScreen@DXUTState@@QAEX_N@Z ; DXUTState::SetShowCursorWhenFullScreen

; 4566 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTSetCursorSettings@@YAX_N0@Z ENDP			; DXUTSetCursorSettings
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTFindValidDeviceSettings@@YAJPAUDXUTDeviceSettings@@0PAUDXUTMatchOptions@@@Z
_TEXT	SEGMENT
_validDeviceSettings$ = -396				; size = 72
_fCurRanking$1 = -316					; size = 4
_pDeviceSettingsCombo$2 = -304				; size = 4
_iDeviceCombo$3 = -292					; size = 4
_pDeviceInfo$4 = -280					; size = 4
_iDeviceInfo$5 = -268					; size = 4
_pAdapterInfo$6 = -256					; size = 4
_iAdapter$7 = -244					; size = 4
_pAdapterList$ = -232					; size = 4
_adapterDesktopDisplayMode$ = -220			; size = 16
_pBestDeviceSettingsCombo$ = -196			; size = 4
_fBestRanking$ = -184					; size = 4
_optimalDeviceSettings$ = -172				; size = 72
_defaultMatchOptions$ = -92				; size = 60
_pD3D$ = -24						; size = 4
_pd3dEnum$ = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
_pOut$ = 8						; size = 4
_pIn$ = 12						; size = 4
_pMatchOptions$ = 16					; size = 4
?DXUTFindValidDeviceSettings@@YAJPAUDXUTDeviceSettings@@0PAUDXUTMatchOptions@@@Z PROC ; DXUTFindValidDeviceSettings, COMDAT

; 1417 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 592				; 00000250H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-592]
	mov	ecx, 148				; 00000094H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1418 :     if( pOut == NULL )

	cmp	DWORD PTR _pOut$[ebp], 0
	jne	SHORT $LN15@DXUTFindVa

; 1419 :         return DXUT_ERR_MSGBOX( "DXUTFindValidDeviceSettings", E_INVALIDARG );

	push	1
	push	OFFSET ??_C@_0BM@MONLLCLM@DXUTFindValidDeviceSettings?$AA@
	push	-2147024809				; 80070057H
	mov	eax, DWORD PTR ?__LINE__Var@?1??DXUTFindValidDeviceSettings@@YAJPAUDXUTDeviceSettings@@0PAUDXUTMatchOptions@@@Z@4JA
	add	eax, 2
	push	eax
	push	OFFSET ??_C@_0CL@KBAHBIDF@z?3?2sampsrc?202xu1?2saco?2d3d9?2commo@
	call	?DXUTTrace@@YGJPBDKJ0_N@Z		; DXUTTrace
	jmp	$LN16@DXUTFindVa
$LN15@DXUTFindVa:

; 1420 : 
; 1421 :     CD3DEnumeration* pd3dEnum = DXUTPrepareEnumerationObject( false );

	push	0
	call	?DXUTPrepareEnumerationObject@@YAPAVCD3DEnumeration@@_N@Z ; DXUTPrepareEnumerationObject
	add	esp, 4
	mov	DWORD PTR _pd3dEnum$[ebp], eax

; 1422 :     IDirect3D9*      pD3D     = DXUTGetD3DObject();

	call	?DXUTGetD3DObject@@YAPAUIDirect3D9@@XZ	; DXUTGetD3DObject
	mov	DWORD PTR _pD3D$[ebp], eax

; 1423 : 
; 1424 :     // Default to DXUTMT_IGNORE_INPUT for everything unless pMatchOptions isn't NULL
; 1425 :     DXUTMatchOptions defaultMatchOptions;
; 1426 :     if( NULL == pMatchOptions )

	cmp	DWORD PTR _pMatchOptions$[ebp], 0
	jne	SHORT $LN14@DXUTFindVa

; 1427 :     {
; 1428 :         ZeroMemory( &defaultMatchOptions, sizeof(DXUTMatchOptions) );

	push	60					; 0000003cH
	push	0
	lea	eax, DWORD PTR _defaultMatchOptions$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1429 :         pMatchOptions = &defaultMatchOptions;

	lea	eax, DWORD PTR _defaultMatchOptions$[ebp]
	mov	DWORD PTR _pMatchOptions$[ebp], eax
$LN14@DXUTFindVa:

; 1430 :     }
; 1431 : 
; 1432 :     // Build an optimal device settings structure based upon the match 
; 1433 :     // options.  If the match option is set to ignore, then a optimal default value is used.
; 1434 :     // The default value may not exist on the system, but later this will be taken 
; 1435 :     // into account.
; 1436 :     DXUTDeviceSettings optimalDeviceSettings;
; 1437 :     DXUTBuildOptimalDeviceSettings( &optimalDeviceSettings, pIn, pMatchOptions );

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pIn$[ebp]
	push	ecx
	lea	edx, DWORD PTR _optimalDeviceSettings$[ebp]
	push	edx
	call	?DXUTBuildOptimalDeviceSettings@@YAXPAUDXUTDeviceSettings@@0PAUDXUTMatchOptions@@@Z ; DXUTBuildOptimalDeviceSettings
	add	esp, 12					; 0000000cH

; 1438 : 
; 1439 :     // Find the best combination of:
; 1440 :     //      Adapter Ordinal
; 1441 :     //      Device Type
; 1442 :     //      Adapter Format
; 1443 :     //      Back Buffer Format
; 1444 :     //      Windowed
; 1445 :     // given what's available on the system and the match options combined with the device settings input.
; 1446 :     // This combination of settings is encapsulated by the CD3DEnumDeviceSettingsCombo class.
; 1447 :     float fBestRanking = -1.0f;

	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _fBestRanking$[ebp], xmm0

; 1448 :     CD3DEnumDeviceSettingsCombo* pBestDeviceSettingsCombo = NULL;

	mov	DWORD PTR _pBestDeviceSettingsCombo$[ebp], 0

; 1449 :     D3DDISPLAYMODE adapterDesktopDisplayMode;
; 1450 : 
; 1451 :     CGrowableArray<CD3DEnumAdapterInfo*>* pAdapterList = pd3dEnum->GetAdapterInfoList();

	mov	ecx, DWORD PTR _pd3dEnum$[ebp]
	call	?GetAdapterInfoList@CD3DEnumeration@@QAEPAV?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@XZ ; CD3DEnumeration::GetAdapterInfoList
	mov	DWORD PTR _pAdapterList$[ebp], eax

; 1452 :     for( int iAdapter=0; iAdapter<pAdapterList->GetSize(); iAdapter++ )

	mov	DWORD PTR _iAdapter$7[ebp], 0
	jmp	SHORT $LN13@DXUTFindVa
$LN12@DXUTFindVa:
	mov	eax, DWORD PTR _iAdapter$7[ebp]
	add	eax, 1
	mov	DWORD PTR _iAdapter$7[ebp], eax
$LN13@DXUTFindVa:
	mov	ecx, DWORD PTR _pAdapterList$[ebp]
	call	?GetSize@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QBEHXZ ; CGrowableArray<CD3DEnumAdapterInfo *>::GetSize
	cmp	DWORD PTR _iAdapter$7[ebp], eax
	jge	$LN11@DXUTFindVa

; 1453 :     {
; 1454 :         CD3DEnumAdapterInfo* pAdapterInfo = pAdapterList->GetAt(iAdapter);

	mov	eax, DWORD PTR _iAdapter$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _pAdapterList$[ebp]
	call	?GetAt@?$CGrowableArray@PAVCD3DEnumAdapterInfo@@@@QAEAAPAVCD3DEnumAdapterInfo@@H@Z ; CGrowableArray<CD3DEnumAdapterInfo *>::GetAt
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pAdapterInfo$6[ebp], ecx

; 1455 : 
; 1456 :         // Get the desktop display mode of adapter 
; 1457 :         pD3D->GetAdapterDisplayMode( pAdapterInfo->AdapterOrdinal, &adapterDesktopDisplayMode );

	mov	esi, esp
	lea	eax, DWORD PTR _adapterDesktopDisplayMode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pAdapterInfo$6[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pD3D$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pD3D$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+32]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1458 : 
; 1459 :         // Enum all the device types supported by this adapter to find the best device settings
; 1460 :         for( int iDeviceInfo=0; iDeviceInfo<pAdapterInfo->deviceInfoList.GetSize(); iDeviceInfo++ )

	mov	DWORD PTR _iDeviceInfo$5[ebp], 0
	jmp	SHORT $LN10@DXUTFindVa
$LN9@DXUTFindVa:
	mov	eax, DWORD PTR _iDeviceInfo$5[ebp]
	add	eax, 1
	mov	DWORD PTR _iDeviceInfo$5[ebp], eax
$LN10@DXUTFindVa:
	mov	ecx, DWORD PTR _pAdapterInfo$6[ebp]
	add	ecx, 1372				; 0000055cH
	call	?GetSize@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QBEHXZ ; CGrowableArray<CD3DEnumDeviceInfo *>::GetSize
	cmp	DWORD PTR _iDeviceInfo$5[ebp], eax
	jge	$LN8@DXUTFindVa

; 1461 :         {
; 1462 :             CD3DEnumDeviceInfo* pDeviceInfo = pAdapterInfo->deviceInfoList.GetAt(iDeviceInfo);

	mov	eax, DWORD PTR _iDeviceInfo$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _pAdapterInfo$6[ebp]
	add	ecx, 1372				; 0000055cH
	call	?GetAt@?$CGrowableArray@PAVCD3DEnumDeviceInfo@@@@QAEAAPAVCD3DEnumDeviceInfo@@H@Z ; CGrowableArray<CD3DEnumDeviceInfo *>::GetAt
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pDeviceInfo$4[ebp], ecx

; 1463 : 
; 1464 :             // Enum all the device settings combinations.  A device settings combination is 
; 1465 :             // a unique set of an adapter format, back buffer format, and IsWindowed.
; 1466 :             for( int iDeviceCombo=0; iDeviceCombo<pDeviceInfo->deviceSettingsComboList.GetSize(); iDeviceCombo++ )

	mov	DWORD PTR _iDeviceCombo$3[ebp], 0
	jmp	SHORT $LN7@DXUTFindVa
$LN6@DXUTFindVa:
	mov	eax, DWORD PTR _iDeviceCombo$3[ebp]
	add	eax, 1
	mov	DWORD PTR _iDeviceCombo$3[ebp], eax
$LN7@DXUTFindVa:
	mov	ecx, DWORD PTR _pDeviceInfo$4[ebp]
	add	ecx, 312				; 00000138H
	call	?GetSize@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QBEHXZ ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::GetSize
	cmp	DWORD PTR _iDeviceCombo$3[ebp], eax
	jge	$LN5@DXUTFindVa

; 1467 :             {
; 1468 :                 CD3DEnumDeviceSettingsCombo* pDeviceSettingsCombo = pDeviceInfo->deviceSettingsComboList.GetAt(iDeviceCombo);

	mov	eax, DWORD PTR _iDeviceCombo$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeviceInfo$4[ebp]
	add	ecx, 312				; 00000138H
	call	?GetAt@?$CGrowableArray@PAUCD3DEnumDeviceSettingsCombo@@@@QAEAAPAUCD3DEnumDeviceSettingsCombo@@H@Z ; CGrowableArray<CD3DEnumDeviceSettingsCombo *>::GetAt
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pDeviceSettingsCombo$2[ebp], ecx

; 1469 : 
; 1470 :                 // If windowed mode the adapter format has to be the same as the desktop 
; 1471 :                 // display mode format so skip any that don't match
; 1472 :                 if (pDeviceSettingsCombo->Windowed && (pDeviceSettingsCombo->AdapterFormat != adapterDesktopDisplayMode.Format))

	mov	eax, DWORD PTR _pDeviceSettingsCombo$2[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN4@DXUTFindVa
	mov	eax, DWORD PTR _pDeviceSettingsCombo$2[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _adapterDesktopDisplayMode$[ebp+12]
	je	SHORT $LN4@DXUTFindVa

; 1473 :                     continue;

	jmp	SHORT $LN6@DXUTFindVa
$LN4@DXUTFindVa:

; 1474 : 
; 1475 :                 // Skip any combo that doesn't meet the preserve match options
; 1476 :                 if( false == DXUTDoesDeviceComboMatchPreserveOptions( pDeviceSettingsCombo, pIn, pMatchOptions ) )

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pIn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pDeviceSettingsCombo$2[ebp]
	push	edx
	call	?DXUTDoesDeviceComboMatchPreserveOptions@@YA_NPAUCD3DEnumDeviceSettingsCombo@@PAUDXUTDeviceSettings@@PAUDXUTMatchOptions@@@Z ; DXUTDoesDeviceComboMatchPreserveOptions
	add	esp, 12					; 0000000cH
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@DXUTFindVa

; 1477 :                     continue;           

	jmp	$LN6@DXUTFindVa
$LN3@DXUTFindVa:

; 1478 : 
; 1479 :                 // Get a ranking number that describes how closely this device combo matches the optimal combo
; 1480 :                 float fCurRanking = DXUTRankDeviceCombo( pDeviceSettingsCombo, &optimalDeviceSettings, &adapterDesktopDisplayMode );

	lea	eax, DWORD PTR _adapterDesktopDisplayMode$[ebp]
	push	eax
	lea	ecx, DWORD PTR _optimalDeviceSettings$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pDeviceSettingsCombo$2[ebp]
	push	edx
	call	?DXUTRankDeviceCombo@@YAMPAUCD3DEnumDeviceSettingsCombo@@PAUDXUTDeviceSettings@@PAU_D3DDISPLAYMODE@@@Z ; DXUTRankDeviceCombo
	add	esp, 12					; 0000000cH
	fstp	DWORD PTR _fCurRanking$1[ebp]

; 1481 : 
; 1482 :                 // If this combo better matches the input device settings then save it
; 1483 :                 if( fCurRanking > fBestRanking )

	movss	xmm0, DWORD PTR _fCurRanking$1[ebp]
	comiss	xmm0, DWORD PTR _fBestRanking$[ebp]
	jbe	SHORT $LN2@DXUTFindVa

; 1484 :                 {
; 1485 :                     pBestDeviceSettingsCombo = pDeviceSettingsCombo;

	mov	eax, DWORD PTR _pDeviceSettingsCombo$2[ebp]
	mov	DWORD PTR _pBestDeviceSettingsCombo$[ebp], eax

; 1486 :                     fBestRanking = fCurRanking;

	movss	xmm0, DWORD PTR _fCurRanking$1[ebp]
	movss	DWORD PTR _fBestRanking$[ebp], xmm0
$LN2@DXUTFindVa:

; 1487 :                 }                
; 1488 :             }

	jmp	$LN6@DXUTFindVa
$LN5@DXUTFindVa:

; 1489 :         }

	jmp	$LN9@DXUTFindVa
$LN8@DXUTFindVa:

; 1490 :     }

	jmp	$LN12@DXUTFindVa
$LN11@DXUTFindVa:

; 1491 : 
; 1492 :     // If no best device combination was found then fail
; 1493 :     if( pBestDeviceSettingsCombo == NULL ) 

	cmp	DWORD PTR _pBestDeviceSettingsCombo$[ebp], 0
	jne	SHORT $LN1@DXUTFindVa

; 1494 :         return DXUTERR_NOCOMPATIBLEDEVICES;

	mov	eax, -2147219198			; 80040902H
	jmp	SHORT $LN16@DXUTFindVa
$LN1@DXUTFindVa:

; 1495 : 
; 1496 :     // Using the best device settings combo found, build valid device settings taking heed of 
; 1497 :     // the match options and the input device settings
; 1498 :     DXUTDeviceSettings validDeviceSettings;
; 1499 :     DXUTBuildValidDeviceSettings( &validDeviceSettings, pBestDeviceSettingsCombo, pIn, pMatchOptions );

	mov	eax, DWORD PTR _pMatchOptions$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pIn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pBestDeviceSettingsCombo$[ebp]
	push	edx
	lea	eax, DWORD PTR _validDeviceSettings$[ebp]
	push	eax
	call	?DXUTBuildValidDeviceSettings@@YAXPAUDXUTDeviceSettings@@PAUCD3DEnumDeviceSettingsCombo@@0PAUDXUTMatchOptions@@@Z ; DXUTBuildValidDeviceSettings
	add	esp, 16					; 00000010H

; 1500 :     *pOut = validDeviceSettings;

	mov	ecx, 18					; 00000012H
	lea	esi, DWORD PTR _validDeviceSettings$[ebp]
	mov	edi, DWORD PTR _pOut$[ebp]
	rep movsd

; 1501 : 
; 1502 :     return S_OK;

	xor	eax, eax
$LN16@DXUTFindVa:

; 1503 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN23@DXUTFindVa
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 592				; 00000250H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN23@DXUTFindVa:
	DD	4
	DD	$LN22@DXUTFindVa
$LN22@DXUTFindVa:
	DD	-92					; ffffffa4H
	DD	60					; 0000003cH
	DD	$LN18@DXUTFindVa
	DD	-172					; ffffff54H
	DD	72					; 00000048H
	DD	$LN19@DXUTFindVa
	DD	-220					; ffffff24H
	DD	16					; 00000010H
	DD	$LN20@DXUTFindVa
	DD	-396					; fffffe74H
	DD	72					; 00000048H
	DD	$LN21@DXUTFindVa
$LN21@DXUTFindVa:
	DB	118					; 00000076H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	68					; 00000044H
	DB	101					; 00000065H
	DB	118					; 00000076H
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	83					; 00000053H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	115					; 00000073H
	DB	0
$LN20@DXUTFindVa:
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	68					; 00000044H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	107					; 0000006bH
	DB	116					; 00000074H
	DB	111					; 0000006fH
	DB	112					; 00000070H
	DB	68					; 00000044H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	77					; 0000004dH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
$LN19@DXUTFindVa:
	DB	111					; 0000006fH
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	68					; 00000044H
	DB	101					; 00000065H
	DB	118					; 00000076H
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	83					; 00000053H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	115					; 00000073H
	DB	0
$LN18@DXUTFindVa:
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	102					; 00000066H
	DB	97					; 00000061H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	77					; 0000004dH
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	79					; 0000004fH
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	115					; 00000073H
	DB	0
?DXUTFindValidDeviceSettings@@YAJPAUDXUTDeviceSettings@@0PAUDXUTMatchOptions@@@Z ENDP ; DXUTFindValidDeviceSettings
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTRender3DEnvironment@@YAXXZ
_TEXT	SEGMENT
tv403 = -684						; size = 8
$T1 = -672						; size = 72
$T2 = -592						; size = 72
_nFrame$ = -320						; size = 4
_rcClient$3 = -308					; size = 16
_pCallbackFrameRender$4 = -284				; size = 4
_pCallbackFrameMove$ = -272				; size = 4
_fElapsedTime$ = -260					; size = 4
_fTime$ = -248						; size = 8
_pDeviceSettings$5 = -232				; size = 4
_deviceSettings$6 = -220				; size = 72
_matchOptions$7 = -140					; size = 60
_pDeviceSettings$8 = -72				; size = 4
_pD3D$9 = -60						; size = 4
_adapterDesktopDisplayMode$10 = -48			; size = 16
_pd3dDevice$ = -24					; size = 4
_hr$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?DXUTRender3DEnvironment@@YAXXZ PROC			; DXUTRender3DEnvironment, COMDAT

; 3504 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 684				; 000002acH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-684]
	mov	ecx, 171				; 000000abH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3505 :     HRESULT hr;
; 3506 :    
; 3507 :     IDirect3DDevice9* pd3dDevice = DXUTGetD3DDevice();

	call	?DXUTGetD3DDevice@@YAPAUIDirect3DDevice9@@XZ ; DXUTGetD3DDevice
	mov	DWORD PTR _pd3dDevice$[ebp], eax

; 3508 :     if( NULL == pd3dDevice )

	cmp	DWORD PTR _pd3dDevice$[ebp], 0
	jne	SHORT $LN31@DXUTRender

; 3509 :         return;

	jmp	$LN32@DXUTRender
$LN31@DXUTRender:

; 3510 :  
; 3511 :     if( GetDXUTState().GetDeviceLost() || DXUTIsRenderingPaused() )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetDeviceLost@DXUTState@@QAE_NXZ	; DXUTState::GetDeviceLost
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN29@DXUTRender
	call	?DXUTIsRenderingPaused@@YA_NXZ		; DXUTIsRenderingPaused
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN30@DXUTRender
$LN29@DXUTRender:

; 3512 :     {
; 3513 :         // Window is minimized or paused so yield 
; 3514 :         // CPU time to other processes
; 3515 :         Sleep( 100 ); 

	mov	esi, esp
	push	100					; 00000064H
	call	DWORD PTR __imp__Sleep@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN30@DXUTRender:

; 3516 :     }
; 3517 : 
; 3518 :     if( !GetDXUTState().GetActive() )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetActive@DXUTState@@QAE_NXZ		; DXUTState::GetActive
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN28@DXUTRender

; 3519 :     {
; 3520 :         // Window is not in focus so yield CPU time to other processes
; 3521 :         Sleep( 20 );

	mov	esi, esp
	push	20					; 00000014H
	call	DWORD PTR __imp__Sleep@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN28@DXUTRender:

; 3522 :     }
; 3523 : 
; 3524 :     if( GetDXUTState().GetDeviceLost() && !GetDXUTState().GetRenderingPaused() )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetDeviceLost@DXUTState@@QAE_NXZ	; DXUTState::GetDeviceLost
	movzx	eax, al
	test	eax, eax
	je	$LN27@DXUTRender
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetRenderingPaused@DXUTState@@QAE_NXZ	; DXUTState::GetRenderingPaused
	movzx	eax, al
	test	eax, eax
	jne	$LN27@DXUTRender

; 3525 :     {
; 3526 :         // Test the cooperative level to see if it's okay to render
; 3527 :         if( FAILED( hr = pd3dDevice->TestCooperativeLevel() ) )

	mov	eax, DWORD PTR _pd3dDevice$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR _pd3dDevice$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+12]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	$LN13@DXUTRender

; 3528 :         {
; 3529 :             if( D3DERR_DEVICELOST == hr )

	cmp	DWORD PTR _hr$[ebp], -2005530520	; 88760868H
	jne	SHORT $LN25@DXUTRender

; 3530 :             {
; 3531 :                 // The device has been lost but cannot be reset at this time.  
; 3532 :                 // So wait until it can be reset.
; 3533 :                 Sleep( 50 );

	mov	esi, esp
	push	50					; 00000032H
	call	DWORD PTR __imp__Sleep@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3534 :                 return;

	jmp	$LN32@DXUTRender
$LN25@DXUTRender:

; 3535 :             }
; 3536 : 
; 3537 :             // If we are windowed, read the desktop format and 
; 3538 :             // ensure that the Direct3D device is using the same format 
; 3539 :             // since the user could have changed the desktop bitdepth 
; 3540 :             if( DXUTIsWindowed() )

	call	?DXUTIsWindowed@@YA_NXZ			; DXUTIsWindowed
	movzx	eax, al
	test	eax, eax
	je	$LN23@DXUTRender

; 3541 :             {
; 3542 :                 D3DDISPLAYMODE adapterDesktopDisplayMode;
; 3543 :                 IDirect3D9* pD3D = DXUTGetD3DObject();

	call	?DXUTGetD3DObject@@YAPAUIDirect3D9@@XZ	; DXUTGetD3DObject
	mov	DWORD PTR _pD3D$9[ebp], eax

; 3544 :                 DXUTDeviceSettings* pDeviceSettings = GetDXUTState().GetCurrentDeviceSettings();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetCurrentDeviceSettings@DXUTState@@QAEPAUDXUTDeviceSettings@@XZ ; DXUTState::GetCurrentDeviceSettings
	mov	DWORD PTR _pDeviceSettings$8[ebp], eax

; 3545 :                 pD3D->GetAdapterDisplayMode( pDeviceSettings->AdapterOrdinal, &adapterDesktopDisplayMode );

	mov	esi, esp
	lea	eax, DWORD PTR _adapterDesktopDisplayMode$10[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeviceSettings$8[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pD3D$9[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pD3D$9[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+32]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3546 :                 if( pDeviceSettings->AdapterFormat != adapterDesktopDisplayMode.Format )

	mov	eax, DWORD PTR _pDeviceSettings$8[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _adapterDesktopDisplayMode$10[ebp+12]
	je	$LN23@DXUTRender

; 3547 :                 {
; 3548 :                     DXUTMatchOptions matchOptions;
; 3549 :                     matchOptions.eAdapterOrdinal     = DXUTMT_PRESERVE_INPUT;

	mov	DWORD PTR _matchOptions$7[ebp], 1

; 3550 :                     matchOptions.eDeviceType         = DXUTMT_PRESERVE_INPUT;

	mov	DWORD PTR _matchOptions$7[ebp+4], 1

; 3551 :                     matchOptions.eWindowed           = DXUTMT_PRESERVE_INPUT;

	mov	DWORD PTR _matchOptions$7[ebp+8], 1

; 3552 :                     matchOptions.eAdapterFormat      = DXUTMT_PRESERVE_INPUT;

	mov	DWORD PTR _matchOptions$7[ebp+12], 1

; 3553 :                     matchOptions.eVertexProcessing   = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$7[ebp+16], 2

; 3554 :                     matchOptions.eResolution         = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$7[ebp+20], 2

; 3555 :                     matchOptions.eBackBufferFormat   = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$7[ebp+24], 2

; 3556 :                     matchOptions.eBackBufferCount    = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$7[ebp+28], 2

; 3557 :                     matchOptions.eMultiSample        = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$7[ebp+32], 2

; 3558 :                     matchOptions.eSwapEffect         = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$7[ebp+36], 2

; 3559 :                     matchOptions.eDepthFormat        = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$7[ebp+40], 2

; 3560 :                     matchOptions.eStencilFormat      = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$7[ebp+44], 2

; 3561 :                     matchOptions.ePresentFlags       = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$7[ebp+48], 2

; 3562 :                     matchOptions.eRefreshRate        = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$7[ebp+52], 2

; 3563 :                     matchOptions.ePresentInterval    = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$7[ebp+56], 2

; 3564 : 
; 3565 :                     DXUTDeviceSettings deviceSettings = DXUTGetDeviceSettings();

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?DXUTGetDeviceSettings@@YA?AUDXUTDeviceSettings@@XZ ; DXUTGetDeviceSettings
	add	esp, 4
	mov	ecx, 18					; 00000012H
	mov	esi, eax
	lea	edi, DWORD PTR $T1[ebp]
	rep movsd
	mov	ecx, 18					; 00000012H
	lea	esi, DWORD PTR $T1[ebp]
	lea	edi, DWORD PTR _deviceSettings$6[ebp]
	rep movsd

; 3566 :                     deviceSettings.AdapterFormat = adapterDesktopDisplayMode.Format;

	mov	eax, DWORD PTR _adapterDesktopDisplayMode$10[ebp+12]
	mov	DWORD PTR _deviceSettings$6[ebp+8], eax

; 3567 : 
; 3568 :                     hr = DXUTFindValidDeviceSettings( &deviceSettings, &deviceSettings, &matchOptions );

	lea	eax, DWORD PTR _matchOptions$7[ebp]
	push	eax
	lea	ecx, DWORD PTR _deviceSettings$6[ebp]
	push	ecx
	lea	edx, DWORD PTR _deviceSettings$6[ebp]
	push	edx
	call	?DXUTFindValidDeviceSettings@@YAJPAUDXUTDeviceSettings@@0PAUDXUTMatchOptions@@@Z ; DXUTFindValidDeviceSettings
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _hr$[ebp], eax

; 3569 :                     if( FAILED(hr) ) // the call will fail if no valid devices were found

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN22@DXUTRender

; 3570 :                     {
; 3571 :                         DXUTDisplayErrorMessage( DXUTERR_NOCOMPATIBLEDEVICES );

	push	-2147219198				; 80040902H
	call	?DXUTDisplayErrorMessage@@YAXJ@Z	; DXUTDisplayErrorMessage
	add	esp, 4

; 3572 :                         DXUTShutdown();

	push	0
	call	?DXUTShutdown@@YAXH@Z			; DXUTShutdown
	add	esp, 4
$LN22@DXUTRender:

; 3573 :                     }
; 3574 : 
; 3575 :                     // Change to a Direct3D device created from the new device settings.  
; 3576 :                     // If there is an existing device, then either reset or recreate the scene
; 3577 :                     hr = DXUTChangeDevice( &deviceSettings, NULL, false, false );

	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _deviceSettings$6[ebp]
	push	eax
	call	?DXUTChangeDevice@@YAJPAUDXUTDeviceSettings@@PAUIDirect3DDevice9@@_N2@Z ; DXUTChangeDevice
	add	esp, 16					; 00000010H
	mov	DWORD PTR _hr$[ebp], eax

; 3578 :                     if( FAILED(hr) )  

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN20@DXUTRender

; 3579 :                     {
; 3580 :                         // If this fails, try to go fullscreen and if this fails also shutdown.
; 3581 :                         if( FAILED(DXUTToggleFullScreen()) )

	call	?DXUTToggleFullScreen@@YAJXZ		; DXUTToggleFullScreen
	test	eax, eax
	jge	SHORT $LN20@DXUTRender

; 3582 :                             DXUTShutdown();

	push	0
	call	?DXUTShutdown@@YAXH@Z			; DXUTShutdown
	add	esp, 4
$LN20@DXUTRender:

; 3583 :                     }
; 3584 : 
; 3585 :                     return;

	jmp	$LN32@DXUTRender
$LN23@DXUTRender:

; 3586 :                 }
; 3587 :             }
; 3588 : 
; 3589 :             // Try to reset the device
; 3590 :             if( FAILED( hr = DXUTReset3DEnvironment() ) )

	call	?DXUTReset3DEnvironment@@YAJXZ		; DXUTReset3DEnvironment
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	$LN13@DXUTRender

; 3591 :             {
; 3592 :                 if( D3DERR_DEVICELOST == hr )

	cmp	DWORD PTR _hr$[ebp], -2005530520	; 88760868H
	jne	SHORT $LN18@DXUTRender

; 3593 :                 {
; 3594 :                     // The device was lost again, so continue waiting until it can be reset.
; 3595 :                     Sleep( 50 );

	mov	esi, esp
	push	50					; 00000032H
	call	DWORD PTR __imp__Sleep@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3596 :                     return;

	jmp	$LN32@DXUTRender

; 3597 :                 }
; 3598 :                 else if( DXUTERR_RESETTINGDEVICEOBJECTS == hr || 

	jmp	SHORT $LN13@DXUTRender
$LN18@DXUTRender:

; 3599 :                          DXUTERR_MEDIANOTFOUND == hr )

	cmp	DWORD PTR _hr$[ebp], -2147219192	; 80040908H
	je	SHORT $LN15@DXUTRender
	cmp	DWORD PTR _hr$[ebp], -2147219197	; 80040903H
	jne	SHORT $LN16@DXUTRender
$LN15@DXUTRender:

; 3600 :                 {
; 3601 :                     DXUTDisplayErrorMessage( hr );

	mov	eax, DWORD PTR _hr$[ebp]
	push	eax
	call	?DXUTDisplayErrorMessage@@YAXJ@Z	; DXUTDisplayErrorMessage
	add	esp, 4

; 3602 :                     DXUTShutdown();

	push	0
	call	?DXUTShutdown@@YAXH@Z			; DXUTShutdown
	add	esp, 4

; 3603 :                     return;

	jmp	$LN32@DXUTRender

; 3604 :                 }
; 3605 :                 else

	jmp	SHORT $LN13@DXUTRender
$LN16@DXUTRender:

; 3606 :                 {
; 3607 :                     // Reset failed, but the device wasn't lost so something bad happened, 
; 3608 :                     // so recreate the device to try to recover
; 3609 :                     DXUTDeviceSettings* pDeviceSettings = GetDXUTState().GetCurrentDeviceSettings();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetCurrentDeviceSettings@DXUTState@@QAEPAUDXUTDeviceSettings@@XZ ; DXUTState::GetCurrentDeviceSettings
	mov	DWORD PTR _pDeviceSettings$5[ebp], eax

; 3610 :                     if( FAILED( DXUTChangeDevice( pDeviceSettings, NULL, true, false ) ) )

	push	0
	push	1
	push	0
	mov	eax, DWORD PTR _pDeviceSettings$5[ebp]
	push	eax
	call	?DXUTChangeDevice@@YAJPAUDXUTDeviceSettings@@PAUIDirect3DDevice9@@_N2@Z ; DXUTChangeDevice
	add	esp, 16					; 00000010H
	test	eax, eax
	jge	SHORT $LN13@DXUTRender

; 3611 :                     {
; 3612 :                         DXUTShutdown();

	push	0
	call	?DXUTShutdown@@YAXH@Z			; DXUTShutdown
	add	esp, 4

; 3613 :                         return;

	jmp	$LN32@DXUTRender
$LN13@DXUTRender:

; 3614 :                     }
; 3615 :                 }
; 3616 :             }
; 3617 :         }
; 3618 : 
; 3619 :         GetDXUTState().SetDeviceLost( false );

	push	0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetDeviceLost@DXUTState@@QAEX_N@Z	; DXUTState::SetDeviceLost
$LN27@DXUTRender:

; 3620 :     }
; 3621 : 
; 3622 :     // Get the app's time, in seconds. Skip rendering if no time elapsed
; 3623 :     double fTime        = DXUTGetGlobalTimer()->GetTime();

	call	?DXUTGetGlobalTimer@@YAPAVCDXUTTimer@@XZ ; DXUTGetGlobalTimer
	mov	ecx, eax
	call	?GetTime@CDXUTTimer@@QAENXZ		; CDXUTTimer::GetTime
	fstp	QWORD PTR _fTime$[ebp]

; 3624 :     float fElapsedTime  = (float) DXUTGetGlobalTimer()->GetElapsedTime();

	call	?DXUTGetGlobalTimer@@YAPAVCDXUTTimer@@XZ ; DXUTGetGlobalTimer
	mov	ecx, eax
	call	?GetElapsedTime@CDXUTTimer@@QAENXZ	; CDXUTTimer::GetElapsedTime
	fstp	DWORD PTR _fElapsedTime$[ebp]

; 3625 : 
; 3626 :     // Store the time for the app
; 3627 :     if( GetDXUTState().GetConstantFrameTime() )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetConstantFrameTime@DXUTState@@QAE_NXZ ; DXUTState::GetConstantFrameTime
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN12@DXUTRender

; 3628 :     {        
; 3629 :         fElapsedTime = GetDXUTState().GetTimePerFrame();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetTimePerFrame@DXUTState@@QAEMXZ	; DXUTState::GetTimePerFrame
	fstp	DWORD PTR _fElapsedTime$[ebp]

; 3630 :         fTime     = DXUTGetTime() + fElapsedTime;

	call	?DXUTGetTime@@YANXZ			; DXUTGetTime
	fstp	QWORD PTR tv403[ebp]
	movsd	xmm0, QWORD PTR tv403[ebp]
	cvtss2sd xmm1, DWORD PTR _fElapsedTime$[ebp]
	addsd	xmm0, xmm1
	movsd	QWORD PTR _fTime$[ebp], xmm0
$LN12@DXUTRender:

; 3631 :     }
; 3632 : 
; 3633 :     GetDXUTState().SetTime( fTime );

	sub	esp, 8
	movsd	xmm0, QWORD PTR _fTime$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetTime@DXUTState@@QAEXN@Z		; DXUTState::SetTime

; 3634 :     GetDXUTState().SetElapsedTime( fElapsedTime );

	push	ecx
	movss	xmm0, DWORD PTR _fElapsedTime$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetElapsedTime@DXUTState@@QAEXM@Z	; DXUTState::SetElapsedTime

; 3635 : 
; 3636 :     // Update the FPS stats
; 3637 :     DXUTUpdateFrameStats();

	call	?DXUTUpdateFrameStats@@YAXXZ		; DXUTUpdateFrameStats

; 3638 : 
; 3639 :     DXUTHandleTimers();

	call	?DXUTHandleTimers@@YAXXZ		; DXUTHandleTimers

; 3640 : 
; 3641 :     // Animate the scene by calling the app's frame move callback
; 3642 :     LPDXUTCALLBACKFRAMEMOVE pCallbackFrameMove = GetDXUTState().GetFrameMoveFunc();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetFrameMoveFunc@DXUTState@@QAEP6GXPAUIDirect3DDevice9@@NMPAX@ZXZ ; DXUTState::GetFrameMoveFunc
	mov	DWORD PTR _pCallbackFrameMove$[ebp], eax

; 3643 :     if( pCallbackFrameMove != NULL )

	cmp	DWORD PTR _pCallbackFrameMove$[ebp], 0
	je	SHORT $LN10@DXUTRender

; 3644 :     {
; 3645 :         pCallbackFrameMove( pd3dDevice, fTime, fElapsedTime, GetDXUTState().GetFrameMoveFuncUserContext() );

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetFrameMoveFuncUserContext@DXUTState@@QAEPAXXZ ; DXUTState::GetFrameMoveFuncUserContext
	mov	esi, esp
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _fElapsedTime$[ebp]
	movss	DWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _fTime$[ebp]
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _pd3dDevice$[ebp]
	push	eax
	call	DWORD PTR _pCallbackFrameMove$[ebp]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3646 :         pd3dDevice = DXUTGetD3DDevice();

	call	?DXUTGetD3DDevice@@YAPAUIDirect3DDevice9@@XZ ; DXUTGetD3DDevice
	mov	DWORD PTR _pd3dDevice$[ebp], eax

; 3647 :         if( NULL == pd3dDevice ) // Handle DXUTShutdown from inside callback

	cmp	DWORD PTR _pd3dDevice$[ebp], 0
	jne	SHORT $LN10@DXUTRender

; 3648 :             return;

	jmp	$LN32@DXUTRender
$LN10@DXUTRender:

; 3649 :     }
; 3650 : 
; 3651 :     if( !GetDXUTState().GetRenderingPaused() )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetRenderingPaused@DXUTState@@QAE_NXZ	; DXUTState::GetRenderingPaused
	movzx	eax, al
	test	eax, eax
	jne	$LN3@DXUTRender

; 3652 :     {
; 3653 :         // Render the scene by calling the app's render callback
; 3654 :         LPDXUTCALLBACKFRAMERENDER pCallbackFrameRender = GetDXUTState().GetFrameRenderFunc();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetFrameRenderFunc@DXUTState@@QAEP6GXPAUIDirect3DDevice9@@NMPAX@ZXZ ; DXUTState::GetFrameRenderFunc
	mov	DWORD PTR _pCallbackFrameRender$4[ebp], eax

; 3655 :         if( pCallbackFrameRender != NULL )

	cmp	DWORD PTR _pCallbackFrameRender$4[ebp], 0
	je	SHORT $LN7@DXUTRender

; 3656 :         {
; 3657 :             pCallbackFrameRender( pd3dDevice, fTime, fElapsedTime, GetDXUTState().GetFrameRenderFuncUserContext() );

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetFrameRenderFuncUserContext@DXUTState@@QAEPAXXZ ; DXUTState::GetFrameRenderFuncUserContext
	mov	esi, esp
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _fElapsedTime$[ebp]
	movss	DWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _fTime$[ebp]
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _pd3dDevice$[ebp]
	push	eax
	call	DWORD PTR _pCallbackFrameRender$4[ebp]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3658 :             pd3dDevice = DXUTGetD3DDevice();

	call	?DXUTGetD3DDevice@@YAPAUIDirect3DDevice9@@XZ ; DXUTGetD3DDevice
	mov	DWORD PTR _pd3dDevice$[ebp], eax

; 3659 :             if( NULL == pd3dDevice ) // Handle DXUTShutdown from inside callback

	cmp	DWORD PTR _pd3dDevice$[ebp], 0
	jne	SHORT $LN7@DXUTRender

; 3660 :                 return;

	jmp	$LN32@DXUTRender
$LN7@DXUTRender:

; 3661 :         }
; 3662 : 
; 3663 : #if defined(DEBUG) | defined(_DEBUG)
; 3664 :         // The back buffer should always match the client rect 
; 3665 :         // if the Direct3D backbuffer covers the entire window
; 3666 :         RECT rcClient;
; 3667 :         GetClientRect( DXUTGetHWND(), &rcClient );

	mov	esi, esp
	lea	eax, DWORD PTR _rcClient$3[ebp]
	push	eax
	call	?DXUTGetHWND@@YAPAUHWND__@@XZ		; DXUTGetHWND
	push	eax
	call	DWORD PTR __imp__GetClientRect@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3668 :         assert( DXUTGetBackBufferSurfaceDesc()->Width == (UINT)rcClient.right );

	call	?DXUTGetBackBufferSurfaceDesc@@YAPBU_D3DSURFACE_DESC@@XZ ; DXUTGetBackBufferSurfaceDesc
	mov	eax, DWORD PTR [eax+24]
	cmp	eax, DWORD PTR _rcClient$3[ebp+8]
	je	SHORT $LN34@DXUTRender
	mov	ecx, DWORD PTR ?__LINE__Var@?1??DXUTRender3DEnvironment@@YAXXZ@4JA
	add	ecx, 164				; 000000a4H
	push	ecx
	push	OFFSET ??_C@_1FG@OJNOEDOF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
	push	OFFSET ??_C@_1HM@DAKFLFBC@?$AAD?$AAX?$AAU?$AAT?$AAG?$AAe?$AAt?$AAB?$AAa?$AAc?$AAk?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAS?$AAu?$AAr?$AAf?$AAa?$AAc?$AAe?$AAD?$AAe?$AAs?$AAc?$AA?$CI?$AA?$CJ?$AA?9?$AA?$DO@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN34@DXUTRender:

; 3669 :         assert( DXUTGetBackBufferSurfaceDesc()->Height == (UINT)rcClient.bottom );

	call	?DXUTGetBackBufferSurfaceDesc@@YAPBU_D3DSURFACE_DESC@@XZ ; DXUTGetBackBufferSurfaceDesc
	mov	eax, DWORD PTR [eax+28]
	cmp	eax, DWORD PTR _rcClient$3[ebp+12]
	je	SHORT $LN35@DXUTRender
	mov	ecx, DWORD PTR ?__LINE__Var@?1??DXUTRender3DEnvironment@@YAXXZ@4JA
	add	ecx, 165				; 000000a5H
	push	ecx
	push	OFFSET ??_C@_1FG@OJNOEDOF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAs?$AAa?$AAc?$AAo?$AA?2?$AAd?$AA3?$AAd?$AA9?$AA?2?$AAc?$AAo?$AAm?$AAm?$AAo@
	push	OFFSET ??_C@_1IA@LBHFHEOB@?$AAD?$AAX?$AAU?$AAT?$AAG?$AAe?$AAt?$AAB?$AAa?$AAc?$AAk?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAS?$AAu?$AAr?$AAf?$AAa?$AAc?$AAe?$AAD?$AAe?$AAs?$AAc?$AA?$CI?$AA?$CJ?$AA?9?$AA?$DO@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN35@DXUTRender:

; 3670 : #endif
; 3671 : 
; 3672 :         // Show the frame on the primary surface.
; 3673 :         hr = pd3dDevice->Present( NULL, NULL, NULL, NULL );

	mov	esi, esp
	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _pd3dDevice$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pd3dDevice$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+68]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 3674 :         if( FAILED(hr) )

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN3@DXUTRender

; 3675 :         {
; 3676 :             if( D3DERR_DEVICELOST == hr )

	cmp	DWORD PTR _hr$[ebp], -2005530520	; 88760868H
	jne	SHORT $LN5@DXUTRender

; 3677 :             {
; 3678 :                 GetDXUTState().SetDeviceLost( true );

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetDeviceLost@DXUTState@@QAEX_N@Z	; DXUTState::SetDeviceLost
	jmp	SHORT $LN3@DXUTRender
$LN5@DXUTRender:

; 3679 :             }
; 3680 :             else if( D3DERR_DRIVERINTERNALERROR == hr )

	cmp	DWORD PTR _hr$[ebp], -2005530585	; 88760827H
	jne	SHORT $LN3@DXUTRender

; 3681 :             {
; 3682 :                 // When D3DERR_DRIVERINTERNALERROR is returned from Present(),
; 3683 :                 // the application can do one of the following:
; 3684 :                 // 
; 3685 :                 // - End, with the pop-up window saying that the application cannot continue 
; 3686 :                 //   because of problems in the display adapter and that the user should 
; 3687 :                 //   contact the adapter manufacturer.
; 3688 :                 //
; 3689 :                 // - Attempt to restart by calling IDirect3DDevice9::Reset, which is essentially the same 
; 3690 :                 //   path as recovering from a lost device. If IDirect3DDevice9::Reset fails with 
; 3691 :                 //   D3DERR_DRIVERINTERNALERROR, the application should end immediately with the message 
; 3692 :                 //   that the user should contact the adapter manufacturer.
; 3693 :                 // 
; 3694 :                 // The framework attempts the path of resetting the device
; 3695 :                 // 
; 3696 :                 GetDXUTState().SetDeviceLost( true );

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetDeviceLost@DXUTState@@QAEX_N@Z	; DXUTState::SetDeviceLost
$LN3@DXUTRender:

; 3697 :             }
; 3698 :         }
; 3699 :     }
; 3700 : 
; 3701 :     // Update current frame #
; 3702 :     int nFrame = GetDXUTState().GetCurrentFrameNumber();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetCurrentFrameNumber@DXUTState@@QAEHXZ ; DXUTState::GetCurrentFrameNumber
	mov	DWORD PTR _nFrame$[ebp], eax

; 3703 :     nFrame++;

	mov	eax, DWORD PTR _nFrame$[ebp]
	add	eax, 1
	mov	DWORD PTR _nFrame$[ebp], eax

; 3704 :     GetDXUTState().SetCurrentFrameNumber( nFrame );

	mov	eax, DWORD PTR _nFrame$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetCurrentFrameNumber@DXUTState@@QAEXH@Z ; DXUTState::SetCurrentFrameNumber

; 3705 : 
; 3706 :     // Check to see if the app should shutdown due to cmdline
; 3707 :     if( GetDXUTState().GetOverrideQuitAfterFrame() != 0 )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetOverrideQuitAfterFrame@DXUTState@@QAEHXZ ; DXUTState::GetOverrideQuitAfterFrame
	test	eax, eax
	je	SHORT $LN1@DXUTRender

; 3708 :     {
; 3709 :         if( nFrame > GetDXUTState().GetOverrideQuitAfterFrame() )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetOverrideQuitAfterFrame@DXUTState@@QAEHXZ ; DXUTState::GetOverrideQuitAfterFrame
	cmp	DWORD PTR _nFrame$[ebp], eax
	jle	SHORT $LN1@DXUTRender

; 3710 :             DXUTShutdown();

	push	0
	call	?DXUTShutdown@@YAXH@Z			; DXUTShutdown
	add	esp, 4
$LN1@DXUTRender:
$LN32@DXUTRender:

; 3711 :     }
; 3712 : 
; 3713 :     return;
; 3714 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN41@DXUTRender
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 684				; 000002acH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN41@DXUTRender:
	DD	4
	DD	$LN40@DXUTRender
$LN40@DXUTRender:
	DD	-48					; ffffffd0H
	DD	16					; 00000010H
	DD	$LN36@DXUTRender
	DD	-140					; ffffff74H
	DD	60					; 0000003cH
	DD	$LN37@DXUTRender
	DD	-220					; ffffff24H
	DD	72					; 00000048H
	DD	$LN38@DXUTRender
	DD	-308					; fffffeccH
	DD	16					; 00000010H
	DD	$LN39@DXUTRender
$LN39@DXUTRender:
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	67					; 00000043H
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
$LN38@DXUTRender:
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	118					; 00000076H
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	83					; 00000053H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	115					; 00000073H
	DB	0
$LN37@DXUTRender:
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	79					; 0000004fH
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	115					; 00000073H
	DB	0
$LN36@DXUTRender:
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	68					; 00000044H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	107					; 0000006bH
	DB	116					; 00000074H
	DB	111					; 0000006fH
	DB	112					; 00000070H
	DB	68					; 00000044H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	77					; 0000004dH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
?DXUTRender3DEnvironment@@YAXXZ ENDP			; DXUTRender3DEnvironment
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTMainLoop@@YAJPAUHACCEL__@@@Z
_TEXT	SEGMENT
tv215 = -268						; size = 4
_msg$ = -68						; size = 28
_bGotMsg$ = -29						; size = 1
_hWnd$ = -20						; size = 4
_hr$ = -8						; size = 4
_hAccel$ = 8						; size = 4
?DXUTMainLoop@@YAJPAUHACCEL__@@@Z PROC			; DXUTMainLoop, COMDAT

; 3413 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-268]
	mov	ecx, 67					; 00000043H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3414 :     HRESULT hr;
; 3415 : 
; 3416 :     // Not allowed to call this from inside the device callbacks or reenter
; 3417 :     if( GetDXUTState().GetInsideDeviceCallback() || GetDXUTState().GetInsideMainloop() )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetInsideDeviceCallback@DXUTState@@QAE_NXZ ; DXUTState::GetInsideDeviceCallback
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN21@DXUTMainLo
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetInsideMainloop@DXUTState@@QAE_NXZ	; DXUTState::GetInsideMainloop
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN22@DXUTMainLo
$LN21@DXUTMainLo:

; 3418 :     {
; 3419 :         if( (GetDXUTState().GetExitCode() == 0) || (GetDXUTState().GetExitCode() == 11) )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetExitCode@DXUTState@@QAEHXZ		; DXUTState::GetExitCode
	test	eax, eax
	je	SHORT $LN19@DXUTMainLo
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetExitCode@DXUTState@@QAEHXZ		; DXUTState::GetExitCode
	cmp	eax, 11					; 0000000bH
	jne	SHORT $LN20@DXUTMainLo
$LN19@DXUTMainLo:

; 3420 :             GetDXUTState().SetExitCode(1);

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetExitCode@DXUTState@@QAEXH@Z		; DXUTState::SetExitCode
$LN20@DXUTMainLo:

; 3421 :         return DXUT_ERR_MSGBOX( "DXUTMainLoop", E_FAIL );

	push	1
	push	OFFSET ??_C@_0N@IDGALNHJ@DXUTMainLoop?$AA@
	push	-2147467259				; 80004005H
	mov	eax, DWORD PTR ?__LINE__Var@?1??DXUTMainLoop@@YAJPAUHACCEL__@@@Z@4JA
	add	eax, 8
	push	eax
	push	OFFSET ??_C@_0CL@KBAHBIDF@z?3?2sampsrc?202xu1?2saco?2d3d9?2commo@
	call	?DXUTTrace@@YGJPBDKJ0_N@Z		; DXUTTrace
	jmp	$LN23@DXUTMainLo
$LN22@DXUTMainLo:

; 3422 :     }
; 3423 : 
; 3424 :     GetDXUTState().SetInsideMainloop( true );

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetInsideMainloop@DXUTState@@QAEX_N@Z	; DXUTState::SetInsideMainloop

; 3425 : 
; 3426 :     // If DXUTCreateDevice*() or DXUTSetDevice() has not already been called, 
; 3427 :     // then call DXUTCreateDevice() with the default parameters.         
; 3428 :     if( !GetDXUTState().GetDeviceCreated() ) 

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetDeviceCreated@DXUTState@@QAE_NXZ	; DXUTState::GetDeviceCreated
	movzx	eax, al
	test	eax, eax
	jne	$LN18@DXUTMainLo

; 3429 :     {
; 3430 :         if( GetDXUTState().GetDeviceCreateCalled() )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetDeviceCreateCalled@DXUTState@@QAE_NXZ ; DXUTState::GetDeviceCreateCalled
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN17@DXUTMainLo

; 3431 :         {
; 3432 :             if( (GetDXUTState().GetExitCode() == 0) || (GetDXUTState().GetExitCode() == 11) )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetExitCode@DXUTState@@QAEHXZ		; DXUTState::GetExitCode
	test	eax, eax
	je	SHORT $LN15@DXUTMainLo
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetExitCode@DXUTState@@QAEHXZ		; DXUTState::GetExitCode
	cmp	eax, 11					; 0000000bH
	jne	SHORT $LN16@DXUTMainLo
$LN15@DXUTMainLo:

; 3433 :                 GetDXUTState().SetExitCode(1);

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetExitCode@DXUTState@@QAEXH@Z		; DXUTState::SetExitCode
$LN16@DXUTMainLo:

; 3434 :             return E_FAIL; // DXUTCreateDevice() must first succeed for this function to succeed

	mov	eax, -2147467259			; 80004005H
	jmp	$LN23@DXUTMainLo
$LN17@DXUTMainLo:

; 3435 :         }
; 3436 : 
; 3437 :         hr = DXUTCreateDevice();

	push	0
	push	0
	push	0
	push	480					; 000001e0H
	push	640					; 00000280H
	push	1
	push	0
	call	?DXUTCreateDevice@@YAJI_NHHP6G_NPAU_D3DCAPS9@@W4_D3DFORMAT@@20PAX@ZP6G_NPAUDXUTDeviceSettings@@PBU1@3@Z3@Z ; DXUTCreateDevice
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _hr$[ebp], eax

; 3438 :         if( FAILED(hr) )

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN18@DXUTMainLo

; 3439 :         {
; 3440 :             if( (GetDXUTState().GetExitCode() == 0) || (GetDXUTState().GetExitCode() == 11) )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetExitCode@DXUTState@@QAEHXZ		; DXUTState::GetExitCode
	test	eax, eax
	je	SHORT $LN12@DXUTMainLo
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetExitCode@DXUTState@@QAEHXZ		; DXUTState::GetExitCode
	cmp	eax, 11					; 0000000bH
	jne	SHORT $LN13@DXUTMainLo
$LN12@DXUTMainLo:

; 3441 :                 GetDXUTState().SetExitCode(1);

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetExitCode@DXUTState@@QAEXH@Z		; DXUTState::SetExitCode
$LN13@DXUTMainLo:

; 3442 :             return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	jmp	$LN23@DXUTMainLo
$LN18@DXUTMainLo:

; 3443 :         }
; 3444 :     }
; 3445 : 
; 3446 :     HWND hWnd = DXUTGetHWND();

	call	?DXUTGetHWND@@YAPAUHWND__@@XZ		; DXUTGetHWND
	mov	DWORD PTR _hWnd$[ebp], eax

; 3447 : 
; 3448 :     // DXUTInit() must have been called and succeeded for this function to proceed
; 3449 :     // DXUTCreateWindow() or DXUTSetWindow() must have been called and succeeded for this function to proceed
; 3450 :     // DXUTCreateDevice() or DXUTCreateDeviceFromSettings() or DXUTSetDevice() must have been called and succeeded for this function to proceed
; 3451 :     if( !GetDXUTState().GetDXUTInited() || !GetDXUTState().GetWindowCreated() || !GetDXUTState().GetDeviceCreated() )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetDXUTInited@DXUTState@@QAE_NXZ	; DXUTState::GetDXUTInited
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@DXUTMainLo
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetWindowCreated@DXUTState@@QAE_NXZ	; DXUTState::GetWindowCreated
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@DXUTMainLo
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetDeviceCreated@DXUTState@@QAE_NXZ	; DXUTState::GetDeviceCreated
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN11@DXUTMainLo
$LN10@DXUTMainLo:

; 3452 :     {
; 3453 :         if( (GetDXUTState().GetExitCode() == 0) || (GetDXUTState().GetExitCode() == 11) )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetExitCode@DXUTState@@QAEHXZ		; DXUTState::GetExitCode
	test	eax, eax
	je	SHORT $LN8@DXUTMainLo
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetExitCode@DXUTState@@QAEHXZ		; DXUTState::GetExitCode
	cmp	eax, 11					; 0000000bH
	jne	SHORT $LN9@DXUTMainLo
$LN8@DXUTMainLo:

; 3454 :             GetDXUTState().SetExitCode(1);

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetExitCode@DXUTState@@QAEXH@Z		; DXUTState::SetExitCode
$LN9@DXUTMainLo:

; 3455 :         return DXUT_ERR_MSGBOX( "DXUTMainLoop", E_FAIL );

	push	1
	push	OFFSET ??_C@_0N@IDGALNHJ@DXUTMainLoop?$AA@
	push	-2147467259				; 80004005H
	mov	eax, DWORD PTR ?__LINE__Var@?1??DXUTMainLoop@@YAJPAUHACCEL__@@@Z@4JA
	add	eax, 42					; 0000002aH
	push	eax
	push	OFFSET ??_C@_0CL@KBAHBIDF@z?3?2sampsrc?202xu1?2saco?2d3d9?2commo@
	call	?DXUTTrace@@YGJPBDKJ0_N@Z		; DXUTTrace
	jmp	$LN23@DXUTMainLo
$LN11@DXUTMainLo:

; 3456 :     }
; 3457 : 
; 3458 :     // Now we're ready to receive and process Windows messages.
; 3459 :     bool bGotMsg;
; 3460 :     MSG  msg;
; 3461 :     msg.message = WM_NULL;

	mov	DWORD PTR _msg$[ebp+4], 0

; 3462 :     PeekMessage( &msg, NULL, 0U, 0U, PM_NOREMOVE );

	mov	esi, esp
	push	0
	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	DWORD PTR __imp__PeekMessageA@20
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@DXUTMainLo:

; 3463 : 
; 3464 :     while( WM_QUIT != msg.message  )

	cmp	DWORD PTR _msg$[ebp+4], 18		; 00000012H
	je	$LN6@DXUTMainLo

; 3465 :     {
; 3466 :         // Use PeekMessage() so we can use idle time to render the scene. 
; 3467 :         bGotMsg = ( PeekMessage( &msg, NULL, 0U, 0U, PM_REMOVE ) != 0 );

	mov	esi, esp
	push	1
	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	DWORD PTR __imp__PeekMessageA@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN25@DXUTMainLo
	mov	DWORD PTR tv215[ebp], 1
	jmp	SHORT $LN26@DXUTMainLo
$LN25@DXUTMainLo:
	mov	DWORD PTR tv215[ebp], 0
$LN26@DXUTMainLo:
	mov	cl, BYTE PTR tv215[ebp]
	mov	BYTE PTR _bGotMsg$[ebp], cl

; 3468 : 
; 3469 :         if( bGotMsg )

	movzx	eax, BYTE PTR _bGotMsg$[ebp]
	test	eax, eax
	je	SHORT $LN5@DXUTMainLo

; 3470 :         {
; 3471 :             // Translate and dispatch the message
; 3472 :             if( hAccel == NULL || hWnd == NULL || 
; 3473 :                 0 == TranslateAccelerator( hWnd, hAccel, &msg ) )

	cmp	DWORD PTR _hAccel$[ebp], 0
	je	SHORT $LN3@DXUTMainLo
	cmp	DWORD PTR _hWnd$[ebp], 0
	je	SHORT $LN3@DXUTMainLo
	mov	esi, esp
	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hAccel$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hWnd$[ebp]
	push	edx
	call	DWORD PTR __imp__TranslateAcceleratorA@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN4@DXUTMainLo
$LN3@DXUTMainLo:

; 3474 :             {
; 3475 :                 TranslateMessage( &msg );

	mov	esi, esp
	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	DWORD PTR __imp__TranslateMessage@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3476 :                 DispatchMessage( &msg );

	mov	esi, esp
	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	DWORD PTR __imp__DispatchMessageA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@DXUTMainLo:

; 3477 :             }
; 3478 :         }
; 3479 :         else

	jmp	SHORT $LN2@DXUTMainLo
$LN5@DXUTMainLo:

; 3480 :         {
; 3481 :             // Render a frame during idle time (no messages are waiting)
; 3482 :             DXUTRender3DEnvironment();

	call	?DXUTRender3DEnvironment@@YAXXZ		; DXUTRender3DEnvironment
$LN2@DXUTMainLo:

; 3483 :         }
; 3484 :     }

	jmp	$LN7@DXUTMainLo
$LN6@DXUTMainLo:

; 3485 : 
; 3486 :     // Cleanup the accelerator table
; 3487 :     if( hAccel != NULL )

	cmp	DWORD PTR _hAccel$[ebp], 0
	je	SHORT $LN1@DXUTMainLo

; 3488 :         DestroyAcceleratorTable( hAccel );

	mov	esi, esp
	mov	eax, DWORD PTR _hAccel$[ebp]
	push	eax
	call	DWORD PTR __imp__DestroyAcceleratorTable@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@DXUTMainLo:

; 3489 : 
; 3490 :     GetDXUTState().SetInsideMainloop( false );

	push	0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetInsideMainloop@DXUTState@@QAEX_N@Z	; DXUTState::SetInsideMainloop

; 3491 : 
; 3492 :     return S_OK;

	xor	eax, eax
$LN23@DXUTMainLo:

; 3493 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN29@DXUTMainLo
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 268				; 0000010cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN29@DXUTMainLo:
	DD	1
	DD	$LN28@DXUTMainLo
$LN28@DXUTMainLo:
	DD	-68					; ffffffbcH
	DD	28					; 0000001cH
	DD	$LN27@DXUTMainLo
$LN27@DXUTMainLo:
	DB	109					; 0000006dH
	DB	115					; 00000073H
	DB	103					; 00000067H
	DB	0
?DXUTMainLoop@@YAJPAUHACCEL__@@@Z ENDP			; DXUTMainLoop
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTSetDevice@@YAJPAUIDirect3DDevice9@@@Z
_TEXT	SEGMENT
$T1 = -272						; size = 4
_d3dCreationParams$ = -68				; size = 16
_pSwapChain$2 = -44					; size = 4
_pBackBuffer$ = -32					; size = 4
_pDeviceSettings$ = -20					; size = 4
_hr$ = -8						; size = 4
_pd3dDevice$ = 8					; size = 4
?DXUTSetDevice@@YAJPAUIDirect3DDevice9@@@Z PROC		; DXUTSetDevice, COMDAT

; 1080 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-276]
	mov	ecx, 69					; 00000045H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1081 :     HRESULT hr;
; 1082 : 
; 1083 :     if( pd3dDevice == NULL )

	cmp	DWORD PTR _pd3dDevice$[ebp], 0
	jne	SHORT $LN11@DXUTSetDev

; 1084 :         return DXUT_ERR_MSGBOX( "DXUTSetDevice", E_INVALIDARG );

	push	1
	push	OFFSET ??_C@_0O@KPHAHHEA@DXUTSetDevice?$AA@
	push	-2147024809				; 80070057H
	mov	eax, DWORD PTR ?__LINE__Var@?1??DXUTSetDevice@@YAJPAUIDirect3DDevice9@@@Z@4JA
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_0CL@KBAHBIDF@z?3?2sampsrc?202xu1?2saco?2d3d9?2commo@
	call	?DXUTTrace@@YGJPBDKJ0_N@Z		; DXUTTrace
	jmp	$LN12@DXUTSetDev
$LN11@DXUTSetDev:

; 1085 : 
; 1086 :     // Not allowed to call this from inside the device callbacks
; 1087 :     if( GetDXUTState().GetInsideDeviceCallback() )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetInsideDeviceCallback@DXUTState@@QAE_NXZ ; DXUTState::GetInsideDeviceCallback
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@DXUTSetDev

; 1088 :         return DXUT_ERR_MSGBOX( "DXUTCreateWindow", E_FAIL );

	push	1
	push	OFFSET ??_C@_0BB@LKEDMNKO@DXUTCreateWindow?$AA@
	push	-2147467259				; 80004005H
	mov	eax, DWORD PTR ?__LINE__Var@?1??DXUTSetDevice@@YAJPAUIDirect3DDevice9@@@Z@4JA
	add	eax, 8
	push	eax
	push	OFFSET ??_C@_0CL@KBAHBIDF@z?3?2sampsrc?202xu1?2saco?2d3d9?2commo@
	call	?DXUTTrace@@YGJPBDKJ0_N@Z		; DXUTTrace
	jmp	$LN12@DXUTSetDev
$LN10@DXUTSetDev:

; 1089 : 
; 1090 :     GetDXUTState().SetDeviceCreateCalled( true );

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetDeviceCreateCalled@DXUTState@@QAEX_N@Z ; DXUTState::SetDeviceCreateCalled

; 1091 : 
; 1092 :     // If DXUTCreateWindow() or DXUTSetWindow() has not already been called, 
; 1093 :     // then call DXUTCreateWindow() with the default parameters.         
; 1094 :     if( !GetDXUTState().GetWindowCreated() ) 

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetWindowCreated@DXUTState@@QAE_NXZ	; DXUTState::GetWindowCreated
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN9@DXUTSetDev

; 1095 :     {
; 1096 :         // If DXUTCreateWindow() or DXUTSetWindow() was already called and failed, then fail.
; 1097 :         // DXUTCreateWindow() or DXUTSetWindow() must first succeed for this function to succeed
; 1098 :         if( GetDXUTState().GetWindowCreateCalled() )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetWindowCreateCalled@DXUTState@@QAE_NXZ ; DXUTState::GetWindowCreateCalled
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@DXUTSetDev

; 1099 :             return E_FAIL; 

	mov	eax, -2147467259			; 80004005H
	jmp	$LN12@DXUTSetDev
$LN8@DXUTSetDev:

; 1100 : 
; 1101 :         // If DXUTCreateWindow() or DXUTSetWindow() hasn't been called, then 
; 1102 :         // automatically call DXUTCreateWindow() with default params
; 1103 :         hr = DXUTCreateWindow();

	push	-2147483648				; 80000000H
	push	-2147483648				; 80000000H
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BA@FFFLJHOO@Direct3D?5Window?$AA@
	call	?DXUTCreateWindow@@YAJPBDPAUHINSTANCE__@@PAUHICON__@@PAUHMENU__@@HH@Z ; DXUTCreateWindow
	add	esp, 24					; 00000018H
	mov	DWORD PTR _hr$[ebp], eax

; 1104 :         if( FAILED(hr) )

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN9@DXUTSetDev

; 1105 :             return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	jmp	$LN12@DXUTSetDev
$LN9@DXUTSetDev:

; 1106 :     }
; 1107 : 
; 1108 :     DXUTDeviceSettings* pDeviceSettings = new DXUTDeviceSettings;

	push	72					; 00000048H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _pDeviceSettings$[ebp], eax

; 1109 :     if( pDeviceSettings == NULL )

	cmp	DWORD PTR _pDeviceSettings$[ebp], 0
	jne	SHORT $LN6@DXUTSetDev

; 1110 :         return E_OUTOFMEMORY;

	mov	eax, -2147024882			; 8007000eH
	jmp	$LN12@DXUTSetDev
$LN6@DXUTSetDev:

; 1111 :     ZeroMemory( pDeviceSettings, sizeof(DXUTDeviceSettings) );

	push	72					; 00000048H
	push	0
	mov	eax, DWORD PTR _pDeviceSettings$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1112 : 
; 1113 :     // Get the present params from the swap chain
; 1114 :     IDirect3DSurface9* pBackBuffer = NULL;

	mov	DWORD PTR _pBackBuffer$[ebp], 0

; 1115 :     hr = pd3dDevice->GetBackBuffer( 0, 0, D3DBACKBUFFER_TYPE_MONO, &pBackBuffer );

	mov	esi, esp
	lea	eax, DWORD PTR _pBackBuffer$[ebp]
	push	eax
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _pd3dDevice$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pd3dDevice$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+72]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 1116 :     if( SUCCEEDED(hr) )

	cmp	DWORD PTR _hr$[ebp], 0
	jl	$LN5@DXUTSetDev

; 1117 :     {
; 1118 :         IDirect3DSwapChain9* pSwapChain = NULL;

	mov	DWORD PTR _pSwapChain$2[ebp], 0

; 1119 :         hr = pBackBuffer->GetContainer( IID_IDirect3DSwapChain9, (void**) &pSwapChain );

	mov	esi, esp
	lea	eax, DWORD PTR _pSwapChain$2[ebp]
	push	eax
	push	OFFSET _IID_IDirect3DSwapChain9
	mov	ecx, DWORD PTR _pBackBuffer$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pBackBuffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+44]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 1120 :         if( SUCCEEDED(hr) )

	cmp	DWORD PTR _hr$[ebp], 0
	jl	SHORT $LN4@DXUTSetDev

; 1121 :         {
; 1122 :             pSwapChain->GetPresentParameters( &pDeviceSettings->pp );

	mov	eax, DWORD PTR _pDeviceSettings$[ebp]
	add	eax, 16					; 00000010H
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _pSwapChain$2[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pSwapChain$2[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+36]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1123 :             SAFE_RELEASE( pSwapChain );

	cmp	DWORD PTR _pSwapChain$2[ebp], 0
	je	SHORT $LN4@DXUTSetDev
	mov	eax, DWORD PTR _pSwapChain$2[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR _pSwapChain$2[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pSwapChain$2[ebp], 0
$LN4@DXUTSetDev:

; 1124 :         }
; 1125 : 
; 1126 :         SAFE_RELEASE( pBackBuffer );

	cmp	DWORD PTR _pBackBuffer$[ebp], 0
	je	SHORT $LN5@DXUTSetDev
	mov	eax, DWORD PTR _pBackBuffer$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR _pBackBuffer$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pBackBuffer$[ebp], 0
$LN5@DXUTSetDev:

; 1127 :     }
; 1128 : 
; 1129 :     D3DDEVICE_CREATION_PARAMETERS d3dCreationParams;
; 1130 :     pd3dDevice->GetCreationParameters( &d3dCreationParams );

	mov	esi, esp
	lea	eax, DWORD PTR _d3dCreationParams$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pd3dDevice$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pd3dDevice$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+36]
	call	ecx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1131 : 
; 1132 :     // Fill out the rest of the device settings struct
; 1133 :     pDeviceSettings->AdapterOrdinal = d3dCreationParams.AdapterOrdinal;

	mov	eax, DWORD PTR _pDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _d3dCreationParams$[ebp]
	mov	DWORD PTR [eax], ecx

; 1134 :     pDeviceSettings->DeviceType     = d3dCreationParams.DeviceType;

	mov	eax, DWORD PTR _pDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _d3dCreationParams$[ebp+4]
	mov	DWORD PTR [eax+4], ecx

; 1135 :     DXUTFindAdapterFormat( pDeviceSettings->AdapterOrdinal, pDeviceSettings->DeviceType, 
; 1136 :                            pDeviceSettings->pp.BackBufferFormat, pDeviceSettings->pp.Windowed, 
; 1137 :                            &pDeviceSettings->AdapterFormat );

	mov	eax, DWORD PTR _pDeviceSettings$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _pDeviceSettings$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	mov	eax, DWORD PTR _pDeviceSettings$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	edx, DWORD PTR _pDeviceSettings$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _pDeviceSettings$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?DXUTFindAdapterFormat@@YAJIW4_D3DDEVTYPE@@W4_D3DFORMAT@@HPAW42@@Z ; DXUTFindAdapterFormat
	add	esp, 20					; 00000014H

; 1138 :     pDeviceSettings->BehaviorFlags  = d3dCreationParams.BehaviorFlags;

	mov	eax, DWORD PTR _pDeviceSettings$[ebp]
	mov	ecx, DWORD PTR _d3dCreationParams$[ebp+12]
	mov	DWORD PTR [eax+12], ecx

; 1139 : 
; 1140 :     // Change to the Direct3D device passed in
; 1141 :     hr = DXUTChangeDevice( pDeviceSettings, pd3dDevice, false, false );

	push	0
	push	0
	mov	eax, DWORD PTR _pd3dDevice$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeviceSettings$[ebp]
	push	ecx
	call	?DXUTChangeDevice@@YAJPAUDXUTDeviceSettings@@PAUIDirect3DDevice9@@_N2@Z ; DXUTChangeDevice
	add	esp, 16					; 00000010H
	mov	DWORD PTR _hr$[ebp], eax

; 1142 :     if( FAILED(hr) ) 

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN1@DXUTSetDev

; 1143 :         return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	jmp	SHORT $LN12@DXUTSetDev
$LN1@DXUTSetDev:

; 1144 : 
; 1145 :     return S_OK;

	xor	eax, eax
$LN12@DXUTSetDev:

; 1146 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN18@DXUTSetDev
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN18@DXUTSetDev:
	DD	3
	DD	$LN17@DXUTSetDev
$LN17@DXUTSetDev:
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN14@DXUTSetDev
	DD	-44					; ffffffd4H
	DD	4
	DD	$LN15@DXUTSetDev
	DD	-68					; ffffffbcH
	DD	16					; 00000010H
	DD	$LN16@DXUTSetDev
$LN16@DXUTSetDev:
	DB	100					; 00000064H
	DB	51					; 00000033H
	DB	100					; 00000064H
	DB	67					; 00000043H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	115					; 00000073H
	DB	0
$LN15@DXUTSetDev:
	DB	112					; 00000070H
	DB	83					; 00000053H
	DB	119					; 00000077H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	67					; 00000043H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	0
$LN14@DXUTSetDev:
	DB	112					; 00000070H
	DB	66					; 00000042H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
?DXUTSetDevice@@YAJPAUIDirect3DDevice9@@@Z ENDP		; DXUTSetDevice
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTCreateDeviceFromSettings@@YAJPAUDXUTDeviceSettings@@_N1@Z
_TEXT	SEGMENT
_matchOptions$1 = -80					; size = 60
_hr$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_pDeviceSettings$ = 8					; size = 4
_bPreserveInput$ = 12					; size = 1
_bClipWindowToSingleAdapter$ = 16			; size = 1
?DXUTCreateDeviceFromSettings@@YAJPAUDXUTDeviceSettings@@_N1@Z PROC ; DXUTCreateDeviceFromSettings, COMDAT

; 1156 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-276]
	mov	ecx, 69					; 00000045H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1157 :     HRESULT hr;
; 1158 : 
; 1159 :     GetDXUTState().SetDeviceCreateCalled( true );

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetDeviceCreateCalled@DXUTState@@QAEX_N@Z ; DXUTState::SetDeviceCreateCalled

; 1160 : 
; 1161 :     // If DXUTCreateWindow() or DXUTSetWindow() has not already been called, 
; 1162 :     // then call DXUTCreateWindow() with the default parameters.         
; 1163 :     if( !GetDXUTState().GetWindowCreated() ) 

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetWindowCreated@DXUTState@@QAE_NXZ	; DXUTState::GetWindowCreated
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@DXUTCreate

; 1164 :     {
; 1165 :         // If DXUTCreateWindow() or DXUTSetWindow() was already called and failed, then fail.
; 1166 :         // DXUTCreateWindow() or DXUTSetWindow() must first succeed for this function to succeed
; 1167 :         if( GetDXUTState().GetWindowCreateCalled() )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetWindowCreateCalled@DXUTState@@QAE_NXZ ; DXUTState::GetWindowCreateCalled
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@DXUTCreate

; 1168 :             return E_FAIL; 

	mov	eax, -2147467259			; 80004005H
	jmp	$LN7@DXUTCreate
$LN5@DXUTCreate:

; 1169 : 
; 1170 :         // If DXUTCreateWindow() or DXUTSetWindow() hasn't been called, then 
; 1171 :         // automatically call DXUTCreateWindow() with default params
; 1172 :         hr = DXUTCreateWindow();

	push	-2147483648				; 80000000H
	push	-2147483648				; 80000000H
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BA@FFFLJHOO@Direct3D?5Window?$AA@
	call	?DXUTCreateWindow@@YAJPBDPAUHINSTANCE__@@PAUHICON__@@PAUHMENU__@@HH@Z ; DXUTCreateWindow
	add	esp, 24					; 00000018H
	mov	DWORD PTR _hr$[ebp], eax

; 1173 :         if( FAILED(hr) )

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN6@DXUTCreate

; 1174 :             return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	jmp	$LN7@DXUTCreate
$LN6@DXUTCreate:

; 1175 :     }
; 1176 : 
; 1177 :     if( !bPreserveInput )

	movzx	eax, BYTE PTR _bPreserveInput$[ebp]
	test	eax, eax
	jne	$LN3@DXUTCreate

; 1178 :     {
; 1179 :         // If not preserving the input, then find the closest valid to it
; 1180 :         DXUTMatchOptions matchOptions;
; 1181 :         matchOptions.eAdapterOrdinal     = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$1[ebp], 2

; 1182 :         matchOptions.eDeviceType         = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$1[ebp+4], 2

; 1183 :         matchOptions.eWindowed           = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$1[ebp+8], 2

; 1184 :         matchOptions.eAdapterFormat      = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$1[ebp+12], 2

; 1185 :         matchOptions.eVertexProcessing   = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$1[ebp+16], 2

; 1186 :         matchOptions.eResolution         = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$1[ebp+20], 2

; 1187 :         matchOptions.eBackBufferFormat   = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$1[ebp+24], 2

; 1188 :         matchOptions.eBackBufferCount    = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$1[ebp+28], 2

; 1189 :         matchOptions.eMultiSample        = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$1[ebp+32], 2

; 1190 :         matchOptions.eSwapEffect         = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$1[ebp+36], 2

; 1191 :         matchOptions.eDepthFormat        = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$1[ebp+40], 2

; 1192 :         matchOptions.eStencilFormat      = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$1[ebp+44], 2

; 1193 :         matchOptions.ePresentFlags       = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$1[ebp+48], 2

; 1194 :         matchOptions.eRefreshRate        = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$1[ebp+52], 2

; 1195 :         matchOptions.ePresentInterval    = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$1[ebp+56], 2

; 1196 : 
; 1197 :         hr = DXUTFindValidDeviceSettings( pDeviceSettings, pDeviceSettings, &matchOptions );

	lea	eax, DWORD PTR _matchOptions$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeviceSettings$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pDeviceSettings$[ebp]
	push	edx
	call	?DXUTFindValidDeviceSettings@@YAJPAUDXUTDeviceSettings@@0PAUDXUTMatchOptions@@@Z ; DXUTFindValidDeviceSettings
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _hr$[ebp], eax

; 1198 :         if( FAILED(hr) ) // the call will fail if no valid devices were found

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN3@DXUTCreate

; 1199 :         {
; 1200 :             DXUTDisplayErrorMessage( hr );

	mov	eax, DWORD PTR _hr$[ebp]
	push	eax
	call	?DXUTDisplayErrorMessage@@YAXJ@Z	; DXUTDisplayErrorMessage
	add	esp, 4

; 1201 :             return DXUT_ERR( "DXUTFindValidDeviceSettings", hr );

	push	0
	push	OFFSET ??_C@_0BM@MONLLCLM@DXUTFindValidDeviceSettings?$AA@
	mov	eax, DWORD PTR _hr$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??DXUTCreateDeviceFromSettings@@YAJPAUDXUTDeviceSettings@@_N1@Z@4JA
	add	ecx, 45					; 0000002dH
	push	ecx
	push	OFFSET ??_C@_0CL@KBAHBIDF@z?3?2sampsrc?202xu1?2saco?2d3d9?2commo@
	call	?DXUTTrace@@YGJPBDKJ0_N@Z		; DXUTTrace
	jmp	SHORT $LN7@DXUTCreate
$LN3@DXUTCreate:

; 1202 :         }
; 1203 :     }
; 1204 : 
; 1205 :     // Change to a Direct3D device created from the new device settings.  
; 1206 :     // If there is an existing device, then either reset or recreate the scene
; 1207 :     hr = DXUTChangeDevice( pDeviceSettings, NULL, false, bClipWindowToSingleAdapter );

	movzx	eax, BYTE PTR _bClipWindowToSingleAdapter$[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _pDeviceSettings$[ebp]
	push	ecx
	call	?DXUTChangeDevice@@YAJPAUDXUTDeviceSettings@@PAUIDirect3DDevice9@@_N2@Z ; DXUTChangeDevice
	add	esp, 16					; 00000010H
	mov	DWORD PTR _hr$[ebp], eax

; 1208 :     if( FAILED(hr) )

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN1@DXUTCreate

; 1209 :         return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	jmp	SHORT $LN7@DXUTCreate
$LN1@DXUTCreate:

; 1210 : 
; 1211 :     return S_OK;

	xor	eax, eax
$LN7@DXUTCreate:

; 1212 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@DXUTCreate
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN11@DXUTCreate:
	DD	1
	DD	$LN10@DXUTCreate
$LN10@DXUTCreate:
	DD	-80					; ffffffb0H
	DD	60					; 0000003cH
	DD	$LN9@DXUTCreate
$LN9@DXUTCreate:
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	79					; 0000004fH
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	115					; 00000073H
	DB	0
?DXUTCreateDeviceFromSettings@@YAJPAUDXUTDeviceSettings@@_N1@Z ENDP ; DXUTCreateDeviceFromSettings
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTCreateDevice@@YAJI_NHHP6G_NPAU_D3DCAPS9@@W4_D3DFORMAT@@20PAX@ZP6G_NPAUDXUTDeviceSettings@@PBU1@3@Z3@Z
_TEXT	SEGMENT
_deviceSettings$ = -160					; size = 72
_matchOptions$ = -80					; size = 60
_hr$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_AdapterOrdinal$ = 8					; size = 4
_bWindowed$ = 12					; size = 1
_nSuggestedWidth$ = 16					; size = 4
_nSuggestedHeight$ = 20					; size = 4
_pCallbackIsDeviceAcceptable$ = 24			; size = 4
_pCallbackModifyDeviceSettings$ = 28			; size = 4
_pUserContext$ = 32					; size = 4
?DXUTCreateDevice@@YAJI_NHHP6G_NPAU_D3DCAPS9@@W4_D3DFORMAT@@20PAX@ZP6G_NPAUDXUTDeviceSettings@@PBU1@3@Z3@Z PROC ; DXUTCreateDevice, COMDAT

; 953  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 356				; 00000164H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-356]
	mov	ecx, 89					; 00000059H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 954  :     HRESULT hr;
; 955  : 
; 956  :     // Not allowed to call this from inside the device callbacks
; 957  :     if( GetDXUTState().GetInsideDeviceCallback() )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetInsideDeviceCallback@DXUTState@@QAE_NXZ ; DXUTState::GetInsideDeviceCallback
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN19@DXUTCreate

; 958  :         return DXUT_ERR_MSGBOX( "DXUTCreateWindow", E_FAIL );

	push	1
	push	OFFSET ??_C@_0BB@LKEDMNKO@DXUTCreateWindow?$AA@
	push	-2147467259				; 80004005H
	mov	eax, DWORD PTR ?__LINE__Var@?1??DXUTCreateDevice@@YAJI_NHHP6G_NPAU_D3DCAPS9@@W4_D3DFORMAT@@20PAX@ZP6G_NPAUDXUTDeviceSettings@@PBU2@3@Z3@Z@4JA
	add	eax, 5
	push	eax
	push	OFFSET ??_C@_0CL@KBAHBIDF@z?3?2sampsrc?202xu1?2saco?2d3d9?2commo@
	call	?DXUTTrace@@YGJPBDKJ0_N@Z		; DXUTTrace
	jmp	$LN20@DXUTCreate
$LN19@DXUTCreate:

; 959  : 
; 960  :     // Record the function arguments in the global state 
; 961  :     GetDXUTState().SetIsDeviceAcceptableFunc( pCallbackIsDeviceAcceptable );

	mov	eax, DWORD PTR _pCallbackIsDeviceAcceptable$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetIsDeviceAcceptableFunc@DXUTState@@QAEXP6G_NPAU_D3DCAPS9@@W4_D3DFORMAT@@1_NPAX@Z@Z ; DXUTState::SetIsDeviceAcceptableFunc

; 962  :     GetDXUTState().SetModifyDeviceSettingsFunc( pCallbackModifyDeviceSettings );

	mov	eax, DWORD PTR _pCallbackModifyDeviceSettings$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetModifyDeviceSettingsFunc@DXUTState@@QAEXP6G_NPAUDXUTDeviceSettings@@PBU_D3DCAPS9@@PAX@Z@Z ; DXUTState::SetModifyDeviceSettingsFunc

; 963  :     GetDXUTState().SetIsDeviceAcceptableFuncUserContext( pUserContext );

	mov	eax, DWORD PTR _pUserContext$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetIsDeviceAcceptableFuncUserContext@DXUTState@@QAEXPAX@Z ; DXUTState::SetIsDeviceAcceptableFuncUserContext

; 964  :     GetDXUTState().SetModifyDeviceSettingsFuncUserContext( pUserContext );

	mov	eax, DWORD PTR _pUserContext$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetModifyDeviceSettingsFuncUserContext@DXUTState@@QAEXPAX@Z ; DXUTState::SetModifyDeviceSettingsFuncUserContext

; 965  : 
; 966  :     GetDXUTState().SetDeviceCreateCalled( true );

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetDeviceCreateCalled@DXUTState@@QAEX_N@Z ; DXUTState::SetDeviceCreateCalled

; 967  : 
; 968  :     // If DXUTCreateWindow() or DXUTSetWindow() has not already been called, 
; 969  :     // then call DXUTCreateWindow() with the default parameters.         
; 970  :     if( !GetDXUTState().GetWindowCreated() ) 

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetWindowCreated@DXUTState@@QAE_NXZ	; DXUTState::GetWindowCreated
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN18@DXUTCreate

; 971  :     {
; 972  :         // If DXUTCreateWindow() or DXUTSetWindow() was already called and failed, then fail.
; 973  :         // DXUTCreateWindow() or DXUTSetWindow() must first succeed for this function to succeed
; 974  :         if( GetDXUTState().GetWindowCreateCalled() )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetWindowCreateCalled@DXUTState@@QAE_NXZ ; DXUTState::GetWindowCreateCalled
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN17@DXUTCreate

; 975  :             return E_FAIL; 

	mov	eax, -2147467259			; 80004005H
	jmp	$LN20@DXUTCreate
$LN17@DXUTCreate:

; 976  : 
; 977  :         // If DXUTCreateWindow() or DXUTSetWindow() hasn't been called, then 
; 978  :         // automatically call DXUTCreateWindow() with default params
; 979  :         hr = DXUTCreateWindow();

	push	-2147483648				; 80000000H
	push	-2147483648				; 80000000H
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0BA@FFFLJHOO@Direct3D?5Window?$AA@
	call	?DXUTCreateWindow@@YAJPBDPAUHINSTANCE__@@PAUHICON__@@PAUHMENU__@@HH@Z ; DXUTCreateWindow
	add	esp, 24					; 00000018H
	mov	DWORD PTR _hr$[ebp], eax

; 980  :         if( FAILED(hr) )

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN18@DXUTCreate

; 981  :             return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	jmp	$LN20@DXUTCreate
$LN18@DXUTCreate:

; 982  :     }
; 983  : 
; 984  :     // Force an enumeration with the new IsDeviceAcceptable callback
; 985  :     DXUTPrepareEnumerationObject( true );

	push	1
	call	?DXUTPrepareEnumerationObject@@YAPAVCD3DEnumeration@@_N@Z ; DXUTPrepareEnumerationObject
	add	esp, 4

; 986  : 
; 987  :     DXUTMatchOptions matchOptions;
; 988  :     matchOptions.eAdapterOrdinal     = DXUTMT_PRESERVE_INPUT;

	mov	DWORD PTR _matchOptions$[ebp], 1

; 989  :     matchOptions.eDeviceType         = DXUTMT_IGNORE_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+4], 0

; 990  :     matchOptions.eWindowed           = DXUTMT_PRESERVE_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+8], 1

; 991  :     matchOptions.eAdapterFormat      = DXUTMT_IGNORE_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+12], 0

; 992  :     matchOptions.eVertexProcessing   = DXUTMT_IGNORE_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+16], 0

; 993  :     matchOptions.eResolution         = DXUTMT_CLOSEST_TO_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+20], 2

; 994  :     matchOptions.eBackBufferFormat   = DXUTMT_IGNORE_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+24], 0

; 995  :     matchOptions.eBackBufferCount    = DXUTMT_IGNORE_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+28], 0

; 996  :     matchOptions.eMultiSample        = DXUTMT_IGNORE_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+32], 0

; 997  :     matchOptions.eSwapEffect         = DXUTMT_IGNORE_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+36], 0

; 998  :     matchOptions.eDepthFormat        = DXUTMT_IGNORE_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+40], 0

; 999  :     matchOptions.eStencilFormat      = DXUTMT_IGNORE_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+44], 0

; 1000 :     matchOptions.ePresentFlags       = DXUTMT_IGNORE_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+48], 0

; 1001 :     matchOptions.eRefreshRate        = DXUTMT_IGNORE_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+52], 0

; 1002 :     matchOptions.ePresentInterval    = DXUTMT_IGNORE_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+56], 0

; 1003 : 
; 1004 :     DXUTDeviceSettings deviceSettings;
; 1005 :     ZeroMemory( &deviceSettings, sizeof(DXUTDeviceSettings) );

	push	72					; 00000048H
	push	0
	lea	eax, DWORD PTR _deviceSettings$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1006 :     deviceSettings.AdapterOrdinal      = AdapterOrdinal;

	mov	eax, DWORD PTR _AdapterOrdinal$[ebp]
	mov	DWORD PTR _deviceSettings$[ebp], eax

; 1007 :     deviceSettings.pp.Windowed         = bWindowed;

	movzx	eax, BYTE PTR _bWindowed$[ebp]
	mov	DWORD PTR _deviceSettings$[ebp+48], eax

; 1008 :     deviceSettings.pp.BackBufferWidth  = nSuggestedWidth;

	mov	eax, DWORD PTR _nSuggestedWidth$[ebp]
	mov	DWORD PTR _deviceSettings$[ebp+16], eax

; 1009 :     deviceSettings.pp.BackBufferHeight = nSuggestedHeight;

	mov	eax, DWORD PTR _nSuggestedHeight$[ebp]
	mov	DWORD PTR _deviceSettings$[ebp+20], eax

; 1010 : 
; 1011 :     // Override with settings from the command line
; 1012 :     if( GetDXUTState().GetOverrideWidth() != 0 )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetOverrideWidth@DXUTState@@QAEHXZ	; DXUTState::GetOverrideWidth
	test	eax, eax
	je	SHORT $LN15@DXUTCreate

; 1013 :         deviceSettings.pp.BackBufferWidth = GetDXUTState().GetOverrideWidth();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetOverrideWidth@DXUTState@@QAEHXZ	; DXUTState::GetOverrideWidth
	mov	DWORD PTR _deviceSettings$[ebp+16], eax
$LN15@DXUTCreate:

; 1014 :     if( GetDXUTState().GetOverrideHeight() != 0 )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetOverrideHeight@DXUTState@@QAEHXZ	; DXUTState::GetOverrideHeight
	test	eax, eax
	je	SHORT $LN14@DXUTCreate

; 1015 :         deviceSettings.pp.BackBufferHeight = GetDXUTState().GetOverrideHeight();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetOverrideHeight@DXUTState@@QAEHXZ	; DXUTState::GetOverrideHeight
	mov	DWORD PTR _deviceSettings$[ebp+20], eax
$LN14@DXUTCreate:

; 1016 : 
; 1017 :     if( GetDXUTState().GetOverrideAdapterOrdinal() != -1 )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetOverrideAdapterOrdinal@DXUTState@@QAEHXZ ; DXUTState::GetOverrideAdapterOrdinal
	cmp	eax, -1
	je	SHORT $LN13@DXUTCreate

; 1018 :         deviceSettings.AdapterOrdinal = GetDXUTState().GetOverrideAdapterOrdinal();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetOverrideAdapterOrdinal@DXUTState@@QAEHXZ ; DXUTState::GetOverrideAdapterOrdinal
	mov	DWORD PTR _deviceSettings$[ebp], eax
$LN13@DXUTCreate:

; 1019 : 
; 1020 :     if( GetDXUTState().GetOverrideFullScreen() )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetOverrideFullScreen@DXUTState@@QAE_NXZ ; DXUTState::GetOverrideFullScreen
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN12@DXUTCreate

; 1021 :     {
; 1022 :         deviceSettings.pp.Windowed = FALSE;

	mov	DWORD PTR _deviceSettings$[ebp+48], 0

; 1023 :         if( GetDXUTState().GetOverrideWidth() == 0 && GetDXUTState().GetOverrideHeight() == 0 )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetOverrideWidth@DXUTState@@QAEHXZ	; DXUTState::GetOverrideWidth
	test	eax, eax
	jne	SHORT $LN12@DXUTCreate
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetOverrideHeight@DXUTState@@QAEHXZ	; DXUTState::GetOverrideHeight
	test	eax, eax
	jne	SHORT $LN12@DXUTCreate

; 1024 :             matchOptions.eResolution = DXUTMT_IGNORE_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+20], 0
$LN12@DXUTCreate:

; 1025 :     }
; 1026 :     if( GetDXUTState().GetOverrideWindowed() )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetOverrideWindowed@DXUTState@@QAE_NXZ	; DXUTState::GetOverrideWindowed
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@DXUTCreate

; 1027 :         deviceSettings.pp.Windowed = TRUE;

	mov	DWORD PTR _deviceSettings$[ebp+48], 1
$LN10@DXUTCreate:

; 1028 : 
; 1029 :     if( GetDXUTState().GetOverrideForceHAL() )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetOverrideForceHAL@DXUTState@@QAE_NXZ	; DXUTState::GetOverrideForceHAL
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@DXUTCreate

; 1030 :     {
; 1031 :         deviceSettings.DeviceType = D3DDEVTYPE_HAL;

	mov	DWORD PTR _deviceSettings$[ebp+4], 1

; 1032 :         matchOptions.eDeviceType = DXUTMT_PRESERVE_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+4], 1
$LN9@DXUTCreate:

; 1033 :     }
; 1034 :     if( GetDXUTState().GetOverrideForceREF() )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetOverrideForceREF@DXUTState@@QAE_NXZ	; DXUTState::GetOverrideForceREF
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@DXUTCreate

; 1035 :     {
; 1036 :         deviceSettings.DeviceType = D3DDEVTYPE_REF;

	mov	DWORD PTR _deviceSettings$[ebp+4], 2

; 1037 :         matchOptions.eDeviceType = DXUTMT_PRESERVE_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+4], 1
$LN8@DXUTCreate:

; 1038 :     }
; 1039 : 
; 1040 :     if( GetDXUTState().GetOverrideForcePureHWVP() )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetOverrideForcePureHWVP@DXUTState@@QAE_NXZ ; DXUTState::GetOverrideForcePureHWVP
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@DXUTCreate

; 1041 :     {
; 1042 :         deviceSettings.BehaviorFlags = D3DCREATE_HARDWARE_VERTEXPROCESSING | D3DCREATE_PUREDEVICE;

	mov	DWORD PTR _deviceSettings$[ebp+12], 80	; 00000050H

; 1043 :         matchOptions.eVertexProcessing = DXUTMT_PRESERVE_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+16], 1
	jmp	SHORT $LN6@DXUTCreate
$LN7@DXUTCreate:

; 1044 :     }
; 1045 :     else if( GetDXUTState().GetOverrideForceHWVP() )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetOverrideForceHWVP@DXUTState@@QAE_NXZ ; DXUTState::GetOverrideForceHWVP
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@DXUTCreate

; 1046 :     {
; 1047 :         deviceSettings.BehaviorFlags = D3DCREATE_HARDWARE_VERTEXPROCESSING;

	mov	DWORD PTR _deviceSettings$[ebp+12], 64	; 00000040H

; 1048 :         matchOptions.eVertexProcessing = DXUTMT_PRESERVE_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+16], 1
	jmp	SHORT $LN6@DXUTCreate
$LN5@DXUTCreate:

; 1049 :     }
; 1050 :     else if( GetDXUTState().GetOverrideForceSWVP() )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetOverrideForceSWVP@DXUTState@@QAE_NXZ ; DXUTState::GetOverrideForceSWVP
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@DXUTCreate

; 1051 :     {
; 1052 :         deviceSettings.BehaviorFlags = D3DCREATE_SOFTWARE_VERTEXPROCESSING;

	mov	DWORD PTR _deviceSettings$[ebp+12], 32	; 00000020H

; 1053 :         matchOptions.eVertexProcessing = DXUTMT_PRESERVE_INPUT;

	mov	DWORD PTR _matchOptions$[ebp+16], 1
$LN6@DXUTCreate:

; 1054 :     }
; 1055 : 
; 1056 :     hr = DXUTFindValidDeviceSettings( &deviceSettings, &deviceSettings, &matchOptions );

	lea	eax, DWORD PTR _matchOptions$[ebp]
	push	eax
	lea	ecx, DWORD PTR _deviceSettings$[ebp]
	push	ecx
	lea	edx, DWORD PTR _deviceSettings$[ebp]
	push	edx
	call	?DXUTFindValidDeviceSettings@@YAJPAUDXUTDeviceSettings@@0PAUDXUTMatchOptions@@@Z ; DXUTFindValidDeviceSettings
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _hr$[ebp], eax

; 1057 :     if( FAILED(hr) ) // the call will fail if no valid devices were found

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN2@DXUTCreate

; 1058 :     {
; 1059 :         DXUTDisplayErrorMessage( hr );

	mov	eax, DWORD PTR _hr$[ebp]
	push	eax
	call	?DXUTDisplayErrorMessage@@YAXJ@Z	; DXUTDisplayErrorMessage
	add	esp, 4

; 1060 :         return DXUT_ERR( "DXUTFindValidDeviceSettings", hr );

	push	0
	push	OFFSET ??_C@_0BM@MONLLCLM@DXUTFindValidDeviceSettings?$AA@
	mov	eax, DWORD PTR _hr$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??DXUTCreateDevice@@YAJI_NHHP6G_NPAU_D3DCAPS9@@W4_D3DFORMAT@@20PAX@ZP6G_NPAUDXUTDeviceSettings@@PBU2@3@Z3@Z@4JA
	add	ecx, 107				; 0000006bH
	push	ecx
	push	OFFSET ??_C@_0CL@KBAHBIDF@z?3?2sampsrc?202xu1?2saco?2d3d9?2commo@
	call	?DXUTTrace@@YGJPBDKJ0_N@Z		; DXUTTrace
	jmp	SHORT $LN20@DXUTCreate
$LN2@DXUTCreate:

; 1061 :     }
; 1062 : 
; 1063 :     // Change to a Direct3D device created from the new device settings.  
; 1064 :     // If there is an existing device, then either reset or recreated the scene
; 1065 :     hr = DXUTChangeDevice( &deviceSettings, NULL, false, true );

	push	1
	push	0
	push	0
	lea	eax, DWORD PTR _deviceSettings$[ebp]
	push	eax
	call	?DXUTChangeDevice@@YAJPAUDXUTDeviceSettings@@PAUIDirect3DDevice9@@_N2@Z ; DXUTChangeDevice
	add	esp, 16					; 00000010H
	mov	DWORD PTR _hr$[ebp], eax

; 1066 :     if( FAILED(hr) )

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN1@DXUTCreate

; 1067 :         return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	jmp	SHORT $LN20@DXUTCreate
$LN1@DXUTCreate:

; 1068 : 
; 1069 :     return S_OK;

	xor	eax, eax
$LN20@DXUTCreate:

; 1070 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN25@DXUTCreate
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 356				; 00000164H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN25@DXUTCreate:
	DD	2
	DD	$LN24@DXUTCreate
$LN24@DXUTCreate:
	DD	-80					; ffffffb0H
	DD	60					; 0000003cH
	DD	$LN22@DXUTCreate
	DD	-160					; ffffff60H
	DD	72					; 00000048H
	DD	$LN23@DXUTCreate
$LN23@DXUTCreate:
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	118					; 00000076H
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	83					; 00000053H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	115					; 00000073H
	DB	0
$LN22@DXUTCreate:
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	79					; 0000004fH
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	115					; 00000073H
	DB	0
?DXUTCreateDevice@@YAJI_NHHP6G_NPAU_D3DCAPS9@@W4_D3DFORMAT@@20PAX@ZP6G_NPAUDXUTDeviceSettings@@PBU1@3@Z3@Z ENDP ; DXUTCreateDevice
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTStaticWndProc@@YGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
tv501 = -560						; size = 4
tv492 = -560						; size = 4
tv479 = -560						; size = 4
tv469 = -560						; size = 4
tv456 = -560						; size = 4
tv441 = -560						; size = 4
tv433 = -560						; size = 4
tv202 = -560						; size = 4
tv171 = -560						; size = 4
tv167 = -560						; size = 4
tv163 = -560						; size = 4
tv74 = -560						; size = 4
tv70 = -560						; size = 4
tv405 = -557						; size = 1
_hMenu$1 = -360						; size = 4
_bTimePaused$2 = -345					; size = 1
_pd3dDevice$3 = -336					; size = 4
_bWireFrame$4 = -321					; size = 1
_dwMask$5 = -312					; size = 4
_ptCursor$6 = -300					; size = 8
_pd3dDevice$7 = -284					; size = 4
_rcCurrentClient$8 = -272				; size = 16
_pCallbackFrameRender$9 = -248				; size = 4
_fElapsedTime$10 = -236					; size = 4
_fTime$11 = -224					; size = 8
_hr$12 = -208						; size = 4
_pd3dDevice$13 = -196					; size = 4
_pCallbackMouse$14 = -184				; size = 4
_bMouseButtons$15 = -172				; size = 4
_bMiddleButton$16 = -157				; size = 1
_bRightButton$17 = -145					; size = 1
_bLeftButton$18 = -133					; size = 1
_nMouseButtonState$19 = -124				; size = 4
_nMouseWheelDelta$20 = -112				; size = 4
_pt$21 = -100						; size = 8
_yPos$22 = -84						; size = 4
_xPos$23 = -72						; size = 4
_pCallbackKeyboard$24 = -60				; size = 4
_bKeys$25 = -48						; size = 4
_bAltDown$26 = -33					; size = 1
_dwMask$27 = -24					; size = 4
_bKeyDown$28 = -9					; size = 1
__$ArrayPad$ = -4					; size = 4
_hWnd$ = 8						; size = 4
_uMsg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?DXUTStaticWndProc@@YGJPAUHWND__@@IIJ@Z PROC		; DXUTStaticWndProc, COMDAT

; 3875 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 560				; 00000230H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-560]
	mov	ecx, 140				; 0000008cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3876 :     // Consolidate the keyboard messages and pass them to the app's keyboard callback
; 3877 :     if( uMsg == WM_KEYDOWN ||
; 3878 :         uMsg == WM_SYSKEYDOWN || 
; 3879 :         uMsg == WM_KEYUP ||
; 3880 :         uMsg == WM_SYSKEYUP )

	cmp	DWORD PTR _uMsg$[ebp], 256		; 00000100H
	je	SHORT $LN82@DXUTStatic
	cmp	DWORD PTR _uMsg$[ebp], 260		; 00000104H
	je	SHORT $LN82@DXUTStatic
	cmp	DWORD PTR _uMsg$[ebp], 257		; 00000101H
	je	SHORT $LN82@DXUTStatic
	cmp	DWORD PTR _uMsg$[ebp], 261		; 00000105H
	jne	$LN81@DXUTStatic
$LN82@DXUTStatic:

; 3881 :     {
; 3882 :         bool bKeyDown = (uMsg == WM_KEYDOWN || uMsg == WM_SYSKEYDOWN);

	cmp	DWORD PTR _uMsg$[ebp], 256		; 00000100H
	je	SHORT $LN86@DXUTStatic
	cmp	DWORD PTR _uMsg$[ebp], 260		; 00000104H
	je	SHORT $LN86@DXUTStatic
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN87@DXUTStatic
$LN86@DXUTStatic:
	mov	DWORD PTR tv70[ebp], 1
$LN87@DXUTStatic:
	mov	al, BYTE PTR tv70[ebp]
	mov	BYTE PTR _bKeyDown$28[ebp], al

; 3883 :         DWORD dwMask = (1 << 29);

	mov	DWORD PTR _dwMask$27[ebp], 536870912	; 20000000H

; 3884 :         bool bAltDown = ( (lParam & dwMask) != 0 );

	mov	eax, DWORD PTR _lParam$[ebp]
	and	eax, DWORD PTR _dwMask$27[ebp]
	je	SHORT $LN88@DXUTStatic
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN89@DXUTStatic
$LN88@DXUTStatic:
	mov	DWORD PTR tv74[ebp], 0
$LN89@DXUTStatic:
	mov	cl, BYTE PTR tv74[ebp]
	mov	BYTE PTR _bAltDown$26[ebp], cl

; 3885 : 
; 3886 :         bool* bKeys = GetDXUTState().GetKeys();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetKeys@DXUTState@@QAEPA_NXZ		; DXUTState::GetKeys
	mov	DWORD PTR _bKeys$25[ebp], eax

; 3887 :         bKeys[ (BYTE) (wParam & 0xFF) ] = bKeyDown;

	mov	eax, DWORD PTR _wParam$[ebp]
	and	eax, 255				; 000000ffH
	movzx	ecx, al
	mov	edx, DWORD PTR _bKeys$25[ebp]
	mov	al, BYTE PTR _bKeyDown$28[ebp]
	mov	BYTE PTR [edx+ecx], al

; 3888 : 
; 3889 :         LPDXUTCALLBACKKEYBOARD pCallbackKeyboard = GetDXUTState().GetKeyboardFunc();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetKeyboardFunc@DXUTState@@QAEP6GXI_N0PAX@ZXZ ; DXUTState::GetKeyboardFunc
	mov	DWORD PTR _pCallbackKeyboard$24[ebp], eax

; 3890 :         if( pCallbackKeyboard )

	cmp	DWORD PTR _pCallbackKeyboard$24[ebp], 0
	je	SHORT $LN81@DXUTStatic

; 3891 :             pCallbackKeyboard( (UINT)wParam, bKeyDown, bAltDown, GetDXUTState().GetKeyboardFuncUserContext() );           

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetKeyboardFuncUserContext@DXUTState@@QAEPAXXZ ; DXUTState::GetKeyboardFuncUserContext
	mov	esi, esp
	push	eax
	movzx	eax, BYTE PTR _bAltDown$26[ebp]
	push	eax
	movzx	ecx, BYTE PTR _bKeyDown$28[ebp]
	push	ecx
	mov	edx, DWORD PTR _wParam$[ebp]
	push	edx
	call	DWORD PTR _pCallbackKeyboard$24[ebp]
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN81@DXUTStatic:

; 3892 :     }
; 3893 : 
; 3894 :     // Consolidate the mouse button messages and pass them to the app's mouse callback
; 3895 :     if( uMsg == WM_LBUTTONDOWN ||
; 3896 :         uMsg == WM_LBUTTONUP ||
; 3897 :         uMsg == WM_LBUTTONDBLCLK ||
; 3898 :         uMsg == WM_MBUTTONDOWN ||
; 3899 :         uMsg == WM_MBUTTONUP ||
; 3900 :         uMsg == WM_MBUTTONDBLCLK ||
; 3901 :         uMsg == WM_RBUTTONDOWN ||
; 3902 :         uMsg == WM_RBUTTONUP ||
; 3903 :         uMsg == WM_RBUTTONDBLCLK ||
; 3904 :         uMsg == WM_MOUSEWHEEL || 
; 3905 :         (GetDXUTState().GetNotifyOnMouseMove() && uMsg == WM_MOUSEMOVE) )

	cmp	DWORD PTR _uMsg$[ebp], 513		; 00000201H
	je	SHORT $LN79@DXUTStatic
	cmp	DWORD PTR _uMsg$[ebp], 514		; 00000202H
	je	SHORT $LN79@DXUTStatic
	cmp	DWORD PTR _uMsg$[ebp], 515		; 00000203H
	je	SHORT $LN79@DXUTStatic
	cmp	DWORD PTR _uMsg$[ebp], 519		; 00000207H
	je	SHORT $LN79@DXUTStatic
	cmp	DWORD PTR _uMsg$[ebp], 520		; 00000208H
	je	SHORT $LN79@DXUTStatic
	cmp	DWORD PTR _uMsg$[ebp], 521		; 00000209H
	je	SHORT $LN79@DXUTStatic
	cmp	DWORD PTR _uMsg$[ebp], 516		; 00000204H
	je	SHORT $LN79@DXUTStatic
	cmp	DWORD PTR _uMsg$[ebp], 517		; 00000205H
	je	SHORT $LN79@DXUTStatic
	cmp	DWORD PTR _uMsg$[ebp], 518		; 00000206H
	je	SHORT $LN79@DXUTStatic
	cmp	DWORD PTR _uMsg$[ebp], 522		; 0000020aH
	je	SHORT $LN79@DXUTStatic
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetNotifyOnMouseMove@DXUTState@@QAE_NXZ ; DXUTState::GetNotifyOnMouseMove
	movzx	eax, al
	test	eax, eax
	je	$LN76@DXUTStatic
	cmp	DWORD PTR _uMsg$[ebp], 512		; 00000200H
	jne	$LN76@DXUTStatic
$LN79@DXUTStatic:

; 3906 :     {
; 3907 :         int xPos = (short)LOWORD(lParam);

	mov	eax, DWORD PTR _lParam$[ebp]
	and	eax, 65535				; 0000ffffH
	movsx	ecx, ax
	mov	DWORD PTR _xPos$23[ebp], ecx

; 3908 :         int yPos = (short)HIWORD(lParam);

	mov	eax, DWORD PTR _lParam$[ebp]
	shr	eax, 16					; 00000010H
	and	eax, 65535				; 0000ffffH
	movsx	ecx, ax
	mov	DWORD PTR _yPos$22[ebp], ecx

; 3909 : 
; 3910 :         if( uMsg == WM_MOUSEWHEEL )

	cmp	DWORD PTR _uMsg$[ebp], 522		; 0000020aH
	jne	SHORT $LN78@DXUTStatic

; 3911 :         {
; 3912 :             // WM_MOUSEWHEEL passes screen mouse coords
; 3913 :             // so convert them to client coords
; 3914 :             POINT pt;
; 3915 :             pt.x = xPos; pt.y = yPos;

	mov	eax, DWORD PTR _xPos$23[ebp]
	mov	DWORD PTR _pt$21[ebp], eax
	mov	eax, DWORD PTR _yPos$22[ebp]
	mov	DWORD PTR _pt$21[ebp+4], eax

; 3916 :             ScreenToClient( hWnd, &pt );

	mov	esi, esp
	lea	eax, DWORD PTR _pt$21[ebp]
	push	eax
	mov	ecx, DWORD PTR _hWnd$[ebp]
	push	ecx
	call	DWORD PTR __imp__ScreenToClient@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3917 :             xPos = pt.x; yPos = pt.y;

	mov	eax, DWORD PTR _pt$21[ebp]
	mov	DWORD PTR _xPos$23[ebp], eax
	mov	eax, DWORD PTR _pt$21[ebp+4]
	mov	DWORD PTR _yPos$22[ebp], eax
$LN78@DXUTStatic:

; 3918 :         }
; 3919 : 
; 3920 :         int nMouseWheelDelta = 0;

	mov	DWORD PTR _nMouseWheelDelta$20[ebp], 0

; 3921 :         if( uMsg == WM_MOUSEWHEEL ) 

	cmp	DWORD PTR _uMsg$[ebp], 522		; 0000020aH
	jne	SHORT $LN77@DXUTStatic

; 3922 :             nMouseWheelDelta = (short) HIWORD(wParam);

	mov	eax, DWORD PTR _wParam$[ebp]
	shr	eax, 16					; 00000010H
	and	eax, 65535				; 0000ffffH
	movsx	ecx, ax
	mov	DWORD PTR _nMouseWheelDelta$20[ebp], ecx
$LN77@DXUTStatic:

; 3923 : 
; 3924 :         int nMouseButtonState = LOWORD(wParam);

	mov	eax, DWORD PTR _wParam$[ebp]
	and	eax, 65535				; 0000ffffH
	movzx	ecx, ax
	mov	DWORD PTR _nMouseButtonState$19[ebp], ecx

; 3925 :         bool bLeftButton  = ((nMouseButtonState & MK_LBUTTON) != 0);

	mov	eax, DWORD PTR _nMouseButtonState$19[ebp]
	and	eax, 1
	je	SHORT $LN90@DXUTStatic
	mov	DWORD PTR tv163[ebp], 1
	jmp	SHORT $LN91@DXUTStatic
$LN90@DXUTStatic:
	mov	DWORD PTR tv163[ebp], 0
$LN91@DXUTStatic:
	mov	cl, BYTE PTR tv163[ebp]
	mov	BYTE PTR _bLeftButton$18[ebp], cl

; 3926 :         bool bRightButton = ((nMouseButtonState & MK_RBUTTON) != 0);

	mov	eax, DWORD PTR _nMouseButtonState$19[ebp]
	and	eax, 2
	je	SHORT $LN92@DXUTStatic
	mov	DWORD PTR tv167[ebp], 1
	jmp	SHORT $LN93@DXUTStatic
$LN92@DXUTStatic:
	mov	DWORD PTR tv167[ebp], 0
$LN93@DXUTStatic:
	mov	cl, BYTE PTR tv167[ebp]
	mov	BYTE PTR _bRightButton$17[ebp], cl

; 3927 :         bool bMiddleButton = ((nMouseButtonState & MK_MBUTTON) != 0);

	mov	eax, DWORD PTR _nMouseButtonState$19[ebp]
	and	eax, 16					; 00000010H
	je	SHORT $LN94@DXUTStatic
	mov	DWORD PTR tv171[ebp], 1
	jmp	SHORT $LN95@DXUTStatic
$LN94@DXUTStatic:
	mov	DWORD PTR tv171[ebp], 0
$LN95@DXUTStatic:
	mov	cl, BYTE PTR tv171[ebp]
	mov	BYTE PTR _bMiddleButton$16[ebp], cl

; 3928 :   
; 3929 : 		bool* bMouseButtons = GetDXUTState().GetMouseButtons();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetMouseButtons@DXUTState@@QAEPA_NXZ	; DXUTState::GetMouseButtons
	mov	DWORD PTR _bMouseButtons$15[ebp], eax

; 3930 :         bMouseButtons[0] = bLeftButton;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _bMouseButtons$15[ebp]
	mov	al, BYTE PTR _bLeftButton$18[ebp]
	mov	BYTE PTR [edx+ecx], al

; 3931 :         bMouseButtons[1] = bMiddleButton;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _bMouseButtons$15[ebp]
	mov	dl, BYTE PTR _bMiddleButton$16[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 3932 :         bMouseButtons[2] = bRightButton;

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _bMouseButtons$15[ebp]
	mov	dl, BYTE PTR _bRightButton$17[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 3933 :         bMouseButtons[3] = false;

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _bMouseButtons$15[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 3934 :         bMouseButtons[4] = false;

	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR _bMouseButtons$15[ebp]
	mov	BYTE PTR [ecx+eax], 0

; 3935 : 
; 3936 :         LPDXUTCALLBACKMOUSE pCallbackMouse = GetDXUTState().GetMouseFunc();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetMouseFunc@DXUTState@@QAEP6GX_N0000HHHPAX@ZXZ ; DXUTState::GetMouseFunc
	mov	DWORD PTR _pCallbackMouse$14[ebp], eax

; 3937 :         if( pCallbackMouse )

	cmp	DWORD PTR _pCallbackMouse$14[ebp], 0
	je	SHORT $LN76@DXUTStatic

; 3938 :             pCallbackMouse( bLeftButton, bRightButton, bMiddleButton, false, false, nMouseWheelDelta, xPos, yPos, GetDXUTState().GetMouseFuncUserContext() );

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetMouseFuncUserContext@DXUTState@@QAEPAXXZ ; DXUTState::GetMouseFuncUserContext
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _yPos$22[ebp]
	push	eax
	mov	ecx, DWORD PTR _xPos$23[ebp]
	push	ecx
	mov	edx, DWORD PTR _nMouseWheelDelta$20[ebp]
	push	edx
	push	0
	push	0
	movzx	eax, BYTE PTR _bMiddleButton$16[ebp]
	push	eax
	movzx	ecx, BYTE PTR _bRightButton$17[ebp]
	push	ecx
	movzx	edx, BYTE PTR _bLeftButton$18[ebp]
	push	edx
	call	DWORD PTR _pCallbackMouse$14[ebp]
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN76@DXUTStatic:

; 3939 :     }
; 3940 : 
; 3941 :     // Pass all messages to the app's MsgProc callback, and don't 
; 3942 :     // process further messages if the apps says not to.
; 3943 :     //NewWndProc(hWnd,uMsg,wParam,lParam);
; 3944 : 
; 3945 :     switch( uMsg )

	mov	eax, DWORD PTR _uMsg$[ebp]
	mov	DWORD PTR tv202[ebp], eax
	cmp	DWORD PTR tv202[ebp], 260		; 00000104H
	ja	SHORT $LN105@DXUTStatic
	cmp	DWORD PTR tv202[ebp], 260		; 00000104H
	je	$LN23@DXUTStatic
	mov	ecx, DWORD PTR tv202[ebp]
	sub	ecx, 2
	mov	DWORD PTR tv202[ebp], ecx
	cmp	DWORD PTR tv202[ebp], 254		; 000000feH
	ja	$LN74@DXUTStatic
	mov	edx, DWORD PTR tv202[ebp]
	movzx	eax, BYTE PTR $LN108@DXUTStatic[edx]
	jmp	DWORD PTR $LN115@DXUTStatic[eax*4]
$LN105@DXUTStatic:
	cmp	DWORD PTR tv202[ebp], 530		; 00000212H
	ja	SHORT $LN106@DXUTStatic
	cmp	DWORD PTR tv202[ebp], 530		; 00000212H
	je	$LN37@DXUTStatic
	cmp	DWORD PTR tv202[ebp], 512		; 00000200H
	ja	SHORT $LN107@DXUTStatic
	cmp	DWORD PTR tv202[ebp], 512		; 00000200H
	je	$LN48@DXUTStatic
	cmp	DWORD PTR tv202[ebp], 274		; 00000112H
	je	$LN28@DXUTStatic
	cmp	DWORD PTR tv202[ebp], 288		; 00000120H
	je	$LN36@DXUTStatic
	jmp	$LN74@DXUTStatic
$LN107@DXUTStatic:
	cmp	DWORD PTR tv202[ebp], 529		; 00000211H
	je	$LN38@DXUTStatic
	jmp	$LN74@DXUTStatic
$LN106@DXUTStatic:
	cmp	DWORD PTR tv202[ebp], 536		; 00000218H
	je	$LN33@DXUTStatic
	cmp	DWORD PTR tv202[ebp], 561		; 00000231H
	je	$LN50@DXUTStatic
	cmp	DWORD PTR tv202[ebp], 562		; 00000232H
	je	$LN49@DXUTStatic
	jmp	$LN74@DXUTStatic
$LN73@DXUTStatic:

; 3946 :     {
; 3947 :         case WM_PAINT:
; 3948 :         {
; 3949 :             IDirect3DDevice9* pd3dDevice = DXUTGetD3DDevice();

	call	?DXUTGetD3DDevice@@YAPAUIDirect3DDevice9@@XZ ; DXUTGetD3DDevice
	mov	DWORD PTR _pd3dDevice$13[ebp], eax

; 3950 : 
; 3951 :             // Handle paint messages when the app is paused
; 3952 :             if( pd3dDevice && DXUTIsRenderingPaused() && 
; 3953 :                 GetDXUTState().GetDeviceObjectsCreated() && GetDXUTState().GetDeviceObjectsReset() )

	cmp	DWORD PTR _pd3dDevice$13[ebp], 0
	je	$LN68@DXUTStatic
	call	?DXUTIsRenderingPaused@@YA_NXZ		; DXUTIsRenderingPaused
	movzx	eax, al
	test	eax, eax
	je	$LN68@DXUTStatic
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetDeviceObjectsCreated@DXUTState@@QAE_NXZ ; DXUTState::GetDeviceObjectsCreated
	movzx	eax, al
	test	eax, eax
	je	$LN68@DXUTStatic
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetDeviceObjectsReset@DXUTState@@QAE_NXZ ; DXUTState::GetDeviceObjectsReset
	movzx	eax, al
	test	eax, eax
	je	$LN68@DXUTStatic

; 3954 :             {
; 3955 :                 HRESULT hr;
; 3956 :                 double fTime = DXUTGetTime();

	call	?DXUTGetTime@@YANXZ			; DXUTGetTime
	fstp	QWORD PTR _fTime$11[ebp]

; 3957 :                 float fElapsedTime = DXUTGetElapsedTime();

	call	?DXUTGetElapsedTime@@YAMXZ		; DXUTGetElapsedTime
	fstp	DWORD PTR _fElapsedTime$10[ebp]

; 3958 : 
; 3959 :                 LPDXUTCALLBACKFRAMERENDER pCallbackFrameRender = GetDXUTState().GetFrameRenderFunc();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetFrameRenderFunc@DXUTState@@QAEP6GXPAUIDirect3DDevice9@@NMPAX@ZXZ ; DXUTState::GetFrameRenderFunc
	mov	DWORD PTR _pCallbackFrameRender$9[ebp], eax

; 3960 :                 if( pCallbackFrameRender != NULL )

	cmp	DWORD PTR _pCallbackFrameRender$9[ebp], 0
	je	SHORT $LN71@DXUTStatic

; 3961 :                     pCallbackFrameRender( pd3dDevice, fTime, fElapsedTime, GetDXUTState().GetFrameRenderFuncUserContext() );

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetFrameRenderFuncUserContext@DXUTState@@QAEPAXXZ ; DXUTState::GetFrameRenderFuncUserContext
	mov	esi, esp
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _fElapsedTime$10[ebp]
	movss	DWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _fTime$11[ebp]
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _pd3dDevice$13[ebp]
	push	eax
	call	DWORD PTR _pCallbackFrameRender$9[ebp]
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN71@DXUTStatic:

; 3962 : 
; 3963 :                 hr = pd3dDevice->Present( NULL, NULL, NULL, NULL );

	mov	esi, esp
	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _pd3dDevice$13[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pd3dDevice$13[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+68]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$12[ebp], eax

; 3964 :                 if( D3DERR_DEVICELOST == hr )

	cmp	DWORD PTR _hr$12[ebp], -2005530520	; 88760868H
	jne	SHORT $LN70@DXUTStatic

; 3965 :                 {
; 3966 :                     GetDXUTState().SetDeviceLost( true );

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetDeviceLost@DXUTState@@QAEX_N@Z	; DXUTState::SetDeviceLost
	jmp	SHORT $LN68@DXUTStatic
$LN70@DXUTStatic:

; 3967 :                 }
; 3968 :                 else if( D3DERR_DRIVERINTERNALERROR == hr )

	cmp	DWORD PTR _hr$12[ebp], -2005530585	; 88760827H
	jne	SHORT $LN68@DXUTStatic

; 3969 :                 {
; 3970 :                     // When D3DERR_DRIVERINTERNALERROR is returned from Present(),
; 3971 :                     // the application can do one of the following:
; 3972 :                     // 
; 3973 :                     // - End, with the pop-up window saying that the application cannot continue 
; 3974 :                     //   because of problems in the display adapter and that the user should 
; 3975 :                     //   contact the adapter manufacturer.
; 3976 :                     //
; 3977 :                     // - Attempt to restart by calling IDirect3DDevice9::Reset, which is essentially the same 
; 3978 :                     //   path as recovering from a lost device. If IDirect3DDevice9::Reset fails with 
; 3979 :                     //   D3DERR_DRIVERINTERNALERROR, the application should end immediately with the message 
; 3980 :                     //   that the user should contact the adapter manufacturer.
; 3981 :                     // 
; 3982 :                     // The framework attempts the path of resetting the device
; 3983 :                     // 
; 3984 :                     GetDXUTState().SetDeviceLost( true );

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetDeviceLost@DXUTState@@QAEX_N@Z	; DXUTState::SetDeviceLost
$LN68@DXUTStatic:

; 3985 :                 }
; 3986 :             }
; 3987 :             break;

	jmp	$LN74@DXUTStatic
$LN67@DXUTStatic:

; 3988 :         }
; 3989 : 
; 3990 :         case WM_SIZE:
; 3991 :             if( SIZE_MINIMIZED == wParam )

	cmp	DWORD PTR _wParam$[ebp], 1
	jne	SHORT $LN66@DXUTStatic

; 3992 :             {
; 3993 :                 if( GetDXUTState().GetClipCursorWhenFullScreen() && !DXUTIsWindowed() )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetClipCursorWhenFullScreen@DXUTState@@QAE_NXZ ; DXUTState::GetClipCursorWhenFullScreen
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN65@DXUTStatic
	call	?DXUTIsWindowed@@YA_NXZ			; DXUTIsWindowed
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN65@DXUTStatic

; 3994 :                     ClipCursor( NULL );

	mov	esi, esp
	push	0
	call	DWORD PTR __imp__ClipCursor@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN65@DXUTStatic:

; 3995 :                 DXUTPause( true, true ); // Pause while we're minimized

	push	1
	push	1
	call	?DXUTPause@@YAX_N0@Z			; DXUTPause
	add	esp, 8

; 3996 : 
; 3997 :                 GetDXUTState().SetMinimized( true );

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetMinimized@DXUTState@@QAEX_N@Z	; DXUTState::SetMinimized

; 3998 :                 GetDXUTState().SetMaximized( false );

	push	0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetMaximized@DXUTState@@QAEX_N@Z	; DXUTState::SetMaximized

; 3999 : 
; 4000 : 
; 4001 :             }
; 4002 :             else

	jmp	$LN52@DXUTStatic
$LN66@DXUTStatic:

; 4003 :             {
; 4004 :                 RECT rcCurrentClient;
; 4005 :                 GetClientRect( DXUTGetHWND(), &rcCurrentClient );

	mov	esi, esp
	lea	eax, DWORD PTR _rcCurrentClient$8[ebp]
	push	eax
	call	?DXUTGetHWND@@YAPAUHWND__@@XZ		; DXUTGetHWND
	push	eax
	call	DWORD PTR __imp__GetClientRect@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4006 :                 if( rcCurrentClient.top == 0 && rcCurrentClient.bottom == 0 )

	cmp	DWORD PTR _rcCurrentClient$8[ebp+4], 0
	jne	SHORT $LN63@DXUTStatic
	cmp	DWORD PTR _rcCurrentClient$8[ebp+12], 0
	jne	SHORT $LN63@DXUTStatic
	jmp	$LN52@DXUTStatic
$LN63@DXUTStatic:

; 4007 :                 {
; 4008 :                     // Rapidly clicking the task bar to minimize and restore a window
; 4009 :                     // can cause a WM_SIZE message with SIZE_RESTORED when 
; 4010 :                     // the window has actually become minimized due to rapid change
; 4011 :                     // so just ignore this message
; 4012 :                 }
; 4013 :                 else if( SIZE_MAXIMIZED == wParam )

	cmp	DWORD PTR _wParam$[ebp], 2
	jne	SHORT $LN61@DXUTStatic

; 4014 :                 {
; 4015 :                     if( GetDXUTState().GetMinimized() )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetMinimized@DXUTState@@QAE_NXZ	; DXUTState::GetMinimized
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN60@DXUTStatic

; 4016 :                         DXUTPause( false, false ); // Unpause since we're no longer minimized

	push	0
	push	0
	call	?DXUTPause@@YAX_N0@Z			; DXUTPause
	add	esp, 8
$LN60@DXUTStatic:

; 4017 :                     GetDXUTState().SetMinimized( false );

	push	0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetMinimized@DXUTState@@QAEX_N@Z	; DXUTState::SetMinimized

; 4018 :                     GetDXUTState().SetMaximized( true );

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetMaximized@DXUTState@@QAEX_N@Z	; DXUTState::SetMaximized

; 4019 :                     DXUTCheckForWindowSizeChange();

	call	?DXUTCheckForWindowSizeChange@@YAXXZ	; DXUTCheckForWindowSizeChange

; 4020 :                     DXUTCheckForWindowChangingMonitors();

	call	?DXUTCheckForWindowChangingMonitors@@YAXXZ ; DXUTCheckForWindowChangingMonitors
	jmp	$LN52@DXUTStatic
$LN61@DXUTStatic:

; 4021 :                 }
; 4022 :                 else if( SIZE_RESTORED == wParam )

	cmp	DWORD PTR _wParam$[ebp], 0
	jne	$LN52@DXUTStatic

; 4023 :                 {      
; 4024 :                     if( GetDXUTState().GetMaximized() )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetMaximized@DXUTState@@QAE_NXZ	; DXUTState::GetMaximized
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN57@DXUTStatic

; 4025 :                     {
; 4026 :                         GetDXUTState().SetMaximized( false );

	push	0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetMaximized@DXUTState@@QAEX_N@Z	; DXUTState::SetMaximized

; 4027 :                         DXUTCheckForWindowSizeChange();

	call	?DXUTCheckForWindowSizeChange@@YAXXZ	; DXUTCheckForWindowSizeChange

; 4028 :                         DXUTCheckForWindowChangingMonitors();

	call	?DXUTCheckForWindowChangingMonitors@@YAXXZ ; DXUTCheckForWindowChangingMonitors
	jmp	SHORT $LN52@DXUTStatic
$LN57@DXUTStatic:

; 4029 :                     }
; 4030 :                     else if( GetDXUTState().GetMinimized() )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetMinimized@DXUTState@@QAE_NXZ	; DXUTState::GetMinimized
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN55@DXUTStatic

; 4031 :                     {
; 4032 :                         DXUTPause( false, false ); // Unpause since we're no longer minimized

	push	0
	push	0
	call	?DXUTPause@@YAX_N0@Z			; DXUTPause
	add	esp, 8

; 4033 :                         GetDXUTState().SetMinimized( false );

	push	0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetMinimized@DXUTState@@QAEX_N@Z	; DXUTState::SetMinimized

; 4034 :                         DXUTCheckForWindowSizeChange();

	call	?DXUTCheckForWindowSizeChange@@YAXXZ	; DXUTCheckForWindowSizeChange

; 4035 :                         DXUTCheckForWindowChangingMonitors();

	call	?DXUTCheckForWindowChangingMonitors@@YAXXZ ; DXUTCheckForWindowChangingMonitors
	jmp	SHORT $LN52@DXUTStatic
$LN55@DXUTStatic:

; 4036 :                     }
; 4037 :                     else if( GetDXUTState().GetInSizeMove() )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetInSizeMove@DXUTState@@QAE_NXZ	; DXUTState::GetInSizeMove
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN53@DXUTStatic

; 4038 :                     {
; 4039 :                         // If we're neither maximized nor minimized, the window size 
; 4040 :                         // is changing by the user dragging the window edges.  In this 
; 4041 :                         // case, we don't reset the device yet -- we wait until the 
; 4042 :                         // user stops dragging, and a WM_EXITSIZEMOVE message comes.
; 4043 :                     }
; 4044 :                     else

	jmp	SHORT $LN52@DXUTStatic
$LN53@DXUTStatic:

; 4045 :                     {
; 4046 :                         // This WM_SIZE come from resizing the window via an API like SetWindowPos() so 
; 4047 :                         // resize and reset the device now.
; 4048 :                         DXUTCheckForWindowSizeChange();

	call	?DXUTCheckForWindowSizeChange@@YAXXZ	; DXUTCheckForWindowSizeChange

; 4049 :                         DXUTCheckForWindowChangingMonitors();

	call	?DXUTCheckForWindowChangingMonitors@@YAXXZ ; DXUTCheckForWindowChangingMonitors
$LN52@DXUTStatic:

; 4050 :                     }
; 4051 :                 }
; 4052 :             }
; 4053 :             break;

	jmp	$LN74@DXUTStatic
$LN51@DXUTStatic:

; 4054 : 
; 4055 :         case WM_GETMINMAXINFO:
; 4056 :             ((MINMAXINFO*)lParam)->ptMinTrackSize.x = DXUT_MIN_WINDOW_SIZE_X;

	mov	eax, DWORD PTR _lParam$[ebp]
	mov	DWORD PTR [eax+24], 200			; 000000c8H

; 4057 :             ((MINMAXINFO*)lParam)->ptMinTrackSize.y = DXUT_MIN_WINDOW_SIZE_Y;

	mov	eax, DWORD PTR _lParam$[ebp]
	mov	DWORD PTR [eax+28], 200			; 000000c8H

; 4058 :             break;

	jmp	$LN74@DXUTStatic
$LN50@DXUTStatic:

; 4059 : 
; 4060 :         case WM_ENTERSIZEMOVE:
; 4061 :             // Halt frame movement while the app is sizing or moving
; 4062 :             DXUTPause( true, true );

	push	1
	push	1
	call	?DXUTPause@@YAX_N0@Z			; DXUTPause
	add	esp, 8

; 4063 :             GetDXUTState().SetInSizeMove( true );

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetInSizeMove@DXUTState@@QAEX_N@Z	; DXUTState::SetInSizeMove

; 4064 :             break;

	jmp	$LN74@DXUTStatic
$LN49@DXUTStatic:

; 4065 : 
; 4066 :         case WM_EXITSIZEMOVE:
; 4067 :             DXUTPause( false, false );

	push	0
	push	0
	call	?DXUTPause@@YAX_N0@Z			; DXUTPause
	add	esp, 8

; 4068 :             DXUTCheckForWindowSizeChange();

	call	?DXUTCheckForWindowSizeChange@@YAXXZ	; DXUTCheckForWindowSizeChange

; 4069 :             DXUTCheckForWindowChangingMonitors();

	call	?DXUTCheckForWindowChangingMonitors@@YAXXZ ; DXUTCheckForWindowChangingMonitors

; 4070 :             GetDXUTState().SetInSizeMove( false );

	push	0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetInSizeMove@DXUTState@@QAEX_N@Z	; DXUTState::SetInSizeMove

; 4071 :             break;

	jmp	$LN74@DXUTStatic
$LN48@DXUTStatic:

; 4072 : 
; 4073 :          case WM_MOUSEMOVE:
; 4074 :             if( !DXUTIsRenderingPaused() && !DXUTIsWindowed() )

	call	?DXUTIsRenderingPaused@@YA_NXZ		; DXUTIsRenderingPaused
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN46@DXUTStatic
	call	?DXUTIsWindowed@@YA_NXZ			; DXUTIsWindowed
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN46@DXUTStatic

; 4075 :             {
; 4076 :                 IDirect3DDevice9* pd3dDevice = DXUTGetD3DDevice();

	call	?DXUTGetD3DDevice@@YAPAUIDirect3DDevice9@@XZ ; DXUTGetD3DDevice
	mov	DWORD PTR _pd3dDevice$7[ebp], eax

; 4077 :                 if( pd3dDevice )

	cmp	DWORD PTR _pd3dDevice$7[ebp], 0
	je	SHORT $LN46@DXUTStatic

; 4078 :                 {
; 4079 :                     POINT ptCursor;
; 4080 :                     GetCursorPos( &ptCursor );

	mov	esi, esp
	lea	eax, DWORD PTR _ptCursor$6[ebp]
	push	eax
	call	DWORD PTR __imp__GetCursorPos@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4081 :                     pd3dDevice->SetCursorPosition( ptCursor.x, ptCursor.y, 0 );

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR _ptCursor$6[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _ptCursor$6[ebp]
	push	ecx
	mov	edx, DWORD PTR _pd3dDevice$7[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pd3dDevice$7[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+44]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN46@DXUTStatic:

; 4082 :                 }
; 4083 :             }
; 4084 :             break;

	jmp	$LN74@DXUTStatic
$LN45@DXUTStatic:

; 4085 : 
; 4086 :        case WM_ACTIVATEAPP:
; 4087 :             if( wParam == TRUE && !GetDXUTState().GetActive() ) // Handle only if previously not active 

	cmp	DWORD PTR _wParam$[ebp], 1
	jne	$LN44@DXUTStatic
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetActive@DXUTState@@QAE_NXZ		; DXUTState::GetActive
	movzx	eax, al
	test	eax, eax
	jne	$LN44@DXUTStatic

; 4088 :             {
; 4089 :                 GetDXUTState().SetActive( true );

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetActive@DXUTState@@QAEX_N@Z		; DXUTState::SetActive

; 4090 : 
; 4091 :                 // Show the cursor again if returning to fullscreen 
; 4092 :                 if( !DXUTIsWindowed() && GetDXUTState().GetShowCursorWhenFullScreen() )

	call	?DXUTIsWindowed@@YA_NXZ			; DXUTIsWindowed
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN43@DXUTStatic
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetShowCursorWhenFullScreen@DXUTState@@QAE_NXZ ; DXUTState::GetShowCursorWhenFullScreen
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN43@DXUTStatic

; 4093 :                     DXUTInitHWCursor();

	call	?DXUTInitHWCursor@@YAXXZ		; DXUTInitHWCursor
$LN43@DXUTStatic:

; 4094 : 
; 4095 :                 // The GetMinimizedWhileFullscreen() varible is used instead of !DXUTIsWindowed()
; 4096 :                 // to handle the rare case toggling to windowed mode while the fullscreen application 
; 4097 :                 // is minimized and thus making the pause count wrong
; 4098 :                 if( GetDXUTState().GetMinimizedWhileFullscreen() ) 

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetMinimizedWhileFullscreen@DXUTState@@QAE_NXZ ; DXUTState::GetMinimizedWhileFullscreen
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN42@DXUTStatic

; 4099 :                 {
; 4100 :                     DXUTPause( false, false ); // Unpause since we're no longer minimized

	push	0
	push	0
	call	?DXUTPause@@YAX_N0@Z			; DXUTPause
	add	esp, 8

; 4101 :                     GetDXUTState().SetMinimizedWhileFullscreen( false );

	push	0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetMinimizedWhileFullscreen@DXUTState@@QAEX_N@Z ; DXUTState::SetMinimizedWhileFullscreen
$LN42@DXUTStatic:

; 4102 :                 }
; 4103 : 
; 4104 :                 // Upon returning to this app, potentially disable shortcut keys 
; 4105 :                 // (Windows key, accessibility shortcuts) 
; 4106 :                 DXUTAllowShortcutKeys( ( DXUTIsWindowed() ) ? GetDXUTState().GetAllowShortcutKeysWhenWindowed() : 
; 4107 :                                                               GetDXUTState().GetAllowShortcutKeysWhenFullscreen() );

	call	?DXUTIsWindowed@@YA_NXZ			; DXUTIsWindowed
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN96@DXUTStatic
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetAllowShortcutKeysWhenWindowed@DXUTState@@QAE_NXZ ; DXUTState::GetAllowShortcutKeysWhenWindowed
	mov	BYTE PTR tv405[ebp], al
	jmp	SHORT $LN97@DXUTStatic
$LN96@DXUTStatic:
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetAllowShortcutKeysWhenFullscreen@DXUTState@@QAE_NXZ ; DXUTState::GetAllowShortcutKeysWhenFullscreen
	mov	BYTE PTR tv405[ebp], al
$LN97@DXUTStatic:
	movzx	ecx, BYTE PTR tv405[ebp]
	push	ecx
	call	?DXUTAllowShortcutKeys@@YAX_N@Z		; DXUTAllowShortcutKeys
	add	esp, 4
	jmp	SHORT $LN40@DXUTStatic
$LN44@DXUTStatic:

; 4108 : 
; 4109 :             }
; 4110 :             else if( wParam == FALSE && GetDXUTState().GetActive() ) // Handle only if previously active 

	cmp	DWORD PTR _wParam$[ebp], 0
	jne	SHORT $LN40@DXUTStatic
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetActive@DXUTState@@QAE_NXZ		; DXUTState::GetActive
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN40@DXUTStatic

; 4111 :             {               
; 4112 :                 GetDXUTState().SetActive( false );

	push	0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetActive@DXUTState@@QAEX_N@Z		; DXUTState::SetActive

; 4113 : 
; 4114 :                 if( !DXUTIsWindowed() )

	call	?DXUTIsWindowed@@YA_NXZ			; DXUTIsWindowed
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN39@DXUTStatic

; 4115 :                 {
; 4116 :                     // Going from full screen to a minimized state 
; 4117 :                     ClipCursor( NULL );      // don't limit the cursor anymore

	mov	esi, esp
	push	0
	call	DWORD PTR __imp__ClipCursor@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4118 :                     DXUTPause( true, true ); // Pause while we're minimized (take care not to pause twice by handling this message twice)

	push	1
	push	1
	call	?DXUTPause@@YAX_N0@Z			; DXUTPause
	add	esp, 8

; 4119 :                     GetDXUTState().SetMinimizedWhileFullscreen( true ); 

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetMinimizedWhileFullscreen@DXUTState@@QAEX_N@Z ; DXUTState::SetMinimizedWhileFullscreen
$LN39@DXUTStatic:

; 4120 :                 }
; 4121 : 
; 4122 :                 // Restore shortcut keys (Windows key, accessibility shortcuts) to original state
; 4123 :                 //
; 4124 :                 // This is important to call here if the shortcuts are disabled, 
; 4125 :                 // because if this is not done then the Windows key will continue to 
; 4126 :                 // be disabled while this app is running which is very bad.
; 4127 :                 // If the app crashes, the Windows key will return to normal.
; 4128 :                 DXUTAllowShortcutKeys( true );

	push	1
	call	?DXUTAllowShortcutKeys@@YAX_N@Z		; DXUTAllowShortcutKeys
	add	esp, 4
$LN40@DXUTStatic:

; 4129 :             }
; 4130 :             break;

	jmp	$LN74@DXUTStatic
$LN38@DXUTStatic:

; 4131 : 
; 4132 :        case WM_ENTERMENULOOP:
; 4133 :             // Pause the app when menus are displayed
; 4134 :             DXUTPause( true, true );

	push	1
	push	1
	call	?DXUTPause@@YAX_N0@Z			; DXUTPause
	add	esp, 8

; 4135 :             break;

	jmp	$LN74@DXUTStatic
$LN37@DXUTStatic:

; 4136 : 
; 4137 :         case WM_EXITMENULOOP:
; 4138 :             DXUTPause( false, false );

	push	0
	push	0
	call	?DXUTPause@@YAX_N0@Z			; DXUTPause
	add	esp, 8

; 4139 :             break;

	jmp	$LN74@DXUTStatic
$LN36@DXUTStatic:

; 4140 : 
; 4141 :         case WM_MENUCHAR:
; 4142 :             // A menu is active and the user presses a key that does not correspond to any mnemonic or accelerator key
; 4143 :             // So just ignore and don't beep
; 4144 :             return MAKELRESULT(0,MNC_CLOSE);

	mov	eax, 65536				; 00010000H
	jmp	$LN1@DXUTStatic

; 4145 :             break;

	jmp	$LN74@DXUTStatic
$LN35@DXUTStatic:

; 4146 : 
; 4147 :         case WM_NCHITTEST:
; 4148 :             // Prevent the user from selecting the menu in full screen mode
; 4149 :             if( !DXUTIsWindowed() )

	call	?DXUTIsWindowed@@YA_NXZ			; DXUTIsWindowed
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN34@DXUTStatic

; 4150 :                 return HTCLIENT;

	mov	eax, 1
	jmp	$LN1@DXUTStatic
$LN34@DXUTStatic:

; 4151 :             break;

	jmp	$LN74@DXUTStatic
$LN33@DXUTStatic:

; 4152 : 
; 4153 :         case WM_POWERBROADCAST:
; 4154 :             switch( wParam )

	mov	eax, DWORD PTR _wParam$[ebp]
	mov	DWORD PTR tv433[ebp], eax
	cmp	DWORD PTR tv433[ebp], 0
	je	SHORT $LN30@DXUTStatic
	cmp	DWORD PTR tv433[ebp], 7
	je	SHORT $LN29@DXUTStatic
	jmp	SHORT $LN31@DXUTStatic
$LN30@DXUTStatic:

; 4155 :             {
; 4156 :                 #ifndef PBT_APMQUERYSUSPEND
; 4157 :                     #define PBT_APMQUERYSUSPEND 0x0000
; 4158 :                 #endif
; 4159 :                 case PBT_APMQUERYSUSPEND:
; 4160 :                     // At this point, the app should save any data for open
; 4161 :                     // network connections, files, etc., and prepare to go into
; 4162 :                     // a suspended mode.  The app can use the MsgProc callback
; 4163 :                     // to handle this if desired.
; 4164 :                     return true;

	mov	eax, 1
	jmp	$LN1@DXUTStatic
$LN29@DXUTStatic:

; 4165 : 
; 4166 :                 #ifndef PBT_APMRESUMESUSPEND
; 4167 :                     #define PBT_APMRESUMESUSPEND 0x0007
; 4168 :                 #endif
; 4169 :                 case PBT_APMRESUMESUSPEND:
; 4170 :                     // At this point, the app should recover any data, network
; 4171 :                     // connections, files, etc., and resume running from when
; 4172 :                     // the app was suspended. The app can use the MsgProc callback
; 4173 :                     // to handle this if desired.
; 4174 :                    
; 4175 :                    // QPC may lose consistency when suspending, so reset the timer
; 4176 :                    // upon resume.
; 4177 :                    DXUTGetGlobalTimer()->Reset();                   

	call	?DXUTGetGlobalTimer@@YAPAVCDXUTTimer@@XZ ; DXUTGetGlobalTimer
	mov	ecx, eax
	call	?Reset@CDXUTTimer@@QAEXXZ		; CDXUTTimer::Reset

; 4178 :                    GetDXUTState().SetLastStatsUpdateTime( 0 );

	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR [esp], xmm0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetLastStatsUpdateTime@DXUTState@@QAEXN@Z ; DXUTState::SetLastStatsUpdateTime

; 4179 :                    return true;

	mov	eax, 1
	jmp	$LN1@DXUTStatic
$LN31@DXUTStatic:

; 4180 :             }
; 4181 :             break;

	jmp	$LN74@DXUTStatic
$LN28@DXUTStatic:

; 4182 : 
; 4183 :         case WM_SYSCOMMAND:
; 4184 :             // Prevent moving/sizing and power loss in full screen mode
; 4185 :             switch( wParam )

	mov	eax, DWORD PTR _wParam$[ebp]
	mov	DWORD PTR tv441[ebp], eax
	cmp	DWORD PTR tv441[ebp], 61488		; 0000f030H
	ja	SHORT $LN98@DXUTStatic
	cmp	DWORD PTR tv441[ebp], 61488		; 0000f030H
	je	SHORT $LN25@DXUTStatic
	cmp	DWORD PTR tv441[ebp], 61440		; 0000f000H
	je	SHORT $LN25@DXUTStatic
	cmp	DWORD PTR tv441[ebp], 61456		; 0000f010H
	je	SHORT $LN25@DXUTStatic
	jmp	SHORT $LN26@DXUTStatic
$LN98@DXUTStatic:
	cmp	DWORD PTR tv441[ebp], 61696		; 0000f100H
	je	SHORT $LN25@DXUTStatic
	cmp	DWORD PTR tv441[ebp], 61808		; 0000f170H
	je	SHORT $LN25@DXUTStatic
	jmp	SHORT $LN26@DXUTStatic
$LN25@DXUTStatic:

; 4186 :             {
; 4187 :                 case SC_MOVE:
; 4188 :                 case SC_SIZE:
; 4189 :                 case SC_MAXIMIZE:
; 4190 :                 case SC_KEYMENU:
; 4191 :                 case SC_MONITORPOWER:
; 4192 :                     if( !DXUTIsWindowed() )

	call	?DXUTIsWindowed@@YA_NXZ			; DXUTIsWindowed
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN24@DXUTStatic

; 4193 :                         return 0;

	xor	eax, eax
	jmp	$LN1@DXUTStatic
$LN24@DXUTStatic:
$LN26@DXUTStatic:

; 4194 :                     break;
; 4195 :             }
; 4196 :             break;

	jmp	$LN74@DXUTStatic
$LN23@DXUTStatic:

; 4197 : 
; 4198 :         case WM_SYSKEYDOWN:
; 4199 :         {
; 4200 :             if( GetDXUTState().GetHandleDefaultHotkeys() )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetHandleDefaultHotkeys@DXUTState@@QAE_NXZ ; DXUTState::GetHandleDefaultHotkeys
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN20@DXUTStatic

; 4201 :             {
; 4202 :                 switch( wParam )

	mov	eax, DWORD PTR _wParam$[ebp]
	mov	DWORD PTR tv456[ebp], eax
	cmp	DWORD PTR tv456[ebp], 13		; 0000000dH
	je	SHORT $LN19@DXUTStatic
	jmp	SHORT $LN20@DXUTStatic
$LN19@DXUTStatic:

; 4203 :                 {
; 4204 :                     case VK_RETURN:
; 4205 :                     {
; 4206 :                         // Toggle full screen upon alt-enter 
; 4207 :                         DWORD dwMask = (1 << 29);

	mov	DWORD PTR _dwMask$5[ebp], 536870912	; 20000000H

; 4208 :                         if( (lParam & dwMask) != 0 ) // Alt is down also

	mov	eax, DWORD PTR _lParam$[ebp]
	and	eax, DWORD PTR _dwMask$5[ebp]
	je	SHORT $LN18@DXUTStatic

; 4209 :                         {
; 4210 :                             // Toggle the full screen/window mode
; 4211 :                             DXUTPause( true, true );

	push	1
	push	1
	call	?DXUTPause@@YAX_N0@Z			; DXUTPause
	add	esp, 8

; 4212 :                             DXUTToggleFullScreen();

	call	?DXUTToggleFullScreen@@YAJXZ		; DXUTToggleFullScreen

; 4213 :                             DXUTPause( false, false );                        

	push	0
	push	0
	call	?DXUTPause@@YAX_N0@Z			; DXUTPause
	add	esp, 8

; 4214 :                             return 0;

	xor	eax, eax
	jmp	$LN1@DXUTStatic
$LN18@DXUTStatic:
$LN20@DXUTStatic:

; 4215 :                         }
; 4216 :                     }
; 4217 :                 }
; 4218 :             }
; 4219 :             break;

	jmp	$LN74@DXUTStatic
$LN17@DXUTStatic:

; 4220 :         }
; 4221 : 
; 4222 :         case WM_KEYDOWN:
; 4223 :         {
; 4224 :             if( GetDXUTState().GetHandleDefaultHotkeys() )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetHandleDefaultHotkeys@DXUTState@@QAE_NXZ ; DXUTState::GetHandleDefaultHotkeys
	movzx	eax, al
	test	eax, eax
	je	$LN14@DXUTStatic

; 4225 :             {
; 4226 :                 switch( wParam )

	mov	eax, DWORD PTR _wParam$[ebp]
	mov	DWORD PTR tv469[ebp], eax
	mov	ecx, DWORD PTR tv469[ebp]
	sub	ecx, 19					; 00000013H
	mov	DWORD PTR tv469[ebp], ecx
	cmp	DWORD PTR tv469[ebp], 100		; 00000064H
	ja	$LN14@DXUTStatic
	mov	edx, DWORD PTR tv469[ebp]
	movzx	eax, BYTE PTR $LN109@DXUTStatic[edx]
	jmp	DWORD PTR $LN116@DXUTStatic[eax*4]
$LN13@DXUTStatic:

; 4227 :                 {
; 4228 :                     case VK_F3:
; 4229 :                     {
; 4230 :                         DXUTPause( true, true );

	push	1
	push	1
	call	?DXUTPause@@YAX_N0@Z			; DXUTPause
	add	esp, 8

; 4231 :                         DXUTToggleREF();

	call	?DXUTToggleREF@@YAJXZ			; DXUTToggleREF

; 4232 :                         DXUTPause( false, false );                        

	push	0
	push	0
	call	?DXUTPause@@YAX_N0@Z			; DXUTPause
	add	esp, 8

; 4233 :                         break;

	jmp	$LN14@DXUTStatic
$LN12@DXUTStatic:

; 4234 :                     }
; 4235 : 
; 4236 :                     case VK_F8:
; 4237 :                     {
; 4238 :                         bool bWireFrame = GetDXUTState().GetWireframeMode();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetWireframeMode@DXUTState@@QAE_NXZ	; DXUTState::GetWireframeMode
	mov	BYTE PTR _bWireFrame$4[ebp], al

; 4239 :                         bWireFrame = !bWireFrame; 

	movzx	eax, BYTE PTR _bWireFrame$4[ebp]
	test	eax, eax
	jne	SHORT $LN99@DXUTStatic
	mov	DWORD PTR tv479[ebp], 1
	jmp	SHORT $LN100@DXUTStatic
$LN99@DXUTStatic:
	mov	DWORD PTR tv479[ebp], 0
$LN100@DXUTStatic:
	mov	cl, BYTE PTR tv479[ebp]
	mov	BYTE PTR _bWireFrame$4[ebp], cl

; 4240 :                         GetDXUTState().SetWireframeMode( bWireFrame );

	movzx	eax, BYTE PTR _bWireFrame$4[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetWireframeMode@DXUTState@@QAEX_N@Z	; DXUTState::SetWireframeMode

; 4241 : 
; 4242 :                         IDirect3DDevice9* pd3dDevice = DXUTGetD3DDevice();

	call	?DXUTGetD3DDevice@@YAPAUIDirect3DDevice9@@XZ ; DXUTGetD3DDevice
	mov	DWORD PTR _pd3dDevice$3[ebp], eax

; 4243 :                         if( pd3dDevice )

	cmp	DWORD PTR _pd3dDevice$3[ebp], 0
	je	SHORT $LN11@DXUTStatic

; 4244 :                             pd3dDevice->SetRenderState( D3DRS_FILLMODE, (bWireFrame) ? D3DFILL_WIREFRAME : D3DFILL_SOLID ); 

	movzx	eax, BYTE PTR _bWireFrame$4[ebp]
	test	eax, eax
	je	SHORT $LN101@DXUTStatic
	mov	DWORD PTR tv492[ebp], 2
	jmp	SHORT $LN102@DXUTStatic
$LN101@DXUTStatic:
	mov	DWORD PTR tv492[ebp], 3
$LN102@DXUTStatic:
	mov	esi, esp
	mov	ecx, DWORD PTR tv492[ebp]
	push	ecx
	push	8
	mov	edx, DWORD PTR _pd3dDevice$3[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pd3dDevice$3[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+228]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN11@DXUTStatic:

; 4245 :                         break;

	jmp	SHORT $LN14@DXUTStatic
$LN10@DXUTStatic:

; 4246 :                     }
; 4247 : 
; 4248 :                     case VK_ESCAPE:
; 4249 :                     {
; 4250 :                         // Received key to exit app
; 4251 :                         SendMessage( hWnd, WM_CLOSE, 0, 0 );

	mov	esi, esp
	push	0
	push	0
	push	16					; 00000010H
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__SendMessageA@16
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN9@DXUTStatic:

; 4252 :                     }
; 4253 : 
; 4254 :                     case VK_PAUSE: 
; 4255 :                     {
; 4256 :                         bool bTimePaused = DXUTIsTimePaused();

	call	?DXUTIsTimePaused@@YA_NXZ		; DXUTIsTimePaused
	mov	BYTE PTR _bTimePaused$2[ebp], al

; 4257 :                         bTimePaused = !bTimePaused;

	movzx	eax, BYTE PTR _bTimePaused$2[ebp]
	test	eax, eax
	jne	SHORT $LN103@DXUTStatic
	mov	DWORD PTR tv501[ebp], 1
	jmp	SHORT $LN104@DXUTStatic
$LN103@DXUTStatic:
	mov	DWORD PTR tv501[ebp], 0
$LN104@DXUTStatic:
	mov	cl, BYTE PTR tv501[ebp]
	mov	BYTE PTR _bTimePaused$2[ebp], cl

; 4258 :                         if( bTimePaused ) 

	movzx	eax, BYTE PTR _bTimePaused$2[ebp]
	test	eax, eax
	je	SHORT $LN8@DXUTStatic

; 4259 :                             DXUTPause( true, false ); 

	push	0
	push	1
	call	?DXUTPause@@YAX_N0@Z			; DXUTPause
	add	esp, 8

; 4260 :                         else

	jmp	SHORT $LN7@DXUTStatic
$LN8@DXUTStatic:

; 4261 :                             DXUTPause( false, false ); 

	push	0
	push	0
	call	?DXUTPause@@YAX_N0@Z			; DXUTPause
	add	esp, 8
$LN7@DXUTStatic:
$LN14@DXUTStatic:

; 4262 :                         break; 
; 4263 :                     }
; 4264 :                 }
; 4265 :             }
; 4266 :             break;

	jmp	$LN74@DXUTStatic
$LN6@DXUTStatic:

; 4267 :         }
; 4268 : 
; 4269 :         case WM_CLOSE:
; 4270 :         {
; 4271 :             HMENU hMenu;
; 4272 :             hMenu = GetMenu(hWnd);

	mov	esi, esp
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__GetMenu@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hMenu$1[ebp], eax

; 4273 :             if( hMenu != NULL )

	cmp	DWORD PTR _hMenu$1[ebp], 0
	je	SHORT $LN5@DXUTStatic

; 4274 :                 DestroyMenu( hMenu );

	mov	esi, esp
	mov	eax, DWORD PTR _hMenu$1[ebp]
	push	eax
	call	DWORD PTR __imp__DestroyMenu@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@DXUTStatic:

; 4275 :             DestroyWindow( hWnd );

	mov	esi, esp
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__DestroyWindow@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4276 :             UnregisterClass( "Direct3DWindowClass", NULL );

	mov	esi, esp
	push	0
	push	OFFSET ??_C@_0BE@MKMDFNEO@Direct3DWindowClass?$AA@
	call	DWORD PTR __imp__UnregisterClassA@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4277 :             GetDXUTState().SetHWNDFocus( NULL );

	push	0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetHWNDFocus@DXUTState@@QAEXPAUHWND__@@@Z ; DXUTState::SetHWNDFocus

; 4278 :             GetDXUTState().SetHWNDDeviceFullScreen( NULL );

	push	0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetHWNDDeviceFullScreen@DXUTState@@QAEXPAUHWND__@@@Z ; DXUTState::SetHWNDDeviceFullScreen

; 4279 :             GetDXUTState().SetHWNDDeviceWindowed( NULL );

	push	0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetHWNDDeviceWindowed@DXUTState@@QAEXPAUHWND__@@@Z ; DXUTState::SetHWNDDeviceWindowed

; 4280 :             return 0;

	xor	eax, eax
	jmp	SHORT $LN1@DXUTStatic
$LN4@DXUTStatic:

; 4281 :         }
; 4282 : 
; 4283 :         case WM_DESTROY:
; 4284 :             PostQuitMessage(0);

	mov	esi, esp
	push	0
	call	DWORD PTR __imp__PostQuitMessage@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN74@DXUTStatic:

; 4285 :             break;
; 4286 :     }
; 4287 : 
; 4288 :     // Don't allow the F10 key to act as a shortcut to the menu bar
; 4289 :     // by not passing these messages to the DefWindowProc only when
; 4290 :     // there's no menu present
; 4291 :     if( GetDXUTState().GetMenu() == NULL && (uMsg == WM_SYSKEYDOWN || uMsg == WM_SYSKEYUP) && wParam == VK_F10 )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetMenu@DXUTState@@QAEPAUHMENU__@@XZ	; DXUTState::GetMenu
	test	eax, eax
	jne	SHORT $LN3@DXUTStatic
	cmp	DWORD PTR _uMsg$[ebp], 260		; 00000104H
	je	SHORT $LN2@DXUTStatic
	cmp	DWORD PTR _uMsg$[ebp], 261		; 00000105H
	jne	SHORT $LN3@DXUTStatic
$LN2@DXUTStatic:
	cmp	DWORD PTR _wParam$[ebp], 121		; 00000079H
	jne	SHORT $LN3@DXUTStatic

; 4292 :         return 0;

	xor	eax, eax
	jmp	SHORT $LN1@DXUTStatic

; 4293 :     else

	jmp	SHORT $LN1@DXUTStatic
$LN3@DXUTStatic:

; 4294 :         return DefWindowProc( hWnd, uMsg, wParam, lParam );

	mov	esi, esp
	mov	eax, DWORD PTR _lParam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wParam$[ebp]
	push	ecx
	mov	edx, DWORD PTR _uMsg$[ebp]
	push	edx
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__DefWindowProcA@16
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@DXUTStatic:

; 4295 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN114@DXUTStatic
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 560				; 00000230H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN114@DXUTStatic:
	DD	3
	DD	$LN113@DXUTStatic
$LN113@DXUTStatic:
	DD	-100					; ffffff9cH
	DD	8
	DD	$LN110@DXUTStatic
	DD	-272					; fffffef0H
	DD	16					; 00000010H
	DD	$LN111@DXUTStatic
	DD	-300					; fffffed4H
	DD	8
	DD	$LN112@DXUTStatic
$LN112@DXUTStatic:
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	67					; 00000043H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	115					; 00000073H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	0
$LN111@DXUTStatic:
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	67					; 00000043H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	67					; 00000043H
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
$LN110@DXUTStatic:
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	0
$LN115@DXUTStatic:
	DD	$LN4@DXUTStatic
	DD	$LN67@DXUTStatic
	DD	$LN73@DXUTStatic
	DD	$LN6@DXUTStatic
	DD	$LN45@DXUTStatic
	DD	$LN51@DXUTStatic
	DD	$LN35@DXUTStatic
	DD	$LN17@DXUTStatic
	DD	$LN74@DXUTStatic
$LN108@DXUTStatic:
	DB	0
	DB	8
	DB	8
	DB	1
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	2
	DB	3
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	4
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	5
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	6
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	7
	npad	1
$LN116@DXUTStatic:
	DD	$LN9@DXUTStatic
	DD	$LN10@DXUTStatic
	DD	$LN13@DXUTStatic
	DD	$LN12@DXUTStatic
	DD	$LN14@DXUTStatic
$LN109@DXUTStatic:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
?DXUTStaticWndProc@@YGJPAUHWND__@@IIJ@Z ENDP		; DXUTStaticWndProc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTSetWindow@@YAJPAUHWND__@@00_N@Z
_TEXT	SEGMENT
_hInstance$ = -56					; size = 4
_strCachedWindowTitle$ = -44				; size = 4
_dwError$1 = -32					; size = 4
_nResult$2 = -20					; size = 4
_hr$ = -8						; size = 4
_hWndFocus$ = 8						; size = 4
_hWndDeviceFullScreen$ = 12				; size = 4
_hWndDeviceWindowed$ = 16				; size = 4
_bHandleMessages$ = 20					; size = 1
?DXUTSetWindow@@YAJPAUHWND__@@00_N@Z PROC		; DXUTSetWindow, COMDAT

; 883  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 884  :     HRESULT hr;
; 885  :  
; 886  :     // Not allowed to call this from inside the device callbacks
; 887  :     if( GetDXUTState().GetInsideDeviceCallback() )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetInsideDeviceCallback@DXUTState@@QAE_NXZ ; DXUTState::GetInsideDeviceCallback
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@DXUTSetWin

; 888  :         return DXUT_ERR_MSGBOX( "DXUTCreateWindow", E_FAIL );

	push	1
	push	OFFSET ??_C@_0BB@LKEDMNKO@DXUTCreateWindow?$AA@
	push	-2147467259				; 80004005H
	mov	eax, DWORD PTR ?__LINE__Var@?1??DXUTSetWindow@@YAJPAUHWND__@@00_N@Z@4JA
	add	eax, 5
	push	eax
	push	OFFSET ??_C@_0CL@KBAHBIDF@z?3?2sampsrc?202xu1?2saco?2d3d9?2commo@
	call	?DXUTTrace@@YGJPBDKJ0_N@Z		; DXUTTrace
	jmp	$LN9@DXUTSetWin
$LN8@DXUTSetWin:

; 889  : 
; 890  :     GetDXUTState().SetWindowCreateCalled( true );

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetWindowCreateCalled@DXUTState@@QAEX_N@Z ; DXUTState::SetWindowCreateCalled

; 891  : 
; 892  :     // To avoid confusion, we do not allow any HWND to be NULL here.  The
; 893  :     // caller must pass in valid HWND for all three parameters.  The same
; 894  :     // HWND may be used for more than one parameter.
; 895  :     if( hWndFocus == NULL || hWndDeviceFullScreen == NULL || hWndDeviceWindowed == NULL )

	cmp	DWORD PTR _hWndFocus$[ebp], 0
	je	SHORT $LN6@DXUTSetWin
	cmp	DWORD PTR _hWndDeviceFullScreen$[ebp], 0
	je	SHORT $LN6@DXUTSetWin
	cmp	DWORD PTR _hWndDeviceWindowed$[ebp], 0
	jne	SHORT $LN7@DXUTSetWin
$LN6@DXUTSetWin:

; 896  :         return DXUT_ERR_MSGBOX( "DXUTSetWindow", E_INVALIDARG );

	push	1
	push	OFFSET ??_C@_0O@FNJALMEB@DXUTSetWindow?$AA@
	push	-2147024809				; 80070057H
	mov	eax, DWORD PTR ?__LINE__Var@?1??DXUTSetWindow@@YAJPAUHWND__@@00_N@Z@4JA
	add	eax, 13					; 0000000dH
	push	eax
	push	OFFSET ??_C@_0CL@KBAHBIDF@z?3?2sampsrc?202xu1?2saco?2d3d9?2commo@
	call	?DXUTTrace@@YGJPBDKJ0_N@Z		; DXUTTrace
	jmp	$LN9@DXUTSetWin
$LN7@DXUTSetWin:

; 897  : 
; 898  :     // If subclassing the window, set the pointer to the local window procedure
; 899  :     if( bHandleMessages )

	movzx	eax, BYTE PTR _bHandleMessages$[ebp]
	test	eax, eax
	je	SHORT $LN5@DXUTSetWin

; 900  :     {
; 901  :         // Switch window procedures
; 902  : #ifdef _WIN64
; 903  :         LONG_PTR nResult = SetWindowLongPtr( hWndFocus, GWLP_WNDPROC, (LONG_PTR)DXUTStaticWndProc );
; 904  : #else
; 905  :         LONG_PTR nResult = SetWindowLongPtr( hWndFocus, GWLP_WNDPROC, (LONG)(LONG_PTR)DXUTStaticWndProc );

	mov	esi, esp
	push	OFFSET ?DXUTStaticWndProc@@YGJPAUHWND__@@IIJ@Z ; DXUTStaticWndProc
	push	-4					; fffffffcH
	mov	eax, DWORD PTR _hWndFocus$[ebp]
	push	eax
	call	DWORD PTR __imp__SetWindowLongA@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _nResult$2[ebp], eax

; 906  : #endif 
; 907  :  
; 908  :         DWORD dwError = GetLastError();

	mov	esi, esp
	call	DWORD PTR __imp__GetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _dwError$1[ebp], eax

; 909  :         if( nResult == 0 )

	cmp	DWORD PTR _nResult$2[ebp], 0
	jne	SHORT $LN5@DXUTSetWin

; 910  :             return DXUT_ERR_MSGBOX( "SetWindowLongPtr", HRESULT_FROM_WIN32(dwError) );

	push	1
	push	OFFSET ??_C@_0BB@CBJJKGDE@SetWindowLongPtr?$AA@
	mov	eax, DWORD PTR _dwError$1[ebp]
	push	eax
	call	_HRESULT_FROM_WIN32
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??DXUTSetWindow@@YAJPAUHWND__@@00_N@Z@4JA
	add	ecx, 27					; 0000001bH
	push	ecx
	push	OFFSET ??_C@_0CL@KBAHBIDF@z?3?2sampsrc?202xu1?2saco?2d3d9?2commo@
	call	?DXUTTrace@@YGJPBDKJ0_N@Z		; DXUTTrace
	jmp	$LN9@DXUTSetWin
$LN5@DXUTSetWin:

; 911  :     }
; 912  :  
; 913  :     if( !GetDXUTState().GetDXUTInited() ) 

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetDXUTInited@DXUTState@@QAE_NXZ	; DXUTState::GetDXUTInited
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@DXUTSetWin

; 914  :     {
; 915  :         // If DXUTInit() was already called and failed, then fail.
; 916  :         // DXUTInit() must first succeed for this function to succeed
; 917  :         if( GetDXUTState().GetDXUTInitCalled() )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetDXUTInitCalled@DXUTState@@QAE_NXZ	; DXUTState::GetDXUTInitCalled
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@DXUTSetWin

; 918  :             return E_FAIL; 

	mov	eax, -2147467259			; 80004005H
	jmp	$LN9@DXUTSetWin
$LN2@DXUTSetWin:

; 919  :  
; 920  :         // If DXUTInit() hasn't been called, then automatically call it
; 921  :         // with default params
; 922  :         hr = DXUTInit();

	push	1
	push	1
	push	1
	call	?DXUTInit@@YAJ_N00@Z			; DXUTInit
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _hr$[ebp], eax

; 923  :         if( FAILED(hr) )

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN3@DXUTSetWin

; 924  :             return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	jmp	$LN9@DXUTSetWin
$LN3@DXUTSetWin:

; 925  :     }
; 926  :  
; 927  :     TCHAR* strCachedWindowTitle = GetDXUTState().GetWindowTitle();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetWindowTitle@DXUTState@@QAEPADXZ	; DXUTState::GetWindowTitle
	mov	DWORD PTR _strCachedWindowTitle$[ebp], eax

; 928  :     GetWindowText( hWndFocus, strCachedWindowTitle, 255 );

	mov	esi, esp
	push	255					; 000000ffH
	mov	eax, DWORD PTR _strCachedWindowTitle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hWndFocus$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetWindowTextA@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 929  :     strCachedWindowTitle[255] = 0;

	mov	eax, 1
	imul	ecx, eax, 255
	mov	edx, DWORD PTR _strCachedWindowTitle$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 930  :    
; 931  :     HINSTANCE hInstance = (HINSTANCE) (LONG_PTR) GetWindowLongPtr( hWndFocus, GWLP_HINSTANCE ); 

	mov	esi, esp
	push	-6					; fffffffaH
	mov	eax, DWORD PTR _hWndFocus$[ebp]
	push	eax
	call	DWORD PTR __imp__GetWindowLongA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hInstance$[ebp], eax

; 932  :     GetDXUTState().SetHInstance( hInstance );

	mov	eax, DWORD PTR _hInstance$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetHInstance@DXUTState@@QAEXPAUHINSTANCE__@@@Z ; DXUTState::SetHInstance

; 933  :     GetDXUTState().SetWindowCreatedWithDefaultPositions( false );

	push	0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetWindowCreatedWithDefaultPositions@DXUTState@@QAEX_N@Z ; DXUTState::SetWindowCreatedWithDefaultPositions

; 934  :     GetDXUTState().SetWindowCreated( true );

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetWindowCreated@DXUTState@@QAEX_N@Z	; DXUTState::SetWindowCreated

; 935  :     GetDXUTState().SetHWNDFocus( hWndFocus );

	mov	eax, DWORD PTR _hWndFocus$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetHWNDFocus@DXUTState@@QAEXPAUHWND__@@@Z ; DXUTState::SetHWNDFocus

; 936  :     GetDXUTState().SetHWNDDeviceFullScreen( hWndDeviceFullScreen );

	mov	eax, DWORD PTR _hWndDeviceFullScreen$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetHWNDDeviceFullScreen@DXUTState@@QAEXPAUHWND__@@@Z ; DXUTState::SetHWNDDeviceFullScreen

; 937  :     GetDXUTState().SetHWNDDeviceWindowed( hWndDeviceWindowed );

	mov	eax, DWORD PTR _hWndDeviceWindowed$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetHWNDDeviceWindowed@DXUTState@@QAEXPAUHWND__@@@Z ; DXUTState::SetHWNDDeviceWindowed

; 938  : 
; 939  :     return S_OK;

	xor	eax, eax
$LN9@DXUTSetWin:

; 940  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTSetWindow@@YAJPAUHWND__@@00_N@Z ENDP		; DXUTSetWindow
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTCreateWindow@@YAJPBDPAUHINSTANCE__@@PAUHICON__@@PAUHMENU__@@HH@Z
_TEXT	SEGMENT
tv237 = -633						; size = 1
_dwError$1 = -436					; size = 4
_hWnd$2 = -424						; size = 4
_strCachedWindowTitle$3 = -412				; size = 4
_nDefaultHeight$4 = -400				; size = 4
_nDefaultWidth$5 = -388					; size = 4
_rc$6 = -376						; size = 16
_dwWindowStyle$7 = -352					; size = 4
_dwError$8 = -340					; size = 4
_wndClass$9 = -328					; size = 40
_szExePath$10 = -280					; size = 260
_hr$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_strWindowTitle$ = 8					; size = 4
_hInstance$ = 12					; size = 4
_hIcon$ = 16						; size = 4
_hMenu$ = 20						; size = 4
_x$ = 24						; size = 4
_y$ = 28						; size = 4
?DXUTCreateWindow@@YAJPBDPAUHINSTANCE__@@PAUHICON__@@PAUHMENU__@@HH@Z PROC ; DXUTCreateWindow, COMDAT

; 773  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 636				; 0000027cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-636]
	mov	ecx, 159				; 0000009fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 774  :     HRESULT hr;
; 775  : 
; 776  :     // Not allowed to call this from inside the device callbacks
; 777  :     if( GetDXUTState().GetInsideDeviceCallback() )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetInsideDeviceCallback@DXUTState@@QAE_NXZ ; DXUTState::GetInsideDeviceCallback
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN15@DXUTCreate

; 778  :         return DXUT_ERR_MSGBOX( "DXUTCreateWindow", E_FAIL );

	push	1
	push	OFFSET ??_C@_0BB@LKEDMNKO@DXUTCreateWindow?$AA@
	push	-2147467259				; 80004005H
	mov	eax, DWORD PTR ?__LINE__Var@?1??DXUTCreateWindow@@YAJPBDPAUHINSTANCE__@@PAUHICON__@@PAUHMENU__@@HH@Z@4JA
	add	eax, 5
	push	eax
	push	OFFSET ??_C@_0CL@KBAHBIDF@z?3?2sampsrc?202xu1?2saco?2d3d9?2commo@
	call	?DXUTTrace@@YGJPBDKJ0_N@Z		; DXUTTrace
	jmp	$LN16@DXUTCreate
$LN15@DXUTCreate:

; 779  : 
; 780  :     GetDXUTState().SetWindowCreateCalled( true );

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetWindowCreateCalled@DXUTState@@QAEX_N@Z ; DXUTState::SetWindowCreateCalled

; 781  : 
; 782  :     if( !GetDXUTState().GetDXUTInited() ) 

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetDXUTInited@DXUTState@@QAE_NXZ	; DXUTState::GetDXUTInited
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN14@DXUTCreate

; 783  :     {
; 784  :         // If DXUTInit() was already called and failed, then fail.
; 785  :         // DXUTInit() must first succeed for this function to succeed
; 786  :         if( GetDXUTState().GetDXUTInitCalled() )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetDXUTInitCalled@DXUTState@@QAE_NXZ	; DXUTState::GetDXUTInitCalled
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN13@DXUTCreate

; 787  :             return E_FAIL; 

	mov	eax, -2147467259			; 80004005H
	jmp	$LN16@DXUTCreate
$LN13@DXUTCreate:

; 788  : 
; 789  :         // If DXUTInit() hasn't been called, then automatically call it
; 790  :         // with default params
; 791  :         hr = DXUTInit();

	push	1
	push	1
	push	1
	call	?DXUTInit@@YAJ_N00@Z			; DXUTInit
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _hr$[ebp], eax

; 792  :         if( FAILED(hr) )

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN14@DXUTCreate

; 793  :             return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	jmp	$LN16@DXUTCreate
$LN14@DXUTCreate:

; 794  :     }
; 795  : 
; 796  :     if( DXUTGetHWNDFocus() == NULL )

	call	?DXUTGetHWNDFocus@@YAPAUHWND__@@XZ	; DXUTGetHWNDFocus
	test	eax, eax
	jne	$LN11@DXUTCreate

; 797  :     {
; 798  :         if( hInstance == NULL ) 

	cmp	DWORD PTR _hInstance$[ebp], 0
	jne	SHORT $LN10@DXUTCreate

; 799  :             hInstance = (HINSTANCE)GetModuleHandle(NULL);

	mov	esi, esp
	push	0
	call	DWORD PTR __imp__GetModuleHandleA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hInstance$[ebp], eax
$LN10@DXUTCreate:

; 800  :         GetDXUTState().SetHInstance( hInstance );

	mov	eax, DWORD PTR _hInstance$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetHInstance@DXUTState@@QAEXPAUHINSTANCE__@@@Z ; DXUTState::SetHInstance

; 801  : 
; 802  :         TCHAR szExePath[MAX_PATH];
; 803  :         GetModuleFileName( NULL, szExePath, MAX_PATH );

	mov	esi, esp
	push	260					; 00000104H
	lea	eax, DWORD PTR _szExePath$10[ebp]
	push	eax
	push	0
	call	DWORD PTR __imp__GetModuleFileNameA@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 804  :         if( hIcon == NULL ) // If the icon is NULL, then use the first one found in the exe

	cmp	DWORD PTR _hIcon$[ebp], 0
	jne	SHORT $LN9@DXUTCreate

; 805  :             hIcon = ExtractIcon( hInstance, szExePath, 0 ); 

	mov	esi, esp
	push	0
	lea	eax, DWORD PTR _szExePath$10[ebp]
	push	eax
	mov	ecx, DWORD PTR _hInstance$[ebp]
	push	ecx
	call	DWORD PTR __imp__ExtractIconA@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hIcon$[ebp], eax
$LN9@DXUTCreate:

; 806  : 
; 807  :         // Register the windows class
; 808  :         WNDCLASS wndClass;
; 809  :         wndClass.style = CS_DBLCLKS;

	mov	DWORD PTR _wndClass$9[ebp], 8

; 810  :         wndClass.lpfnWndProc = DXUTStaticWndProc;

	mov	DWORD PTR _wndClass$9[ebp+4], OFFSET ?DXUTStaticWndProc@@YGJPAUHWND__@@IIJ@Z ; DXUTStaticWndProc

; 811  :         wndClass.cbClsExtra = 0;

	mov	DWORD PTR _wndClass$9[ebp+8], 0

; 812  :         wndClass.cbWndExtra = 0;

	mov	DWORD PTR _wndClass$9[ebp+12], 0

; 813  :         wndClass.hInstance = hInstance;

	mov	eax, DWORD PTR _hInstance$[ebp]
	mov	DWORD PTR _wndClass$9[ebp+16], eax

; 814  :         wndClass.hIcon = hIcon;

	mov	eax, DWORD PTR _hIcon$[ebp]
	mov	DWORD PTR _wndClass$9[ebp+20], eax

; 815  :         wndClass.hCursor = LoadCursor( NULL, IDC_ARROW );

	mov	esi, esp
	push	32512					; 00007f00H
	push	0
	call	DWORD PTR __imp__LoadCursorA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _wndClass$9[ebp+24], eax

; 816  :         wndClass.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);

	mov	esi, esp
	push	4
	call	DWORD PTR __imp__GetStockObject@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _wndClass$9[ebp+28], eax

; 817  :         wndClass.lpszMenuName = NULL;

	mov	DWORD PTR _wndClass$9[ebp+32], 0

; 818  :         wndClass.lpszClassName = "Direct3DWindowClass";

	mov	DWORD PTR _wndClass$9[ebp+36], OFFSET ??_C@_0BE@MKMDFNEO@Direct3DWindowClass?$AA@

; 819  : 
; 820  :         if( !RegisterClass( &wndClass ) )

	mov	esi, esp
	lea	eax, DWORD PTR _wndClass$9[ebp]
	push	eax
	call	DWORD PTR __imp__RegisterClassA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	movzx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN8@DXUTCreate

; 821  :         {
; 822  :             DWORD dwError = GetLastError();

	mov	esi, esp
	call	DWORD PTR __imp__GetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _dwError$8[ebp], eax

; 823  :             if( dwError != ERROR_CLASS_ALREADY_EXISTS )

	cmp	DWORD PTR _dwError$8[ebp], 1410		; 00000582H
	je	SHORT $LN8@DXUTCreate

; 824  :                 return DXUT_ERR_MSGBOX( "RegisterClass", HRESULT_FROM_WIN32(dwError) );

	push	1
	push	OFFSET ??_C@_0O@NLFCIADE@RegisterClass?$AA@
	mov	eax, DWORD PTR _dwError$8[ebp]
	push	eax
	call	_HRESULT_FROM_WIN32
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??DXUTCreateWindow@@YAJPBDPAUHINSTANCE__@@PAUHICON__@@PAUHMENU__@@HH@Z@4JA
	add	ecx, 51					; 00000033H
	push	ecx
	push	OFFSET ??_C@_0CL@KBAHBIDF@z?3?2sampsrc?202xu1?2saco?2d3d9?2commo@
	call	?DXUTTrace@@YGJPBDKJ0_N@Z		; DXUTTrace
	jmp	$LN16@DXUTCreate
$LN8@DXUTCreate:

; 825  :         }
; 826  : 
; 827  :         // Set the window's initial style.  It is invisible initially since it might
; 828  :         // be resized later
; 829  :         DWORD dwWindowStyle = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | 
; 830  :                               WS_MINIMIZEBOX | WS_MAXIMIZEBOX;

	mov	DWORD PTR _dwWindowStyle$7[ebp], 13565952 ; 00cf0000H

; 831  :         
; 832  :         RECT rc;
; 833  : 
; 834  :         // Override the window's initial & size position if there were cmd line args
; 835  :         if( GetDXUTState().GetOverrideStartX() != -1 )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetOverrideStartX@DXUTState@@QAEHXZ	; DXUTState::GetOverrideStartX
	cmp	eax, -1
	je	SHORT $LN6@DXUTCreate

; 836  :             x = GetDXUTState().GetOverrideStartX();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetOverrideStartX@DXUTState@@QAEHXZ	; DXUTState::GetOverrideStartX
	mov	DWORD PTR _x$[ebp], eax
$LN6@DXUTCreate:

; 837  :         if( GetDXUTState().GetOverrideStartY() != -1 )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetOverrideStartY@DXUTState@@QAEHXZ	; DXUTState::GetOverrideStartY
	cmp	eax, -1
	je	SHORT $LN5@DXUTCreate

; 838  :             y = GetDXUTState().GetOverrideStartY();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetOverrideStartY@DXUTState@@QAEHXZ	; DXUTState::GetOverrideStartY
	mov	DWORD PTR _y$[ebp], eax
$LN5@DXUTCreate:

; 839  : 
; 840  :         GetDXUTState().SetWindowCreatedWithDefaultPositions( false );

	push	0
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetWindowCreatedWithDefaultPositions@DXUTState@@QAEX_N@Z ; DXUTState::SetWindowCreatedWithDefaultPositions

; 841  :         if( x == CW_USEDEFAULT && y == CW_USEDEFAULT )

	cmp	DWORD PTR _x$[ebp], -2147483648		; 80000000H
	jne	SHORT $LN4@DXUTCreate
	cmp	DWORD PTR _y$[ebp], -2147483648		; 80000000H
	jne	SHORT $LN4@DXUTCreate

; 842  :             GetDXUTState().SetWindowCreatedWithDefaultPositions( true );

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetWindowCreatedWithDefaultPositions@DXUTState@@QAEX_N@Z ; DXUTState::SetWindowCreatedWithDefaultPositions
$LN4@DXUTCreate:

; 843  : 
; 844  :         // Find the window's initial size, but it might be changed later
; 845  :         int nDefaultWidth = 640;

	mov	DWORD PTR _nDefaultWidth$5[ebp], 640	; 00000280H

; 846  :         int nDefaultHeight = 480;

	mov	DWORD PTR _nDefaultHeight$4[ebp], 480	; 000001e0H

; 847  :         if( GetDXUTState().GetOverrideWidth() != 0 )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetOverrideWidth@DXUTState@@QAEHXZ	; DXUTState::GetOverrideWidth
	test	eax, eax
	je	SHORT $LN3@DXUTCreate

; 848  :             nDefaultWidth = GetDXUTState().GetOverrideWidth();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetOverrideWidth@DXUTState@@QAEHXZ	; DXUTState::GetOverrideWidth
	mov	DWORD PTR _nDefaultWidth$5[ebp], eax
$LN3@DXUTCreate:

; 849  :         if( GetDXUTState().GetOverrideHeight() != 0 )

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetOverrideHeight@DXUTState@@QAEHXZ	; DXUTState::GetOverrideHeight
	test	eax, eax
	je	SHORT $LN2@DXUTCreate

; 850  :             nDefaultHeight = GetDXUTState().GetOverrideHeight();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetOverrideHeight@DXUTState@@QAEHXZ	; DXUTState::GetOverrideHeight
	mov	DWORD PTR _nDefaultHeight$4[ebp], eax
$LN2@DXUTCreate:

; 851  :         SetRect( &rc, 0, 0, nDefaultWidth, nDefaultHeight );        

	mov	esi, esp
	mov	eax, DWORD PTR _nDefaultHeight$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _nDefaultWidth$5[ebp]
	push	ecx
	push	0
	push	0
	lea	edx, DWORD PTR _rc$6[ebp]
	push	edx
	call	DWORD PTR __imp__SetRect@20
	cmp	esi, esp
	call	__RTC_CheckEsp

; 852  :         AdjustWindowRect( &rc, dwWindowStyle, ( hMenu != NULL ) ? true : false );

	cmp	DWORD PTR _hMenu$[ebp], 0
	je	SHORT $LN18@DXUTCreate
	mov	BYTE PTR tv237[ebp], 1
	jmp	SHORT $LN19@DXUTCreate
$LN18@DXUTCreate:
	mov	BYTE PTR tv237[ebp], 0
$LN19@DXUTCreate:
	movzx	eax, BYTE PTR tv237[ebp]
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _dwWindowStyle$7[ebp]
	push	ecx
	lea	edx, DWORD PTR _rc$6[ebp]
	push	edx
	call	DWORD PTR __imp__AdjustWindowRect@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 853  : 
; 854  :         TCHAR* strCachedWindowTitle = GetDXUTState().GetWindowTitle();

	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?GetWindowTitle@DXUTState@@QAEPADXZ	; DXUTState::GetWindowTitle
	mov	DWORD PTR _strCachedWindowTitle$3[ebp], eax

; 855  :         StringCchCopy( strCachedWindowTitle, 256, strWindowTitle );

	mov	eax, DWORD PTR _strWindowTitle$[ebp]
	push	eax
	push	256					; 00000100H
	mov	ecx, DWORD PTR _strCachedWindowTitle$3[ebp]
	push	ecx
	call	?StringCchCopyA@@YGJPADIPBD@Z		; StringCchCopyA

; 856  : 
; 857  :         // Create the render window
; 858  :         HWND hWnd = CreateWindow( "Direct3DWindowClass", strWindowTitle, dwWindowStyle,
; 859  :                                x, y, (rc.right-rc.left), (rc.bottom-rc.top), 0,
; 860  :                                hMenu, hInstance, 0 );

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR _hInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hMenu$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _rc$6[ebp+12]
	sub	edx, DWORD PTR _rc$6[ebp+4]
	push	edx
	mov	eax, DWORD PTR _rc$6[ebp+8]
	sub	eax, DWORD PTR _rc$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	eax, DWORD PTR _dwWindowStyle$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _strWindowTitle$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BE@MKMDFNEO@Direct3DWindowClass?$AA@
	push	0
	call	DWORD PTR __imp__CreateWindowExA@48
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hWnd$2[ebp], eax

; 861  :         if( hWnd == NULL )

	cmp	DWORD PTR _hWnd$2[ebp], 0
	jne	SHORT $LN1@DXUTCreate

; 862  :         {
; 863  :             DWORD dwError = GetLastError();

	mov	esi, esp
	call	DWORD PTR __imp__GetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _dwError$1[ebp], eax

; 864  :             return DXUT_ERR_MSGBOX( "CreateWindow", HRESULT_FROM_WIN32(dwError) );

	push	1
	push	OFFSET ??_C@_0N@GKGFHBLO@CreateWindow?$AA@
	mov	eax, DWORD PTR _dwError$1[ebp]
	push	eax
	call	_HRESULT_FROM_WIN32
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR ?__LINE__Var@?1??DXUTCreateWindow@@YAJPBDPAUHINSTANCE__@@PAUHICON__@@PAUHMENU__@@HH@Z@4JA
	add	ecx, 91					; 0000005bH
	push	ecx
	push	OFFSET ??_C@_0CL@KBAHBIDF@z?3?2sampsrc?202xu1?2saco?2d3d9?2commo@
	call	?DXUTTrace@@YGJPBDKJ0_N@Z		; DXUTTrace
	jmp	SHORT $LN16@DXUTCreate
$LN1@DXUTCreate:

; 865  :         }
; 866  : 
; 867  :         GetDXUTState().SetWindowCreated( true );

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetWindowCreated@DXUTState@@QAEX_N@Z	; DXUTState::SetWindowCreated

; 868  :         GetDXUTState().SetHWNDFocus( hWnd );

	mov	eax, DWORD PTR _hWnd$2[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetHWNDFocus@DXUTState@@QAEXPAUHWND__@@@Z ; DXUTState::SetHWNDFocus

; 869  :         GetDXUTState().SetHWNDDeviceFullScreen( hWnd );

	mov	eax, DWORD PTR _hWnd$2[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetHWNDDeviceFullScreen@DXUTState@@QAEXPAUHWND__@@@Z ; DXUTState::SetHWNDDeviceFullScreen

; 870  :         GetDXUTState().SetHWNDDeviceWindowed( hWnd );

	mov	eax, DWORD PTR _hWnd$2[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetHWNDDeviceWindowed@DXUTState@@QAEXPAUHWND__@@@Z ; DXUTState::SetHWNDDeviceWindowed
$LN11@DXUTCreate:

; 871  :     }
; 872  : 
; 873  :     return S_OK;

	xor	eax, eax
$LN16@DXUTCreate:

; 874  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN24@DXUTCreate
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 636				; 0000027cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN24@DXUTCreate:
	DD	3
	DD	$LN23@DXUTCreate
$LN23@DXUTCreate:
	DD	-280					; fffffee8H
	DD	260					; 00000104H
	DD	$LN20@DXUTCreate
	DD	-328					; fffffeb8H
	DD	40					; 00000028H
	DD	$LN21@DXUTCreate
	DD	-376					; fffffe88H
	DD	16					; 00000010H
	DD	$LN22@DXUTCreate
$LN22@DXUTCreate:
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	0
$LN21@DXUTCreate:
	DB	119					; 00000077H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	67					; 00000043H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	115					; 00000073H
	DB	0
$LN20@DXUTCreate:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	101					; 00000065H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
?DXUTCreateWindow@@YAJPBDPAUHINSTANCE__@@PAUHICON__@@PAUHMENU__@@HH@Z ENDP ; DXUTCreateWindow
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTInit@@YAJ_N00@Z
_TEXT	SEGMENT
_pD3D$ = -372						; size = 4
_pTimeBeginPeriod$1 = -360				; size = 4
_hInstWinMM$2 = -348					; size = 4
_wszPath$ = -336					; size = 261
_fk$ = -64						; size = 24
_tk$ = -32						; size = 8
_sk$ = -16						; size = 8
__$ArrayPad$ = -4					; size = 4
_bParseCommandLine$ = 8					; size = 1
_bHandleDefaultHotkeys$ = 12				; size = 1
_bShowMsgBoxOnError$ = 16				; size = 1
?DXUTInit@@YAJ_N00@Z PROC				; DXUTInit, COMDAT

; 449  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 568				; 00000238H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-568]
	mov	ecx, 142				; 0000008eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 450  :     GetDXUTState().SetDXUTInitCalled( true );

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetDXUTInitCalled@DXUTState@@QAEX_N@Z	; DXUTState::SetDXUTInitCalled

; 451  : 
; 452  :     // Not always needed, but lets the app create GDI dialogs
; 453  :     InitCommonControls();

	mov	esi, esp
	call	DWORD PTR __imp__InitCommonControls@0
	cmp	esi, esp
	call	__RTC_CheckEsp

; 454  : 
; 455  :     // Save the current sticky/toggle/filter key settings so DXUT can restore them later
; 456  :     STICKYKEYS sk = {sizeof(STICKYKEYS), 0};

	mov	DWORD PTR _sk$[ebp], 8
	mov	DWORD PTR _sk$[ebp+4], 0

; 457  :     SystemParametersInfo(SPI_GETSTICKYKEYS, sizeof(STICKYKEYS), &sk, 0);

	mov	esi, esp
	push	0
	lea	eax, DWORD PTR _sk$[ebp]
	push	eax
	push	8
	push	58					; 0000003aH
	call	DWORD PTR __imp__SystemParametersInfoA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 458  :     GetDXUTState().SetStartupStickyKeys( sk );

	mov	eax, DWORD PTR _sk$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _sk$[ebp]
	push	ecx
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetStartupStickyKeys@DXUTState@@QAEXUtagSTICKYKEYS@@@Z ; DXUTState::SetStartupStickyKeys

; 459  : 
; 460  :     TOGGLEKEYS tk = {sizeof(TOGGLEKEYS), 0};

	mov	DWORD PTR _tk$[ebp], 8
	mov	DWORD PTR _tk$[ebp+4], 0

; 461  :     SystemParametersInfo(SPI_GETTOGGLEKEYS, sizeof(TOGGLEKEYS), &tk, 0);

	mov	esi, esp
	push	0
	lea	eax, DWORD PTR _tk$[ebp]
	push	eax
	push	8
	push	52					; 00000034H
	call	DWORD PTR __imp__SystemParametersInfoA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 462  :     GetDXUTState().SetStartupToggleKeys( tk );

	mov	eax, DWORD PTR _tk$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _tk$[ebp]
	push	ecx
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetStartupToggleKeys@DXUTState@@QAEXUtagTOGGLEKEYS@@@Z ; DXUTState::SetStartupToggleKeys

; 463  : 
; 464  :     FILTERKEYS fk = {sizeof(FILTERKEYS), 0};

	mov	DWORD PTR _fk$[ebp], 24			; 00000018H
	mov	DWORD PTR _fk$[ebp+4], 0
	xor	eax, eax
	mov	DWORD PTR _fk$[ebp+8], eax
	mov	DWORD PTR _fk$[ebp+12], eax
	mov	DWORD PTR _fk$[ebp+16], eax
	mov	DWORD PTR _fk$[ebp+20], eax

; 465  :     SystemParametersInfo(SPI_GETFILTERKEYS, sizeof(FILTERKEYS), &fk, 0);

	mov	esi, esp
	push	0
	lea	eax, DWORD PTR _fk$[ebp]
	push	eax
	push	24					; 00000018H
	push	50					; 00000032H
	call	DWORD PTR __imp__SystemParametersInfoA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 466  :     GetDXUTState().SetStartupFilterKeys( fk );

	sub	esp, 24					; 00000018H
	mov	eax, esp
	mov	ecx, DWORD PTR _fk$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _fk$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _fk$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _fk$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _fk$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR _fk$[ebp+20]
	mov	DWORD PTR [eax+20], edx
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetStartupFilterKeys@DXUTState@@QAEXUtagFILTERKEYS@@@Z ; DXUTState::SetStartupFilterKeys

; 467  : 
; 468  :     // Increase the accuracy of Sleep() without needing to link to winmm.lib
; 469  :     TCHAR wszPath[MAX_PATH+1];
; 470  :     if( GetSystemDirectory( wszPath, MAX_PATH+1 ) )

	mov	esi, esp
	push	261					; 00000105H
	lea	eax, DWORD PTR _wszPath$[ebp]
	push	eax
	call	DWORD PTR __imp__GetSystemDirectoryA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	$LN7@DXUTInit

; 471  :     {
; 472  :         StringCchCat( wszPath, MAX_PATH, "\\winmm.dll" );

	push	OFFSET ??_C@_0L@NLNDMMBI@?2winmm?4dll?$AA@
	push	260					; 00000104H
	lea	eax, DWORD PTR _wszPath$[ebp]
	push	eax
	call	?StringCchCatA@@YGJPADIPBD@Z		; StringCchCatA

; 473  :         HINSTANCE hInstWinMM = LoadLibrary( wszPath );

	mov	esi, esp
	lea	eax, DWORD PTR _wszPath$[ebp]
	push	eax
	call	DWORD PTR __imp__LoadLibraryA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hInstWinMM$2[ebp], eax

; 474  :         if( hInstWinMM ) 

	cmp	DWORD PTR _hInstWinMM$2[ebp], 0
	je	SHORT $LN7@DXUTInit

; 475  :         {
; 476  :             LPTIMEBEGINPERIOD pTimeBeginPeriod = (LPTIMEBEGINPERIOD)GetProcAddress( hInstWinMM, "timeBeginPeriod" );

	mov	esi, esp
	push	OFFSET ??_C@_0BA@DCPFICL@timeBeginPeriod?$AA@
	mov	eax, DWORD PTR _hInstWinMM$2[ebp]
	push	eax
	call	DWORD PTR __imp__GetProcAddress@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pTimeBeginPeriod$1[ebp], eax

; 477  :             if( NULL != pTimeBeginPeriod )

	cmp	DWORD PTR _pTimeBeginPeriod$1[ebp], 0
	je	SHORT $LN5@DXUTInit

; 478  :                 pTimeBeginPeriod(1);

	mov	esi, esp
	push	1
	call	DWORD PTR _pTimeBeginPeriod$1[ebp]
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@DXUTInit:

; 479  : 
; 480  :             FreeLibrary(hInstWinMM);

	mov	esi, esp
	mov	eax, DWORD PTR _hInstWinMM$2[ebp]
	push	eax
	call	DWORD PTR __imp__FreeLibrary@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@DXUTInit:

; 481  :         }
; 482  :     }
; 483  : 
; 484  :     GetDXUTState().SetShowMsgBoxOnError( bShowMsgBoxOnError );

	movzx	eax, BYTE PTR _bShowMsgBoxOnError$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetShowMsgBoxOnError@DXUTState@@QAEX_N@Z ; DXUTState::SetShowMsgBoxOnError

; 485  :     GetDXUTState().SetHandleDefaultHotkeys( bHandleDefaultHotkeys );

	movzx	eax, BYTE PTR _bHandleDefaultHotkeys$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetHandleDefaultHotkeys@DXUTState@@QAEX_N@Z ; DXUTState::SetHandleDefaultHotkeys

; 486  : 
; 487  :     if( bParseCommandLine )

	movzx	eax, BYTE PTR _bParseCommandLine$[ebp]
	test	eax, eax
	je	SHORT $LN4@DXUTInit

; 488  :         DXUTParseCommandLine();

	call	?DXUTParseCommandLine@@YAXXZ		; DXUTParseCommandLine
$LN4@DXUTInit:

; 489  : 
; 490  :     // Verify D3DX version
; 491  :     if( !D3DXCheckVersion( D3D_SDK_VERSION, D3DX_SDK_VERSION ) )

	push	25					; 00000019H
	push	-2147483616				; 80000020H
	call	_D3DXCheckVersion@8
	test	eax, eax
	jne	SHORT $LN3@DXUTInit

; 492  :     {
; 493  :         DXUTDisplayErrorMessage( DXUTERR_INCORRECTVERSION );

	push	-2147219191				; 80040909H
	call	?DXUTDisplayErrorMessage@@YAXJ@Z	; DXUTDisplayErrorMessage
	add	esp, 4

; 494  :         return DXUT_ERR( "D3DXCheckVersion", DXUTERR_INCORRECTVERSION );

	push	0
	push	OFFSET ??_C@_0BB@DDKDNGFF@D3DXCheckVersion?$AA@
	push	-2147219191				; 80040909H
	mov	eax, DWORD PTR ?__LINE__Var@?1??DXUTInit@@YAJ_N00@Z@4JA
	add	eax, 45					; 0000002dH
	push	eax
	push	OFFSET ??_C@_0CL@KBAHBIDF@z?3?2sampsrc?202xu1?2saco?2d3d9?2commo@
	call	?DXUTTrace@@YGJPBDKJ0_N@Z		; DXUTTrace
	jmp	$LN8@DXUTInit
$LN3@DXUTInit:

; 495  :     }
; 496  : 
; 497  :     // Create a Direct3D object if one has not already been created
; 498  :     IDirect3D9* pD3D = DXUTGetD3DObject();

	call	?DXUTGetD3DObject@@YAPAUIDirect3D9@@XZ	; DXUTGetD3DObject
	mov	DWORD PTR _pD3D$[ebp], eax

; 499  :     if( pD3D == NULL )

	cmp	DWORD PTR _pD3D$[ebp], 0
	jne	SHORT $LN2@DXUTInit

; 500  :     {
; 501  :         // This may fail if DirectX 9 isn't installed
; 502  :         // This may fail if the DirectX headers are out of sync with the installed DirectX DLLs
; 503  :         pD3D = DXUT_Dynamic_Direct3DCreate9( D3D_SDK_VERSION );

	push	-2147483616				; 80000020H
	call	?DXUT_Dynamic_Direct3DCreate9@@YGPAUIDirect3D9@@I@Z ; DXUT_Dynamic_Direct3DCreate9
	mov	DWORD PTR _pD3D$[ebp], eax

; 504  :         GetDXUTState().SetD3D( pD3D );

	mov	eax, DWORD PTR _pD3D$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetD3D@DXUTState@@QAEXPAUIDirect3D9@@@Z ; DXUTState::SetD3D
$LN2@DXUTInit:

; 505  :     }
; 506  : 
; 507  :     if( pD3D == NULL )

	cmp	DWORD PTR _pD3D$[ebp], 0
	jne	SHORT $LN1@DXUTInit

; 508  :     {
; 509  :         // If still NULL, then something went wrong
; 510  :         DXUTDisplayErrorMessage( DXUTERR_NODIRECT3D );

	push	-2147219199				; 80040901H
	call	?DXUTDisplayErrorMessage@@YAXJ@Z	; DXUTDisplayErrorMessage
	add	esp, 4

; 511  :         return DXUT_ERR( "Direct3DCreate9", DXUTERR_NODIRECT3D );

	push	0
	push	OFFSET ??_C@_0BA@FAFMMBOF@Direct3DCreate9?$AA@
	push	-2147219199				; 80040901H
	mov	eax, DWORD PTR ?__LINE__Var@?1??DXUTInit@@YAJ_N00@Z@4JA
	add	eax, 62					; 0000003eH
	push	eax
	push	OFFSET ??_C@_0CL@KBAHBIDF@z?3?2sampsrc?202xu1?2saco?2d3d9?2commo@
	call	?DXUTTrace@@YGJPBDKJ0_N@Z		; DXUTTrace
	jmp	SHORT $LN8@DXUTInit
$LN1@DXUTInit:

; 512  :     }
; 513  : 
; 514  :     // Reset the timer
; 515  :     DXUTGetGlobalTimer()->Reset();

	call	?DXUTGetGlobalTimer@@YAPAVCDXUTTimer@@XZ ; DXUTGetGlobalTimer
	mov	ecx, eax
	call	?Reset@CDXUTTimer@@QAEXXZ		; CDXUTTimer::Reset

; 516  : 
; 517  :     GetDXUTState().SetDXUTInited( true );

	push	1
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetDXUTInited@DXUTState@@QAEX_N@Z	; DXUTState::SetDXUTInited

; 518  : 
; 519  :     return S_OK;

	xor	eax, eax
$LN8@DXUTInit:

; 520  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN15@DXUTInit
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 568				; 00000238H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@DXUTInit:
	DD	4
	DD	$LN14@DXUTInit
$LN14@DXUTInit:
	DD	-16					; fffffff0H
	DD	8
	DD	$LN10@DXUTInit
	DD	-32					; ffffffe0H
	DD	8
	DD	$LN11@DXUTInit
	DD	-64					; ffffffc0H
	DD	24					; 00000018H
	DD	$LN12@DXUTInit
	DD	-336					; fffffeb0H
	DD	261					; 00000105H
	DD	$LN13@DXUTInit
$LN13@DXUTInit:
	DB	119					; 00000077H
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$LN12@DXUTInit:
	DB	102					; 00000066H
	DB	107					; 0000006bH
	DB	0
$LN11@DXUTInit:
	DB	116					; 00000074H
	DB	107					; 0000006bH
	DB	0
$LN10@DXUTInit:
	DB	115					; 00000073H
	DB	107					; 0000006bH
	DB	0
?DXUTInit@@YAJ_N00@Z ENDP				; DXUTInit
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTSetCallbackMsgProc@@YAXP6GJPAUHWND__@@IIJPA_NPAX@Z2@Z
_TEXT	SEGMENT
_pCallbackMsgProc$ = 8					; size = 4
_pUserContext$ = 12					; size = 4
?DXUTSetCallbackMsgProc@@YAXP6GJPAUHWND__@@IIJPA_NPAX@Z2@Z PROC ; DXUTSetCallbackMsgProc, COMDAT

; 415  : void DXUTSetCallbackMsgProc( LPDXUTCALLBACKMSGPROC pCallbackMsgProc, void* pUserContext )                   { GetDXUTState().SetWindowMsgFunc( pCallbackMsgProc );  GetDXUTState().SetWindowMsgFuncUserContext( pUserContext ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _pCallbackMsgProc$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetWindowMsgFunc@DXUTState@@QAEXP6GJPAUHWND__@@IIJPA_NPAX@Z@Z ; DXUTState::SetWindowMsgFunc
	mov	eax, DWORD PTR _pUserContext$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetWindowMsgFuncUserContext@DXUTState@@QAEXPAX@Z ; DXUTState::SetWindowMsgFuncUserContext
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTSetCallbackMsgProc@@YAXP6GJPAUHWND__@@IIJPA_NPAX@Z2@Z ENDP ; DXUTSetCallbackMsgProc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTSetCallbackMouse@@YAXP6GX_N0000HHHPAX@Z01@Z
_TEXT	SEGMENT
_pCallbackMouse$ = 8					; size = 4
_bIncludeMouseMove$ = 12				; size = 1
_pUserContext$ = 16					; size = 4
?DXUTSetCallbackMouse@@YAXP6GX_N0000HHHPAX@Z01@Z PROC	; DXUTSetCallbackMouse, COMDAT

; 414  : void DXUTSetCallbackMouse( LPDXUTCALLBACKMOUSE pCallbackMouse, bool bIncludeMouseMove, void* pUserContext ) { GetDXUTState().SetMouseFunc( pCallbackMouse ); GetDXUTState().SetNotifyOnMouseMove( bIncludeMouseMove );  GetDXUTState().SetMouseFuncUserContext( pUserContext ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _pCallbackMouse$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetMouseFunc@DXUTState@@QAEXP6GX_N0000HHHPAX@Z@Z ; DXUTState::SetMouseFunc
	movzx	eax, BYTE PTR _bIncludeMouseMove$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetNotifyOnMouseMove@DXUTState@@QAEX_N@Z ; DXUTState::SetNotifyOnMouseMove
	mov	eax, DWORD PTR _pUserContext$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetMouseFuncUserContext@DXUTState@@QAEXPAX@Z ; DXUTState::SetMouseFuncUserContext
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTSetCallbackMouse@@YAXP6GX_N0000HHHPAX@Z01@Z ENDP	; DXUTSetCallbackMouse
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTSetCallbackKeyboard@@YAXP6GXI_N0PAX@Z1@Z
_TEXT	SEGMENT
_pCallbackKeyboard$ = 8					; size = 4
_pUserContext$ = 12					; size = 4
?DXUTSetCallbackKeyboard@@YAXP6GXI_N0PAX@Z1@Z PROC	; DXUTSetCallbackKeyboard, COMDAT

; 413  : void DXUTSetCallbackKeyboard( LPDXUTCALLBACKKEYBOARD pCallbackKeyboard, void* pUserContext )                { GetDXUTState().SetKeyboardFunc( pCallbackKeyboard );  GetDXUTState().SetKeyboardFuncUserContext( pUserContext ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _pCallbackKeyboard$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetKeyboardFunc@DXUTState@@QAEXP6GXI_N0PAX@Z@Z ; DXUTState::SetKeyboardFunc
	mov	eax, DWORD PTR _pUserContext$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetKeyboardFuncUserContext@DXUTState@@QAEXPAX@Z ; DXUTState::SetKeyboardFuncUserContext
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTSetCallbackKeyboard@@YAXP6GXI_N0PAX@Z1@Z ENDP	; DXUTSetCallbackKeyboard
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTSetCallbackFrameRender@@YAXP6GXPAUIDirect3DDevice9@@NMPAX@Z1@Z
_TEXT	SEGMENT
_pCallbackFrameRender$ = 8				; size = 4
_pUserContext$ = 12					; size = 4
?DXUTSetCallbackFrameRender@@YAXP6GXPAUIDirect3DDevice9@@NMPAX@Z1@Z PROC ; DXUTSetCallbackFrameRender, COMDAT

; 412  : void DXUTSetCallbackFrameRender( LPDXUTCALLBACKFRAMERENDER pCallbackFrameRender, void* pUserContext )       { GetDXUTState().SetFrameRenderFunc( pCallbackFrameRender );  GetDXUTState().SetFrameRenderFuncUserContext( pUserContext ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _pCallbackFrameRender$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetFrameRenderFunc@DXUTState@@QAEXP6GXPAUIDirect3DDevice9@@NMPAX@Z@Z ; DXUTState::SetFrameRenderFunc
	mov	eax, DWORD PTR _pUserContext$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetFrameRenderFuncUserContext@DXUTState@@QAEXPAX@Z ; DXUTState::SetFrameRenderFuncUserContext
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTSetCallbackFrameRender@@YAXP6GXPAUIDirect3DDevice9@@NMPAX@Z1@Z ENDP ; DXUTSetCallbackFrameRender
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTSetCallbackFrameMove@@YAXP6GXPAUIDirect3DDevice9@@NMPAX@Z1@Z
_TEXT	SEGMENT
_pCallbackFrameMove$ = 8				; size = 4
_pUserContext$ = 12					; size = 4
?DXUTSetCallbackFrameMove@@YAXP6GXPAUIDirect3DDevice9@@NMPAX@Z1@Z PROC ; DXUTSetCallbackFrameMove, COMDAT

; 411  : void DXUTSetCallbackFrameMove( LPDXUTCALLBACKFRAMEMOVE pCallbackFrameMove, void* pUserContext ) { GetDXUTState().SetFrameMoveFunc( pCallbackFrameMove );  GetDXUTState().SetFrameMoveFuncUserContext( pUserContext ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _pCallbackFrameMove$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetFrameMoveFunc@DXUTState@@QAEXP6GXPAUIDirect3DDevice9@@NMPAX@Z@Z ; DXUTState::SetFrameMoveFunc
	mov	eax, DWORD PTR _pUserContext$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetFrameMoveFuncUserContext@DXUTState@@QAEXPAX@Z ; DXUTState::SetFrameMoveFuncUserContext
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTSetCallbackFrameMove@@YAXP6GXPAUIDirect3DDevice9@@NMPAX@Z1@Z ENDP ; DXUTSetCallbackFrameMove
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTSetCallbackDeviceChanging@@YAXP6G_NPAUDXUTDeviceSettings@@PBU_D3DCAPS9@@PAX@Z2@Z
_TEXT	SEGMENT
_pCallbackModifyDeviceSettings$ = 8			; size = 4
_pUserContext$ = 12					; size = 4
?DXUTSetCallbackDeviceChanging@@YAXP6G_NPAUDXUTDeviceSettings@@PBU_D3DCAPS9@@PAX@Z2@Z PROC ; DXUTSetCallbackDeviceChanging, COMDAT

; 410  : void DXUTSetCallbackDeviceChanging( LPDXUTCALLBACKMODIFYDEVICESETTINGS pCallbackModifyDeviceSettings, void* pUserContext ) { GetDXUTState().SetModifyDeviceSettingsFunc( pCallbackModifyDeviceSettings );  GetDXUTState().SetModifyDeviceSettingsFuncUserContext( pUserContext ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _pCallbackModifyDeviceSettings$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetModifyDeviceSettingsFunc@DXUTState@@QAEXP6G_NPAUDXUTDeviceSettings@@PBU_D3DCAPS9@@PAX@Z@Z ; DXUTState::SetModifyDeviceSettingsFunc
	mov	eax, DWORD PTR _pUserContext$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetModifyDeviceSettingsFuncUserContext@DXUTState@@QAEXPAX@Z ; DXUTState::SetModifyDeviceSettingsFuncUserContext
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTSetCallbackDeviceChanging@@YAXP6G_NPAUDXUTDeviceSettings@@PBU_D3DCAPS9@@PAX@Z2@Z ENDP ; DXUTSetCallbackDeviceChanging
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTSetCallbackDeviceDestroyed@@YAXP6GXPAX@Z0@Z
_TEXT	SEGMENT
_pCallbackDeviceDestroyed$ = 8				; size = 4
_pUserContext$ = 12					; size = 4
?DXUTSetCallbackDeviceDestroyed@@YAXP6GXPAX@Z0@Z PROC	; DXUTSetCallbackDeviceDestroyed, COMDAT

; 409  : void DXUTSetCallbackDeviceDestroyed( LPDXUTCALLBACKDEVICEDESTROYED pCallbackDeviceDestroyed, void* pUserContext ) { GetDXUTState().SetDeviceDestroyedFunc( pCallbackDeviceDestroyed );  GetDXUTState().SetDeviceDestroyedFuncUserContext( pUserContext ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _pCallbackDeviceDestroyed$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetDeviceDestroyedFunc@DXUTState@@QAEXP6GXPAX@Z@Z ; DXUTState::SetDeviceDestroyedFunc
	mov	eax, DWORD PTR _pUserContext$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetDeviceDestroyedFuncUserContext@DXUTState@@QAEXPAX@Z ; DXUTState::SetDeviceDestroyedFuncUserContext
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTSetCallbackDeviceDestroyed@@YAXP6GXPAX@Z0@Z ENDP	; DXUTSetCallbackDeviceDestroyed
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTSetCallbackDeviceLost@@YAXP6GXPAX@Z0@Z
_TEXT	SEGMENT
_pCallbackDeviceLost$ = 8				; size = 4
_pUserContext$ = 12					; size = 4
?DXUTSetCallbackDeviceLost@@YAXP6GXPAX@Z0@Z PROC	; DXUTSetCallbackDeviceLost, COMDAT

; 408  : void DXUTSetCallbackDeviceLost( LPDXUTCALLBACKDEVICELOST pCallbackDeviceLost, void* pUserContext )          { GetDXUTState().SetDeviceLostFunc( pCallbackDeviceLost );  GetDXUTState().SetDeviceLostFuncUserContext( pUserContext ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _pCallbackDeviceLost$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetDeviceLostFunc@DXUTState@@QAEXP6GXPAX@Z@Z ; DXUTState::SetDeviceLostFunc
	mov	eax, DWORD PTR _pUserContext$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetDeviceLostFuncUserContext@DXUTState@@QAEXPAX@Z ; DXUTState::SetDeviceLostFuncUserContext
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTSetCallbackDeviceLost@@YAXP6GXPAX@Z0@Z ENDP	; DXUTSetCallbackDeviceLost
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTSetCallbackDeviceReset@@YAXP6GJPAUIDirect3DDevice9@@PBU_D3DSURFACE_DESC@@PAX@Z2@Z
_TEXT	SEGMENT
_pCallbackDeviceReset$ = 8				; size = 4
_pUserContext$ = 12					; size = 4
?DXUTSetCallbackDeviceReset@@YAXP6GJPAUIDirect3DDevice9@@PBU_D3DSURFACE_DESC@@PAX@Z2@Z PROC ; DXUTSetCallbackDeviceReset, COMDAT

; 407  : void DXUTSetCallbackDeviceReset( LPDXUTCALLBACKDEVICERESET pCallbackDeviceReset, void* pUserContext )       { GetDXUTState().SetDeviceResetFunc( pCallbackDeviceReset );  GetDXUTState().SetDeviceResetFuncUserContext( pUserContext ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _pCallbackDeviceReset$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetDeviceResetFunc@DXUTState@@QAEXP6GJPAUIDirect3DDevice9@@PBU_D3DSURFACE_DESC@@PAX@Z@Z ; DXUTState::SetDeviceResetFunc
	mov	eax, DWORD PTR _pUserContext$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetDeviceResetFuncUserContext@DXUTState@@QAEXPAX@Z ; DXUTState::SetDeviceResetFuncUserContext
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTSetCallbackDeviceReset@@YAXP6GJPAUIDirect3DDevice9@@PBU_D3DSURFACE_DESC@@PAX@Z2@Z ENDP ; DXUTSetCallbackDeviceReset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\common\dxut.cpp
;	COMDAT ?DXUTSetCallbackDeviceCreated@@YAXP6GJPAUIDirect3DDevice9@@PBU_D3DSURFACE_DESC@@PAX@Z2@Z
_TEXT	SEGMENT
_pCallbackDeviceCreated$ = 8				; size = 4
_pUserContext$ = 12					; size = 4
?DXUTSetCallbackDeviceCreated@@YAXP6GJPAUIDirect3DDevice9@@PBU_D3DSURFACE_DESC@@PAX@Z2@Z PROC ; DXUTSetCallbackDeviceCreated, COMDAT

; 406  : void DXUTSetCallbackDeviceCreated( LPDXUTCALLBACKDEVICECREATED pCallbackDeviceCreated, void* pUserContext ) { GetDXUTState().SetDeviceCreatedFunc( pCallbackDeviceCreated ); GetDXUTState().SetDeviceCreatedFuncUserContext( pUserContext ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR _pCallbackDeviceCreated$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetDeviceCreatedFunc@DXUTState@@QAEXP6GJPAUIDirect3DDevice9@@PBU_D3DSURFACE_DESC@@PAX@Z@Z ; DXUTState::SetDeviceCreatedFunc
	mov	eax, DWORD PTR _pUserContext$[ebp]
	push	eax
	call	?GetDXUTState@@YAAAVDXUTState@@XZ	; GetDXUTState
	mov	ecx, eax
	call	?SetDeviceCreatedFuncUserContext@DXUTState@@QAEXPAX@Z ; DXUTState::SetDeviceCreatedFuncUserContext
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DXUTSetCallbackDeviceCreated@@YAXP6GJPAUIDirect3DDevice9@@PBU_D3DSURFACE_DESC@@PAX@Z2@Z ENDP ; DXUTSetCallbackDeviceCreated
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\include\strsafe.h
;	COMDAT ?StringCchPrintfA@@YAJPADIPBDZZ
_TEXT	SEGMENT
_argList$1 = -20					; size = 4
_hr$ = -8						; size = 4
_pszDest$ = 8						; size = 4
_cchDest$ = 12						; size = 4
_pszFormat$ = 16					; size = 4
?StringCchPrintfA@@YAJPADIPBDZZ PROC			; StringCchPrintfA, COMDAT

; 2678 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2679 :     HRESULT hr;
; 2680 : 
; 2681 :     if (cchDest > STRSAFE_MAX_CCH)

	cmp	DWORD PTR _cchDest$[ebp], 2147483647	; 7fffffffH
	jbe	SHORT $LN2@StringCchP

; 2682 :     {
; 2683 :         hr = STRSAFE_E_INVALID_PARAMETER;

	mov	DWORD PTR _hr$[ebp], -2147024809	; 80070057H

; 2684 :     }
; 2685 :     else

	jmp	SHORT $LN1@StringCchP
$LN2@StringCchP:

; 2686 :     {
; 2687 :         va_list argList;
; 2688 : 
; 2689 :         va_start(argList, pszFormat);

	lea	eax, DWORD PTR _pszFormat$[ebp+4]
	mov	DWORD PTR _argList$1[ebp], eax

; 2690 : 
; 2691 :         hr = StringVPrintfWorkerA(pszDest, cchDest, pszFormat, argList);

	mov	eax, DWORD PTR _argList$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszFormat$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cchDest$[ebp]
	push	edx
	mov	eax, DWORD PTR _pszDest$[ebp]
	push	eax
	call	?StringVPrintfWorkerA@@YGJPADIPBD0@Z	; StringVPrintfWorkerA
	mov	DWORD PTR _hr$[ebp], eax

; 2692 : 
; 2693 :         va_end(argList);

	mov	DWORD PTR _argList$1[ebp], 0
$LN1@StringCchP:

; 2694 :     }
; 2695 : 
; 2696 :     return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 2697 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?StringCchPrintfA@@YAJPADIPBDZZ ENDP			; StringCchPrintfA
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\include\strsafe.h
;	COMDAT ?StringCchCatA@@YGJPADIPBD@Z
_TEXT	SEGMENT
_hr$ = -8						; size = 4
_pszDest$ = 8						; size = 4
_cchDest$ = 12						; size = 4
_pszSrc$ = 16						; size = 4
?StringCchCatA@@YGJPADIPBD@Z PROC			; StringCchCatA, COMDAT

; 1347 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1348 :     HRESULT hr;
; 1349 : 
; 1350 :     if (cchDest > STRSAFE_MAX_CCH)

	cmp	DWORD PTR _cchDest$[ebp], 2147483647	; 7fffffffH
	jbe	SHORT $LN2@StringCchC

; 1351 :     {
; 1352 :         hr = STRSAFE_E_INVALID_PARAMETER;

	mov	DWORD PTR _hr$[ebp], -2147024809	; 80070057H

; 1353 :     }
; 1354 :     else

	jmp	SHORT $LN1@StringCchC
$LN2@StringCchC:

; 1355 :     {
; 1356 :         hr = StringCatWorkerA(pszDest, cchDest, pszSrc);

	mov	eax, DWORD PTR _pszSrc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cchDest$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszDest$[ebp]
	push	edx
	call	?StringCatWorkerA@@YGJPADIPBD@Z		; StringCatWorkerA
	mov	DWORD PTR _hr$[ebp], eax
$LN1@StringCchC:

; 1357 :     }
; 1358 : 
; 1359 :     return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 1360 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?StringCchCatA@@YGJPADIPBD@Z ENDP			; StringCchCatA
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\include\strsafe.h
;	COMDAT ?StringCchCopyA@@YGJPADIPBD@Z
_TEXT	SEGMENT
_hr$ = -8						; size = 4
_pszDest$ = 8						; size = 4
_cchDest$ = 12						; size = 4
_pszSrc$ = 16						; size = 4
?StringCchCopyA@@YGJPADIPBD@Z PROC			; StringCchCopyA, COMDAT

; 231  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 232  :     HRESULT hr;
; 233  : 
; 234  :     if (cchDest > STRSAFE_MAX_CCH)

	cmp	DWORD PTR _cchDest$[ebp], 2147483647	; 7fffffffH
	jbe	SHORT $LN2@StringCchC

; 235  :     {
; 236  :         hr = STRSAFE_E_INVALID_PARAMETER;

	mov	DWORD PTR _hr$[ebp], -2147024809	; 80070057H

; 237  :     }
; 238  :     else

	jmp	SHORT $LN1@StringCchC
$LN2@StringCchC:

; 239  :     {
; 240  :         hr = StringCopyWorkerA(pszDest, cchDest, pszSrc);

	mov	eax, DWORD PTR _pszSrc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cchDest$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszDest$[ebp]
	push	edx
	call	?StringCopyWorkerA@@YGJPADIPBD@Z	; StringCopyWorkerA
	mov	DWORD PTR _hr$[ebp], eax
$LN1@StringCchC:

; 241  :     }
; 242  : 
; 243  :     return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 244  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?StringCchCopyA@@YGJPADIPBD@Z ENDP			; StringCchCopyA
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\include\strsafe.h
;	COMDAT ?StringLengthWorkerA@@YGJPBDIPAI@Z
_TEXT	SEGMENT
_cchMaxPrev$ = -20					; size = 4
_hr$ = -8						; size = 4
_psz$ = 8						; size = 4
_cchMax$ = 12						; size = 4
_pcch$ = 16						; size = 4
?StringLengthWorkerA@@YGJPBDIPAI@Z PROC			; StringLengthWorkerA, COMDAT

; 5963 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5964 :     HRESULT hr = S_OK;

	mov	DWORD PTR _hr$[ebp], 0

; 5965 :     size_t cchMaxPrev = cchMax;

	mov	eax, DWORD PTR _cchMax$[ebp]
	mov	DWORD PTR _cchMaxPrev$[ebp], eax
$LN4@StringLeng:

; 5966 : 
; 5967 :     while (cchMax && (*psz != '\0'))

	cmp	DWORD PTR _cchMax$[ebp], 0
	je	SHORT $LN3@StringLeng
	mov	eax, DWORD PTR _psz$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@StringLeng

; 5968 :     {
; 5969 :         psz++;

	mov	eax, DWORD PTR _psz$[ebp]
	add	eax, 1
	mov	DWORD PTR _psz$[ebp], eax

; 5970 :         cchMax--;

	mov	eax, DWORD PTR _cchMax$[ebp]
	sub	eax, 1
	mov	DWORD PTR _cchMax$[ebp], eax

; 5971 :     }

	jmp	SHORT $LN4@StringLeng
$LN3@StringLeng:

; 5972 : 
; 5973 :     if (cchMax == 0)

	cmp	DWORD PTR _cchMax$[ebp], 0
	jne	SHORT $LN2@StringLeng

; 5974 :     {
; 5975 :         // the string is longer than cchMax
; 5976 :         hr = STRSAFE_E_INVALID_PARAMETER;

	mov	DWORD PTR _hr$[ebp], -2147024809	; 80070057H
$LN2@StringLeng:

; 5977 :     }
; 5978 : 
; 5979 :     if (SUCCEEDED(hr) && pcch)

	cmp	DWORD PTR _hr$[ebp], 0
	jl	SHORT $LN1@StringLeng
	cmp	DWORD PTR _pcch$[ebp], 0
	je	SHORT $LN1@StringLeng

; 5980 :     {
; 5981 :         *pcch = cchMaxPrev - cchMax;

	mov	eax, DWORD PTR _cchMaxPrev$[ebp]
	sub	eax, DWORD PTR _cchMax$[ebp]
	mov	ecx, DWORD PTR _pcch$[ebp]
	mov	DWORD PTR [ecx], eax
$LN1@StringLeng:

; 5982 :     }
; 5983 : 
; 5984 :     return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 5985 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?StringLengthWorkerA@@YGJPBDIPAI@Z ENDP			; StringLengthWorkerA
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\include\strsafe.h
;	COMDAT ?StringVPrintfWorkerA@@YGJPADIPBD0@Z
_TEXT	SEGMENT
_cchMax$1 = -32						; size = 4
_iRet$2 = -20						; size = 4
_hr$ = -8						; size = 4
_pszDest$ = 8						; size = 4
_cchDest$ = 12						; size = 4
_pszFormat$ = 16					; size = 4
_argList$ = 20						; size = 4
?StringVPrintfWorkerA@@YGJPADIPBD0@Z PROC		; StringVPrintfWorkerA, COMDAT

; 5579 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5580 :     HRESULT hr = S_OK;

	mov	DWORD PTR _hr$[ebp], 0

; 5581 : 
; 5582 :     if (cchDest == 0)

	cmp	DWORD PTR _cchDest$[ebp], 0
	jne	SHORT $LN6@StringVPri

; 5583 :     {
; 5584 :         // can not null terminate a zero-byte dest buffer
; 5585 :         hr = STRSAFE_E_INVALID_PARAMETER;

	mov	DWORD PTR _hr$[ebp], -2147024809	; 80070057H

; 5586 :     }
; 5587 :     else

	jmp	SHORT $LN5@StringVPri
$LN6@StringVPri:

; 5588 :     {
; 5589 :         int iRet;
; 5590 :         size_t cchMax;
; 5591 : 
; 5592 :         // leave the last space for the null terminator
; 5593 :         cchMax = cchDest - 1;

	mov	eax, DWORD PTR _cchDest$[ebp]
	sub	eax, 1
	mov	DWORD PTR _cchMax$1[ebp], eax

; 5594 : 
; 5595 :         iRet = _vsnprintf(pszDest, cchMax, pszFormat, argList);

	mov	eax, DWORD PTR _argList$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszFormat$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cchMax$1[ebp]
	push	edx
	mov	eax, DWORD PTR _pszDest$[ebp]
	push	eax
	call	__vsnprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iRet$2[ebp], eax

; 5596 :         // ASSERT((iRet < 0) || (((size_t)iRet) <= cchMax));
; 5597 : 
; 5598 :         if ((iRet < 0) || (((size_t)iRet) > cchMax))

	cmp	DWORD PTR _iRet$2[ebp], 0
	jl	SHORT $LN3@StringVPri
	mov	eax, DWORD PTR _iRet$2[ebp]
	cmp	eax, DWORD PTR _cchMax$1[ebp]
	jbe	SHORT $LN4@StringVPri
$LN3@StringVPri:

; 5599 :         {
; 5600 :             // need to null terminate the string
; 5601 :             pszDest += cchMax;

	mov	eax, DWORD PTR _pszDest$[ebp]
	add	eax, DWORD PTR _cchMax$1[ebp]
	mov	DWORD PTR _pszDest$[ebp], eax

; 5602 :             *pszDest = '\0';

	mov	eax, DWORD PTR _pszDest$[ebp]
	mov	BYTE PTR [eax], 0

; 5603 : 
; 5604 :             // we have truncated pszDest
; 5605 :             hr = STRSAFE_E_INSUFFICIENT_BUFFER;

	mov	DWORD PTR _hr$[ebp], -2147024774	; 8007007aH
	jmp	SHORT $LN5@StringVPri
$LN4@StringVPri:

; 5606 :         }
; 5607 :         else if (((size_t)iRet) == cchMax)

	mov	eax, DWORD PTR _iRet$2[ebp]
	cmp	eax, DWORD PTR _cchMax$1[ebp]
	jne	SHORT $LN5@StringVPri

; 5608 :         {
; 5609 :             // need to null terminate the string
; 5610 :             pszDest += cchMax;

	mov	eax, DWORD PTR _pszDest$[ebp]
	add	eax, DWORD PTR _cchMax$1[ebp]
	mov	DWORD PTR _pszDest$[ebp], eax

; 5611 :             *pszDest = '\0';

	mov	eax, DWORD PTR _pszDest$[ebp]
	mov	BYTE PTR [eax], 0
$LN5@StringVPri:

; 5612 :         }
; 5613 :     }
; 5614 : 
; 5615 :     return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 5616 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?StringVPrintfWorkerA@@YGJPADIPBD0@Z ENDP		; StringVPrintfWorkerA
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\include\strsafe.h
;	COMDAT ?StringCatWorkerA@@YGJPADIPBD@Z
_TEXT	SEGMENT
_cchDestCurrent$ = -20					; size = 4
_hr$ = -8						; size = 4
_pszDest$ = 8						; size = 4
_cchDest$ = 12						; size = 4
_pszSrc$ = 16						; size = 4
?StringCatWorkerA@@YGJPADIPBD@Z PROC			; StringCatWorkerA, COMDAT

; 4923 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4924 :    HRESULT hr;
; 4925 :    size_t cchDestCurrent;
; 4926 : 
; 4927 :    hr = StringLengthWorkerA(pszDest, cchDest, &cchDestCurrent);

	lea	eax, DWORD PTR _cchDestCurrent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cchDest$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszDest$[ebp]
	push	edx
	call	?StringLengthWorkerA@@YGJPBDIPAI@Z	; StringLengthWorkerA
	mov	DWORD PTR _hr$[ebp], eax

; 4928 : 
; 4929 :    if (SUCCEEDED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jl	SHORT $LN1@StringCatW

; 4930 :    {
; 4931 :        hr = StringCopyWorkerA(pszDest + cchDestCurrent,
; 4932 :                               cchDest - cchDestCurrent,
; 4933 :                               pszSrc);

	mov	eax, DWORD PTR _pszSrc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cchDest$[ebp]
	sub	ecx, DWORD PTR _cchDestCurrent$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszDest$[ebp]
	add	edx, DWORD PTR _cchDestCurrent$[ebp]
	push	edx
	call	?StringCopyWorkerA@@YGJPADIPBD@Z	; StringCopyWorkerA
	mov	DWORD PTR _hr$[ebp], eax
$LN1@StringCatW:

; 4934 :    }
; 4935 : 
; 4936 :    return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 4937 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@StringCatW
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN6@StringCatW:
	DD	1
	DD	$LN5@StringCatW
$LN5@StringCatW:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN4@StringCatW
$LN4@StringCatW:
	DB	99					; 00000063H
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	68					; 00000044H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	67					; 00000043H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
?StringCatWorkerA@@YGJPADIPBD@Z ENDP			; StringCatWorkerA
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\include\strsafe.h
;	COMDAT ?StringCopyWorkerA@@YGJPADIPBD@Z
_TEXT	SEGMENT
_hr$ = -8						; size = 4
_pszDest$ = 8						; size = 4
_cchDest$ = 12						; size = 4
_pszSrc$ = 16						; size = 4
?StringCopyWorkerA@@YGJPADIPBD@Z PROC			; StringCopyWorkerA, COMDAT

; 4247 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4248 :     HRESULT hr = S_OK;

	mov	DWORD PTR _hr$[ebp], 0

; 4249 : 
; 4250 :     if (cchDest == 0)

	cmp	DWORD PTR _cchDest$[ebp], 0
	jne	SHORT $LN3@StringCopy

; 4251 :     {
; 4252 :         // can not null terminate a zero-byte dest buffer
; 4253 :         hr = STRSAFE_E_INVALID_PARAMETER;

	mov	DWORD PTR _hr$[ebp], -2147024809	; 80070057H

; 4254 :     }
; 4255 :     else

	jmp	SHORT $LN4@StringCopy
$LN3@StringCopy:

; 4256 :     {
; 4257 :         while (cchDest && (*pszSrc != '\0'))

	cmp	DWORD PTR _cchDest$[ebp], 0
	je	SHORT $LN2@StringCopy
	mov	eax, DWORD PTR _pszSrc$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN2@StringCopy

; 4258 :         {
; 4259 :             *pszDest++ = *pszSrc++;

	mov	eax, DWORD PTR _pszDest$[ebp]
	mov	ecx, DWORD PTR _pszSrc$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _pszDest$[ebp]
	add	eax, 1
	mov	DWORD PTR _pszDest$[ebp], eax
	mov	ecx, DWORD PTR _pszSrc$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pszSrc$[ebp], ecx

; 4260 :             cchDest--;

	mov	eax, DWORD PTR _cchDest$[ebp]
	sub	eax, 1
	mov	DWORD PTR _cchDest$[ebp], eax

; 4261 :         }

	jmp	SHORT $LN3@StringCopy
$LN2@StringCopy:

; 4262 : 
; 4263 :         if (cchDest == 0)

	cmp	DWORD PTR _cchDest$[ebp], 0
	jne	SHORT $LN1@StringCopy

; 4264 :         {
; 4265 :             // we are going to truncate pszDest
; 4266 :             pszDest--;

	mov	eax, DWORD PTR _pszDest$[ebp]
	sub	eax, 1
	mov	DWORD PTR _pszDest$[ebp], eax

; 4267 :             hr = STRSAFE_E_INSUFFICIENT_BUFFER;

	mov	DWORD PTR _hr$[ebp], -2147024774	; 8007007aH
$LN1@StringCopy:

; 4268 :         }
; 4269 : 
; 4270 :         *pszDest= '\0';

	mov	eax, DWORD PTR _pszDest$[ebp]
	mov	BYTE PTR [eax], 0
$LN4@StringCopy:

; 4271 :     }
; 4272 : 
; 4273 :     return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 4274 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?StringCopyWorkerA@@YGJPADIPBD@Z ENDP			; StringCopyWorkerA
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\include\multimon.h
;	COMDAT _xEnumDisplayDevices@16
_TEXT	SEGMENT
_Unused$ = 8						; size = 4
_iDevNum$ = 12						; size = 4
_lpDisplayDevice$ = 16					; size = 4
_dwFlags$ = 20						; size = 4
_xEnumDisplayDevices@16 PROC				; COMDAT

; 429  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 430  :     if (InitMultipleMonitorStubs())

	call	_InitMultipleMonitorStubs
	test	eax, eax
	je	SHORT $LN5@xEnumDispl

; 431  :         return g_pfnEnumDisplayDevices(Unused, iDevNum, lpDisplayDevice, dwFlags);

	mov	esi, esp
	mov	eax, DWORD PTR _dwFlags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDisplayDevice$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iDevNum$[ebp]
	push	edx
	mov	eax, DWORD PTR _Unused$[ebp]
	push	eax
	call	DWORD PTR _g_pfnEnumDisplayDevices
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN6@xEnumDispl
$LN5@xEnumDispl:

; 432  : 
; 433  :     if (Unused != NULL)

	cmp	DWORD PTR _Unused$[ebp], 0
	je	SHORT $LN4@xEnumDispl

; 434  :         return FALSE;

	xor	eax, eax
	jmp	SHORT $LN6@xEnumDispl
$LN4@xEnumDispl:

; 435  : 
; 436  :     if (iDevNum != 0)

	cmp	DWORD PTR _iDevNum$[ebp], 0
	je	SHORT $LN3@xEnumDispl

; 437  :         return FALSE;

	xor	eax, eax
	jmp	SHORT $LN6@xEnumDispl
$LN3@xEnumDispl:

; 438  : 
; 439  :     if (lpDisplayDevice == NULL || lpDisplayDevice->cb < sizeof(DISPLAY_DEVICE))

	cmp	DWORD PTR _lpDisplayDevice$[ebp], 0
	je	SHORT $LN1@xEnumDispl
	mov	eax, DWORD PTR _lpDisplayDevice$[ebp]
	cmp	DWORD PTR [eax], 424			; 000001a8H
	jae	SHORT $LN2@xEnumDispl
$LN1@xEnumDispl:

; 440  :         return FALSE;

	xor	eax, eax
	jmp	SHORT $LN6@xEnumDispl
$LN2@xEnumDispl:

; 441  : 
; 442  : #ifdef UNICODE
; 443  :     MultiByteToWideChar(CP_ACP, 0, "DISPLAY", -1, lpDisplayDevice->DeviceName, (sizeof(lpDisplayDevice->DeviceName)/sizeof(TCHAR)));
; 444  :     MultiByteToWideChar(CP_ACP, 0, "DISPLAY", -1, lpDisplayDevice->DeviceString, (sizeof(lpDisplayDevice->DeviceName)/sizeof(TCHAR)));
; 445  : #else // UNICODE
; 446  :     lstrcpy((LPTSTR)lpDisplayDevice->DeviceName,   TEXT("DISPLAY"));

	mov	esi, esp
	push	OFFSET ??_C@_07JPHDIPNG@DISPLAY?$AA@
	mov	eax, DWORD PTR _lpDisplayDevice$[ebp]
	add	eax, 4
	push	eax
	call	DWORD PTR __imp__lstrcpyA@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 447  :     lstrcpy((LPTSTR)lpDisplayDevice->DeviceString, TEXT("DISPLAY"));

	mov	esi, esp
	push	OFFSET ??_C@_07JPHDIPNG@DISPLAY?$AA@
	mov	eax, DWORD PTR _lpDisplayDevice$[ebp]
	add	eax, 36					; 00000024H
	push	eax
	call	DWORD PTR __imp__lstrcpyA@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 448  : #endif // UNICODE
; 449  : 
; 450  :     lpDisplayDevice->StateFlags = DISPLAY_DEVICE_ATTACHED_TO_DESKTOP | DISPLAY_DEVICE_PRIMARY_DEVICE;

	mov	eax, DWORD PTR _lpDisplayDevice$[ebp]
	mov	DWORD PTR [eax+164], 5

; 451  : 
; 452  :     return TRUE;

	mov	eax, 1
$LN6@xEnumDispl:

; 453  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_xEnumDisplayDevices@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\include\multimon.h
;	COMDAT _xEnumDisplayMonitors@16
_TEXT	SEGMENT
tv80 = -264						; size = 4
_ptOrg$1 = -64						; size = 8
_rcClip$2 = -48						; size = 16
_rcLimit$ = -24						; size = 16
__$ArrayPad$ = -4					; size = 4
_hdcOptionalForPainting$ = 8				; size = 4
_lprcEnumMonitorsThatIntersect$ = 12			; size = 4
_lpfnEnumProc$ = 16					; size = 4
_dwData$ = 20						; size = 4
_xEnumDisplayMonitors@16 PROC				; COMDAT

; 365  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 366  :     RECT rcLimit;
; 367  : 
; 368  :     if (InitMultipleMonitorStubs()) {

	call	_InitMultipleMonitorStubs
	test	eax, eax
	je	SHORT $LN13@xEnumDispl

; 369  :         return g_pfnEnumDisplayMonitors(
; 370  :                 hdcOptionalForPainting,
; 371  :                 lprcEnumMonitorsThatIntersect,
; 372  :                 lpfnEnumProc,
; 373  :                 dwData);

	mov	esi, esp
	mov	eax, DWORD PTR _dwData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpfnEnumProc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lprcEnumMonitorsThatIntersect$[ebp]
	push	edx
	mov	eax, DWORD PTR _hdcOptionalForPainting$[ebp]
	push	eax
	call	DWORD PTR _g_pfnEnumDisplayMonitors
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	$LN14@xEnumDispl
$LN13@xEnumDispl:

; 374  :     }
; 375  : 
; 376  :     if (!lpfnEnumProc)

	cmp	DWORD PTR _lpfnEnumProc$[ebp], 0
	jne	SHORT $LN12@xEnumDispl

; 377  :         return FALSE;

	xor	eax, eax
	jmp	$LN14@xEnumDispl
$LN12@xEnumDispl:

; 378  : 
; 379  :     rcLimit.left   = 0;

	mov	DWORD PTR _rcLimit$[ebp], 0

; 380  :     rcLimit.top    = 0;

	mov	DWORD PTR _rcLimit$[ebp+4], 0

; 381  :     rcLimit.right  = GetSystemMetrics(SM_CXSCREEN);

	mov	esi, esp
	push	0
	call	DWORD PTR __imp__GetSystemMetrics@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _rcLimit$[ebp+8], eax

; 382  :     rcLimit.bottom = GetSystemMetrics(SM_CYSCREEN);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__GetSystemMetrics@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _rcLimit$[ebp+12], eax

; 383  : 
; 384  :     if (hdcOptionalForPainting)

	cmp	DWORD PTR _hdcOptionalForPainting$[ebp], 0
	je	$LN11@xEnumDispl

; 385  :     {
; 386  :         RECT    rcClip;
; 387  :         POINT   ptOrg;
; 388  : 
; 389  :         switch (GetClipBox(hdcOptionalForPainting, &rcClip))

	mov	esi, esp
	lea	eax, DWORD PTR _rcClip$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _hdcOptionalForPainting$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetClipBox@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv80[ebp], eax
	cmp	DWORD PTR tv80[ebp], 0
	je	$LN3@xEnumDispl
	cmp	DWORD PTR tv80[ebp], 1
	je	$LN4@xEnumDispl

; 390  :         {
; 391  :         default:
; 392  :             if (!GetDCOrgEx(hdcOptionalForPainting, &ptOrg))

	mov	esi, esp
	lea	eax, DWORD PTR _ptOrg$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _hdcOptionalForPainting$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetDCOrgEx@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN7@xEnumDispl

; 393  :                 return FALSE;

	xor	eax, eax
	jmp	$LN14@xEnumDispl
$LN7@xEnumDispl:

; 394  : 
; 395  :             OffsetRect(&rcLimit, -ptOrg.x, -ptOrg.y);

	mov	eax, DWORD PTR _ptOrg$1[ebp+4]
	neg	eax
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _ptOrg$1[ebp]
	neg	ecx
	push	ecx
	lea	edx, DWORD PTR _rcLimit$[ebp]
	push	edx
	call	DWORD PTR __imp__OffsetRect@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 396  :             if (IntersectRect(&rcLimit, &rcLimit, &rcClip) &&
; 397  :                 (!lprcEnumMonitorsThatIntersect ||
; 398  :                      IntersectRect(&rcLimit, &rcLimit, lprcEnumMonitorsThatIntersect))) {

	mov	esi, esp
	lea	eax, DWORD PTR _rcClip$2[ebp]
	push	eax
	lea	ecx, DWORD PTR _rcLimit$[ebp]
	push	ecx
	lea	edx, DWORD PTR _rcLimit$[ebp]
	push	edx
	call	DWORD PTR __imp__IntersectRect@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN4@xEnumDispl
	cmp	DWORD PTR _lprcEnumMonitorsThatIntersect$[ebp], 0
	je	SHORT $LN5@xEnumDispl
	mov	esi, esp
	mov	eax, DWORD PTR _lprcEnumMonitorsThatIntersect$[ebp]
	push	eax
	lea	ecx, DWORD PTR _rcLimit$[ebp]
	push	ecx
	lea	edx, DWORD PTR _rcLimit$[ebp]
	push	edx
	call	DWORD PTR __imp__IntersectRect@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN4@xEnumDispl
$LN5@xEnumDispl:

; 399  : 
; 400  :                 break;

	jmp	SHORT $LN9@xEnumDispl
$LN4@xEnumDispl:

; 401  :             }
; 402  :             //fall thru
; 403  :         case NULLREGION:
; 404  :              return TRUE;

	mov	eax, 1
	jmp	SHORT $LN14@xEnumDispl
$LN3@xEnumDispl:

; 405  :         case ERROR:
; 406  :              return FALSE;

	xor	eax, eax
	jmp	SHORT $LN14@xEnumDispl
$LN9@xEnumDispl:

; 407  :         }
; 408  :     } else {

	jmp	SHORT $LN2@xEnumDispl
$LN11@xEnumDispl:

; 409  :         if (    lprcEnumMonitorsThatIntersect &&
; 410  :                 !IntersectRect(&rcLimit, &rcLimit, lprcEnumMonitorsThatIntersect)) {

	cmp	DWORD PTR _lprcEnumMonitorsThatIntersect$[ebp], 0
	je	SHORT $LN2@xEnumDispl
	mov	esi, esp
	mov	eax, DWORD PTR _lprcEnumMonitorsThatIntersect$[ebp]
	push	eax
	lea	ecx, DWORD PTR _rcLimit$[ebp]
	push	ecx
	lea	edx, DWORD PTR _rcLimit$[ebp]
	push	edx
	call	DWORD PTR __imp__IntersectRect@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN2@xEnumDispl

; 411  : 
; 412  :             return TRUE;

	mov	eax, 1
	jmp	SHORT $LN14@xEnumDispl
$LN2@xEnumDispl:

; 413  :         }
; 414  :     }
; 415  : 
; 416  :     return lpfnEnumProc(
; 417  :             xPRIMARY_MONITOR,
; 418  :             hdcOptionalForPainting,
; 419  :             &rcLimit,
; 420  :             dwData);

	mov	esi, esp
	mov	eax, DWORD PTR _dwData$[ebp]
	push	eax
	lea	ecx, DWORD PTR _rcLimit$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hdcOptionalForPainting$[ebp]
	push	edx
	push	305397826				; 12340042H
	call	DWORD PTR _lpfnEnumProc$[ebp]
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN14@xEnumDispl:

; 421  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN20@xEnumDispl
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	npad	1
$LN20@xEnumDispl:
	DD	3
	DD	$LN19@xEnumDispl
$LN19@xEnumDispl:
	DD	-24					; ffffffe8H
	DD	16					; 00000010H
	DD	$LN16@xEnumDispl
	DD	-48					; ffffffd0H
	DD	16					; 00000010H
	DD	$LN17@xEnumDispl
	DD	-64					; ffffffc0H
	DD	8
	DD	$LN18@xEnumDispl
$LN18@xEnumDispl:
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	79					; 0000004fH
	DB	114					; 00000072H
	DB	103					; 00000067H
	DB	0
$LN17@xEnumDispl:
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	67					; 00000043H
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	112					; 00000070H
	DB	0
$LN16@xEnumDispl:
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	76					; 0000004cH
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	0
_xEnumDisplayMonitors@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\include\multimon.h
;	COMDAT _xGetMonitorInfo@8
_TEXT	SEGMENT
_f$1 = -36						; size = 4
_rcWork$ = -24						; size = 16
__$ArrayPad$ = -4					; size = 4
_hMonitor$ = 8						; size = 4
_lpMonitorInfo$ = 12					; size = 4
_xGetMonitorInfo@8 PROC					; COMDAT

; 315  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 316  :     RECT rcWork;
; 317  : 
; 318  :     if (InitMultipleMonitorStubs())

	call	_InitMultipleMonitorStubs
	test	eax, eax
	je	SHORT $LN3@xGetMonito

; 319  :     {
; 320  :         BOOL f = g_pfnGetMonitorInfo(hMonitor, lpMonitorInfo);

	mov	esi, esp
	mov	eax, DWORD PTR _lpMonitorInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hMonitor$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetMonitorInfo
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _f$1[ebp], eax

; 321  : #ifdef UNICODE
; 322  :         if (f && !g_fMultimonPlatformNT && (lpMonitorInfo->cbSize >= sizeof(MONITORINFOEX)))
; 323  :         { 
; 324  :             MultiByteToWideChar(CP_ACP, 0,
; 325  :                 (LPSTR)((MONITORINFOEX*)lpMonitorInfo)->szDevice, -1,
; 326  :                 ((MONITORINFOEX*)lpMonitorInfo)->szDevice, (sizeof(((MONITORINFOEX*)lpMonitorInfo)->szDevice)/sizeof(TCHAR)));
; 327  :         }
; 328  : #endif
; 329  :         return f;

	mov	eax, DWORD PTR _f$1[ebp]
	jmp	$LN4@xGetMonito
$LN3@xGetMonito:

; 330  :     }
; 331  : 
; 332  :     if ((hMonitor == xPRIMARY_MONITOR) &&
; 333  :         lpMonitorInfo &&
; 334  :         (lpMonitorInfo->cbSize >= sizeof(MONITORINFO)) &&
; 335  :         SystemParametersInfoA(SPI_GETWORKAREA, 0, &rcWork, 0))

	cmp	DWORD PTR _hMonitor$[ebp], 305397826	; 12340042H
	jne	$LN2@xGetMonito
	cmp	DWORD PTR _lpMonitorInfo$[ebp], 0
	je	$LN2@xGetMonito
	mov	eax, DWORD PTR _lpMonitorInfo$[ebp]
	cmp	DWORD PTR [eax], 40			; 00000028H
	jb	$LN2@xGetMonito
	mov	esi, esp
	push	0
	lea	eax, DWORD PTR _rcWork$[ebp]
	push	eax
	push	0
	push	48					; 00000030H
	call	DWORD PTR __imp__SystemParametersInfoA@16
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	$LN2@xGetMonito

; 336  :     {
; 337  :         lpMonitorInfo->rcMonitor.left = 0;

	mov	eax, DWORD PTR _lpMonitorInfo$[ebp]
	mov	DWORD PTR [eax+4], 0

; 338  :         lpMonitorInfo->rcMonitor.top  = 0;

	mov	eax, DWORD PTR _lpMonitorInfo$[ebp]
	mov	DWORD PTR [eax+8], 0

; 339  :         lpMonitorInfo->rcMonitor.right  = GetSystemMetrics(SM_CXSCREEN);

	mov	esi, esp
	push	0
	call	DWORD PTR __imp__GetSystemMetrics@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _lpMonitorInfo$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 340  :         lpMonitorInfo->rcMonitor.bottom = GetSystemMetrics(SM_CYSCREEN);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__GetSystemMetrics@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _lpMonitorInfo$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 341  :         lpMonitorInfo->rcWork = rcWork;

	mov	eax, DWORD PTR _lpMonitorInfo$[ebp]
	add	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _rcWork$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _rcWork$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _rcWork$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _rcWork$[ebp+12]
	mov	DWORD PTR [eax+12], edx

; 342  :         lpMonitorInfo->dwFlags = MONITORINFOF_PRIMARY;

	mov	eax, DWORD PTR _lpMonitorInfo$[ebp]
	mov	DWORD PTR [eax+36], 1

; 343  : 
; 344  :         if (lpMonitorInfo->cbSize >= sizeof(MONITORINFOEX))

	mov	eax, DWORD PTR _lpMonitorInfo$[ebp]
	cmp	DWORD PTR [eax], 72			; 00000048H
	jb	SHORT $LN1@xGetMonito

; 345  :         {
; 346  : #ifdef UNICODE
; 347  :             MultiByteToWideChar(CP_ACP, 0, "DISPLAY", -1, ((MONITORINFOEX*)lpMonitorInfo)->szDevice, (sizeof(((MONITORINFOEX*)lpMonitorInfo)->szDevice)/sizeof(TCHAR)));
; 348  : #else // UNICODE
; 349  :             lstrcpy(((MONITORINFOEX*)lpMonitorInfo)->szDevice, TEXT("DISPLAY"));

	mov	esi, esp
	push	OFFSET ??_C@_07JPHDIPNG@DISPLAY?$AA@
	mov	eax, DWORD PTR _lpMonitorInfo$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	call	DWORD PTR __imp__lstrcpyA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@xGetMonito:

; 350  : #endif // UNICODE
; 351  :         }
; 352  : 
; 353  :         return TRUE;

	mov	eax, 1
	jmp	SHORT $LN4@xGetMonito
$LN2@xGetMonito:

; 354  :     }
; 355  : 
; 356  :     return FALSE;

	xor	eax, eax
$LN4@xGetMonito:

; 357  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@xGetMonito
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN8@xGetMonito:
	DD	1
	DD	$LN7@xGetMonito
$LN7@xGetMonito:
	DD	-24					; ffffffe8H
	DD	16					; 00000010H
	DD	$LN6@xGetMonito
$LN6@xGetMonito:
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	87					; 00000057H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	107					; 0000006bH
	DB	0
_xGetMonitorInfo@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\include\multimon.h
;	COMDAT _xMonitorFromPoint@12
_TEXT	SEGMENT
_ptScreenCoords$ = 8					; size = 8
_dwFlags$ = 16						; size = 4
_xMonitorFromPoint@12 PROC				; COMDAT

; 258  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 259  :     if (InitMultipleMonitorStubs())

	call	_InitMultipleMonitorStubs
	test	eax, eax
	je	SHORT $LN3@xMonitorFr

; 260  :         return g_pfnMonitorFromPoint(ptScreenCoords, dwFlags);

	mov	esi, esp
	mov	eax, DWORD PTR _dwFlags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptScreenCoords$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _ptScreenCoords$[ebp]
	push	edx
	call	DWORD PTR _g_pfnMonitorFromPoint
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN4@xMonitorFr
$LN3@xMonitorFr:

; 261  : 
; 262  :     if ((dwFlags & (MONITOR_DEFAULTTOPRIMARY | MONITOR_DEFAULTTONEAREST)) ||
; 263  :         ((ptScreenCoords.x >= 0) &&
; 264  :         (ptScreenCoords.x < GetSystemMetrics(SM_CXSCREEN)) &&
; 265  :         (ptScreenCoords.y >= 0) &&
; 266  :         (ptScreenCoords.y < GetSystemMetrics(SM_CYSCREEN))))

	mov	eax, DWORD PTR _dwFlags$[ebp]
	and	eax, 3
	jne	SHORT $LN1@xMonitorFr
	cmp	DWORD PTR _ptScreenCoords$[ebp], 0
	jl	SHORT $LN2@xMonitorFr
	mov	esi, esp
	push	0
	call	DWORD PTR __imp__GetSystemMetrics@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	DWORD PTR _ptScreenCoords$[ebp], eax
	jge	SHORT $LN2@xMonitorFr
	cmp	DWORD PTR _ptScreenCoords$[ebp+4], 0
	jl	SHORT $LN2@xMonitorFr
	mov	esi, esp
	push	1
	call	DWORD PTR __imp__GetSystemMetrics@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	DWORD PTR _ptScreenCoords$[ebp+4], eax
	jge	SHORT $LN2@xMonitorFr
$LN1@xMonitorFr:

; 267  :     {
; 268  :         return xPRIMARY_MONITOR;

	mov	eax, 305397826				; 12340042H
	jmp	SHORT $LN4@xMonitorFr
$LN2@xMonitorFr:

; 269  :     }
; 270  : 
; 271  :     return NULL;

	xor	eax, eax
$LN4@xMonitorFr:

; 272  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_xMonitorFromPoint@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\include\multimon.h
;	COMDAT _xMonitorFromRect@8
_TEXT	SEGMENT
_lprcScreenCoords$ = 8					; size = 4
_dwFlags$ = 12						; size = 4
_xMonitorFromRect@8 PROC				; COMDAT

; 276  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 277  :     if (InitMultipleMonitorStubs())

	call	_InitMultipleMonitorStubs
	test	eax, eax
	je	SHORT $LN3@xMonitorFr

; 278  :         return g_pfnMonitorFromRect(lprcScreenCoords, dwFlags);

	mov	esi, esp
	mov	eax, DWORD PTR _dwFlags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lprcScreenCoords$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnMonitorFromRect
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN4@xMonitorFr
$LN3@xMonitorFr:

; 279  : 
; 280  :     if ((dwFlags & (MONITOR_DEFAULTTOPRIMARY | MONITOR_DEFAULTTONEAREST)) ||
; 281  :         ((lprcScreenCoords->right > 0) &&
; 282  :         (lprcScreenCoords->bottom > 0) &&
; 283  :         (lprcScreenCoords->left < GetSystemMetrics(SM_CXSCREEN)) &&
; 284  :         (lprcScreenCoords->top < GetSystemMetrics(SM_CYSCREEN))))

	mov	eax, DWORD PTR _dwFlags$[ebp]
	and	eax, 3
	jne	SHORT $LN1@xMonitorFr
	mov	eax, DWORD PTR _lprcScreenCoords$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jle	SHORT $LN2@xMonitorFr
	mov	eax, DWORD PTR _lprcScreenCoords$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jle	SHORT $LN2@xMonitorFr
	mov	esi, esp
	push	0
	call	DWORD PTR __imp__GetSystemMetrics@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _lprcScreenCoords$[ebp]
	cmp	DWORD PTR [ecx], eax
	jge	SHORT $LN2@xMonitorFr
	mov	esi, esp
	push	1
	call	DWORD PTR __imp__GetSystemMetrics@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _lprcScreenCoords$[ebp]
	cmp	DWORD PTR [ecx+4], eax
	jge	SHORT $LN2@xMonitorFr
$LN1@xMonitorFr:

; 285  :     {
; 286  :         return xPRIMARY_MONITOR;

	mov	eax, 305397826				; 12340042H
	jmp	SHORT $LN4@xMonitorFr
$LN2@xMonitorFr:

; 287  :     }
; 288  : 
; 289  :     return NULL;

	xor	eax, eax
$LN4@xMonitorFr:

; 290  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_xMonitorFromRect@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\include\multimon.h
;	COMDAT _xMonitorFromWindow@8
_TEXT	SEGMENT
tv80 = -252						; size = 4
_wp$ = -52						; size = 44
__$ArrayPad$ = -4					; size = 4
_hWnd$ = 8						; size = 4
_dwFlags$ = 12						; size = 4
_xMonitorFromWindow@8 PROC				; COMDAT

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 295  :     WINDOWPLACEMENT wp;
; 296  : 
; 297  :     if (InitMultipleMonitorStubs())

	call	_InitMultipleMonitorStubs
	test	eax, eax
	je	SHORT $LN3@xMonitorFr

; 298  :         return g_pfnMonitorFromWindow(hWnd, dwFlags);

	mov	esi, esp
	mov	eax, DWORD PTR _dwFlags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hWnd$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnMonitorFromWindow
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN4@xMonitorFr
$LN3@xMonitorFr:

; 299  : 
; 300  :     if (dwFlags & (MONITOR_DEFAULTTOPRIMARY | MONITOR_DEFAULTTONEAREST))

	mov	eax, DWORD PTR _dwFlags$[ebp]
	and	eax, 3
	je	SHORT $LN2@xMonitorFr

; 301  :         return xPRIMARY_MONITOR;

	mov	eax, 305397826				; 12340042H
	jmp	SHORT $LN4@xMonitorFr
$LN2@xMonitorFr:

; 302  : 
; 303  :     if (IsIconic(hWnd) ?
; 304  :             GetWindowPlacement(hWnd, &wp) :
; 305  :             GetWindowRect(hWnd, &wp.rcNormalPosition)) {

	mov	esi, esp
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__IsIconic@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN6@xMonitorFr
	mov	esi, esp
	lea	ecx, DWORD PTR _wp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hWnd$[ebp]
	push	edx
	call	DWORD PTR __imp__GetWindowPlacement@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv80[ebp], eax
	jmp	SHORT $LN7@xMonitorFr
$LN6@xMonitorFr:
	mov	esi, esp
	lea	eax, DWORD PTR _wp$[ebp+28]
	push	eax
	mov	ecx, DWORD PTR _hWnd$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetWindowRect@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv80[ebp], eax
$LN7@xMonitorFr:
	cmp	DWORD PTR tv80[ebp], 0
	je	SHORT $LN1@xMonitorFr

; 306  : 
; 307  :         return xMonitorFromRect(&wp.rcNormalPosition, dwFlags);

	mov	eax, DWORD PTR _dwFlags$[ebp]
	push	eax
	lea	ecx, DWORD PTR _wp$[ebp+28]
	push	ecx
	call	_xMonitorFromRect@8
	jmp	SHORT $LN4@xMonitorFr
$LN1@xMonitorFr:

; 308  :     }
; 309  : 
; 310  :     return NULL;

	xor	eax, eax
$LN4@xMonitorFr:

; 311  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@xMonitorFr
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN10@xMonitorFr:
	DD	1
	DD	$LN9@xMonitorFr
$LN9@xMonitorFr:
	DD	-52					; ffffffccH
	DD	44					; 0000002cH
	DD	$LN8@xMonitorFr
$LN8@xMonitorFr:
	DB	119					; 00000077H
	DB	112					; 00000070H
	DB	0
_xMonitorFromWindow@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\d3d9\include\multimon.h
;	COMDAT _xGetSystemMetrics@4
_TEXT	SEGMENT
tv68 = -196						; size = 4
_nIndex$ = 8						; size = 4
_xGetSystemMetrics@4 PROC				; COMDAT

; 228  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 229  :     if (InitMultipleMonitorStubs())

	call	_InitMultipleMonitorStubs
	test	eax, eax
	je	SHORT $LN7@xGetSystem

; 230  :         return g_pfnGetSystemMetrics(nIndex);

	mov	esi, esp
	mov	eax, DWORD PTR _nIndex$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetSystemMetrics
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN8@xGetSystem
$LN7@xGetSystem:

; 231  : 
; 232  :     switch (nIndex)

	mov	eax, DWORD PTR _nIndex$[ebp]
	mov	DWORD PTR tv68[ebp], eax
	mov	ecx, DWORD PTR tv68[ebp]
	sub	ecx, 76					; 0000004cH
	mov	DWORD PTR tv68[ebp], ecx
	cmp	DWORD PTR tv68[ebp], 5
	ja	SHORT $LN5@xGetSystem
	mov	edx, DWORD PTR tv68[ebp]
	jmp	DWORD PTR $LN10@xGetSystem[edx*4]
$LN4@xGetSystem:

; 233  :     {
; 234  :     case SM_CMONITORS:
; 235  :     case SM_SAMEDISPLAYFORMAT:
; 236  :         return 1;

	mov	eax, 1
	jmp	SHORT $LN8@xGetSystem
$LN3@xGetSystem:

; 237  : 
; 238  :     case SM_XVIRTUALSCREEN:
; 239  :     case SM_YVIRTUALSCREEN:
; 240  :         return 0;

	xor	eax, eax
	jmp	SHORT $LN8@xGetSystem
$LN2@xGetSystem:

; 241  : 
; 242  :     case SM_CXVIRTUALSCREEN:
; 243  :         nIndex = SM_CXSCREEN;

	mov	DWORD PTR _nIndex$[ebp], 0

; 244  :         break;

	jmp	SHORT $LN5@xGetSystem
$LN1@xGetSystem:

; 245  : 
; 246  :     case SM_CYVIRTUALSCREEN:
; 247  :         nIndex = SM_CYSCREEN;

	mov	DWORD PTR _nIndex$[ebp], 1
$LN5@xGetSystem:

; 248  :         break;
; 249  :     }
; 250  : 
; 251  :     return GetSystemMetrics(nIndex);

	mov	esi, esp
	mov	eax, DWORD PTR _nIndex$[ebp]
	push	eax
	call	DWORD PTR __imp__GetSystemMetrics@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN8@xGetSystem:

; 252  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN10@xGetSystem:
	DD	$LN3@xGetSystem
	DD	$LN3@xGetSystem
	DD	$LN2@xGetSystem
	DD	$LN1@xGetSystem
	DD	$LN4@xGetSystem
	DD	$LN4@xGetSystem
_xGetSystemMetrics@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\program files (x86)\microsoft visual studio 12.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 103  :         {return (_Where); }

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR __Where$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\program files (x86)\microsoft visual studio 12.0\vc\include\stdlib.h
;	COMDAT ?abs@@YAJJ@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?abs@@YAJJ@Z PROC					; abs, COMDAT

; 498  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 499  :         return labs(_X);

	mov	eax, DWORD PTR __X$[ebp]
	push	eax
	call	_labs
	add	esp, 4

; 500  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?abs@@YAJJ@Z ENDP					; abs
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\program files (x86)\windows kits\8.1\include\shared\winerror.h
;	COMDAT _HRESULT_FROM_WIN32
_TEXT	SEGMENT
tv68 = -196						; size = 4
_x$ = 8							; size = 4
_HRESULT_FROM_WIN32 PROC				; COMDAT

; 26297: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	cmp	DWORD PTR _x$[ebp], 0
	jg	SHORT $LN3@HRESULT_FR
	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN4@HRESULT_FR
$LN3@HRESULT_FR:
	mov	ecx, DWORD PTR _x$[ebp]
	and	ecx, 65535				; 0000ffffH
	or	ecx, 458752				; 00070000H
	or	ecx, -2147483648			; 80000000H
	mov	DWORD PTR tv68[ebp], ecx
$LN4@HRESULT_FR:
	mov	eax, DWORD PTR tv68[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_HRESULT_FROM_WIN32 ENDP
_TEXT	ENDS
END
