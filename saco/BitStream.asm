; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.31101.0 

	TITLE	Z:\sampsrc\02Xu1\raknet\BitStream.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	??0BitStream@RakNet@@QAE@XZ			; RakNet::BitStream::BitStream
PUBLIC	??0BitStream@RakNet@@QAE@H@Z			; RakNet::BitStream::BitStream
PUBLIC	??0BitStream@RakNet@@QAE@PAEI_N@Z		; RakNet::BitStream::BitStream
PUBLIC	??0BitStream@RakNet@@QAE@PADI_N@Z		; RakNet::BitStream::BitStream
PUBLIC	??1BitStream@RakNet@@QAE@XZ			; RakNet::BitStream::~BitStream
PUBLIC	?Reset@BitStream@RakNet@@QAEXXZ			; RakNet::BitStream::Reset
PUBLIC	?Write@BitStream@RakNet@@QAEXPBDH@Z		; RakNet::BitStream::Write
PUBLIC	?Write@BitStream@RakNet@@QAEXPAV12@H@Z		; RakNet::BitStream::Write
PUBLIC	?Write@BitStream@RakNet@@QAEXPAV12@@Z		; RakNet::BitStream::Write
PUBLIC	?Read@BitStream@RakNet@@QAE_NPADH@Z		; RakNet::BitStream::Read
PUBLIC	?ResetReadPointer@BitStream@RakNet@@QAEXXZ	; RakNet::BitStream::ResetReadPointer
PUBLIC	?ResetWritePointer@BitStream@RakNet@@QAEXXZ	; RakNet::BitStream::ResetWritePointer
PUBLIC	?AssertStreamEmpty@BitStream@RakNet@@QAEXXZ	; RakNet::BitStream::AssertStreamEmpty
PUBLIC	?PrintBits@BitStream@RakNet@@QBEXXZ		; RakNet::BitStream::PrintBits
PUBLIC	?IgnoreBits@BitStream@RakNet@@QAEXH@Z		; RakNet::BitStream::IgnoreBits
PUBLIC	?SetWriteOffset@BitStream@RakNet@@QAEXH@Z	; RakNet::BitStream::SetWriteOffset
PUBLIC	?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ	; RakNet::BitStream::GetNumberOfBitsUsed
PUBLIC	?GetWriteOffset@BitStream@RakNet@@QBEHXZ	; RakNet::BitStream::GetWriteOffset
PUBLIC	?CopyData@BitStream@RakNet@@QBEHPAPAE@Z		; RakNet::BitStream::CopyData
PUBLIC	?SetData@BitStream@RakNet@@QAEXPAE@Z		; RakNet::BitStream::SetData
PUBLIC	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z	; RakNet::BitStream::WriteBits
PUBLIC	?WriteAlignedBytes@BitStream@RakNet@@QAEXPBEH@Z	; RakNet::BitStream::WriteAlignedBytes
PUBLIC	?ReadAlignedBytes@BitStream@RakNet@@QAE_NPAEH@Z	; RakNet::BitStream::ReadAlignedBytes
PUBLIC	?AlignWriteToByteBoundary@BitStream@RakNet@@QAEXXZ ; RakNet::BitStream::AlignWriteToByteBoundary
PUBLIC	?AlignReadToByteBoundary@BitStream@RakNet@@QAEXXZ ; RakNet::BitStream::AlignReadToByteBoundary
PUBLIC	?ReadBits@BitStream@RakNet@@QAE_NPAEH_N@Z	; RakNet::BitStream::ReadBits
PUBLIC	?Write0@BitStream@RakNet@@QAEXXZ		; RakNet::BitStream::Write0
PUBLIC	?Write1@BitStream@RakNet@@QAEXXZ		; RakNet::BitStream::Write1
PUBLIC	?ReadBit@BitStream@RakNet@@QAE_NXZ		; RakNet::BitStream::ReadBit
PUBLIC	?AssertCopyData@BitStream@RakNet@@QAEXXZ	; RakNet::BitStream::AssertCopyData
PUBLIC	?SetNumberOfBitsAllocated@BitStream@RakNet@@QAEXI@Z ; RakNet::BitStream::SetNumberOfBitsAllocated
PUBLIC	?AddBitsAndReallocate@BitStream@RakNet@@QAEXH@Z	; RakNet::BitStream::AddBitsAndReallocate
PUBLIC	?WriteCompressed@BitStream@RakNet@@AAEXPBEH_N@Z	; RakNet::BitStream::WriteCompressed
PUBLIC	?ReadCompressed@BitStream@RakNet@@AAE_NPAEH_N@Z	; RakNet::BitStream::ReadCompressed
PUBLIC	?ReverseBytes@BitStream@RakNet@@AAEXPAE0H@Z	; RakNet::BitStream::ReverseBytes
PUBLIC	?DoEndianSwap@BitStream@RakNet@@ABE_NXZ		; RakNet::BitStream::DoEndianSwap
PUBLIC	??$Write@_N@BitStream@RakNet@@QAEX_N@Z		; RakNet::BitStream::Write<bool>
PUBLIC	??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z	; RakNet::BitStream::Read<bool>
PUBLIC	?__LINE__Var@?1???0BitStream@RakNet@@QAE@H@Z@4JA ; `RakNet::BitStream::BitStream'::`2'::__LINE__Var
PUBLIC	??_C@_1EM@DFHCFFCB@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAb?$AAi?$AAt?$AAs?$AAt?$AAr?$AAe?$AAa@ ; `string'
PUBLIC	??_C@_19MLBBEMBH@?$AAd?$AAa?$AAt?$AAa?$AA?$AA@	; `string'
PUBLIC	?__LINE__Var@?1???0BitStream@RakNet@@QAE@PAEI_N@Z@4JA ; `RakNet::BitStream::BitStream'::`2'::__LINE__Var
PUBLIC	?__LINE__Var@?1???0BitStream@RakNet@@QAE@PADI_N@Z@4JA ; `RakNet::BitStream::BitStream'::`2'::__LINE__Var
PUBLIC	?__LINE__Var@?1??SetNumberOfBitsAllocated@BitStream@RakNet@@QAEXI@Z@4JA ; `RakNet::BitStream::SetNumberOfBitsAllocated'::`2'::__LINE__Var
PUBLIC	??_C@_1GO@EPGHOGFD@?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AAI?$AAn?$AAB?$AAi?$AAt?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA?$CI?$AA?5?$AAu?$AAn?$AAs?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AAi?$AAn?$AAt?$AA?5?$AA?$CJ@ ; `string'
PUBLIC	?__LINE__Var@?1??WriteAlignedBytes@BitStream@RakNet@@QAEXPBEH@Z@4JA ; `RakNet::BitStream::WriteAlignedBytes'::`2'::__LINE__Var
PUBLIC	??_C@_1DC@JEEOABPC@?$AAn?$AAu?$AAm?$AAb?$AAe?$AAr?$AAO?$AAf?$AAB?$AAy?$AAt?$AAe?$AAs?$AAT?$AAo?$AAW?$AAr?$AAi?$AAt?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??ReadAlignedBytes@BitStream@RakNet@@QAE_NPAEH@Z@4JA ; `RakNet::BitStream::ReadAlignedBytes'::`2'::__LINE__Var
PUBLIC	??_C@_1DA@DCBJKEEH@?$AAn?$AAu?$AAm?$AAb?$AAe?$AAr?$AAO?$AAf?$AAB?$AAy?$AAt?$AAe?$AAs?$AAT?$AAo?$AAR?$AAe?$AAa?$AAd?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??ReadBits@BitStream@RakNet@@QAE_NPAEH_N@Z@4JA ; `RakNet::BitStream::ReadBits'::`2'::__LINE__Var
PUBLIC	??_C@_1CO@BNPNFPEM@?$AAn?$AAu?$AAm?$AAb?$AAe?$AAr?$AAO?$AAf?$AAB?$AAi?$AAt?$AAs?$AAT?$AAo?$AAR?$AAe?$AAa?$AAd?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??AddBitsAndReallocate@BitStream@RakNet@@QAEXH@Z@4JA ; `RakNet::BitStream::AddBitsAndReallocate'::`2'::__LINE__Var
PUBLIC	??_C@_1CC@HCNGKMKC@?$AAc?$AAo?$AAp?$AAy?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAr?$AAu?$AAe?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??AssertStreamEmpty@BitStream@RakNet@@QAEXXZ@4JA ; `RakNet::BitStream::AssertStreamEmpty'::`2'::__LINE__Var
PUBLIC	??_C@_1DO@BPODHJKO@?$AAr?$AAe?$AAa?$AAd?$AAO?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAn?$AAu?$AAm?$AAb?$AAe?$AAr?$AAO?$AAf?$AAB?$AAi?$AAt?$AAs?$AAU?$AAs?$AAe?$AAd?$AA?$AA@ ; `string'
PUBLIC	??_C@_08FAMLAKGK@No?5bits?6?$AA@		; `string'
PUBLIC	?__LINE__Var@?1??CopyData@BitStream@RakNet@@QBEHPAPAE@Z@4JA ; `RakNet::BitStream::CopyData'::`2'::__LINE__Var
PUBLIC	??_C@_1CK@KPLFMFLB@?$AAn?$AAu?$AAm?$AAb?$AAe?$AAr?$AAO?$AAf?$AAB?$AAi?$AAt?$AAs?$AAU?$AAs?$AAe?$AAd?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??AssertCopyData@BitStream@RakNet@@QAEXXZ@4JA ; `RakNet::BitStream::AssertCopyData'::`2'::__LINE__Var
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__wassert:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_realloc:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_printf:PROC
EXTRN	_putchar:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ?__LINE__Var@?1??AssertCopyData@BitStream@RakNet@@QAEXXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?1??AssertCopyData@BitStream@RakNet@@QAEXXZ@4JA DD 030bH ; `RakNet::BitStream::AssertCopyData'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1CK@KPLFMFLB@?$AAn?$AAu?$AAm?$AAb?$AAe?$AAr?$AAO?$AAf?$AAB?$AAi?$AAt?$AAs?$AAU?$AAs?$AAe?$AAd?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@KPLFMFLB@?$AAn?$AAu?$AAm?$AAb?$AAe?$AAr?$AAO?$AAf?$AAB?$AAi?$AAt?$AAs?$AAU?$AAs?$AAe?$AAd?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB 'n'
	DB	00H, 'u', 00H, 'm', 00H, 'b', 00H, 'e', 00H, 'r', 00H, 'O', 00H
	DB	'f', 00H, 'B', 00H, 'i', 00H, 't', 00H, 's', 00H, 'U', 00H, 's'
	DB	00H, 'e', 00H, 'd', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??CopyData@BitStream@RakNet@@QBEHPAPAE@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??CopyData@BitStream@RakNet@@QBEHPAPAE@Z@4JA DD 02c8H ; `RakNet::BitStream::CopyData'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_08FAMLAKGK@No?5bits?6?$AA@
CONST	SEGMENT
??_C@_08FAMLAKGK@No?5bits?6?$AA@ DB 'No bits', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DO@BPODHJKO@?$AAr?$AAe?$AAa?$AAd?$AAO?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAn?$AAu?$AAm?$AAb?$AAe?$AAr?$AAO?$AAf?$AAB?$AAi?$AAt?$AAs?$AAU?$AAs?$AAe?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1DO@BPODHJKO@?$AAr?$AAe?$AAa?$AAd?$AAO?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAn?$AAu?$AAm?$AAb?$AAe?$AAr?$AAO?$AAf?$AAB?$AAi?$AAt?$AAs?$AAU?$AAs?$AAe?$AAd?$AA?$AA@ DB 'r'
	DB	00H, 'e', 00H, 'a', 00H, 'd', 00H, 'O', 00H, 'f', 00H, 'f', 00H
	DB	's', 00H, 'e', 00H, 't', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, 'n', 00H, 'u', 00H, 'm', 00H, 'b', 00H, 'e', 00H, 'r', 00H
	DB	'O', 00H, 'f', 00H, 'B', 00H, 'i', 00H, 't', 00H, 's', 00H, 'U'
	DB	00H, 's', 00H, 'e', 00H, 'd', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??AssertStreamEmpty@BitStream@RakNet@@QAEXXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?1??AssertStreamEmpty@BitStream@RakNet@@QAEXXZ@4JA DD 02a1H ; `RakNet::BitStream::AssertStreamEmpty'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1CC@HCNGKMKC@?$AAc?$AAo?$AAp?$AAy?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAr?$AAu?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@HCNGKMKC@?$AAc?$AAo?$AAp?$AAy?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAr?$AAu?$AAe?$AA?$AA@ DB 'c'
	DB	00H, 'o', 00H, 'p', 00H, 'y', 00H, 'D', 00H, 'a', 00H, 't', 00H
	DB	'a', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 't', 00H, 'r'
	DB	00H, 'u', 00H, 'e', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??AddBitsAndReallocate@BitStream@RakNet@@QAEXH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??AddBitsAndReallocate@BitStream@RakNet@@QAEXH@Z@4JA DD 0273H ; `RakNet::BitStream::AddBitsAndReallocate'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1CO@BNPNFPEM@?$AAn?$AAu?$AAm?$AAb?$AAe?$AAr?$AAO?$AAf?$AAB?$AAi?$AAt?$AAs?$AAT?$AAo?$AAR?$AAe?$AAa?$AAd?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@BNPNFPEM@?$AAn?$AAu?$AAm?$AAb?$AAe?$AAr?$AAO?$AAf?$AAB?$AAi?$AAt?$AAs?$AAT?$AAo?$AAR?$AAe?$AAa?$AAd?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB 'n'
	DB	00H, 'u', 00H, 'm', 00H, 'b', 00H, 'e', 00H, 'r', 00H, 'O', 00H
	DB	'f', 00H, 'B', 00H, 'i', 00H, 't', 00H, 's', 00H, 'T', 00H, 'o'
	DB	00H, 'R', 00H, 'e', 00H, 'a', 00H, 'd', 00H, ' ', 00H, '>', 00H
	DB	' ', 00H, '0', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??ReadBits@BitStream@RakNet@@QAE_NPAEH_N@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??ReadBits@BitStream@RakNet@@QAE_NPAEH_N@Z@4JA DD 01f4H ; `RakNet::BitStream::ReadBits'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1DA@DCBJKEEH@?$AAn?$AAu?$AAm?$AAb?$AAe?$AAr?$AAO?$AAf?$AAB?$AAy?$AAt?$AAe?$AAs?$AAT?$AAo?$AAR?$AAe?$AAa?$AAd?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@DCBJKEEH@?$AAn?$AAu?$AAm?$AAb?$AAe?$AAr?$AAO?$AAf?$AAB?$AAy?$AAt?$AAe?$AAs?$AAT?$AAo?$AAR?$AAe?$AAa?$AAd?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB 'n'
	DB	00H, 'u', 00H, 'm', 00H, 'b', 00H, 'e', 00H, 'r', 00H, 'O', 00H
	DB	'f', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H, 'T'
	DB	00H, 'o', 00H, 'R', 00H, 'e', 00H, 'a', 00H, 'd', 00H, ' ', 00H
	DB	'>', 00H, ' ', 00H, '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??ReadAlignedBytes@BitStream@RakNet@@QAE_NPAEH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??ReadAlignedBytes@BitStream@RakNet@@QAE_NPAEH@Z@4JA DD 0159H ; `RakNet::BitStream::ReadAlignedBytes'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1DC@JEEOABPC@?$AAn?$AAu?$AAm?$AAb?$AAe?$AAr?$AAO?$AAf?$AAB?$AAy?$AAt?$AAe?$AAs?$AAT?$AAo?$AAW?$AAr?$AAi?$AAt?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@JEEOABPC@?$AAn?$AAu?$AAm?$AAb?$AAe?$AAr?$AAO?$AAf?$AAB?$AAy?$AAt?$AAe?$AAs?$AAT?$AAo?$AAW?$AAr?$AAi?$AAt?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB 'n'
	DB	00H, 'u', 00H, 'm', 00H, 'b', 00H, 'e', 00H, 'r', 00H, 'O', 00H
	DB	'f', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H, 'T'
	DB	00H, 'o', 00H, 'W', 00H, 'r', 00H, 'i', 00H, 't', 00H, 'e', 00H
	DB	' ', 00H, '>', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??WriteAlignedBytes@BitStream@RakNet@@QAEXPBEH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??WriteAlignedBytes@BitStream@RakNet@@QAEXPBEH@Z@4JA DD 014cH ; `RakNet::BitStream::WriteAlignedBytes'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1GO@EPGHOGFD@?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AAI?$AAn?$AAB?$AAi?$AAt?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA?$CI?$AA?5?$AAu?$AAn?$AAs?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AAi?$AAn?$AAt?$AA?5?$AA?$CJ@
CONST	SEGMENT
??_C@_1GO@EPGHOGFD@?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AAI?$AAn?$AAB?$AAi?$AAt?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA?$CI?$AA?5?$AAu?$AAn?$AAs?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AAi?$AAn?$AAt?$AA?5?$AA?$CJ@ DB 'l'
	DB	00H, 'e', 00H, 'n', 00H, 'g', 00H, 't', 00H, 'h', 00H, 'I', 00H
	DB	'n', 00H, 'B', 00H, 'i', 00H, 't', 00H, 's', 00H, ' ', 00H, '>'
	DB	00H, '=', 00H, ' ', 00H, '(', 00H, ' ', 00H, 'u', 00H, 'n', 00H
	DB	's', 00H, 'i', 00H, 'g', 00H, 'n', 00H, 'e', 00H, 'd', 00H, ' '
	DB	00H, 'i', 00H, 'n', 00H, 't', 00H, ' ', 00H, ')', 00H, ' ', 00H
	DB	'n', 00H, 'u', 00H, 'm', 00H, 'b', 00H, 'e', 00H, 'r', 00H, 'O'
	DB	00H, 'f', 00H, 'B', 00H, 'i', 00H, 't', 00H, 's', 00H, 'A', 00H
	DB	'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'e'
	DB	00H, 'd', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??SetNumberOfBitsAllocated@BitStream@RakNet@@QAEXI@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??SetNumberOfBitsAllocated@BitStream@RakNet@@QAEXI@Z@4JA DD 0a5H ; `RakNet::BitStream::SetNumberOfBitsAllocated'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1???0BitStream@RakNet@@QAE@PADI_N@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1???0BitStream@RakNet@@QAE@PADI_N@Z@4JA DD 080H ; `RakNet::BitStream::BitStream'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1???0BitStream@RakNet@@QAE@PAEI_N@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1???0BitStream@RakNet@@QAE@PAEI_N@Z@4JA DD 05fH ; `RakNet::BitStream::BitStream'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_19MLBBEMBH@?$AAd?$AAa?$AAt?$AAa?$AA?$AA@
CONST	SEGMENT
??_C@_19MLBBEMBH@?$AAd?$AAa?$AAt?$AAa?$AA?$AA@ DB 'd', 00H, 'a', 00H, 't', 00H
	DB	'a', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1EM@DFHCFFCB@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAb?$AAi?$AAt?$AAs?$AAt?$AAr?$AAe?$AAa@
CONST	SEGMENT
??_C@_1EM@DFHCFFCB@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAb?$AAi?$AAt?$AAs?$AAt?$AAr?$AAe?$AAa@ DB 'z'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H
	DB	's', 00H, 'r', 00H, 'c', 00H, '\', 00H, '0', 00H, '2', 00H, 'x'
	DB	00H, 'u', 00H, '1', 00H, '\', 00H, 'r', 00H, 'a', 00H, 'k', 00H
	DB	'n', 00H, 'e', 00H, 't', 00H, '\', 00H, 'b', 00H, 'i', 00H, 't'
	DB	00H, 's', 00H, 't', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'm', 00H
	DB	'.', 00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1???0BitStream@RakNet@@QAE@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1???0BitStream@RakNet@@QAE@H@Z@4JA DD 04aH ; `RakNet::BitStream::BitStream'::`2'::__LINE__Var
_DATA	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z
_TEXT	SEGMENT
tv82 = -208						; size = 4
_this$ = -8						; size = 4
_var$ = 8						; size = 4
??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z PROC		; RakNet::BitStream::Read<bool>, COMDAT
; _this$ = ecx

; 1019 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1020 : 		if ( readOffset + 1 > numberOfBitsUsed )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [edx]
	jle	SHORT $LN3@Read

; 1021 : 			return false;

	xor	al, al
	jmp	SHORT $LN4@Read
$LN3@Read:

; 1022 : 
; 1023 : 		if ( data[ readOffset >> 3 ] & ( 0x80 >> ( readOffset++ % 8 ) ) )   // Is it faster to just write it out here?

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sar	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	movzx	edx, BYTE PTR [eax+ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -2147483641			; 80000007H
	jns	SHORT $LN6@Read
	dec	ecx
	or	ecx, -8					; fffffff8H
	inc	ecx
$LN6@Read:
	mov	eax, 128				; 00000080H
	sar	eax, cl
	and	edx, eax
	mov	DWORD PTR tv82[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx
	cmp	DWORD PTR tv82[ebp], 0
	je	SHORT $LN2@Read

; 1024 : 			var = true;

	mov	eax, DWORD PTR _var$[ebp]
	mov	BYTE PTR [eax], 1

; 1025 : 		else

	jmp	SHORT $LN1@Read
$LN2@Read:

; 1026 : 			var = false;

	mov	eax, DWORD PTR _var$[ebp]
	mov	BYTE PTR [eax], 0
$LN1@Read:

; 1027 : 
; 1028 : 		return true;

	mov	al, 1
$LN4@Read:

; 1029 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z ENDP		; RakNet::BitStream::Read<bool>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Write@_N@BitStream@RakNet@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 1
??$Write@_N@BitStream@RakNet@@QAEX_N@Z PROC		; RakNet::BitStream::Write<bool>, COMDAT
; _this$ = ecx

; 754  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 755  : 		if ( var )

	movzx	eax, BYTE PTR _var$[ebp]
	test	eax, eax
	je	SHORT $LN2@Write

; 756  : 			Write1();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Write1@BitStream@RakNet@@QAEXXZ	; RakNet::BitStream::Write1

; 757  : 		else

	jmp	SHORT $LN3@Write
$LN2@Write:

; 758  : 			Write0();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Write0@BitStream@RakNet@@QAEXXZ	; RakNet::BitStream::Write0
$LN3@Write:

; 759  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$Write@_N@BitStream@RakNet@@QAEX_N@Z ENDP		; RakNet::BitStream::Write<bool>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.cpp
;	COMDAT ?DoEndianSwap@BitStream@RakNet@@ABE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?DoEndianSwap@BitStream@RakNet@@ABE_NXZ PROC		; RakNet::BitStream::DoEndianSwap, COMDAT
; _this$ = ecx

; 806  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 807  : #ifndef __BITSTREAM_NATIVE_END
; 808  : 	static bool swap=htonl(12345) == 12345;
; 809  : 	return swap;
; 810  : #else
; 811  : 	return false;

	xor	al, al

; 812  : #endif
; 813  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DoEndianSwap@BitStream@RakNet@@ABE_NXZ ENDP		; RakNet::BitStream::DoEndianSwap
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.cpp
;	COMDAT ?ReverseBytes@BitStream@RakNet@@AAEXPAE0H@Z
_TEXT	SEGMENT
_i$1 = -20						; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
_output$ = 12						; size = 4
_length$ = 16						; size = 4
?ReverseBytes@BitStream@RakNet@@AAEXPAE0H@Z PROC	; RakNet::BitStream::ReverseBytes, COMDAT
; _this$ = ecx

; 801  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 802  : 	for (int i=0; i < length; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN3@ReverseByt
$LN2@ReverseByt:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN3@ReverseByt:
	mov	eax, DWORD PTR _i$1[ebp]
	cmp	eax, DWORD PTR _length$[ebp]
	jge	SHORT $LN4@ReverseByt

; 803  : 		output[i]=input[length-i-1];

	mov	eax, DWORD PTR _length$[ebp]
	sub	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _output$[ebp]
	add	ecx, DWORD PTR _i$1[ebp]
	mov	edx, DWORD PTR _input$[ebp]
	mov	al, BYTE PTR [edx+eax-1]
	mov	BYTE PTR [ecx], al
	jmp	SHORT $LN2@ReverseByt
$LN4@ReverseByt:

; 804  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?ReverseBytes@BitStream@RakNet@@AAEXPAE0H@Z ENDP	; RakNet::BitStream::ReverseBytes
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.cpp
;	COMDAT ?ReadCompressed@BitStream@RakNet@@AAE_NPAEH_N@Z
_TEXT	SEGMENT
_b$ = -65						; size = 1
_b$1 = -53						; size = 1
_halfByteMatch$ = -41					; size = 1
_byteMatch$ = -29					; size = 1
_currentByte$ = -20					; size = 4
_this$ = -8						; size = 4
_output$ = 8						; size = 4
_size$ = 12						; size = 4
_unsignedData$ = 16					; size = 1
?ReadCompressed@BitStream@RakNet@@AAE_NPAEH_N@Z PROC	; RakNet::BitStream::ReadCompressed, COMDAT
; _this$ = ecx

; 552  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 553  : 	int currentByte = ( size >> 3 ) - 1;

	mov	eax, DWORD PTR _size$[ebp]
	sar	eax, 3
	sub	eax, 1
	mov	DWORD PTR _currentByte$[ebp], eax

; 554  : 	
; 555  : 	
; 556  : 	unsigned char byteMatch, halfByteMatch;
; 557  : 	
; 558  : 	if ( unsignedData )

	movzx	eax, BYTE PTR _unsignedData$[ebp]
	test	eax, eax
	je	SHORT $LN14@ReadCompre

; 559  : 	{
; 560  : 		byteMatch = 0;

	mov	BYTE PTR _byteMatch$[ebp], 0

; 561  : 		halfByteMatch = 0;

	mov	BYTE PTR _halfByteMatch$[ebp], 0

; 562  : 	}
; 563  : 	
; 564  : 	else

	jmp	SHORT $LN12@ReadCompre
$LN14@ReadCompre:

; 565  : 	{
; 566  : 		byteMatch = 0xFF;

	mov	BYTE PTR _byteMatch$[ebp], 255		; 000000ffH

; 567  : 		halfByteMatch = 0xF0;

	mov	BYTE PTR _halfByteMatch$[ebp], 240	; 000000f0H
$LN12@ReadCompre:

; 568  : 	}
; 569  : 	
; 570  : 	// Upper bytes are specified with a single 1 if they match byteMatch
; 571  : 	// From high byte to low byte, if high byte is a byteMatch then write a 1 bit. Otherwise write a 0 bit and then write the remaining bytes
; 572  : 	while ( currentByte > 0 )

	cmp	DWORD PTR _currentByte$[ebp], 0
	jle	SHORT $LN11@ReadCompre

; 573  : 	{
; 574  : 		// If we read a 1 then the data is byteMatch.
; 575  : 		
; 576  : 		bool b;
; 577  : 		
; 578  : 		if ( Read( b ) == false )

	lea	eax, DWORD PTR _b$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z ; RakNet::BitStream::Read<bool>
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN10@ReadCompre

; 579  : 			return false;

	xor	al, al
	jmp	$LN15@ReadCompre
$LN10@ReadCompre:

; 580  : 			
; 581  : 		if ( b )   // Check that bit

	movzx	eax, BYTE PTR _b$1[ebp]
	test	eax, eax
	je	SHORT $LN9@ReadCompre

; 582  : 		{
; 583  : 			output[ currentByte ] = byteMatch;

	mov	eax, DWORD PTR _output$[ebp]
	add	eax, DWORD PTR _currentByte$[ebp]
	mov	cl, BYTE PTR _byteMatch$[ebp]
	mov	BYTE PTR [eax], cl

; 584  : 			currentByte--;

	mov	eax, DWORD PTR _currentByte$[ebp]
	sub	eax, 1
	mov	DWORD PTR _currentByte$[ebp], eax

; 585  : 		}
; 586  : 		else

	jmp	SHORT $LN8@ReadCompre
$LN9@ReadCompre:

; 587  : 		{
; 588  : 			// Read the rest of the bytes
; 589  : 			
; 590  : 			if ( ReadBits( output, ( currentByte + 1 ) << 3 ) == false )

	push	1
	mov	eax, DWORD PTR _currentByte$[ebp]
	lea	ecx, DWORD PTR [eax*8+8]
	push	ecx
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadBits@BitStream@RakNet@@QAE_NPAEH_N@Z ; RakNet::BitStream::ReadBits
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN7@ReadCompre

; 591  : 				return false;

	xor	al, al
	jmp	$LN15@ReadCompre
$LN7@ReadCompre:

; 592  : 				
; 593  : 			return true;

	mov	al, 1
	jmp	$LN15@ReadCompre
$LN8@ReadCompre:

; 594  : 		}
; 595  : 	}

	jmp	SHORT $LN12@ReadCompre
$LN11@ReadCompre:

; 596  : 	
; 597  : 	// All but the first bytes are byteMatch.  If the upper half of the last byte is a 0 (positive) or 16 (negative) then what we read will be a 1 and the remaining 4 bits.
; 598  : 	// Otherwise we read a 0 and the 8 bytes
; 599  : 	//assert(readOffset+1 <=numberOfBitsUsed); // If this assert is hit the stream wasn't long enough to read from
; 600  : 	if ( readOffset + 1 > numberOfBitsUsed )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [edx]
	jle	SHORT $LN6@ReadCompre

; 601  : 		return false;

	xor	al, al
	jmp	SHORT $LN15@ReadCompre
$LN6@ReadCompre:

; 602  : 		
; 603  : 	bool b;
; 604  : 	
; 605  : 	if ( Read( b ) == false )

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z ; RakNet::BitStream::Read<bool>
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN5@ReadCompre

; 606  : 		return false;

	xor	al, al
	jmp	SHORT $LN15@ReadCompre
$LN5@ReadCompre:

; 607  : 		
; 608  : 	if ( b )   // Check that bit

	movzx	eax, BYTE PTR _b$[ebp]
	test	eax, eax
	je	SHORT $LN4@ReadCompre

; 609  : 	{
; 610  : 	
; 611  : 		if ( ReadBits( output + currentByte, 4 ) == false )

	push	1
	push	4
	mov	eax, DWORD PTR _output$[ebp]
	add	eax, DWORD PTR _currentByte$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadBits@BitStream@RakNet@@QAE_NPAEH_N@Z ; RakNet::BitStream::ReadBits
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@ReadCompre

; 612  : 			return false;

	xor	al, al
	jmp	SHORT $LN15@ReadCompre
$LN3@ReadCompre:

; 613  : 			
; 614  : 		output[ currentByte ] |= halfByteMatch; // We have to set the high 4 bits since these are set to 0 by ReadBits

	movzx	eax, BYTE PTR _halfByteMatch$[ebp]
	mov	ecx, DWORD PTR _output$[ebp]
	add	ecx, DWORD PTR _currentByte$[ebp]
	movzx	edx, BYTE PTR [ecx]
	or	edx, eax
	mov	eax, DWORD PTR _output$[ebp]
	add	eax, DWORD PTR _currentByte$[ebp]
	mov	BYTE PTR [eax], dl

; 615  : 	}
; 616  : 	else

	jmp	SHORT $LN2@ReadCompre
$LN4@ReadCompre:

; 617  : 	{
; 618  : 		if ( ReadBits( output + currentByte, 8 ) == false )

	push	1
	push	8
	mov	eax, DWORD PTR _output$[ebp]
	add	eax, DWORD PTR _currentByte$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadBits@BitStream@RakNet@@QAE_NPAEH_N@Z ; RakNet::BitStream::ReadBits
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@ReadCompre

; 619  : 			return false;

	xor	al, al
	jmp	SHORT $LN15@ReadCompre
$LN2@ReadCompre:

; 620  : 	}
; 621  : 	
; 622  : 	return true;

	mov	al, 1
$LN15@ReadCompre:

; 623  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN20@ReadCompre
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN20@ReadCompre:
	DD	2
	DD	$LN19@ReadCompre
$LN19@ReadCompre:
	DD	-53					; ffffffcbH
	DD	1
	DD	$LN17@ReadCompre
	DD	-65					; ffffffbfH
	DD	1
	DD	$LN18@ReadCompre
$LN18@ReadCompre:
	DB	98					; 00000062H
	DB	0
$LN17@ReadCompre:
	DB	98					; 00000062H
	DB	0
?ReadCompressed@BitStream@RakNet@@AAE_NPAEH_N@Z ENDP	; RakNet::BitStream::ReadCompressed
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.cpp
;	COMDAT ?WriteCompressed@BitStream@RakNet@@AAEXPBEH_N@Z
_TEXT	SEGMENT
_b$1 = -77						; size = 1
_b$2 = -65						; size = 1
_b$3 = -53						; size = 1
_b$4 = -41						; size = 1
_byteMatch$ = -29					; size = 1
_currentByte$ = -20					; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
_size$ = 12						; size = 4
_unsignedData$ = 16					; size = 1
?WriteCompressed@BitStream@RakNet@@AAEXPBEH_N@Z PROC	; RakNet::BitStream::WriteCompressed, COMDAT
; _this$ = ecx

; 439  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-276]
	mov	ecx, 69					; 00000045H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 440  : 	int currentByte = ( size >> 3 ) - 1; // PCs

	mov	eax, DWORD PTR _size$[ebp]
	sar	eax, 3
	sub	eax, 1
	mov	DWORD PTR _currentByte$[ebp], eax

; 441  : 	
; 442  : 	unsigned char byteMatch;
; 443  : 	
; 444  : 	if ( unsignedData )

	movzx	eax, BYTE PTR _unsignedData$[ebp]
	test	eax, eax
	je	SHORT $LN10@WriteCompr

; 445  : 	{
; 446  : 		byteMatch = 0;

	mov	BYTE PTR _byteMatch$[ebp], 0

; 447  : 	}
; 448  : 	
; 449  : 	else

	jmp	SHORT $LN8@WriteCompr
$LN10@WriteCompr:

; 450  : 	{
; 451  : 		byteMatch = 0xFF;

	mov	BYTE PTR _byteMatch$[ebp], 255		; 000000ffH
$LN8@WriteCompr:

; 452  : 	}
; 453  : 	
; 454  : 	// Write upper bytes with a single 1
; 455  : 	// From high byte to low byte, if high byte is a byteMatch then write a 1 bit. Otherwise write a 0 bit and then write the remaining bytes
; 456  : 	while ( currentByte > 0 )

	cmp	DWORD PTR _currentByte$[ebp], 0
	jle	SHORT $LN7@WriteCompr

; 457  : 	{
; 458  : 		if ( input[ currentByte ] == byteMatch )   // If high byte is byteMatch (0 of 0xff) then it would have the same value shifted

	mov	eax, DWORD PTR _input$[ebp]
	add	eax, DWORD PTR _currentByte$[ebp]
	movzx	ecx, BYTE PTR [eax]
	movzx	edx, BYTE PTR _byteMatch$[ebp]
	cmp	ecx, edx
	jne	SHORT $LN6@WriteCompr

; 459  : 		{
; 460  : 			bool b = true;

	mov	BYTE PTR _b$4[ebp], 1

; 461  : 			Write( b );

	movzx	eax, BYTE PTR _b$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$Write@_N@BitStream@RakNet@@QAEX_N@Z	; RakNet::BitStream::Write<bool>

; 462  : 		}
; 463  : 		else

	jmp	SHORT $LN5@WriteCompr
$LN6@WriteCompr:

; 464  : 		{
; 465  : 			// Write the remainder of the data after writing 0
; 466  : 			bool b = false;

	mov	BYTE PTR _b$3[ebp], 0

; 467  : 			Write( b );

	movzx	eax, BYTE PTR _b$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$Write@_N@BitStream@RakNet@@QAEX_N@Z	; RakNet::BitStream::Write<bool>

; 468  : 			
; 469  : 			WriteBits( input, ( currentByte + 1 ) << 3, true );

	push	1
	mov	eax, DWORD PTR _currentByte$[ebp]
	lea	ecx, DWORD PTR [eax*8+8]
	push	ecx
	mov	edx, DWORD PTR _input$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z ; RakNet::BitStream::WriteBits

; 470  : 			//  currentByte--;
; 471  : 			
; 472  : 			
; 473  : 			return ;

	jmp	$LN11@WriteCompr
$LN5@WriteCompr:

; 474  : 		}
; 475  : 		
; 476  : 		currentByte--;

	mov	eax, DWORD PTR _currentByte$[ebp]
	sub	eax, 1
	mov	DWORD PTR _currentByte$[ebp], eax

; 477  : 	}

	jmp	SHORT $LN8@WriteCompr
$LN7@WriteCompr:

; 478  : 	
; 479  : 	// If the upper half of the last byte is a 0 (positive) or 16 (negative) then write a 1 and the remaining 4 bits.  Otherwise write a 0 and the 8 bites.
; 480  : 	if ( ( unsignedData && ( ( *( input + currentByte ) ) & 0xF0 ) == 0x00 ) ||
; 481  : 		( unsignedData == false && ( ( *( input + currentByte ) ) & 0xF0 ) == 0xF0 ) )

	movzx	eax, BYTE PTR _unsignedData$[ebp]
	test	eax, eax
	je	SHORT $LN2@WriteCompr
	mov	eax, DWORD PTR _input$[ebp]
	add	eax, DWORD PTR _currentByte$[ebp]
	movzx	ecx, BYTE PTR [eax]
	and	ecx, 240				; 000000f0H
	je	SHORT $LN3@WriteCompr
$LN2@WriteCompr:
	movzx	eax, BYTE PTR _unsignedData$[ebp]
	test	eax, eax
	jne	SHORT $LN4@WriteCompr
	mov	eax, DWORD PTR _input$[ebp]
	add	eax, DWORD PTR _currentByte$[ebp]
	movzx	ecx, BYTE PTR [eax]
	and	ecx, 240				; 000000f0H
	cmp	ecx, 240				; 000000f0H
	jne	SHORT $LN4@WriteCompr
$LN3@WriteCompr:

; 482  : 	{
; 483  : 		bool b = true;

	mov	BYTE PTR _b$2[ebp], 1

; 484  : 		Write( b );

	movzx	eax, BYTE PTR _b$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$Write@_N@BitStream@RakNet@@QAEX_N@Z	; RakNet::BitStream::Write<bool>

; 485  : 		WriteBits( input + currentByte, 4, true );

	push	1
	push	4
	mov	eax, DWORD PTR _input$[ebp]
	add	eax, DWORD PTR _currentByte$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z ; RakNet::BitStream::WriteBits

; 486  : 	}
; 487  : 	
; 488  : 	else

	jmp	SHORT $LN11@WriteCompr
$LN4@WriteCompr:

; 489  : 	{
; 490  : 		bool b = false;

	mov	BYTE PTR _b$1[ebp], 0

; 491  : 		Write( b );

	movzx	eax, BYTE PTR _b$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$Write@_N@BitStream@RakNet@@QAEX_N@Z	; RakNet::BitStream::Write<bool>

; 492  : 		WriteBits( input + currentByte, 8, true );

	push	1
	push	8
	mov	eax, DWORD PTR _input$[ebp]
	add	eax, DWORD PTR _currentByte$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z ; RakNet::BitStream::WriteBits
$LN11@WriteCompr:

; 493  : 	}
; 494  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?WriteCompressed@BitStream@RakNet@@AAEXPBEH_N@Z ENDP	; RakNet::BitStream::WriteCompressed
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.cpp
;	COMDAT ?AddBitsAndReallocate@BitStream@RakNet@@QAEXH@Z
_TEXT	SEGMENT
_amountToAllocate$1 = -32				; size = 4
_newNumberOfBitsAllocated$ = -20			; size = 4
_this$ = -8						; size = 4
_numberOfBitsToWrite$ = 8				; size = 4
?AddBitsAndReallocate@BitStream@RakNet@@QAEXH@Z PROC	; RakNet::BitStream::AddBitsAndReallocate, COMDAT
; _this$ = ecx

; 627  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 	if (numberOfBitsToWrite <= 0)

	cmp	DWORD PTR _numberOfBitsToWrite$[ebp], 0
	jg	SHORT $LN6@AddBitsAnd

; 629  : 		return;

	jmp	$LN7@AddBitsAnd
$LN6@AddBitsAnd:

; 630  : 
; 631  : 	int newNumberOfBitsAllocated = numberOfBitsToWrite + numberOfBitsUsed;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _numberOfBitsToWrite$[ebp]
	add	ecx, DWORD PTR [eax]
	mov	DWORD PTR _newNumberOfBitsAllocated$[ebp], ecx

; 632  : 	
; 633  : 	if ( numberOfBitsToWrite + numberOfBitsUsed > 0 && ( ( numberOfBitsAllocated - 1 ) >> 3 ) < ( ( newNumberOfBitsAllocated - 1 ) >> 3 ) )   // If we need to allocate 1 or more new bytes

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _numberOfBitsToWrite$[ebp]
	add	ecx, DWORD PTR [eax]
	test	ecx, ecx
	jle	$LN5@AddBitsAnd
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	sar	ecx, 3
	mov	edx, DWORD PTR _newNumberOfBitsAllocated$[ebp]
	sub	edx, 1
	sar	edx, 3
	cmp	ecx, edx
	jge	$LN5@AddBitsAnd

; 634  : 	{
; 635  : #ifdef _DEBUG
; 636  : 		// If this assert hits then we need to specify true for the third parameter in the constructor
; 637  : 		// It needs to reallocate to hold all the data and can't do it unless we allocated to begin with
; 638  : 		assert( copyData == true );

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+16]
	cmp	ecx, 1
	je	SHORT $LN9@AddBitsAnd
	mov	edx, DWORD PTR ?__LINE__Var@?1??AddBitsAndReallocate@BitStream@RakNet@@QAEXH@Z@4JA
	add	edx, 11					; 0000000bH
	push	edx
	push	OFFSET ??_C@_1EM@DFHCFFCB@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAb?$AAi?$AAt?$AAs?$AAt?$AAr?$AAe?$AAa@
	push	OFFSET ??_C@_1CC@HCNGKMKC@?$AAc?$AAo?$AAp?$AAy?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAr?$AAu?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN9@AddBitsAnd:

; 639  : #endif
; 640  : 
; 641  : 		// Less memory efficient but saves on news and deletes
; 642  : 		newNumberOfBitsAllocated = ( numberOfBitsToWrite + numberOfBitsUsed ) * 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _numberOfBitsToWrite$[ebp]
	add	ecx, DWORD PTR [eax]
	shl	ecx, 1
	mov	DWORD PTR _newNumberOfBitsAllocated$[ebp], ecx

; 643  : //		int newByteOffset = BITS_TO_BYTES( numberOfBitsAllocated );
; 644  : 		// Use realloc and free so we are more efficient than delete and new for resizing
; 645  : 		int amountToAllocate = BITS_TO_BYTES( newNumberOfBitsAllocated );

	mov	eax, DWORD PTR _newNumberOfBitsAllocated$[ebp]
	add	eax, 7
	sar	eax, 3
	mov	DWORD PTR _amountToAllocate$1[ebp], eax

; 646  : 		if (data==(unsigned char*)stackData)

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 17					; 00000011H
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], eax
	jne	SHORT $LN4@AddBitsAnd

; 647  : 		{
; 648  : 			 if (amountToAllocate > BITSTREAM_STACK_ALLOCATION_SIZE)

	cmp	DWORD PTR _amountToAllocate$1[ebp], 256	; 00000100H
	jle	SHORT $LN3@AddBitsAnd

; 649  : 			 {
; 650  : 				 data = ( unsigned char* ) malloc( amountToAllocate );

	mov	eax, DWORD PTR _amountToAllocate$1[ebp]
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 651  : 
; 652  : 				 // need to copy the stack data over to our new memory area too
; 653  : 				 memcpy ((void *)data, (void *)stackData, BITS_TO_BYTES( numberOfBitsAllocated )); 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 7
	sar	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 17					; 00000011H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN3@AddBitsAnd:

; 654  : 			 }
; 655  : 		}
; 656  : 		else

	jmp	SHORT $LN2@AddBitsAnd
$LN4@AddBitsAnd:

; 657  : 		{
; 658  : 			data = ( unsigned char* ) realloc( data, amountToAllocate );

	mov	eax, DWORD PTR _amountToAllocate$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	_realloc
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax
$LN2@AddBitsAnd:

; 659  : 		}
; 660  : 
; 661  : #ifdef _DEBUG
; 662  : 		assert( data ); // Make sure realloc succeeded

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN5@AddBitsAnd
	mov	ecx, DWORD PTR ?__LINE__Var@?1??AddBitsAndReallocate@BitStream@RakNet@@QAEXH@Z@4JA
	add	ecx, 35					; 00000023H
	push	ecx
	push	OFFSET ??_C@_1EM@DFHCFFCB@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAb?$AAi?$AAt?$AAs?$AAt?$AAr?$AAe?$AAa@
	push	OFFSET ??_C@_19MLBBEMBH@?$AAd?$AAa?$AAt?$AAa?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN5@AddBitsAnd:

; 663  : #endif
; 664  : 		//  memset(data+newByteOffset, 0,  ((newNumberOfBitsAllocated-1)>>3) - ((numberOfBitsAllocated-1)>>3)); // Set the new data block to 0
; 665  : 	}
; 666  : 	
; 667  : 	if ( newNumberOfBitsAllocated > numberOfBitsAllocated )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newNumberOfBitsAllocated$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jle	SHORT $LN7@AddBitsAnd

; 668  : 		numberOfBitsAllocated = newNumberOfBitsAllocated;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newNumberOfBitsAllocated$[ebp]
	mov	DWORD PTR [eax+4], ecx
$LN7@AddBitsAnd:

; 669  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?AddBitsAndReallocate@BitStream@RakNet@@QAEXH@Z ENDP	; RakNet::BitStream::AddBitsAndReallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.cpp
;	COMDAT ?SetNumberOfBitsAllocated@BitStream@RakNet@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_lengthInBits$ = 8					; size = 4
?SetNumberOfBitsAllocated@BitStream@RakNet@@QAEXI@Z PROC ; RakNet::BitStream::SetNumberOfBitsAllocated, COMDAT
; _this$ = ecx

; 165  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 166  : #ifdef _DEBUG
; 167  : 	assert( lengthInBits >= ( unsigned int ) numberOfBitsAllocated );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _lengthInBits$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN3@SetNumberO
	mov	edx, DWORD PTR ?__LINE__Var@?1??SetNumberOfBitsAllocated@BitStream@RakNet@@QAEXI@Z@4JA
	add	edx, 2
	push	edx
	push	OFFSET ??_C@_1EM@DFHCFFCB@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAb?$AAi?$AAt?$AAs?$AAt?$AAr?$AAe?$AAa@
	push	OFFSET ??_C@_1GO@EPGHOGFD@?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AAI?$AAn?$AAB?$AAi?$AAt?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA?$CI?$AA?5?$AAu?$AAn?$AAs?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AAi?$AAn?$AAt?$AA?5?$AA?$CJ@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@SetNumberO:

; 168  : #endif	
; 169  : 	numberOfBitsAllocated = lengthInBits;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _lengthInBits$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 170  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetNumberOfBitsAllocated@BitStream@RakNet@@QAEXI@Z ENDP ; RakNet::BitStream::SetNumberOfBitsAllocated
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.cpp
;	COMDAT ?AssertCopyData@BitStream@RakNet@@QAEXXZ
_TEXT	SEGMENT
_newdata$1 = -20					; size = 4
_this$ = -8						; size = 4
?AssertCopyData@BitStream@RakNet@@QAEXXZ PROC		; RakNet::BitStream::AssertCopyData, COMDAT
; _this$ = ecx

; 779  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 780  : 	if ( copyData == false )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+16]
	test	ecx, ecx
	jne	$LN4@AssertCopy

; 781  : 	{
; 782  : 		copyData = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+16], 1

; 783  : 		
; 784  : 		if ( numberOfBitsAllocated > 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jle	SHORT $LN2@AssertCopy

; 785  : 		{
; 786  : 			unsigned char * newdata = ( unsigned char* ) malloc( BITS_TO_BYTES( numberOfBitsAllocated ) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 7
	sar	ecx, 3
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _newdata$1[ebp], eax

; 787  : #ifdef _DEBUG
; 788  : 			
; 789  : 			assert( data );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN6@AssertCopy
	mov	ecx, DWORD PTR ?__LINE__Var@?1??AssertCopyData@BitStream@RakNet@@QAEXXZ@4JA
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET ??_C@_1EM@DFHCFFCB@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAb?$AAi?$AAt?$AAs?$AAt?$AAr?$AAe?$AAa@
	push	OFFSET ??_C@_19MLBBEMBH@?$AAd?$AAa?$AAt?$AAa?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN6@AssertCopy:

; 790  : #endif
; 791  : 			
; 792  : 			memcpy( newdata, data, BITS_TO_BYTES( numberOfBitsAllocated ) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 7
	sar	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _newdata$1[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 793  : 			data = newdata;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newdata$1[ebp]
	mov	DWORD PTR [eax+12], ecx

; 794  : 		}
; 795  : 		
; 796  : 		else

	jmp	SHORT $LN4@AssertCopy
$LN2@AssertCopy:

; 797  : 			data = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
$LN4@AssertCopy:

; 798  : 	}
; 799  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?AssertCopyData@BitStream@RakNet@@QAEXXZ ENDP		; RakNet::BitStream::AssertCopyData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.cpp
;	COMDAT ?ReadBit@BitStream@RakNet@@QAE_NXZ
_TEXT	SEGMENT
tv80 = -209						; size = 1
tv79 = -208						; size = 4
_this$ = -8						; size = 4
?ReadBit@BitStream@RakNet@@QAE_NXZ PROC			; RakNet::BitStream::ReadBit, COMDAT
; _this$ = ecx

; 323  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 212				; 000000d4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-212]
	mov	ecx, 53					; 00000035H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 324  : 	return ( bool ) ( data[ readOffset >> 3 ] & ( 0x80 >> ( readOffset++ & 7 ) ) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sar	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	movzx	edx, BYTE PTR [eax+ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 7
	mov	eax, 128				; 00000080H
	sar	eax, cl
	and	edx, eax
	mov	DWORD PTR tv79[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx
	cmp	DWORD PTR tv79[ebp], 0
	je	SHORT $LN3@ReadBit
	mov	BYTE PTR tv80[ebp], 1
	jmp	SHORT $LN4@ReadBit
$LN3@ReadBit:
	mov	BYTE PTR tv80[ebp], 0
$LN4@ReadBit:
	mov	al, BYTE PTR tv80[ebp]

; 325  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadBit@BitStream@RakNet@@QAE_NXZ ENDP			; RakNet::BitStream::ReadBit
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.cpp
;	COMDAT ?Write1@BitStream@RakNet@@QAEXXZ
_TEXT	SEGMENT
_numberOfBitsMod8$ = -20				; size = 4
_this$ = -8						; size = 4
?Write1@BitStream@RakNet@@QAEXXZ PROC			; RakNet::BitStream::Write1, COMDAT
; _this$ = ecx

; 305  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 306  : 	AddBitsAndReallocate( 1 );

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddBitsAndReallocate@BitStream@RakNet@@QAEXH@Z ; RakNet::BitStream::AddBitsAndReallocate

; 307  : 	
; 308  : 	int numberOfBitsMod8 = numberOfBitsUsed & 7;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 7
	mov	DWORD PTR _numberOfBitsMod8$[ebp], ecx

; 309  : 	
; 310  : 	if ( numberOfBitsMod8 == 0 )

	jne	SHORT $LN2@Write1

; 311  : 		data[ numberOfBitsUsed >> 3 ] = 0x80;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sar	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	BYTE PTR [eax+ecx], 128			; 00000080H

; 312  : 	else

	jmp	SHORT $LN1@Write1
$LN2@Write1:

; 313  : 		data[ numberOfBitsUsed >> 3 ] |= 0x80 >> ( numberOfBitsMod8 ); // Set the bit to 1

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	sar	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	mov	esi, 128				; 00000080H
	mov	ecx, DWORD PTR _numberOfBitsMod8$[ebp]
	sar	esi, cl
	movzx	ecx, BYTE PTR [eax+edx]
	or	ecx, esi
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	sar	eax, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+12]
	mov	BYTE PTR [edx+eax], cl
$LN1@Write1:

; 314  : 		
; 315  : 	numberOfBitsUsed++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 316  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Write1@BitStream@RakNet@@QAEXXZ ENDP			; RakNet::BitStream::Write1
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.cpp
;	COMDAT ?Write0@BitStream@RakNet@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Write0@BitStream@RakNet@@QAEXXZ PROC			; RakNet::BitStream::Write0, COMDAT
; _this$ = ecx

; 293  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 294  : 	AddBitsAndReallocate( 1 );

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddBitsAndReallocate@BitStream@RakNet@@QAEXH@Z ; RakNet::BitStream::AddBitsAndReallocate

; 295  : 	
; 296  : 	// New bytes need to be zeroed
; 297  : 	if ( ( numberOfBitsUsed & 7 ) == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 7
	jne	SHORT $LN1@Write0

; 298  : 		data[ numberOfBitsUsed >> 3 ] = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sar	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	BYTE PTR [eax+ecx], 0
$LN1@Write0:

; 299  : 		
; 300  : 	numberOfBitsUsed++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 301  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Write0@BitStream@RakNet@@QAEXXZ ENDP			; RakNet::BitStream::Write0
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.cpp
;	COMDAT ?ReadBits@BitStream@RakNet@@QAE_NPAEH_N@Z
_TEXT	SEGMENT
_offset$ = -32						; size = 4
_readOffsetMod8$ = -20					; size = 4
_this$ = -8						; size = 4
_output$ = 8						; size = 4
_numberOfBitsToRead$ = 12				; size = 4
_alignBitsToRight$ = 16					; size = 1
?ReadBits@BitStream@RakNet@@QAE_NPAEH_N@Z PROC		; RakNet::BitStream::ReadBits, COMDAT
; _this$ = ecx

; 500  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 501  : #ifdef _DEBUG
; 502  : 	assert( numberOfBitsToRead > 0 );

	cmp	DWORD PTR _numberOfBitsToRead$[ebp], 0
	jg	SHORT $LN11@ReadBits
	mov	eax, DWORD PTR ?__LINE__Var@?1??ReadBits@BitStream@RakNet@@QAE_NPAEH_N@Z@4JA
	add	eax, 2
	push	eax
	push	OFFSET ??_C@_1EM@DFHCFFCB@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAb?$AAi?$AAt?$AAs?$AAt?$AAr?$AAe?$AAa@
	push	OFFSET ??_C@_1CO@BNPNFPEM@?$AAn?$AAu?$AAm?$AAb?$AAe?$AAr?$AAO?$AAf?$AAB?$AAi?$AAt?$AAs?$AAT?$AAo?$AAR?$AAe?$AAa?$AAd?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN11@ReadBits:

; 503  : #endif
; 504  : 	if (numberOfBitsToRead<=0)

	cmp	DWORD PTR _numberOfBitsToRead$[ebp], 0
	jg	SHORT $LN8@ReadBits

; 505  : 	  return false;

	xor	al, al
	jmp	$LN9@ReadBits
$LN8@ReadBits:

; 506  : 	
; 507  : 	if ( readOffset + numberOfBitsToRead > numberOfBitsUsed )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _numberOfBitsToRead$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [edx]
	jle	SHORT $LN7@ReadBits

; 508  : 		return false;

	xor	al, al
	jmp	$LN9@ReadBits
$LN7@ReadBits:

; 509  : 		
; 510  : 	int readOffsetMod8;
; 511  : 	
; 512  : 	int offset = 0;

	mov	DWORD PTR _offset$[ebp], 0

; 513  : 	
; 514  : 	memset( output, 0, BITS_TO_BYTES( numberOfBitsToRead ) );

	mov	eax, DWORD PTR _numberOfBitsToRead$[ebp]
	add	eax, 7
	sar	eax, 3
	push	eax
	push	0
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 515  : 	
; 516  : 	readOffsetMod8 = readOffset & 7;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 7
	mov	DWORD PTR _readOffsetMod8$[ebp], ecx
$LN6@ReadBits:

; 517  : 	
; 518  : 	// do
; 519  : 	// Faster to put the while at the top surprisingly enough
; 520  : 	while ( numberOfBitsToRead > 0 )

	cmp	DWORD PTR _numberOfBitsToRead$[ebp], 0
	jle	$LN5@ReadBits

; 521  : 	{
; 522  : 		*( output + offset ) |= *( data + ( readOffset >> 3 ) ) << ( readOffsetMod8 ); // First half

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sar	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	movzx	edx, BYTE PTR [eax+ecx]
	mov	ecx, DWORD PTR _readOffsetMod8$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _output$[ebp]
	add	eax, DWORD PTR _offset$[ebp]
	movzx	ecx, BYTE PTR [eax]
	or	ecx, edx
	mov	edx, DWORD PTR _output$[ebp]
	add	edx, DWORD PTR _offset$[ebp]
	mov	BYTE PTR [edx], cl

; 523  : 		
; 524  : 		if ( readOffsetMod8 > 0 && numberOfBitsToRead > 8 - ( readOffsetMod8 ) )   // If we have a second half, we didn't read enough bytes in the first half

	cmp	DWORD PTR _readOffsetMod8$[ebp], 0
	jle	SHORT $LN4@ReadBits
	mov	eax, 8
	sub	eax, DWORD PTR _readOffsetMod8$[ebp]
	cmp	DWORD PTR _numberOfBitsToRead$[ebp], eax
	jle	SHORT $LN4@ReadBits

; 525  : 			*( output + offset ) |= *( data + ( readOffset >> 3 ) + 1 ) >> ( 8 - ( readOffsetMod8 ) ); // Second half (overlaps byte boundary)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sar	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	movzx	edx, BYTE PTR [eax+ecx+1]
	mov	ecx, 8
	sub	ecx, DWORD PTR _readOffsetMod8$[ebp]
	sar	edx, cl
	mov	eax, DWORD PTR _output$[ebp]
	add	eax, DWORD PTR _offset$[ebp]
	movzx	ecx, BYTE PTR [eax]
	or	ecx, edx
	mov	edx, DWORD PTR _output$[ebp]
	add	edx, DWORD PTR _offset$[ebp]
	mov	BYTE PTR [edx], cl
$LN4@ReadBits:

; 526  : 			
; 527  : 		numberOfBitsToRead -= 8;

	mov	eax, DWORD PTR _numberOfBitsToRead$[ebp]
	sub	eax, 8
	mov	DWORD PTR _numberOfBitsToRead$[ebp], eax

; 528  : 		
; 529  : 		if ( numberOfBitsToRead < 0 )   // Reading a partial byte for the last byte, shift right so the data is aligned on the right

	jns	SHORT $LN3@ReadBits

; 530  : 		{
; 531  : 		
; 532  : 			if ( alignBitsToRight )

	movzx	eax, BYTE PTR _alignBitsToRight$[ebp]
	test	eax, eax
	je	SHORT $LN2@ReadBits

; 533  : 				* ( output + offset ) >>= -numberOfBitsToRead;

	mov	ecx, DWORD PTR _numberOfBitsToRead$[ebp]
	neg	ecx
	mov	eax, DWORD PTR _output$[ebp]
	add	eax, DWORD PTR _offset$[ebp]
	mov	dl, BYTE PTR [eax]
	shr	dl, cl
	mov	eax, DWORD PTR _output$[ebp]
	add	eax, DWORD PTR _offset$[ebp]
	mov	BYTE PTR [eax], dl
$LN2@ReadBits:

; 534  : 				
; 535  : 			readOffset += 8 + numberOfBitsToRead;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _numberOfBitsToRead$[ebp]
	lea	eax, DWORD PTR [edx+ecx+8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 536  : 		}
; 537  : 		else

	jmp	SHORT $LN1@ReadBits
$LN3@ReadBits:

; 538  : 			readOffset += 8;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN1@ReadBits:

; 539  : 			
; 540  : 		offset++;

	mov	eax, DWORD PTR _offset$[ebp]
	add	eax, 1
	mov	DWORD PTR _offset$[ebp], eax

; 541  : 		
; 542  : 	}

	jmp	$LN6@ReadBits
$LN5@ReadBits:

; 543  : 	
; 544  : 	//} while(numberOfBitsToRead>0);
; 545  : 	
; 546  : 	return true;

	mov	al, 1
$LN9@ReadBits:

; 547  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?ReadBits@BitStream@RakNet@@QAE_NPAEH_N@Z ENDP		; RakNet::BitStream::ReadBits
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.cpp
;	COMDAT ?AlignReadToByteBoundary@BitStream@RakNet@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?AlignReadToByteBoundary@BitStream@RakNet@@QAEXXZ PROC	; RakNet::BitStream::AlignReadToByteBoundary, COMDAT
; _this$ = ecx

; 376  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 	if ( readOffset )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN2@AlignReadT

; 378  : 		readOffset += 8 - ( (( readOffset - 1 ) & 7 ) + 1 );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, 1
	and	ecx, 7
	add	ecx, 1
	mov	edx, 8
	sub	edx, ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN2@AlignReadT:

; 379  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AlignReadToByteBoundary@BitStream@RakNet@@QAEXXZ ENDP	; RakNet::BitStream::AlignReadToByteBoundary
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.cpp
;	COMDAT ?AlignWriteToByteBoundary@BitStream@RakNet@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?AlignWriteToByteBoundary@BitStream@RakNet@@QAEXXZ PROC	; RakNet::BitStream::AlignWriteToByteBoundary, COMDAT
; _this$ = ecx

; 369  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 370  : 	if ( numberOfBitsUsed )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@AlignWrite

; 371  : 		numberOfBitsUsed += 8 - ( (( numberOfBitsUsed - 1 ) & 7) + 1 );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	and	ecx, 7
	add	ecx, 1
	mov	edx, 8
	sub	edx, ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], edx
$LN2@AlignWrite:

; 372  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AlignWriteToByteBoundary@BitStream@RakNet@@QAEXXZ ENDP	; RakNet::BitStream::AlignWriteToByteBoundary
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.cpp
;	COMDAT ?ReadAlignedBytes@BitStream@RakNet@@QAE_NPAEH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_output$ = 8						; size = 4
_numberOfBytesToRead$ = 12				; size = 4
?ReadAlignedBytes@BitStream@RakNet@@QAE_NPAEH@Z PROC	; RakNet::BitStream::ReadAlignedBytes, COMDAT
; _this$ = ecx

; 345  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 346  : #ifdef _DEBUG
; 347  : 	assert( numberOfBytesToRead > 0 );

	cmp	DWORD PTR _numberOfBytesToRead$[ebp], 0
	jg	SHORT $LN5@ReadAligne
	mov	eax, DWORD PTR ?__LINE__Var@?1??ReadAlignedBytes@BitStream@RakNet@@QAE_NPAEH@Z@4JA
	add	eax, 2
	push	eax
	push	OFFSET ??_C@_1EM@DFHCFFCB@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAb?$AAi?$AAt?$AAs?$AAt?$AAr?$AAe?$AAa@
	push	OFFSET ??_C@_1DA@DCBJKEEH@?$AAn?$AAu?$AAm?$AAb?$AAe?$AAr?$AAO?$AAf?$AAB?$AAy?$AAt?$AAe?$AAs?$AAT?$AAo?$AAR?$AAe?$AAa?$AAd?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN5@ReadAligne:

; 348  : #endif
; 349  : 	
; 350  : 	if ( numberOfBytesToRead <= 0 )

	cmp	DWORD PTR _numberOfBytesToRead$[ebp], 0
	jg	SHORT $LN2@ReadAligne

; 351  : 		return false;

	xor	al, al
	jmp	SHORT $LN3@ReadAligne
$LN2@ReadAligne:

; 352  : 		
; 353  : 	// Byte align
; 354  : 	AlignReadToByteBoundary();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AlignReadToByteBoundary@BitStream@RakNet@@QAEXXZ ; RakNet::BitStream::AlignReadToByteBoundary

; 355  : 
; 356  : 	if ( readOffset + ( numberOfBytesToRead << 3 ) > numberOfBitsUsed )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _numberOfBytesToRead$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [ecx]
	jle	SHORT $LN1@ReadAligne

; 357  : 		return false;

	xor	al, al
	jmp	SHORT $LN3@ReadAligne
$LN1@ReadAligne:

; 358  : 
; 359  : 	// Write the data
; 360  : 	memcpy( output, data + ( readOffset >> 3 ), numberOfBytesToRead );

	mov	eax, DWORD PTR _numberOfBytesToRead$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sar	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+12]
	push	edx
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 361  : 	
; 362  : 	readOffset += numberOfBytesToRead << 3;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _numberOfBytesToRead$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 363  : 	
; 364  : 	return true;

	mov	al, 1
$LN3@ReadAligne:

; 365  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?ReadAlignedBytes@BitStream@RakNet@@QAE_NPAEH@Z ENDP	; RakNet::BitStream::ReadAlignedBytes
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.cpp
;	COMDAT ?WriteAlignedBytes@BitStream@RakNet@@QAEXPBEH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_input$ = 8						; size = 4
_numberOfBytesToWrite$ = 12				; size = 4
?WriteAlignedBytes@BitStream@RakNet@@QAEXPBEH@Z PROC	; RakNet::BitStream::WriteAlignedBytes, COMDAT
; _this$ = ecx

; 332  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 333  : #ifdef _DEBUG
; 334  : 	assert( numberOfBytesToWrite > 0 );

	cmp	DWORD PTR _numberOfBytesToWrite$[ebp], 0
	jg	SHORT $LN3@WriteAlign
	mov	eax, DWORD PTR ?__LINE__Var@?1??WriteAlignedBytes@BitStream@RakNet@@QAEXPBEH@Z@4JA
	add	eax, 2
	push	eax
	push	OFFSET ??_C@_1EM@DFHCFFCB@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAb?$AAi?$AAt?$AAs?$AAt?$AAr?$AAe?$AAa@
	push	OFFSET ??_C@_1DC@JEEOABPC@?$AAn?$AAu?$AAm?$AAb?$AAe?$AAr?$AAO?$AAf?$AAB?$AAy?$AAt?$AAe?$AAs?$AAT?$AAo?$AAW?$AAr?$AAi?$AAt?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@WriteAlign:

; 335  : #endif
; 336  : 	
; 337  : 	AlignWriteToByteBoundary();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AlignWriteToByteBoundary@BitStream@RakNet@@QAEXXZ ; RakNet::BitStream::AlignWriteToByteBoundary

; 338  : 	Write((const char*) input, numberOfBytesToWrite);

	mov	eax, DWORD PTR _numberOfBytesToWrite$[ebp]
	push	eax
	mov	ecx, DWORD PTR _input$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Write@BitStream@RakNet@@QAEXPBDH@Z	; RakNet::BitStream::Write

; 339  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?WriteAlignedBytes@BitStream@RakNet@@QAEXPBEH@Z ENDP	; RakNet::BitStream::WriteAlignedBytes
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.cpp
;	COMDAT ?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z
_TEXT	SEGMENT
_numberOfBitsUsedMod8$ = -44				; size = 4
_dataByte$ = -29					; size = 1
_offset$ = -20						; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
_numberOfBitsToWrite$ = 12				; size = 4
_rightAlignedBits$ = 16					; size = 1
?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z PROC		; RakNet::BitStream::WriteBits, COMDAT
; _this$ = ecx

; 383  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 384  : 	if (numberOfBitsToWrite<=0)

	cmp	DWORD PTR _numberOfBitsToWrite$[ebp], 0
	jg	SHORT $LN9@WriteBits

; 385  : 		return;

	jmp	$LN10@WriteBits
$LN9@WriteBits:

; 386  : 	
; 387  : 	AddBitsAndReallocate( numberOfBitsToWrite );

	mov	eax, DWORD PTR _numberOfBitsToWrite$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddBitsAndReallocate@BitStream@RakNet@@QAEXH@Z ; RakNet::BitStream::AddBitsAndReallocate

; 388  : 	int offset = 0;

	mov	DWORD PTR _offset$[ebp], 0

; 389  : 	unsigned char dataByte;
; 390  : 	int numberOfBitsUsedMod8;
; 391  : 	
; 392  : 	numberOfBitsUsedMod8 = numberOfBitsUsed & 7;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 7
	mov	DWORD PTR _numberOfBitsUsedMod8$[ebp], ecx
$LN8@WriteBits:

; 393  : 	
; 394  : 	// Faster to put the while at the top surprisingly enough
; 395  : 	while ( numberOfBitsToWrite > 0 )

	cmp	DWORD PTR _numberOfBitsToWrite$[ebp], 0
	jle	$LN10@WriteBits

; 396  : 		//do
; 397  : 	{
; 398  : 		dataByte = *( input + offset );

	mov	eax, DWORD PTR _input$[ebp]
	add	eax, DWORD PTR _offset$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _dataByte$[ebp], cl

; 399  : 		
; 400  : 		if ( numberOfBitsToWrite < 8 && rightAlignedBits )   // rightAlignedBits means in the case of a partial byte, the bits are aligned from the right (bit 0) rather than the left (as in the normal internal representation)

	cmp	DWORD PTR _numberOfBitsToWrite$[ebp], 8
	jge	SHORT $LN6@WriteBits
	movzx	eax, BYTE PTR _rightAlignedBits$[ebp]
	test	eax, eax
	je	SHORT $LN6@WriteBits

; 401  : 			dataByte <<= 8 - numberOfBitsToWrite;  // shift left to get the bits on the left, as in our internal representation

	mov	ecx, 8
	sub	ecx, DWORD PTR _numberOfBitsToWrite$[ebp]
	mov	al, BYTE PTR _dataByte$[ebp]
	shl	al, cl
	mov	BYTE PTR _dataByte$[ebp], al
$LN6@WriteBits:

; 402  : 			
; 403  : 		// Writing to a new byte each time
; 404  : 		if ( numberOfBitsUsedMod8 == 0 )

	cmp	DWORD PTR _numberOfBitsUsedMod8$[ebp], 0
	jne	SHORT $LN5@WriteBits

; 405  : 			* ( data + ( numberOfBitsUsed >> 3 ) ) = dataByte;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sar	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	dl, BYTE PTR _dataByte$[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 406  : 		else

	jmp	SHORT $LN4@WriteBits
$LN5@WriteBits:

; 407  : 		{
; 408  : 			// Copy over the new data.
; 409  : 			*( data + ( numberOfBitsUsed >> 3 ) ) |= dataByte >> ( numberOfBitsUsedMod8 ); // First half

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	sar	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	movzx	esi, BYTE PTR _dataByte$[ebp]
	mov	ecx, DWORD PTR _numberOfBitsUsedMod8$[ebp]
	sar	esi, cl
	movzx	ecx, BYTE PTR [eax+edx]
	or	ecx, esi
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	sar	eax, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+12]
	mov	BYTE PTR [eax+edx], cl

; 410  : 			
; 411  : 			if ( 8 - ( numberOfBitsUsedMod8 ) < 8 && 8 - ( numberOfBitsUsedMod8 ) < numberOfBitsToWrite )   // If we didn't write it all out in the first half (8 - (numberOfBitsUsed%8) is the number we wrote in the first half)

	mov	eax, 8
	sub	eax, DWORD PTR _numberOfBitsUsedMod8$[ebp]
	cmp	eax, 8
	jge	SHORT $LN4@WriteBits
	mov	eax, 8
	sub	eax, DWORD PTR _numberOfBitsUsedMod8$[ebp]
	cmp	eax, DWORD PTR _numberOfBitsToWrite$[ebp]
	jge	SHORT $LN4@WriteBits

; 412  : 			{
; 413  : 				*( data + ( numberOfBitsUsed >> 3 ) + 1 ) = (unsigned char) ( dataByte << ( 8 - ( numberOfBitsUsedMod8 ) ) ); // Second half (overlaps byte boundary)

	movzx	eax, BYTE PTR _dataByte$[ebp]
	mov	ecx, 8
	sub	ecx, DWORD PTR _numberOfBitsUsedMod8$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	sar	edx, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	mov	BYTE PTR [ecx+edx+1], al
$LN4@WriteBits:

; 414  : 			}
; 415  : 		}
; 416  : 		
; 417  : 		if ( numberOfBitsToWrite >= 8 )

	cmp	DWORD PTR _numberOfBitsToWrite$[ebp], 8
	jl	SHORT $LN2@WriteBits

; 418  : 			numberOfBitsUsed += 8;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 419  : 		else

	jmp	SHORT $LN1@WriteBits
$LN2@WriteBits:

; 420  : 			numberOfBitsUsed += numberOfBitsToWrite;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _numberOfBitsToWrite$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@WriteBits:

; 421  : 		
; 422  : 		numberOfBitsToWrite -= 8;

	mov	eax, DWORD PTR _numberOfBitsToWrite$[ebp]
	sub	eax, 8
	mov	DWORD PTR _numberOfBitsToWrite$[ebp], eax

; 423  : 		
; 424  : 		offset++;

	mov	eax, DWORD PTR _offset$[ebp]
	add	eax, 1
	mov	DWORD PTR _offset$[ebp], eax

; 425  : 	}

	jmp	$LN8@WriteBits
$LN10@WriteBits:

; 426  : 	// } while(numberOfBitsToWrite>0);
; 427  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z ENDP		; RakNet::BitStream::WriteBits
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.cpp
;	COMDAT ?SetData@BitStream@RakNet@@QAEXPAE@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_input$ = 8						; size = 4
?SetData@BitStream@RakNet@@QAEXPAE@Z PROC		; RakNet::BitStream::SetData, COMDAT
; _this$ = ecx

; 431  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 432  : 	data=input;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _input$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 433  : 	copyData=false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+16], 0

; 434  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetData@BitStream@RakNet@@QAEXPAE@Z ENDP		; RakNet::BitStream::SetData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.cpp
;	COMDAT ?CopyData@BitStream@RakNet@@QBEHPAPAE@Z
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
__data$ = 8						; size = 4
?CopyData@BitStream@RakNet@@QBEHPAPAE@Z PROC		; RakNet::BitStream::CopyData, COMDAT
; _this$ = ecx

; 712  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 713  : #ifdef _DEBUG
; 714  : 	assert( numberOfBitsUsed > 0 );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jg	SHORT $LN3@CopyData
	mov	ecx, DWORD PTR ?__LINE__Var@?1??CopyData@BitStream@RakNet@@QBEHPAPAE@Z@4JA
	add	ecx, 2
	push	ecx
	push	OFFSET ??_C@_1EM@DFHCFFCB@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAb?$AAi?$AAt?$AAs?$AAt?$AAr?$AAe?$AAa@
	push	OFFSET ??_C@_1CK@KPLFMFLB@?$AAn?$AAu?$AAm?$AAb?$AAe?$AAr?$AAO?$AAf?$AAB?$AAi?$AAt?$AAs?$AAU?$AAs?$AAe?$AAd?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@CopyData:

; 715  : #endif
; 716  : 	
; 717  : 	*_data = new unsigned char [ BITS_TO_BYTES( numberOfBitsUsed ) ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 7
	sar	ecx, 3
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	edx, DWORD PTR __data$[ebp]
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR [edx], eax

; 718  : 	memcpy( *_data, data, sizeof(unsigned char) * ( BITS_TO_BYTES( numberOfBitsUsed ) ) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 7
	sar	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR __data$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 719  : 	return numberOfBitsUsed;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 720  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?CopyData@BitStream@RakNet@@QBEHPAPAE@Z ENDP		; RakNet::BitStream::CopyData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ?GetWriteOffset@BitStream@RakNet@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetWriteOffset@BitStream@RakNet@@QBEHXZ PROC		; RakNet::BitStream::GetWriteOffset, COMDAT
; _this$ = ecx

; 370  : 		inline int GetWriteOffset( void ) const {return numberOfBitsUsed;}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWriteOffset@BitStream@RakNet@@QBEHXZ ENDP		; RakNet::BitStream::GetWriteOffset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ PROC	; RakNet::BitStream::GetNumberOfBitsUsed, COMDAT
; _this$ = ecx

; 369  : 		inline int GetNumberOfBitsUsed( void ) const {return GetWriteOffset();}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetWriteOffset@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetWriteOffset
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ ENDP	; RakNet::BitStream::GetNumberOfBitsUsed
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.cpp
;	COMDAT ?SetWriteOffset@BitStream@RakNet@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_offset$ = 8						; size = 4
?SetWriteOffset@BitStream@RakNet@@QAEXH@Z PROC		; RakNet::BitStream::SetWriteOffset, COMDAT
; _this$ = ecx

; 730  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 	numberOfBitsUsed = offset;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _offset$[ebp]
	mov	DWORD PTR [eax], ecx

; 732  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetWriteOffset@BitStream@RakNet@@QAEXH@Z ENDP		; RakNet::BitStream::SetWriteOffset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.cpp
;	COMDAT ?IgnoreBits@BitStream@RakNet@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_numberOfBits$ = 8					; size = 4
?IgnoreBits@BitStream@RakNet@@QAEXH@Z PROC		; RakNet::BitStream::IgnoreBits, COMDAT
; _this$ = ecx

; 724  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 725  : 	readOffset += numberOfBits;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _numberOfBits$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 726  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IgnoreBits@BitStream@RakNet@@QAEXH@Z ENDP		; RakNet::BitStream::IgnoreBits
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.cpp
;	COMDAT ?PrintBits@BitStream@RakNet@@QBEXXZ
_TEXT	SEGMENT
_counter2$1 = -44					; size = 4
_stop$2 = -32						; size = 4
_counter$3 = -20					; size = 4
_this$ = -8						; size = 4
?PrintBits@BitStream@RakNet@@QBEXXZ PROC		; RakNet::BitStream::PrintBits, COMDAT
; _this$ = ecx

; 678  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 679  : 	if ( numberOfBitsUsed <= 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jg	SHORT $LN11@PrintBits

; 680  : 	{
; 681  : 		printf( "No bits\n" );

	push	OFFSET ??_C@_08FAMLAKGK@No?5bits?6?$AA@
	call	_printf
	add	esp, 4

; 682  : 		return ;

	jmp	$LN12@PrintBits
$LN11@PrintBits:

; 683  : 	}
; 684  : 	
; 685  : 	for ( int counter = 0; counter < BITS_TO_BYTES( numberOfBitsUsed ); counter++ )

	mov	DWORD PTR _counter$3[ebp], 0
	jmp	SHORT $LN10@PrintBits
$LN9@PrintBits:
	mov	eax, DWORD PTR _counter$3[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$3[ebp], eax
$LN10@PrintBits:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 7
	sar	ecx, 3
	cmp	DWORD PTR _counter$3[ebp], ecx
	jge	$LN8@PrintBits

; 686  : 	{
; 687  : 		int stop;
; 688  : 		
; 689  : 		if ( counter == ( numberOfBitsUsed - 1 ) >> 3 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	sar	ecx, 3
	cmp	DWORD PTR _counter$3[ebp], ecx
	jne	SHORT $LN7@PrintBits

; 690  : 			stop = 8 - ( ( ( numberOfBitsUsed - 1 ) & 7 ) + 1 );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	and	ecx, 7
	add	ecx, 1
	mov	edx, 8
	sub	edx, ecx
	mov	DWORD PTR _stop$2[ebp], edx

; 691  : 		else

	jmp	SHORT $LN6@PrintBits
$LN7@PrintBits:

; 692  : 			stop = 0;

	mov	DWORD PTR _stop$2[ebp], 0
$LN6@PrintBits:

; 693  : 			
; 694  : 		for ( int counter2 = 7; counter2 >= stop; counter2-- )

	mov	DWORD PTR _counter2$1[ebp], 7
	jmp	SHORT $LN5@PrintBits
$LN4@PrintBits:
	mov	eax, DWORD PTR _counter2$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _counter2$1[ebp], eax
$LN5@PrintBits:
	mov	eax, DWORD PTR _counter2$1[ebp]
	cmp	eax, DWORD PTR _stop$2[ebp]
	jl	SHORT $LN3@PrintBits

; 695  : 		{
; 696  : 			if ( ( data[ counter ] >> counter2 ) & 1 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _counter$3[ebp]
	movzx	eax, BYTE PTR [ecx+edx]
	mov	ecx, DWORD PTR _counter2$1[ebp]
	sar	eax, cl
	and	eax, 1
	je	SHORT $LN2@PrintBits

; 697  : 				putchar( '1' );

	push	49					; 00000031H
	call	_putchar
	add	esp, 4

; 698  : 			else

	jmp	SHORT $LN1@PrintBits
$LN2@PrintBits:

; 699  : 				putchar( '0' );

	push	48					; 00000030H
	call	_putchar
	add	esp, 4
$LN1@PrintBits:

; 700  : 		}

	jmp	SHORT $LN4@PrintBits
$LN3@PrintBits:

; 701  : 		
; 702  : 		putchar( ' ' );

	push	32					; 00000020H
	call	_putchar
	add	esp, 4

; 703  : 	}

	jmp	$LN9@PrintBits
$LN8@PrintBits:

; 704  : 	
; 705  : 	putchar( '\n' );

	push	10					; 0000000aH
	call	_putchar
	add	esp, 4
$LN12@PrintBits:

; 706  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?PrintBits@BitStream@RakNet@@QBEXXZ ENDP		; RakNet::BitStream::PrintBits
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.cpp
;	COMDAT ?AssertStreamEmpty@BitStream@RakNet@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?AssertStreamEmpty@BitStream@RakNet@@QAEXXZ PROC	; RakNet::BitStream::AssertStreamEmpty, COMDAT
; _this$ = ecx

; 673  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 674  : 	assert( readOffset == numberOfBitsUsed );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx]
	je	SHORT $LN1@AssertStre
	mov	eax, DWORD PTR ?__LINE__Var@?1??AssertStreamEmpty@BitStream@RakNet@@QAEXXZ@4JA
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_1EM@DFHCFFCB@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAb?$AAi?$AAt?$AAs?$AAt?$AAr?$AAe?$AAa@
	push	OFFSET ??_C@_1DO@BPODHJKO@?$AAr?$AAe?$AAa?$AAd?$AAO?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAn?$AAu?$AAm?$AAb?$AAe?$AAr?$AAO?$AAf?$AAB?$AAi?$AAt?$AAs?$AAU?$AAs?$AAe?$AAd?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN1@AssertStre:

; 675  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?AssertStreamEmpty@BitStream@RakNet@@QAEXXZ ENDP	; RakNet::BitStream::AssertStreamEmpty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.cpp
;	COMDAT ?ResetWritePointer@BitStream@RakNet@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?ResetWritePointer@BitStream@RakNet@@QAEXXZ PROC	; RakNet::BitStream::ResetWritePointer, COMDAT
; _this$ = ecx

; 287  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 288  : 	numberOfBitsUsed = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 289  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetWritePointer@BitStream@RakNet@@QAEXXZ ENDP	; RakNet::BitStream::ResetWritePointer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.cpp
;	COMDAT ?ResetReadPointer@BitStream@RakNet@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?ResetReadPointer@BitStream@RakNet@@QAEXXZ PROC		; RakNet::BitStream::ResetReadPointer, COMDAT
; _this$ = ecx

; 281  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 282  : 	readOffset = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 283  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetReadPointer@BitStream@RakNet@@QAEXXZ ENDP		; RakNet::BitStream::ResetReadPointer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.cpp
;	COMDAT ?Read@BitStream@RakNet@@QAE_NPADH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_output$ = 8						; size = 4
_numberOfBytes$ = 12					; size = 4
?Read@BitStream@RakNet@@QAE_NPADH@Z PROC		; RakNet::BitStream::Read, COMDAT
; _this$ = ecx

; 260  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 261  : 	// Optimization:
; 262  : 	if ((readOffset & 7) == 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 7
	jne	SHORT $LN3@Read

; 263  : 	{
; 264  : 		if ( readOffset + ( numberOfBytes << 3 ) > numberOfBitsUsed )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _numberOfBytes$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [ecx]
	jle	SHORT $LN2@Read

; 265  : 			return false;

	xor	al, al
	jmp	SHORT $LN4@Read
$LN2@Read:

; 266  : 
; 267  : 		// Write the data
; 268  : 		memcpy( output, data + ( readOffset >> 3 ), numberOfBytes );

	mov	eax, DWORD PTR _numberOfBytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sar	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+12]
	push	edx
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 269  : 
; 270  : 		readOffset += numberOfBytes << 3;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _numberOfBytes$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 271  : 		return true;

	mov	al, 1
	jmp	SHORT $LN4@Read

; 272  : 	}
; 273  : 	else

	jmp	SHORT $LN4@Read
$LN3@Read:

; 274  : 	{
; 275  : 		return ReadBits( ( unsigned char* ) output, numberOfBytes * 8 );

	push	1
	mov	eax, DWORD PTR _numberOfBytes$[ebp]
	shl	eax, 3
	push	eax
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadBits@BitStream@RakNet@@QAE_NPAEH_N@Z ; RakNet::BitStream::ReadBits
$LN4@Read:

; 276  : 	}
; 277  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?Read@BitStream@RakNet@@QAE_NPADH@Z ENDP		; RakNet::BitStream::Read
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.cpp
;	COMDAT ?Write@BitStream@RakNet@@QAEXPAV12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_bitStream$ = 8						; size = 4
?Write@BitStream@RakNet@@QAEXPAV12@@Z PROC		; RakNet::BitStream::Write, COMDAT
; _this$ = ecx

; 221  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 222  : 	Write(bitStream, bitStream->GetNumberOfBitsUsed());

	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBitsUsed
	push	eax
	mov	eax, DWORD PTR _bitStream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Write@BitStream@RakNet@@QAEXPAV12@H@Z	; RakNet::BitStream::Write

; 223  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Write@BitStream@RakNet@@QAEXPAV12@@Z ENDP		; RakNet::BitStream::Write
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.cpp
;	COMDAT ?Write@BitStream@RakNet@@QAEXPAV12@H@Z
_TEXT	SEGMENT
tv69 = -224						; size = 4
tv150 = -220						; size = 4
tv91 = -220						; size = 4
tv68 = -220						; size = 4
_numberOfBitsMod8$ = -20				; size = 4
_this$ = -8						; size = 4
_bitStream$ = 8						; size = 4
_numberOfBits$ = 12					; size = 4
?Write@BitStream@RakNet@@QAEXPAV12@H@Z PROC		; RakNet::BitStream::Write, COMDAT
; _this$ = ecx

; 225  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 224				; 000000e0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-224]
	mov	ecx, 56					; 00000038H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 226  : 	AddBitsAndReallocate( numberOfBits );

	mov	eax, DWORD PTR _numberOfBits$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddBitsAndReallocate@BitStream@RakNet@@QAEXH@Z ; RakNet::BitStream::AddBitsAndReallocate
$LN7@Write:

; 227  : 	int numberOfBitsMod8;
; 228  : 
; 229  : 	while (numberOfBits-->0 && bitStream->readOffset + 1 <= bitStream->numberOfBitsUsed)

	mov	eax, DWORD PTR _numberOfBits$[ebp]
	mov	DWORD PTR tv68[ebp], eax
	mov	ecx, DWORD PTR _numberOfBits$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _numberOfBits$[ebp], ecx
	cmp	DWORD PTR tv68[ebp], 0
	jle	SHORT $LN10@Write
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN11@Write
$LN10@Write:
	mov	DWORD PTR tv69[ebp], 0
$LN11@Write:
	cmp	DWORD PTR tv69[ebp], 0
	je	$LN8@Write
	mov	eax, DWORD PTR _bitStream$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _bitStream$[ebp]
	cmp	ecx, DWORD PTR [edx]
	jg	$LN8@Write

; 230  : 	{
; 231  : 		numberOfBitsMod8 = numberOfBitsUsed & 7;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 7
	mov	DWORD PTR _numberOfBitsMod8$[ebp], ecx

; 232  : 		if ( numberOfBitsMod8 == 0 )

	jne	SHORT $LN5@Write

; 233  : 		{
; 234  : 			// New byte
; 235  : 			if (bitStream->data[ bitStream->readOffset >> 3 ] & ( 0x80 >> ( bitStream->readOffset++ % 8 ) ) )

	mov	eax, DWORD PTR _bitStream$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sar	ecx, 3
	mov	edx, DWORD PTR _bitStream$[ebp]
	mov	eax, DWORD PTR [edx+12]
	movzx	edx, BYTE PTR [eax+ecx]
	mov	eax, DWORD PTR _bitStream$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -2147483641			; 80000007H
	jns	SHORT $LN12@Write
	dec	ecx
	or	ecx, -8					; fffffff8H
	inc	ecx
$LN12@Write:
	mov	eax, 128				; 00000080H
	sar	eax, cl
	and	edx, eax
	mov	DWORD PTR tv91[ebp], edx
	mov	ecx, DWORD PTR _bitStream$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, 1
	mov	eax, DWORD PTR _bitStream$[ebp]
	mov	DWORD PTR [eax+8], edx
	cmp	DWORD PTR tv91[ebp], 0
	je	SHORT $LN4@Write

; 236  : 			{
; 237  : 				// Write 1
; 238  : 				data[ numberOfBitsUsed >> 3 ] = 0x80;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sar	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	BYTE PTR [eax+ecx], 128			; 00000080H

; 239  : 			}
; 240  : 			else

	jmp	SHORT $LN3@Write
$LN4@Write:

; 241  : 			{
; 242  : 				// Write 0
; 243  : 				data[ numberOfBitsUsed >> 3 ] = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sar	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	BYTE PTR [eax+ecx], 0
$LN3@Write:

; 244  : 			}
; 245  : 		}
; 246  : 		else

	jmp	SHORT $LN2@Write
$LN5@Write:

; 247  : 		{
; 248  : 			// Existing byte
; 249  : 			if (bitStream->data[ bitStream->readOffset >> 3 ] & ( 0x80 >> ( bitStream->readOffset++ % 8 ) ) )

	mov	eax, DWORD PTR _bitStream$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sar	ecx, 3
	mov	edx, DWORD PTR _bitStream$[ebp]
	mov	eax, DWORD PTR [edx+12]
	movzx	edx, BYTE PTR [eax+ecx]
	mov	eax, DWORD PTR _bitStream$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -2147483641			; 80000007H
	jns	SHORT $LN13@Write
	dec	ecx
	or	ecx, -8					; fffffff8H
	inc	ecx
$LN13@Write:
	mov	eax, 128				; 00000080H
	sar	eax, cl
	and	edx, eax
	mov	DWORD PTR tv150[ebp], edx
	mov	ecx, DWORD PTR _bitStream$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, 1
	mov	eax, DWORD PTR _bitStream$[ebp]
	mov	DWORD PTR [eax+8], edx
	cmp	DWORD PTR tv150[ebp], 0
	je	SHORT $LN2@Write

; 250  : 				data[ numberOfBitsUsed >> 3 ] |= 0x80 >> ( numberOfBitsMod8 ); // Set the bit to 1

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	sar	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	mov	esi, 128				; 00000080H
	mov	ecx, DWORD PTR _numberOfBitsMod8$[ebp]
	sar	esi, cl
	movzx	ecx, BYTE PTR [eax+edx]
	or	ecx, esi
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	sar	eax, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+12]
	mov	BYTE PTR [edx+eax], cl
$LN2@Write:

; 251  : 			// else 0, do nothing
; 252  : 		}
; 253  : 
; 254  : 		numberOfBitsUsed++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 255  : 	}

	jmp	$LN7@Write
$LN8@Write:

; 256  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 224				; 000000e0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?Write@BitStream@RakNet@@QAEXPAV12@H@Z ENDP		; RakNet::BitStream::Write
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.cpp
;	COMDAT ?Write@BitStream@RakNet@@QAEXPBDH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_input$ = 8						; size = 4
_numberOfBytes$ = 12					; size = 4
?Write@BitStream@RakNet@@QAEXPBDH@Z PROC		; RakNet::BitStream::Write, COMDAT
; _this$ = ecx

; 203  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 	if (numberOfBytes==0)

	cmp	DWORD PTR _numberOfBytes$[ebp], 0
	jne	SHORT $LN3@Write

; 205  : 		return;

	jmp	SHORT $LN4@Write
$LN3@Write:

; 206  : 
; 207  : 	// Optimization:
; 208  : 	if ((numberOfBitsUsed & 7) == 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 7
	jne	SHORT $LN2@Write

; 209  : 	{
; 210  : 		AddBitsAndReallocate( BYTES_TO_BITS(numberOfBytes) );

	mov	eax, DWORD PTR _numberOfBytes$[ebp]
	shl	eax, 3
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddBitsAndReallocate@BitStream@RakNet@@QAEXH@Z ; RakNet::BitStream::AddBitsAndReallocate

; 211  : 		memcpy(data+BITS_TO_BYTES(numberOfBitsUsed), input, numberOfBytes);

	mov	eax, DWORD PTR _numberOfBytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _input$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 7
	sar	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+12]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 212  : 		numberOfBitsUsed+=BYTES_TO_BITS(numberOfBytes);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _numberOfBytes$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 213  : 	}
; 214  : 	else

	jmp	SHORT $LN4@Write
$LN2@Write:

; 215  : 	{
; 216  : 		WriteBits( ( unsigned char* ) input, numberOfBytes * 8, true );

	push	1
	mov	eax, DWORD PTR _numberOfBytes$[ebp]
	shl	eax, 3
	push	eax
	mov	ecx, DWORD PTR _input$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z ; RakNet::BitStream::WriteBits
$LN4@Write:

; 217  : 	}
; 218  : 	
; 219  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?Write@BitStream@RakNet@@QAEXPBDH@Z ENDP		; RakNet::BitStream::Write
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.cpp
;	COMDAT ?Reset@BitStream@RakNet@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Reset@BitStream@RakNet@@QAEXXZ PROC			; RakNet::BitStream::Reset, COMDAT
; _this$ = ecx

; 179  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 180  : 	// Note:  Do NOT reallocate memory because BitStream is used
; 181  : 	// in places to serialize/deserialize a buffer. Reallocation
; 182  : 	// is a dangerous operation (may result in leaks).
; 183  : 	
; 184  : 	if ( numberOfBitsUsed > 0 )
; 185  : 	{
; 186  : 		//  memset(data, 0, BITS_TO_BYTES(numberOfBitsUsed));
; 187  : 	}
; 188  : 	
; 189  : 	// Don't free memory here for speed efficiency
; 190  : 	//free(data);  // Use realloc and free so we are more efficient than delete and new for resizing
; 191  : 	numberOfBitsUsed = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 192  : 	
; 193  : 	//numberOfBitsAllocated=8;
; 194  : 	readOffset = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 195  : 	
; 196  : 	//data=(unsigned char*)malloc(1);
; 197  : 	// if (numberOfBitsAllocated>0)
; 198  : 	//  memset(data, 0, BITS_TO_BYTES(numberOfBitsAllocated));
; 199  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Reset@BitStream@RakNet@@QAEXXZ ENDP			; RakNet::BitStream::Reset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.cpp
;	COMDAT ??1BitStream@RakNet@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1BitStream@RakNet@@QAE@XZ PROC			; RakNet::BitStream::~BitStream, COMDAT
; _this$ = ecx

; 173  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 174  : 	if ( copyData && numberOfBitsAllocated > BITSTREAM_STACK_ALLOCATION_SIZE << 3)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+16]
	test	ecx, ecx
	je	SHORT $LN2@BitStream
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 2048			; 00000800H
	jle	SHORT $LN2@BitStream

; 175  : 		free( data );  // Use realloc and free so we are more efficient than delete and new for resizing

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_free
	add	esp, 4
$LN2@BitStream:

; 176  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1BitStream@RakNet@@QAE@XZ ENDP			; RakNet::BitStream::~BitStream
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.cpp
;	COMDAT ??0BitStream@RakNet@@QAE@PADI_N@Z
_TEXT	SEGMENT
__data$ = -20						; size = 4
_this$ = -8						; size = 4
__dataC$ = 8						; size = 4
_lengthInBytes$ = 12					; size = 4
__copyData$ = 16					; size = 1
??0BitStream@RakNet@@QAE@PADI_N@Z PROC			; RakNet::BitStream::BitStream, COMDAT
; _this$ = ecx

; 128  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 	unsigned char* _data = reinterpret_cast<unsigned char*>(_dataC);

	mov	eax, DWORD PTR __dataC$[ebp]
	mov	DWORD PTR __data$[ebp], eax

; 130  : 
; 131  : 	numberOfBitsUsed = lengthInBytes << 3;

	mov	eax, DWORD PTR _lengthInBytes$[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 132  : 	readOffset = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 133  : 	copyData = _copyData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR __copyData$[ebp]
	mov	BYTE PTR [eax+16], cl

; 134  : 	numberOfBitsAllocated = lengthInBytes << 3;

	mov	eax, DWORD PTR _lengthInBytes$[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 135  : 	
; 136  : 	if ( copyData )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+16]
	test	ecx, ecx
	je	$LN6@BitStream

; 137  : 	{
; 138  : 		if ( lengthInBytes > 0 )

	cmp	DWORD PTR _lengthInBytes$[ebp], 0
	jbe	SHORT $LN5@BitStream

; 139  : 		{
; 140  : 			if (lengthInBytes < BITSTREAM_STACK_ALLOCATION_SIZE)

	cmp	DWORD PTR _lengthInBytes$[ebp], 256	; 00000100H
	jae	SHORT $LN4@BitStream

; 141  : 			{
; 142  : 				data = ( unsigned char* ) stackData;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 17					; 00000011H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 143  : 				numberOfBitsAllocated = BITSTREAM_STACK_ALLOCATION_SIZE << 3;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 2048			; 00000800H

; 144  : 			}
; 145  : 			else

	jmp	SHORT $LN3@BitStream
$LN4@BitStream:

; 146  : 			{
; 147  : 				data = ( unsigned char* ) malloc( lengthInBytes );

	mov	eax, DWORD PTR _lengthInBytes$[ebp]
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax
$LN3@BitStream:

; 148  : 			}
; 149  : #ifdef _DEBUG
; 150  : 			assert( data );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN9@BitStream
	mov	ecx, DWORD PTR ?__LINE__Var@?1???0BitStream@RakNet@@QAE@PADI_N@Z@4JA
	add	ecx, 22					; 00000016H
	push	ecx
	push	OFFSET ??_C@_1EM@DFHCFFCB@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAb?$AAi?$AAt?$AAs?$AAt?$AAr?$AAe?$AAa@
	push	OFFSET ??_C@_19MLBBEMBH@?$AAd?$AAa?$AAt?$AAa?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN9@BitStream:

; 151  : #endif
; 152  : 			memcpy( data, _data, lengthInBytes );

	mov	eax, DWORD PTR _lengthInBytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR __data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 153  : 		}
; 154  : 		else

	jmp	SHORT $LN2@BitStream
$LN5@BitStream:

; 155  : 			data = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
$LN2@BitStream:

; 156  : 	}
; 157  : 	else

	jmp	SHORT $LN7@BitStream
$LN6@BitStream:

; 158  : 		data = ( unsigned char* ) _data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __data$[ebp]
	mov	DWORD PTR [eax+12], ecx
$LN7@BitStream:

; 159  : 
; 160  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0BitStream@RakNet@@QAE@PADI_N@Z ENDP			; RakNet::BitStream::BitStream
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.cpp
;	COMDAT ??0BitStream@RakNet@@QAE@PAEI_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__data$ = 8						; size = 4
_lengthInBytes$ = 12					; size = 4
__copyData$ = 16					; size = 1
??0BitStream@RakNet@@QAE@PAEI_N@Z PROC			; RakNet::BitStream::BitStream, COMDAT
; _this$ = ecx

; 95   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 96   : 	numberOfBitsUsed = lengthInBytes << 3;

	mov	eax, DWORD PTR _lengthInBytes$[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 97   : 	readOffset = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 98   : 	copyData = _copyData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR __copyData$[ebp]
	mov	BYTE PTR [eax+16], cl

; 99   : 	numberOfBitsAllocated = lengthInBytes << 3;

	mov	eax, DWORD PTR _lengthInBytes$[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 100  : 	
; 101  : 	if ( copyData )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+16]
	test	ecx, ecx
	je	$LN6@BitStream

; 102  : 	{
; 103  : 		if ( lengthInBytes > 0 )

	cmp	DWORD PTR _lengthInBytes$[ebp], 0
	jbe	SHORT $LN5@BitStream

; 104  : 		{
; 105  : 			if (lengthInBytes < BITSTREAM_STACK_ALLOCATION_SIZE)

	cmp	DWORD PTR _lengthInBytes$[ebp], 256	; 00000100H
	jae	SHORT $LN4@BitStream

; 106  : 			{
; 107  : 				data = ( unsigned char* ) stackData;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 17					; 00000011H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 108  : 				numberOfBitsAllocated = BITSTREAM_STACK_ALLOCATION_SIZE << 3;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 2048			; 00000800H

; 109  : 			}
; 110  : 			else

	jmp	SHORT $LN3@BitStream
$LN4@BitStream:

; 111  : 			{
; 112  : 				data = ( unsigned char* ) malloc( lengthInBytes );

	mov	eax, DWORD PTR _lengthInBytes$[ebp]
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax
$LN3@BitStream:

; 113  : 			}
; 114  : #ifdef _DEBUG
; 115  : 			assert( data );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN9@BitStream
	mov	ecx, DWORD PTR ?__LINE__Var@?1???0BitStream@RakNet@@QAE@PAEI_N@Z@4JA
	add	ecx, 20					; 00000014H
	push	ecx
	push	OFFSET ??_C@_1EM@DFHCFFCB@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAb?$AAi?$AAt?$AAs?$AAt?$AAr?$AAe?$AAa@
	push	OFFSET ??_C@_19MLBBEMBH@?$AAd?$AAa?$AAt?$AAa?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN9@BitStream:

; 116  : #endif
; 117  : 			memcpy( data, _data, lengthInBytes );

	mov	eax, DWORD PTR _lengthInBytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR __data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 118  : 		}
; 119  : 		else

	jmp	SHORT $LN2@BitStream
$LN5@BitStream:

; 120  : 			data = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
$LN2@BitStream:

; 121  : 	}
; 122  : 	else

	jmp	SHORT $LN7@BitStream
$LN6@BitStream:

; 123  : 		data = ( unsigned char* ) _data;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __data$[ebp]
	mov	DWORD PTR [eax+12], ecx
$LN7@BitStream:

; 124  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0BitStream@RakNet@@QAE@PAEI_N@Z ENDP			; RakNet::BitStream::BitStream
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.cpp
;	COMDAT ??0BitStream@RakNet@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_initialBytesToAllocate$ = 8				; size = 4
??0BitStream@RakNet@@QAE@H@Z PROC			; RakNet::BitStream::BitStream, COMDAT
; _this$ = ecx

; 74   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 75   : 	numberOfBitsUsed = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 76   : 	readOffset = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 77   : 	if (initialBytesToAllocate <= BITSTREAM_STACK_ALLOCATION_SIZE)

	cmp	DWORD PTR _initialBytesToAllocate$[ebp], 256 ; 00000100H
	jg	SHORT $LN2@BitStream

; 78   : 	{
; 79   : 		data = ( unsigned char* ) stackData;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 17					; 00000011H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 80   : 		numberOfBitsAllocated = BITSTREAM_STACK_ALLOCATION_SIZE * 8;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 2048			; 00000800H

; 81   : 	}
; 82   : 	else

	jmp	SHORT $LN1@BitStream
$LN2@BitStream:

; 83   : 	{
; 84   : 		data = ( unsigned char* ) malloc( initialBytesToAllocate );

	mov	eax, DWORD PTR _initialBytesToAllocate$[ebp]
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 85   : 		numberOfBitsAllocated = initialBytesToAllocate << 3;

	mov	eax, DWORD PTR _initialBytesToAllocate$[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax
$LN1@BitStream:

; 86   : 	}
; 87   : #ifdef _DEBUG
; 88   : 	assert( data );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN5@BitStream
	mov	ecx, DWORD PTR ?__LINE__Var@?1???0BitStream@RakNet@@QAE@H@Z@4JA
	add	ecx, 14					; 0000000eH
	push	ecx
	push	OFFSET ??_C@_1EM@DFHCFFCB@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAb?$AAi?$AAt?$AAs?$AAt?$AAr?$AAe?$AAa@
	push	OFFSET ??_C@_19MLBBEMBH@?$AAd?$AAa?$AAt?$AAa?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN5@BitStream:

; 89   : #endif
; 90   : 	// memset(data, 0, initialBytesToAllocate);
; 91   : 	copyData = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+16], 1

; 92   : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0BitStream@RakNet@@QAE@H@Z ENDP			; RakNet::BitStream::BitStream
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.cpp
;	COMDAT ??0BitStream@RakNet@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0BitStream@RakNet@@QAE@XZ PROC			; RakNet::BitStream::BitStream, COMDAT
; _this$ = ecx

; 58   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 59   : 	numberOfBitsUsed = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 60   : 	//numberOfBitsAllocated = 32 * 8;
; 61   : 	numberOfBitsAllocated = BITSTREAM_STACK_ALLOCATION_SIZE * 8;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 2048			; 00000800H

; 62   : 	readOffset = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 63   : 	//data = ( unsigned char* ) malloc( 32 );
; 64   : 	data = ( unsigned char* ) stackData;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 17					; 00000011H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 65   : 	
; 66   : #ifdef _DEBUG	
; 67   : //	assert( data );
; 68   : #endif
; 69   : 	//memset(data, 0, 32);
; 70   : 	copyData = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+16], 1

; 71   : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0BitStream@RakNet@@QAE@XZ ENDP			; RakNet::BitStream::BitStream
_TEXT	ENDS
END
