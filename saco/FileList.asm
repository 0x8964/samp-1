; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.31101.0 

	TITLE	Z:\sampsrc\02Xu1\raknet\FileList.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	??0FileList@@QAE@XZ				; FileList::FileList
PUBLIC	??1FileList@@QAE@XZ				; FileList::~FileList
PUBLIC	?AddFilesFromDirectory@FileList@@QAEXPBD0_N11E@Z ; FileList::AddFilesFromDirectory
PUBLIC	?Clear@FileList@@QAEXXZ				; FileList::Clear
PUBLIC	?Serialize@FileList@@QAEXPAVBitStream@RakNet@@@Z ; FileList::Serialize
PUBLIC	?Deserialize@FileList@@QAE_NPAVBitStream@RakNet@@@Z ; FileList::Deserialize
PUBLIC	?ListMissingOrChangedFiles@FileList@@QAEXPBDPAV1@_N2@Z ; FileList::ListMissingOrChangedFiles
PUBLIC	?GetDeltaToCurrent@FileList@@QAEXPAV1@0PBD1@Z	; FileList::GetDeltaToCurrent
PUBLIC	?PopulateDataFromDisk@FileList@@QAEXPBD_N11@Z	; FileList::PopulateDataFromDisk
PUBLIC	?WriteDataToDisk@FileList@@QAEXPBD@Z		; FileList::WriteDataToDisk
PUBLIC	?AddFile@FileList@@QAEXPBD0IIE@Z		; FileList::AddFile
PUBLIC	?AddFile@FileList@@QAEXPBD0E@Z			; FileList::AddFile
PUBLIC	?DeleteFiles@FileList@@QAEXPBD@Z		; FileList::DeleteFiles
PUBLIC	??0?$List@UFileListNode@@@DataStructures@@QAE@XZ ; DataStructures::List<FileListNode>::List<FileListNode>
PUBLIC	??1?$List@UFileListNode@@@DataStructures@@QAE@XZ ; DataStructures::List<FileListNode>::~List<FileListNode>
PUBLIC	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
PUBLIC	?Insert@?$List@UFileListNode@@@DataStructures@@QAEXUFileListNode@@@Z ; DataStructures::List<FileListNode>::Insert
PUBLIC	?RemoveAtIndex@?$List@UFileListNode@@@DataStructures@@QAEXI@Z ; DataStructures::List<FileListNode>::RemoveAtIndex
PUBLIC	?Del@?$List@UFileListNode@@@DataStructures@@QAEXI@Z ; DataStructures::List<FileListNode>::Del
PUBLIC	?Size@?$List@UFileListNode@@@DataStructures@@QBEIXZ ; DataStructures::List<FileListNode>::Size
PUBLIC	?Clear@?$List@UFileListNode@@@DataStructures@@QAEX_N@Z ; DataStructures::List<FileListNode>::Clear
PUBLIC	??$Write@_N@BitStream@RakNet@@QAEX_N@Z		; RakNet::BitStream::Write<bool>
PUBLIC	??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z	; RakNet::BitStream::Read<bool>
PUBLIC	??0?$Queue@PAD@DataStructures@@QAE@XZ		; DataStructures::Queue<char *>::Queue<char *>
PUBLIC	??1?$Queue@PAD@DataStructures@@QAE@XZ		; DataStructures::Queue<char *>::~Queue<char *>
PUBLIC	?Push@?$Queue@PAD@DataStructures@@QAEXABQAD@Z	; DataStructures::Queue<char *>::Push
PUBLIC	??A?$Queue@PAD@DataStructures@@QBEAAPADI@Z	; DataStructures::Queue<char *>::operator[]
PUBLIC	?Pop@?$Queue@PAD@DataStructures@@QAEPADXZ	; DataStructures::Queue<char *>::Pop
PUBLIC	?Size@?$Queue@PAD@DataStructures@@QBEIXZ	; DataStructures::Queue<char *>::Size
PUBLIC	??$WriteCompressed@I@BitStream@RakNet@@QAEXI@Z	; RakNet::BitStream::WriteCompressed<unsigned int>
PUBLIC	??$WriteCompressed@E@BitStream@RakNet@@QAEXE@Z	; RakNet::BitStream::WriteCompressed<unsigned char>
PUBLIC	??$ReadCompressed@I@BitStream@RakNet@@QAE_NAAI@Z ; RakNet::BitStream::ReadCompressed<unsigned int>
PUBLIC	??$ReadCompressed@E@BitStream@RakNet@@QAE_NAAE@Z ; RakNet::BitStream::ReadCompressed<unsigned char>
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	??_C@_01KMDKNFGN@?1?$AA@			; `string'
PUBLIC	??_C@_03EMIMMIHL@?$CK?4?$CK?$AA@		; `string'
PUBLIC	?__LINE__Var@?1??Deserialize@FileList@@QAE_NPAVBitStream@RakNet@@@Z@4JA ; `FileList::Deserialize'::`2'::__LINE__Var
PUBLIC	??_C@_1EK@JGBLDIEJ@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAf?$AAi?$AAl?$AAe?$AAl?$AAi?$AAs?$AAt@ ; `string'
PUBLIC	??_C@_13EPJEBPGL@?$AAb?$AA?$AA@			; `string'
PUBLIC	??_C@_1CK@PBAHFKCM@?$AAf?$AAi?$AAl?$AAe?$AAL?$AAi?$AAs?$AAt?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?5?$AA1?$AA0?$AA0?$AA0?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DA@CODFILKM@?$AAn?$AA?4?$AAd?$AAa?$AAt?$AAa?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?$DM?$AA?$DN?$AA2?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??WriteDataToDisk@FileList@@QAEXPBD@Z@4JA ; `FileList::WriteDataToDisk'::`2'::__LINE__Var
PUBLIC	??_C@_13COJANIEC@?$AA0?$AA?$AA@			; `string'
PUBLIC	?__LINE__Var@?1??DeleteFiles@FileList@@QAEXPBD@Z@4JA ; `FileList::DeleteFiles'::`2'::__LINE__Var
PUBLIC	??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@ ; `string'
PUBLIC	??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@ ; `string'
PUBLIC	??_C@_1BE@OMEGJCHO@?$AAn?$AAe?$AAw?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CE@CLDOPLDF@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1GG@JDEIIJCO@?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN@ ; `string'
PUBLIC	??_C@_1BO@JBFMBKMD@?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$DO?$AA?$DN?$AAn?$AAu?$AAm?$AA?$AA@ ; `string'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__wassert:PROC
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	_strcpy:PROC
EXTRN	_strcat:PROC
EXTRN	_strcmp:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	__stricmp:PROC
EXTRN	__strnicmp:PROC
EXTRN	__findclose:PROC
EXTRN	__unlink:PROC
EXTRN	__findfirst64i32:PROC
EXTRN	__findnext64i32:PROC
EXTRN	_fclose:PROC
EXTRN	_fopen:PROC
EXTRN	_fread:PROC
EXTRN	_fseek:PROC
EXTRN	_ftell:PROC
EXTRN	??0CSHA1@@QAE@XZ:PROC				; CSHA1::CSHA1
EXTRN	??1CSHA1@@UAE@XZ:PROC				; CSHA1::~CSHA1
EXTRN	?Reset@CSHA1@@QAEXXZ:PROC			; CSHA1::Reset
EXTRN	?Update@CSHA1@@QAEXPAEI@Z:PROC			; CSHA1::Update
EXTRN	?Final@CSHA1@@QAEXXZ:PROC			; CSHA1::Final
EXTRN	?GetHash@CSHA1@@QBEPAEXZ:PROC			; CSHA1::GetHash
EXTRN	?Instance@StringCompressor@@SAPAV1@XZ:PROC	; StringCompressor::Instance
EXTRN	?EncodeString@StringCompressor@@QAEXPBDHPAVBitStream@RakNet@@H@Z:PROC ; StringCompressor::EncodeString
EXTRN	?DecodeString@StringCompressor@@QAE_NPADHPAVBitStream@RakNet@@H@Z:PROC ; StringCompressor::DecodeString
EXTRN	?Write@BitStream@RakNet@@QAEXPBDH@Z:PROC	; RakNet::BitStream::Write
EXTRN	?Read@BitStream@RakNet@@QAE_NPADH@Z:PROC	; RakNet::BitStream::Read
EXTRN	?Write0@BitStream@RakNet@@QAEXXZ:PROC		; RakNet::BitStream::Write0
EXTRN	?Write1@BitStream@RakNet@@QAEXXZ:PROC		; RakNet::BitStream::Write1
EXTRN	?WriteCompressed@BitStream@RakNet@@AAEXPBEH_N@Z:PROC ; RakNet::BitStream::WriteCompressed
EXTRN	?ReadCompressed@BitStream@RakNet@@AAE_NPAEH_N@Z:PROC ; RakNet::BitStream::ReadCompressed
EXTRN	?WriteFileWithDirectories@@YA_NPBDPADI@Z:PROC	; WriteFileWithDirectories
EXTRN	?IsSlash@@YA_NE@Z:PROC				; IsSlash
EXTRN	@_RTC_AllocaHelper@12:PROC
EXTRN	@_RTC_CheckStackVars2@12:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__alloca_probe_16:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_1BO@JBFMBKMD@?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$DO?$AA?$DN?$AAn?$AAu?$AAm?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@JBFMBKMD@?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$DO?$AA?$DN?$AAn?$AAu?$AAm?$AA?$AA@ DB 'l'
	DB	00H, 'i', 00H, 's', 00H, 't', 00H, '_', 00H, 's', 00H, 'i', 00H
	DB	'z', 00H, 'e', 00H, '>', 00H, '=', 00H, 'n', 00H, 'u', 00H, 'm'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1GG@JDEIIJCO@?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN@
CONST	SEGMENT
??_C@_1GG@JDEIIJCO@?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN@ DB 'a'
	DB	00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H
	DB	'i', 00H, 'o', 00H, 'n', 00H, '_', 00H, 's', 00H, 'i', 00H, 'z'
	DB	00H, 'e', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e'
	DB	00H, '(', 00H, ')', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H
	DB	'0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'h', 00H, 'e'
	DB	00H, 'a', 00H, 'd', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H
	DB	't', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@CLDOPLDF@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@CLDOPLDF@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@ DB 'p'
	DB	00H, 'o', 00H, 's', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'o', 00H
	DB	'n', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'S', 00H, 'i', 00H, 'z'
	DB	00H, 'e', 00H, '(', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@OMEGJCHO@?$AAn?$AAe?$AAw?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@OMEGJCHO@?$AAn?$AAe?$AAw?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?$AA@ DB 'n'
	DB	00H, 'e', 00H, 'w', 00H, '_', 00H, 'a', 00H, 'r', 00H, 'r', 00H
	DB	'a', 00H, 'y', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@
CONST	SEGMENT
??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@ DB 'z'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H
	DB	's', 00H, 'r', 00H, 'c', 00H, '\', 00H, '0', 00H, '2', 00H, 'x'
	DB	00H, 'u', 00H, '1', 00H, '\', 00H, 'r', 00H, 'a', 00H, 'k', 00H
	DB	'n', 00H, 'e', 00H, 't', 00H, '\', 00H, 'd', 00H, 's', 00H, '_'
	DB	00H, 'q', 00H, 'u', 00H, 'e', 00H, 'u', 00H, 'e', 00H, '.', 00H
	DB	'h', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ DB 'p'
	DB	00H, 'o', 00H, 's', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'o', 00H
	DB	'n', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'l', 00H, 'i', 00H, 's'
	DB	00H, 't', 00H, '_', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
CONST	SEGMENT
??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@ DB 'z'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H
	DB	's', 00H, 'r', 00H, 'c', 00H, '\', 00H, '0', 00H, '2', 00H, 'x'
	DB	00H, 'u', 00H, '1', 00H, '\', 00H, 'r', 00H, 'a', 00H, 'k', 00H
	DB	'n', 00H, 'e', 00H, 't', 00H, '\', 00H, 'd', 00H, 's', 00H, '_'
	DB	00H, 'l', 00H, 'i', 00H, 's', 00H, 't', 00H, '.', 00H, 'h', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??DeleteFiles@FileList@@QAEXPBD@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??DeleteFiles@FileList@@QAEXPBD@Z@4JA DD 0239H ; `FileList::DeleteFiles'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_13COJANIEC@?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_13COJANIEC@?$AA0?$AA?$AA@ DB '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??WriteDataToDisk@FileList@@QAEXPBD@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??WriteDataToDisk@FileList@@QAEXPBD@Z@4JA DD 021bH ; `FileList::WriteDataToDisk'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1DA@CODFILKM@?$AAn?$AA?4?$AAd?$AAa?$AAt?$AAa?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?$DM?$AA?$DN?$AA2?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@CODFILKM@?$AAn?$AA?4?$AAd?$AAa?$AAt?$AAa?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?$DM?$AA?$DN?$AA2?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0?$AA?$AA@ DB 'n'
	DB	00H, '.', 00H, 'd', 00H, 'a', 00H, 't', 00H, 'a', 00H, 'L', 00H
	DB	'e', 00H, 'n', 00H, 'g', 00H, 't', 00H, 'h', 00H, '<', 00H, '='
	DB	00H, '2', 00H, '0', 00H, '0', 00H, '0', 00H, '0', 00H, '0', 00H
	DB	'0', 00H, '0', 00H, '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@PBAHFKCM@?$AAf?$AAi?$AAl?$AAe?$AAL?$AAi?$AAs?$AAt?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?5?$AA1?$AA0?$AA0?$AA0?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@PBAHFKCM@?$AAf?$AAi?$AAl?$AAe?$AAL?$AAi?$AAs?$AAt?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?5?$AA1?$AA0?$AA0?$AA0?$AA0?$AA?$AA@ DB 'f'
	DB	00H, 'i', 00H, 'l', 00H, 'e', 00H, 'L', 00H, 'i', 00H, 's', 00H
	DB	't', 00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '<'
	DB	00H, ' ', 00H, '1', 00H, '0', 00H, '0', 00H, '0', 00H, '0', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_13EPJEBPGL@?$AAb?$AA?$AA@
CONST	SEGMENT
??_C@_13EPJEBPGL@?$AAb?$AA?$AA@ DB 'b', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EK@JGBLDIEJ@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAf?$AAi?$AAl?$AAe?$AAl?$AAi?$AAs?$AAt@
CONST	SEGMENT
??_C@_1EK@JGBLDIEJ@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAf?$AAi?$AAl?$AAe?$AAl?$AAi?$AAs?$AAt@ DB 'z'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H
	DB	's', 00H, 'r', 00H, 'c', 00H, '\', 00H, '0', 00H, '2', 00H, 'x'
	DB	00H, 'u', 00H, '1', 00H, '\', 00H, 'r', 00H, 'a', 00H, 'k', 00H
	DB	'n', 00H, 'e', 00H, 't', 00H, '\', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 'l', 00H, 'i', 00H, 's', 00H, 't', 00H, '.', 00H
	DB	'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??Deserialize@FileList@@QAE_NPAVBitStream@RakNet@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??Deserialize@FileList@@QAE_NPAVBitStream@RakNet@@@Z@4JA DD 0115H ; `FileList::Deserialize'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_03EMIMMIHL@?$CK?4?$CK?$AA@
CONST	SEGMENT
??_C@_03EMIMMIHL@?$CK?4?$CK?$AA@ DB '*.*', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01KMDKNFGN@?1?$AA@
CONST	SEGMENT
??_C@_01KMDKNFGN@?1?$AA@ DB '/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?PopulateDataFromDisk@FileList@@QAEXPBD_N11@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PopulateDataFromDisk@FileList@@QAEXPBD_N11@Z$0
__ehfuncinfo$?PopulateDataFromDisk@FileList@@QAEXPBD_N11@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PopulateDataFromDisk@FileList@@QAEXPBD_N11@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ListMissingOrChangedFiles@FileList@@QAEXPBDPAV1@_N2@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ListMissingOrChangedFiles@FileList@@QAEXPBDPAV1@_N2@Z$0
__ehfuncinfo$?ListMissingOrChangedFiles@FileList@@QAEXPBDPAV1@_N2@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ListMissingOrChangedFiles@FileList@@QAEXPBDPAV1@_N2@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?AddFilesFromDirectory@FileList@@QAEXPBD0_N11E@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddFilesFromDirectory@FileList@@QAEXPBD0_N11E@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?AddFilesFromDirectory@FileList@@QAEXPBD0_N11E@Z$1
__ehfuncinfo$?AddFilesFromDirectory@FileList@@QAEXPBD0_N11E@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AddFilesFromDirectory@FileList@@QAEXPBD0_N11E@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1FileList@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1FileList@@QAE@XZ$0
__ehfuncinfo$??1FileList@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1FileList@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$ReadCompressed@E@BitStream@RakNet@@QAE_NAAE@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 4
??$ReadCompressed@E@BitStream@RakNet@@QAE_NAAE@Z PROC	; RakNet::BitStream::ReadCompressed<unsigned char>, COMDAT
; _this$ = ecx

; 1080 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1081 : #ifdef _MSC_VER
; 1082 : #pragma warning(disable:4127)   // conditional expression is constant
; 1083 : #endif
; 1084 : 		if (sizeof(var)==1)

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN2@ReadCompre

; 1085 : 			return ReadCompressed( ( unsigned char* ) &var, sizeof(templateType) * 8, true );

	push	1
	push	8
	mov	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadCompressed@BitStream@RakNet@@AAE_NPAEH_N@Z ; RakNet::BitStream::ReadCompressed
	jmp	SHORT $LN3@ReadCompre

; 1086 : 		else

	jmp	SHORT $LN3@ReadCompre
$LN2@ReadCompre:

; 1087 : 		{
; 1088 : #ifndef __BITSTREAM_NATIVE_END
; 1089 : 			if (DoEndianSwap())
; 1090 : 			{
; 1091 : 				unsigned char output[sizeof(templateType)];
; 1092 : 				if (ReadCompressed( ( unsigned char* ) output, sizeof(templateType) * 8, true ))
; 1093 : 				{
; 1094 : 					ReverseBytes(output, (unsigned char*)&var, sizeof(templateType));
; 1095 : 					return true;
; 1096 : 				}
; 1097 : 				return false;
; 1098 : 			}
; 1099 : 			else
; 1100 : #endif
; 1101 : 				return ReadCompressed( ( unsigned char* ) & var, sizeof(templateType) * 8, true );

	push	1
	push	8
	mov	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadCompressed@BitStream@RakNet@@AAE_NPAEH_N@Z ; RakNet::BitStream::ReadCompressed
$LN3@ReadCompre:

; 1102 : 		}
; 1103 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$ReadCompressed@E@BitStream@RakNet@@QAE_NAAE@Z ENDP	; RakNet::BitStream::ReadCompressed<unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$ReadCompressed@I@BitStream@RakNet@@QAE_NAAI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 4
??$ReadCompressed@I@BitStream@RakNet@@QAE_NAAI@Z PROC	; RakNet::BitStream::ReadCompressed<unsigned int>, COMDAT
; _this$ = ecx

; 1080 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1081 : #ifdef _MSC_VER
; 1082 : #pragma warning(disable:4127)   // conditional expression is constant
; 1083 : #endif
; 1084 : 		if (sizeof(var)==1)

	xor	eax, eax
	je	SHORT $LN2@ReadCompre

; 1085 : 			return ReadCompressed( ( unsigned char* ) &var, sizeof(templateType) * 8, true );

	push	1
	push	32					; 00000020H
	mov	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadCompressed@BitStream@RakNet@@AAE_NPAEH_N@Z ; RakNet::BitStream::ReadCompressed
	jmp	SHORT $LN3@ReadCompre

; 1086 : 		else

	jmp	SHORT $LN3@ReadCompre
$LN2@ReadCompre:

; 1087 : 		{
; 1088 : #ifndef __BITSTREAM_NATIVE_END
; 1089 : 			if (DoEndianSwap())
; 1090 : 			{
; 1091 : 				unsigned char output[sizeof(templateType)];
; 1092 : 				if (ReadCompressed( ( unsigned char* ) output, sizeof(templateType) * 8, true ))
; 1093 : 				{
; 1094 : 					ReverseBytes(output, (unsigned char*)&var, sizeof(templateType));
; 1095 : 					return true;
; 1096 : 				}
; 1097 : 				return false;
; 1098 : 			}
; 1099 : 			else
; 1100 : #endif
; 1101 : 				return ReadCompressed( ( unsigned char* ) & var, sizeof(templateType) * 8, true );

	push	1
	push	32					; 00000020H
	mov	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadCompressed@BitStream@RakNet@@AAE_NPAEH_N@Z ; RakNet::BitStream::ReadCompressed
$LN3@ReadCompre:

; 1102 : 		}
; 1103 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$ReadCompressed@I@BitStream@RakNet@@QAE_NAAI@Z ENDP	; RakNet::BitStream::ReadCompressed<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$WriteCompressed@E@BitStream@RakNet@@QAEXE@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 1
??$WriteCompressed@E@BitStream@RakNet@@QAEXE@Z PROC	; RakNet::BitStream::WriteCompressed<unsigned char>, COMDAT
; _this$ = ecx

; 865  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 866  : #ifdef _MSC_VER
; 867  : #pragma warning(disable:4127)   // conditional expression is constant
; 868  : #endif
; 869  : 		if (sizeof(var)==1)

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN2@WriteCompr

; 870  : 			WriteCompressed( ( unsigned char* ) & var, sizeof( templateType ) * 8, true );

	push	1
	push	8
	lea	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteCompressed@BitStream@RakNet@@AAEXPBEH_N@Z ; RakNet::BitStream::WriteCompressed

; 871  : 		else

	jmp	SHORT $LN3@WriteCompr
$LN2@WriteCompr:

; 872  : 		{
; 873  : #ifndef __BITSTREAM_NATIVE_END
; 874  : #ifdef _MSC_VER
; 875  : #pragma warning(disable:4244)   // '=' : conversion from 'unsigned long' to 'unsigned short', possible loss of data
; 876  : #endif
; 877  : 
; 878  : 			if (DoEndianSwap())
; 879  : 			{
; 880  : 				unsigned char output[sizeof(templateType)];
; 881  : 				ReverseBytes((unsigned char*)&var, output, sizeof(templateType));
; 882  : 				WriteCompressed( ( unsigned char* ) output, sizeof(templateType) * 8, true );
; 883  : 			}
; 884  : 			else
; 885  : #endif
; 886  : 				WriteCompressed( ( unsigned char* ) & var, sizeof(templateType) * 8, true );

	push	1
	push	8
	lea	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteCompressed@BitStream@RakNet@@AAEXPBEH_N@Z ; RakNet::BitStream::WriteCompressed
$LN3@WriteCompr:

; 887  : 		}
; 888  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$WriteCompressed@E@BitStream@RakNet@@QAEXE@Z ENDP	; RakNet::BitStream::WriteCompressed<unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$WriteCompressed@I@BitStream@RakNet@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 4
??$WriteCompressed@I@BitStream@RakNet@@QAEXI@Z PROC	; RakNet::BitStream::WriteCompressed<unsigned int>, COMDAT
; _this$ = ecx

; 865  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 866  : #ifdef _MSC_VER
; 867  : #pragma warning(disable:4127)   // conditional expression is constant
; 868  : #endif
; 869  : 		if (sizeof(var)==1)

	xor	eax, eax
	je	SHORT $LN2@WriteCompr

; 870  : 			WriteCompressed( ( unsigned char* ) & var, sizeof( templateType ) * 8, true );

	push	1
	push	32					; 00000020H
	lea	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteCompressed@BitStream@RakNet@@AAEXPBEH_N@Z ; RakNet::BitStream::WriteCompressed

; 871  : 		else

	jmp	SHORT $LN3@WriteCompr
$LN2@WriteCompr:

; 872  : 		{
; 873  : #ifndef __BITSTREAM_NATIVE_END
; 874  : #ifdef _MSC_VER
; 875  : #pragma warning(disable:4244)   // '=' : conversion from 'unsigned long' to 'unsigned short', possible loss of data
; 876  : #endif
; 877  : 
; 878  : 			if (DoEndianSwap())
; 879  : 			{
; 880  : 				unsigned char output[sizeof(templateType)];
; 881  : 				ReverseBytes((unsigned char*)&var, output, sizeof(templateType));
; 882  : 				WriteCompressed( ( unsigned char* ) output, sizeof(templateType) * 8, true );
; 883  : 			}
; 884  : 			else
; 885  : #endif
; 886  : 				WriteCompressed( ( unsigned char* ) & var, sizeof(templateType) * 8, true );

	push	1
	push	32					; 00000020H
	lea	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteCompressed@BitStream@RakNet@@AAEXPBEH_N@Z ; RakNet::BitStream::WriteCompressed
$LN3@WriteCompr:

; 887  : 		}
; 888  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$WriteCompressed@I@BitStream@RakNet@@QAEXI@Z ENDP	; RakNet::BitStream::WriteCompressed<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ?Size@?$Queue@PAD@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$Queue@PAD@DataStructures@@QBEIXZ PROC		; DataStructures::Queue<char *>::Size, COMDAT
; _this$ = ecx

; 62   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 63   : 		if ( head <= tail )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	ja	SHORT $LN2@Size

; 64   : 			return tail -head;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	jmp	SHORT $LN3@Size

; 65   : 		else

	jmp	SHORT $LN3@Size
$LN2@Size:

; 66   : 			return allocation_size -head + tail;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx+8]
$LN3@Size:

; 67   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$Queue@PAD@DataStructures@@QBEIXZ ENDP		; DataStructures::Queue<char *>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ?Pop@?$Queue@PAD@DataStructures@@QAEPADXZ
_TEXT	SEGMENT
tv78 = -208						; size = 4
_this$ = -8						; size = 4
?Pop@?$Queue@PAD@DataStructures@@QAEPADXZ PROC		; DataStructures::Queue<char *>::Pop, COMDAT
; _this$ = ecx

; 99   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 100  : #ifdef _DEBUG
; 101  : 		assert( allocation_size > 0 && Size() >= 0 && head != tail);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jbe	SHORT $LN5@Pop
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$Queue@PAD@DataStructures@@QBEIXZ ; DataStructures::Queue<char *>::Size
	test	eax, eax
	jb	SHORT $LN5@Pop
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN6@Pop
$LN5@Pop:
	push	101					; 00000065H
	push	OFFSET ??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@
	push	OFFSET ??_C@_1GG@JDEIIJCO@?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN6@Pop:

; 102  : #endif
; 103  : 		//head=(head+1) % allocation_size;
; 104  : 
; 105  : 		if ( ++head == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	DWORD PTR tv78[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv78[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv78[ebp]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN2@Pop

; 106  : 			head = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
$LN2@Pop:

; 107  : 
; 108  : 		if ( head == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN1@Pop

; 109  : 			return ( queue_type ) array[ allocation_size -1 ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+ecx*4-4]
	jmp	SHORT $LN3@Pop
$LN1@Pop:

; 110  : 
; 111  : 		return ( queue_type ) array[ head -1 ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+ecx*4-4]
$LN3@Pop:

; 112  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Pop@?$Queue@PAD@DataStructures@@QAEPADXZ ENDP		; DataStructures::Queue<char *>::Pop
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ??A?$Queue@PAD@DataStructures@@QBEAAPADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
??A?$Queue@PAD@DataStructures@@QBEAAPADI@Z PROC		; DataStructures::Queue<char *>::operator[], COMDAT
; _this$ = ecx

; 356  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 357  : #ifdef _DEBUG
; 358  : 		assert( position < Size() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$Queue@PAD@DataStructures@@QBEIXZ ; DataStructures::Queue<char *>::Size
	cmp	DWORD PTR _position$[ebp], eax
	jb	SHORT $LN5@operator
	push	358					; 00000166H
	push	OFFSET ??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@
	push	OFFSET ??_C@_1CE@CLDOPLDF@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN5@operator:

; 359  : #endif
; 360  : 		//return array[(head + position) % allocation_size];
; 361  : 
; 362  : 		if ( head + position >= allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _position$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [edx+12]
	jb	SHORT $LN2@operator

; 363  : 			return array[ head + position - allocation_size ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _position$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	sub	ecx, DWORD PTR [edx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	lea	eax, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN3@operator

; 364  : 		else

	jmp	SHORT $LN3@operator
$LN2@operator:

; 365  : 			return array[ head + position ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _position$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	eax, DWORD PTR [eax+ecx*4]
$LN3@operator:

; 366  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$Queue@PAD@DataStructures@@QBEAAPADI@Z ENDP		; DataStructures::Queue<char *>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ?Push@?$Queue@PAD@DataStructures@@QAEXABQAD@Z
_TEXT	SEGMENT
$T1 = -260						; size = 4
$T2 = -248						; size = 4
$T3 = -236						; size = 4
_counter$4 = -32					; size = 4
_new_array$5 = -20					; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
?Push@?$Queue@PAD@DataStructures@@QAEXABQAD@Z PROC	; DataStructures::Queue<char *>::Push, COMDAT
; _this$ = ecx

; 182  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 183  : 		if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN6@Push

; 184  : 		{
; 185  : 			array = new queue_type[ 16 ];

	push	64					; 00000040H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax], ecx

; 186  : 			head = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 187  : 			tail = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 1

; 188  : 			array[ 0 ] = input;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+eax], edx

; 189  : 			allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 16			; 00000010H

; 190  : 			return ;

	jmp	$LN7@Push
$LN6@Push:

; 191  : 		}
; 192  : 
; 193  : 		array[ tail++ ] = input;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [eax+ecx*4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 194  : 
; 195  : 		if ( tail == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN5@Push

; 196  : 			tail = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
$LN5@Push:

; 197  : 
; 198  : 		if ( tail == head )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+4]
	jne	$LN7@Push

; 199  : 		{
; 200  : 			//  unsigned int index=tail;
; 201  : 
; 202  : 			// Need to allocate more memory.
; 203  : 			queue_type * new_array;
; 204  : 			new_array = new queue_type[ allocation_size * 2 ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	shl	eax, 1
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _new_array$5[ebp], eax

; 205  : #ifdef _DEBUG
; 206  : 
; 207  : 			assert( new_array );

	cmp	DWORD PTR _new_array$5[ebp], 0
	jne	SHORT $LN9@Push
	push	207					; 000000cfH
	push	OFFSET ??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@
	push	OFFSET ??_C@_1BE@OMEGJCHO@?$AAn?$AAe?$AAw?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN9@Push:

; 208  : #endif
; 209  : 
; 210  : 			for ( unsigned int counter = 0; counter < allocation_size; ++counter )

	mov	DWORD PTR _counter$4[ebp], 0
	jmp	SHORT $LN3@Push
$LN2@Push:
	mov	eax, DWORD PTR _counter$4[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$4[ebp], eax
$LN3@Push:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _counter$4[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN1@Push

; 211  : 				new_array[ counter ] = array[ ( head + counter ) % ( allocation_size ) ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, DWORD PTR _counter$4[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _counter$4[ebp]
	mov	esi, DWORD PTR _new_array$5[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [esi+eax*4], ecx
	jmp	SHORT $LN2@Push
$LN1@Push:

; 212  : 
; 213  : 			head = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 214  : 
; 215  : 			tail = allocation_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+8], edx

; 216  : 
; 217  : 			allocation_size *= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 218  : 
; 219  : 			// Delete the old array and move the pointer to the new array
; 220  : 			delete [] array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T3[ebp], ecx
	mov	edx, DWORD PTR $T3[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 221  : 
; 222  : 			array = new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$5[ebp]
	mov	DWORD PTR [eax], ecx
$LN7@Push:

; 223  : 		}
; 224  : 
; 225  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Push@?$Queue@PAD@DataStructures@@QAEXABQAD@Z ENDP	; DataStructures::Queue<char *>::Push
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ??1?$Queue@PAD@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
??1?$Queue@PAD@DataStructures@@QAE@XZ PROC		; DataStructures::Queue<char *>::~Queue<char *>, COMDAT
; _this$ = ecx

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		if (allocation_size>0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jbe	SHORT $LN2@Queue

; 94   : 			delete [] array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@Queue:

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$Queue@PAD@DataStructures@@QAE@XZ ENDP		; DataStructures::Queue<char *>::~Queue<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ??0?$Queue@PAD@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
??0?$Queue@PAD@DataStructures@@QAE@XZ PROC		; DataStructures::Queue<char *>::Queue<char *>, COMDAT
; _this$ = ecx

; 83   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 84   : 		allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 16			; 00000010H

; 85   : 		array = new queue_type[ allocation_size ];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax], ecx

; 86   : 		head = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 87   : 		tail = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 88   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$Queue@PAD@DataStructures@@QAE@XZ ENDP		; DataStructures::Queue<char *>::Queue<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z
_TEXT	SEGMENT
tv82 = -208						; size = 4
_this$ = -8						; size = 4
_var$ = 8						; size = 4
??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z PROC		; RakNet::BitStream::Read<bool>, COMDAT
; _this$ = ecx

; 1019 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1020 : 		if ( readOffset + 1 > numberOfBitsUsed )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [edx]
	jle	SHORT $LN3@Read

; 1021 : 			return false;

	xor	al, al
	jmp	SHORT $LN4@Read
$LN3@Read:

; 1022 : 
; 1023 : 		if ( data[ readOffset >> 3 ] & ( 0x80 >> ( readOffset++ % 8 ) ) )   // Is it faster to just write it out here?

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sar	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	movzx	edx, BYTE PTR [eax+ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -2147483641			; 80000007H
	jns	SHORT $LN6@Read
	dec	ecx
	or	ecx, -8					; fffffff8H
	inc	ecx
$LN6@Read:
	mov	eax, 128				; 00000080H
	sar	eax, cl
	and	edx, eax
	mov	DWORD PTR tv82[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx
	cmp	DWORD PTR tv82[ebp], 0
	je	SHORT $LN2@Read

; 1024 : 			var = true;

	mov	eax, DWORD PTR _var$[ebp]
	mov	BYTE PTR [eax], 1

; 1025 : 		else

	jmp	SHORT $LN1@Read
$LN2@Read:

; 1026 : 			var = false;

	mov	eax, DWORD PTR _var$[ebp]
	mov	BYTE PTR [eax], 0
$LN1@Read:

; 1027 : 
; 1028 : 		return true;

	mov	al, 1
$LN4@Read:

; 1029 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z ENDP		; RakNet::BitStream::Read<bool>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Write@_N@BitStream@RakNet@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 1
??$Write@_N@BitStream@RakNet@@QAEX_N@Z PROC		; RakNet::BitStream::Write<bool>, COMDAT
; _this$ = ecx

; 754  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 755  : 		if ( var )

	movzx	eax, BYTE PTR _var$[ebp]
	test	eax, eax
	je	SHORT $LN2@Write

; 756  : 			Write1();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Write1@BitStream@RakNet@@QAEXXZ	; RakNet::BitStream::Write1

; 757  : 		else

	jmp	SHORT $LN3@Write
$LN2@Write:

; 758  : 			Write0();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Write0@BitStream@RakNet@@QAEXXZ	; RakNet::BitStream::Write0
$LN3@Write:

; 759  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$Write@_N@BitStream@RakNet@@QAEX_N@Z ENDP		; RakNet::BitStream::Write<bool>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Clear@?$List@UFileListNode@@@DataStructures@@QAEX_N@Z
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
_doNotDeallocate$ = 8					; size = 1
?Clear@?$List@UFileListNode@@@DataStructures@@QAEX_N@Z PROC ; DataStructures::List<FileListNode>::Clear, COMDAT
; _this$ = ecx

; 379  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  : 		if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Clear

; 381  : 			return;

	jmp	SHORT $LN3@Clear
$LN2@Clear:

; 382  : 
; 383  : 		if (allocation_size>512 && doNotDeallocate==false)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 512			; 00000200H
	jbe	SHORT $LN1@Clear
	movzx	eax, BYTE PTR _doNotDeallocate$[ebp]
	test	eax, eax
	jne	SHORT $LN1@Clear

; 384  : 		{
; 385  : 			delete [] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 386  : 			allocation_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 387  : 			listArray = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN1@Clear:

; 388  : 		}
; 389  : 		list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
$LN3@Clear:

; 390  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Clear@?$List@UFileListNode@@@DataStructures@@QAEX_N@Z ENDP ; DataStructures::List<FileListNode>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Size@?$List@UFileListNode@@@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$List@UFileListNode@@@DataStructures@@QBEIXZ PROC ; DataStructures::List<FileListNode>::Size, COMDAT
; _this$ = ecx

; 373  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 374  : 		return list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 375  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$List@UFileListNode@@@DataStructures@@QBEIXZ ENDP ; DataStructures::List<FileListNode>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Del@?$List@UFileListNode@@@DataStructures@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_num$ = 8						; size = 4
?Del@?$List@UFileListNode@@@DataStructures@@QAEXI@Z PROC ; DataStructures::List<FileListNode>::Del, COMDAT
; _this$ = ecx

; 353  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 354  : 		// Delete the last elements on the list.  No compression needed
; 355  : #ifdef _DEBUG
; 356  : 		assert(list_size>=num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _num$[ebp]
	jae	SHORT $LN3@Del
	push	356					; 00000164H
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1BO@JBFMBKMD@?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$DO?$AA?$DN?$AAn?$AAu?$AAm?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@Del:

; 357  : #endif
; 358  : 		list_size-=num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _num$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 359  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Del@?$List@UFileListNode@@@DataStructures@@QAEXI@Z ENDP ; DataStructures::List<FileListNode>::Del
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?RemoveAtIndex@?$List@UFileListNode@@@DataStructures@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
?RemoveAtIndex@?$List@UFileListNode@@@DataStructures@@QAEXI@Z PROC ; DataStructures::List<FileListNode>::RemoveAtIndex, COMDAT
; _this$ = ecx

; 333  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 334  : #ifdef _DEBUG
; 335  : 		assert( position < list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN4@RemoveAtIn
	push	335					; 0000014fH
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@RemoveAtIn:

; 336  : #endif
; 337  : 
; 338  : 		if ( position < list_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN2@RemoveAtIn

; 339  : 		{
; 340  : 			// Compress the array
; 341  : 			/*
; 342  : 			for ( unsigned int counter = position; counter < list_size - 1 ; ++counter )
; 343  : 			listArray[ counter ] = listArray[ counter + 1 ];
; 344  : 			*/
; 345  : 			memmove(listArray+position, listArray+position+1, (list_size-1-position) * sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	sub	ecx, DWORD PTR _position$[ebp]
	imul	edx, ecx, 17
	push	edx
	imul	eax, DWORD PTR _position$[ebp], 17
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax+17]
	push	eax
	imul	ecx, DWORD PTR _position$[ebp], 17
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	call	_memmove
	add	esp, 12					; 0000000cH

; 346  : 
; 347  : 			Del();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Del@?$List@UFileListNode@@@DataStructures@@QAEXI@Z ; DataStructures::List<FileListNode>::Del
$LN2@RemoveAtIn:

; 348  : 		}
; 349  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveAtIndex@?$List@UFileListNode@@@DataStructures@@QAEXI@Z ENDP ; DataStructures::List<FileListNode>::RemoveAtIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Insert@?$List@UFileListNode@@@DataStructures@@QAEXUFileListNode@@@Z
_TEXT	SEGMENT
$T1 = -236						; size = 4
$T2 = -224						; size = 4
_new_array$3 = -20					; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 17
?Insert@?$List@UFileListNode@@@DataStructures@@QAEXUFileListNode@@@Z PROC ; DataStructures::List<FileListNode>::Insert, COMDAT
; _this$ = ecx

; 242  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 243  : 		// Reallocate list if necessary
; 244  : 
; 245  : 		if ( list_size == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	$LN3@Insert

; 246  : 		{
; 247  : 			// allocate twice the currently allocated memory
; 248  : 			list_type * new_array;
; 249  : 
; 250  : 			if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Insert

; 251  : 				allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 16			; 00000010H

; 252  : 			else

	jmp	SHORT $LN1@Insert
$LN2@Insert:

; 253  : 				allocation_size *= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN1@Insert:

; 254  : 
; 255  : 			new_array = new list_type [ allocation_size ];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, 17					; 00000011H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _new_array$3[ebp], eax

; 256  : 
; 257  : 			// copy old array over
; 258  : 			//	for ( unsigned int counter = 0; counter < list_size; ++counter )
; 259  : 			//		new_array[ counter ] = listArray[ counter ];
; 260  : 
; 261  : 			// Don't call constructors, assignment operators, etc.
; 262  : 			memcpy(new_array, listArray, list_size*sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [eax+4], 17
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _new_array$3[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 263  : 
; 264  : 			// set old array to point to the newly allocated and twice as large array
; 265  : 			delete[] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 266  : 
; 267  : 			listArray = new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$3[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Insert:

; 268  : 		}
; 269  : 
; 270  : 		// Insert the new item at the correct spot
; 271  : 		listArray[ list_size ] = input;

	mov	eax, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [eax+4], 17
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, ecx
	mov	ecx, DWORD PTR _input$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _input$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _input$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _input$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	cl, BYTE PTR _input$[ebp+16]
	mov	BYTE PTR [eax+16], cl

; 272  : 
; 273  : 		++list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 274  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?Insert@?$List@UFileListNode@@@DataStructures@@QAEXUFileListNode@@@Z ENDP ; DataStructures::List<FileListNode>::Insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z PROC ; DataStructures::List<FileListNode>::operator[], COMDAT
; _this$ = ecx

; 185  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 186  : #ifdef _DEBUG
; 187  : 		assert ( position < list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN3@operator
	push	187					; 000000bbH
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@operator:

; 188  : #endif
; 189  : 		return listArray[ position ];

	imul	eax, DWORD PTR _position$[ebp], 17
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]

; 190  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ENDP ; DataStructures::List<FileListNode>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??1?$List@UFileListNode@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
??1?$List@UFileListNode@@@DataStructures@@QAE@XZ PROC	; DataStructures::List<FileListNode>::~List<FileListNode>, COMDAT
; _this$ = ecx

; 121  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 122  : 		if (allocation_size>0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jbe	SHORT $LN2@List

; 123  : 			delete [] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@List:

; 124  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@UFileListNode@@@DataStructures@@QAE@XZ ENDP	; DataStructures::List<FileListNode>::~List<FileListNode>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??0?$List@UFileListNode@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$List@UFileListNode@@@DataStructures@@QAE@XZ PROC	; DataStructures::List<FileListNode>::List<FileListNode>, COMDAT
; _this$ = ecx

; 113  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 114  : 		allocation_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 115  : 		listArray = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 116  : 		list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 117  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@UFileListNode@@@DataStructures@@QAE@XZ ENDP	; DataStructures::List<FileListNode>::List<FileListNode>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\filelist.cpp
;	COMDAT ?DeleteFiles@FileList@@QAEXPBD@Z
_TEXT	SEGMENT
_j$ = -556						; size = 4
_i$ = -544						; size = 4
_fullPath$ = -532					; size = 512
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_applicationDirectory$ = 8				; size = 4
?DeleteFiles@FileList@@QAEXPBD@Z PROC			; FileList::DeleteFiles, COMDAT
; _this$ = ecx

; 569  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 752				; 000002f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-752]
	mov	ecx, 188				; 000000bcH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 570  : 	char fullPath[512];
; 571  : 	unsigned i,j;
; 572  : 
; 573  : 	for (i=0; i < fileList.Size(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@DeleteFile
$LN6@DeleteFile:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@DeleteFile:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@UFileListNode@@@DataStructures@@QBEIXZ ; DataStructures::List<FileListNode>::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	$LN8@DeleteFile

; 574  : 	{
; 575  : 		// The filename should not have .. in the path - if it does ignore it
; 576  : 		for (j=1; j < strlen(fileList[i].filename); j++)

	mov	DWORD PTR _j$[ebp], 1
	jmp	SHORT $LN4@DeleteFile
$LN3@DeleteFile:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN4@DeleteFile:
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_strlen
	add	esp, 4
	cmp	DWORD PTR _j$[ebp], eax
	jae	SHORT $LN2@DeleteFile

; 577  : 		{
; 578  : 			if (fileList[i].filename[j]=='.' && fileList[i].filename[j-1]=='.')

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _j$[ebp]
	movsx	eax, BYTE PTR [ecx+edx]
	cmp	eax, 46					; 0000002eH
	jne	SHORT $LN1@DeleteFile
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _j$[ebp]
	movsx	eax, BYTE PTR [ecx+edx-1]
	cmp	eax, 46					; 0000002eH
	jne	SHORT $LN1@DeleteFile

; 579  : 			{
; 580  : #ifdef _DEBUG
; 581  : 				assert(0);

	xor	eax, eax
	jne	SHORT $LN10@DeleteFile
	mov	ecx, DWORD PTR ?__LINE__Var@?1??DeleteFiles@FileList@@QAEXPBD@Z@4JA
	add	ecx, 12					; 0000000cH
	push	ecx
	push	OFFSET ??_C@_1EK@JGBLDIEJ@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAf?$AAi?$AAl?$AAe?$AAl?$AAi?$AAs?$AAt@
	push	OFFSET ??_C@_13COJANIEC@?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN10@DeleteFile:

; 582  : #endif
; 583  : 				// Just cancel the deletion entirely
; 584  : 				return;

	jmp	SHORT $LN8@DeleteFile
$LN1@DeleteFile:

; 585  : 			}
; 586  : 		}

	jmp	$LN3@DeleteFile
$LN2@DeleteFile:

; 587  : 
; 588  : 		strcpy(fullPath, applicationDirectory);

	mov	eax, DWORD PTR _applicationDirectory$[ebp]
	push	eax
	lea	ecx, DWORD PTR _fullPath$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 589  : 		strcat(fullPath, fileList[i].filename);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR _fullPath$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 590  :         _unlink(fullPath);

	lea	eax, DWORD PTR _fullPath$[ebp]
	push	eax
	call	__unlink
	add	esp, 4

; 591  : 	}

	jmp	$LN6@DeleteFile
$LN8@DeleteFile:

; 592  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN13@DeleteFile
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 752				; 000002f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN13@DeleteFile:
	DD	1
	DD	$LN12@DeleteFile
$LN12@DeleteFile:
	DD	-532					; fffffdecH
	DD	512					; 00000200H
	DD	$LN11@DeleteFile
$LN11@DeleteFile:
	DB	102					; 00000066H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
?DeleteFiles@FileList@@QAEXPBD@Z ENDP			; FileList::DeleteFiles
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\filelist.cpp
;	COMDAT ?AddFile@FileList@@QAEXPBD0E@Z
_TEXT	SEGMENT
tv81 = -300						; size = 4
tv94 = -296						; size = 4
$T1 = -288						; size = 4
$T2 = -276						; size = 4
__$AllocaPad$$ = -72					; size = 4
_usedAlloca$ = -57					; size = 1
_length$ = -48						; size = 4
_fp$ = -36						; size = 4
_data$ = -24						; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_filepath$ = 8						; size = 4
_filename$ = 12						; size = 4
_context$ = 16						; size = 1
?AddFile@FileList@@QAEXPBD0E@Z PROC			; FileList::AddFile, COMDAT
; _this$ = ecx

; 57   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 300				; 0000012cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-300]
	mov	ecx, 75					; 0000004bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$AllocaPad$$[ebp], 0

; 58   : 	if (filepath==0 || filename==0)

	cmp	DWORD PTR _filepath$[ebp], 0
	je	SHORT $LN5@AddFile
	cmp	DWORD PTR _filename$[ebp], 0
	jne	SHORT $LN6@AddFile
$LN5@AddFile:

; 59   : 		return;

	jmp	$LN7@AddFile
$LN6@AddFile:

; 60   : 
; 61   : 	char *data;
; 62   : 	FILE *fp = fopen(filepath, "rb");

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	mov	eax, DWORD PTR _filepath$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax

; 63   : 	if (fp==0)

	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN4@AddFile

; 64   : 		return;

	jmp	$LN7@AddFile
$LN4@AddFile:

; 65   : 	fseek(fp, 0, SEEK_END);

	push	2
	push	0
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 66   : 	int length = ftell(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_ftell
	add	esp, 4
	mov	DWORD PTR _length$[ebp], eax

; 67   : 	fseek(fp, 0, SEEK_SET);

	push	0
	push	0
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 68   : #if !defined(_COMPATIBILITY_1)
; 69   : 	bool usedAlloca=false;

	mov	BYTE PTR _usedAlloca$[ebp], 0

; 70   : 	if (length < MAX_ALLOCA_STACK_ALLOCATION)

	cmp	DWORD PTR _length$[ebp], 1048576	; 00100000H
	jge	SHORT $LN3@AddFile
	mov	eax, DWORD PTR _length$[ebp]
	add	eax, 36					; 00000024H
	mov	DWORD PTR tv94[ebp], eax

; 71   : 	{
; 72   : 		data = ( char* ) alloca( length );

	mov	eax, DWORD PTR tv94[ebp]
	call	__alloca_probe_16
	mov	DWORD PTR tv81[ebp], esp
	lea	ecx, DWORD PTR __$AllocaPad$$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv94[ebp]
	mov	ecx, DWORD PTR tv81[ebp]
	call	@_RTC_AllocaHelper@12
	add	DWORD PTR tv81[ebp], 32			; 00000020H
	mov	edx, DWORD PTR tv81[ebp]
	mov	DWORD PTR _data$[ebp], edx

; 73   : 		usedAlloca=true;

	mov	BYTE PTR _usedAlloca$[ebp], 1

; 74   : 	}
; 75   : 	else

	jmp	SHORT $LN2@AddFile
$LN3@AddFile:

; 76   : #endif
; 77   : 	{
; 78   : 		data = new char [length];

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR _data$[ebp], ecx
$LN2@AddFile:

; 79   : 	}
; 80   : 
; 81   : 	AddFile(filename, data, length, length, context);

	movzx	eax, BYTE PTR _context$[ebp]
	push	eax
	mov	ecx, DWORD PTR _length$[ebp]
	push	ecx
	mov	edx, DWORD PTR _length$[ebp]
	push	edx
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddFile@FileList@@QAEXPBD0IIE@Z	; FileList::AddFile

; 82   : 	fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 83   : 
; 84   : #if !defined(_COMPATIBILITY_1)
; 85   : 	if (usedAlloca==false)

	movzx	eax, BYTE PTR _usedAlloca$[ebp]
	test	eax, eax
	jne	SHORT $LN7@AddFile

; 86   : #endif
; 87   : 		delete [] data;

	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@AddFile:

; 88   : 
; 89   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@AddFile
	push	DWORD PTR __$AllocaPad$$[ebp]
	call	@_RTC_CheckStackVars2@12
	pop	eax
	pop	edx
	lea	esp, DWORD PTR [ebp-312]
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	3
$LN11@AddFile:
	DD	1
	DD	$LN10@AddFile
$LN10@AddFile:
	DD	-72					; ffffffb8H
	DD	4
	DD	$LN9@AddFile
$LN9@AddFile:
	DB	95					; 0000005fH
	DB	36					; 00000024H
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	36					; 00000024H
	DB	0
?AddFile@FileList@@QAEXPBD0E@Z ENDP			; FileList::AddFile
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\filelist.cpp
;	COMDAT ?AddFile@FileList@@QAEXPBD0IIE@Z
_TEXT	SEGMENT
$T1 = -288						; size = 4
$T2 = -276						; size = 4
$T3 = -264						; size = 4
$T4 = -252						; size = 4
_n$ = -48						; size = 17
_i$ = -20						; size = 4
_this$ = -8						; size = 4
_filename$ = 8						; size = 4
_data$ = 12						; size = 4
_dataLength$ = 16					; size = 4
_fileLength$ = 20					; size = 4
_context$ = 24						; size = 1
?AddFile@FileList@@QAEXPBD0IIE@Z PROC			; FileList::AddFile, COMDAT
; _this$ = ecx

; 91   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-292]
	mov	ecx, 73					; 00000049H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 92   : 	if (filename==0)

	cmp	DWORD PTR _filename$[ebp], 0
	jne	SHORT $LN9@AddFile

; 93   : 		return;

	jmp	$LN10@AddFile
$LN9@AddFile:

; 94   : 
; 95   : 	// Avoid duplicate insertions unless the data is different, in which case overwrite the old data
; 96   : 	unsigned i;
; 97   : 	for (i=0; i<fileList.Size();i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN8@AddFile
$LN7@AddFile:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN8@AddFile:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@UFileListNode@@@DataStructures@@QBEIXZ ; DataStructures::List<FileListNode>::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	$LN6@AddFile

; 98   : 	{
; 99   : 		if (strcmp(fileList[i].filename, filename)==0)

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	edx, DWORD PTR [eax]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	$LN5@AddFile

; 100  : 		{
; 101  : 			if (fileList[i].fileLength==fileLength && fileList[i].dataLength==dataLength &&
; 102  : 				(dataLength==0 || memcmp(fileList[i].data, data, dataLength)==0))

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR _fileLength$[ebp]
	jne	SHORT $LN4@AddFile
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _dataLength$[ebp]
	jne	SHORT $LN4@AddFile
	cmp	DWORD PTR _dataLength$[ebp], 0
	je	SHORT $LN3@AddFile
	mov	eax, DWORD PTR _dataLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	eax, DWORD PTR [eax+4]
	push	eax
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN4@AddFile
$LN3@AddFile:

; 103  : 				// Exact same file already here
; 104  : 				return;

	jmp	$LN10@AddFile
$LN4@AddFile:

; 105  : 
; 106  : 			// File of the same name, but different contents, so overwrite
; 107  : 			delete [] fileList[i].data;

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 108  : 			delete [] fileList[i].filename;

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 109  : 			fileList.RemoveAtIndex(i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAtIndex@?$List@UFileListNode@@@DataStructures@@QAEXI@Z ; DataStructures::List<FileListNode>::RemoveAtIndex

; 110  : 			break;

	jmp	SHORT $LN6@AddFile
$LN5@AddFile:

; 111  : 		}
; 112  : 	}

	jmp	$LN7@AddFile
$LN6@AddFile:

; 113  : 
; 114  : 	FileListNode n;
; 115  : 	n.filename=new char [strlen(filename)+1];

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR _n$[ebp], ecx

; 116  : 	if (dataLength)

	cmp	DWORD PTR _dataLength$[ebp], 0
	je	SHORT $LN2@AddFile

; 117  : 	{
; 118  : 		n.data=new char [dataLength];

	mov	eax, DWORD PTR _dataLength$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	ecx, DWORD PTR $T4[ebp]
	mov	DWORD PTR _n$[ebp+4], ecx

; 119  : 		memcpy(n.data, data, dataLength);

	mov	eax, DWORD PTR _dataLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _n$[ebp+4]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 120  : 	}
; 121  : 	else

	jmp	SHORT $LN1@AddFile
$LN2@AddFile:

; 122  : 		n.data=0;

	mov	DWORD PTR _n$[ebp+4], 0
$LN1@AddFile:

; 123  : 	n.dataLength=dataLength;

	mov	eax, DWORD PTR _dataLength$[ebp]
	mov	DWORD PTR _n$[ebp+8], eax

; 124  : 	n.fileLength=fileLength;

	mov	eax, DWORD PTR _fileLength$[ebp]
	mov	DWORD PTR _n$[ebp+12], eax

; 125  : 	n.context=context;

	mov	al, BYTE PTR _context$[ebp]
	mov	BYTE PTR _n$[ebp+16], al

; 126  : 	strcpy(n.filename, filename);

	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 127  : 		
; 128  : 	fileList.Insert(n);

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _n$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _n$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _n$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	cl, BYTE PTR _n$[ebp+16]
	mov	BYTE PTR [eax+16], cl
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Insert@?$List@UFileListNode@@@DataStructures@@QAEXUFileListNode@@@Z ; DataStructures::List<FileListNode>::Insert
$LN10@AddFile:

; 129  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN14@AddFile
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 292				; 00000124H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
	npad	3
$LN14@AddFile:
	DD	1
	DD	$LN13@AddFile
$LN13@AddFile:
	DD	-48					; ffffffd0H
	DD	17					; 00000011H
	DD	$LN12@AddFile
$LN12@AddFile:
	DB	110					; 0000006eH
	DB	0
?AddFile@FileList@@QAEXPBD0IIE@Z ENDP			; FileList::AddFile
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\filelist.cpp
;	COMDAT ?WriteDataToDisk@FileList@@QAEXPBD@Z
_TEXT	SEGMENT
_j$ = -556						; size = 4
_i$ = -544						; size = 4
_fullPath$ = -532					; size = 512
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_applicationDirectory$ = 8				; size = 4
?WriteDataToDisk@FileList@@QAEXPBD@Z PROC		; FileList::WriteDataToDisk, COMDAT
; _this$ = ecx

; 539  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 752				; 000002f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-752]
	mov	ecx, 188				; 000000bcH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 540  : 	char fullPath[512];
; 541  : 	unsigned i,j;
; 542  : 
; 543  : 	for (i=0; i < fileList.Size(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN8@WriteDataT
$LN7@WriteDataT:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN8@WriteDataT:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@UFileListNode@@@DataStructures@@QBEIXZ ; DataStructures::List<FileListNode>::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	$LN9@WriteDataT

; 544  : 	{
; 545  : 		strcpy(fullPath, applicationDirectory);

	mov	eax, DWORD PTR _applicationDirectory$[ebp]
	push	eax
	lea	ecx, DWORD PTR _fullPath$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 546  : 		if (fullPath[strlen(fullPath)-1]!='/' && fullPath[strlen(fullPath)-1]!='\\')

	lea	eax, DWORD PTR _fullPath$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	movsx	ecx, BYTE PTR _fullPath$[ebp+eax-1]
	cmp	ecx, 47					; 0000002fH
	je	SHORT $LN5@WriteDataT
	lea	eax, DWORD PTR _fullPath$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	movsx	ecx, BYTE PTR _fullPath$[ebp+eax-1]
	cmp	ecx, 92					; 0000005cH
	je	SHORT $LN5@WriteDataT

; 547  : 			strcat(fullPath, "/");

	push	OFFSET ??_C@_01KMDKNFGN@?1?$AA@
	lea	eax, DWORD PTR _fullPath$[ebp]
	push	eax
	call	_strcat
	add	esp, 8
$LN5@WriteDataT:

; 548  : 		strcat(fullPath,fileList[i].filename);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR _fullPath$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 549  : 		
; 550  : 		// Security - Don't allow .. in the filename anywhere so you can't write outside of the root directory
; 551  : 		for (j=1; j < strlen(fileList[i].filename); j++)

	mov	DWORD PTR _j$[ebp], 1
	jmp	SHORT $LN4@WriteDataT
$LN3@WriteDataT:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN4@WriteDataT:
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_strlen
	add	esp, 4
	cmp	DWORD PTR _j$[ebp], eax
	jae	SHORT $LN2@WriteDataT

; 552  : 		{
; 553  : 			if (fileList[i].filename[j]=='.' && fileList[i].filename[j-1]=='.')

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _j$[ebp]
	movsx	eax, BYTE PTR [ecx+edx]
	cmp	eax, 46					; 0000002eH
	jne	SHORT $LN1@WriteDataT
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _j$[ebp]
	movsx	eax, BYTE PTR [ecx+edx-1]
	cmp	eax, 46					; 0000002eH
	jne	SHORT $LN1@WriteDataT

; 554  : 			{
; 555  : #ifdef _DEBUG
; 556  : 				assert(0);

	xor	eax, eax
	jne	SHORT $LN11@WriteDataT
	mov	ecx, DWORD PTR ?__LINE__Var@?1??WriteDataToDisk@FileList@@QAEXPBD@Z@4JA
	add	ecx, 17					; 00000011H
	push	ecx
	push	OFFSET ??_C@_1EK@JGBLDIEJ@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAf?$AAi?$AAl?$AAe?$AAl?$AAi?$AAs?$AAt@
	push	OFFSET ??_C@_13COJANIEC@?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN11@WriteDataT:

; 557  : #endif
; 558  : 				// Just cancel the write entirely
; 559  : 				return;

	jmp	SHORT $LN9@WriteDataT
$LN1@WriteDataT:

; 560  : 			}
; 561  : 		}

	jmp	$LN3@WriteDataT
$LN2@WriteDataT:

; 562  : 
; 563  : 		WriteFileWithDirectories(fullPath, fileList[i].data, fileList[i].dataLength);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	eax, DWORD PTR [eax+4]
	push	eax
	lea	ecx, DWORD PTR _fullPath$[ebp]
	push	ecx
	call	?WriteFileWithDirectories@@YA_NPBDPADI@Z ; WriteFileWithDirectories
	add	esp, 12					; 0000000cH

; 564  : 	}

	jmp	$LN7@WriteDataT
$LN9@WriteDataT:

; 565  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN14@WriteDataT
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 752				; 000002f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$LN14@WriteDataT:
	DD	1
	DD	$LN13@WriteDataT
$LN13@WriteDataT:
	DD	-532					; fffffdecH
	DD	512					; 00000200H
	DD	$LN12@WriteDataT
$LN12@WriteDataT:
	DB	102					; 00000066H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
?WriteDataToDisk@FileList@@QAEXPBD@Z ENDP		; FileList::WriteDataToDisk
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\filelist.cpp
;	COMDAT ?PopulateDataFromDisk@FileList@@QAEXPBD_N11@Z
_TEXT	SEGMENT
$T2 = -1020						; size = 4
$T3 = -1008						; size = 4
$T4 = -996						; size = 4
$T5 = -984						; size = 4
$T6 = -972						; size = 4
$T7 = -960						; size = 4
_sha1$ = -756						; size = 180
_i$ = -568						; size = 4
_fullPath$ = -556					; size = 512
_fp$ = -36						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_applicationDirectory$ = 8				; size = 4
_writeFileData$ = 12					; size = 1
_writeFileHash$ = 16					; size = 1
_removeUnknownFiles$ = 20				; size = 1
?PopulateDataFromDisk@FileList@@QAEXPBD_N11@Z PROC	; FileList::PopulateDataFromDisk, COMDAT
; _this$ = ecx

; 460  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PopulateDataFromDisk@FileList@@QAEXPBD_N11@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1012				; 000003f4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-1024]
	mov	ecx, 253				; 000000fdH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 461  : 	FILE *fp;
; 462  : 	char fullPath[512];
; 463  : 	unsigned i;
; 464  : 	CSHA1 sha1;

	lea	ecx, DWORD PTR _sha1$[ebp]
	call	??0CSHA1@@QAE@XZ			; CSHA1::CSHA1
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 465  : 
; 466  : 	i=0;

	mov	DWORD PTR _i$[ebp], 0
$LN16@PopulateDa:

; 467  : 	while (i < fileList.Size())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@UFileListNode@@@DataStructures@@QBEIXZ ; DataStructures::List<FileListNode>::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	$LN15@PopulateDa

; 468  : 	{
; 469  : 		delete [] fileList[i].data;

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 470  : 		strcpy(fullPath, applicationDirectory);

	mov	eax, DWORD PTR _applicationDirectory$[ebp]
	push	eax
	lea	ecx, DWORD PTR _fullPath$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 471  : 		if (fullPath[strlen(fullPath)-1]!='/' && fullPath[strlen(fullPath)-1]!='\\')

	lea	eax, DWORD PTR _fullPath$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	movsx	ecx, BYTE PTR _fullPath$[ebp+eax-1]
	cmp	ecx, 47					; 0000002fH
	je	SHORT $LN14@PopulateDa
	lea	eax, DWORD PTR _fullPath$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	movsx	ecx, BYTE PTR _fullPath$[ebp+eax-1]
	cmp	ecx, 92					; 0000005cH
	je	SHORT $LN14@PopulateDa

; 472  : 			strcat(fullPath, "/");

	push	OFFSET ??_C@_01KMDKNFGN@?1?$AA@
	lea	eax, DWORD PTR _fullPath$[ebp]
	push	eax
	call	_strcat
	add	esp, 8
$LN14@PopulateDa:

; 473  : 		strcat(fullPath,fileList[i].filename);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR _fullPath$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 474  : 		fp=fopen(fullPath, "rb");

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	lea	eax, DWORD PTR _fullPath$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax

; 475  : 		if (fp)

	cmp	DWORD PTR _fp$[ebp], 0
	je	$LN13@PopulateDa

; 476  : 		{
; 477  : 			if (writeFileHash || writeFileData)

	movzx	eax, BYTE PTR _writeFileHash$[ebp]
	test	eax, eax
	jne	SHORT $LN11@PopulateDa
	movzx	eax, BYTE PTR _writeFileData$[ebp]
	test	eax, eax
	je	$LN12@PopulateDa
$LN11@PopulateDa:

; 478  : 			{
; 479  : 				fseek(fp, 0, SEEK_END);

	push	2
	push	0
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 480  : 				fileList[i].fileLength = ftell(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_ftell
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	DWORD PTR [eax+12], esi

; 481  : 				fseek(fp, 0, SEEK_SET);

	push	0
	push	0
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 482  : 				if (writeFileHash)

	movzx	eax, BYTE PTR _writeFileHash$[ebp]
	test	eax, eax
	je	$LN10@PopulateDa

; 483  : 				{
; 484  : 					if (writeFileData)

	movzx	eax, BYTE PTR _writeFileData$[ebp]
	test	eax, eax
	je	$LN9@PopulateDa

; 485  : 					{
; 486  : 						// Hash + data so offset the data by SHA1_LENGTH
; 487  : 						fileList[i].data=new char[fileList[i].fileLength+SHA1_LENGTH];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 20					; 00000014H
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR [eax+4], ecx

; 488  : 						fread(fileList[i].data+SHA1_LENGTH, fileList[i].fileLength, 1, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	edx, DWORD PTR [eax+12]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 20					; 00000014H
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 489  : 						sha1.Reset();

	lea	ecx, DWORD PTR _sha1$[ebp]
	call	?Reset@CSHA1@@QAEXXZ			; CSHA1::Reset

; 490  : 						sha1.Update((unsigned char*)fileList[i].data+SHA1_LENGTH, fileList[i].fileLength);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	eax, DWORD PTR [eax+4]
	add	eax, 20					; 00000014H
	push	eax
	lea	ecx, DWORD PTR _sha1$[ebp]
	call	?Update@CSHA1@@QAEXPAEI@Z		; CSHA1::Update

; 491  : 						sha1.Final();

	lea	ecx, DWORD PTR _sha1$[ebp]
	call	?Final@CSHA1@@QAEXXZ			; CSHA1::Final

; 492  : 						memcpy(fileList[i].data, sha1.GetHash(), SHA1_LENGTH);

	push	20					; 00000014H
	lea	ecx, DWORD PTR _sha1$[ebp]
	call	?GetHash@CSHA1@@QBEPAEXZ		; CSHA1::GetHash
	push	eax
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 493  : 					}
; 494  : 					else

	jmp	$LN8@PopulateDa
$LN9@PopulateDa:

; 495  : 					{
; 496  : 						// Hash only
; 497  : 						fileList[i].dataLength=SHA1_LENGTH;

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	DWORD PTR [eax+8], 20			; 00000014H

; 498  : 						if (fileList[i].fileLength < SHA1_LENGTH)

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	cmp	DWORD PTR [eax+12], 20			; 00000014H
	jae	SHORT $LN7@PopulateDa

; 499  : 							fileList[i].data=new char[SHA1_LENGTH];

	push	20					; 00000014H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR $T4[ebp]
	mov	DWORD PTR [eax+4], ecx

; 500  : 						else

	jmp	SHORT $LN6@PopulateDa
$LN7@PopulateDa:

; 501  : 							fileList[i].data=new char[fileList[i].fileLength];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR $T5[ebp]
	mov	DWORD PTR [eax+4], ecx
$LN6@PopulateDa:

; 502  : 						fread(fileList[i].data, fileList[i].fileLength, 1, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	edx, DWORD PTR [eax+12]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 503  : 						sha1.Reset();

	lea	ecx, DWORD PTR _sha1$[ebp]
	call	?Reset@CSHA1@@QAEXXZ			; CSHA1::Reset

; 504  : 						sha1.Update((unsigned char*)fileList[i].data, fileList[i].fileLength);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	eax, DWORD PTR [eax+4]
	push	eax
	lea	ecx, DWORD PTR _sha1$[ebp]
	call	?Update@CSHA1@@QAEXPAEI@Z		; CSHA1::Update

; 505  : 						sha1.Final();

	lea	ecx, DWORD PTR _sha1$[ebp]
	call	?Final@CSHA1@@QAEXXZ			; CSHA1::Final

; 506  : 						memcpy(fileList[i].data, sha1.GetHash(), SHA1_LENGTH);

	push	20					; 00000014H
	lea	ecx, DWORD PTR _sha1$[ebp]
	call	?GetHash@CSHA1@@QBEPAEXZ		; CSHA1::GetHash
	push	eax
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN8@PopulateDa:

; 507  : 					}
; 508  : 				}
; 509  : 				else

	jmp	$LN5@PopulateDa
$LN10@PopulateDa:

; 510  : 				{
; 511  : 					// Data only
; 512  : 					fileList[i].dataLength=fileList[i].fileLength;

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	esi, eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+8], edx

; 513  : 					fileList[i].data=new char[fileList[i].fileLength];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T6[ebp], eax
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR $T6[ebp]
	mov	DWORD PTR [eax+4], ecx

; 514  : 					fread(fileList[i].data, fileList[i].fileLength, 1, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	edx, DWORD PTR [eax+12]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H
$LN5@PopulateDa:

; 515  : 				}
; 516  : 
; 517  : 				fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 518  : 				i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax

; 519  : 			}
; 520  : 			else

	jmp	SHORT $LN4@PopulateDa
$LN12@PopulateDa:

; 521  : 			{
; 522  : 				fileList[i].data=0;

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	DWORD PTR [eax+4], 0

; 523  : 				fileList[i].dataLength=0;

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	DWORD PTR [eax+8], 0
$LN4@PopulateDa:

; 524  : 			}
; 525  : 		}
; 526  : 		else

	jmp	SHORT $LN3@PopulateDa
$LN13@PopulateDa:

; 527  : 		{
; 528  : 			if (removeUnknownFiles)

	movzx	eax, BYTE PTR _removeUnknownFiles$[ebp]
	test	eax, eax
	je	SHORT $LN2@PopulateDa

; 529  : 			{
; 530  : 				delete [] fileList[i].filename;

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T7[ebp], ecx
	mov	edx, DWORD PTR $T7[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 531  : 				fileList.RemoveAtIndex(i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAtIndex@?$List@UFileListNode@@@DataStructures@@QAEXI@Z ; DataStructures::List<FileListNode>::RemoveAtIndex

; 532  : 			}
; 533  : 			else

	jmp	SHORT $LN3@PopulateDa
$LN2@PopulateDa:

; 534  : 				i++;			

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@PopulateDa:

; 535  : 		}
; 536  : 	}

	jmp	$LN16@PopulateDa
$LN15@PopulateDa:

; 537  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sha1$[ebp]
	call	??1CSHA1@@UAE@XZ			; CSHA1::~CSHA1
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN24@PopulateDa
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 1024				; 00000400H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	npad	2
$LN24@PopulateDa:
	DD	2
	DD	$LN23@PopulateDa
$LN23@PopulateDa:
	DD	-556					; fffffdd4H
	DD	512					; 00000200H
	DD	$LN20@PopulateDa
	DD	-756					; fffffd0cH
	DD	180					; 000000b4H
	DD	$LN21@PopulateDa
$LN21@PopulateDa:
	DB	115					; 00000073H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	49					; 00000031H
	DB	0
$LN20@PopulateDa:
	DB	102					; 00000066H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PopulateDataFromDisk@FileList@@QAEXPBD_N11@Z$0:
	lea	ecx, DWORD PTR _sha1$[ebp]
	jmp	??1CSHA1@@UAE@XZ			; CSHA1::~CSHA1
__ehhandler$?PopulateDataFromDisk@FileList@@QAEXPBD_N11@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1028]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?PopulateDataFromDisk@FileList@@QAEXPBD_N11@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?PopulateDataFromDisk@FileList@@QAEXPBD_N11@Z ENDP	; FileList::PopulateDataFromDisk
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\filelist.cpp
;	COMDAT ?GetDeltaToCurrent@FileList@@QAEXPAV1@0PBD1@Z
_TEXT	SEGMENT
_match$ = -77						; size = 1
_remoteSubdirLen$ = -68					; size = 4
_localPathLen$ = -56					; size = 4
_dirSubsetLen$ = -44					; size = 4
_inputIndex$ = -32					; size = 4
_thisIndex$ = -20					; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
_output$ = 12						; size = 4
_dirSubset$ = 16					; size = 4
_remoteSubdir$ = 20					; size = 4
?GetDeltaToCurrent@FileList@@QAEXPAV1@0PBD1@Z PROC	; FileList::GetDeltaToCurrent, COMDAT
; _this$ = ecx

; 337  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-276]
	mov	ecx, 69					; 00000045H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 338  : 	// For all files in this list that do not match the input list, write them to the output list.
; 339  : 	// dirSubset allows checking only a portion of the files in this list.
; 340  : 	unsigned thisIndex, inputIndex;
; 341  : 	unsigned dirSubsetLen, localPathLen, remoteSubdirLen;
; 342  : 	bool match;
; 343  : 	if (dirSubset)

	cmp	DWORD PTR _dirSubset$[ebp], 0
	je	SHORT $LN20@GetDeltaTo

; 344  : 		dirSubsetLen = (unsigned int) strlen(dirSubset);

	mov	eax, DWORD PTR _dirSubset$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _dirSubsetLen$[ebp], eax

; 345  : 	else

	jmp	SHORT $LN19@GetDeltaTo
$LN20@GetDeltaTo:

; 346  : 		dirSubsetLen = 0;

	mov	DWORD PTR _dirSubsetLen$[ebp], 0
$LN19@GetDeltaTo:

; 347  : 	if (remoteSubdir && remoteSubdir[0])

	cmp	DWORD PTR _remoteSubdir$[ebp], 0
	je	SHORT $LN18@GetDeltaTo
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _remoteSubdir$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	SHORT $LN18@GetDeltaTo

; 348  : 	{
; 349  : 		remoteSubdirLen=(unsigned int) strlen(remoteSubdir);

	mov	eax, DWORD PTR _remoteSubdir$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _remoteSubdirLen$[ebp], eax

; 350  : 		if (IsSlash(remoteSubdir[remoteSubdirLen-1]))

	mov	eax, DWORD PTR _remoteSubdir$[ebp]
	add	eax, DWORD PTR _remoteSubdirLen$[ebp]
	movzx	ecx, BYTE PTR [eax-1]
	push	ecx
	call	?IsSlash@@YA_NE@Z			; IsSlash
	add	esp, 4
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN17@GetDeltaTo

; 351  : 			remoteSubdirLen--;

	mov	eax, DWORD PTR _remoteSubdirLen$[ebp]
	sub	eax, 1
	mov	DWORD PTR _remoteSubdirLen$[ebp], eax
$LN17@GetDeltaTo:

; 352  : 	}
; 353  : 	else

	jmp	SHORT $LN16@GetDeltaTo
$LN18@GetDeltaTo:

; 354  : 		remoteSubdirLen=0;

	mov	DWORD PTR _remoteSubdirLen$[ebp], 0
$LN16@GetDeltaTo:

; 355  : 
; 356  : 	for (thisIndex=0; thisIndex < fileList.Size(); thisIndex++)

	mov	DWORD PTR _thisIndex$[ebp], 0
	jmp	SHORT $LN15@GetDeltaTo
$LN14@GetDeltaTo:
	mov	eax, DWORD PTR _thisIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _thisIndex$[ebp], eax
$LN15@GetDeltaTo:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@UFileListNode@@@DataStructures@@QBEIXZ ; DataStructures::List<FileListNode>::Size
	cmp	DWORD PTR _thisIndex$[ebp], eax
	jae	$LN21@GetDeltaTo

; 357  : 	{
; 358  : 		localPathLen = (unsigned int) strlen(fileList[thisIndex].filename);

	mov	eax, DWORD PTR _thisIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _localPathLen$[ebp], eax
$LN12@GetDeltaTo:

; 359  : 		while (localPathLen>0)

	cmp	DWORD PTR _localPathLen$[ebp], 0
	jbe	SHORT $LN11@GetDeltaTo

; 360  : 		{
; 361  : 			if (IsSlash(fileList[thisIndex].filename[localPathLen-1]))

	mov	eax, DWORD PTR _thisIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _localPathLen$[ebp]
	movzx	eax, BYTE PTR [ecx+edx-1]
	push	eax
	call	?IsSlash@@YA_NE@Z			; IsSlash
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN10@GetDeltaTo

; 362  : 			{
; 363  : 				localPathLen--;

	mov	eax, DWORD PTR _localPathLen$[ebp]
	sub	eax, 1
	mov	DWORD PTR _localPathLen$[ebp], eax

; 364  : 				break;

	jmp	SHORT $LN11@GetDeltaTo
$LN10@GetDeltaTo:

; 365  : 			}
; 366  : 			localPathLen--;

	mov	eax, DWORD PTR _localPathLen$[ebp]
	sub	eax, 1
	mov	DWORD PTR _localPathLen$[ebp], eax

; 367  : 		}

	jmp	SHORT $LN12@GetDeltaTo
$LN11@GetDeltaTo:

; 368  : 
; 369  : 		// fileList[thisIndex].filename has to match dirSubset and be shorter or equal to it in length.
; 370  : 		if (dirSubsetLen>0 &&
; 371  : 			(localPathLen<dirSubsetLen ||
; 372  : 			_strnicmp(fileList[thisIndex].filename, dirSubset, dirSubsetLen)!=0 ||
; 373  : 			(localPathLen>dirSubsetLen && IsSlash(fileList[thisIndex].filename[dirSubsetLen])==false)))

	cmp	DWORD PTR _dirSubsetLen$[ebp], 0
	jbe	SHORT $LN9@GetDeltaTo
	mov	eax, DWORD PTR _localPathLen$[ebp]
	cmp	eax, DWORD PTR _dirSubsetLen$[ebp]
	jb	SHORT $LN8@GetDeltaTo
	mov	eax, DWORD PTR _dirSubsetLen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dirSubset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _thisIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	eax, DWORD PTR [eax]
	push	eax
	call	__strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN8@GetDeltaTo
	mov	eax, DWORD PTR _localPathLen$[ebp]
	cmp	eax, DWORD PTR _dirSubsetLen$[ebp]
	jbe	SHORT $LN9@GetDeltaTo
	mov	eax, DWORD PTR _thisIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _dirSubsetLen$[ebp]
	movzx	eax, BYTE PTR [ecx+edx]
	push	eax
	call	?IsSlash@@YA_NE@Z			; IsSlash
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN9@GetDeltaTo
$LN8@GetDeltaTo:

; 374  : 			continue;

	jmp	$LN14@GetDeltaTo
$LN9@GetDeltaTo:

; 375  : 
; 376  : 		match=false;

	mov	BYTE PTR _match$[ebp], 0

; 377  : 		for (inputIndex=0; inputIndex < input->fileList.Size(); inputIndex++)

	mov	DWORD PTR _inputIndex$[ebp], 0
	jmp	SHORT $LN7@GetDeltaTo
$LN6@GetDeltaTo:
	mov	eax, DWORD PTR _inputIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _inputIndex$[ebp], eax
$LN7@GetDeltaTo:
	mov	ecx, DWORD PTR _input$[ebp]
	call	?Size@?$List@UFileListNode@@@DataStructures@@QBEIXZ ; DataStructures::List<FileListNode>::Size
	cmp	DWORD PTR _inputIndex$[ebp], eax
	jae	$LN5@GetDeltaTo

; 378  : 		{
; 379  : 			// If the filenames, hashes, and lengths match then skip this element in fileList.  Otherwise write it to output
; 380  : 			if (_stricmp(input->fileList[inputIndex].filename+remoteSubdirLen,fileList[thisIndex].filename+dirSubsetLen)==0)

	mov	eax, DWORD PTR _thisIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _dirSubsetLen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _inputIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _input$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	eax, DWORD PTR [eax]
	add	eax, DWORD PTR _remoteSubdirLen$[ebp]
	push	eax
	call	__stricmp
	add	esp, 8
	test	eax, eax
	jne	$LN4@GetDeltaTo

; 381  : 			{
; 382  : 				match=true;

	mov	BYTE PTR _match$[ebp], 1

; 383  : 				if (input->fileList[inputIndex].fileLength==fileList[thisIndex].fileLength &&
; 384  : 					input->fileList[inputIndex].dataLength==fileList[thisIndex].dataLength &&
; 385  : 					memcmp(input->fileList[inputIndex].data,fileList[thisIndex].data,fileList[thisIndex].dataLength)==0)

	mov	eax, DWORD PTR _inputIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _input$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	esi, eax
	mov	ecx, DWORD PTR _thisIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	edx, DWORD PTR [esi+12]
	cmp	edx, DWORD PTR [eax+12]
	jne	SHORT $LN3@GetDeltaTo
	mov	eax, DWORD PTR _inputIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _input$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	esi, eax
	mov	ecx, DWORD PTR _thisIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	edx, DWORD PTR [esi+8]
	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $LN3@GetDeltaTo
	mov	eax, DWORD PTR _thisIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _thisIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	eax, DWORD PTR [eax+4]
	push	eax
	mov	ecx, DWORD PTR _inputIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _input$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	edx, DWORD PTR [eax+4]
	push	edx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN3@GetDeltaTo

; 386  : 				{
; 387  : 					// File exists on both machines and is the same.
; 388  : 					break;

	jmp	SHORT $LN5@GetDeltaTo

; 389  : 				}
; 390  : 				else

	jmp	SHORT $LN4@GetDeltaTo
$LN3@GetDeltaTo:

; 391  : 				{
; 392  : 					// File exists on both machines and is not the same.
; 393  : 					output->AddFile(fileList[inputIndex].filename, 0,0, fileList[inputIndex].fileLength, 0);

	push	0
	mov	eax, DWORD PTR _inputIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _inputIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _output$[ebp]
	call	?AddFile@FileList@@QAEXPBD0IIE@Z	; FileList::AddFile

; 394  : 					break;

	jmp	SHORT $LN5@GetDeltaTo
$LN4@GetDeltaTo:

; 395  : 				}
; 396  : 			}
; 397  : 		}

	jmp	$LN6@GetDeltaTo
$LN5@GetDeltaTo:

; 398  : 		if (match==false)

	movzx	eax, BYTE PTR _match$[ebp]
	test	eax, eax
	jne	SHORT $LN1@GetDeltaTo

; 399  : 		{
; 400  :             // Other system does not have the file at all
; 401  : 			output->AddFile(fileList[thisIndex].filename, 0,0, fileList[thisIndex].fileLength, 0);

	push	0
	mov	eax, DWORD PTR _thisIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _thisIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _output$[ebp]
	call	?AddFile@FileList@@QAEXPBD0IIE@Z	; FileList::AddFile
$LN1@GetDeltaTo:

; 402  : 		}
; 403  : 	}

	jmp	$LN14@GetDeltaTo
$LN21@GetDeltaTo:

; 404  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?GetDeltaToCurrent@FileList@@QAEXPAV1@0PBD1@Z ENDP	; FileList::GetDeltaToCurrent
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\filelist.cpp
;	COMDAT ?ListMissingOrChangedFiles@FileList@@QAEXPBDPAV1@_N2@Z
_TEXT	SEGMENT
$T2 = -996						; size = 4
$T3 = -984						; size = 4
_fileData$ = -780					; size = 4
_i$ = -768						; size = 4
_fullPath$ = -756					; size = 512
_fp$ = -236						; size = 4
_sha1$ = -224						; size = 180
_fileLength$ = -36					; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_applicationDirectory$ = 8				; size = 4
_missingOrChangedFiles$ = 12				; size = 4
_alwaysWriteHash$ = 16					; size = 1
_neverWriteHash$ = 20					; size = 1
?ListMissingOrChangedFiles@FileList@@QAEXPBDPAV1@_N2@Z PROC ; FileList::ListMissingOrChangedFiles, COMDAT
; _this$ = ecx

; 406  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ListMissingOrChangedFiles@FileList@@QAEXPBDPAV1@_N2@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 988				; 000003dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-1000]
	mov	ecx, 247				; 000000f7H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 407  : 	unsigned fileLength;
; 408  : 	CSHA1 sha1;

	lea	ecx, DWORD PTR _sha1$[ebp]
	call	??0CSHA1@@QAE@XZ			; CSHA1::CSHA1
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 409  : 	FILE *fp;
; 410  : 	char fullPath[512];
; 411  : 	unsigned i;
; 412  : 	char *fileData;
; 413  : 
; 414  : 	for (i=0; i < fileList.Size(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN12@ListMissin
$LN11@ListMissin:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN12@ListMissin:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@UFileListNode@@@DataStructures@@QBEIXZ ; DataStructures::List<FileListNode>::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	$LN10@ListMissin

; 415  : 	{
; 416  : 		strcpy(fullPath, applicationDirectory);

	mov	eax, DWORD PTR _applicationDirectory$[ebp]
	push	eax
	lea	ecx, DWORD PTR _fullPath$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 417  : 		if (fullPath[strlen(fullPath)-1]!='/' && fullPath[strlen(fullPath)-1]!='\\')

	lea	eax, DWORD PTR _fullPath$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	movsx	ecx, BYTE PTR _fullPath$[ebp+eax-1]
	cmp	ecx, 47					; 0000002fH
	je	SHORT $LN9@ListMissin
	lea	eax, DWORD PTR _fullPath$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	movsx	ecx, BYTE PTR _fullPath$[ebp+eax-1]
	cmp	ecx, 92					; 0000005cH
	je	SHORT $LN9@ListMissin

; 418  : 			strcat(fullPath, "/");

	push	OFFSET ??_C@_01KMDKNFGN@?1?$AA@
	lea	eax, DWORD PTR _fullPath$[ebp]
	push	eax
	call	_strcat
	add	esp, 8
$LN9@ListMissin:

; 419  : 		strcat(fullPath,fileList[i].filename);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR _fullPath$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 420  : 		fp=fopen(fullPath, "rb");

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	lea	eax, DWORD PTR _fullPath$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax

; 421  : 		if (fp==0)

	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN8@ListMissin

; 422  : 		{
; 423  : 			missingOrChangedFiles->AddFile(fileList[i].filename, 0, 0, 0, 0);

	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _missingOrChangedFiles$[ebp]
	call	?AddFile@FileList@@QAEXPBD0IIE@Z	; FileList::AddFile

; 424  : 		}
; 425  : 		else

	jmp	$LN7@ListMissin
$LN8@ListMissin:

; 426  : 		{
; 427  : 			fseek(fp, 0, SEEK_END);

	push	2
	push	0
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 428  : 			fileLength = ftell(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_ftell
	add	esp, 4
	mov	DWORD PTR _fileLength$[ebp], eax

; 429  : 			fseek(fp, 0, SEEK_SET);

	push	0
	push	0
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 430  : 
; 431  : 			if (fileLength != fileList[i].fileLength && alwaysWriteHash==false)

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR _fileLength$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	je	SHORT $LN6@ListMissin
	movzx	eax, BYTE PTR _alwaysWriteHash$[ebp]
	test	eax, eax
	jne	SHORT $LN6@ListMissin

; 432  : 			{
; 433  : 				missingOrChangedFiles->AddFile(fileList[i].filename, 0, 0, fileLength, 0);

	push	0
	mov	eax, DWORD PTR _fileLength$[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _missingOrChangedFiles$[ebp]
	call	?AddFile@FileList@@QAEXPBD0IIE@Z	; FileList::AddFile

; 434  : 			}
; 435  : 			else

	jmp	$LN7@ListMissin
$LN6@ListMissin:

; 436  : 			{
; 437  : 
; 438  : 				fileData= new char [fileLength];

	mov	eax, DWORD PTR _fileLength$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _fileData$[ebp], ecx

; 439  : 				fread(fileData, fileLength, 1, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _fileLength$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fileData$[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 440  : 				fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 441  : 
; 442  : 				sha1.Reset();

	lea	ecx, DWORD PTR _sha1$[ebp]
	call	?Reset@CSHA1@@QAEXXZ			; CSHA1::Reset

; 443  : 				sha1.Update( ( unsigned char* ) fileData, fileLength );

	mov	eax, DWORD PTR _fileLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fileData$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _sha1$[ebp]
	call	?Update@CSHA1@@QAEXPAEI@Z		; CSHA1::Update

; 444  : 				sha1.Final();

	lea	ecx, DWORD PTR _sha1$[ebp]
	call	?Final@CSHA1@@QAEXXZ			; CSHA1::Final

; 445  : 
; 446  : 				delete [] fileData;

	mov	eax, DWORD PTR _fileData$[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 447  : 
; 448  : 				if (fileLength != fileList[i].fileLength || memcmp( sha1.GetHash(), fileList[i].data, 20)!=0)

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR _fileLength$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jne	SHORT $LN3@ListMissin
	push	20					; 00000014H
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	ecx, DWORD PTR _sha1$[ebp]
	call	?GetHash@CSHA1@@QBEPAEXZ		; CSHA1::GetHash
	push	eax
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN7@ListMissin
$LN3@ListMissin:

; 449  : 				{
; 450  : 					if (neverWriteHash==false)

	movzx	eax, BYTE PTR _neverWriteHash$[ebp]
	test	eax, eax
	jne	SHORT $LN2@ListMissin

; 451  : 						missingOrChangedFiles->AddFile((const char*)fileList[i].filename, (const char*)sha1.GetHash(), 20, fileLength, 0);

	push	0
	mov	eax, DWORD PTR _fileLength$[ebp]
	push	eax
	push	20					; 00000014H
	lea	ecx, DWORD PTR _sha1$[ebp]
	call	?GetHash@CSHA1@@QBEPAEXZ		; CSHA1::GetHash
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _missingOrChangedFiles$[ebp]
	call	?AddFile@FileList@@QAEXPBD0IIE@Z	; FileList::AddFile

; 452  : 					else

	jmp	SHORT $LN7@ListMissin
$LN2@ListMissin:

; 453  : 						missingOrChangedFiles->AddFile((const char*)fileList[i].filename, 0, 0, fileLength, 0);

	push	0
	mov	eax, DWORD PTR _fileLength$[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _missingOrChangedFiles$[ebp]
	call	?AddFile@FileList@@QAEXPBD0IIE@Z	; FileList::AddFile
$LN7@ListMissin:

; 454  : 				}
; 455  : 			}
; 456  : 		}
; 457  : 	}

	jmp	$LN11@ListMissin
$LN10@ListMissin:

; 458  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sha1$[ebp]
	call	??1CSHA1@@UAE@XZ			; CSHA1::~CSHA1
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN20@ListMissin
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 1000				; 000003e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	npad	1
$LN20@ListMissin:
	DD	2
	DD	$LN19@ListMissin
$LN19@ListMissin:
	DD	-224					; ffffff20H
	DD	180					; 000000b4H
	DD	$LN16@ListMissin
	DD	-756					; fffffd0cH
	DD	512					; 00000200H
	DD	$LN17@ListMissin
$LN17@ListMissin:
	DB	102					; 00000066H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$LN16@ListMissin:
	DB	115					; 00000073H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	49					; 00000031H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ListMissingOrChangedFiles@FileList@@QAEXPBDPAV1@_N2@Z$0:
	lea	ecx, DWORD PTR _sha1$[ebp]
	jmp	??1CSHA1@@UAE@XZ			; CSHA1::~CSHA1
__ehhandler$?ListMissingOrChangedFiles@FileList@@QAEXPBDPAV1@_N2@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1004]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ListMissingOrChangedFiles@FileList@@QAEXPBDPAV1@_N2@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ListMissingOrChangedFiles@FileList@@QAEXPBDPAV1@_N2@Z ENDP ; FileList::ListMissingOrChangedFiles
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\filelist.cpp
;	COMDAT ?Deserialize@FileList@@QAE_NPAVBitStream@RakNet@@@Z
_TEXT	SEGMENT
$T1 = -836						; size = 4
$T2 = -824						; size = 4
_i$ = -620						; size = 4
_n$ = -608						; size = 17
_fileListSize$ = -580					; size = 4
_filename$ = -568					; size = 512
_fileLenMatchesDataLen$ = -45				; size = 1
_dataLenNonZero$ = -33					; size = 1
_b$ = -21						; size = 1
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_inBitStream$ = 8					; size = 4
?Deserialize@FileList@@QAE_NPAVBitStream@RakNet@@@Z PROC ; FileList::Deserialize, COMDAT
; _this$ = ecx

; 277  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 840				; 00000348H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-840]
	mov	ecx, 210				; 000000d2H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 278  : 	bool b, dataLenNonZero, fileLenMatchesDataLen;
; 279  : 	char filename[512];
; 280  : 	unsigned int fileListSize;
; 281  : 	FileListNode n;
; 282  : 	b=inBitStream->ReadCompressed(fileListSize);

	lea	eax, DWORD PTR _fileListSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inBitStream$[ebp]
	call	??$ReadCompressed@I@BitStream@RakNet@@QAE_NAAI@Z ; RakNet::BitStream::ReadCompressed<unsigned int>
	mov	BYTE PTR _b$[ebp], al

; 283  : #ifdef _DEBUG
; 284  : 	assert(b);

	movzx	eax, BYTE PTR _b$[ebp]
	test	eax, eax
	jne	SHORT $LN14@Deserializ
	mov	ecx, DWORD PTR ?__LINE__Var@?1??Deserialize@FileList@@QAE_NPAVBitStream@RakNet@@@Z@4JA
	add	ecx, 7
	push	ecx
	push	OFFSET ??_C@_1EK@JGBLDIEJ@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAf?$AAi?$AAl?$AAe?$AAl?$AAi?$AAs?$AAt@
	push	OFFSET ??_C@_13EPJEBPGL@?$AAb?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN14@Deserializ:

; 285  : 	assert(fileListSize < 10000);

	cmp	DWORD PTR _fileListSize$[ebp], 10000	; 00002710H
	jb	SHORT $LN15@Deserializ
	mov	eax, DWORD PTR ?__LINE__Var@?1??Deserialize@FileList@@QAE_NPAVBitStream@RakNet@@@Z@4JA
	add	eax, 8
	push	eax
	push	OFFSET ??_C@_1EK@JGBLDIEJ@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAf?$AAi?$AAl?$AAe?$AAl?$AAi?$AAs?$AAt@
	push	OFFSET ??_C@_1CK@PBAHFKCM@?$AAf?$AAi?$AAl?$AAe?$AAL?$AAi?$AAs?$AAt?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?5?$AA1?$AA0?$AA0?$AA0?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN15@Deserializ:

; 286  : #endif
; 287  : 	if (b==false || fileListSize > 10000)

	movzx	eax, BYTE PTR _b$[ebp]
	test	eax, eax
	je	SHORT $LN10@Deserializ
	cmp	DWORD PTR _fileListSize$[ebp], 10000	; 00002710H
	jbe	SHORT $LN11@Deserializ
$LN10@Deserializ:

; 288  : 		return false; // Sanity check

	xor	al, al
	jmp	$LN12@Deserializ
$LN11@Deserializ:

; 289  : 	Clear();	

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@FileList@@QAEXXZ			; FileList::Clear

; 290  : 	unsigned i;
; 291  : 	for (i=0; i < fileListSize; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN9@Deserializ
$LN8@Deserializ:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN9@Deserializ:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _fileListSize$[ebp]
	jae	$LN7@Deserializ

; 292  : 	{
; 293  : 		inBitStream->ReadCompressed(n.context);

	lea	eax, DWORD PTR _n$[ebp+16]
	push	eax
	mov	ecx, DWORD PTR _inBitStream$[ebp]
	call	??$ReadCompressed@E@BitStream@RakNet@@QAE_NAAE@Z ; RakNet::BitStream::ReadCompressed<unsigned char>

; 294  : 		stringCompressor->DecodeString((char*)filename, 512, inBitStream);

	push	0
	mov	eax, DWORD PTR _inBitStream$[ebp]
	push	eax
	push	512					; 00000200H
	lea	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	?Instance@StringCompressor@@SAPAV1@XZ	; StringCompressor::Instance
	mov	ecx, eax
	call	?DecodeString@StringCompressor@@QAE_NPADHPAVBitStream@RakNet@@H@Z ; StringCompressor::DecodeString

; 295  : 		inBitStream->Read(dataLenNonZero);

	lea	eax, DWORD PTR _dataLenNonZero$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inBitStream$[ebp]
	call	??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z ; RakNet::BitStream::Read<bool>

; 296  : 		if (dataLenNonZero)

	movzx	eax, BYTE PTR _dataLenNonZero$[ebp]
	test	eax, eax
	je	$LN6@Deserializ

; 297  : 		{
; 298  : 			inBitStream->ReadCompressed(n.dataLength);

	lea	eax, DWORD PTR _n$[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _inBitStream$[ebp]
	call	??$ReadCompressed@I@BitStream@RakNet@@QAE_NAAI@Z ; RakNet::BitStream::ReadCompressed<unsigned int>

; 299  : 			// sanity check
; 300  : 			if (n.dataLength>200000000)

	cmp	DWORD PTR _n$[ebp+8], 200000000		; 0bebc200H
	jbe	SHORT $LN5@Deserializ

; 301  : 			{
; 302  : #ifdef _DEBUG
; 303  : 				assert(n.dataLength<=200000000);

	cmp	DWORD PTR _n$[ebp+8], 200000000		; 0bebc200H
	jbe	SHORT $LN16@Deserializ
	mov	eax, DWORD PTR ?__LINE__Var@?1??Deserialize@FileList@@QAE_NPAVBitStream@RakNet@@@Z@4JA
	add	eax, 26					; 0000001aH
	push	eax
	push	OFFSET ??_C@_1EK@JGBLDIEJ@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAf?$AAi?$AAl?$AAe?$AAl?$AAi?$AAs?$AAt@
	push	OFFSET ??_C@_1DA@CODFILKM@?$AAn?$AA?4?$AAd?$AAa?$AAt?$AAa?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?$DM?$AA?$DN?$AA2?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN16@Deserializ:

; 304  : #endif
; 305  : 				return false;

	xor	al, al
	jmp	$LN12@Deserializ
$LN5@Deserializ:

; 306  : 			}
; 307  : 			n.data=new char [n.dataLength];

	mov	eax, DWORD PTR _n$[ebp+8]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR _n$[ebp+4], ecx

; 308  : 			inBitStream->Read(n.data, n.dataLength);

	mov	eax, DWORD PTR _n$[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _n$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR _inBitStream$[ebp]
	call	?Read@BitStream@RakNet@@QAE_NPADH@Z	; RakNet::BitStream::Read

; 309  : 		}
; 310  : 		else

	jmp	SHORT $LN4@Deserializ
$LN6@Deserializ:

; 311  : 		{
; 312  : 			n.dataLength=0;

	mov	DWORD PTR _n$[ebp+8], 0

; 313  : 			n.data=0;

	mov	DWORD PTR _n$[ebp+4], 0
$LN4@Deserializ:

; 314  : 		}
; 315  : 		
; 316  : 		b=inBitStream->Read(fileLenMatchesDataLen);

	lea	eax, DWORD PTR _fileLenMatchesDataLen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inBitStream$[ebp]
	call	??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z ; RakNet::BitStream::Read<bool>
	mov	BYTE PTR _b$[ebp], al

; 317  : 		if (fileLenMatchesDataLen)

	movzx	eax, BYTE PTR _fileLenMatchesDataLen$[ebp]
	test	eax, eax
	je	SHORT $LN3@Deserializ

; 318  : 			n.fileLength=n.dataLength;

	mov	eax, DWORD PTR _n$[ebp+8]
	mov	DWORD PTR _n$[ebp+12], eax

; 319  : 		else

	jmp	SHORT $LN2@Deserializ
$LN3@Deserializ:

; 320  : 			b=inBitStream->ReadCompressed(n.fileLength);

	lea	eax, DWORD PTR _n$[ebp+12]
	push	eax
	mov	ecx, DWORD PTR _inBitStream$[ebp]
	call	??$ReadCompressed@I@BitStream@RakNet@@QAE_NAAI@Z ; RakNet::BitStream::ReadCompressed<unsigned int>
	mov	BYTE PTR _b$[ebp], al
$LN2@Deserializ:

; 321  : #ifdef _DEBUG
; 322  : 		assert(b);

	movzx	eax, BYTE PTR _b$[ebp]
	test	eax, eax
	jne	SHORT $LN17@Deserializ
	mov	ecx, DWORD PTR ?__LINE__Var@?1??Deserialize@FileList@@QAE_NPAVBitStream@RakNet@@@Z@4JA
	add	ecx, 45					; 0000002dH
	push	ecx
	push	OFFSET ??_C@_1EK@JGBLDIEJ@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAf?$AAi?$AAl?$AAe?$AAl?$AAi?$AAs?$AAt@
	push	OFFSET ??_C@_13EPJEBPGL@?$AAb?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN17@Deserializ:

; 323  : #endif
; 324  : 		if (b==0)

	movzx	eax, BYTE PTR _b$[ebp]
	test	eax, eax
	jne	SHORT $LN1@Deserializ

; 325  : 		{
; 326  : 			Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@FileList@@QAEXXZ			; FileList::Clear

; 327  : 			return false;

	xor	al, al
	jmp	$LN12@Deserializ
$LN1@Deserializ:

; 328  : 		}
; 329  : 		n.filename=new char [strlen(filename)+1];

	lea	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _n$[ebp], ecx

; 330  : 		strcpy(n.filename, filename);

	lea	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 331  : 		fileList.Insert(n);

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _n$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _n$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _n$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	cl, BYTE PTR _n$[ebp+16]
	mov	BYTE PTR [eax+16], cl
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Insert@?$List@UFileListNode@@@DataStructures@@QAEXUFileListNode@@@Z ; DataStructures::List<FileListNode>::Insert

; 332  : 	}

	jmp	$LN8@Deserializ
$LN7@Deserializ:

; 333  : 
; 334  : 	return true;

	mov	al, 1
$LN12@Deserializ:

; 335  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN24@Deserializ
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 840				; 00000348H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN24@Deserializ:
	DD	5
	DD	$LN23@Deserializ
$LN23@Deserializ:
	DD	-33					; ffffffdfH
	DD	1
	DD	$LN18@Deserializ
	DD	-45					; ffffffd3H
	DD	1
	DD	$LN19@Deserializ
	DD	-568					; fffffdc8H
	DD	512					; 00000200H
	DD	$LN20@Deserializ
	DD	-580					; fffffdbcH
	DD	4
	DD	$LN21@Deserializ
	DD	-608					; fffffda0H
	DD	17					; 00000011H
	DD	$LN22@Deserializ
$LN22@Deserializ:
	DB	110					; 0000006eH
	DB	0
$LN21@Deserializ:
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	76					; 0000004cH
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$LN20@Deserializ:
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$LN19@Deserializ:
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	76					; 0000004cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	77					; 0000004dH
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	76					; 0000004cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$LN18@Deserializ:
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	76					; 0000004cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	78					; 0000004eH
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	90					; 0000005aH
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	0
?Deserialize@FileList@@QAE_NPAVBitStream@RakNet@@@Z ENDP ; FileList::Deserialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\filelist.cpp
;	COMDAT ?Serialize@FileList@@QAEXPAVBitStream@RakNet@@@Z
_TEXT	SEGMENT
tv133 = -221						; size = 1
tv131 = -220						; size = 4
tv173 = -217						; size = 1
_i$ = -20						; size = 4
_this$ = -8						; size = 4
_outBitStream$ = 8					; size = 4
?Serialize@FileList@@QAEXPAVBitStream@RakNet@@@Z PROC	; FileList::Serialize, COMDAT
; _this$ = ecx

; 257  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 224				; 000000e0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-224]
	mov	ecx, 56					; 00000038H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 258  : 	outBitStream->WriteCompressed(fileList.Size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@UFileListNode@@@DataStructures@@QBEIXZ ; DataStructures::List<FileListNode>::Size
	push	eax
	mov	ecx, DWORD PTR _outBitStream$[ebp]
	call	??$WriteCompressed@I@BitStream@RakNet@@QAEXI@Z ; RakNet::BitStream::WriteCompressed<unsigned int>

; 259  : 	unsigned i;
; 260  : 	for (i=0; i < fileList.Size(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN5@Serialize
$LN4@Serialize:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN5@Serialize:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@UFileListNode@@@DataStructures@@QBEIXZ ; DataStructures::List<FileListNode>::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	$LN6@Serialize

; 261  : 	{
; 262  : 		outBitStream->WriteCompressed(fileList[i].context);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	cl, BYTE PTR [eax+16]
	movzx	edx, cl
	push	edx
	mov	ecx, DWORD PTR _outBitStream$[ebp]
	call	??$WriteCompressed@E@BitStream@RakNet@@QAEXE@Z ; RakNet::BitStream::WriteCompressed<unsigned char>

; 263  : 		stringCompressor->EncodeString(fileList[i].filename, 512, outBitStream);

	push	0
	mov	eax, DWORD PTR _outBitStream$[ebp]
	push	eax
	push	512					; 00000200H
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?Instance@StringCompressor@@SAPAV1@XZ	; StringCompressor::Instance
	mov	ecx, eax
	call	?EncodeString@StringCompressor@@QAEXPBDHPAVBitStream@RakNet@@H@Z ; StringCompressor::EncodeString

; 264  : 		outBitStream->Write((bool)(fileList[i].dataLength>0==true));

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	cmp	DWORD PTR [eax+8], 0
	jbe	SHORT $LN8@Serialize
	mov	DWORD PTR tv131[ebp], 1
	jmp	SHORT $LN9@Serialize
$LN8@Serialize:
	mov	DWORD PTR tv131[ebp], 0
$LN9@Serialize:
	cmp	DWORD PTR tv131[ebp], 1
	jne	SHORT $LN10@Serialize
	mov	BYTE PTR tv133[ebp], 1
	jmp	SHORT $LN11@Serialize
$LN10@Serialize:
	mov	BYTE PTR tv133[ebp], 0
$LN11@Serialize:
	movzx	ecx, BYTE PTR tv133[ebp]
	push	ecx
	mov	ecx, DWORD PTR _outBitStream$[ebp]
	call	??$Write@_N@BitStream@RakNet@@QAEX_N@Z	; RakNet::BitStream::Write<bool>

; 265  : 		if (fileList[i].dataLength>0)

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	cmp	DWORD PTR [eax+8], 0
	jbe	SHORT $LN2@Serialize

; 266  : 		{
; 267  : 			outBitStream->WriteCompressed(fileList[i].dataLength);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR _outBitStream$[ebp]
	call	??$WriteCompressed@I@BitStream@RakNet@@QAEXI@Z ; RakNet::BitStream::WriteCompressed<unsigned int>

; 268  : 			outBitStream->Write(fileList[i].data, fileList[i].dataLength);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	eax, DWORD PTR [eax+4]
	push	eax
	mov	ecx, DWORD PTR _outBitStream$[ebp]
	call	?Write@BitStream@RakNet@@QAEXPBDH@Z	; RakNet::BitStream::Write
$LN2@Serialize:

; 269  : 		}
; 270  : 
; 271  : 		outBitStream->Write((bool)(fileList[i].fileLength==fileList[i].dataLength));

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	esi, eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	edx, DWORD PTR [esi+12]
	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $LN12@Serialize
	mov	BYTE PTR tv173[ebp], 1
	jmp	SHORT $LN13@Serialize
$LN12@Serialize:
	mov	BYTE PTR tv173[ebp], 0
$LN13@Serialize:
	movzx	eax, BYTE PTR tv173[ebp]
	push	eax
	mov	ecx, DWORD PTR _outBitStream$[ebp]
	call	??$Write@_N@BitStream@RakNet@@QAEX_N@Z	; RakNet::BitStream::Write<bool>

; 272  : 		if (fileList[i].fileLength!=fileList[i].dataLength)

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	esi, eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	edx, DWORD PTR [esi+12]
	cmp	edx, DWORD PTR [eax+8]
	je	SHORT $LN1@Serialize

; 273  : 			outBitStream->WriteCompressed(fileList[i].fileLength);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _outBitStream$[ebp]
	call	??$WriteCompressed@I@BitStream@RakNet@@QAEXI@Z ; RakNet::BitStream::WriteCompressed<unsigned int>
$LN1@Serialize:

; 274  : 	}

	jmp	$LN4@Serialize
$LN6@Serialize:

; 275  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 224				; 000000e0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Serialize@FileList@@QAEXPAVBitStream@RakNet@@@Z ENDP	; FileList::Serialize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\filelist.cpp
;	COMDAT ?Clear@FileList@@QAEXXZ
_TEXT	SEGMENT
$T1 = -236						; size = 4
$T2 = -224						; size = 4
_i$ = -20						; size = 4
_this$ = -8						; size = 4
?Clear@FileList@@QAEXXZ PROC				; FileList::Clear, COMDAT
; _this$ = ecx

; 247  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 248  : 	unsigned i;
; 249  : 	for (i=0; i<fileList.Size(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@Clear
$LN2@Clear:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@Clear:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@UFileListNode@@@DataStructures@@QBEIXZ ; DataStructures::List<FileListNode>::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN1@Clear

; 250  : 	{
; 251  : 		delete [] fileList[i].data;

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 252  : 		delete [] fileList[i].filename;

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UFileListNode@@@DataStructures@@QBEAAUFileListNode@@I@Z ; DataStructures::List<FileListNode>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 253  : 	}

	jmp	SHORT $LN2@Clear
$LN1@Clear:

; 254  : 	fileList.Clear();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UFileListNode@@@DataStructures@@QAEX_N@Z ; DataStructures::List<FileListNode>::Clear

; 255  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@FileList@@QAEXXZ ENDP				; FileList::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\filelist.cpp
;	COMDAT ?AddFilesFromDirectory@FileList@@QAEXPBD0_N11E@Z
_TEXT	SEGMENT
$T2 = -1732						; size = 4
$T3 = -1720						; size = 4
$T4 = -1708						; size = 4
$T5 = -1696						; size = 4
$T6 = -1684						; size = 4
$T7 = -1672						; size = 4
$T8 = -1660						; size = 4
$T9 = -1648						; size = 4
$T10 = -1636						; size = 4
_newDir$11 = -1432					; size = 4
_i$12 = -1420						; size = 4
_rootLen$ = -1408					; size = 4
_fileData$ = -1396					; size = 4
_dirSoFar$ = -1384					; size = 4
_sha1$ = -1372						; size = 180
_fp$ = -1184						; size = 4
_file$ = -1172						; size = 4
_dir$ = -1160						; size = 4
_fileInfo$ = -1148					; size = 296
_fullPath$ = -844					; size = 520
_root$ = -316						; size = 260
_dirList$ = -48						; size = 16
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_applicationDirectory$ = 8				; size = 4
_subDirectory$ = 12					; size = 4
_writeHash$ = 16					; size = 1
_writeData$ = 20					; size = 1
_recursive$ = 24					; size = 1
_context$ = 28						; size = 1
?AddFilesFromDirectory@FileList@@QAEXPBD0_N11E@Z PROC	; FileList::AddFilesFromDirectory, COMDAT
; _this$ = ecx

; 131  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddFilesFromDirectory@FileList@@QAEXPBD0_N11E@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1724				; 000006bcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-1736]
	mov	ecx, 431				; 000001afH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 132  : #ifndef _COMPATIBILITY_2
; 133  : 	DataStructures::Queue<char*> dirList;

	lea	ecx, DWORD PTR _dirList$[ebp]
	call	??0?$Queue@PAD@DataStructures@@QAE@XZ	; DataStructures::Queue<char *>::Queue<char *>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 134  : 	char root[260];
; 135  : 	char fullPath[520];
; 136  : 	_finddata_t fileInfo;
; 137  : 	intptr_t dir;
; 138  : 	int file;
; 139  : 	FILE *fp;
; 140  : 	CSHA1 sha1;

	lea	ecx, DWORD PTR _sha1$[ebp]
	call	??0CSHA1@@QAE@XZ			; CSHA1::CSHA1
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 141  : 	char *dirSoFar, *fileData;
; 142  : 	dirSoFar=new char[520];

	push	520					; 00000208H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _dirSoFar$[ebp], eax

; 143  : 
; 144  : 	if (applicationDirectory)

	cmp	DWORD PTR _applicationDirectory$[ebp], 0
	je	SHORT $LN28@AddFilesFr

; 145  : 		strcpy(root, applicationDirectory);

	mov	eax, DWORD PTR _applicationDirectory$[ebp]
	push	eax
	lea	ecx, DWORD PTR _root$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 146  : 	else

	jmp	SHORT $LN27@AddFilesFr
$LN28@AddFilesFr:

; 147  : 		root[0]=0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T3[ebp], ecx
	cmp	DWORD PTR $T3[ebp], 260			; 00000104H
	jae	SHORT $LN31@AddFilesFr
	jmp	SHORT $LN32@AddFilesFr
$LN31@AddFilesFr:
	call	___report_rangecheckfailure
$LN32@AddFilesFr:
	mov	edx, DWORD PTR $T3[ebp]
	mov	BYTE PTR _root$[ebp+edx], 0
$LN27@AddFilesFr:

; 148  : 
; 149  : 	int rootLen=(int)strlen(root);

	lea	eax, DWORD PTR _root$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _rootLen$[ebp], eax

; 150  : 	if (rootLen)

	cmp	DWORD PTR _rootLen$[ebp], 0
	je	SHORT $LN26@AddFilesFr

; 151  : 	{
; 152  : 		strcpy(dirSoFar, root);

	lea	eax, DWORD PTR _root$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dirSoFar$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 153  : 		if (dirSoFar[strlen(dirSoFar)-1]!='/' && dirSoFar[strlen(dirSoFar)-1]!='\\')

	mov	eax, DWORD PTR _dirSoFar$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _dirSoFar$[ebp]
	movsx	edx, BYTE PTR [ecx+eax-1]
	cmp	edx, 47					; 0000002fH
	je	SHORT $LN25@AddFilesFr
	mov	eax, DWORD PTR _dirSoFar$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _dirSoFar$[ebp]
	movsx	edx, BYTE PTR [ecx+eax-1]
	cmp	edx, 92					; 0000005cH
	je	SHORT $LN25@AddFilesFr

; 154  : 		{
; 155  : 			strcat(dirSoFar, "/");

	push	OFFSET ??_C@_01KMDKNFGN@?1?$AA@
	mov	eax, DWORD PTR _dirSoFar$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 156  : 			rootLen++;

	mov	eax, DWORD PTR _rootLen$[ebp]
	add	eax, 1
	mov	DWORD PTR _rootLen$[ebp], eax
$LN25@AddFilesFr:

; 157  : 		}
; 158  : 	}
; 159  : 	else

	jmp	SHORT $LN24@AddFilesFr
$LN26@AddFilesFr:

; 160  : 		dirSoFar[0]=0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _dirSoFar$[ebp]
	mov	BYTE PTR [edx+ecx], 0
$LN24@AddFilesFr:

; 161  : 	
; 162  : 	if (subDirectory)

	cmp	DWORD PTR _subDirectory$[ebp], 0
	je	SHORT $LN23@AddFilesFr

; 163  : 	{
; 164  : 		strcat(dirSoFar, subDirectory);

	mov	eax, DWORD PTR _subDirectory$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dirSoFar$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 165  : 		if (dirSoFar[strlen(dirSoFar)-1]!='/' && dirSoFar[strlen(dirSoFar)-1]!='\\')

	mov	eax, DWORD PTR _dirSoFar$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _dirSoFar$[ebp]
	movsx	edx, BYTE PTR [ecx+eax-1]
	cmp	edx, 47					; 0000002fH
	je	SHORT $LN23@AddFilesFr
	mov	eax, DWORD PTR _dirSoFar$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _dirSoFar$[ebp]
	movsx	edx, BYTE PTR [ecx+eax-1]
	cmp	edx, 92					; 0000005cH
	je	SHORT $LN23@AddFilesFr

; 166  : 		{
; 167  : 			strcat(dirSoFar, "/");

	push	OFFSET ??_C@_01KMDKNFGN@?1?$AA@
	mov	eax, DWORD PTR _dirSoFar$[ebp]
	push	eax
	call	_strcat
	add	esp, 8
$LN23@AddFilesFr:

; 168  : 		}
; 169  : 	}
; 170  : 	dirList.Push(dirSoFar);

	lea	eax, DWORD PTR _dirSoFar$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dirList$[ebp]
	call	?Push@?$Queue@PAD@DataStructures@@QAEXABQAD@Z ; DataStructures::Queue<char *>::Push
$LN21@AddFilesFr:

; 171  : 	while (dirList.Size())

	lea	ecx, DWORD PTR _dirList$[ebp]
	call	?Size@?$Queue@PAD@DataStructures@@QBEIXZ ; DataStructures::Queue<char *>::Size
	test	eax, eax
	je	$LN20@AddFilesFr

; 172  : 	{
; 173  : 		dirSoFar=dirList.Pop();

	lea	ecx, DWORD PTR _dirList$[ebp]
	call	?Pop@?$Queue@PAD@DataStructures@@QAEPADXZ ; DataStructures::Queue<char *>::Pop
	mov	DWORD PTR _dirSoFar$[ebp], eax

; 174  : 		strcpy(fullPath, dirSoFar);

	mov	eax, DWORD PTR _dirSoFar$[ebp]
	push	eax
	lea	ecx, DWORD PTR _fullPath$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 175  : 		strcat(fullPath, "*.*");

	push	OFFSET ??_C@_03EMIMMIHL@?$CK?4?$CK?$AA@
	lea	eax, DWORD PTR _fullPath$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 176  : 		dir=_findfirst(fullPath, &fileInfo ); // Read .

	lea	eax, DWORD PTR _fileInfo$[ebp]
	push	eax
	lea	ecx, DWORD PTR _fullPath$[ebp]
	push	ecx
	call	__findfirst64i32
	add	esp, 8
	mov	DWORD PTR _dir$[ebp], eax

; 177  : 		if (dir==-1)

	cmp	DWORD PTR _dir$[ebp], -1
	jne	$LN19@AddFilesFr

; 178  : 		{
; 179  : 			_findclose(dir);

	mov	eax, DWORD PTR _dir$[ebp]
	push	eax
	call	__findclose
	add	esp, 4

; 180  : 			delete [] dirSoFar;

	mov	eax, DWORD PTR _dirSoFar$[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	ecx, DWORD PTR $T4[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 181  : 			unsigned i;
; 182  : 			for (i=0; i < dirList.Size(); i++)

	mov	DWORD PTR _i$12[ebp], 0
	jmp	SHORT $LN18@AddFilesFr
$LN17@AddFilesFr:
	mov	eax, DWORD PTR _i$12[ebp]
	add	eax, 1
	mov	DWORD PTR _i$12[ebp], eax
$LN18@AddFilesFr:
	lea	ecx, DWORD PTR _dirList$[ebp]
	call	?Size@?$Queue@PAD@DataStructures@@QBEIXZ ; DataStructures::Queue<char *>::Size
	cmp	DWORD PTR _i$12[ebp], eax
	jae	SHORT $LN16@AddFilesFr

; 183  : 				delete [] dirList[i];

	mov	eax, DWORD PTR _i$12[ebp]
	push	eax
	lea	ecx, DWORD PTR _dirList$[ebp]
	call	??A?$Queue@PAD@DataStructures@@QBEAAPADI@Z ; DataStructures::Queue<char *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T5[ebp], ecx
	mov	edx, DWORD PTR $T5[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	jmp	SHORT $LN17@AddFilesFr
$LN16@AddFilesFr:

; 184  : 			return;

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _sha1$[ebp]
	call	??1CSHA1@@UAE@XZ			; CSHA1::~CSHA1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _dirList$[ebp]
	call	??1?$Queue@PAD@DataStructures@@QAE@XZ	; DataStructures::Queue<char *>::~Queue<char *>
	jmp	$LN30@AddFilesFr
$LN19@AddFilesFr:

; 185  : 		}
; 186  : 		file=_findnext(dir, &fileInfo ); // Read ..

	lea	eax, DWORD PTR _fileInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dir$[ebp]
	push	ecx
	call	__findnext64i32
	add	esp, 8
	mov	DWORD PTR _file$[ebp], eax

; 187  : 		file=_findnext(dir, &fileInfo ); // Skip ..

	lea	eax, DWORD PTR _fileInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dir$[ebp]
	push	ecx
	call	__findnext64i32
	add	esp, 8
	mov	DWORD PTR _file$[ebp], eax
$LN15@AddFilesFr:

; 188  : 
; 189  : 		while (file!=-1)

	cmp	DWORD PTR _file$[ebp], -1
	je	$LN14@AddFilesFr

; 190  : 		{
; 191  : 			if ((fileInfo.attrib & (_A_HIDDEN | _A_SUBDIR | _A_SYSTEM))==0)

	mov	eax, DWORD PTR _fileInfo$[ebp]
	and	eax, 22					; 00000016H
	jne	$LN13@AddFilesFr

; 192  : 			{
; 193  : 				strcpy(fullPath, dirSoFar);

	mov	eax, DWORD PTR _dirSoFar$[ebp]
	push	eax
	lea	ecx, DWORD PTR _fullPath$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 194  : 				strcat(fullPath, fileInfo.name);

	lea	eax, DWORD PTR _fileInfo$[ebp+36]
	push	eax
	lea	ecx, DWORD PTR _fullPath$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 195  : 				if (writeData && writeHash)

	movzx	eax, BYTE PTR _writeData$[ebp]
	test	eax, eax
	je	SHORT $LN12@AddFilesFr
	movzx	eax, BYTE PTR _writeHash$[ebp]
	test	eax, eax
	je	SHORT $LN12@AddFilesFr

; 196  : 					fileData= new char [fileInfo.size+SHA1_LENGTH];

	mov	eax, DWORD PTR _fileInfo$[ebp+32]
	add	eax, 20					; 00000014H
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T6[ebp], eax
	mov	ecx, DWORD PTR $T6[ebp]
	mov	DWORD PTR _fileData$[ebp], ecx

; 197  : 				else

	jmp	SHORT $LN11@AddFilesFr
$LN12@AddFilesFr:

; 198  : 					fileData= new char [fileInfo.size];

	mov	eax, DWORD PTR _fileInfo$[ebp+32]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T7[ebp], eax
	mov	ecx, DWORD PTR $T7[ebp]
	mov	DWORD PTR _fileData$[ebp], ecx
$LN11@AddFilesFr:

; 199  : 				fp = fopen(fullPath, "rb");

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	lea	eax, DWORD PTR _fullPath$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax

; 200  : 				if (writeData && writeHash)

	movzx	eax, BYTE PTR _writeData$[ebp]
	test	eax, eax
	je	SHORT $LN10@AddFilesFr
	movzx	eax, BYTE PTR _writeHash$[ebp]
	test	eax, eax
	je	SHORT $LN10@AddFilesFr

; 201  : 					fread(fileData+SHA1_LENGTH, fileInfo.size, 1, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _fileInfo$[ebp+32]
	push	ecx
	mov	edx, DWORD PTR _fileData$[ebp]
	add	edx, 20					; 00000014H
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 202  : 				else

	jmp	SHORT $LN9@AddFilesFr
$LN10@AddFilesFr:

; 203  : 					fread(fileData, fileInfo.size, 1, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _fileInfo$[ebp+32]
	push	ecx
	mov	edx, DWORD PTR _fileData$[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H
$LN9@AddFilesFr:

; 204  : 				fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 205  : 
; 206  : 				if (writeData && writeHash)

	movzx	eax, BYTE PTR _writeData$[ebp]
	test	eax, eax
	je	$LN8@AddFilesFr
	movzx	eax, BYTE PTR _writeHash$[ebp]
	test	eax, eax
	je	$LN8@AddFilesFr

; 207  : 				{
; 208  : 					sha1.Reset();

	lea	ecx, DWORD PTR _sha1$[ebp]
	call	?Reset@CSHA1@@QAEXXZ			; CSHA1::Reset

; 209  : 					sha1.Update( ( unsigned char* ) fileData+SHA1_LENGTH, fileInfo.size );

	mov	eax, DWORD PTR _fileInfo$[ebp+32]
	push	eax
	mov	ecx, DWORD PTR _fileData$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	lea	ecx, DWORD PTR _sha1$[ebp]
	call	?Update@CSHA1@@QAEXPAEI@Z		; CSHA1::Update

; 210  : 					sha1.Final();

	lea	ecx, DWORD PTR _sha1$[ebp]
	call	?Final@CSHA1@@QAEXXZ			; CSHA1::Final

; 211  : 					memcpy(fileData, sha1.GetHash(), SHA1_LENGTH);

	push	20					; 00000014H
	lea	ecx, DWORD PTR _sha1$[ebp]
	call	?GetHash@CSHA1@@QBEPAEXZ		; CSHA1::GetHash
	push	eax
	mov	eax, DWORD PTR _fileData$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 212  : 					AddFile((const char*)fullPath+rootLen, fileData, fileInfo.size+SHA1_LENGTH, fileInfo.size, context);

	movzx	eax, BYTE PTR _context$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fileInfo$[ebp+32]
	push	ecx
	mov	edx, DWORD PTR _fileInfo$[ebp+32]
	add	edx, 20					; 00000014H
	push	edx
	mov	eax, DWORD PTR _fileData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rootLen$[ebp]
	lea	edx, DWORD PTR _fullPath$[ebp+ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddFile@FileList@@QAEXPBD0IIE@Z	; FileList::AddFile
	jmp	$LN7@AddFilesFr
$LN8@AddFilesFr:

; 213  : 				}
; 214  : 				else if (writeHash)

	movzx	eax, BYTE PTR _writeHash$[ebp]
	test	eax, eax
	je	SHORT $LN6@AddFilesFr

; 215  : 				{
; 216  : 					sha1.Reset();

	lea	ecx, DWORD PTR _sha1$[ebp]
	call	?Reset@CSHA1@@QAEXXZ			; CSHA1::Reset

; 217  : 					sha1.Update( ( unsigned char* ) fileData, fileInfo.size );

	mov	eax, DWORD PTR _fileInfo$[ebp+32]
	push	eax
	mov	ecx, DWORD PTR _fileData$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _sha1$[ebp]
	call	?Update@CSHA1@@QAEXPAEI@Z		; CSHA1::Update

; 218  : 					sha1.Final();

	lea	ecx, DWORD PTR _sha1$[ebp]
	call	?Final@CSHA1@@QAEXXZ			; CSHA1::Final

; 219  : 					AddFile((const char*)fullPath+rootLen, (const char*)sha1.GetHash(), SHA1_LENGTH, fileInfo.size, context);

	movzx	eax, BYTE PTR _context$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fileInfo$[ebp+32]
	push	ecx
	push	20					; 00000014H
	lea	ecx, DWORD PTR _sha1$[ebp]
	call	?GetHash@CSHA1@@QBEPAEXZ		; CSHA1::GetHash
	push	eax
	mov	edx, DWORD PTR _rootLen$[ebp]
	lea	eax, DWORD PTR _fullPath$[ebp+edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddFile@FileList@@QAEXPBD0IIE@Z	; FileList::AddFile
	jmp	SHORT $LN7@AddFilesFr
$LN6@AddFilesFr:

; 220  : 				}
; 221  : 				else if (writeData)

	movzx	eax, BYTE PTR _writeData$[ebp]
	test	eax, eax
	je	SHORT $LN4@AddFilesFr

; 222  : 				{
; 223  : 					AddFile(fullPath+rootLen, fileData, fileInfo.size, fileInfo.size, context);

	movzx	eax, BYTE PTR _context$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fileInfo$[ebp+32]
	push	ecx
	mov	edx, DWORD PTR _fileInfo$[ebp+32]
	push	edx
	mov	eax, DWORD PTR _fileData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rootLen$[ebp]
	lea	edx, DWORD PTR _fullPath$[ebp+ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddFile@FileList@@QAEXPBD0IIE@Z	; FileList::AddFile

; 224  : 				}
; 225  : 				else

	jmp	SHORT $LN7@AddFilesFr
$LN4@AddFilesFr:

; 226  : 					AddFile(fullPath+rootLen, 0, 0, fileInfo.size, context);

	movzx	eax, BYTE PTR _context$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fileInfo$[ebp+32]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _rootLen$[ebp]
	lea	eax, DWORD PTR _fullPath$[ebp+edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddFile@FileList@@QAEXPBD0IIE@Z	; FileList::AddFile
$LN7@AddFilesFr:

; 227  : 
; 228  : 				delete [] fileData;

	mov	eax, DWORD PTR _fileData$[ebp]
	mov	DWORD PTR $T8[ebp], eax
	mov	ecx, DWORD PTR $T8[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	jmp	$LN2@AddFilesFr
$LN13@AddFilesFr:

; 229  : 			}
; 230  : 			else if ((fileInfo.attrib & _A_SUBDIR) && (fileInfo.attrib & (_A_HIDDEN | _A_SYSTEM))==0 && recursive)

	mov	eax, DWORD PTR _fileInfo$[ebp]
	and	eax, 16					; 00000010H
	je	$LN2@AddFilesFr
	mov	eax, DWORD PTR _fileInfo$[ebp]
	and	eax, 6
	jne	SHORT $LN2@AddFilesFr
	movzx	eax, BYTE PTR _recursive$[ebp]
	test	eax, eax
	je	SHORT $LN2@AddFilesFr

; 231  : 			{
; 232  : 				char *newDir=new char[520];

	push	520					; 00000208H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T9[ebp], eax
	mov	eax, DWORD PTR $T9[ebp]
	mov	DWORD PTR _newDir$11[ebp], eax

; 233  : 				strcpy(newDir, dirSoFar);

	mov	eax, DWORD PTR _dirSoFar$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newDir$11[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 234  : 				strcat(newDir, fileInfo.name);

	lea	eax, DWORD PTR _fileInfo$[ebp+36]
	push	eax
	mov	ecx, DWORD PTR _newDir$11[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 235  : 				strcat(newDir, "/");

	push	OFFSET ??_C@_01KMDKNFGN@?1?$AA@
	mov	eax, DWORD PTR _newDir$11[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 236  : 				dirList.Push(newDir);

	lea	eax, DWORD PTR _newDir$11[ebp]
	push	eax
	lea	ecx, DWORD PTR _dirList$[ebp]
	call	?Push@?$Queue@PAD@DataStructures@@QAEXABQAD@Z ; DataStructures::Queue<char *>::Push
$LN2@AddFilesFr:

; 237  : 			}
; 238  : 			file=_findnext(dir, &fileInfo );

	lea	eax, DWORD PTR _fileInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dir$[ebp]
	push	ecx
	call	__findnext64i32
	add	esp, 8
	mov	DWORD PTR _file$[ebp], eax

; 239  : 		}

	jmp	$LN15@AddFilesFr
$LN14@AddFilesFr:

; 240  : 
; 241  : 		_findclose(dir);

	mov	eax, DWORD PTR _dir$[ebp]
	push	eax
	call	__findclose
	add	esp, 4

; 242  : 		delete [] dirSoFar;

	mov	eax, DWORD PTR _dirSoFar$[ebp]
	mov	DWORD PTR $T10[ebp], eax
	mov	ecx, DWORD PTR $T10[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 243  : 	}

	jmp	$LN21@AddFilesFr
$LN20@AddFilesFr:

; 244  : #endif
; 245  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _sha1$[ebp]
	call	??1CSHA1@@UAE@XZ			; CSHA1::~CSHA1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _dirList$[ebp]
	call	??1?$Queue@PAD@DataStructures@@QAE@XZ	; DataStructures::Queue<char *>::~Queue<char *>
$LN30@AddFilesFr:
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN44@AddFilesFr
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 1736				; 000006c8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
	npad	3
$LN44@AddFilesFr:
	DD	7
	DD	$LN43@AddFilesFr
$LN43@AddFilesFr:
	DD	-48					; ffffffd0H
	DD	16					; 00000010H
	DD	$LN35@AddFilesFr
	DD	-316					; fffffec4H
	DD	260					; 00000104H
	DD	$LN36@AddFilesFr
	DD	-844					; fffffcb4H
	DD	520					; 00000208H
	DD	$LN37@AddFilesFr
	DD	-1148					; fffffb84H
	DD	296					; 00000128H
	DD	$LN38@AddFilesFr
	DD	-1372					; fffffaa4H
	DD	180					; 000000b4H
	DD	$LN39@AddFilesFr
	DD	-1384					; fffffa98H
	DD	4
	DD	$LN40@AddFilesFr
	DD	-1432					; fffffa68H
	DD	4
	DD	$LN41@AddFilesFr
$LN41@AddFilesFr:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	68					; 00000044H
	DB	105					; 00000069H
	DB	114					; 00000072H
	DB	0
$LN40@AddFilesFr:
	DB	100					; 00000064H
	DB	105					; 00000069H
	DB	114					; 00000072H
	DB	83					; 00000053H
	DB	111					; 0000006fH
	DB	70					; 00000046H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	0
$LN39@AddFilesFr:
	DB	115					; 00000073H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	49					; 00000031H
	DB	0
$LN38@AddFilesFr:
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	102					; 00000066H
	DB	111					; 0000006fH
	DB	0
$LN37@AddFilesFr:
	DB	102					; 00000066H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$LN36@AddFilesFr:
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	111					; 0000006fH
	DB	116					; 00000074H
	DB	0
$LN35@AddFilesFr:
	DB	100					; 00000064H
	DB	105					; 00000069H
	DB	114					; 00000072H
	DB	76					; 0000004cH
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddFilesFromDirectory@FileList@@QAEXPBD0_N11E@Z$0:
	lea	ecx, DWORD PTR _dirList$[ebp]
	jmp	??1?$Queue@PAD@DataStructures@@QAE@XZ	; DataStructures::Queue<char *>::~Queue<char *>
__unwindfunclet$?AddFilesFromDirectory@FileList@@QAEXPBD0_N11E@Z$1:
	lea	ecx, DWORD PTR _sha1$[ebp]
	jmp	??1CSHA1@@UAE@XZ			; CSHA1::~CSHA1
__ehhandler$?AddFilesFromDirectory@FileList@@QAEXPBD0_N11E@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1740]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddFilesFromDirectory@FileList@@QAEXPBD0_N11E@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddFilesFromDirectory@FileList@@QAEXPBD0_N11E@Z ENDP	; FileList::AddFilesFromDirectory
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\filelist.cpp
;	COMDAT ??1FileList@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1FileList@@QAE@XZ PROC				; FileList::~FileList, COMDAT
; _this$ = ecx

; 53   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1FileList@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 54   : 	Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@FileList@@QAEXXZ			; FileList::Clear

; 55   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$List@UFileListNode@@@DataStructures@@QAE@XZ ; DataStructures::List<FileListNode>::~List<FileListNode>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1FileList@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$List@UFileListNode@@@DataStructures@@QAE@XZ ; DataStructures::List<FileListNode>::~List<FileListNode>
__ehhandler$??1FileList@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1FileList@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1FileList@@QAE@XZ ENDP				; FileList::~FileList
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\filelist.cpp
;	COMDAT ??0FileList@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0FileList@@QAE@XZ PROC				; FileList::FileList, COMDAT
; _this$ = ecx

; 50   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$List@UFileListNode@@@DataStructures@@QAE@XZ ; DataStructures::List<FileListNode>::List<FileListNode>

; 51   : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0FileList@@QAE@XZ ENDP				; FileList::FileList
_TEXT	ENDS
END
