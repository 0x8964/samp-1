; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.31101.0 

	TITLE	Z:\sampsrc\02Xu1\raknet\StringTable.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?instance@StringTable@@1PAV1@A			; StringTable::instance
PUBLIC	?referenceCount@StringTable@@1HA		; StringTable::referenceCount
_BSS	SEGMENT
?instance@StringTable@@1PAV1@A DD 01H DUP (?)		; StringTable::instance
?referenceCount@StringTable@@1HA DD 01H DUP (?)		; StringTable::referenceCount
_BSS	ENDS
PUBLIC	?StrAndBoolComp@@YAHABQADABUStrAndBool@@@Z	; StrAndBoolComp
PUBLIC	??1StringTable@@QAE@XZ				; StringTable::~StringTable
PUBLIC	?Instance@StringTable@@SAPAV1@XZ		; StringTable::Instance
PUBLIC	?AddString@StringTable@@QAEXPBD_N@Z		; StringTable::AddString
PUBLIC	?EncodeString@StringTable@@QAEXPBDHPAVBitStream@RakNet@@@Z ; StringTable::EncodeString
PUBLIC	?DecodeString@StringTable@@QAE_NPADHPAVBitStream@RakNet@@@Z ; StringTable::DecodeString
PUBLIC	?AddReference@StringTable@@SAXXZ		; StringTable::AddReference
PUBLIC	?RemoveReference@StringTable@@SAXXZ		; StringTable::RemoveReference
PUBLIC	?LogStringNotFound@StringTable@@IAEXPBD@Z	; StringTable::LogStringNotFound
PUBLIC	??0StringTable@@IAE@XZ				; StringTable::StringTable
PUBLIC	??0?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<char *,StrAndBool,&StrAndBoolComp>::OrderedList<char *,StrAndBool,&StrAndBoolComp>
PUBLIC	??1?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<char *,StrAndBool,&StrAndBoolComp>::~OrderedList<char *,StrAndBool,&StrAndBoolComp>
PUBLIC	?GetIndexFromKey@?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QBEIABQADPA_N@Z ; DataStructures::OrderedList<char *,StrAndBool,&StrAndBoolComp>::GetIndexFromKey
PUBLIC	?Insert@?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QAEIABQADABUStrAndBool@@@Z ; DataStructures::OrderedList<char *,StrAndBool,&StrAndBoolComp>::Insert
PUBLIC	??A?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QBEAAUStrAndBool@@I@Z ; DataStructures::OrderedList<char *,StrAndBool,&StrAndBoolComp>::operator[]
PUBLIC	?Clear@?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QAEXXZ ; DataStructures::OrderedList<char *,StrAndBool,&StrAndBoolComp>::Clear
PUBLIC	?Size@?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<char *,StrAndBool,&StrAndBoolComp>::Size
PUBLIC	??0?$List@UStrAndBool@@@DataStructures@@QAE@XZ	; DataStructures::List<StrAndBool>::List<StrAndBool>
PUBLIC	??1?$List@UStrAndBool@@@DataStructures@@QAE@XZ	; DataStructures::List<StrAndBool>::~List<StrAndBool>
PUBLIC	??A?$List@UStrAndBool@@@DataStructures@@QBEAAUStrAndBool@@I@Z ; DataStructures::List<StrAndBool>::operator[]
PUBLIC	?Insert@?$List@UStrAndBool@@@DataStructures@@QAEXUStrAndBool@@I@Z ; DataStructures::List<StrAndBool>::Insert
PUBLIC	?Insert@?$List@UStrAndBool@@@DataStructures@@QAEXUStrAndBool@@@Z ; DataStructures::List<StrAndBool>::Insert
PUBLIC	?Size@?$List@UStrAndBool@@@DataStructures@@QBEIXZ ; DataStructures::List<StrAndBool>::Size
PUBLIC	?Clear@?$List@UStrAndBool@@@DataStructures@@QAEX_N@Z ; DataStructures::List<StrAndBool>::Clear
PUBLIC	??_GStringTable@@QAEPAXI@Z			; StringTable::`scalar deleting destructor'
PUBLIC	??$Write@_N@BitStream@RakNet@@QAEX_N@Z		; RakNet::BitStream::Write<bool>
PUBLIC	??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z	; RakNet::BitStream::Read<bool>
PUBLIC	??$Write@E@BitStream@RakNet@@QAEXE@Z		; RakNet::BitStream::Write<unsigned char>
PUBLIC	??$Read@E@BitStream@RakNet@@QAE_NAAE@Z		; RakNet::BitStream::Read<unsigned char>
PUBLIC	?__LINE__Var@?1??RemoveReference@StringTable@@SAXXZ@4JA@e8ba9f31 ; `StringTable::RemoveReference'::`2'::__LINE__Var
PUBLIC	??_C@_1FA@FIECJAFM@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AAt?$AAa@ ; `string'
PUBLIC	??_C@_1CG@DEPNCJGC@?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAe?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??AddString@StringTable@@QAEXPBD_N@Z@4JA ; `StringTable::AddString'::`2'::__LINE__Var
PUBLIC	??_C@_1FO@HDKNIFHI@?$AAo?$AAr?$AAd?$AAe?$AAr?$AAe?$AAd?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AAL?$AAi?$AAs?$AAt?$AA?4?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAS?$AAt?$AAr?$AAi@ ; `string'
PUBLIC	?__LINE__Var@?1??DecodeString@StringTable@@QAE_NPADHPAVBitStream@RakNet@@@Z@4JA ; `StringTable::DecodeString'::`2'::__LINE__Var
PUBLIC	??_C@_1CE@IIKHMION@?$AAm?$AAa?$AAx?$AAC?$AAh?$AAa?$AAr?$AAs?$AAT?$AAo?$AAW?$AAr?$AAi?$AAt?$AAe?$AA?$DO?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_13COJANIEC@?$AA0?$AA?$AA@			; `string'
PUBLIC	??_C@_0EB@HCJBANNB@Efficiency?5Warning?$CB?5Unregistered@ ; `string'
PUBLIC	??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@ ; `string'
PUBLIC	??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CM@FMCFHBCK@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ ; `string'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	__wassert:PROC
EXTRN	_memcpy:PROC
EXTRN	_strcpy:PROC
EXTRN	_strcmp:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	_strncpy:PROC
EXTRN	_printf:PROC
EXTRN	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z:PROC	; RakNet::BitStream::WriteBits
EXTRN	?ReadBits@BitStream@RakNet@@QAE_NPAEH_N@Z:PROC	; RakNet::BitStream::ReadBits
EXTRN	?Write0@BitStream@RakNet@@QAEXXZ:PROC		; RakNet::BitStream::Write0
EXTRN	?Write1@BitStream@RakNet@@QAEXXZ:PROC		; RakNet::BitStream::Write1
EXTRN	?Instance@StringCompressor@@SAPAV1@XZ:PROC	; StringCompressor::Instance
EXTRN	?EncodeString@StringCompressor@@QAEXPBDHPAVBitStream@RakNet@@H@Z:PROC ; StringCompressor::EncodeString
EXTRN	?DecodeString@StringCompressor@@QAE_NPADHPAVBitStream@RakNet@@H@Z:PROC ; StringCompressor::DecodeString
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_1CM@FMCFHBCK@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@FMCFHBCK@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ DB 'p'
	DB	00H, 'o', 00H, 's', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'o', 00H
	DB	'n', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'l', 00H, 'i'
	DB	00H, 's', 00H, 't', 00H, '_', 00H, 's', 00H, 'i', 00H, 'z', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ DB 'p'
	DB	00H, 'o', 00H, 's', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'o', 00H
	DB	'n', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'l', 00H, 'i', 00H, 's'
	DB	00H, 't', 00H, '_', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
CONST	SEGMENT
??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@ DB 'z'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H
	DB	's', 00H, 'r', 00H, 'c', 00H, '\', 00H, '0', 00H, '2', 00H, 'x'
	DB	00H, 'u', 00H, '1', 00H, '\', 00H, 'r', 00H, 'a', 00H, 'k', 00H
	DB	'n', 00H, 'e', 00H, 't', 00H, '\', 00H, 'd', 00H, 's', 00H, '_'
	DB	00H, 'l', 00H, 'i', 00H, 's', 00H, 't', 00H, '.', 00H, 'h', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@HCJBANNB@Efficiency?5Warning?$CB?5Unregistered@
CONST	SEGMENT
??_C@_0EB@HCJBANNB@Efficiency?5Warning?$CB?5Unregistered@ DB 'Efficiency '
	DB	'Warning! Unregistered String %s sent to StringTable.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_13COJANIEC@?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_13COJANIEC@?$AA0?$AA?$AA@ DB '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@IIKHMION@?$AAm?$AAa?$AAx?$AAC?$AAh?$AAa?$AAr?$AAs?$AAT?$AAo?$AAW?$AAr?$AAi?$AAt?$AAe?$AA?$DO?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@IIKHMION@?$AAm?$AAa?$AAx?$AAC?$AAh?$AAa?$AAr?$AAs?$AAT?$AAo?$AAW?$AAr?$AAi?$AAt?$AAe?$AA?$DO?$AA0?$AA?$AA@ DB 'm'
	DB	00H, 'a', 00H, 'x', 00H, 'C', 00H, 'h', 00H, 'a', 00H, 'r', 00H
	DB	's', 00H, 'T', 00H, 'o', 00H, 'W', 00H, 'r', 00H, 'i', 00H, 't'
	DB	00H, 'e', 00H, '>', 00H, '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??DecodeString@StringTable@@QAE_NPADHPAVBitStream@RakNet@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??DecodeString@StringTable@@QAE_NPADHPAVBitStream@RakNet@@@Z@4JA DD 066H ; `StringTable::DecodeString'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1FO@HDKNIFHI@?$AAo?$AAr?$AAd?$AAe?$AAr?$AAe?$AAd?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AAL?$AAi?$AAs?$AAt?$AA?4?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAS?$AAt?$AAr?$AAi@
CONST	SEGMENT
??_C@_1FO@HDKNIFHI@?$AAo?$AAr?$AAd?$AAe?$AAr?$AAe?$AAd?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AAL?$AAi?$AAs?$AAt?$AA?4?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAS?$AAt?$AAr?$AAi@ DB 'o'
	DB	00H, 'r', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'd', 00H
	DB	'S', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 'L'
	DB	00H, 'i', 00H, 's', 00H, 't', 00H, '.', 00H, 'S', 00H, 'i', 00H
	DB	'z', 00H, 'e', 00H, '(', 00H, ')', 00H, ' ', 00H, '<', 00H, ' '
	DB	00H, '(', 00H, 'S', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, 'T', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, 'T'
	DB	00H, 'y', 00H, 'p', 00H, 'e', 00H, ')', 00H, '-', 00H, '1', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??AddString@StringTable@@QAEXPBD_N@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??AddString@StringTable@@QAEXPBD_N@Z@4JA DD 03aH ; `StringTable::AddString'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1CG@DEPNCJGC@?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAe?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@DEPNCJGC@?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAe?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB 'r'
	DB	00H, 'e', 00H, 'f', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'n', 00H
	DB	'c', 00H, 'e', 00H, 'C', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't'
	DB	00H, ' ', 00H, '>', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FA@FIECJAFM@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AAt?$AAa@
CONST	SEGMENT
??_C@_1FA@FIECJAFM@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AAt?$AAa@ DB 'z'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H
	DB	's', 00H, 'r', 00H, 'c', 00H, '\', 00H, '0', 00H, '2', 00H, 'x'
	DB	00H, 'u', 00H, '1', 00H, '\', 00H, 'r', 00H, 'a', 00H, 'k', 00H
	DB	'n', 00H, 'e', 00H, 't', 00H, '\', 00H, 's', 00H, 't', 00H, 'r'
	DB	00H, 'i', 00H, 'n', 00H, 'g', 00H, 't', 00H, 'a', 00H, 'b', 00H
	DB	'l', 00H, 'e', 00H, '.', 00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??RemoveReference@StringTable@@SAXXZ@4JA@e8ba9f31
_DATA	SEGMENT
?__LINE__Var@?1??RemoveReference@StringTable@@SAXXZ@4JA@e8ba9f31 DD 027H ; `StringTable::RemoveReference'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QAE@XZ$0
__ehfuncinfo$??1?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?AddReference@StringTable@@SAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddReference@StringTable@@SAXXZ$0
__ehfuncinfo$?AddReference@StringTable@@SAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddReference@StringTable@@SAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1StringTable@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1StringTable@@QAE@XZ$0
__ehfuncinfo$??1StringTable@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1StringTable@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Read@E@BitStream@RakNet@@QAE_NAAE@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 4
??$Read@E@BitStream@RakNet@@QAE_NAAE@Z PROC		; RakNet::BitStream::Read<unsigned char>, COMDAT
; _this$ = ecx

; 987  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 988  : #ifdef _MSC_VER
; 989  : #pragma warning(disable:4127)   // conditional expression is constant
; 990  : #endif
; 991  : 		if (sizeof(var)==1)

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN2@Read

; 992  : 			return ReadBits( ( unsigned char* ) &var, sizeof(templateType) * 8, true );

	push	1
	push	8
	mov	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadBits@BitStream@RakNet@@QAE_NPAEH_N@Z ; RakNet::BitStream::ReadBits
	jmp	SHORT $LN3@Read

; 993  : 		else

	jmp	SHORT $LN3@Read
$LN2@Read:

; 994  : 		{
; 995  : #ifndef __BITSTREAM_NATIVE_END
; 996  : #ifdef _MSC_VER
; 997  : #pragma warning(disable:4244)   // '=' : conversion from 'unsigned long' to 'unsigned short', possible loss of data
; 998  : #endif
; 999  : 			if (DoEndianSwap())
; 1000 : 			{
; 1001 : 				unsigned char output[sizeof(templateType)];
; 1002 : 				if (ReadBits( ( unsigned char* ) output, sizeof(templateType) * 8, true ))
; 1003 : 				{
; 1004 : 					ReverseBytes(output, (unsigned char*)&var, sizeof(templateType));
; 1005 : 					return true;
; 1006 : 				}
; 1007 : 				return false;
; 1008 : 			}
; 1009 : 			else
; 1010 : #endif
; 1011 : 				return ReadBits( ( unsigned char* ) & var, sizeof(templateType) * 8, true );

	push	1
	push	8
	mov	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadBits@BitStream@RakNet@@QAE_NPAEH_N@Z ; RakNet::BitStream::ReadBits
$LN3@Read:

; 1012 : 		}
; 1013 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$Read@E@BitStream@RakNet@@QAE_NAAE@Z ENDP		; RakNet::BitStream::Read<unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Write@E@BitStream@RakNet@@QAEXE@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 1
??$Write@E@BitStream@RakNet@@QAEXE@Z PROC		; RakNet::BitStream::Write<unsigned char>, COMDAT
; _this$ = ecx

; 729  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 730  : #ifdef _MSC_VER
; 731  : #pragma warning(disable:4127)   // conditional expression is constant
; 732  : #endif
; 733  : 		if (sizeof(var)==1)

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN2@Write

; 734  : 			WriteBits( ( unsigned char* ) & var, sizeof( templateType ) * 8, true );

	push	1
	push	8
	lea	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z ; RakNet::BitStream::WriteBits

; 735  : 		else

	jmp	SHORT $LN3@Write
$LN2@Write:

; 736  : 		{
; 737  : #ifndef __BITSTREAM_NATIVE_END
; 738  : 			if (DoEndianSwap())
; 739  : 			{
; 740  : 				unsigned char output[sizeof(templateType)];
; 741  : 				ReverseBytes((unsigned char*)&var, output, sizeof(templateType));
; 742  : 				WriteBits( ( unsigned char* ) output, sizeof(templateType) * 8, true );
; 743  : 			}
; 744  : 			else
; 745  : #endif
; 746  : 				WriteBits( ( unsigned char* ) & var, sizeof(templateType) * 8, true );

	push	1
	push	8
	lea	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z ; RakNet::BitStream::WriteBits
$LN3@Write:

; 747  : 		}
; 748  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$Write@E@BitStream@RakNet@@QAEXE@Z ENDP		; RakNet::BitStream::Write<unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z
_TEXT	SEGMENT
tv82 = -208						; size = 4
_this$ = -8						; size = 4
_var$ = 8						; size = 4
??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z PROC		; RakNet::BitStream::Read<bool>, COMDAT
; _this$ = ecx

; 1019 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1020 : 		if ( readOffset + 1 > numberOfBitsUsed )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [edx]
	jle	SHORT $LN3@Read

; 1021 : 			return false;

	xor	al, al
	jmp	SHORT $LN4@Read
$LN3@Read:

; 1022 : 
; 1023 : 		if ( data[ readOffset >> 3 ] & ( 0x80 >> ( readOffset++ % 8 ) ) )   // Is it faster to just write it out here?

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sar	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	movzx	edx, BYTE PTR [eax+ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -2147483641			; 80000007H
	jns	SHORT $LN6@Read
	dec	ecx
	or	ecx, -8					; fffffff8H
	inc	ecx
$LN6@Read:
	mov	eax, 128				; 00000080H
	sar	eax, cl
	and	edx, eax
	mov	DWORD PTR tv82[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx
	cmp	DWORD PTR tv82[ebp], 0
	je	SHORT $LN2@Read

; 1024 : 			var = true;

	mov	eax, DWORD PTR _var$[ebp]
	mov	BYTE PTR [eax], 1

; 1025 : 		else

	jmp	SHORT $LN1@Read
$LN2@Read:

; 1026 : 			var = false;

	mov	eax, DWORD PTR _var$[ebp]
	mov	BYTE PTR [eax], 0
$LN1@Read:

; 1027 : 
; 1028 : 		return true;

	mov	al, 1
$LN4@Read:

; 1029 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z ENDP		; RakNet::BitStream::Read<bool>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Write@_N@BitStream@RakNet@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 1
??$Write@_N@BitStream@RakNet@@QAEX_N@Z PROC		; RakNet::BitStream::Write<bool>, COMDAT
; _this$ = ecx

; 754  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 755  : 		if ( var )

	movzx	eax, BYTE PTR _var$[ebp]
	test	eax, eax
	je	SHORT $LN2@Write

; 756  : 			Write1();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Write1@BitStream@RakNet@@QAEXXZ	; RakNet::BitStream::Write1

; 757  : 		else

	jmp	SHORT $LN3@Write
$LN2@Write:

; 758  : 			Write0();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Write0@BitStream@RakNet@@QAEXXZ	; RakNet::BitStream::Write0
$LN3@Write:

; 759  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$Write@_N@BitStream@RakNet@@QAEX_N@Z ENDP		; RakNet::BitStream::Write<bool>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GStringTable@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GStringTable@@QAEPAXI@Z PROC				; StringTable::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1StringTable@@QAE@XZ			; StringTable::~StringTable
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GStringTable@@QAEPAXI@Z ENDP				; StringTable::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Clear@?$List@UStrAndBool@@@DataStructures@@QAEX_N@Z
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
_doNotDeallocate$ = 8					; size = 1
?Clear@?$List@UStrAndBool@@@DataStructures@@QAEX_N@Z PROC ; DataStructures::List<StrAndBool>::Clear, COMDAT
; _this$ = ecx

; 379  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  : 		if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Clear

; 381  : 			return;

	jmp	SHORT $LN3@Clear
$LN2@Clear:

; 382  : 
; 383  : 		if (allocation_size>512 && doNotDeallocate==false)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 512			; 00000200H
	jbe	SHORT $LN1@Clear
	movzx	eax, BYTE PTR _doNotDeallocate$[ebp]
	test	eax, eax
	jne	SHORT $LN1@Clear

; 384  : 		{
; 385  : 			delete [] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 386  : 			allocation_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 387  : 			listArray = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN1@Clear:

; 388  : 		}
; 389  : 		list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
$LN3@Clear:

; 390  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Clear@?$List@UStrAndBool@@@DataStructures@@QAEX_N@Z ENDP ; DataStructures::List<StrAndBool>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Size@?$List@UStrAndBool@@@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$List@UStrAndBool@@@DataStructures@@QBEIXZ PROC	; DataStructures::List<StrAndBool>::Size, COMDAT
; _this$ = ecx

; 373  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 374  : 		return list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 375  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$List@UStrAndBool@@@DataStructures@@QBEIXZ ENDP	; DataStructures::List<StrAndBool>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Insert@?$List@UStrAndBool@@@DataStructures@@QAEXUStrAndBool@@@Z
_TEXT	SEGMENT
$T1 = -236						; size = 4
$T2 = -224						; size = 4
_new_array$3 = -20					; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 5
?Insert@?$List@UStrAndBool@@@DataStructures@@QAEXUStrAndBool@@@Z PROC ; DataStructures::List<StrAndBool>::Insert, COMDAT
; _this$ = ecx

; 242  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 243  : 		// Reallocate list if necessary
; 244  : 
; 245  : 		if ( list_size == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	$LN3@Insert

; 246  : 		{
; 247  : 			// allocate twice the currently allocated memory
; 248  : 			list_type * new_array;
; 249  : 
; 250  : 			if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Insert

; 251  : 				allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 16			; 00000010H

; 252  : 			else

	jmp	SHORT $LN1@Insert
$LN2@Insert:

; 253  : 				allocation_size *= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN1@Insert:

; 254  : 
; 255  : 			new_array = new list_type [ allocation_size ];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, 5
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _new_array$3[ebp], eax

; 256  : 
; 257  : 			// copy old array over
; 258  : 			//	for ( unsigned int counter = 0; counter < list_size; ++counter )
; 259  : 			//		new_array[ counter ] = listArray[ counter ];
; 260  : 
; 261  : 			// Don't call constructors, assignment operators, etc.
; 262  : 			memcpy(new_array, listArray, list_size*sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [eax+4], 5
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _new_array$3[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 263  : 
; 264  : 			// set old array to point to the newly allocated and twice as large array
; 265  : 			delete[] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 266  : 
; 267  : 			listArray = new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$3[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Insert:

; 268  : 		}
; 269  : 
; 270  : 		// Insert the new item at the correct spot
; 271  : 		listArray[ list_size ] = input;

	mov	eax, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [eax+4], 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, ecx
	mov	ecx, DWORD PTR _input$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dl, BYTE PTR _input$[ebp+4]
	mov	BYTE PTR [eax+4], dl

; 272  : 
; 273  : 		++list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 274  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?Insert@?$List@UStrAndBool@@@DataStructures@@QAEXUStrAndBool@@@Z ENDP ; DataStructures::List<StrAndBool>::Insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Insert@?$List@UStrAndBool@@@DataStructures@@QAEXUStrAndBool@@I@Z
_TEXT	SEGMENT
$T1 = -236						; size = 4
$T2 = -224						; size = 4
_new_array$3 = -20					; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 5
_position$ = 16						; size = 4
?Insert@?$List@UStrAndBool@@@DataStructures@@QAEXUStrAndBool@@I@Z PROC ; DataStructures::List<StrAndBool>::Insert, COMDAT
; _this$ = ecx

; 194  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 195  : #ifdef _DEBUG
; 196  : 		assert( position <= list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jbe	SHORT $LN6@Insert
	push	196					; 000000c4H
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CM@FMCFHBCK@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN6@Insert:

; 197  : #endif
; 198  : 
; 199  : 		// Reallocate list if necessary
; 200  : 		if ( list_size == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	$LN3@Insert

; 201  : 		{
; 202  : 			// allocate twice the currently allocated memory
; 203  : 			list_type * new_array;
; 204  : 
; 205  : 			if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Insert

; 206  : 				allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 16			; 00000010H

; 207  : 			else

	jmp	SHORT $LN1@Insert
$LN2@Insert:

; 208  : 				allocation_size *= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN1@Insert:

; 209  : 
; 210  : 			new_array = new list_type [ allocation_size ];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, 5
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _new_array$3[ebp], eax

; 211  : 
; 212  : 			// copy old array over
; 213  : 			//for ( unsigned int counter = 0; counter < list_size; ++counter )
; 214  : 			//	new_array[ counter ] = listArray[ counter ];
; 215  : 
; 216  : 			// Don't call constructors, assignment operators, etc.
; 217  : 			memcpy(new_array, listArray, list_size*sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [eax+4], 5
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _new_array$3[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 218  : 
; 219  : 			// set old array to point to the newly allocated and twice as large array
; 220  : 			delete[] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 221  : 
; 222  : 			listArray = new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$3[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Insert:

; 223  : 		}
; 224  : 
; 225  : 		// Move the elements in the list to make room
; 226  : 		//for ( unsigned int counter = list_size; counter != position; counter-- )
; 227  : 		//	listArray[ counter ] = listArray[ counter - 1 ];
; 228  : 
; 229  : 		// Don't call constructors, assignment operators, etc.
; 230  : 		memmove(listArray+position+1, listArray+position, (list_size-position)*sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _position$[ebp]
	imul	edx, ecx, 5
	push	edx
	imul	eax, DWORD PTR _position$[ebp], 5
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	push	eax
	imul	edx, DWORD PTR _position$[ebp], 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+edx+5]
	push	edx
	call	_memmove
	add	esp, 12					; 0000000cH

; 231  : 
; 232  : 		// Insert the new item at the correct spot
; 233  : 		listArray[ position ] = input;

	imul	eax, DWORD PTR _position$[ebp], 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, eax
	mov	eax, DWORD PTR _input$[ebp]
	mov	DWORD PTR [edx], eax
	mov	cl, BYTE PTR _input$[ebp+4]
	mov	BYTE PTR [edx+4], cl

; 234  : 
; 235  : 		++list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 236  : 
; 237  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Insert@?$List@UStrAndBool@@@DataStructures@@QAEXUStrAndBool@@I@Z ENDP ; DataStructures::List<StrAndBool>::Insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??A?$List@UStrAndBool@@@DataStructures@@QBEAAUStrAndBool@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
??A?$List@UStrAndBool@@@DataStructures@@QBEAAUStrAndBool@@I@Z PROC ; DataStructures::List<StrAndBool>::operator[], COMDAT
; _this$ = ecx

; 185  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 186  : #ifdef _DEBUG
; 187  : 		assert ( position < list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN3@operator
	push	187					; 000000bbH
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@operator:

; 188  : #endif
; 189  : 		return listArray[ position ];

	imul	eax, DWORD PTR _position$[ebp], 5
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]

; 190  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@UStrAndBool@@@DataStructures@@QBEAAUStrAndBool@@I@Z ENDP ; DataStructures::List<StrAndBool>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??1?$List@UStrAndBool@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
??1?$List@UStrAndBool@@@DataStructures@@QAE@XZ PROC	; DataStructures::List<StrAndBool>::~List<StrAndBool>, COMDAT
; _this$ = ecx

; 121  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 122  : 		if (allocation_size>0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jbe	SHORT $LN2@List

; 123  : 			delete [] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@List:

; 124  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@UStrAndBool@@@DataStructures@@QAE@XZ ENDP	; DataStructures::List<StrAndBool>::~List<StrAndBool>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??0?$List@UStrAndBool@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$List@UStrAndBool@@@DataStructures@@QAE@XZ PROC	; DataStructures::List<StrAndBool>::List<StrAndBool>, COMDAT
; _this$ = ecx

; 113  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 114  : 		allocation_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 115  : 		listArray = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 116  : 		list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 117  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@UStrAndBool@@@DataStructures@@QAE@XZ ENDP	; DataStructures::List<StrAndBool>::List<StrAndBool>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?Size@?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QBEIXZ PROC ; DataStructures::OrderedList<char *,StrAndBool,&StrAndBoolComp>::Size, COMDAT
; _this$ = ecx

; 231  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 232  : 		return orderedList.Size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@UStrAndBool@@@DataStructures@@QBEIXZ ; DataStructures::List<StrAndBool>::Size

; 233  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QBEIXZ ENDP ; DataStructures::OrderedList<char *,StrAndBool,&StrAndBoolComp>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?Clear@?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Clear@?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QAEXXZ PROC ; DataStructures::OrderedList<char *,StrAndBool,&StrAndBoolComp>::Clear, COMDAT
; _this$ = ecx

; 219  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 220  : 		orderedList.Clear();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UStrAndBool@@@DataStructures@@QAEX_N@Z ; DataStructures::List<StrAndBool>::Clear

; 221  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QAEXXZ ENDP ; DataStructures::OrderedList<char *,StrAndBool,&StrAndBoolComp>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ??A?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QBEAAUStrAndBool@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
??A?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QBEAAUStrAndBool@@I@Z PROC ; DataStructures::OrderedList<char *,StrAndBool,&StrAndBoolComp>::operator[], COMDAT
; _this$ = ecx

; 225  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 226  : 		return orderedList[position];

	mov	eax, DWORD PTR _position$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UStrAndBool@@@DataStructures@@QBEAAUStrAndBool@@I@Z ; DataStructures::List<StrAndBool>::operator[]

; 227  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QBEAAUStrAndBool@@I@Z ENDP ; DataStructures::OrderedList<char *,StrAndBool,&StrAndBoolComp>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?Insert@?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QAEIABQADABUStrAndBool@@@Z
_TEXT	SEGMENT
_index$ = -32						; size = 4
_objectExists$ = -17					; size = 1
_this$ = -8						; size = 4
_key$ = 8						; size = 4
_data$ = 12						; size = 4
?Insert@?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QAEIABQADABUStrAndBool@@@Z PROC ; DataStructures::OrderedList<char *,StrAndBool,&StrAndBoolComp>::Insert, COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		bool objectExists;
; 158  : 		unsigned index;
; 159  : 		index = GetIndexFromKey(key, &objectExists);

	lea	eax, DWORD PTR _objectExists$[ebp]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexFromKey@?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QBEIABQADPA_N@Z ; DataStructures::OrderedList<char *,StrAndBool,&StrAndBoolComp>::GetIndexFromKey
	mov	DWORD PTR _index$[ebp], eax

; 160  : 
; 161  : 		// Don't allow duplicate insertion.
; 162  : 		if (objectExists)

	movzx	eax, BYTE PTR _objectExists$[ebp]
	test	eax, eax
	je	SHORT $LN3@Insert

; 163  : 			return (unsigned)-1;

	or	eax, -1
	jmp	SHORT $LN4@Insert
$LN3@Insert:

; 164  : 
; 165  : 		if (index>=orderedList.Size())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@UStrAndBool@@@DataStructures@@QBEIXZ ; DataStructures::List<StrAndBool>::Size
	cmp	DWORD PTR _index$[ebp], eax
	jb	SHORT $LN2@Insert

; 166  : 		{
; 167  : 			orderedList.Insert(data);

	mov	eax, DWORD PTR _data$[ebp]
	sub	esp, 8
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	al, BYTE PTR [eax+4]
	mov	BYTE PTR [ecx+4], al
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Insert@?$List@UStrAndBool@@@DataStructures@@QAEXUStrAndBool@@@Z ; DataStructures::List<StrAndBool>::Insert

; 168  : 			return orderedList.Size()-1;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@UStrAndBool@@@DataStructures@@QBEIXZ ; DataStructures::List<StrAndBool>::Size
	sub	eax, 1
	jmp	SHORT $LN4@Insert

; 169  : 		}
; 170  : 		else

	jmp	SHORT $LN4@Insert
$LN2@Insert:

; 171  : 		{
; 172  : 			orderedList.Insert(data,index);

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	sub	esp, 8
	mov	edx, esp
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	cl, BYTE PTR [ecx+4]
	mov	BYTE PTR [edx+4], cl
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Insert@?$List@UStrAndBool@@@DataStructures@@QAEXUStrAndBool@@I@Z ; DataStructures::List<StrAndBool>::Insert

; 173  : 			return index;

	mov	eax, DWORD PTR _index$[ebp]
$LN4@Insert:

; 174  : 		}		
; 175  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@Insert
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN8@Insert:
	DD	1
	DD	$LN7@Insert
$LN7@Insert:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN6@Insert
$LN6@Insert:
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
?Insert@?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QAEIABQADABUStrAndBool@@@Z ENDP ; DataStructures::OrderedList<char *,StrAndBool,&StrAndBoolComp>::Insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?GetIndexFromKey@?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QBEIABQADPA_N@Z
_TEXT	SEGMENT
_res$ = -56						; size = 4
_lowerBound$ = -44					; size = 4
_upperBound$ = -32					; size = 4
_index$ = -20						; size = 4
_this$ = -8						; size = 4
_key$ = 8						; size = 4
_objectExists$ = 12					; size = 4
?GetIndexFromKey@?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QBEIABQADPA_N@Z PROC ; DataStructures::OrderedList<char *,StrAndBool,&StrAndBoolComp>::GetIndexFromKey, COMDAT
; _this$ = ecx

; 110  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 111  : 		int index, upperBound, lowerBound;
; 112  : 		int res;
; 113  : 
; 114  : 		if (orderedList.Size()==0)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@UStrAndBool@@@DataStructures@@QBEIXZ ; DataStructures::List<StrAndBool>::Size
	test	eax, eax
	jne	SHORT $LN8@GetIndexFr

; 115  : 		{
; 116  : 			*objectExists=false;

	mov	eax, DWORD PTR _objectExists$[ebp]
	mov	BYTE PTR [eax], 0

; 117  : 			return 0;

	xor	eax, eax
	jmp	$LN9@GetIndexFr
$LN8@GetIndexFr:

; 118  : 		}
; 119  : 
; 120  : 		upperBound=(int)orderedList.Size()-1;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@UStrAndBool@@@DataStructures@@QBEIXZ ; DataStructures::List<StrAndBool>::Size
	sub	eax, 1
	mov	DWORD PTR _upperBound$[ebp], eax

; 121  : 		lowerBound=0;

	mov	DWORD PTR _lowerBound$[ebp], 0

; 122  : 		index = (int)orderedList.Size()/2;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@UStrAndBool@@@DataStructures@@QBEIXZ ; DataStructures::List<StrAndBool>::Size
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _index$[ebp], eax
$LN7@GetIndexFr:

; 123  : 
; 124  : #ifdef _MSC_VER
; 125  : 	#pragma warning( disable : 4127 ) // warning C4127: conditional expression is constant
; 126  : #endif
; 127  : 		while (1)

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN9@GetIndexFr

; 128  : 		{
; 129  : 			res = comparison_function(key,orderedList[index]);

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UStrAndBool@@@DataStructures@@QBEAAUStrAndBool@@I@Z ; DataStructures::List<StrAndBool>::operator[]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	call	?StrAndBoolComp@@YAHABQADABUStrAndBool@@@Z ; StrAndBoolComp
	add	esp, 8
	mov	DWORD PTR _res$[ebp], eax

; 130  : 			if (res==0)

	cmp	DWORD PTR _res$[ebp], 0
	jne	SHORT $LN5@GetIndexFr

; 131  : 			{
; 132  : 				*objectExists=true;

	mov	eax, DWORD PTR _objectExists$[ebp]
	mov	BYTE PTR [eax], 1

; 133  : 				return index;

	mov	eax, DWORD PTR _index$[ebp]
	jmp	SHORT $LN9@GetIndexFr
	jmp	SHORT $LN4@GetIndexFr
$LN5@GetIndexFr:

; 134  : 			}
; 135  : 			else if (res<0)

	cmp	DWORD PTR _res$[ebp], 0
	jge	SHORT $LN3@GetIndexFr

; 136  : 			{
; 137  : 				upperBound=index-1;

	mov	eax, DWORD PTR _index$[ebp]
	sub	eax, 1
	mov	DWORD PTR _upperBound$[ebp], eax

; 138  : 			}
; 139  : 			else// if (res>0)

	jmp	SHORT $LN4@GetIndexFr
$LN3@GetIndexFr:

; 140  : 			{
; 141  : 				lowerBound=index+1;

	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 1
	mov	DWORD PTR _lowerBound$[ebp], eax
$LN4@GetIndexFr:

; 142  : 			}
; 143  : 
; 144  : 			index=lowerBound+(upperBound-lowerBound)/2;

	mov	eax, DWORD PTR _upperBound$[ebp]
	sub	eax, DWORD PTR _lowerBound$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _lowerBound$[ebp]
	mov	DWORD PTR _index$[ebp], eax

; 145  : 
; 146  : 			if (lowerBound>upperBound)

	mov	eax, DWORD PTR _lowerBound$[ebp]
	cmp	eax, DWORD PTR _upperBound$[ebp]
	jle	SHORT $LN1@GetIndexFr

; 147  : 			{
; 148  : 				*objectExists=false;

	mov	eax, DWORD PTR _objectExists$[ebp]
	mov	BYTE PTR [eax], 0

; 149  : 				return lowerBound; // No match

	mov	eax, DWORD PTR _lowerBound$[ebp]
	jmp	SHORT $LN9@GetIndexFr
$LN1@GetIndexFr:

; 150  : 			}
; 151  : 		}

	jmp	SHORT $LN7@GetIndexFr
$LN9@GetIndexFr:

; 152  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?GetIndexFromKey@?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QBEIABQADPA_N@Z ENDP ; DataStructures::OrderedList<char *,StrAndBool,&StrAndBoolComp>::GetIndexFromKey
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ??1?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QAE@XZ PROC ; DataStructures::OrderedList<char *,StrAndBool,&StrAndBoolComp>::~OrderedList<char *,StrAndBool,&StrAndBoolComp>, COMDAT
; _this$ = ecx

; 72   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 73   : 		Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QAEXXZ ; DataStructures::OrderedList<char *,StrAndBool,&StrAndBoolComp>::Clear

; 74   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$List@UStrAndBool@@@DataStructures@@QAE@XZ ; DataStructures::List<StrAndBool>::~List<StrAndBool>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$List@UStrAndBool@@@DataStructures@@QAE@XZ ; DataStructures::List<StrAndBool>::~List<StrAndBool>
__ehhandler$??1?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QAE@XZ ENDP ; DataStructures::OrderedList<char *,StrAndBool,&StrAndBoolComp>::~OrderedList<char *,StrAndBool,&StrAndBoolComp>
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ??0?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QAE@XZ PROC ; DataStructures::OrderedList<char *,StrAndBool,&StrAndBoolComp>::OrderedList<char *,StrAndBool,&StrAndBoolComp>, COMDAT
; _this$ = ecx

; 67   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$List@UStrAndBool@@@DataStructures@@QAE@XZ ; DataStructures::List<StrAndBool>::List<StrAndBool>

; 68   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QAE@XZ ENDP ; DataStructures::OrderedList<char *,StrAndBool,&StrAndBoolComp>::OrderedList<char *,StrAndBool,&StrAndBoolComp>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\stringtable.cpp
;	COMDAT ??0StringTable@@IAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0StringTable@@IAE@XZ PROC				; StringTable::StringTable, COMDAT
; _this$ = ecx

; 17   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<char *,StrAndBool,&StrAndBoolComp>::OrderedList<char *,StrAndBool,&StrAndBoolComp>

; 18   : 
; 19   : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0StringTable@@IAE@XZ ENDP				; StringTable::StringTable
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\stringtable.cpp
;	COMDAT ?LogStringNotFound@StringTable@@IAEXPBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_strName$ = 8						; size = 4
?LogStringNotFound@StringTable@@IAEXPBD@Z PROC		; StringTable::LogStringNotFound, COMDAT
; _this$ = ecx

; 139  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : #ifdef _DEBUG
; 141  : 	printf("Efficiency Warning! Unregistered String %s sent to StringTable.\n", strName);

	mov	eax, DWORD PTR _strName$[ebp]
	push	eax
	push	OFFSET ??_C@_0EB@HCJBANNB@Efficiency?5Warning?$CB?5Unregistered@
	call	_printf
	add	esp, 8

; 142  : #endif
; 143  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?LogStringNotFound@StringTable@@IAEXPBD@Z ENDP		; StringTable::LogStringNotFound
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\stringtable.cpp
;	COMDAT ?RemoveReference@StringTable@@SAXXZ
_TEXT	SEGMENT
tv77 = -220						; size = 4
$T1 = -212						; size = 4
$T2 = -200						; size = 4
?RemoveReference@StringTable@@SAXXZ PROC		; StringTable::RemoveReference, COMDAT

; 39   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 40   : 	assert(referenceCount > 0);

	cmp	DWORD PTR ?referenceCount@StringTable@@1HA, 0 ; StringTable::referenceCount
	jg	SHORT $LN5@RemoveRefe
	mov	eax, DWORD PTR ?__LINE__Var@?1??RemoveReference@StringTable@@SAXXZ@4JA@e8ba9f31
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_1FA@FIECJAFM@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AAt?$AAa@
	push	OFFSET ??_C@_1CG@DEPNCJGC@?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAe?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN5@RemoveRefe:

; 41   : 
; 42   : 	if (referenceCount > 0)

	cmp	DWORD PTR ?referenceCount@StringTable@@1HA, 0 ; StringTable::referenceCount
	jle	SHORT $LN3@RemoveRefe

; 43   : 	{
; 44   : 		if (--referenceCount==0)

	mov	eax, DWORD PTR ?referenceCount@StringTable@@1HA ; StringTable::referenceCount
	sub	eax, 1
	mov	DWORD PTR ?referenceCount@StringTable@@1HA, eax ; StringTable::referenceCount
	jne	SHORT $LN3@RemoveRefe

; 45   : 		{
; 46   : 			delete instance;

	mov	eax, DWORD PTR ?instance@StringTable@@1PAV1@A ; StringTable::instance
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN6@RemoveRefe
	push	1
	mov	ecx, DWORD PTR $T1[ebp]
	call	??_GStringTable@@QAEPAXI@Z
	mov	DWORD PTR tv77[ebp], eax
	jmp	SHORT $LN7@RemoveRefe
$LN6@RemoveRefe:
	mov	DWORD PTR tv77[ebp], 0
$LN7@RemoveRefe:

; 47   : 			instance=0;

	mov	DWORD PTR ?instance@StringTable@@1PAV1@A, 0 ; StringTable::instance
$LN3@RemoveRefe:

; 48   : 		}
; 49   : 	}
; 50   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveReference@StringTable@@SAXXZ ENDP		; StringTable::RemoveReference
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\stringtable.cpp
;	COMDAT ?AddReference@StringTable@@SAXXZ
_TEXT	SEGMENT
tv73 = -232						; size = 4
$T2 = -224						; size = 4
$T3 = -212						; size = 4
__$EHRec$ = -12						; size = 12
?AddReference@StringTable@@SAXXZ PROC			; StringTable::AddReference, COMDAT

; 32   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddReference@StringTable@@SAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 33   : 	if (++referenceCount==1)

	mov	eax, DWORD PTR ?referenceCount@StringTable@@1HA ; StringTable::referenceCount
	add	eax, 1
	mov	DWORD PTR ?referenceCount@StringTable@@1HA, eax ; StringTable::referenceCount
	cmp	DWORD PTR ?referenceCount@StringTable@@1HA, 1 ; StringTable::referenceCount
	jne	SHORT $LN2@AddReferen

; 34   : 	{
; 35   : 		instance = new StringTable;

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN4@AddReferen
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0StringTable@@IAE@XZ			; StringTable::StringTable
	mov	DWORD PTR tv73[ebp], eax
	jmp	SHORT $LN5@AddReferen
$LN4@AddReferen:
	mov	DWORD PTR tv73[ebp], 0
$LN5@AddReferen:
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR ?instance@StringTable@@1PAV1@A, ecx ; StringTable::instance
$LN2@AddReferen:

; 36   : 	}
; 37   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddReference@StringTable@@SAXXZ$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?AddReference@StringTable@@SAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-236]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddReference@StringTable@@SAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddReference@StringTable@@SAXXZ ENDP			; StringTable::AddReference
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\stringtable.cpp
;	COMDAT ?DecodeString@StringTable@@QAE_NPADHPAVBitStream@RakNet@@@Z
_TEXT	SEGMENT
_index$1 = -29						; size = 1
_hasIndex$ = -17					; size = 1
_this$ = -8						; size = 4
_output$ = 8						; size = 4
_maxCharsToWrite$ = 12					; size = 4
_input$ = 16						; size = 4
?DecodeString@StringTable@@QAE_NPADHPAVBitStream@RakNet@@@Z PROC ; StringTable::DecodeString, COMDAT
; _this$ = ecx

; 102  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 103  : 	bool hasIndex;
; 104  : 	assert(maxCharsToWrite>0);

	cmp	DWORD PTR _maxCharsToWrite$[ebp], 0
	jg	SHORT $LN9@DecodeStri
	mov	eax, DWORD PTR ?__LINE__Var@?1??DecodeString@StringTable@@QAE_NPADHPAVBitStream@RakNet@@@Z@4JA
	add	eax, 2
	push	eax
	push	OFFSET ??_C@_1FA@FIECJAFM@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AAt?$AAa@
	push	OFFSET ??_C@_1CE@IIKHMION@?$AAm?$AAa?$AAx?$AAC?$AAh?$AAa?$AAr?$AAs?$AAT?$AAo?$AAW?$AAr?$AAi?$AAt?$AAe?$AA?$DO?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN9@DecodeStri:

; 105  : 
; 106  : 	if (maxCharsToWrite==0)

	cmp	DWORD PTR _maxCharsToWrite$[ebp], 0
	jne	SHORT $LN6@DecodeStri

; 107  : 		return false;

	xor	al, al
	jmp	$LN7@DecodeStri
$LN6@DecodeStri:

; 108  : 	if (!input->Read(hasIndex))

	lea	eax, DWORD PTR _hasIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _input$[ebp]
	call	??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z ; RakNet::BitStream::Read<bool>
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN5@DecodeStri

; 109  : 		return false;

	xor	al, al
	jmp	$LN7@DecodeStri
$LN5@DecodeStri:

; 110  : 	if (hasIndex==false)

	movzx	eax, BYTE PTR _hasIndex$[ebp]
	test	eax, eax
	jne	SHORT $LN4@DecodeStri

; 111  : 	{
; 112  : 		stringCompressor->DecodeString(output, maxCharsToWrite, input);

	push	0
	mov	eax, DWORD PTR _input$[ebp]
	push	eax
	mov	ecx, DWORD PTR _maxCharsToWrite$[ebp]
	push	ecx
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	?Instance@StringCompressor@@SAPAV1@XZ	; StringCompressor::Instance
	mov	ecx, eax
	call	?DecodeString@StringCompressor@@QAE_NPADHPAVBitStream@RakNet@@H@Z ; StringCompressor::DecodeString

; 113  : 	}
; 114  : 	else

	jmp	SHORT $LN3@DecodeStri
$LN4@DecodeStri:

; 115  : 	{
; 116  : 		StringTableType index;
; 117  : 		if (!input->Read(index))

	lea	eax, DWORD PTR _index$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _input$[ebp]
	call	??$Read@E@BitStream@RakNet@@QAE_NAAE@Z	; RakNet::BitStream::Read<unsigned char>
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@DecodeStri

; 118  : 			return false;

	xor	al, al
	jmp	SHORT $LN7@DecodeStri
$LN2@DecodeStri:

; 119  : 		if (index >= orderedStringList.Size())

	movzx	esi, BYTE PTR _index$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<char *,StrAndBool,&StrAndBoolComp>::Size
	cmp	esi, eax
	jb	SHORT $LN1@DecodeStri

; 120  : 		{
; 121  : #ifdef _DEBUG
; 122  : 			// Critical error - got a string index out of range, which means AddString was called more times on the remote system than on this system.
; 123  : 			// All systems must call AddString the same number of types, with the same strings in the same order.
; 124  : 			assert(0);

	xor	eax, eax
	jne	SHORT $LN10@DecodeStri
	mov	ecx, DWORD PTR ?__LINE__Var@?1??DecodeString@StringTable@@QAE_NPADHPAVBitStream@RakNet@@@Z@4JA
	add	ecx, 22					; 00000016H
	push	ecx
	push	OFFSET ??_C@_1FA@FIECJAFM@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AAt?$AAa@
	push	OFFSET ??_C@_13COJANIEC@?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN10@DecodeStri:

; 125  : #endif
; 126  : 			return false;

	xor	al, al
	jmp	SHORT $LN7@DecodeStri
$LN1@DecodeStri:

; 127  : 		}
; 128  : 		
; 129  : 		strncpy(output, orderedStringList[index].str, maxCharsToWrite);

	mov	eax, DWORD PTR _maxCharsToWrite$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _index$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QBEAAUStrAndBool@@I@Z ; DataStructures::OrderedList<char *,StrAndBool,&StrAndBoolComp>::operator[]
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	call	_strncpy
	add	esp, 12					; 0000000cH

; 130  : 		output[maxCharsToWrite-1]=0;

	mov	eax, DWORD PTR _output$[ebp]
	add	eax, DWORD PTR _maxCharsToWrite$[ebp]
	mov	BYTE PTR [eax-1], 0
$LN3@DecodeStri:

; 131  : 	}
; 132  : 
; 133  : 	return true;

	mov	al, 1
$LN7@DecodeStri:

; 134  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN14@DecodeStri
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	3
$LN14@DecodeStri:
	DD	2
	DD	$LN13@DecodeStri
$LN13@DecodeStri:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN11@DecodeStri
	DD	-29					; ffffffe3H
	DD	1
	DD	$LN12@DecodeStri
$LN12@DecodeStri:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	0
$LN11@DecodeStri:
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	0
?DecodeString@StringTable@@QAE_NPADHPAVBitStream@RakNet@@@Z ENDP ; StringTable::DecodeString
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\stringtable.cpp
;	COMDAT ?EncodeString@StringTable@@QAEXPBDHPAVBitStream@RakNet@@@Z
_TEXT	SEGMENT
$T1 = -236						; size = 4
_objectExists$ = -29					; size = 1
_index$ = -20						; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
_maxCharsToWrite$ = 12					; size = 4
_output$ = 16						; size = 4
?EncodeString@StringTable@@QAEXPBDHPAVBitStream@RakNet@@@Z PROC ; StringTable::EncodeString, COMDAT
; _this$ = ecx

; 83   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 84   : 	unsigned index;
; 85   : 	bool objectExists;
; 86   : 	// This is fast because the list is kept ordered.
; 87   : 	index=orderedStringList.GetIndexFromKey((char*)input, &objectExists);

	mov	eax, DWORD PTR _input$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	lea	ecx, DWORD PTR _objectExists$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexFromKey@?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QBEIABQADPA_N@Z ; DataStructures::OrderedList<char *,StrAndBool,&StrAndBoolComp>::GetIndexFromKey
	mov	DWORD PTR _index$[ebp], eax

; 88   : 	if (objectExists)

	movzx	eax, BYTE PTR _objectExists$[ebp]
	test	eax, eax
	je	SHORT $LN2@EncodeStri

; 89   : 	{
; 90   : 		output->Write(true);

	push	1
	mov	ecx, DWORD PTR _output$[ebp]
	call	??$Write@_N@BitStream@RakNet@@QAEX_N@Z	; RakNet::BitStream::Write<bool>

; 91   : 		output->Write((StringTableType)index);

	movzx	eax, BYTE PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _output$[ebp]
	call	??$Write@E@BitStream@RakNet@@QAEXE@Z	; RakNet::BitStream::Write<unsigned char>

; 92   : 	}
; 93   : 	else

	jmp	SHORT $LN3@EncodeStri
$LN2@EncodeStri:

; 94   : 	{
; 95   : 		LogStringNotFound(input);

	mov	eax, DWORD PTR _input$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogStringNotFound@StringTable@@IAEXPBD@Z ; StringTable::LogStringNotFound

; 96   : 		output->Write(false);

	push	0
	mov	ecx, DWORD PTR _output$[ebp]
	call	??$Write@_N@BitStream@RakNet@@QAEX_N@Z	; RakNet::BitStream::Write<bool>

; 97   : 		stringCompressor->EncodeString(input, maxCharsToWrite, output);

	push	0
	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	mov	ecx, DWORD PTR _maxCharsToWrite$[ebp]
	push	ecx
	mov	edx, DWORD PTR _input$[ebp]
	push	edx
	call	?Instance@StringCompressor@@SAPAV1@XZ	; StringCompressor::Instance
	mov	ecx, eax
	call	?EncodeString@StringCompressor@@QAEXPBDHPAVBitStream@RakNet@@H@Z ; StringCompressor::EncodeString
$LN3@EncodeStri:

; 98   : 	}
; 99   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@EncodeStri
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	2
$LN7@EncodeStri:
	DD	1
	DD	$LN6@EncodeStri
$LN6@EncodeStri:
	DD	-29					; ffffffe3H
	DD	1
	DD	$LN5@EncodeStri
$LN5@EncodeStri:
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
?EncodeString@StringTable@@QAEXPBDHPAVBitStream@RakNet@@@Z ENDP ; StringTable::EncodeString
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\stringtable.cpp
;	COMDAT ?AddString@StringTable@@QAEXPBD_N@Z
_TEXT	SEGMENT
$T1 = -240						; size = 4
$T2 = -228						; size = 4
_sab$ = -24						; size = 5
_this$ = -8						; size = 4
_str$ = 8						; size = 4
_copyString$ = 12					; size = 1
?AddString@StringTable@@QAEXPBD_N@Z PROC		; StringTable::AddString, COMDAT
; _this$ = ecx

; 58   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 59   : 	StrAndBool sab;
; 60   : 	sab.b=copyString;

	mov	al, BYTE PTR _copyString$[ebp]
	mov	BYTE PTR _sab$[ebp+4], al

; 61   : 	if (copyString)

	movzx	eax, BYTE PTR _copyString$[ebp]
	test	eax, eax
	je	SHORT $LN4@AddString

; 62   : 	{
; 63   : 		sab.str = new char [strlen(str)+1];

	mov	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR _sab$[ebp], ecx

; 64   : 		strcpy(sab.str, str);

	mov	eax, DWORD PTR _str$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sab$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 65   : 	}
; 66   : 	else

	jmp	SHORT $LN3@AddString
$LN4@AddString:

; 67   : 	{
; 68   : 		sab.str=(char*)str;

	mov	eax, DWORD PTR _str$[ebp]
	mov	DWORD PTR _sab$[ebp], eax
$LN3@AddString:

; 69   : 	}
; 70   : 
; 71   : 	// If it asserts inside here you are adding duplicate strings.
; 72   : 	if (!orderedStringList.Insert(sab.str,sab))

	lea	eax, DWORD PTR _sab$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sab$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Insert@?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QAEIABQADABUStrAndBool@@@Z ; DataStructures::OrderedList<char *,StrAndBool,&StrAndBoolComp>::Insert
	test	eax, eax
	jne	SHORT $LN2@AddString

; 73   : 	{
; 74   : 		if (copyString)

	movzx	eax, BYTE PTR _copyString$[ebp]
	test	eax, eax
	je	SHORT $LN2@AddString

; 75   : 			delete sab.str;

	mov	eax, DWORD PTR _sab$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@AddString:

; 76   : 	}
; 77   : 
; 78   : 	// If this assert hits you need to increase the range of StringTableType
; 79   : 	assert(orderedStringList.Size() < (StringTableType)-1);	

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<char *,StrAndBool,&StrAndBoolComp>::Size
	cmp	eax, 255				; 000000ffH
	jb	SHORT $LN5@AddString
	mov	eax, DWORD PTR ?__LINE__Var@?1??AddString@StringTable@@QAEXPBD_N@Z@4JA
	add	eax, 21					; 00000015H
	push	eax
	push	OFFSET ??_C@_1FA@FIECJAFM@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AAt?$AAa@
	push	OFFSET ??_C@_1FO@HDKNIFHI@?$AAo?$AAr?$AAd?$AAe?$AAr?$AAe?$AAd?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AAL?$AAi?$AAs?$AAt?$AA?4?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAS?$AAt?$AAr?$AAi@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN5@AddString:

; 80   : 	
; 81   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@AddString
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN10@AddString:
	DD	1
	DD	$LN9@AddString
$LN9@AddString:
	DD	-24					; ffffffe8H
	DD	5
	DD	$LN8@AddString
$LN8@AddString:
	DB	115					; 00000073H
	DB	97					; 00000061H
	DB	98					; 00000062H
	DB	0
?AddString@StringTable@@QAEXPBD_N@Z ENDP		; StringTable::AddString
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\stringtable.cpp
;	COMDAT ?Instance@StringTable@@SAPAV1@XZ
_TEXT	SEGMENT
?Instance@StringTable@@SAPAV1@XZ PROC			; StringTable::Instance, COMDAT

; 53   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 54   : 	return instance;

	mov	eax, DWORD PTR ?instance@StringTable@@1PAV1@A ; StringTable::instance

; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Instance@StringTable@@SAPAV1@XZ ENDP			; StringTable::Instance
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\stringtable.cpp
;	COMDAT ??1StringTable@@QAE@XZ
_TEXT	SEGMENT
$T2 = -236						; size = 4
_i$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1StringTable@@QAE@XZ PROC				; StringTable::~StringTable, COMDAT
; _this$ = ecx

; 22   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1StringTable@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 23   : 	unsigned i;
; 24   : 	for (i=0; i < orderedStringList.Size(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@StringTabl
$LN3@StringTabl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@StringTabl:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<char *,StrAndBool,&StrAndBoolComp>::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN5@StringTabl

; 25   : 	{
; 26   : 		if (orderedStringList[i].b)

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QBEAAUStrAndBool@@I@Z ; DataStructures::OrderedList<char *,StrAndBool,&StrAndBoolComp>::operator[]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN1@StringTabl

; 27   : 			delete [] orderedStringList[i].str;

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QBEAAUStrAndBool@@I@Z ; DataStructures::OrderedList<char *,StrAndBool,&StrAndBoolComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@StringTabl:

; 28   : 	}

	jmp	SHORT $LN3@StringTabl
$LN5@StringTabl:

; 29   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<char *,StrAndBool,&StrAndBoolComp>::~OrderedList<char *,StrAndBool,&StrAndBoolComp>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1StringTable@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$OrderedList@PADUStrAndBool@@$1?StrAndBoolComp@@YAHABQADABU1@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<char *,StrAndBool,&StrAndBoolComp>::~OrderedList<char *,StrAndBool,&StrAndBoolComp>
__ehhandler$??1StringTable@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-244]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1StringTable@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1StringTable@@QAE@XZ ENDP				; StringTable::~StringTable
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\stringtable.cpp
;	COMDAT ?StrAndBoolComp@@YAHABQADABUStrAndBool@@@Z
_TEXT	SEGMENT
_key$ = 8						; size = 4
_data$ = 12						; size = 4
?StrAndBoolComp@@YAHABQADABUStrAndBool@@@Z PROC		; StrAndBoolComp, COMDAT

; 12   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 13   : 	return strcmp(key,(const char*)data.str);

	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _key$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_strcmp
	add	esp, 8

; 14   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?StrAndBoolComp@@YAHABQADABUStrAndBool@@@Z ENDP		; StrAndBoolComp
_TEXT	ENDS
END
