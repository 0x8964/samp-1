; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.31101.0 

	TITLE	Z:\sampsrc\02Xu1\raknet\ReplicaManager.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
_UNASSIGNED_PLAYER_ID DD 0ffffffffH
	DW	0ffffH
	ORG $+2
_UNASSIGNED_NETWORK_ID DD 0ffffffffH
	DW	0ffffH
	DW	0ffffH
CONST	ENDS
PUBLIC	??4PlayerID@@QAEAAU0@ABU0@@Z			; PlayerID::operator=
PUBLIC	??0PluginInterface@@QAE@XZ			; PluginInterface::PluginInterface
PUBLIC	??0ReplicaManager@@QAE@XZ			; ReplicaManager::ReplicaManager
PUBLIC	??1ReplicaManager@@QAE@XZ			; ReplicaManager::~ReplicaManager
PUBLIC	?SetAutoParticipateNewConnections@ReplicaManager@@QAEX_N@Z ; ReplicaManager::SetAutoParticipateNewConnections
PUBLIC	?AddParticipant@ReplicaManager@@QAEXUPlayerID@@@Z ; ReplicaManager::AddParticipant
PUBLIC	?RemoveParticipant@ReplicaManager@@QAEXUPlayerID@@@Z ; ReplicaManager::RemoveParticipant
PUBLIC	?Construct@ReplicaManager@@QAEXPAVReplica@@_NUPlayerID@@1@Z ; ReplicaManager::Construct
PUBLIC	?Destruct@ReplicaManager@@QAEXPAVReplica@@UPlayerID@@_N@Z ; ReplicaManager::Destruct
PUBLIC	?ReferencePointer@ReplicaManager@@QAEXPAVReplica@@@Z ; ReplicaManager::ReferencePointer
PUBLIC	?DereferencePointer@ReplicaManager@@QAEXPAVReplica@@@Z ; ReplicaManager::DereferencePointer
PUBLIC	?SetScope@ReplicaManager@@QAEXPAVReplica@@_NUPlayerID@@1@Z ; ReplicaManager::SetScope
PUBLIC	?SignalSerializeNeeded@ReplicaManager@@QAEXPAVReplica@@UPlayerID@@_N@Z ; ReplicaManager::SignalSerializeNeeded
PUBLIC	?SetReceiveConstructionCB@ReplicaManager@@QAEXP6A?AW4ReplicaReturnResult@@PAVBitStream@RakNet@@IUNetworkID@@UPlayerID@@PAV1@@Z@Z ; ReplicaManager::SetReceiveConstructionCB
PUBLIC	?SetDownloadCompleteCB@ReplicaManager@@QAEXP6A?AW4ReplicaReturnResult@@PAVBitStream@RakNet@@IUPlayerID@@PAV1@@ZP6A?AW42@012@Z@Z ; ReplicaManager::SetDownloadCompleteCB
PUBLIC	?SetSendChannel@ReplicaManager@@QAEXE@Z		; ReplicaManager::SetSendChannel
PUBLIC	?SetAutoConstructToNewParticipants@ReplicaManager@@QAEX_N@Z ; ReplicaManager::SetAutoConstructToNewParticipants
PUBLIC	?SetDefaultScope@ReplicaManager@@QAEX_N@Z	; ReplicaManager::SetDefaultScope
PUBLIC	?EnableReplicaInterfaces@ReplicaManager@@QAEXPAVReplica@@E@Z ; ReplicaManager::EnableReplicaInterfaces
PUBLIC	?DisableReplicaInterfaces@ReplicaManager@@QAEXPAVReplica@@E@Z ; ReplicaManager::DisableReplicaInterfaces
PUBLIC	?IsConstructed@ReplicaManager@@QAE_NPAVReplica@@UPlayerID@@@Z ; ReplicaManager::IsConstructed
PUBLIC	?IsInScope@ReplicaManager@@QAE_NPAVReplica@@UPlayerID@@@Z ; ReplicaManager::IsInScope
PUBLIC	?GetReplicaCount@ReplicaManager@@QBEIXZ		; ReplicaManager::GetReplicaCount
PUBLIC	?GetReplicaAtIndex@ReplicaManager@@QAEPAVReplica@@I@Z ; ReplicaManager::GetReplicaAtIndex
PUBLIC	?RegisteredReplicaComp@ReplicaManager@@SAHABQAVReplica@@ABURegisteredReplica@1@@Z ; ReplicaManager::RegisteredReplicaComp
PUBLIC	?RemoteObjectComp@ReplicaManager@@SAHABQAVReplica@@ABURemoteObject@1@@Z ; ReplicaManager::RemoteObjectComp
PUBLIC	?CommandStructComp@ReplicaManager@@SAHABQAVReplica@@ABUCommandStruct@1@@Z ; ReplicaManager::CommandStructComp
PUBLIC	??1ParticipantStruct@ReplicaManager@@QAE@XZ	; ReplicaManager::ParticipantStruct::~ParticipantStruct
PUBLIC	??0?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>
PUBLIC	??1?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::~OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>
PUBLIC	?HasData@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBE_NABQAVReplica@@@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::HasData
PUBLIC	?GetIndexFromKey@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIABQAVReplica@@PA_N@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::GetIndexFromKey
PUBLIC	?Insert@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEIABQAVReplica@@ABUCommandStruct@ReplicaManager@@@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::Insert
PUBLIC	??A?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAUCommandStruct@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::operator[]
PUBLIC	?RemoveAtIndex@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEXI@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::RemoveAtIndex
PUBLIC	?Clear@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEXXZ ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::Clear
PUBLIC	?Size@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::Size
PUBLIC	??0?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QAE@XZ ; DataStructures::List<ReplicaManager::CommandStruct>::List<ReplicaManager::CommandStruct>
PUBLIC	??1?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QAE@XZ ; DataStructures::List<ReplicaManager::CommandStruct>::~List<ReplicaManager::CommandStruct>
PUBLIC	??A?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QBEAAUCommandStruct@ReplicaManager@@I@Z ; DataStructures::List<ReplicaManager::CommandStruct>::operator[]
PUBLIC	?Insert@?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QAEXUCommandStruct@ReplicaManager@@I@Z ; DataStructures::List<ReplicaManager::CommandStruct>::Insert
PUBLIC	?Insert@?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QAEXUCommandStruct@ReplicaManager@@@Z ; DataStructures::List<ReplicaManager::CommandStruct>::Insert
PUBLIC	?RemoveAtIndex@?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QAEXI@Z ; DataStructures::List<ReplicaManager::CommandStruct>::RemoveAtIndex
PUBLIC	?Del@?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QAEXI@Z ; DataStructures::List<ReplicaManager::CommandStruct>::Del
PUBLIC	?Size@?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QBEIXZ ; DataStructures::List<ReplicaManager::CommandStruct>::Size
PUBLIC	?Clear@?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QAEX_N@Z ; DataStructures::List<ReplicaManager::CommandStruct>::Clear
PUBLIC	??0?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>
PUBLIC	??1?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::~OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>
PUBLIC	?HasData@?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBE_NABQAVReplica@@@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::HasData
PUBLIC	?GetIndexFromKey@?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIABQAVReplica@@PA_N@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::GetIndexFromKey
PUBLIC	?Insert@?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEIABQAVReplica@@ABURemoteObject@ReplicaManager@@@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::Insert
PUBLIC	??A?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAURemoteObject@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::operator[]
PUBLIC	?RemoveAtIndex@?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEXI@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::RemoveAtIndex
PUBLIC	?Clear@?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEXXZ ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::Clear
PUBLIC	??0?$List@URemoteObject@ReplicaManager@@@DataStructures@@QAE@XZ ; DataStructures::List<ReplicaManager::RemoteObject>::List<ReplicaManager::RemoteObject>
PUBLIC	??1?$List@URemoteObject@ReplicaManager@@@DataStructures@@QAE@XZ ; DataStructures::List<ReplicaManager::RemoteObject>::~List<ReplicaManager::RemoteObject>
PUBLIC	??A?$List@URemoteObject@ReplicaManager@@@DataStructures@@QBEAAURemoteObject@ReplicaManager@@I@Z ; DataStructures::List<ReplicaManager::RemoteObject>::operator[]
PUBLIC	?Insert@?$List@URemoteObject@ReplicaManager@@@DataStructures@@QAEXURemoteObject@ReplicaManager@@I@Z ; DataStructures::List<ReplicaManager::RemoteObject>::Insert
PUBLIC	?Insert@?$List@URemoteObject@ReplicaManager@@@DataStructures@@QAEXURemoteObject@ReplicaManager@@@Z ; DataStructures::List<ReplicaManager::RemoteObject>::Insert
PUBLIC	?RemoveAtIndex@?$List@URemoteObject@ReplicaManager@@@DataStructures@@QAEXI@Z ; DataStructures::List<ReplicaManager::RemoteObject>::RemoveAtIndex
PUBLIC	?Del@?$List@URemoteObject@ReplicaManager@@@DataStructures@@QAEXI@Z ; DataStructures::List<ReplicaManager::RemoteObject>::Del
PUBLIC	?Size@?$List@URemoteObject@ReplicaManager@@@DataStructures@@QBEIXZ ; DataStructures::List<ReplicaManager::RemoteObject>::Size
PUBLIC	?Clear@?$List@URemoteObject@ReplicaManager@@@DataStructures@@QAEX_N@Z ; DataStructures::List<ReplicaManager::RemoteObject>::Clear
PUBLIC	??0?$Queue@PAUReceivedCommand@ReplicaManager@@@DataStructures@@QAE@XZ ; DataStructures::Queue<ReplicaManager::ReceivedCommand *>::Queue<ReplicaManager::ReceivedCommand *>
PUBLIC	??1?$Queue@PAUReceivedCommand@ReplicaManager@@@DataStructures@@QAE@XZ ; DataStructures::Queue<ReplicaManager::ReceivedCommand *>::~Queue<ReplicaManager::ReceivedCommand *>
PUBLIC	?Push@?$Queue@PAUReceivedCommand@ReplicaManager@@@DataStructures@@QAEXABQAUReceivedCommand@ReplicaManager@@@Z ; DataStructures::Queue<ReplicaManager::ReceivedCommand *>::Push
PUBLIC	?PushAtHead@?$Queue@PAUReceivedCommand@ReplicaManager@@@DataStructures@@QAEXABQAUReceivedCommand@ReplicaManager@@I@Z ; DataStructures::Queue<ReplicaManager::ReceivedCommand *>::PushAtHead
PUBLIC	?Pop@?$Queue@PAUReceivedCommand@ReplicaManager@@@DataStructures@@QAEPAUReceivedCommand@ReplicaManager@@XZ ; DataStructures::Queue<ReplicaManager::ReceivedCommand *>::Pop
PUBLIC	?Size@?$Queue@PAUReceivedCommand@ReplicaManager@@@DataStructures@@QBEIXZ ; DataStructures::Queue<ReplicaManager::ReceivedCommand *>::Size
PUBLIC	??0ParticipantStruct@ReplicaManager@@QAE@XZ	; ReplicaManager::ParticipantStruct::ParticipantStruct
PUBLIC	??_GParticipantStruct@ReplicaManager@@QAEPAXI@Z	; ReplicaManager::ParticipantStruct::`scalar deleting destructor'
PUBLIC	?ParticipantStructComp@ReplicaManager@@SAHABUPlayerID@@ABQAUParticipantStruct@1@@Z ; ReplicaManager::ParticipantStructComp
PUBLIC	?Clear@ReplicaManager@@IAEXXZ			; ReplicaManager::Clear
PUBLIC	?ProcessReceivedCommand@ReplicaManager@@IAE?AW4ReplicaReturnResult@@PAUParticipantStruct@1@PAUReceivedCommand@1@@Z ; ReplicaManager::ProcessReceivedCommand
PUBLIC	?Update@ReplicaManager@@MAEXPAVRakPeerInterface@@@Z ; ReplicaManager::Update
PUBLIC	?OnAttach@ReplicaManager@@MAEXPAVRakPeerInterface@@@Z ; ReplicaManager::OnAttach
PUBLIC	?OnReceive@ReplicaManager@@MAE?AW4PluginReceiveResult@@PAVRakPeerInterface@@PAUPacket@@@Z ; ReplicaManager::OnReceive
PUBLIC	?OnCloseConnection@ReplicaManager@@MAEXPAVRakPeerInterface@@UPlayerID@@@Z ; ReplicaManager::OnCloseConnection
PUBLIC	?OnDisconnect@ReplicaManager@@MAEXPAVRakPeerInterface@@@Z ; ReplicaManager::OnDisconnect
PUBLIC	??0?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>
PUBLIC	??1?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::~OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>
PUBLIC	?HasData@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBE_NABQAVReplica@@@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::HasData
PUBLIC	?GetIndexFromKey@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIABQAVReplica@@PA_N@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::GetIndexFromKey
PUBLIC	?Insert@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEIABQAVReplica@@ABURegisteredReplica@ReplicaManager@@@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::Insert
PUBLIC	??A?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAURegisteredReplica@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::operator[]
PUBLIC	?RemoveAtIndex@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEXI@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::RemoveAtIndex
PUBLIC	?Clear@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEXXZ ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::Clear
PUBLIC	?Size@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::Size
PUBLIC	??0?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QAE@XZ ; DataStructures::List<ReplicaManager::RegisteredReplica>::List<ReplicaManager::RegisteredReplica>
PUBLIC	??1?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QAE@XZ ; DataStructures::List<ReplicaManager::RegisteredReplica>::~List<ReplicaManager::RegisteredReplica>
PUBLIC	??A?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QBEAAURegisteredReplica@ReplicaManager@@I@Z ; DataStructures::List<ReplicaManager::RegisteredReplica>::operator[]
PUBLIC	?Insert@?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QAEXURegisteredReplica@ReplicaManager@@I@Z ; DataStructures::List<ReplicaManager::RegisteredReplica>::Insert
PUBLIC	?Insert@?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QAEXURegisteredReplica@ReplicaManager@@@Z ; DataStructures::List<ReplicaManager::RegisteredReplica>::Insert
PUBLIC	?RemoveAtIndex@?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QAEXI@Z ; DataStructures::List<ReplicaManager::RegisteredReplica>::RemoveAtIndex
PUBLIC	?Del@?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QAEXI@Z ; DataStructures::List<ReplicaManager::RegisteredReplica>::Del
PUBLIC	?Size@?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QBEIXZ ; DataStructures::List<ReplicaManager::RegisteredReplica>::Size
PUBLIC	?Clear@?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QAEX_N@Z ; DataStructures::List<ReplicaManager::RegisteredReplica>::Clear
PUBLIC	??0?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>
PUBLIC	??1?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::~OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>
PUBLIC	?GetIndexFromKey@?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QBEIABUPlayerID@@PA_N@Z ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::GetIndexFromKey
PUBLIC	?Insert@?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QAEIABUPlayerID@@ABQAUParticipantStruct@ReplicaManager@@@Z ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::Insert
PUBLIC	?Remove@?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QAEIABUPlayerID@@@Z ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::Remove
PUBLIC	??A?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QBEAAPAUParticipantStruct@ReplicaManager@@I@Z ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::operator[]
PUBLIC	?Clear@?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QAEXXZ ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::Clear
PUBLIC	?Size@?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::Size
PUBLIC	??0?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QAE@XZ ; DataStructures::List<ReplicaManager::ParticipantStruct *>::List<ReplicaManager::ParticipantStruct *>
PUBLIC	??1?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QAE@XZ ; DataStructures::List<ReplicaManager::ParticipantStruct *>::~List<ReplicaManager::ParticipantStruct *>
PUBLIC	??A?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QBEAAPAUParticipantStruct@ReplicaManager@@I@Z ; DataStructures::List<ReplicaManager::ParticipantStruct *>::operator[]
PUBLIC	?Insert@?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QAEXQAUParticipantStruct@ReplicaManager@@I@Z ; DataStructures::List<ReplicaManager::ParticipantStruct *>::Insert
PUBLIC	?Insert@?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QAEXQAUParticipantStruct@ReplicaManager@@@Z ; DataStructures::List<ReplicaManager::ParticipantStruct *>::Insert
PUBLIC	?RemoveAtIndex@?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QAEXI@Z ; DataStructures::List<ReplicaManager::ParticipantStruct *>::RemoveAtIndex
PUBLIC	?Del@?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QAEXI@Z ; DataStructures::List<ReplicaManager::ParticipantStruct *>::Del
PUBLIC	?Size@?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QBEIXZ ; DataStructures::List<ReplicaManager::ParticipantStruct *>::Size
PUBLIC	?Clear@?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QAEX_N@Z ; DataStructures::List<ReplicaManager::ParticipantStruct *>::Clear
PUBLIC	?GetParticipantByPlayerID@ReplicaManager@@IBEPAUParticipantStruct@1@UPlayerID@@@Z ; ReplicaManager::GetParticipantByPlayerID
PUBLIC	?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ	; RakNet::BitStream::GetNumberOfBitsUsed
PUBLIC	?GetWriteOffset@BitStream@RakNet@@QBEHXZ	; RakNet::BitStream::GetWriteOffset
PUBLIC	??_GBitStream@RakNet@@QAEPAXI@Z			; RakNet::BitStream::`scalar deleting destructor'
PUBLIC	??$Write@_N@BitStream@RakNet@@QAEX_N@Z		; RakNet::BitStream::Write<bool>
PUBLIC	??$Write@UPlayerID@@@BitStream@RakNet@@QAEXUPlayerID@@@Z ; RakNet::BitStream::Write<PlayerID>
PUBLIC	??$Write@I@BitStream@RakNet@@QAEXI@Z		; RakNet::BitStream::Write<unsigned int>
PUBLIC	??$Write@G@BitStream@RakNet@@QAEXG@Z		; RakNet::BitStream::Write<unsigned short>
PUBLIC	??$Write@UNetworkID@@@BitStream@RakNet@@QAEXUNetworkID@@@Z ; RakNet::BitStream::Write<NetworkID>
PUBLIC	??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z	; RakNet::BitStream::Read<bool>
PUBLIC	??$Read@UPlayerID@@@BitStream@RakNet@@QAE_NAAUPlayerID@@@Z ; RakNet::BitStream::Read<PlayerID>
PUBLIC	??$Read@I@BitStream@RakNet@@QAE_NAAI@Z		; RakNet::BitStream::Read<unsigned int>
PUBLIC	??$Read@G@BitStream@RakNet@@QAE_NAAG@Z		; RakNet::BitStream::Read<unsigned short>
PUBLIC	??$Read@UNetworkID@@@BitStream@RakNet@@QAE_NAAUNetworkID@@@Z ; RakNet::BitStream::Read<NetworkID>
PUBLIC	??$Write@E@BitStream@RakNet@@QAEXE@Z		; RakNet::BitStream::Write<unsigned char>
PUBLIC	??_7PluginInterface@@6B@			; PluginInterface::`vftable'
PUBLIC	??_7ReplicaManager@@6B@				; ReplicaManager::`vftable'
PUBLIC	?__LINE__Var@?1??AddParticipant@ReplicaManager@@QAEXUPlayerID@@@Z@4JA ; `ReplicaManager::AddParticipant'::`2'::__LINE__Var
PUBLIC	??_C@_1FG@CAHGPPEA@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAe?$AAp?$AAl?$AAi?$AAc?$AAa?$AAm@ ; `string'
PUBLIC	??_C@_1DO@FONFJDEJ@?$AAp?$AAl?$AAa?$AAy?$AAe?$AAr?$AAI?$AAd?$AA?$CB?$AA?$DN?$AAU?$AAN?$AAA?$AAS?$AAS?$AAI?$AAG?$AAN?$AAE?$AAD?$AA_?$AAP?$AAL?$AAA?$AAY?$AAE?$AAR?$AA_?$AAI?$AAD?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??RemoveParticipant@ReplicaManager@@QAEXUPlayerID@@@Z@4JA ; `ReplicaManager::RemoveParticipant'::`2'::__LINE__Var
PUBLIC	?__LINE__Var@?1??Construct@ReplicaManager@@QAEXPAVReplica@@_NUPlayerID@@1@Z@4JA ; `ReplicaManager::Construct'::`2'::__LINE__Var
PUBLIC	??_C@_1BA@GODDPAJM@?$AAr?$AAe?$AAp?$AAl?$AAi?$AAc?$AAa?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BM@DOEBGNAM@?$AAi?$AAs?$AAC?$AAo?$AAp?$AAy?$AA?$DN?$AA?$DN?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??Destruct@ReplicaManager@@QAEXPAVReplica@@UPlayerID@@_N@Z@4JA ; `ReplicaManager::Destruct'::`2'::__LINE__Var
PUBLIC	?__LINE__Var@?1??SetScope@ReplicaManager@@QAEXPAVReplica@@_NUPlayerID@@1@Z@4JA ; `ReplicaManager::SetScope'::`2'::__LINE__Var
PUBLIC	?__LINE__Var@?1??SignalSerializeNeeded@ReplicaManager@@QAEXPAVReplica@@UPlayerID@@_N@Z@4JA ; `ReplicaManager::SignalSerializeNeeded'::`2'::__LINE__Var
PUBLIC	?__LINE__Var@?1??Update@ReplicaManager@@MAEXPAVRakPeerInterface@@@Z@4JA ; `ReplicaManager::Update'::`2'::__LINE__Var
PUBLIC	??_C@_1BK@EBNJALNF@?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAE?$AAx?$AAi?$AAs?$AAt?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DI@HDKFLDGG@?$AAr?$AAe?$AAs?$AA?$DN?$AA?$DN?$AAR?$AAE?$AAP?$AAL?$AAI?$AAC?$AAA?$AA_?$AAC?$AAA?$AAN?$AAC?$AAE?$AAL?$AA_?$AAP?$AAR?$AAO?$AAC?$AAE?$AAS?$AAS?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EM@HMDKKPAI@?$AAs?$AAe?$AAn?$AAd?$AAD?$AAL?$AAC?$AAo?$AAm?$AAp?$AAl?$AAe?$AAt?$AAe?$AA?$DN?$AA?$DN?$AAR?$AAE?$AAP?$AAL?$AAI?$AAC?$AAA?$AA_?$AAP?$AAR?$AAO?$AAC?$AAE?$AAS?$AAS?$AA_@ ; `string'
PUBLIC	??_C@_1DG@DECCOGIG@?$AAr?$AAe?$AAs?$AA?$DN?$AA?$DN?$AAR?$AAE?$AAP?$AAL?$AAI?$AAC?$AAA?$AA_?$AAP?$AAR?$AAO?$AAC?$AAE?$AAS?$AAS?$AA_?$AAL?$AAA?$AAT?$AAE?$AAR?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??OnReceive@ReplicaManager@@MAE?AW4PluginReceiveResult@@PAVRakPeerInterface@@PAUPacket@@@Z@4JA ; `ReplicaManager::OnReceive'::`2'::__LINE__Var
PUBLIC	??_C@_13COJANIEC@?$AA0?$AA?$AA@			; `string'
PUBLIC	?__LINE__Var@?1??ProcessReceivedCommand@ReplicaManager@@IAE?AW4ReplicaReturnResult@@PAUParticipantStruct@2@PAUReceivedCommand@2@@Z@4JA ; `ReplicaManager::ProcessReceivedCommand'::`2'::__LINE__Var
PUBLIC	??_C@_1CA@HAOFBOHJ@?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AAi?$AAo?$AAn?$AAC?$AAB?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@ ; `string'
PUBLIC	??_C@_1BE@OMEGJCHO@?$AAn?$AAe?$AAw?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?$AA@ ; `string'
PUBLIC	??_C@_1GG@JDEIIJCO@?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN@ ; `string'
PUBLIC	??_C@_1FC@PKHPOOLI@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAo?$AAr?$AAd?$AAe?$AAr@ ; `string'
PUBLIC	??_C@_1CG@FNLJFNDG@?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAE?$AAx?$AAi?$AAs?$AAt?$AAs?$AA?$DN?$AA?$DN?$AAt?$AAr?$AAu?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@ ; `string'
PUBLIC	??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CM@FMCFHBCK@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BO@JBFMBKMD@?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$DO?$AA?$DN?$AAn?$AAu?$AAm?$AA?$AA@ ; `string'
PUBLIC	??_R4PluginInterface@@6B@			; PluginInterface::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVPluginInterface@@@8			; PluginInterface `RTTI Type Descriptor'
PUBLIC	??_R3PluginInterface@@8				; PluginInterface::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2PluginInterface@@8				; PluginInterface::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@PluginInterface@@8		; PluginInterface::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4ReplicaManager@@6B@			; ReplicaManager::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVReplicaManager@@@8			; ReplicaManager `RTTI Type Descriptor'
PUBLIC	??_R3ReplicaManager@@8				; ReplicaManager::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ReplicaManager@@8				; ReplicaManager::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ReplicaManager@@8			; ReplicaManager::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??8PlayerID@@QBE_NABU0@@Z:PROC			; PlayerID::operator==
EXTRN	??9PlayerID@@QBE_NABU0@@Z:PROC			; PlayerID::operator!=
EXTRN	??MPlayerID@@QBE_NABU0@@Z:PROC			; PlayerID::operator<
EXTRN	??4NetworkID@@QAEAAU0@ABU0@@Z:PROC		; NetworkID::operator=
EXTRN	?IsPeerToPeerMode@NetworkID@@SA_NXZ:PROC	; NetworkID::IsPeerToPeerMode
EXTRN	??8NetworkID@@QBE_NABU0@@Z:PROC			; NetworkID::operator==
EXTRN	??9NetworkID@@QBE_NABU0@@Z:PROC			; NetworkID::operator!=
EXTRN	__wassert:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	?OnAttach@PluginInterface@@UAEXPAVRakPeerInterface@@@Z:PROC ; PluginInterface::OnAttach
EXTRN	?OnDetach@PluginInterface@@UAEXPAVRakPeerInterface@@@Z:PROC ; PluginInterface::OnDetach
EXTRN	?OnInitialize@PluginInterface@@UAEXPAVRakPeerInterface@@@Z:PROC ; PluginInterface::OnInitialize
EXTRN	?Update@PluginInterface@@UAEXPAVRakPeerInterface@@@Z:PROC ; PluginInterface::Update
EXTRN	?OnReceive@PluginInterface@@UAE?AW4PluginReceiveResult@@PAVRakPeerInterface@@PAUPacket@@@Z:PROC ; PluginInterface::OnReceive
EXTRN	?OnDisconnect@PluginInterface@@UAEXPAVRakPeerInterface@@@Z:PROC ; PluginInterface::OnDisconnect
EXTRN	?OnCloseConnection@PluginInterface@@UAEXPAVRakPeerInterface@@UPlayerID@@@Z:PROC ; PluginInterface::OnCloseConnection
EXTRN	?OnDirectSocketSend@PluginInterface@@UAEXPBDIUPlayerID@@@Z:PROC ; PluginInterface::OnDirectSocketSend
EXTRN	?OnDirectSocketReceive@PluginInterface@@UAEXPBDIUPlayerID@@@Z:PROC ; PluginInterface::OnDirectSocketReceive
EXTRN	?OnInternalPacket@PluginInterface@@UAEXPAUInternalPacket@@IUPlayerID@@I_N@Z:PROC ; PluginInterface::OnInternalPacket
EXTRN	?GET_BASE_OBJECT_FROM_ID@NetworkIDGenerator@@SAPAXUNetworkID@@@Z:PROC ; NetworkIDGenerator::GET_BASE_OBJECT_FROM_ID
EXTRN	?GetTime@RakNet@@YAIXZ:PROC			; RakNet::GetTime
EXTRN	??0BitStream@RakNet@@QAE@XZ:PROC		; RakNet::BitStream::BitStream
EXTRN	??0BitStream@RakNet@@QAE@PAEI_N@Z:PROC		; RakNet::BitStream::BitStream
EXTRN	??1BitStream@RakNet@@QAE@XZ:PROC		; RakNet::BitStream::~BitStream
EXTRN	?Reset@BitStream@RakNet@@QAEXXZ:PROC		; RakNet::BitStream::Reset
EXTRN	?Write@BitStream@RakNet@@QAEXPAV12@H@Z:PROC	; RakNet::BitStream::Write
EXTRN	?IgnoreBits@BitStream@RakNet@@QAEXH@Z:PROC	; RakNet::BitStream::IgnoreBits
EXTRN	?SetWriteOffset@BitStream@RakNet@@QAEXH@Z:PROC	; RakNet::BitStream::SetWriteOffset
EXTRN	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z:PROC	; RakNet::BitStream::WriteBits
EXTRN	?ReadBits@BitStream@RakNet@@QAE_NPAEH_N@Z:PROC	; RakNet::BitStream::ReadBits
EXTRN	?Write0@BitStream@RakNet@@QAEXXZ:PROC		; RakNet::BitStream::Write0
EXTRN	?Write1@BitStream@RakNet@@QAEXXZ:PROC		; RakNet::BitStream::Write1
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_UninitUse:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_R1A@?0A@EA@ReplicaManager@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ReplicaManager@@8 DD FLAT:??_R0?AVReplicaManager@@@8 ; ReplicaManager::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ReplicaManager@@8
rdata$r	ENDS
;	COMDAT ??_R2ReplicaManager@@8
rdata$r	SEGMENT
??_R2ReplicaManager@@8 DD FLAT:??_R1A@?0A@EA@ReplicaManager@@8 ; ReplicaManager::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@PluginInterface@@8
rdata$r	ENDS
;	COMDAT ??_R3ReplicaManager@@8
rdata$r	SEGMENT
??_R3ReplicaManager@@8 DD 00H				; ReplicaManager::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ReplicaManager@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVReplicaManager@@@8
data$r	SEGMENT
??_R0?AVReplicaManager@@@8 DD FLAT:??_7type_info@@6B@	; ReplicaManager `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVReplicaManager@@', 00H
data$r	ENDS
;	COMDAT ??_R4ReplicaManager@@6B@
rdata$r	SEGMENT
??_R4ReplicaManager@@6B@ DD 00H				; ReplicaManager::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVReplicaManager@@@8
	DD	FLAT:??_R3ReplicaManager@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@PluginInterface@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@PluginInterface@@8 DD FLAT:??_R0?AVPluginInterface@@@8 ; PluginInterface::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3PluginInterface@@8
rdata$r	ENDS
;	COMDAT ??_R2PluginInterface@@8
rdata$r	SEGMENT
??_R2PluginInterface@@8 DD FLAT:??_R1A@?0A@EA@PluginInterface@@8 ; PluginInterface::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3PluginInterface@@8
rdata$r	SEGMENT
??_R3PluginInterface@@8 DD 00H				; PluginInterface::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2PluginInterface@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVPluginInterface@@@8
data$r	SEGMENT
??_R0?AVPluginInterface@@@8 DD FLAT:??_7type_info@@6B@	; PluginInterface `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVPluginInterface@@', 00H
data$r	ENDS
;	COMDAT ??_R4PluginInterface@@6B@
rdata$r	SEGMENT
??_R4PluginInterface@@6B@ DD 00H			; PluginInterface::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVPluginInterface@@@8
	DD	FLAT:??_R3PluginInterface@@8
rdata$r	ENDS
;	COMDAT ??_C@_1BO@JBFMBKMD@?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$DO?$AA?$DN?$AAn?$AAu?$AAm?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@JBFMBKMD@?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$DO?$AA?$DN?$AAn?$AAu?$AAm?$AA?$AA@ DB 'l'
	DB	00H, 'i', 00H, 's', 00H, 't', 00H, '_', 00H, 's', 00H, 'i', 00H
	DB	'z', 00H, 'e', 00H, '>', 00H, '=', 00H, 'n', 00H, 'u', 00H, 'm'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CM@FMCFHBCK@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@FMCFHBCK@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ DB 'p'
	DB	00H, 'o', 00H, 's', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'o', 00H
	DB	'n', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'l', 00H, 'i'
	DB	00H, 's', 00H, 't', 00H, '_', 00H, 's', 00H, 'i', 00H, 'z', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ DB 'p'
	DB	00H, 'o', 00H, 's', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'o', 00H
	DB	'n', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'l', 00H, 'i', 00H, 's'
	DB	00H, 't', 00H, '_', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
CONST	SEGMENT
??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@ DB 'z'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H
	DB	's', 00H, 'r', 00H, 'c', 00H, '\', 00H, '0', 00H, '2', 00H, 'x'
	DB	00H, 'u', 00H, '1', 00H, '\', 00H, 'r', 00H, 'a', 00H, 'k', 00H
	DB	'n', 00H, 'e', 00H, 't', 00H, '\', 00H, 'd', 00H, 's', 00H, '_'
	DB	00H, 'l', 00H, 'i', 00H, 's', 00H, 't', 00H, '.', 00H, 'h', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@FNLJFNDG@?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAE?$AAx?$AAi?$AAs?$AAt?$AAs?$AA?$DN?$AA?$DN?$AAt?$AAr?$AAu?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@FNLJFNDG@?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAE?$AAx?$AAi?$AAs?$AAt?$AAs?$AA?$DN?$AA?$DN?$AAt?$AAr?$AAu?$AAe?$AA?$AA@ DB 'o'
	DB	00H, 'b', 00H, 'j', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'E', 00H
	DB	'x', 00H, 'i', 00H, 's', 00H, 't', 00H, 's', 00H, '=', 00H, '='
	DB	00H, 't', 00H, 'r', 00H, 'u', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FC@PKHPOOLI@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAo?$AAr?$AAd?$AAe?$AAr@
CONST	SEGMENT
??_C@_1FC@PKHPOOLI@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAo?$AAr?$AAd?$AAe?$AAr@ DB 'z'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H
	DB	's', 00H, 'r', 00H, 'c', 00H, '\', 00H, '0', 00H, '2', 00H, 'x'
	DB	00H, 'u', 00H, '1', 00H, '\', 00H, 'r', 00H, 'a', 00H, 'k', 00H
	DB	'n', 00H, 'e', 00H, 't', 00H, '\', 00H, 'd', 00H, 's', 00H, '_'
	DB	00H, 'o', 00H, 'r', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 'e', 00H
	DB	'd', 00H, 'l', 00H, 'i', 00H, 's', 00H, 't', 00H, '.', 00H, 'h'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1GG@JDEIIJCO@?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN@
CONST	SEGMENT
??_C@_1GG@JDEIIJCO@?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN@ DB 'a'
	DB	00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H
	DB	'i', 00H, 'o', 00H, 'n', 00H, '_', 00H, 's', 00H, 'i', 00H, 'z'
	DB	00H, 'e', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e'
	DB	00H, '(', 00H, ')', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H
	DB	'0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'h', 00H, 'e'
	DB	00H, 'a', 00H, 'd', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H
	DB	't', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@OMEGJCHO@?$AAn?$AAe?$AAw?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@OMEGJCHO@?$AAn?$AAe?$AAw?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?$AA@ DB 'n'
	DB	00H, 'e', 00H, 'w', 00H, '_', 00H, 'a', 00H, 'r', 00H, 'r', 00H
	DB	'a', 00H, 'y', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@
CONST	SEGMENT
??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@ DB 'z'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H
	DB	's', 00H, 'r', 00H, 'c', 00H, '\', 00H, '0', 00H, '2', 00H, 'x'
	DB	00H, 'u', 00H, '1', 00H, '\', 00H, 'r', 00H, 'a', 00H, 'k', 00H
	DB	'n', 00H, 'e', 00H, 't', 00H, '\', 00H, 'd', 00H, 's', 00H, '_'
	DB	00H, 'q', 00H, 'u', 00H, 'e', 00H, 'u', 00H, 'e', 00H, '.', 00H
	DB	'h', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@HAOFBOHJ@?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AAi?$AAo?$AAn?$AAC?$AAB?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@HAOFBOHJ@?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AAi?$AAo?$AAn?$AAC?$AAB?$AA?$AA@ DB '_'
	DB	00H, 'c', 00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, 'r', 00H
	DB	'u', 00H, 'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 'C'
	DB	00H, 'B', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??ProcessReceivedCommand@ReplicaManager@@IAE?AW4ReplicaReturnResult@@PAUParticipantStruct@2@PAUReceivedCommand@2@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??ProcessReceivedCommand@ReplicaManager@@IAE?AW4ReplicaReturnResult@@PAUParticipantStruct@2@PAUReceivedCommand@2@@Z@4JA DD 0398H ; `ReplicaManager::ProcessReceivedCommand'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_13COJANIEC@?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_13COJANIEC@?$AA0?$AA?$AA@ DB '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??OnReceive@ReplicaManager@@MAE?AW4PluginReceiveResult@@PAVRakPeerInterface@@PAUPacket@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??OnReceive@ReplicaManager@@MAE?AW4PluginReceiveResult@@PAVRakPeerInterface@@PAUPacket@@@Z@4JA DD 0325H ; `ReplicaManager::OnReceive'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1DG@DECCOGIG@?$AAr?$AAe?$AAs?$AA?$DN?$AA?$DN?$AAR?$AAE?$AAP?$AAL?$AAI?$AAC?$AAA?$AA_?$AAP?$AAR?$AAO?$AAC?$AAE?$AAS?$AAS?$AA_?$AAL?$AAA?$AAT?$AAE?$AAR?$AA?$AA@
CONST	SEGMENT
??_C@_1DG@DECCOGIG@?$AAr?$AAe?$AAs?$AA?$DN?$AA?$DN?$AAR?$AAE?$AAP?$AAL?$AAI?$AAC?$AAA?$AA_?$AAP?$AAR?$AAO?$AAC?$AAE?$AAS?$AAS?$AA_?$AAL?$AAA?$AAT?$AAE?$AAR?$AA?$AA@ DB 'r'
	DB	00H, 'e', 00H, 's', 00H, '=', 00H, '=', 00H, 'R', 00H, 'E', 00H
	DB	'P', 00H, 'L', 00H, 'I', 00H, 'C', 00H, 'A', 00H, '_', 00H, 'P'
	DB	00H, 'R', 00H, 'O', 00H, 'C', 00H, 'E', 00H, 'S', 00H, 'S', 00H
	DB	'_', 00H, 'L', 00H, 'A', 00H, 'T', 00H, 'E', 00H, 'R', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1EM@HMDKKPAI@?$AAs?$AAe?$AAn?$AAd?$AAD?$AAL?$AAC?$AAo?$AAm?$AAp?$AAl?$AAe?$AAt?$AAe?$AA?$DN?$AA?$DN?$AAR?$AAE?$AAP?$AAL?$AAI?$AAC?$AAA?$AA_?$AAP?$AAR?$AAO?$AAC?$AAE?$AAS?$AAS?$AA_@
CONST	SEGMENT
??_C@_1EM@HMDKKPAI@?$AAs?$AAe?$AAn?$AAd?$AAD?$AAL?$AAC?$AAo?$AAm?$AAp?$AAl?$AAe?$AAt?$AAe?$AA?$DN?$AA?$DN?$AAR?$AAE?$AAP?$AAL?$AAI?$AAC?$AAA?$AA_?$AAP?$AAR?$AAO?$AAC?$AAE?$AAS?$AAS?$AA_@ DB 's'
	DB	00H, 'e', 00H, 'n', 00H, 'd', 00H, 'D', 00H, 'L', 00H, 'C', 00H
	DB	'o', 00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, 't', 00H, 'e'
	DB	00H, '=', 00H, '=', 00H, 'R', 00H, 'E', 00H, 'P', 00H, 'L', 00H
	DB	'I', 00H, 'C', 00H, 'A', 00H, '_', 00H, 'P', 00H, 'R', 00H, 'O'
	DB	00H, 'C', 00H, 'E', 00H, 'S', 00H, 'S', 00H, '_', 00H, 'L', 00H
	DB	'A', 00H, 'T', 00H, 'E', 00H, 'R', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DI@HDKFLDGG@?$AAr?$AAe?$AAs?$AA?$DN?$AA?$DN?$AAR?$AAE?$AAP?$AAL?$AAI?$AAC?$AAA?$AA_?$AAC?$AAA?$AAN?$AAC?$AAE?$AAL?$AA_?$AAP?$AAR?$AAO?$AAC?$AAE?$AAS?$AAS?$AA?$AA@
CONST	SEGMENT
??_C@_1DI@HDKFLDGG@?$AAr?$AAe?$AAs?$AA?$DN?$AA?$DN?$AAR?$AAE?$AAP?$AAL?$AAI?$AAC?$AAA?$AA_?$AAC?$AAA?$AAN?$AAC?$AAE?$AAL?$AA_?$AAP?$AAR?$AAO?$AAC?$AAE?$AAS?$AAS?$AA?$AA@ DB 'r'
	DB	00H, 'e', 00H, 's', 00H, '=', 00H, '=', 00H, 'R', 00H, 'E', 00H
	DB	'P', 00H, 'L', 00H, 'I', 00H, 'C', 00H, 'A', 00H, '_', 00H, 'C'
	DB	00H, 'A', 00H, 'N', 00H, 'C', 00H, 'E', 00H, 'L', 00H, '_', 00H
	DB	'P', 00H, 'R', 00H, 'O', 00H, 'C', 00H, 'E', 00H, 'S', 00H, 'S'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@EBNJALNF@?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAE?$AAx?$AAi?$AAs?$AAt?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@EBNJALNF@?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAE?$AAx?$AAi?$AAs?$AAt?$AAs?$AA?$AA@ DB 'o'
	DB	00H, 'b', 00H, 'j', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'E', 00H
	DB	'x', 00H, 'i', 00H, 's', 00H, 't', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??Update@ReplicaManager@@MAEXPAVRakPeerInterface@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??Update@ReplicaManager@@MAEXPAVRakPeerInterface@@@Z@4JA DD 01c1H ; `ReplicaManager::Update'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??SignalSerializeNeeded@ReplicaManager@@QAEXPAVReplica@@UPlayerID@@_N@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??SignalSerializeNeeded@ReplicaManager@@QAEXPAVReplica@@UPlayerID@@_N@Z@4JA DD 013aH ; `ReplicaManager::SignalSerializeNeeded'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??SetScope@ReplicaManager@@QAEXPAVReplica@@_NUPlayerID@@1@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??SetScope@ReplicaManager@@QAEXPAVReplica@@_NUPlayerID@@1@Z@4JA DD 0107H ; `ReplicaManager::SetScope'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??Destruct@ReplicaManager@@QAEXPAVReplica@@UPlayerID@@_N@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??Destruct@ReplicaManager@@QAEXPAVReplica@@UPlayerID@@_N@Z@4JA DD 0a4H ; `ReplicaManager::Destruct'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1BM@DOEBGNAM@?$AAi?$AAs?$AAC?$AAo?$AAp?$AAy?$AA?$DN?$AA?$DN?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@DOEBGNAM@?$AAi?$AAs?$AAC?$AAo?$AAp?$AAy?$AA?$DN?$AA?$DN?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@ DB 'i'
	DB	00H, 's', 00H, 'C', 00H, 'o', 00H, 'p', 00H, 'y', 00H, '=', 00H
	DB	'=', 00H, 'f', 00H, 'a', 00H, 'l', 00H, 's', 00H, 'e', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BA@GODDPAJM@?$AAr?$AAe?$AAp?$AAl?$AAi?$AAc?$AAa?$AA?$AA@
CONST	SEGMENT
??_C@_1BA@GODDPAJM@?$AAr?$AAe?$AAp?$AAl?$AAi?$AAc?$AAa?$AA?$AA@ DB 'r', 00H
	DB	'e', 00H, 'p', 00H, 'l', 00H, 'i', 00H, 'c', 00H, 'a', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??Construct@ReplicaManager@@QAEXPAVReplica@@_NUPlayerID@@1@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??Construct@ReplicaManager@@QAEXPAVReplica@@_NUPlayerID@@1@Z@4JA DD 078H ; `ReplicaManager::Construct'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??RemoveParticipant@ReplicaManager@@QAEXUPlayerID@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??RemoveParticipant@ReplicaManager@@QAEXUPlayerID@@@Z@4JA DD 068H ; `ReplicaManager::RemoveParticipant'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1DO@FONFJDEJ@?$AAp?$AAl?$AAa?$AAy?$AAe?$AAr?$AAI?$AAd?$AA?$CB?$AA?$DN?$AAU?$AAN?$AAA?$AAS?$AAS?$AAI?$AAG?$AAN?$AAE?$AAD?$AA_?$AAP?$AAL?$AAA?$AAY?$AAE?$AAR?$AA_?$AAI?$AAD?$AA?$AA@
CONST	SEGMENT
??_C@_1DO@FONFJDEJ@?$AAp?$AAl?$AAa?$AAy?$AAe?$AAr?$AAI?$AAd?$AA?$CB?$AA?$DN?$AAU?$AAN?$AAA?$AAS?$AAS?$AAI?$AAG?$AAN?$AAE?$AAD?$AA_?$AAP?$AAL?$AAA?$AAY?$AAE?$AAR?$AA_?$AAI?$AAD?$AA?$AA@ DB 'p'
	DB	00H, 'l', 00H, 'a', 00H, 'y', 00H, 'e', 00H, 'r', 00H, 'I', 00H
	DB	'd', 00H, '!', 00H, '=', 00H, 'U', 00H, 'N', 00H, 'A', 00H, 'S'
	DB	00H, 'S', 00H, 'I', 00H, 'G', 00H, 'N', 00H, 'E', 00H, 'D', 00H
	DB	'_', 00H, 'P', 00H, 'L', 00H, 'A', 00H, 'Y', 00H, 'E', 00H, 'R'
	DB	00H, '_', 00H, 'I', 00H, 'D', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1FG@CAHGPPEA@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAe?$AAp?$AAl?$AAi?$AAc?$AAa?$AAm@
CONST	SEGMENT
??_C@_1FG@CAHGPPEA@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAe?$AAp?$AAl?$AAi?$AAc?$AAa?$AAm@ DB 'z'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H
	DB	's', 00H, 'r', 00H, 'c', 00H, '\', 00H, '0', 00H, '2', 00H, 'x'
	DB	00H, 'u', 00H, '1', 00H, '\', 00H, 'r', 00H, 'a', 00H, 'k', 00H
	DB	'n', 00H, 'e', 00H, 't', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p'
	DB	00H, 'l', 00H, 'i', 00H, 'c', 00H, 'a', 00H, 'm', 00H, 'a', 00H
	DB	'n', 00H, 'a', 00H, 'g', 00H, 'e', 00H, 'r', 00H, '.', 00H, 'c'
	DB	00H, 'p', 00H, 'p', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??AddParticipant@ReplicaManager@@QAEXUPlayerID@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??AddParticipant@ReplicaManager@@QAEXUPlayerID@@@Z@4JA DD 047H ; `ReplicaManager::AddParticipant'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_7ReplicaManager@@6B@
CONST	SEGMENT
??_7ReplicaManager@@6B@ DD FLAT:??_R4ReplicaManager@@6B@ ; ReplicaManager::`vftable'
	DD	FLAT:?OnAttach@ReplicaManager@@MAEXPAVRakPeerInterface@@@Z
	DD	FLAT:?OnDetach@PluginInterface@@UAEXPAVRakPeerInterface@@@Z
	DD	FLAT:?OnInitialize@PluginInterface@@UAEXPAVRakPeerInterface@@@Z
	DD	FLAT:?Update@ReplicaManager@@MAEXPAVRakPeerInterface@@@Z
	DD	FLAT:?OnReceive@ReplicaManager@@MAE?AW4PluginReceiveResult@@PAVRakPeerInterface@@PAUPacket@@@Z
	DD	FLAT:?OnDisconnect@ReplicaManager@@MAEXPAVRakPeerInterface@@@Z
	DD	FLAT:?OnCloseConnection@ReplicaManager@@MAEXPAVRakPeerInterface@@UPlayerID@@@Z
	DD	FLAT:?OnDirectSocketSend@PluginInterface@@UAEXPBDIUPlayerID@@@Z
	DD	FLAT:?OnDirectSocketReceive@PluginInterface@@UAEXPBDIUPlayerID@@@Z
	DD	FLAT:?OnInternalPacket@PluginInterface@@UAEXPAUInternalPacket@@IUPlayerID@@I_N@Z
CONST	ENDS
;	COMDAT ??_7PluginInterface@@6B@
CONST	SEGMENT
??_7PluginInterface@@6B@ DD FLAT:??_R4PluginInterface@@6B@ ; PluginInterface::`vftable'
	DD	FLAT:?OnAttach@PluginInterface@@UAEXPAVRakPeerInterface@@@Z
	DD	FLAT:?OnDetach@PluginInterface@@UAEXPAVRakPeerInterface@@@Z
	DD	FLAT:?OnInitialize@PluginInterface@@UAEXPAVRakPeerInterface@@@Z
	DD	FLAT:?Update@PluginInterface@@UAEXPAVRakPeerInterface@@@Z
	DD	FLAT:?OnReceive@PluginInterface@@UAE?AW4PluginReceiveResult@@PAVRakPeerInterface@@PAUPacket@@@Z
	DD	FLAT:?OnDisconnect@PluginInterface@@UAEXPAVRakPeerInterface@@@Z
	DD	FLAT:?OnCloseConnection@PluginInterface@@UAEXPAVRakPeerInterface@@UPlayerID@@@Z
	DD	FLAT:?OnDirectSocketSend@PluginInterface@@UAEXPBDIUPlayerID@@@Z
	DD	FLAT:?OnDirectSocketReceive@PluginInterface@@UAEXPBDIUPlayerID@@@Z
	DD	FLAT:?OnInternalPacket@PluginInterface@@UAEXPAUInternalPacket@@IUPlayerID@@I_N@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QAE@XZ$0
__ehfuncinfo$??1?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ$0
__ehfuncinfo$??1?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?OnReceive@ReplicaManager@@MAE?AW4PluginReceiveResult@@PAVRakPeerInterface@@PAUPacket@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnReceive@ReplicaManager@@MAE?AW4PluginReceiveResult@@PAVRakPeerInterface@@PAUPacket@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?OnReceive@ReplicaManager@@MAE?AW4PluginReceiveResult@@PAVRakPeerInterface@@PAUPacket@@@Z$1
__ehfuncinfo$?OnReceive@ReplicaManager@@MAE?AW4PluginReceiveResult@@PAVRakPeerInterface@@PAUPacket@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?OnReceive@ReplicaManager@@MAE?AW4PluginReceiveResult@@PAVRakPeerInterface@@PAUPacket@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Update@ReplicaManager@@MAEXPAVRakPeerInterface@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Update@ReplicaManager@@MAEXPAVRakPeerInterface@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Update@ReplicaManager@@MAEXPAVRakPeerInterface@@@Z$1
__ehfuncinfo$?Update@ReplicaManager@@MAEXPAVRakPeerInterface@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Update@ReplicaManager@@MAEXPAVRakPeerInterface@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0ParticipantStruct@ReplicaManager@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ParticipantStruct@ReplicaManager@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0ParticipantStruct@ReplicaManager@@QAE@XZ$1
__ehfuncinfo$??0ParticipantStruct@ReplicaManager@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0ParticipantStruct@ReplicaManager@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ$0
__ehfuncinfo$??1?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ$0
__ehfuncinfo$??1?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1ParticipantStruct@ReplicaManager@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1ParticipantStruct@ReplicaManager@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1ParticipantStruct@ReplicaManager@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1ParticipantStruct@ReplicaManager@@QAE@XZ$2
__ehfuncinfo$??1ParticipantStruct@ReplicaManager@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1ParticipantStruct@ReplicaManager@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Destruct@ReplicaManager@@QAEXPAVReplica@@UPlayerID@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Destruct@ReplicaManager@@QAEXPAVReplica@@UPlayerID@@_N@Z$0
__ehfuncinfo$?Destruct@ReplicaManager@@QAEXPAVReplica@@UPlayerID@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Destruct@ReplicaManager@@QAEXPAVReplica@@UPlayerID@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?AddParticipant@ReplicaManager@@QAEXUPlayerID@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddParticipant@ReplicaManager@@QAEXUPlayerID@@@Z$0
__ehfuncinfo$?AddParticipant@ReplicaManager@@QAEXUPlayerID@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddParticipant@ReplicaManager@@QAEXUPlayerID@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1ReplicaManager@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1ReplicaManager@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1ReplicaManager@@QAE@XZ$1
__ehfuncinfo$??1ReplicaManager@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1ReplicaManager@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0ReplicaManager@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ReplicaManager@@QAE@XZ$0
__ehfuncinfo$??0ReplicaManager@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0ReplicaManager@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Write@E@BitStream@RakNet@@QAEXE@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 1
??$Write@E@BitStream@RakNet@@QAEXE@Z PROC		; RakNet::BitStream::Write<unsigned char>, COMDAT
; _this$ = ecx

; 729  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 730  : #ifdef _MSC_VER
; 731  : #pragma warning(disable:4127)   // conditional expression is constant
; 732  : #endif
; 733  : 		if (sizeof(var)==1)

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN2@Write

; 734  : 			WriteBits( ( unsigned char* ) & var, sizeof( templateType ) * 8, true );

	push	1
	push	8
	lea	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z ; RakNet::BitStream::WriteBits

; 735  : 		else

	jmp	SHORT $LN3@Write
$LN2@Write:

; 736  : 		{
; 737  : #ifndef __BITSTREAM_NATIVE_END
; 738  : 			if (DoEndianSwap())
; 739  : 			{
; 740  : 				unsigned char output[sizeof(templateType)];
; 741  : 				ReverseBytes((unsigned char*)&var, output, sizeof(templateType));
; 742  : 				WriteBits( ( unsigned char* ) output, sizeof(templateType) * 8, true );
; 743  : 			}
; 744  : 			else
; 745  : #endif
; 746  : 				WriteBits( ( unsigned char* ) & var, sizeof(templateType) * 8, true );

	push	1
	push	8
	lea	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z ; RakNet::BitStream::WriteBits
$LN3@Write:

; 747  : 		}
; 748  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$Write@E@BitStream@RakNet@@QAEXE@Z ENDP		; RakNet::BitStream::Write<unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Read@UNetworkID@@@BitStream@RakNet@@QAE_NAAUNetworkID@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 4
??$Read@UNetworkID@@@BitStream@RakNet@@QAE_NAAUNetworkID@@@Z PROC ; RakNet::BitStream::Read<NetworkID>, COMDAT
; _this$ = ecx

; 1044 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1045 : 		if (NetworkID::IsPeerToPeerMode()) // Use the function rather than directly access the member or DLL users will get an undefined external error

	call	?IsPeerToPeerMode@NetworkID@@SA_NXZ	; NetworkID::IsPeerToPeerMode
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@Read

; 1046 : 			Read(var.playerId);

	mov	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$Read@UPlayerID@@@BitStream@RakNet@@QAE_NAAUPlayerID@@@Z ; RakNet::BitStream::Read<PlayerID>
$LN1@Read:

; 1047 : 		return Read(var.localSystemId);

	mov	eax, DWORD PTR _var$[ebp]
	add	eax, 6
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$Read@G@BitStream@RakNet@@QAE_NAAG@Z	; RakNet::BitStream::Read<unsigned short>

; 1048 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$Read@UNetworkID@@@BitStream@RakNet@@QAE_NAAUNetworkID@@@Z ENDP ; RakNet::BitStream::Read<NetworkID>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Read@G@BitStream@RakNet@@QAE_NAAG@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 4
??$Read@G@BitStream@RakNet@@QAE_NAAG@Z PROC		; RakNet::BitStream::Read<unsigned short>, COMDAT
; _this$ = ecx

; 987  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 988  : #ifdef _MSC_VER
; 989  : #pragma warning(disable:4127)   // conditional expression is constant
; 990  : #endif
; 991  : 		if (sizeof(var)==1)

	xor	eax, eax
	je	SHORT $LN2@Read

; 992  : 			return ReadBits( ( unsigned char* ) &var, sizeof(templateType) * 8, true );

	push	1
	push	16					; 00000010H
	mov	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadBits@BitStream@RakNet@@QAE_NPAEH_N@Z ; RakNet::BitStream::ReadBits
	jmp	SHORT $LN3@Read

; 993  : 		else

	jmp	SHORT $LN3@Read
$LN2@Read:

; 994  : 		{
; 995  : #ifndef __BITSTREAM_NATIVE_END
; 996  : #ifdef _MSC_VER
; 997  : #pragma warning(disable:4244)   // '=' : conversion from 'unsigned long' to 'unsigned short', possible loss of data
; 998  : #endif
; 999  : 			if (DoEndianSwap())
; 1000 : 			{
; 1001 : 				unsigned char output[sizeof(templateType)];
; 1002 : 				if (ReadBits( ( unsigned char* ) output, sizeof(templateType) * 8, true ))
; 1003 : 				{
; 1004 : 					ReverseBytes(output, (unsigned char*)&var, sizeof(templateType));
; 1005 : 					return true;
; 1006 : 				}
; 1007 : 				return false;
; 1008 : 			}
; 1009 : 			else
; 1010 : #endif
; 1011 : 				return ReadBits( ( unsigned char* ) & var, sizeof(templateType) * 8, true );

	push	1
	push	16					; 00000010H
	mov	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadBits@BitStream@RakNet@@QAE_NPAEH_N@Z ; RakNet::BitStream::ReadBits
$LN3@Read:

; 1012 : 		}
; 1013 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$Read@G@BitStream@RakNet@@QAE_NAAG@Z ENDP		; RakNet::BitStream::Read<unsigned short>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Read@I@BitStream@RakNet@@QAE_NAAI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 4
??$Read@I@BitStream@RakNet@@QAE_NAAI@Z PROC		; RakNet::BitStream::Read<unsigned int>, COMDAT
; _this$ = ecx

; 987  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 988  : #ifdef _MSC_VER
; 989  : #pragma warning(disable:4127)   // conditional expression is constant
; 990  : #endif
; 991  : 		if (sizeof(var)==1)

	xor	eax, eax
	je	SHORT $LN2@Read

; 992  : 			return ReadBits( ( unsigned char* ) &var, sizeof(templateType) * 8, true );

	push	1
	push	32					; 00000020H
	mov	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadBits@BitStream@RakNet@@QAE_NPAEH_N@Z ; RakNet::BitStream::ReadBits
	jmp	SHORT $LN3@Read

; 993  : 		else

	jmp	SHORT $LN3@Read
$LN2@Read:

; 994  : 		{
; 995  : #ifndef __BITSTREAM_NATIVE_END
; 996  : #ifdef _MSC_VER
; 997  : #pragma warning(disable:4244)   // '=' : conversion from 'unsigned long' to 'unsigned short', possible loss of data
; 998  : #endif
; 999  : 			if (DoEndianSwap())
; 1000 : 			{
; 1001 : 				unsigned char output[sizeof(templateType)];
; 1002 : 				if (ReadBits( ( unsigned char* ) output, sizeof(templateType) * 8, true ))
; 1003 : 				{
; 1004 : 					ReverseBytes(output, (unsigned char*)&var, sizeof(templateType));
; 1005 : 					return true;
; 1006 : 				}
; 1007 : 				return false;
; 1008 : 			}
; 1009 : 			else
; 1010 : #endif
; 1011 : 				return ReadBits( ( unsigned char* ) & var, sizeof(templateType) * 8, true );

	push	1
	push	32					; 00000020H
	mov	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadBits@BitStream@RakNet@@QAE_NPAEH_N@Z ; RakNet::BitStream::ReadBits
$LN3@Read:

; 1012 : 		}
; 1013 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$Read@I@BitStream@RakNet@@QAE_NAAI@Z ENDP		; RakNet::BitStream::Read<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Read@UPlayerID@@@BitStream@RakNet@@QAE_NAAUPlayerID@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 4
??$Read@UPlayerID@@@BitStream@RakNet@@QAE_NAAUPlayerID@@@Z PROC ; RakNet::BitStream::Read<PlayerID>, COMDAT
; _this$ = ecx

; 1035 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1036 : 		Read(var.binaryAddress);

	mov	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$Read@I@BitStream@RakNet@@QAE_NAAI@Z	; RakNet::BitStream::Read<unsigned int>

; 1037 : 		return Read(var.port);

	mov	eax, DWORD PTR _var$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$Read@G@BitStream@RakNet@@QAE_NAAG@Z	; RakNet::BitStream::Read<unsigned short>

; 1038 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$Read@UPlayerID@@@BitStream@RakNet@@QAE_NAAUPlayerID@@@Z ENDP ; RakNet::BitStream::Read<PlayerID>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z
_TEXT	SEGMENT
tv82 = -208						; size = 4
_this$ = -8						; size = 4
_var$ = 8						; size = 4
??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z PROC		; RakNet::BitStream::Read<bool>, COMDAT
; _this$ = ecx

; 1019 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1020 : 		if ( readOffset + 1 > numberOfBitsUsed )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [edx]
	jle	SHORT $LN3@Read

; 1021 : 			return false;

	xor	al, al
	jmp	SHORT $LN4@Read
$LN3@Read:

; 1022 : 
; 1023 : 		if ( data[ readOffset >> 3 ] & ( 0x80 >> ( readOffset++ % 8 ) ) )   // Is it faster to just write it out here?

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sar	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	movzx	edx, BYTE PTR [eax+ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -2147483641			; 80000007H
	jns	SHORT $LN6@Read
	dec	ecx
	or	ecx, -8					; fffffff8H
	inc	ecx
$LN6@Read:
	mov	eax, 128				; 00000080H
	sar	eax, cl
	and	edx, eax
	mov	DWORD PTR tv82[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx
	cmp	DWORD PTR tv82[ebp], 0
	je	SHORT $LN2@Read

; 1024 : 			var = true;

	mov	eax, DWORD PTR _var$[ebp]
	mov	BYTE PTR [eax], 1

; 1025 : 		else

	jmp	SHORT $LN1@Read
$LN2@Read:

; 1026 : 			var = false;

	mov	eax, DWORD PTR _var$[ebp]
	mov	BYTE PTR [eax], 0
$LN1@Read:

; 1027 : 
; 1028 : 		return true;

	mov	al, 1
$LN4@Read:

; 1029 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z ENDP		; RakNet::BitStream::Read<bool>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Write@UNetworkID@@@BitStream@RakNet@@QAEXUNetworkID@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 8
??$Write@UNetworkID@@@BitStream@RakNet@@QAEXUNetworkID@@@Z PROC ; RakNet::BitStream::Write<NetworkID>, COMDAT
; _this$ = ecx

; 774  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 		if (NetworkID::IsPeerToPeerMode()) // Use the function rather than directly access the member or DLL users will get an undefined external error

	call	?IsPeerToPeerMode@NetworkID@@SA_NXZ	; NetworkID::IsPeerToPeerMode
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@Write

; 776  : 			Write(var.playerId);

	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _var$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _var$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$Write@UPlayerID@@@BitStream@RakNet@@QAEXUPlayerID@@@Z ; RakNet::BitStream::Write<PlayerID>
$LN1@Write:

; 777  : 		Write(var.localSystemId);

	movzx	eax, WORD PTR _var$[ebp+6]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$Write@G@BitStream@RakNet@@QAEXG@Z	; RakNet::BitStream::Write<unsigned short>

; 778  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$Write@UNetworkID@@@BitStream@RakNet@@QAEXUNetworkID@@@Z ENDP ; RakNet::BitStream::Write<NetworkID>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Write@G@BitStream@RakNet@@QAEXG@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 2
??$Write@G@BitStream@RakNet@@QAEXG@Z PROC		; RakNet::BitStream::Write<unsigned short>, COMDAT
; _this$ = ecx

; 729  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 730  : #ifdef _MSC_VER
; 731  : #pragma warning(disable:4127)   // conditional expression is constant
; 732  : #endif
; 733  : 		if (sizeof(var)==1)

	xor	eax, eax
	je	SHORT $LN2@Write

; 734  : 			WriteBits( ( unsigned char* ) & var, sizeof( templateType ) * 8, true );

	push	1
	push	16					; 00000010H
	lea	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z ; RakNet::BitStream::WriteBits

; 735  : 		else

	jmp	SHORT $LN3@Write
$LN2@Write:

; 736  : 		{
; 737  : #ifndef __BITSTREAM_NATIVE_END
; 738  : 			if (DoEndianSwap())
; 739  : 			{
; 740  : 				unsigned char output[sizeof(templateType)];
; 741  : 				ReverseBytes((unsigned char*)&var, output, sizeof(templateType));
; 742  : 				WriteBits( ( unsigned char* ) output, sizeof(templateType) * 8, true );
; 743  : 			}
; 744  : 			else
; 745  : #endif
; 746  : 				WriteBits( ( unsigned char* ) & var, sizeof(templateType) * 8, true );

	push	1
	push	16					; 00000010H
	lea	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z ; RakNet::BitStream::WriteBits
$LN3@Write:

; 747  : 		}
; 748  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$Write@G@BitStream@RakNet@@QAEXG@Z ENDP		; RakNet::BitStream::Write<unsigned short>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Write@I@BitStream@RakNet@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 4
??$Write@I@BitStream@RakNet@@QAEXI@Z PROC		; RakNet::BitStream::Write<unsigned int>, COMDAT
; _this$ = ecx

; 729  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 730  : #ifdef _MSC_VER
; 731  : #pragma warning(disable:4127)   // conditional expression is constant
; 732  : #endif
; 733  : 		if (sizeof(var)==1)

	xor	eax, eax
	je	SHORT $LN2@Write

; 734  : 			WriteBits( ( unsigned char* ) & var, sizeof( templateType ) * 8, true );

	push	1
	push	32					; 00000020H
	lea	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z ; RakNet::BitStream::WriteBits

; 735  : 		else

	jmp	SHORT $LN3@Write
$LN2@Write:

; 736  : 		{
; 737  : #ifndef __BITSTREAM_NATIVE_END
; 738  : 			if (DoEndianSwap())
; 739  : 			{
; 740  : 				unsigned char output[sizeof(templateType)];
; 741  : 				ReverseBytes((unsigned char*)&var, output, sizeof(templateType));
; 742  : 				WriteBits( ( unsigned char* ) output, sizeof(templateType) * 8, true );
; 743  : 			}
; 744  : 			else
; 745  : #endif
; 746  : 				WriteBits( ( unsigned char* ) & var, sizeof(templateType) * 8, true );

	push	1
	push	32					; 00000020H
	lea	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z ; RakNet::BitStream::WriteBits
$LN3@Write:

; 747  : 		}
; 748  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$Write@I@BitStream@RakNet@@QAEXI@Z ENDP		; RakNet::BitStream::Write<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Write@UPlayerID@@@BitStream@RakNet@@QAEXUPlayerID@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 6
??$Write@UPlayerID@@@BitStream@RakNet@@QAEXUPlayerID@@@Z PROC ; RakNet::BitStream::Write<PlayerID>, COMDAT
; _this$ = ecx

; 765  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 766  : 		Write(var.binaryAddress);

	mov	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$Write@I@BitStream@RakNet@@QAEXI@Z	; RakNet::BitStream::Write<unsigned int>

; 767  : 		Write(var.port);

	movzx	eax, WORD PTR _var$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$Write@G@BitStream@RakNet@@QAEXG@Z	; RakNet::BitStream::Write<unsigned short>

; 768  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$Write@UPlayerID@@@BitStream@RakNet@@QAEXUPlayerID@@@Z ENDP ; RakNet::BitStream::Write<PlayerID>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Write@_N@BitStream@RakNet@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 1
??$Write@_N@BitStream@RakNet@@QAEX_N@Z PROC		; RakNet::BitStream::Write<bool>, COMDAT
; _this$ = ecx

; 754  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 755  : 		if ( var )

	movzx	eax, BYTE PTR _var$[ebp]
	test	eax, eax
	je	SHORT $LN2@Write

; 756  : 			Write1();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Write1@BitStream@RakNet@@QAEXXZ	; RakNet::BitStream::Write1

; 757  : 		else

	jmp	SHORT $LN3@Write
$LN2@Write:

; 758  : 			Write0();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Write0@BitStream@RakNet@@QAEXXZ	; RakNet::BitStream::Write0
$LN3@Write:

; 759  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$Write@_N@BitStream@RakNet@@QAEX_N@Z ENDP		; RakNet::BitStream::Write<bool>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GBitStream@RakNet@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GBitStream@RakNet@@QAEPAXI@Z PROC			; RakNet::BitStream::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GBitStream@RakNet@@QAEPAXI@Z ENDP			; RakNet::BitStream::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ?GetWriteOffset@BitStream@RakNet@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetWriteOffset@BitStream@RakNet@@QBEHXZ PROC		; RakNet::BitStream::GetWriteOffset, COMDAT
; _this$ = ecx

; 370  : 		inline int GetWriteOffset( void ) const {return numberOfBitsUsed;}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWriteOffset@BitStream@RakNet@@QBEHXZ ENDP		; RakNet::BitStream::GetWriteOffset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ PROC	; RakNet::BitStream::GetNumberOfBitsUsed, COMDAT
; _this$ = ecx

; 369  : 		inline int GetNumberOfBitsUsed( void ) const {return GetWriteOffset();}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetWriteOffset@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetWriteOffset
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ ENDP	; RakNet::BitStream::GetNumberOfBitsUsed
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\replicamanager.cpp
;	COMDAT ?GetParticipantByPlayerID@ReplicaManager@@IBEPAUParticipantStruct@1@UPlayerID@@@Z
_TEXT	SEGMENT
_index$ = -32						; size = 4
_objectExists$ = -17					; size = 1
_this$ = -8						; size = 4
_playerId$ = 8						; size = 6
?GetParticipantByPlayerID@ReplicaManager@@IBEPAUParticipantStruct@1@UPlayerID@@@Z PROC ; ReplicaManager::GetParticipantByPlayerID, COMDAT
; _this$ = ecx

; 907  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 	bool objectExists;
; 909  : 	unsigned index;
; 910  : 	index = participantList.GetIndexFromKey(playerId, &objectExists);

	lea	eax, DWORD PTR _objectExists$[ebp]
	push	eax
	lea	ecx, DWORD PTR _playerId$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?GetIndexFromKey@?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QBEIABUPlayerID@@PA_N@Z ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::GetIndexFromKey
	mov	DWORD PTR _index$[ebp], eax

; 911  : 	if (objectExists==false)

	movzx	eax, BYTE PTR _objectExists$[ebp]
	test	eax, eax
	jne	SHORT $LN1@GetPartici

; 912  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN2@GetPartici
$LN1@GetPartici:

; 913  : 	return participantList[index];

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??A?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QBEAAPAUParticipantStruct@ReplicaManager@@I@Z ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::operator[]
	mov	eax, DWORD PTR [eax]
$LN2@GetPartici:

; 914  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetPartici
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN6@GetPartici:
	DD	1
	DD	$LN5@GetPartici
$LN5@GetPartici:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@GetPartici
$LN4@GetPartici:
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
?GetParticipantByPlayerID@ReplicaManager@@IBEPAUParticipantStruct@1@UPlayerID@@@Z ENDP ; ReplicaManager::GetParticipantByPlayerID
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Clear@?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QAEX_N@Z
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
_doNotDeallocate$ = 8					; size = 1
?Clear@?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QAEX_N@Z PROC ; DataStructures::List<ReplicaManager::ParticipantStruct *>::Clear, COMDAT
; _this$ = ecx

; 379  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  : 		if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Clear

; 381  : 			return;

	jmp	SHORT $LN3@Clear
$LN2@Clear:

; 382  : 
; 383  : 		if (allocation_size>512 && doNotDeallocate==false)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 512			; 00000200H
	jbe	SHORT $LN1@Clear
	movzx	eax, BYTE PTR _doNotDeallocate$[ebp]
	test	eax, eax
	jne	SHORT $LN1@Clear

; 384  : 		{
; 385  : 			delete [] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 386  : 			allocation_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 387  : 			listArray = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN1@Clear:

; 388  : 		}
; 389  : 		list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
$LN3@Clear:

; 390  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Clear@?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QAEX_N@Z ENDP ; DataStructures::List<ReplicaManager::ParticipantStruct *>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Size@?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QBEIXZ PROC ; DataStructures::List<ReplicaManager::ParticipantStruct *>::Size, COMDAT
; _this$ = ecx

; 373  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 374  : 		return list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 375  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QBEIXZ ENDP ; DataStructures::List<ReplicaManager::ParticipantStruct *>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Del@?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_num$ = 8						; size = 4
?Del@?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QAEXI@Z PROC ; DataStructures::List<ReplicaManager::ParticipantStruct *>::Del, COMDAT
; _this$ = ecx

; 353  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 354  : 		// Delete the last elements on the list.  No compression needed
; 355  : #ifdef _DEBUG
; 356  : 		assert(list_size>=num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _num$[ebp]
	jae	SHORT $LN3@Del
	push	356					; 00000164H
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1BO@JBFMBKMD@?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$DO?$AA?$DN?$AAn?$AAu?$AAm?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@Del:

; 357  : #endif
; 358  : 		list_size-=num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _num$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 359  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Del@?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QAEXI@Z ENDP ; DataStructures::List<ReplicaManager::ParticipantStruct *>::Del
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?RemoveAtIndex@?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
?RemoveAtIndex@?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QAEXI@Z PROC ; DataStructures::List<ReplicaManager::ParticipantStruct *>::RemoveAtIndex, COMDAT
; _this$ = ecx

; 333  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 334  : #ifdef _DEBUG
; 335  : 		assert( position < list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN4@RemoveAtIn
	push	335					; 0000014fH
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@RemoveAtIn:

; 336  : #endif
; 337  : 
; 338  : 		if ( position < list_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN2@RemoveAtIn

; 339  : 		{
; 340  : 			// Compress the array
; 341  : 			/*
; 342  : 			for ( unsigned int counter = position; counter < list_size - 1 ; ++counter )
; 343  : 			listArray[ counter ] = listArray[ counter + 1 ];
; 344  : 			*/
; 345  : 			memmove(listArray+position, listArray+position+1, (list_size-1-position) * sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	sub	ecx, DWORD PTR _position$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _position$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _position$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 346  : 
; 347  : 			Del();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Del@?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QAEXI@Z ; DataStructures::List<ReplicaManager::ParticipantStruct *>::Del
$LN2@RemoveAtIn:

; 348  : 		}
; 349  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveAtIndex@?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QAEXI@Z ENDP ; DataStructures::List<ReplicaManager::ParticipantStruct *>::RemoveAtIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Insert@?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QAEXQAUParticipantStruct@ReplicaManager@@@Z
_TEXT	SEGMENT
$T1 = -236						; size = 4
$T2 = -224						; size = 4
_new_array$3 = -20					; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
?Insert@?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QAEXQAUParticipantStruct@ReplicaManager@@@Z PROC ; DataStructures::List<ReplicaManager::ParticipantStruct *>::Insert, COMDAT
; _this$ = ecx

; 242  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 243  : 		// Reallocate list if necessary
; 244  : 
; 245  : 		if ( list_size == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	$LN3@Insert

; 246  : 		{
; 247  : 			// allocate twice the currently allocated memory
; 248  : 			list_type * new_array;
; 249  : 
; 250  : 			if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Insert

; 251  : 				allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 16			; 00000010H

; 252  : 			else

	jmp	SHORT $LN1@Insert
$LN2@Insert:

; 253  : 				allocation_size *= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN1@Insert:

; 254  : 
; 255  : 			new_array = new list_type [ allocation_size ];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _new_array$3[ebp], eax

; 256  : 
; 257  : 			// copy old array over
; 258  : 			//	for ( unsigned int counter = 0; counter < list_size; ++counter )
; 259  : 			//		new_array[ counter ] = listArray[ counter ];
; 260  : 
; 261  : 			// Don't call constructors, assignment operators, etc.
; 262  : 			memcpy(new_array, listArray, list_size*sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _new_array$3[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 263  : 
; 264  : 			// set old array to point to the newly allocated and twice as large array
; 265  : 			delete[] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 266  : 
; 267  : 			listArray = new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$3[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Insert:

; 268  : 		}
; 269  : 
; 270  : 		// Insert the new item at the correct spot
; 271  : 		listArray[ list_size ] = input;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _input$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 272  : 
; 273  : 		++list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 274  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Insert@?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QAEXQAUParticipantStruct@ReplicaManager@@@Z ENDP ; DataStructures::List<ReplicaManager::ParticipantStruct *>::Insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Insert@?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QAEXQAUParticipantStruct@ReplicaManager@@I@Z
_TEXT	SEGMENT
$T1 = -236						; size = 4
$T2 = -224						; size = 4
_new_array$3 = -20					; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
_position$ = 12						; size = 4
?Insert@?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QAEXQAUParticipantStruct@ReplicaManager@@I@Z PROC ; DataStructures::List<ReplicaManager::ParticipantStruct *>::Insert, COMDAT
; _this$ = ecx

; 194  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 195  : #ifdef _DEBUG
; 196  : 		assert( position <= list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jbe	SHORT $LN6@Insert
	push	196					; 000000c4H
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CM@FMCFHBCK@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN6@Insert:

; 197  : #endif
; 198  : 
; 199  : 		// Reallocate list if necessary
; 200  : 		if ( list_size == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	$LN3@Insert

; 201  : 		{
; 202  : 			// allocate twice the currently allocated memory
; 203  : 			list_type * new_array;
; 204  : 
; 205  : 			if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Insert

; 206  : 				allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 16			; 00000010H

; 207  : 			else

	jmp	SHORT $LN1@Insert
$LN2@Insert:

; 208  : 				allocation_size *= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN1@Insert:

; 209  : 
; 210  : 			new_array = new list_type [ allocation_size ];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _new_array$3[ebp], eax

; 211  : 
; 212  : 			// copy old array over
; 213  : 			//for ( unsigned int counter = 0; counter < list_size; ++counter )
; 214  : 			//	new_array[ counter ] = listArray[ counter ];
; 215  : 
; 216  : 			// Don't call constructors, assignment operators, etc.
; 217  : 			memcpy(new_array, listArray, list_size*sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _new_array$3[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 218  : 
; 219  : 			// set old array to point to the newly allocated and twice as large array
; 220  : 			delete[] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 221  : 
; 222  : 			listArray = new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$3[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Insert:

; 223  : 		}
; 224  : 
; 225  : 		// Move the elements in the list to make room
; 226  : 		//for ( unsigned int counter = list_size; counter != position; counter-- )
; 227  : 		//	listArray[ counter ] = listArray[ counter - 1 ];
; 228  : 
; 229  : 		// Don't call constructors, assignment operators, etc.
; 230  : 		memmove(listArray+position+1, listArray+position, (list_size-position)*sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _position$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _position$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _position$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4+4]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 231  : 
; 232  : 		// Insert the new item at the correct spot
; 233  : 		listArray[ position ] = input;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _position$[ebp]
	mov	eax, DWORD PTR _input$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 234  : 
; 235  : 		++list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 236  : 
; 237  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?Insert@?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QAEXQAUParticipantStruct@ReplicaManager@@I@Z ENDP ; DataStructures::List<ReplicaManager::ParticipantStruct *>::Insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??A?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QBEAAPAUParticipantStruct@ReplicaManager@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
??A?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QBEAAPAUParticipantStruct@ReplicaManager@@I@Z PROC ; DataStructures::List<ReplicaManager::ParticipantStruct *>::operator[], COMDAT
; _this$ = ecx

; 185  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 186  : #ifdef _DEBUG
; 187  : 		assert ( position < list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN3@operator
	push	187					; 000000bbH
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@operator:

; 188  : #endif
; 189  : 		return listArray[ position ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _position$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 190  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QBEAAPAUParticipantStruct@ReplicaManager@@I@Z ENDP ; DataStructures::List<ReplicaManager::ParticipantStruct *>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??1?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
??1?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QAE@XZ PROC ; DataStructures::List<ReplicaManager::ParticipantStruct *>::~List<ReplicaManager::ParticipantStruct *>, COMDAT
; _this$ = ecx

; 121  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 122  : 		if (allocation_size>0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jbe	SHORT $LN2@List

; 123  : 			delete [] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@List:

; 124  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QAE@XZ ENDP ; DataStructures::List<ReplicaManager::ParticipantStruct *>::~List<ReplicaManager::ParticipantStruct *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??0?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QAE@XZ PROC ; DataStructures::List<ReplicaManager::ParticipantStruct *>::List<ReplicaManager::ParticipantStruct *>, COMDAT
; _this$ = ecx

; 113  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 114  : 		allocation_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 115  : 		listArray = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 116  : 		list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 117  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QAE@XZ ENDP ; DataStructures::List<ReplicaManager::ParticipantStruct *>::List<ReplicaManager::ParticipantStruct *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?Size@?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QBEIXZ PROC ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::Size, COMDAT
; _this$ = ecx

; 231  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 232  : 		return orderedList.Size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QBEIXZ ; DataStructures::List<ReplicaManager::ParticipantStruct *>::Size

; 233  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QBEIXZ ENDP ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?Clear@?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Clear@?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QAEXXZ PROC ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::Clear, COMDAT
; _this$ = ecx

; 219  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 220  : 		orderedList.Clear();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QAEX_N@Z ; DataStructures::List<ReplicaManager::ParticipantStruct *>::Clear

; 221  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QAEXXZ ENDP ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ??A?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QBEAAPAUParticipantStruct@ReplicaManager@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
??A?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QBEAAPAUParticipantStruct@ReplicaManager@@I@Z PROC ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::operator[], COMDAT
; _this$ = ecx

; 225  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 226  : 		return orderedList[position];

	mov	eax, DWORD PTR _position$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QBEAAPAUParticipantStruct@ReplicaManager@@I@Z ; DataStructures::List<ReplicaManager::ParticipantStruct *>::operator[]

; 227  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QBEAAPAUParticipantStruct@ReplicaManager@@I@Z ENDP ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?Remove@?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QAEIABUPlayerID@@@Z
_TEXT	SEGMENT
_index$ = -32						; size = 4
_objectExists$ = -17					; size = 1
_this$ = -8						; size = 4
_key$ = 8						; size = 4
?Remove@?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QAEIABUPlayerID@@@Z PROC ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::Remove, COMDAT
; _this$ = ecx

; 179  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 180  : 		bool objectExists;
; 181  : 		unsigned index;
; 182  : 		index = GetIndexFromKey(key, &objectExists);

	lea	eax, DWORD PTR _objectExists$[ebp]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexFromKey@?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QBEIABUPlayerID@@PA_N@Z ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::GetIndexFromKey
	mov	DWORD PTR _index$[ebp], eax

; 183  : 
; 184  : 		// Can't find the element to remove if this assert hits
; 185  : 		assert(objectExists==true);

	movzx	eax, BYTE PTR _objectExists$[ebp]
	cmp	eax, 1
	je	SHORT $LN4@Remove
	push	185					; 000000b9H
	push	OFFSET ??_C@_1FC@PKHPOOLI@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAo?$AAr?$AAd?$AAe?$AAr@
	push	OFFSET ??_C@_1CG@FNLJFNDG@?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAE?$AAx?$AAi?$AAs?$AAt?$AAs?$AA?$DN?$AA?$DN?$AAt?$AAr?$AAu?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@Remove:

; 186  : 		if (objectExists==false)

	movzx	eax, BYTE PTR _objectExists$[ebp]
	test	eax, eax
	jne	SHORT $LN1@Remove

; 187  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN2@Remove
$LN1@Remove:

; 188  : 
; 189  : 		orderedList.RemoveAtIndex(index);

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAtIndex@?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QAEXI@Z ; DataStructures::List<ReplicaManager::ParticipantStruct *>::RemoveAtIndex

; 190  : 		return index;

	mov	eax, DWORD PTR _index$[ebp]
$LN2@Remove:

; 191  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@Remove
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$LN7@Remove:
	DD	1
	DD	$LN6@Remove
$LN6@Remove:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN5@Remove
$LN5@Remove:
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
?Remove@?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QAEIABUPlayerID@@@Z ENDP ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::Remove
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?Insert@?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QAEIABUPlayerID@@ABQAUParticipantStruct@ReplicaManager@@@Z
_TEXT	SEGMENT
_index$ = -32						; size = 4
_objectExists$ = -17					; size = 1
_this$ = -8						; size = 4
_key$ = 8						; size = 4
_data$ = 12						; size = 4
?Insert@?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QAEIABUPlayerID@@ABQAUParticipantStruct@ReplicaManager@@@Z PROC ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::Insert, COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		bool objectExists;
; 158  : 		unsigned index;
; 159  : 		index = GetIndexFromKey(key, &objectExists);

	lea	eax, DWORD PTR _objectExists$[ebp]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexFromKey@?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QBEIABUPlayerID@@PA_N@Z ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::GetIndexFromKey
	mov	DWORD PTR _index$[ebp], eax

; 160  : 
; 161  : 		// Don't allow duplicate insertion.
; 162  : 		if (objectExists)

	movzx	eax, BYTE PTR _objectExists$[ebp]
	test	eax, eax
	je	SHORT $LN3@Insert

; 163  : 			return (unsigned)-1;

	or	eax, -1
	jmp	SHORT $LN4@Insert
$LN3@Insert:

; 164  : 
; 165  : 		if (index>=orderedList.Size())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QBEIXZ ; DataStructures::List<ReplicaManager::ParticipantStruct *>::Size
	cmp	DWORD PTR _index$[ebp], eax
	jb	SHORT $LN2@Insert

; 166  : 		{
; 167  : 			orderedList.Insert(data);

	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Insert@?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QAEXQAUParticipantStruct@ReplicaManager@@@Z ; DataStructures::List<ReplicaManager::ParticipantStruct *>::Insert

; 168  : 			return orderedList.Size()-1;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QBEIXZ ; DataStructures::List<ReplicaManager::ParticipantStruct *>::Size
	sub	eax, 1
	jmp	SHORT $LN4@Insert

; 169  : 		}
; 170  : 		else

	jmp	SHORT $LN4@Insert
$LN2@Insert:

; 171  : 		{
; 172  : 			orderedList.Insert(data,index);

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Insert@?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QAEXQAUParticipantStruct@ReplicaManager@@I@Z ; DataStructures::List<ReplicaManager::ParticipantStruct *>::Insert

; 173  : 			return index;

	mov	eax, DWORD PTR _index$[ebp]
$LN4@Insert:

; 174  : 		}		
; 175  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@Insert
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN8@Insert:
	DD	1
	DD	$LN7@Insert
$LN7@Insert:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN6@Insert
$LN6@Insert:
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
?Insert@?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QAEIABUPlayerID@@ABQAUParticipantStruct@ReplicaManager@@@Z ENDP ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::Insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?GetIndexFromKey@?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QBEIABUPlayerID@@PA_N@Z
_TEXT	SEGMENT
_res$ = -56						; size = 4
_lowerBound$ = -44					; size = 4
_upperBound$ = -32					; size = 4
_index$ = -20						; size = 4
_this$ = -8						; size = 4
_key$ = 8						; size = 4
_objectExists$ = 12					; size = 4
?GetIndexFromKey@?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QBEIABUPlayerID@@PA_N@Z PROC ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::GetIndexFromKey, COMDAT
; _this$ = ecx

; 110  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 111  : 		int index, upperBound, lowerBound;
; 112  : 		int res;
; 113  : 
; 114  : 		if (orderedList.Size()==0)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QBEIXZ ; DataStructures::List<ReplicaManager::ParticipantStruct *>::Size
	test	eax, eax
	jne	SHORT $LN8@GetIndexFr

; 115  : 		{
; 116  : 			*objectExists=false;

	mov	eax, DWORD PTR _objectExists$[ebp]
	mov	BYTE PTR [eax], 0

; 117  : 			return 0;

	xor	eax, eax
	jmp	$LN9@GetIndexFr
$LN8@GetIndexFr:

; 118  : 		}
; 119  : 
; 120  : 		upperBound=(int)orderedList.Size()-1;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QBEIXZ ; DataStructures::List<ReplicaManager::ParticipantStruct *>::Size
	sub	eax, 1
	mov	DWORD PTR _upperBound$[ebp], eax

; 121  : 		lowerBound=0;

	mov	DWORD PTR _lowerBound$[ebp], 0

; 122  : 		index = (int)orderedList.Size()/2;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QBEIXZ ; DataStructures::List<ReplicaManager::ParticipantStruct *>::Size
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _index$[ebp], eax
$LN7@GetIndexFr:

; 123  : 
; 124  : #ifdef _MSC_VER
; 125  : 	#pragma warning( disable : 4127 ) // warning C4127: conditional expression is constant
; 126  : #endif
; 127  : 		while (1)

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN9@GetIndexFr

; 128  : 		{
; 129  : 			res = comparison_function(key,orderedList[index]);

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QBEAAPAUParticipantStruct@ReplicaManager@@I@Z ; DataStructures::List<ReplicaManager::ParticipantStruct *>::operator[]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	call	?ParticipantStructComp@ReplicaManager@@SAHABUPlayerID@@ABQAUParticipantStruct@1@@Z ; ReplicaManager::ParticipantStructComp
	add	esp, 8
	mov	DWORD PTR _res$[ebp], eax

; 130  : 			if (res==0)

	cmp	DWORD PTR _res$[ebp], 0
	jne	SHORT $LN5@GetIndexFr

; 131  : 			{
; 132  : 				*objectExists=true;

	mov	eax, DWORD PTR _objectExists$[ebp]
	mov	BYTE PTR [eax], 1

; 133  : 				return index;

	mov	eax, DWORD PTR _index$[ebp]
	jmp	SHORT $LN9@GetIndexFr
	jmp	SHORT $LN4@GetIndexFr
$LN5@GetIndexFr:

; 134  : 			}
; 135  : 			else if (res<0)

	cmp	DWORD PTR _res$[ebp], 0
	jge	SHORT $LN3@GetIndexFr

; 136  : 			{
; 137  : 				upperBound=index-1;

	mov	eax, DWORD PTR _index$[ebp]
	sub	eax, 1
	mov	DWORD PTR _upperBound$[ebp], eax

; 138  : 			}
; 139  : 			else// if (res>0)

	jmp	SHORT $LN4@GetIndexFr
$LN3@GetIndexFr:

; 140  : 			{
; 141  : 				lowerBound=index+1;

	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 1
	mov	DWORD PTR _lowerBound$[ebp], eax
$LN4@GetIndexFr:

; 142  : 			}
; 143  : 
; 144  : 			index=lowerBound+(upperBound-lowerBound)/2;

	mov	eax, DWORD PTR _upperBound$[ebp]
	sub	eax, DWORD PTR _lowerBound$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _lowerBound$[ebp]
	mov	DWORD PTR _index$[ebp], eax

; 145  : 
; 146  : 			if (lowerBound>upperBound)

	mov	eax, DWORD PTR _lowerBound$[ebp]
	cmp	eax, DWORD PTR _upperBound$[ebp]
	jle	SHORT $LN1@GetIndexFr

; 147  : 			{
; 148  : 				*objectExists=false;

	mov	eax, DWORD PTR _objectExists$[ebp]
	mov	BYTE PTR [eax], 0

; 149  : 				return lowerBound; // No match

	mov	eax, DWORD PTR _lowerBound$[ebp]
	jmp	SHORT $LN9@GetIndexFr
$LN1@GetIndexFr:

; 150  : 			}
; 151  : 		}

	jmp	SHORT $LN7@GetIndexFr
$LN9@GetIndexFr:

; 152  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?GetIndexFromKey@?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QBEIABUPlayerID@@PA_N@Z ENDP ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::GetIndexFromKey
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ??1?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QAE@XZ PROC ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::~OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>, COMDAT
; _this$ = ecx

; 72   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 73   : 		Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QAEXXZ ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::Clear

; 74   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QAE@XZ ; DataStructures::List<ReplicaManager::ParticipantStruct *>::~List<ReplicaManager::ParticipantStruct *>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QAE@XZ ; DataStructures::List<ReplicaManager::ParticipantStruct *>::~List<ReplicaManager::ParticipantStruct *>
__ehhandler$??1?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QAE@XZ ENDP ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::~OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ??0?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QAE@XZ PROC ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>, COMDAT
; _this$ = ecx

; 67   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$List@PAUParticipantStruct@ReplicaManager@@@DataStructures@@QAE@XZ ; DataStructures::List<ReplicaManager::ParticipantStruct *>::List<ReplicaManager::ParticipantStruct *>

; 68   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QAE@XZ ENDP ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Clear@?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QAEX_N@Z
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
_doNotDeallocate$ = 8					; size = 1
?Clear@?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QAEX_N@Z PROC ; DataStructures::List<ReplicaManager::RegisteredReplica>::Clear, COMDAT
; _this$ = ecx

; 379  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  : 		if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Clear

; 381  : 			return;

	jmp	SHORT $LN3@Clear
$LN2@Clear:

; 382  : 
; 383  : 		if (allocation_size>512 && doNotDeallocate==false)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 512			; 00000200H
	jbe	SHORT $LN1@Clear
	movzx	eax, BYTE PTR _doNotDeallocate$[ebp]
	test	eax, eax
	jne	SHORT $LN1@Clear

; 384  : 		{
; 385  : 			delete [] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 386  : 			allocation_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 387  : 			listArray = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN1@Clear:

; 388  : 		}
; 389  : 		list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
$LN3@Clear:

; 390  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Clear@?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QAEX_N@Z ENDP ; DataStructures::List<ReplicaManager::RegisteredReplica>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Size@?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QBEIXZ PROC ; DataStructures::List<ReplicaManager::RegisteredReplica>::Size, COMDAT
; _this$ = ecx

; 373  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 374  : 		return list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 375  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QBEIXZ ENDP ; DataStructures::List<ReplicaManager::RegisteredReplica>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Del@?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_num$ = 8						; size = 4
?Del@?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QAEXI@Z PROC ; DataStructures::List<ReplicaManager::RegisteredReplica>::Del, COMDAT
; _this$ = ecx

; 353  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 354  : 		// Delete the last elements on the list.  No compression needed
; 355  : #ifdef _DEBUG
; 356  : 		assert(list_size>=num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _num$[ebp]
	jae	SHORT $LN3@Del
	push	356					; 00000164H
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1BO@JBFMBKMD@?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$DO?$AA?$DN?$AAn?$AAu?$AAm?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@Del:

; 357  : #endif
; 358  : 		list_size-=num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _num$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 359  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Del@?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QAEXI@Z ENDP ; DataStructures::List<ReplicaManager::RegisteredReplica>::Del
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?RemoveAtIndex@?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
?RemoveAtIndex@?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QAEXI@Z PROC ; DataStructures::List<ReplicaManager::RegisteredReplica>::RemoveAtIndex, COMDAT
; _this$ = ecx

; 333  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 334  : #ifdef _DEBUG
; 335  : 		assert( position < list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN4@RemoveAtIn
	push	335					; 0000014fH
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@RemoveAtIn:

; 336  : #endif
; 337  : 
; 338  : 		if ( position < list_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN2@RemoveAtIn

; 339  : 		{
; 340  : 			// Compress the array
; 341  : 			/*
; 342  : 			for ( unsigned int counter = position; counter < list_size - 1 ; ++counter )
; 343  : 			listArray[ counter ] = listArray[ counter + 1 ];
; 344  : 			*/
; 345  : 			memmove(listArray+position, listArray+position+1, (list_size-1-position) * sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	sub	ecx, DWORD PTR _position$[ebp]
	imul	edx, ecx, 9
	push	edx
	imul	eax, DWORD PTR _position$[ebp], 9
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax+9]
	push	eax
	imul	ecx, DWORD PTR _position$[ebp], 9
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	call	_memmove
	add	esp, 12					; 0000000cH

; 346  : 
; 347  : 			Del();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Del@?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QAEXI@Z ; DataStructures::List<ReplicaManager::RegisteredReplica>::Del
$LN2@RemoveAtIn:

; 348  : 		}
; 349  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveAtIndex@?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QAEXI@Z ENDP ; DataStructures::List<ReplicaManager::RegisteredReplica>::RemoveAtIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Insert@?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QAEXURegisteredReplica@ReplicaManager@@@Z
_TEXT	SEGMENT
$T1 = -236						; size = 4
$T2 = -224						; size = 4
_new_array$3 = -20					; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 9
?Insert@?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QAEXURegisteredReplica@ReplicaManager@@@Z PROC ; DataStructures::List<ReplicaManager::RegisteredReplica>::Insert, COMDAT
; _this$ = ecx

; 242  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 243  : 		// Reallocate list if necessary
; 244  : 
; 245  : 		if ( list_size == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	$LN3@Insert

; 246  : 		{
; 247  : 			// allocate twice the currently allocated memory
; 248  : 			list_type * new_array;
; 249  : 
; 250  : 			if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Insert

; 251  : 				allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 16			; 00000010H

; 252  : 			else

	jmp	SHORT $LN1@Insert
$LN2@Insert:

; 253  : 				allocation_size *= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN1@Insert:

; 254  : 
; 255  : 			new_array = new list_type [ allocation_size ];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, 9
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _new_array$3[ebp], eax

; 256  : 
; 257  : 			// copy old array over
; 258  : 			//	for ( unsigned int counter = 0; counter < list_size; ++counter )
; 259  : 			//		new_array[ counter ] = listArray[ counter ];
; 260  : 
; 261  : 			// Don't call constructors, assignment operators, etc.
; 262  : 			memcpy(new_array, listArray, list_size*sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [eax+4], 9
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _new_array$3[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 263  : 
; 264  : 			// set old array to point to the newly allocated and twice as large array
; 265  : 			delete[] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 266  : 
; 267  : 			listArray = new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$3[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Insert:

; 268  : 		}
; 269  : 
; 270  : 		// Insert the new item at the correct spot
; 271  : 		listArray[ list_size ] = input;

	mov	eax, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [eax+4], 9
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, ecx
	mov	ecx, DWORD PTR _input$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _input$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	cl, BYTE PTR _input$[ebp+8]
	mov	BYTE PTR [eax+8], cl

; 272  : 
; 273  : 		++list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 274  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Insert@?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QAEXURegisteredReplica@ReplicaManager@@@Z ENDP ; DataStructures::List<ReplicaManager::RegisteredReplica>::Insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Insert@?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QAEXURegisteredReplica@ReplicaManager@@I@Z
_TEXT	SEGMENT
$T1 = -236						; size = 4
$T2 = -224						; size = 4
_new_array$3 = -20					; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 9
_position$ = 20						; size = 4
?Insert@?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QAEXURegisteredReplica@ReplicaManager@@I@Z PROC ; DataStructures::List<ReplicaManager::RegisteredReplica>::Insert, COMDAT
; _this$ = ecx

; 194  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 195  : #ifdef _DEBUG
; 196  : 		assert( position <= list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jbe	SHORT $LN6@Insert
	push	196					; 000000c4H
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CM@FMCFHBCK@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN6@Insert:

; 197  : #endif
; 198  : 
; 199  : 		// Reallocate list if necessary
; 200  : 		if ( list_size == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	$LN3@Insert

; 201  : 		{
; 202  : 			// allocate twice the currently allocated memory
; 203  : 			list_type * new_array;
; 204  : 
; 205  : 			if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Insert

; 206  : 				allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 16			; 00000010H

; 207  : 			else

	jmp	SHORT $LN1@Insert
$LN2@Insert:

; 208  : 				allocation_size *= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN1@Insert:

; 209  : 
; 210  : 			new_array = new list_type [ allocation_size ];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, 9
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _new_array$3[ebp], eax

; 211  : 
; 212  : 			// copy old array over
; 213  : 			//for ( unsigned int counter = 0; counter < list_size; ++counter )
; 214  : 			//	new_array[ counter ] = listArray[ counter ];
; 215  : 
; 216  : 			// Don't call constructors, assignment operators, etc.
; 217  : 			memcpy(new_array, listArray, list_size*sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [eax+4], 9
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _new_array$3[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 218  : 
; 219  : 			// set old array to point to the newly allocated and twice as large array
; 220  : 			delete[] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 221  : 
; 222  : 			listArray = new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$3[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Insert:

; 223  : 		}
; 224  : 
; 225  : 		// Move the elements in the list to make room
; 226  : 		//for ( unsigned int counter = list_size; counter != position; counter-- )
; 227  : 		//	listArray[ counter ] = listArray[ counter - 1 ];
; 228  : 
; 229  : 		// Don't call constructors, assignment operators, etc.
; 230  : 		memmove(listArray+position+1, listArray+position, (list_size-position)*sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _position$[ebp]
	imul	edx, ecx, 9
	push	edx
	imul	eax, DWORD PTR _position$[ebp], 9
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	push	eax
	imul	edx, DWORD PTR _position$[ebp], 9
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+edx+9]
	push	edx
	call	_memmove
	add	esp, 12					; 0000000cH

; 231  : 
; 232  : 		// Insert the new item at the correct spot
; 233  : 		listArray[ position ] = input;

	imul	eax, DWORD PTR _position$[ebp], 9
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, eax
	mov	eax, DWORD PTR _input$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _input$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	al, BYTE PTR _input$[ebp+8]
	mov	BYTE PTR [edx+8], al

; 234  : 
; 235  : 		++list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 236  : 
; 237  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Insert@?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QAEXURegisteredReplica@ReplicaManager@@I@Z ENDP ; DataStructures::List<ReplicaManager::RegisteredReplica>::Insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??A?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QBEAAURegisteredReplica@ReplicaManager@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
??A?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QBEAAURegisteredReplica@ReplicaManager@@I@Z PROC ; DataStructures::List<ReplicaManager::RegisteredReplica>::operator[], COMDAT
; _this$ = ecx

; 185  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 186  : #ifdef _DEBUG
; 187  : 		assert ( position < list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN3@operator
	push	187					; 000000bbH
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@operator:

; 188  : #endif
; 189  : 		return listArray[ position ];

	imul	eax, DWORD PTR _position$[ebp], 9
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]

; 190  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QBEAAURegisteredReplica@ReplicaManager@@I@Z ENDP ; DataStructures::List<ReplicaManager::RegisteredReplica>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??1?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
??1?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QAE@XZ PROC ; DataStructures::List<ReplicaManager::RegisteredReplica>::~List<ReplicaManager::RegisteredReplica>, COMDAT
; _this$ = ecx

; 121  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 122  : 		if (allocation_size>0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jbe	SHORT $LN2@List

; 123  : 			delete [] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@List:

; 124  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QAE@XZ ENDP ; DataStructures::List<ReplicaManager::RegisteredReplica>::~List<ReplicaManager::RegisteredReplica>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??0?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QAE@XZ PROC ; DataStructures::List<ReplicaManager::RegisteredReplica>::List<ReplicaManager::RegisteredReplica>, COMDAT
; _this$ = ecx

; 113  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 114  : 		allocation_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 115  : 		listArray = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 116  : 		list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 117  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QAE@XZ ENDP ; DataStructures::List<ReplicaManager::RegisteredReplica>::List<ReplicaManager::RegisteredReplica>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?Size@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIXZ PROC ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::Size, COMDAT
; _this$ = ecx

; 231  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 232  : 		return orderedList.Size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QBEIXZ ; DataStructures::List<ReplicaManager::RegisteredReplica>::Size

; 233  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIXZ ENDP ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?Clear@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Clear@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEXXZ PROC ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::Clear, COMDAT
; _this$ = ecx

; 219  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 220  : 		orderedList.Clear();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QAEX_N@Z ; DataStructures::List<ReplicaManager::RegisteredReplica>::Clear

; 221  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEXXZ ENDP ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?RemoveAtIndex@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_index$ = 8						; size = 4
?RemoveAtIndex@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEXI@Z PROC ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::RemoveAtIndex, COMDAT
; _this$ = ecx

; 195  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 196  : 		orderedList.RemoveAtIndex(index);

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAtIndex@?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QAEXI@Z ; DataStructures::List<ReplicaManager::RegisteredReplica>::RemoveAtIndex

; 197  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveAtIndex@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEXI@Z ENDP ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::RemoveAtIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ??A?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAURegisteredReplica@ReplicaManager@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
??A?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAURegisteredReplica@ReplicaManager@@I@Z PROC ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::operator[], COMDAT
; _this$ = ecx

; 225  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 226  : 		return orderedList[position];

	mov	eax, DWORD PTR _position$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QBEAAURegisteredReplica@ReplicaManager@@I@Z ; DataStructures::List<ReplicaManager::RegisteredReplica>::operator[]

; 227  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAURegisteredReplica@ReplicaManager@@I@Z ENDP ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?Insert@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEIABQAVReplica@@ABURegisteredReplica@ReplicaManager@@@Z
_TEXT	SEGMENT
_index$ = -32						; size = 4
_objectExists$ = -17					; size = 1
_this$ = -8						; size = 4
_key$ = 8						; size = 4
_data$ = 12						; size = 4
?Insert@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEIABQAVReplica@@ABURegisteredReplica@ReplicaManager@@@Z PROC ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::Insert, COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		bool objectExists;
; 158  : 		unsigned index;
; 159  : 		index = GetIndexFromKey(key, &objectExists);

	lea	eax, DWORD PTR _objectExists$[ebp]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexFromKey@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIABQAVReplica@@PA_N@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::GetIndexFromKey
	mov	DWORD PTR _index$[ebp], eax

; 160  : 
; 161  : 		// Don't allow duplicate insertion.
; 162  : 		if (objectExists)

	movzx	eax, BYTE PTR _objectExists$[ebp]
	test	eax, eax
	je	SHORT $LN3@Insert

; 163  : 			return (unsigned)-1;

	or	eax, -1
	jmp	SHORT $LN4@Insert
$LN3@Insert:

; 164  : 
; 165  : 		if (index>=orderedList.Size())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QBEIXZ ; DataStructures::List<ReplicaManager::RegisteredReplica>::Size
	cmp	DWORD PTR _index$[ebp], eax
	jb	SHORT $LN2@Insert

; 166  : 		{
; 167  : 			orderedList.Insert(data);

	mov	eax, DWORD PTR _data$[ebp]
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	al, BYTE PTR [eax+8]
	mov	BYTE PTR [ecx+8], al
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Insert@?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QAEXURegisteredReplica@ReplicaManager@@@Z ; DataStructures::List<ReplicaManager::RegisteredReplica>::Insert

; 168  : 			return orderedList.Size()-1;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QBEIXZ ; DataStructures::List<ReplicaManager::RegisteredReplica>::Size
	sub	eax, 1
	jmp	SHORT $LN4@Insert

; 169  : 		}
; 170  : 		else

	jmp	SHORT $LN4@Insert
$LN2@Insert:

; 171  : 		{
; 172  : 			orderedList.Insert(data,index);

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	cl, BYTE PTR [ecx+8]
	mov	BYTE PTR [edx+8], cl
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Insert@?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QAEXURegisteredReplica@ReplicaManager@@I@Z ; DataStructures::List<ReplicaManager::RegisteredReplica>::Insert

; 173  : 			return index;

	mov	eax, DWORD PTR _index$[ebp]
$LN4@Insert:

; 174  : 		}		
; 175  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@Insert
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN8@Insert:
	DD	1
	DD	$LN7@Insert
$LN7@Insert:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN6@Insert
$LN6@Insert:
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
?Insert@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEIABQAVReplica@@ABURegisteredReplica@ReplicaManager@@@Z ENDP ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::Insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?GetIndexFromKey@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIABQAVReplica@@PA_N@Z
_TEXT	SEGMENT
_res$ = -56						; size = 4
_lowerBound$ = -44					; size = 4
_upperBound$ = -32					; size = 4
_index$ = -20						; size = 4
_this$ = -8						; size = 4
_key$ = 8						; size = 4
_objectExists$ = 12					; size = 4
?GetIndexFromKey@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIABQAVReplica@@PA_N@Z PROC ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::GetIndexFromKey, COMDAT
; _this$ = ecx

; 110  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 111  : 		int index, upperBound, lowerBound;
; 112  : 		int res;
; 113  : 
; 114  : 		if (orderedList.Size()==0)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QBEIXZ ; DataStructures::List<ReplicaManager::RegisteredReplica>::Size
	test	eax, eax
	jne	SHORT $LN8@GetIndexFr

; 115  : 		{
; 116  : 			*objectExists=false;

	mov	eax, DWORD PTR _objectExists$[ebp]
	mov	BYTE PTR [eax], 0

; 117  : 			return 0;

	xor	eax, eax
	jmp	$LN9@GetIndexFr
$LN8@GetIndexFr:

; 118  : 		}
; 119  : 
; 120  : 		upperBound=(int)orderedList.Size()-1;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QBEIXZ ; DataStructures::List<ReplicaManager::RegisteredReplica>::Size
	sub	eax, 1
	mov	DWORD PTR _upperBound$[ebp], eax

; 121  : 		lowerBound=0;

	mov	DWORD PTR _lowerBound$[ebp], 0

; 122  : 		index = (int)orderedList.Size()/2;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QBEIXZ ; DataStructures::List<ReplicaManager::RegisteredReplica>::Size
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _index$[ebp], eax
$LN7@GetIndexFr:

; 123  : 
; 124  : #ifdef _MSC_VER
; 125  : 	#pragma warning( disable : 4127 ) // warning C4127: conditional expression is constant
; 126  : #endif
; 127  : 		while (1)

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN9@GetIndexFr

; 128  : 		{
; 129  : 			res = comparison_function(key,orderedList[index]);

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QBEAAURegisteredReplica@ReplicaManager@@I@Z ; DataStructures::List<ReplicaManager::RegisteredReplica>::operator[]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	call	?RegisteredReplicaComp@ReplicaManager@@SAHABQAVReplica@@ABURegisteredReplica@1@@Z ; ReplicaManager::RegisteredReplicaComp
	add	esp, 8
	mov	DWORD PTR _res$[ebp], eax

; 130  : 			if (res==0)

	cmp	DWORD PTR _res$[ebp], 0
	jne	SHORT $LN5@GetIndexFr

; 131  : 			{
; 132  : 				*objectExists=true;

	mov	eax, DWORD PTR _objectExists$[ebp]
	mov	BYTE PTR [eax], 1

; 133  : 				return index;

	mov	eax, DWORD PTR _index$[ebp]
	jmp	SHORT $LN9@GetIndexFr
	jmp	SHORT $LN4@GetIndexFr
$LN5@GetIndexFr:

; 134  : 			}
; 135  : 			else if (res<0)

	cmp	DWORD PTR _res$[ebp], 0
	jge	SHORT $LN3@GetIndexFr

; 136  : 			{
; 137  : 				upperBound=index-1;

	mov	eax, DWORD PTR _index$[ebp]
	sub	eax, 1
	mov	DWORD PTR _upperBound$[ebp], eax

; 138  : 			}
; 139  : 			else// if (res>0)

	jmp	SHORT $LN4@GetIndexFr
$LN3@GetIndexFr:

; 140  : 			{
; 141  : 				lowerBound=index+1;

	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 1
	mov	DWORD PTR _lowerBound$[ebp], eax
$LN4@GetIndexFr:

; 142  : 			}
; 143  : 
; 144  : 			index=lowerBound+(upperBound-lowerBound)/2;

	mov	eax, DWORD PTR _upperBound$[ebp]
	sub	eax, DWORD PTR _lowerBound$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _lowerBound$[ebp]
	mov	DWORD PTR _index$[ebp], eax

; 145  : 
; 146  : 			if (lowerBound>upperBound)

	mov	eax, DWORD PTR _lowerBound$[ebp]
	cmp	eax, DWORD PTR _upperBound$[ebp]
	jle	SHORT $LN1@GetIndexFr

; 147  : 			{
; 148  : 				*objectExists=false;

	mov	eax, DWORD PTR _objectExists$[ebp]
	mov	BYTE PTR [eax], 0

; 149  : 				return lowerBound; // No match

	mov	eax, DWORD PTR _lowerBound$[ebp]
	jmp	SHORT $LN9@GetIndexFr
$LN1@GetIndexFr:

; 150  : 			}
; 151  : 		}

	jmp	SHORT $LN7@GetIndexFr
$LN9@GetIndexFr:

; 152  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?GetIndexFromKey@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIABQAVReplica@@PA_N@Z ENDP ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::GetIndexFromKey
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?HasData@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBE_NABQAVReplica@@@Z
_TEXT	SEGMENT
_index$ = -32						; size = 4
_objectExists$ = -17					; size = 1
_this$ = -8						; size = 4
_key$ = 8						; size = 4
?HasData@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBE_NABQAVReplica@@@Z PROC ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::HasData, COMDAT
; _this$ = ecx

; 91   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 92   : 		bool objectExists;
; 93   : 		unsigned index;
; 94   : 		index = GetIndexFromKey(key, &objectExists);

	lea	eax, DWORD PTR _objectExists$[ebp]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexFromKey@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIABQAVReplica@@PA_N@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::GetIndexFromKey
	mov	DWORD PTR _index$[ebp], eax

; 95   : 		return objectExists;

	mov	al, BYTE PTR _objectExists$[ebp]

; 96   : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@HasData
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$LN5@HasData:
	DD	1
	DD	$LN4@HasData
$LN4@HasData:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN3@HasData
$LN3@HasData:
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
?HasData@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBE_NABQAVReplica@@@Z ENDP ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::HasData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ??1?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ PROC ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::~OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>, COMDAT
; _this$ = ecx

; 72   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 73   : 		Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEXXZ ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::Clear

; 74   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QAE@XZ ; DataStructures::List<ReplicaManager::RegisteredReplica>::~List<ReplicaManager::RegisteredReplica>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QAE@XZ ; DataStructures::List<ReplicaManager::RegisteredReplica>::~List<ReplicaManager::RegisteredReplica>
__ehhandler$??1?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ ENDP ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::~OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ??0?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ PROC ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>, COMDAT
; _this$ = ecx

; 67   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$List@URegisteredReplica@ReplicaManager@@@DataStructures@@QAE@XZ ; DataStructures::List<ReplicaManager::RegisteredReplica>::List<ReplicaManager::RegisteredReplica>

; 68   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ ENDP ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\replicamanager.cpp
;	COMDAT ?OnDisconnect@ReplicaManager@@MAEXPAVRakPeerInterface@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_peer$ = 8						; size = 4
?OnDisconnect@ReplicaManager@@MAEXPAVRakPeerInterface@@@Z PROC ; ReplicaManager::OnDisconnect, COMDAT
; _this$ = ecx

; 801  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 802  : 	Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@ReplicaManager@@IAEXXZ		; ReplicaManager::Clear

; 803  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?OnDisconnect@ReplicaManager@@MAEXPAVRakPeerInterface@@@Z ENDP ; ReplicaManager::OnDisconnect
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\replicamanager.cpp
;	COMDAT ?OnCloseConnection@ReplicaManager@@MAEXPAVRakPeerInterface@@UPlayerID@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_peer$ = 8						; size = 4
_playerId$ = 12						; size = 6
?OnCloseConnection@ReplicaManager@@MAEXPAVRakPeerInterface@@UPlayerID@@@Z PROC ; ReplicaManager::OnCloseConnection, COMDAT
; _this$ = ecx

; 794  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 795  : 	RemoveParticipant(playerId);

	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveParticipant@ReplicaManager@@QAEXUPlayerID@@@Z ; ReplicaManager::RemoveParticipant

; 796  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?OnCloseConnection@ReplicaManager@@MAEXPAVRakPeerInterface@@UPlayerID@@@Z ENDP ; ReplicaManager::OnCloseConnection
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\replicamanager.cpp
;	COMDAT ?OnReceive@ReplicaManager@@MAE?AW4PluginReceiveResult@@PAVRakPeerInterface@@PAUPacket@@@Z
_TEXT	SEGMENT
tv207 = -664						; size = 4
tv78 = -664						; size = 4
$T2 = -656						; size = 4
$T3 = -644						; size = 4
$T4 = -632						; size = 4
$T5 = -620						; size = 4
$T6 = -608						; size = 4
_rc$7 = -404						; size = 4
_inBitstream$8 = -392					; size = 273
_b$9 = -105						; size = 1
_receivedCommand$10 = -96				; size = 26
_hasNetworkId$11 = -57					; size = 1
_participantStruct$12 = -48				; size = 4
_packetIdentifier$ = -33				; size = 1
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_peer$ = 8						; size = 4
_packet$ = 12						; size = 4
?OnReceive@ReplicaManager@@MAE?AW4PluginReceiveResult@@PAVRakPeerInterface@@PAUPacket@@@Z PROC ; ReplicaManager::OnReceive, COMDAT
; _this$ = ecx

; 805  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?OnReceive@ReplicaManager@@MAE?AW4PluginReceiveResult@@PAVRakPeerInterface@@PAUPacket@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 652				; 0000028cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-664]
	mov	ecx, 163				; 000000a3H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 806  : 	unsigned char packetIdentifier;
; 807  : 	if ( ( unsigned char ) packet->data[ 0 ] == ID_TIMESTAMP )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _packet$[ebp]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax+ecx]
	cmp	ecx, 36					; 00000024H
	jne	SHORT $LN22@OnReceive

; 808  : 	{
; 809  : 		if ( packet->length > sizeof( unsigned char ) + sizeof( unsigned int ) )

	mov	eax, DWORD PTR _packet$[ebp]
	cmp	DWORD PTR [eax+8], 5
	jbe	SHORT $LN21@OnReceive

; 810  : 			packetIdentifier = ( unsigned char ) packet->data[ sizeof( unsigned char ) + sizeof( unsigned int ) ];

	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _packet$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	cl, BYTE PTR [ecx+eax]
	mov	BYTE PTR _packetIdentifier$[ebp], cl

; 811  : 		else

	jmp	SHORT $LN20@OnReceive
$LN21@OnReceive:

; 812  : 			return RR_STOP_PROCESSING_AND_DEALLOCATE;

	xor	eax, eax
	jmp	$LN23@OnReceive
$LN20@OnReceive:

; 813  : 	}
; 814  : 	else

	jmp	SHORT $LN19@OnReceive
$LN22@OnReceive:

; 815  : 		packetIdentifier = ( unsigned char ) packet->data[ 0 ];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _packet$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	cl, BYTE PTR [ecx+eax]
	mov	BYTE PTR _packetIdentifier$[ebp], cl
$LN19@OnReceive:

; 816  : 
; 817  : 	switch (packetIdentifier)

	movzx	eax, BYTE PTR _packetIdentifier$[ebp]
	mov	DWORD PTR tv78[ebp], eax
	mov	ecx, DWORD PTR tv78[ebp]
	sub	ecx, 23					; 00000017H
	mov	DWORD PTR tv78[ebp], ecx
	cmp	DWORD PTR tv78[ebp], 37			; 00000025H
	ja	$LN17@OnReceive
	mov	edx, DWORD PTR tv78[ebp]
	movzx	eax, BYTE PTR $LN30@OnReceive[edx]
	jmp	DWORD PTR $LN38@OnReceive[eax*4]
$LN16@OnReceive:

; 818  : 	{
; 819  : 	case ID_NEW_INCOMING_CONNECTION:
; 820  : 	case ID_CONNECTION_REQUEST_ACCEPTED:
; 821  : 		if (autoParticipateNewConnections)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+41]
	test	ecx, ecx
	je	SHORT $LN15@OnReceive

; 822  : 			AddParticipant(packet->playerId);

	mov	eax, DWORD PTR _packet$[ebp]
	add	eax, 2
	sub	esp, 8
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	ax, WORD PTR [eax+4]
	mov	WORD PTR [ecx+4], ax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddParticipant@ReplicaManager@@QAEXUPlayerID@@@Z ; ReplicaManager::AddParticipant
$LN15@OnReceive:

; 823  : 		return RR_CONTINUE_PROCESSING;

	mov	eax, 1
	jmp	$LN23@OnReceive
$LN14@OnReceive:

; 824  : 	case ID_DISCONNECTION_NOTIFICATION:
; 825  : 	case ID_CONNECTION_LOST:
; 826  : 		OnCloseConnection(peer, packet->playerId);

	mov	eax, DWORD PTR _packet$[ebp]
	add	eax, 2
	mov	esi, esp
	sub	esp, 8
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	ax, WORD PTR [eax+4]
	mov	WORD PTR [ecx+4], ax
	mov	ecx, DWORD PTR _peer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+24]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 827  : 		return RR_CONTINUE_PROCESSING;

	mov	eax, 1
	jmp	$LN23@OnReceive
$LN13@OnReceive:

; 828  : 	case ID_REPLICA_MANAGER_DOWNLOAD_COMPLETE:
; 829  : 		if (_receiveDownloadCompleteCB==0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+36], 0
	jne	SHORT $LN11@OnReceive

; 830  : 		{
; 831  : 			return RR_STOP_PROCESSING_AND_DEALLOCATE;

	xor	eax, eax
	jmp	$LN23@OnReceive
$LN11@OnReceive:

; 832  : 		}
; 833  : 	case ID_REPLICA_MANAGER_CONSTRUCTION:
; 834  : 	case ID_REPLICA_MANAGER_DESTRUCTION:
; 835  : 	case ID_REPLICA_MANAGER_SCOPE_CHANGE:
; 836  : 	case ID_REPLICA_MANAGER_SERIALIZE:
; 837  : 		{
; 838  : 			ParticipantStruct *participantStruct;
; 839  : 			bool hasNetworkId;
; 840  : 			ReceivedCommand receivedCommand;
; 841  : 			bool b=true;

	mov	BYTE PTR _b$9[ebp], 1

; 842  : 			RakNet::BitStream inBitstream(packet->data, packet->length, false);

	push	0
	mov	eax, DWORD PTR _packet$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _packet$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	lea	ecx, DWORD PTR _inBitstream$8[ebp]
	call	??0BitStream@RakNet@@QAE@PAEI_N@Z	; RakNet::BitStream::BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 843  : 			// SetWriteOffset is used here to get around a design flaw, where I should have had the bitstream constructor take bits, rather than bytes
; 844  : 			// It sets the actual number of bits in the packet
; 845  : 			inBitstream.SetWriteOffset(packet->bitSize);

	mov	eax, DWORD PTR _packet$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	lea	ecx, DWORD PTR _inBitstream$8[ebp]
	call	?SetWriteOffset@BitStream@RakNet@@QAEXH@Z ; RakNet::BitStream::SetWriteOffset

; 846  : 			receivedCommand.playerId=packet->playerId;

	mov	eax, DWORD PTR _packet$[ebp]
	add	eax, 2
	push	eax
	lea	ecx, DWORD PTR _receivedCommand$10[ebp]
	call	??4PlayerID@@QAEAAU0@ABU0@@Z		; PlayerID::operator=

; 847  : 			receivedCommand.command=packetIdentifier;

	movzx	eax, BYTE PTR _packetIdentifier$[ebp]
	mov	DWORD PTR _receivedCommand$10[ebp+14], eax

; 848  : 
; 849  : 			if ( ( unsigned char ) packet->data[ 0 ] == ID_TIMESTAMP )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _packet$[ebp]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax+ecx]
	cmp	ecx, 36					; 00000024H
	jne	SHORT $LN10@OnReceive

; 850  : 			{
; 851  : 				inBitstream.IgnoreBits(8);

	push	8
	lea	ecx, DWORD PTR _inBitstream$8[ebp]
	call	?IgnoreBits@BitStream@RakNet@@QAEXH@Z	; RakNet::BitStream::IgnoreBits

; 852  : 				b=inBitstream.Read(receivedCommand.u1);

	lea	eax, DWORD PTR _receivedCommand$10[ebp+18]
	push	eax
	lea	ecx, DWORD PTR _inBitstream$8[ebp]
	call	??$Read@I@BitStream@RakNet@@QAE_NAAI@Z	; RakNet::BitStream::Read<unsigned int>
	mov	BYTE PTR _b$9[ebp], al

; 853  : 			}
; 854  : 			else

	jmp	SHORT $LN9@OnReceive
$LN10@OnReceive:

; 855  : 				receivedCommand.u1=0;

	mov	DWORD PTR _receivedCommand$10[ebp+18], 0
$LN9@OnReceive:

; 856  : 			inBitstream.IgnoreBits(8); // Ignore the packet id

	push	8
	lea	ecx, DWORD PTR _inBitstream$8[ebp]
	call	?IgnoreBits@BitStream@RakNet@@QAEXH@Z	; RakNet::BitStream::IgnoreBits

; 857  : 			receivedCommand.networkID=UNASSIGNED_NETWORK_ID;

	push	OFFSET _UNASSIGNED_NETWORK_ID
	lea	ecx, DWORD PTR _receivedCommand$10[ebp+6]
	call	??4NetworkID@@QAEAAU0@ABU0@@Z		; NetworkID::operator=

; 858  : 			if (packetIdentifier==ID_REPLICA_MANAGER_CONSTRUCTION) // ID_REPLICA_MANAGER_CONSTRUCTION has an optional networkID

	movzx	eax, BYTE PTR _packetIdentifier$[ebp]
	cmp	eax, 56					; 00000038H
	jne	SHORT $LN8@OnReceive

; 859  : 			{
; 860  : 				b=inBitstream.Read(hasNetworkId);

	lea	eax, DWORD PTR _hasNetworkId$11[ebp]
	push	eax
	lea	ecx, DWORD PTR _inBitstream$8[ebp]
	call	??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z ; RakNet::BitStream::Read<bool>
	mov	BYTE PTR _b$9[ebp], al

; 861  : 				if (hasNetworkId)

	movzx	eax, BYTE PTR _hasNetworkId$11[ebp]
	test	eax, eax
	je	SHORT $LN7@OnReceive

; 862  : 					b=inBitstream.Read(receivedCommand.networkID);

	lea	eax, DWORD PTR _receivedCommand$10[ebp+6]
	push	eax
	lea	ecx, DWORD PTR _inBitstream$8[ebp]
	call	??$Read@UNetworkID@@@BitStream@RakNet@@QAE_NAAUNetworkID@@@Z ; RakNet::BitStream::Read<NetworkID>
	mov	BYTE PTR _b$9[ebp], al
$LN7@OnReceive:

; 863  : 			}

	jmp	SHORT $LN6@OnReceive
$LN8@OnReceive:

; 864  : 			else if (packetIdentifier!=ID_REPLICA_MANAGER_DOWNLOAD_COMPLETE)

	movzx	eax, BYTE PTR _packetIdentifier$[ebp]
	cmp	eax, 60					; 0000003cH
	je	SHORT $LN6@OnReceive

; 865  : 			{
; 866  : 				b=inBitstream.Read(receivedCommand.networkID); // Other packets always have an networkID

	lea	eax, DWORD PTR _receivedCommand$10[ebp+6]
	push	eax
	lea	ecx, DWORD PTR _inBitstream$8[ebp]
	call	??$Read@UNetworkID@@@BitStream@RakNet@@QAE_NAAUNetworkID@@@Z ; RakNet::BitStream::Read<NetworkID>
	mov	BYTE PTR _b$9[ebp], al
$LN6@OnReceive:

; 867  : 			}
; 868  : 
; 869  : 			if (b==false)

	movzx	eax, BYTE PTR _b$9[ebp]
	test	eax, eax
	jne	SHORT $LN4@OnReceive

; 870  : 			{
; 871  : 				// Invalid packet
; 872  : #ifdef _DEBUG
; 873  : 				assert(0);

	xor	eax, eax
	jne	SHORT $LN25@OnReceive
	mov	ecx, DWORD PTR ?__LINE__Var@?1??OnReceive@ReplicaManager@@MAE?AW4PluginReceiveResult@@PAVRakPeerInterface@@PAUPacket@@@Z@4JA
	add	ecx, 68					; 00000044H
	push	ecx
	push	OFFSET ??_C@_1FG@CAHGPPEA@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAe?$AAp?$AAl?$AAi?$AAc?$AAa?$AAm@
	push	OFFSET ??_C@_13COJANIEC@?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN25@OnReceive:

; 874  : #endif
; 875  : 				return RR_STOP_PROCESSING_AND_DEALLOCATE;

	mov	DWORD PTR $T2[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _inBitstream$8[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	eax, DWORD PTR $T2[ebp]
	jmp	$LN23@OnReceive
$LN4@OnReceive:

; 876  : 			}
; 877  : 			receivedCommand.userData=&inBitstream;

	lea	eax, DWORD PTR _inBitstream$8[ebp]
	mov	DWORD PTR _receivedCommand$10[ebp+22], eax

; 878  : 			participantStruct=GetParticipantByPlayerID(receivedCommand.playerId);

	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _receivedCommand$10[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _receivedCommand$10[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetParticipantByPlayerID@ReplicaManager@@IBEPAUParticipantStruct@1@UPlayerID@@@Z ; ReplicaManager::GetParticipantByPlayerID
	mov	DWORD PTR _participantStruct$12[ebp], eax

; 879  : 			if (participantStruct)

	cmp	DWORD PTR _participantStruct$12[ebp], 0
	je	$LN3@OnReceive

; 880  : 			{
; 881  : 				// .Size()>0 is because commands are always processed in order.  If a command is delayed, no further commands are processed.
; 882  : 				// ProcessReceivedCommand(...)==false means that the use signaled to delay a command
; 883  : 				if (participantStruct->pendingCommands.Size()>0 || ProcessReceivedCommand(participantStruct, &receivedCommand)==REPLICA_PROCESS_LATER)

	mov	ecx, DWORD PTR _participantStruct$12[ebp]
	add	ecx, 31					; 0000001fH
	call	?Size@?$Queue@PAUReceivedCommand@ReplicaManager@@@DataStructures@@QBEIXZ ; DataStructures::Queue<ReplicaManager::ReceivedCommand *>::Size
	test	eax, eax
	ja	SHORT $LN1@OnReceive
	lea	eax, DWORD PTR _receivedCommand$10[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$12[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ProcessReceivedCommand@ReplicaManager@@IAE?AW4ReplicaReturnResult@@PAUParticipantStruct@1@PAUReceivedCommand@1@@Z ; ReplicaManager::ProcessReceivedCommand
	test	eax, eax
	jne	$LN3@OnReceive
$LN1@OnReceive:

; 884  : 				{
; 885  : 					// Copy the data and add this to a queue that will call ProcessReceivedCommand again in Update.
; 886  : 
; 887  : 					// Allocate and copy structure
; 888  : 					ReceivedCommand *rc = new ReceivedCommand;

	push	26					; 0000001aH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR _rc$7[ebp], eax

; 889  : 					memcpy(rc, &receivedCommand, sizeof(ReceivedCommand));

	push	26					; 0000001aH
	lea	eax, DWORD PTR _receivedCommand$10[ebp]
	push	eax
	mov	ecx, DWORD PTR _rc$7[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 890  : 
; 891  : 					// Allocate and copy inBitstream remaining data
; 892  : 					rc->userData = new RakNet::BitStream;

	push	273					; 00000111H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN26@OnReceive
	mov	ecx, DWORD PTR $T5[ebp]
	call	??0BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::BitStream
	mov	DWORD PTR tv207[ebp], eax
	jmp	SHORT $LN27@OnReceive
$LN26@OnReceive:
	mov	DWORD PTR tv207[ebp], 0
$LN27@OnReceive:
	mov	eax, DWORD PTR tv207[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _rc$7[ebp]
	mov	edx, DWORD PTR $T4[ebp]
	mov	DWORD PTR [ecx+22], edx

; 893  : 					rc->userData->Write(&inBitstream, inBitstream.GetNumberOfBitsUsed());

	lea	ecx, DWORD PTR _inBitstream$8[ebp]
	call	?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBitsUsed
	push	eax
	lea	eax, DWORD PTR _inBitstream$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _rc$7[ebp]
	mov	ecx, DWORD PTR [ecx+22]
	call	?Write@BitStream@RakNet@@QAEXPAV12@H@Z	; RakNet::BitStream::Write

; 894  : 
; 895  : 					participantStruct->pendingCommands.Push(rc);

	lea	eax, DWORD PTR _rc$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$12[ebp]
	add	ecx, 31					; 0000001fH
	call	?Push@?$Queue@PAUReceivedCommand@ReplicaManager@@@DataStructures@@QAEXABQAUReceivedCommand@ReplicaManager@@@Z ; DataStructures::Queue<ReplicaManager::ReceivedCommand *>::Push
$LN3@OnReceive:

; 896  : 				}
; 897  : 			}
; 898  : 
; 899  : 			return RR_STOP_PROCESSING_AND_DEALLOCATE;

	mov	DWORD PTR $T6[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _inBitstream$8[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	eax, DWORD PTR $T6[ebp]
	jmp	SHORT $LN23@OnReceive
$LN17@OnReceive:

; 900  : 		}
; 901  : 	}
; 902  : 
; 903  : 	return RR_CONTINUE_PROCESSING;

	mov	eax, 1
$LN23@OnReceive:

; 904  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN37@OnReceive
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 664				; 00000298H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN37@OnReceive:
	DD	4
	DD	$LN36@OnReceive
$LN36@OnReceive:
	DD	-57					; ffffffc7H
	DD	1
	DD	$LN31@OnReceive
	DD	-96					; ffffffa0H
	DD	26					; 0000001aH
	DD	$LN32@OnReceive
	DD	-392					; fffffe78H
	DD	273					; 00000111H
	DD	$LN33@OnReceive
	DD	-404					; fffffe6cH
	DD	4
	DD	$LN34@OnReceive
$LN34@OnReceive:
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	0
$LN33@OnReceive:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	66					; 00000042H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	0
$LN32@OnReceive:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	105					; 00000069H
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	0
$LN31@OnReceive:
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	119					; 00000077H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	107					; 0000006bH
	DB	73					; 00000049H
	DB	100					; 00000064H
	DB	0
$LN38@OnReceive:
	DD	$LN16@OnReceive
	DD	$LN14@OnReceive
	DD	$LN11@OnReceive
	DD	$LN13@OnReceive
	DD	$LN17@OnReceive
$LN30@OnReceive:
	DB	0
	DB	4
	DB	4
	DB	0
	DB	4
	DB	1
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	2
	DB	2
	DB	2
	DB	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?OnReceive@ReplicaManager@@MAE?AW4PluginReceiveResult@@PAVRakPeerInterface@@PAUPacket@@@Z$0:
	lea	ecx, DWORD PTR _inBitstream$8[ebp]
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__unwindfunclet$?OnReceive@ReplicaManager@@MAE?AW4PluginReceiveResult@@PAVRakPeerInterface@@PAUPacket@@@Z$1:
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?OnReceive@ReplicaManager@@MAE?AW4PluginReceiveResult@@PAVRakPeerInterface@@PAUPacket@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-668]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?OnReceive@ReplicaManager@@MAE?AW4PluginReceiveResult@@PAVRakPeerInterface@@PAUPacket@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?OnReceive@ReplicaManager@@MAE?AW4PluginReceiveResult@@PAVRakPeerInterface@@PAUPacket@@@Z ENDP ; ReplicaManager::OnReceive
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\replicamanager.cpp
;	COMDAT ?OnAttach@ReplicaManager@@MAEXPAVRakPeerInterface@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_peer$ = 8						; size = 4
?OnAttach@ReplicaManager@@MAEXPAVRakPeerInterface@@@Z PROC ; ReplicaManager::OnAttach, COMDAT
; _this$ = ecx

; 445  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 446  : 	rakPeer=peer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _peer$[ebp]
	mov	DWORD PTR [eax+44], ecx

; 447  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?OnAttach@ReplicaManager@@MAEXPAVRakPeerInterface@@@Z ENDP ; ReplicaManager::OnAttach
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\replicamanager.cpp
;	COMDAT ?Update@ReplicaManager@@MAEXPAVRakPeerInterface@@@Z
_TEXT	SEGMENT
tv692 = -1180						; size = 4
tv637 = -1180						; size = 4
tv621 = -1180						; size = 4
tv611 = -1180						; size = 4
tv500 = -1180						; size = 4
tv488 = -1180						; size = 4
tv477 = -1180						; size = 4
tv467 = -1180						; size = 4
tv458 = -1180						; size = 4
tv397 = -1180						; size = 4
tv259 = -1180						; size = 4
tv225 = -1180						; size = 4
$T2 = -1172						; size = 8
$T3 = -1156						; size = 8
$T4 = -1140						; size = 8
$T5 = -1124						; size = 8
$T6 = -1108						; size = 8
$T7 = -1092						; size = 8
$T8 = -1076						; size = 4
$T9 = -1064						; size = 4
$T10 = -1052						; size = 4
_scopeTrue$11 = -845					; size = 1
_sendDLComplete$12 = -836				; size = 4
_j$13 = -824						; size = 4
_anyHasConstruction$14 = -809				; size = 1
_remoteObject$15 = -800					; size = 9
_remoteObject$16 = -780					; size = 9
_command$ = -757					; size = 1
_replica$ = -748					; size = 4
_receivedCommand$ = -736				; size = 4
_reliability$ = -724					; size = 4
_priority$ = -712					; size = 4
_objectExists$ = -697					; size = 1
_currentTime$ = -688					; size = 4
_userDataBitstream$ = -676				; size = 273
_outBitstream$ = -392					; size = 273
_commandListIndex$ = -108				; size = 4
_participantStruct$ = -96				; size = 4
_sendTimestamp$ = -81					; size = 1
_res$ = -72						; size = 4
_replicatedObjectsIndex$ = -60				; size = 4
_remoteObjectListIndex$ = -48				; size = 4
_participantIndex$ = -36				; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_peer$ = 8						; size = 4
?Update@ReplicaManager@@MAEXPAVRakPeerInterface@@@Z PROC ; ReplicaManager::Update, COMDAT
; _this$ = ecx

; 449  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Update@ReplicaManager@@MAEXPAVRakPeerInterface@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1168				; 00000490H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-1180]
	mov	ecx, 292				; 00000124H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 450  : 	if (participantList.Size()==0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?Size@?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::Size
	test	eax, eax
	jne	SHORT $LN67@Update

; 451  : 		return;

	jmp	$LN68@Update
$LN67@Update:

; 452  : 
; 453  : 	unsigned participantIndex, remoteObjectListIndex, replicatedObjectsIndex;
; 454  : 	ReplicaReturnResult res;
; 455  : 	bool sendTimestamp;
; 456  : 	ParticipantStruct *participantStruct;
; 457  : 	unsigned commandListIndex;
; 458  : 	RakNet::BitStream outBitstream, userDataBitstream;

	lea	ecx, DWORD PTR _outBitstream$[ebp]
	call	??0BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _userDataBitstream$[ebp]
	call	??0BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::BitStream
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 459  : 	RakNetTime currentTime;
; 460  : 	bool objectExists;
; 461  : 	PacketPriority priority;
; 462  : 	PacketReliability reliability;
; 463  : 	ReceivedCommand *receivedCommand;
; 464  : 	Replica *replica;
; 465  : 	unsigned char command;
; 466  : 	currentTime=0;

	mov	DWORD PTR _currentTime$[ebp], 0

; 467  : 
; 468  : 	// For each participant
; 469  : 	for (participantIndex=0; participantIndex < participantList.Size(); participantIndex++)

	mov	DWORD PTR _participantIndex$[ebp], 0
	jmp	SHORT $LN66@Update
$LN65@Update:
	mov	eax, DWORD PTR _participantIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _participantIndex$[ebp], eax
$LN66@Update:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?Size@?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::Size
	cmp	DWORD PTR _participantIndex$[ebp], eax
	jae	$LN64@Update

; 470  : 	{
; 471  : 		participantStruct = participantList[participantIndex];

	mov	eax, DWORD PTR _participantIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??A?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QBEAAPAUParticipantStruct@ReplicaManager@@I@Z ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _participantStruct$[ebp], ecx

; 472  : 
; 473  : 		// For each CommandStruct to send
; 474  : 		for (commandListIndex=0; commandListIndex < participantStruct->commandList.Size(); commandListIndex++)

	mov	DWORD PTR _commandListIndex$[ebp], 0
	jmp	SHORT $LN63@Update
$LN62@Update:
	mov	eax, DWORD PTR _commandListIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _commandListIndex$[ebp], eax
$LN63@Update:
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 7
	call	?Size@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::Size
	cmp	DWORD PTR _commandListIndex$[ebp], eax
	jae	$LN61@Update

; 475  : 		{
; 476  : 			// Only call RakNet::GetTime() once because it's slow
; 477  : 			if (currentTime==0)

	cmp	DWORD PTR _currentTime$[ebp], 0
	jne	SHORT $LN60@Update

; 478  : 				currentTime=RakNet::GetTime();

	call	?GetTime@RakNet@@YAIXZ			; RakNet::GetTime
	mov	DWORD PTR _currentTime$[ebp], eax
$LN60@Update:

; 479  : 
; 480  : 			replica=participantStruct->commandList[commandListIndex].replica;

	mov	eax, DWORD PTR _commandListIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 7
	call	??A?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAUCommandStruct@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _replica$[ebp], ecx

; 481  : 			command=participantStruct->commandList[commandListIndex].command;

	mov	eax, DWORD PTR _commandListIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 7
	call	??A?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAUCommandStruct@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::operator[]
	mov	cl, BYTE PTR [eax+4]
	mov	BYTE PTR _command$[ebp], cl

; 482  : 			replicatedObjectsIndex=replicatedObjects.GetIndexFromKey(replica, &objectExists);

	lea	eax, DWORD PTR _objectExists$[ebp]
	push	eax
	lea	ecx, DWORD PTR _replica$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?GetIndexFromKey@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIABQAVReplica@@PA_N@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::GetIndexFromKey
	mov	DWORD PTR _replicatedObjectsIndex$[ebp], eax

; 483  : #ifdef _DEBUG
; 484  : 			assert(objectExists);

	movzx	eax, BYTE PTR _objectExists$[ebp]
	test	eax, eax
	jne	SHORT $LN70@Update
	mov	ecx, DWORD PTR ?__LINE__Var@?1??Update@ReplicaManager@@MAEXPAVRakPeerInterface@@@Z@4JA
	add	ecx, 35					; 00000023H
	push	ecx
	push	OFFSET ??_C@_1FG@CAHGPPEA@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAe?$AAp?$AAl?$AAi?$AAc?$AAa?$AAm@
	push	OFFSET ??_C@_1BK@EBNJALNF@?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAE?$AAx?$AAi?$AAs?$AAt?$AAs?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN70@Update:

; 485  : #endif
; 486  : 
; 487  : 			// If construction is set, call SendConstruction.  The only precondition is that the object was not already created,
; 488  : 			// which was checked in ReplicaManager::Replicate
; 489  : 			if (command & REPLICA_EXPLICIT_CONSTRUCTION)

	movzx	eax, BYTE PTR _command$[ebp]
	and	eax, 1
	je	$LN59@Update

; 490  : 			{
; 491  : 				if (replicatedObjects[replicatedObjectsIndex].allowedInterfaces & REPLICA_SEND_CONSTRUCTION)

	mov	eax, DWORD PTR _replicatedObjectsIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAURegisteredReplica@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::operator[]
	movzx	ecx, BYTE PTR [eax+8]
	and	ecx, 8
	je	$LN58@Update

; 492  : 				{
; 493  : 					userDataBitstream.Reset();

	lea	ecx, DWORD PTR _userDataBitstream$[ebp]
	call	?Reset@BitStream@RakNet@@QAEXXZ		; RakNet::BitStream::Reset

; 494  : 					sendTimestamp=false;

	mov	BYTE PTR _sendTimestamp$[ebp], 0

; 495  : 					res=replica->SendConstruction(currentTime, participantStruct->playerId, &userDataBitstream, &sendTimestamp);

	mov	esi, esp
	lea	eax, DWORD PTR _sendTimestamp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _userDataBitstream$[ebp]
	push	ecx
	mov	edx, DWORD PTR _participantStruct$[ebp]
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR [edx+4]
	mov	WORD PTR [eax+4], dx
	mov	eax, DWORD PTR _currentTime$[ebp]
	push	eax
	mov	ecx, DWORD PTR _replica$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _replica$[ebp]
	mov	eax, DWORD PTR [edx+28]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _res$[ebp], eax

; 496  : 
; 497  : 					if (res==REPLICA_PROCESSING_DONE)

	cmp	DWORD PTR _res$[ebp], 1
	jne	$LN57@Update

; 498  : 					{
; 499  : 						outBitstream.Reset();

	lea	ecx, DWORD PTR _outBitstream$[ebp]
	call	?Reset@BitStream@RakNet@@QAEXXZ		; RakNet::BitStream::Reset

; 500  : 						// If SendConstruction returns true and writes to outBitStream, do this send.  Clear the construction command.  Then process the next command for this CommandStruct, if any.
; 501  : 						if (sendTimestamp)

	movzx	eax, BYTE PTR _sendTimestamp$[ebp]
	test	eax, eax
	je	SHORT $LN56@Update

; 502  : 						{
; 503  : 							outBitstream.Write((unsigned char)ID_TIMESTAMP);

	push	36					; 00000024H
	lea	ecx, DWORD PTR _outBitstream$[ebp]
	call	??$Write@E@BitStream@RakNet@@QAEXE@Z	; RakNet::BitStream::Write<unsigned char>

; 504  : 							outBitstream.Write(currentTime);

	mov	eax, DWORD PTR _currentTime$[ebp]
	push	eax
	lea	ecx, DWORD PTR _outBitstream$[ebp]
	call	??$Write@I@BitStream@RakNet@@QAEXI@Z	; RakNet::BitStream::Write<unsigned int>
$LN56@Update:

; 505  : 						}
; 506  : 						outBitstream.Write((unsigned char)ID_REPLICA_MANAGER_CONSTRUCTION);

	push	56					; 00000038H
	lea	ecx, DWORD PTR _outBitstream$[ebp]
	call	??$Write@E@BitStream@RakNet@@QAEXE@Z	; RakNet::BitStream::Write<unsigned char>

; 507  : 						// It's required to send an NetworkID if available.
; 508  : 						// Problem:
; 509  : 						// A->B->C
; 510  : 						//	|  |
; 511  : 						//	D->E
; 512  : 						//
; 513  : 						// A creates.
; 514  : 						// B->C->E->D->B will cycle forever.
; 515  : 						// Fix is to always include an networkID.  Objects are not created if that object id already is present.
; 516  : 						if (replica->GetNetworkID()!=UNASSIGNED_NETWORK_ID)

	push	OFFSET _UNASSIGNED_NETWORK_ID
	mov	esi, esp
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _replica$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _replica$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, eax
	call	??9NetworkID@@QBE_NABU0@@Z		; NetworkID::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN55@Update

; 517  : 						{
; 518  : 							outBitstream.Write(true);

	push	1
	lea	ecx, DWORD PTR _outBitstream$[ebp]
	call	??$Write@_N@BitStream@RakNet@@QAEX_N@Z	; RakNet::BitStream::Write<bool>

; 519  : 							outBitstream.Write(replica->GetNetworkID());

	mov	esi, esp
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _replica$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _replica$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	ecx, DWORD PTR _outBitstream$[ebp]
	call	??$Write@UNetworkID@@@BitStream@RakNet@@QAEXUNetworkID@@@Z ; RakNet::BitStream::Write<NetworkID>

; 520  : 						}
; 521  : 						else

	jmp	SHORT $LN54@Update
$LN55@Update:

; 522  : 							outBitstream.Write(false);

	push	0
	lea	ecx, DWORD PTR _outBitstream$[ebp]
	call	??$Write@_N@BitStream@RakNet@@QAEX_N@Z	; RakNet::BitStream::Write<bool>
$LN54@Update:

; 523  : 
; 524  : 						outBitstream.Write(&userDataBitstream, userDataBitstream.GetNumberOfBitsUsed());

	lea	ecx, DWORD PTR _userDataBitstream$[ebp]
	call	?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBitsUsed
	push	eax
	lea	eax, DWORD PTR _userDataBitstream$[ebp]
	push	eax
	lea	ecx, DWORD PTR _outBitstream$[ebp]
	call	?Write@BitStream@RakNet@@QAEXPAV12@H@Z	; RakNet::BitStream::Write

; 525  : 
; 526  : 						peer->Send(&outBitstream, HIGH_PRIORITY, RELIABLE_ORDERED, sendChannel, participantStruct->playerId, false);

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR _participantStruct$[ebp]
	sub	esp, 8
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	ax, WORD PTR [eax+4]
	mov	WORD PTR [ecx+4], ax
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+40]
	push	edx
	push	3
	push	1
	lea	eax, DWORD PTR _outBitstream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _peer$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _peer$[ebp]
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 527  : 
; 528  : 						// Turn off this bit
; 529  : 						participantStruct->commandList[commandListIndex].command &= 0xFF ^ REPLICA_EXPLICIT_CONSTRUCTION;

	mov	eax, DWORD PTR _commandListIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 7
	call	??A?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAUCommandStruct@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::operator[]
	add	eax, 4
	mov	DWORD PTR tv225[ebp], eax
	mov	ecx, DWORD PTR tv225[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	edx, 254				; 000000feH
	mov	eax, DWORD PTR tv225[ebp]
	mov	BYTE PTR [eax], dl

; 530  : 
; 531  : 						// Add the object to the participant's object list, indicating this object has been remotely created
; 532  : 						RemoteObject remoteObject;
; 533  : 						remoteObject.replica=replica;

	mov	eax, DWORD PTR _replica$[ebp]
	mov	DWORD PTR _remoteObject$16[ebp], eax

; 534  : 						remoteObject.inScope=defaultScope;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+42]
	mov	BYTE PTR _remoteObject$16[ebp+4], cl

; 535  : 						remoteObject.lastSendTime=0;

	mov	DWORD PTR _remoteObject$16[ebp+5], 0

; 536  : 						// Create an entry for this object.  We do this now, even if the user might refuse the SendConstruction override,
; 537  : 						// because that call may be delayed and other commands sent while that is pending.  We always do the REPLICA_EXPLICIT_CONSTRUCTION call first.
; 538  : 						participantStruct->remoteObjectList.Insert(remoteObject.replica,remoteObject);

	lea	eax, DWORD PTR _remoteObject$16[ebp]
	push	eax
	lea	ecx, DWORD PTR _remoteObject$16[ebp]
	push	ecx
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 19					; 00000013H
	call	?Insert@?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEIABQAVReplica@@ABURemoteObject@ReplicaManager@@@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::Insert
	jmp	SHORT $LN53@Update
$LN57@Update:

; 539  : 					}
; 540  : 					else if (res==REPLICA_PROCESS_LATER)

	cmp	DWORD PTR _res$[ebp], 0
	jne	SHORT $LN52@Update

; 541  : 					{
; 542  : 						continue;

	jmp	$LN62@Update

; 543  : 					}
; 544  : 					else // REPLICA_CANCEL_PROCESS

	jmp	SHORT $LN53@Update
$LN52@Update:

; 545  : 					{
; 546  : 						assert(res==REPLICA_CANCEL_PROCESS);

	cmp	DWORD PTR _res$[ebp], 2
	je	SHORT $LN71@Update
	mov	eax, DWORD PTR ?__LINE__Var@?1??Update@ReplicaManager@@MAEXPAVRakPeerInterface@@@Z@4JA
	add	eax, 97					; 00000061H
	push	eax
	push	OFFSET ??_C@_1FG@CAHGPPEA@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAe?$AAp?$AAl?$AAi?$AAc?$AAa?$AAm@
	push	OFFSET ??_C@_1DI@HDKFLDGG@?$AAr?$AAe?$AAs?$AA?$DN?$AA?$DN?$AAR?$AAE?$AAP?$AAL?$AAI?$AAC?$AAA?$AA_?$AAC?$AAA?$AAN?$AAC?$AAE?$AAL?$AA_?$AAP?$AAR?$AAO?$AAC?$AAE?$AAS?$AAS?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN71@Update:

; 547  : 						participantStruct->commandList[commandListIndex].command=0;

	mov	eax, DWORD PTR _commandListIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 7
	call	??A?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAUCommandStruct@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::operator[]
	mov	BYTE PTR [eax+4], 0
$LN53@Update:

; 548  : 					}
; 549  : 				}
; 550  : 				else

	jmp	SHORT $LN50@Update
$LN58@Update:

; 551  : 				{
; 552  : 					// Don't allow construction, or anything else for this object, as the construction send call is disallowed
; 553  : 					participantStruct->commandList[commandListIndex].command=0;

	mov	eax, DWORD PTR _commandListIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 7
	call	??A?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAUCommandStruct@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::operator[]
	mov	BYTE PTR [eax+4], 0
$LN50@Update:

; 554  : 				}

	jmp	SHORT $LN49@Update
$LN59@Update:

; 555  : 			}
; 556  : 			else if (command & REPLICA_IMPLICIT_CONSTRUCTION)

	movzx	eax, BYTE PTR _command$[ebp]
	and	eax, 2
	je	SHORT $LN49@Update

; 557  : 			{
; 558  : 				// Turn off this bit
; 559  : 				participantStruct->commandList[commandListIndex].command &= 0xFF ^ REPLICA_IMPLICIT_CONSTRUCTION;

	mov	eax, DWORD PTR _commandListIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 7
	call	??A?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAUCommandStruct@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::operator[]
	add	eax, 4
	mov	DWORD PTR tv259[ebp], eax
	mov	ecx, DWORD PTR tv259[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	edx, 253				; 000000fdH
	mov	eax, DWORD PTR tv259[ebp]
	mov	BYTE PTR [eax], dl

; 560  : 
; 561  : 				// Add the object to the participant's object list, indicating this object is assumed to be remotely created
; 562  : 				RemoteObject remoteObject;
; 563  : 				remoteObject.replica=replica;

	mov	eax, DWORD PTR _replica$[ebp]
	mov	DWORD PTR _remoteObject$15[ebp], eax

; 564  : 				remoteObject.inScope=defaultScope;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+42]
	mov	BYTE PTR _remoteObject$15[ebp+4], cl

; 565  : 				remoteObject.lastSendTime=0;

	mov	DWORD PTR _remoteObject$15[ebp+5], 0

; 566  : 				// Create an entry for this object.  We do this now, even if the user might refuse the SendConstruction override,
; 567  : 				// because that call may be delayed and other commands sent while that is pending.  We always do the REPLICA_EXPLICIT_CONSTRUCTION call first.
; 568  : 				participantStruct->remoteObjectList.Insert(remoteObject.replica,remoteObject);

	lea	eax, DWORD PTR _remoteObject$15[ebp]
	push	eax
	lea	ecx, DWORD PTR _remoteObject$15[ebp]
	push	ecx
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 19					; 00000013H
	call	?Insert@?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEIABQAVReplica@@ABURemoteObject@ReplicaManager@@@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::Insert
$LN49@Update:

; 569  : 			}
; 570  : 
; 571  : 			// Sends the download complete packet
; 572  : 			// If callDownloadCompleteCB is true then check all the remaining objects starting at commandListIndex
; 573  : 			// I scan every frame in case the callback returns false to delay, and after that time a new object is Replicated
; 574  : 			if (participantStruct->callDownloadCompleteCB)

	mov	eax, DWORD PTR _participantStruct$[ebp]
	movzx	ecx, BYTE PTR [eax+6]
	test	ecx, ecx
	je	$LN47@Update

; 575  : 			{
; 576  : 				bool anyHasConstruction;
; 577  : 				unsigned j;
; 578  : 				anyHasConstruction=false;

	mov	BYTE PTR _anyHasConstruction$14[ebp], 0

; 579  : 				for (j=0; j < participantStruct->commandList.Size(); j++)

	mov	DWORD PTR _j$13[ebp], 0
	jmp	SHORT $LN46@Update
$LN45@Update:
	mov	eax, DWORD PTR _j$13[ebp]
	add	eax, 1
	mov	DWORD PTR _j$13[ebp], eax
$LN46@Update:
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 7
	call	?Size@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::Size
	cmp	DWORD PTR _j$13[ebp], eax
	jae	SHORT $LN44@Update

; 580  : 				{
; 581  : 					if (participantStruct->commandList[j].command & REPLICA_EXPLICIT_CONSTRUCTION)

	mov	eax, DWORD PTR _j$13[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 7
	call	??A?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAUCommandStruct@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::operator[]
	movzx	ecx, BYTE PTR [eax+4]
	and	ecx, 1
	je	SHORT $LN43@Update

; 582  : 					{
; 583  : 						anyHasConstruction=true;

	mov	BYTE PTR _anyHasConstruction$14[ebp], 1

; 584  : 						break;

	jmp	SHORT $LN44@Update
$LN43@Update:

; 585  : 					}
; 586  : 				}

	jmp	SHORT $LN45@Update
$LN44@Update:

; 587  : 				// If none have REPLICA_EXPLICIT_CONSTRUCTION, send ID_REPLICA_MANAGER_DOWNLOAD_COMPLETE and set callDownloadCompleteCB false
; 588  : 				if (anyHasConstruction==false)

	movzx	eax, BYTE PTR _anyHasConstruction$14[ebp]
	test	eax, eax
	jne	$LN47@Update

; 589  : 				{
; 590  : 					ReplicaReturnResult sendDLComplete;
; 591  : 					userDataBitstream.Reset();

	lea	ecx, DWORD PTR _userDataBitstream$[ebp]
	call	?Reset@BitStream@RakNet@@QAEXXZ		; RakNet::BitStream::Reset

; 592  : 					if (_sendDownloadCompleteCB)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN41@Update

; 593  : 						sendDLComplete=_sendDownloadCompleteCB(&userDataBitstream, currentTime, participantStruct->playerId, this); // If you return false, this will be called again next update

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	sub	esp, 8
	mov	edx, esp
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	cx, WORD PTR [ecx+4]
	mov	WORD PTR [edx+4], cx
	mov	edx, DWORD PTR _currentTime$[ebp]
	push	edx
	lea	eax, DWORD PTR _userDataBitstream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	call	edx
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _sendDLComplete$12[ebp], eax

; 594  : 					else

	jmp	SHORT $LN40@Update
$LN41@Update:

; 595  : 						sendDLComplete=REPLICA_CANCEL_PROCESS;

	mov	DWORD PTR _sendDLComplete$12[ebp], 2
$LN40@Update:

; 596  : 					if (sendDLComplete==REPLICA_PROCESSING_DONE)

	cmp	DWORD PTR _sendDLComplete$12[ebp], 1
	jne	SHORT $LN39@Update

; 597  : 					{
; 598  : 						outBitstream.Reset();

	lea	ecx, DWORD PTR _outBitstream$[ebp]
	call	?Reset@BitStream@RakNet@@QAEXXZ		; RakNet::BitStream::Reset

; 599  : 						outBitstream.Write((unsigned char)ID_REPLICA_MANAGER_DOWNLOAD_COMPLETE);

	push	60					; 0000003cH
	lea	ecx, DWORD PTR _outBitstream$[ebp]
	call	??$Write@E@BitStream@RakNet@@QAEXE@Z	; RakNet::BitStream::Write<unsigned char>

; 600  : 						outBitstream.Write(&userDataBitstream, userDataBitstream.GetNumberOfBitsUsed());

	lea	ecx, DWORD PTR _userDataBitstream$[ebp]
	call	?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBitsUsed
	push	eax
	lea	eax, DWORD PTR _userDataBitstream$[ebp]
	push	eax
	lea	ecx, DWORD PTR _outBitstream$[ebp]
	call	?Write@BitStream@RakNet@@QAEXPAV12@H@Z	; RakNet::BitStream::Write

; 601  : 						peer->Send(&outBitstream, HIGH_PRIORITY, RELIABLE_ORDERED, sendChannel, participantStruct->playerId, false);

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR _participantStruct$[ebp]
	sub	esp, 8
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	ax, WORD PTR [eax+4]
	mov	WORD PTR [ecx+4], ax
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+40]
	push	edx
	push	3
	push	1
	lea	eax, DWORD PTR _outBitstream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _peer$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _peer$[ebp]
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 602  : 						participantStruct->callDownloadCompleteCB=false;

	mov	eax, DWORD PTR _participantStruct$[ebp]
	mov	BYTE PTR [eax+6], 0
	jmp	SHORT $LN47@Update
$LN39@Update:

; 603  : 					}
; 604  : 					else if (sendDLComplete==REPLICA_CANCEL_PROCESS)

	cmp	DWORD PTR _sendDLComplete$12[ebp], 2
	jne	SHORT $LN37@Update

; 605  : 					{
; 606  : 						participantStruct->callDownloadCompleteCB=false;

	mov	eax, DWORD PTR _participantStruct$[ebp]
	mov	BYTE PTR [eax+6], 0

; 607  : 					}
; 608  : 					else

	jmp	SHORT $LN47@Update
$LN37@Update:

; 609  : 					{
; 610  : 						assert(sendDLComplete==REPLICA_PROCESS_LATER);

	cmp	DWORD PTR _sendDLComplete$12[ebp], 0
	je	SHORT $LN47@Update
	mov	eax, DWORD PTR ?__LINE__Var@?1??Update@ReplicaManager@@MAEXPAVRakPeerInterface@@@Z@4JA
	add	eax, 161				; 000000a1H
	push	eax
	push	OFFSET ??_C@_1FG@CAHGPPEA@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAe?$AAp?$AAl?$AAi?$AAc?$AAa?$AAm@
	push	OFFSET ??_C@_1EM@HMDKKPAI@?$AAs?$AAe?$AAn?$AAd?$AAD?$AAL?$AAC?$AAo?$AAm?$AAp?$AAl?$AAe?$AAt?$AAe?$AA?$DN?$AA?$DN?$AAR?$AAE?$AAP?$AAL?$AAI?$AAC?$AAA?$AA_?$AAP?$AAR?$AAO?$AAC?$AAE?$AAS?$AAS?$AA_@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN47@Update:

; 611  : 						// else REPLICA_PROCESS_LATER
; 612  : 					}
; 613  : 					
; 614  : 				}
; 615  : 			}
; 616  : 
; 617  : 			// The remaining commands, SendScopeChange and Serialize, require the object the command references exists on the remote system, so check that
; 618  : 			remoteObjectListIndex = participantStruct->remoteObjectList.GetIndexFromKey(replica, &objectExists);

	lea	eax, DWORD PTR _objectExists$[ebp]
	push	eax
	lea	ecx, DWORD PTR _replica$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 19					; 00000013H
	call	?GetIndexFromKey@?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIABQAVReplica@@PA_N@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::GetIndexFromKey
	mov	DWORD PTR _remoteObjectListIndex$[ebp], eax

; 619  : 			if (objectExists)

	movzx	eax, BYTE PTR _objectExists$[ebp]
	test	eax, eax
	je	$LN35@Update

; 620  : 			{
; 621  : 				command = participantStruct->commandList[commandListIndex].command;

	mov	eax, DWORD PTR _commandListIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 7
	call	??A?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAUCommandStruct@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::operator[]
	mov	cl, BYTE PTR [eax+4]
	mov	BYTE PTR _command$[ebp], cl

; 622  : 
; 623  : 				// Process SendScopeChange.
; 624  : 				if ((command & (REPLICA_SCOPE_TRUE | REPLICA_SCOPE_FALSE)))

	movzx	eax, BYTE PTR _command$[ebp]
	and	eax, 12					; 0000000cH
	je	$LN34@Update

; 625  : 				{
; 626  : 					if (replica->GetNetworkID()==UNASSIGNED_NETWORK_ID)

	push	OFFSET _UNASSIGNED_NETWORK_ID
	mov	esi, esp
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _replica$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _replica$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, eax
	call	??8NetworkID@@QBE_NABU0@@Z		; NetworkID::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN33@Update

; 627  : 						continue; // Not set yet so call this later.

	jmp	$LN62@Update
$LN33@Update:

; 628  : 
; 629  : 					if (replicatedObjects[replicatedObjectsIndex].allowedInterfaces & REPLICA_SEND_SCOPE_CHANGE)

	mov	eax, DWORD PTR _replicatedObjectsIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAURegisteredReplica@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::operator[]
	movzx	ecx, BYTE PTR [eax+8]
	and	ecx, 32					; 00000020H
	je	$LN32@Update

; 630  : 					{
; 631  : 						bool scopeTrue = (command & REPLICA_SCOPE_TRUE)!=0;

	movzx	eax, BYTE PTR _command$[ebp]
	and	eax, 4
	je	SHORT $LN73@Update
	mov	DWORD PTR tv397[ebp], 1
	jmp	SHORT $LN74@Update
$LN73@Update:
	mov	DWORD PTR tv397[ebp], 0
$LN74@Update:
	mov	cl, BYTE PTR tv397[ebp]
	mov	BYTE PTR _scopeTrue$11[ebp], cl

; 632  : 
; 633  : 						// Only send scope changes if the requested change is different from what they already have
; 634  : 						if (participantStruct->remoteObjectList[remoteObjectListIndex].inScope!=scopeTrue)

	mov	eax, DWORD PTR _remoteObjectListIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 19					; 00000013H
	call	??A?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAURemoteObject@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::operator[]
	movzx	ecx, BYTE PTR [eax+4]
	movzx	edx, BYTE PTR _scopeTrue$11[ebp]
	cmp	ecx, edx
	je	$LN31@Update

; 635  : 						{
; 636  : 							userDataBitstream.Reset();

	lea	ecx, DWORD PTR _userDataBitstream$[ebp]
	call	?Reset@BitStream@RakNet@@QAEXXZ		; RakNet::BitStream::Reset

; 637  : 							res=replica->SendScopeChange(scopeTrue, &userDataBitstream, currentTime, participantStruct->playerId);

	mov	eax, DWORD PTR _participantStruct$[ebp]
	mov	esi, esp
	sub	esp, 8
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	ax, WORD PTR [eax+4]
	mov	WORD PTR [ecx+4], ax
	mov	ecx, DWORD PTR _currentTime$[ebp]
	push	ecx
	lea	edx, DWORD PTR _userDataBitstream$[ebp]
	push	edx
	movzx	eax, BYTE PTR _scopeTrue$11[ebp]
	push	eax
	mov	ecx, DWORD PTR _replica$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _replica$[ebp]
	mov	eax, DWORD PTR [edx+40]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _res$[ebp], eax

; 638  : 
; 639  : 							if (res==REPLICA_PROCESSING_DONE)

	cmp	DWORD PTR _res$[ebp], 1
	jne	$LN30@Update

; 640  : 							{
; 641  : 								// If the user returns true and does write to outBitstream, do this send.  Clear the scope change command. Then process the next command for this CommandStruct, if any.
; 642  : 								outBitstream.Reset();

	lea	ecx, DWORD PTR _outBitstream$[ebp]
	call	?Reset@BitStream@RakNet@@QAEXXZ		; RakNet::BitStream::Reset

; 643  : 								outBitstream.Write((unsigned char)ID_REPLICA_MANAGER_SCOPE_CHANGE);

	push	58					; 0000003aH
	lea	ecx, DWORD PTR _outBitstream$[ebp]
	call	??$Write@E@BitStream@RakNet@@QAEXE@Z	; RakNet::BitStream::Write<unsigned char>

; 644  : 								outBitstream.Write(replica->GetNetworkID());

	mov	esi, esp
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	mov	ecx, DWORD PTR _replica$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _replica$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	ecx, DWORD PTR _outBitstream$[ebp]
	call	??$Write@UNetworkID@@@BitStream@RakNet@@QAEXUNetworkID@@@Z ; RakNet::BitStream::Write<NetworkID>

; 645  : 								outBitstream.Write(&userDataBitstream, userDataBitstream.GetNumberOfBitsUsed());

	lea	ecx, DWORD PTR _userDataBitstream$[ebp]
	call	?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBitsUsed
	push	eax
	lea	eax, DWORD PTR _userDataBitstream$[ebp]
	push	eax
	lea	ecx, DWORD PTR _outBitstream$[ebp]
	call	?Write@BitStream@RakNet@@QAEXPAV12@H@Z	; RakNet::BitStream::Write

; 646  : 								peer->Send(&outBitstream, HIGH_PRIORITY, RELIABLE_ORDERED, sendChannel, participantStruct->playerId, false);

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR _participantStruct$[ebp]
	sub	esp, 8
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	ax, WORD PTR [eax+4]
	mov	WORD PTR [ecx+4], ax
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+40]
	push	edx
	push	3
	push	1
	lea	eax, DWORD PTR _outBitstream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _peer$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _peer$[ebp]
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 647  : 
; 648  : 								// Set the scope for this object and system
; 649  : 								participantStruct->remoteObjectList[remoteObjectListIndex].inScope=scopeTrue;

	mov	eax, DWORD PTR _remoteObjectListIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 19					; 00000013H
	call	??A?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAURemoteObject@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::operator[]
	mov	cl, BYTE PTR _scopeTrue$11[ebp]
	mov	BYTE PTR [eax+4], cl

; 650  : 
; 651  : 								// If scope is true, turn on serialize, since you virtually always want to serialize when an object goes in scope
; 652  : 								participantStruct->commandList[commandListIndex].command |= REPLICA_SERIALIZE;

	mov	eax, DWORD PTR _commandListIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 7
	call	??A?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAUCommandStruct@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::operator[]
	add	eax, 4
	mov	DWORD PTR tv458[ebp], eax
	mov	ecx, DWORD PTR tv458[ebp]
	movzx	edx, BYTE PTR [ecx]
	or	edx, 16					; 00000010H
	mov	eax, DWORD PTR tv458[ebp]
	mov	BYTE PTR [eax], dl

; 653  : 
; 654  : 								// Turn off these bits - Call is processed
; 655  : 								participantStruct->commandList[commandListIndex].command &= 0xFF ^ (REPLICA_SCOPE_TRUE | REPLICA_SCOPE_FALSE);

	mov	eax, DWORD PTR _commandListIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 7
	call	??A?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAUCommandStruct@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::operator[]
	add	eax, 4
	mov	DWORD PTR tv467[ebp], eax
	mov	ecx, DWORD PTR tv467[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	edx, 243				; 000000f3H
	mov	eax, DWORD PTR tv467[ebp]
	mov	BYTE PTR [eax], dl
	jmp	SHORT $LN31@Update
$LN30@Update:

; 656  : 							}
; 657  : 							else if (res==REPLICA_CANCEL_PROCESS)

	cmp	DWORD PTR _res$[ebp], 2
	jne	SHORT $LN28@Update

; 658  : 							{
; 659  : 								// Turn off these bits - Call is canceled
; 660  : 								participantStruct->commandList[commandListIndex].command &= 0xFF ^ (REPLICA_SCOPE_TRUE | REPLICA_SCOPE_FALSE);

	mov	eax, DWORD PTR _commandListIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 7
	call	??A?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAUCommandStruct@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::operator[]
	add	eax, 4
	mov	DWORD PTR tv477[ebp], eax
	mov	ecx, DWORD PTR tv477[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	edx, 243				; 000000f3H
	mov	eax, DWORD PTR tv477[ebp]
	mov	BYTE PTR [eax], dl

; 661  : 							}
; 662  : 							else

	jmp	SHORT $LN31@Update
$LN28@Update:

; 663  : 							{
; 664  : 								// If the user returns false and the scope is currently set to false, just continue with another CommandStruct.  Don't process serialization until scoping is resolved first.
; 665  : 								if (scopeTrue==false)

	movzx	eax, BYTE PTR _scopeTrue$11[ebp]
	test	eax, eax
	jne	SHORT $LN31@Update

; 666  : 									continue;

	jmp	$LN62@Update
$LN31@Update:

; 667  : 
; 668  : 								// If the user returns false and the scope is currently set to false, process the next command for this CommandStruct, if any.
; 669  : 							}
; 670  : 						}
; 671  : 					}
; 672  : 					else

	jmp	SHORT $LN34@Update
$LN32@Update:

; 673  : 					{
; 674  : 						// Turn off these bits - Call is disallowed
; 675  : 						participantStruct->commandList[commandListIndex].command &= 0xFF ^ (REPLICA_SCOPE_TRUE | REPLICA_SCOPE_FALSE);

	mov	eax, DWORD PTR _commandListIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 7
	call	??A?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAUCommandStruct@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::operator[]
	add	eax, 4
	mov	DWORD PTR tv488[ebp], eax
	mov	ecx, DWORD PTR tv488[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	edx, 243				; 000000f3H
	mov	eax, DWORD PTR tv488[ebp]
	mov	BYTE PTR [eax], dl

; 676  : 
; 677  : 						// Set the scope - even if the actual send is disabled we might still be able to serialize.
; 678  : 						participantStruct->remoteObjectList[remoteObjectListIndex].inScope=(command & REPLICA_SCOPE_TRUE)!=0;

	movzx	eax, BYTE PTR _command$[ebp]
	and	eax, 4
	je	SHORT $LN75@Update
	mov	DWORD PTR tv500[ebp], 1
	jmp	SHORT $LN76@Update
$LN75@Update:
	mov	DWORD PTR tv500[ebp], 0
$LN76@Update:
	mov	ecx, DWORD PTR _remoteObjectListIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 19					; 00000013H
	call	??A?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAURemoteObject@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::operator[]
	mov	dl, BYTE PTR tv500[ebp]
	mov	BYTE PTR [eax+4], dl
$LN34@Update:

; 679  : 					}
; 680  : 				}
; 681  : 
; 682  : 				command = participantStruct->commandList[commandListIndex].command;

	mov	eax, DWORD PTR _commandListIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 7
	call	??A?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAUCommandStruct@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::operator[]
	mov	cl, BYTE PTR [eax+4]
	mov	BYTE PTR _command$[ebp], cl

; 683  : 				// Process Serialize
; 684  : 				if ((participantStruct->commandList[commandListIndex].command & REPLICA_SERIALIZE))

	mov	eax, DWORD PTR _commandListIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 7
	call	??A?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAUCommandStruct@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::operator[]
	movzx	ecx, BYTE PTR [eax+4]
	and	ecx, 16					; 00000010H
	je	$LN35@Update

; 685  : 				{
; 686  : 					if (replica->GetNetworkID()==UNASSIGNED_NETWORK_ID)

	push	OFFSET _UNASSIGNED_NETWORK_ID
	mov	esi, esp
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	mov	ecx, DWORD PTR _replica$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _replica$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, eax
	call	??8NetworkID@@QBE_NABU0@@Z		; NetworkID::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN23@Update

; 687  : 						continue; // Not set yet so call this later.

	jmp	$LN62@Update
$LN23@Update:

; 688  : 
; 689  : 					// If scope is currently false for this object in the RemoteObject list, cancel this serialize as the scope changed before the serialization went out
; 690  : 					if (participantStruct->remoteObjectList[remoteObjectListIndex].inScope && (replicatedObjects[replicatedObjectsIndex].allowedInterfaces & REPLICA_SEND_SERIALIZE))

	mov	eax, DWORD PTR _remoteObjectListIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 19					; 00000013H
	call	??A?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAURemoteObject@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::operator[]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	je	$LN22@Update
	mov	eax, DWORD PTR _replicatedObjectsIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAURegisteredReplica@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::operator[]
	movzx	ecx, BYTE PTR [eax+8]
	and	ecx, 64					; 00000040H
	je	$LN22@Update
$LN21@Update:

; 691  : 					{
; 692  : 						do 
; 693  : 						{
; 694  : 							userDataBitstream.Reset();

	lea	ecx, DWORD PTR _userDataBitstream$[ebp]
	call	?Reset@BitStream@RakNet@@QAEXXZ		; RakNet::BitStream::Reset

; 695  : 							priority=HIGH_PRIORITY;

	mov	DWORD PTR _priority$[ebp], 1

; 696  : 							reliability=RELIABLE_ORDERED;

	mov	DWORD PTR _reliability$[ebp], 3

; 697  : 							sendTimestamp=false;

	mov	BYTE PTR _sendTimestamp$[ebp], 0

; 698  : 							res=replica->Serialize(&sendTimestamp, &userDataBitstream, participantStruct->remoteObjectList[remoteObjectListIndex].lastSendTime, &priority, &reliability, currentTime, participantStruct->playerId);

	mov	eax, DWORD PTR _participantStruct$[ebp]
	mov	esi, esp
	sub	esp, 8
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	ax, WORD PTR [eax+4]
	mov	WORD PTR [ecx+4], ax
	mov	ecx, DWORD PTR _currentTime$[ebp]
	push	ecx
	lea	edx, DWORD PTR _reliability$[ebp]
	push	edx
	lea	eax, DWORD PTR _priority$[ebp]
	push	eax
	mov	ecx, DWORD PTR _remoteObjectListIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 19					; 00000013H
	call	??A?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAURemoteObject@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::operator[]
	mov	edx, DWORD PTR [eax+5]
	push	edx
	lea	eax, DWORD PTR _userDataBitstream$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sendTimestamp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _replica$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _replica$[ebp]
	mov	edx, DWORD PTR [eax+48]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _res$[ebp], eax

; 699  : 
; 700  : 							if (res==REPLICA_PROCESSING_DONE || res==REPLICA_PROCESS_AGAIN)

	cmp	DWORD PTR _res$[ebp], 1
	je	SHORT $LN17@Update
	cmp	DWORD PTR _res$[ebp], 3
	jne	$LN18@Update
$LN17@Update:

; 701  : 							{
; 702  : 								participantStruct->remoteObjectList[remoteObjectListIndex].lastSendTime=currentTime;

	mov	eax, DWORD PTR _remoteObjectListIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 19					; 00000013H
	call	??A?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAURemoteObject@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::operator[]
	mov	ecx, DWORD PTR _currentTime$[ebp]
	mov	DWORD PTR [eax+5], ecx

; 703  : 
; 704  : 								outBitstream.Reset();

	lea	ecx, DWORD PTR _outBitstream$[ebp]
	call	?Reset@BitStream@RakNet@@QAEXXZ		; RakNet::BitStream::Reset

; 705  : 								if (sendTimestamp)

	movzx	eax, BYTE PTR _sendTimestamp$[ebp]
	test	eax, eax
	je	SHORT $LN16@Update

; 706  : 								{
; 707  : 									outBitstream.Write((unsigned char)ID_TIMESTAMP);

	push	36					; 00000024H
	lea	ecx, DWORD PTR _outBitstream$[ebp]
	call	??$Write@E@BitStream@RakNet@@QAEXE@Z	; RakNet::BitStream::Write<unsigned char>

; 708  : 									outBitstream.Write(currentTime);

	mov	eax, DWORD PTR _currentTime$[ebp]
	push	eax
	lea	ecx, DWORD PTR _outBitstream$[ebp]
	call	??$Write@I@BitStream@RakNet@@QAEXI@Z	; RakNet::BitStream::Write<unsigned int>
$LN16@Update:

; 709  : 								}
; 710  : 								outBitstream.Write((unsigned char)ID_REPLICA_MANAGER_SERIALIZE);

	push	59					; 0000003bH
	lea	ecx, DWORD PTR _outBitstream$[ebp]
	call	??$Write@E@BitStream@RakNet@@QAEXE@Z	; RakNet::BitStream::Write<unsigned char>

; 711  : 								outBitstream.Write(replica->GetNetworkID());

	mov	esi, esp
	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	mov	ecx, DWORD PTR _replica$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _replica$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	ecx, DWORD PTR _outBitstream$[ebp]
	call	??$Write@UNetworkID@@@BitStream@RakNet@@QAEXUNetworkID@@@Z ; RakNet::BitStream::Write<NetworkID>

; 712  : 								outBitstream.Write(&userDataBitstream, userDataBitstream.GetNumberOfBitsUsed());

	lea	ecx, DWORD PTR _userDataBitstream$[ebp]
	call	?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBitsUsed
	push	eax
	lea	eax, DWORD PTR _userDataBitstream$[ebp]
	push	eax
	lea	ecx, DWORD PTR _outBitstream$[ebp]
	call	?Write@BitStream@RakNet@@QAEXPAV12@H@Z	; RakNet::BitStream::Write

; 713  : 								peer->Send(&outBitstream, priority, reliability, sendChannel, participantStruct->playerId, false);		

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR _participantStruct$[ebp]
	sub	esp, 8
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	ax, WORD PTR [eax+4]
	mov	WORD PTR [ecx+4], ax
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+40]
	push	edx
	mov	eax, DWORD PTR _reliability$[ebp]
	push	eax
	mov	ecx, DWORD PTR _priority$[ebp]
	push	ecx
	lea	edx, DWORD PTR _outBitstream$[ebp]
	push	edx
	mov	eax, DWORD PTR _peer$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _peer$[ebp]
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 714  : 
; 715  : 								// Clear the serialize bit when done
; 716  : 								if (res==REPLICA_PROCESSING_DONE)

	cmp	DWORD PTR _res$[ebp], 1
	jne	SHORT $LN15@Update

; 717  : 									participantStruct->commandList[commandListIndex].command &= 0xFF ^ REPLICA_SERIALIZE;

	mov	eax, DWORD PTR _commandListIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 7
	call	??A?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAUCommandStruct@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::operator[]
	add	eax, 4
	mov	DWORD PTR tv611[ebp], eax
	mov	ecx, DWORD PTR tv611[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	edx, 239				; 000000efH
	mov	eax, DWORD PTR tv611[ebp]
	mov	BYTE PTR [eax], dl
$LN15@Update:

; 718  : 								// else res==REPLICA_PROCESS_AGAIN so it will repeat the enclosing do {} while(); loop
; 719  : 							}

	jmp	SHORT $LN20@Update
$LN18@Update:

; 720  : 							else if (res==REPLICA_CANCEL_PROCESS)

	cmp	DWORD PTR _res$[ebp], 2
	jne	SHORT $LN13@Update

; 721  : 							{
; 722  : 								// Clear the serialize bit
; 723  : 								participantStruct->commandList[commandListIndex].command &= 0xFF ^ REPLICA_SERIALIZE;

	mov	eax, DWORD PTR _commandListIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 7
	call	??A?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAUCommandStruct@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::operator[]
	add	eax, 4
	mov	DWORD PTR tv621[ebp], eax
	mov	ecx, DWORD PTR tv621[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	edx, 239				; 000000efH
	mov	eax, DWORD PTR tv621[ebp]
	mov	BYTE PTR [eax], dl

; 724  : 							}
; 725  : 							else

	jmp	SHORT $LN20@Update
$LN13@Update:

; 726  : 							{
; 727  : 								// if the user returns REPLICA_PROCESS_LATER, just continue with another CommandStruct.
; 728  : 								assert(res==REPLICA_PROCESS_LATER);

	cmp	DWORD PTR _res$[ebp], 0
	je	SHORT $LN20@Update
	mov	eax, DWORD PTR ?__LINE__Var@?1??Update@ReplicaManager@@MAEXPAVRakPeerInterface@@@Z@4JA
	add	eax, 279				; 00000117H
	push	eax
	push	OFFSET ??_C@_1FG@CAHGPPEA@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAe?$AAp?$AAl?$AAi?$AAc?$AAa?$AAm@
	push	OFFSET ??_C@_1DG@DECCOGIG@?$AAr?$AAe?$AAs?$AA?$DN?$AA?$DN?$AAR?$AAE?$AAP?$AAL?$AAI?$AAC?$AAA?$AA_?$AAP?$AAR?$AAO?$AAC?$AAE?$AAS?$AAS?$AA_?$AAL?$AAA?$AAT?$AAE?$AAR?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN20@Update:

; 729  : 							}
; 730  : 						} while(res==REPLICA_PROCESS_AGAIN);

	cmp	DWORD PTR _res$[ebp], 3
	je	$LN21@Update

; 731  : 					}
; 732  : 					else

	jmp	SHORT $LN35@Update
$LN22@Update:

; 733  : 					{
; 734  : 						// Cancel this serialize
; 735  : 						participantStruct->commandList[commandListIndex].command &= 0xFF ^ REPLICA_SERIALIZE;

	mov	eax, DWORD PTR _commandListIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 7
	call	??A?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAUCommandStruct@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::operator[]
	add	eax, 4
	mov	DWORD PTR tv637[ebp], eax
	mov	ecx, DWORD PTR tv637[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	edx, 239				; 000000efH
	mov	eax, DWORD PTR tv637[ebp]
	mov	BYTE PTR [eax], dl
$LN35@Update:

; 736  : 					}
; 737  : 				}
; 738  : 			}
; 739  : 		}

	jmp	$LN62@Update
$LN61@Update:

; 740  : 
; 741  : 		// Go through the command list and delete all cleared commands, from back to front.  It is more efficient to do this than to delete them as we process
; 742  : 		commandListIndex=participantStruct->commandList.Size();

	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 7
	call	?Size@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::Size
	mov	DWORD PTR _commandListIndex$[ebp], eax

; 743  : 		if (commandListIndex>0)

	cmp	DWORD PTR _commandListIndex$[ebp], 0
	jbe	SHORT $LN5@Update
$LN9@Update:

; 744  : 		{
; 745  : #ifdef _MSC_VER
; 746  : #pragma warning( disable : 4127 ) // warning C4127: conditional expression is constant
; 747  : #endif
; 748  : 			while (1)

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN5@Update

; 749  : 			{
; 750  : 				if (participantStruct->commandList[commandListIndex-1].command==0)

	mov	eax, DWORD PTR _commandListIndex$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 7
	call	??A?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAUCommandStruct@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::operator[]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN7@Update

; 751  : 				{
; 752  : 					// If this is the last item in the list, and it probably is, then it just changes a number rather than shifts the entire array
; 753  : 					participantStruct->commandList.RemoveAtIndex(commandListIndex-1);

	mov	eax, DWORD PTR _commandListIndex$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 7
	call	?RemoveAtIndex@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEXI@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::RemoveAtIndex
$LN7@Update:

; 754  : 				}
; 755  : 
; 756  : 				if (--commandListIndex==0)

	mov	eax, DWORD PTR _commandListIndex$[ebp]
	sub	eax, 1
	mov	DWORD PTR _commandListIndex$[ebp], eax
	jne	SHORT $LN6@Update

; 757  : 					break;

	jmp	SHORT $LN5@Update
$LN6@Update:

; 758  : 			}

	jmp	SHORT $LN9@Update
$LN5@Update:

; 759  : 		}
; 760  : 		
; 761  : 		// Now process queued receives
; 762  : 		while (participantStruct->pendingCommands.Size())

	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 31					; 0000001fH
	call	?Size@?$Queue@PAUReceivedCommand@ReplicaManager@@@DataStructures@@QBEIXZ ; DataStructures::Queue<ReplicaManager::ReceivedCommand *>::Size
	test	eax, eax
	je	$LN4@Update

; 763  : 		{
; 764  : 			receivedCommand=participantStruct->pendingCommands.Pop();

	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 31					; 0000001fH
	call	?Pop@?$Queue@PAUReceivedCommand@ReplicaManager@@@DataStructures@@QAEPAUReceivedCommand@ReplicaManager@@XZ ; DataStructures::Queue<ReplicaManager::ReceivedCommand *>::Pop
	mov	DWORD PTR _receivedCommand$[ebp], eax

; 765  : 			participantStruct=GetParticipantByPlayerID(receivedCommand->playerId);

	mov	eax, DWORD PTR _receivedCommand$[ebp]
	sub	esp, 8
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	ax, WORD PTR [eax+4]
	mov	WORD PTR [ecx+4], ax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetParticipantByPlayerID@ReplicaManager@@IBEPAUParticipantStruct@1@UPlayerID@@@Z ; ReplicaManager::GetParticipantByPlayerID
	mov	DWORD PTR _participantStruct$[ebp], eax

; 766  : 			if (participantStruct)

	cmp	DWORD PTR _participantStruct$[ebp], 0
	je	SHORT $LN3@Update

; 767  : 			{
; 768  : 				res=ProcessReceivedCommand(participantStruct, receivedCommand);

	mov	eax, DWORD PTR _receivedCommand$[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ProcessReceivedCommand@ReplicaManager@@IAE?AW4ReplicaReturnResult@@PAUParticipantStruct@1@PAUReceivedCommand@1@@Z ; ReplicaManager::ProcessReceivedCommand
	mov	DWORD PTR _res$[ebp], eax

; 769  : 				// Returning false means process this command again later
; 770  : 				if (res==REPLICA_PROCESS_LATER)

	cmp	DWORD PTR _res$[ebp], 0
	jne	SHORT $LN2@Update

; 771  : 				{
; 772  : 					// Push the command back in the queue
; 773  : 					participantStruct->pendingCommands.PushAtHead(receivedCommand);

	push	0
	lea	eax, DWORD PTR _receivedCommand$[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 31					; 0000001fH
	call	?PushAtHead@?$Queue@PAUReceivedCommand@ReplicaManager@@@DataStructures@@QAEXABQAUReceivedCommand@ReplicaManager@@I@Z ; DataStructures::Queue<ReplicaManager::ReceivedCommand *>::PushAtHead

; 774  : 
; 775  : 					// Stop processing, because all processing is in order
; 776  : 					break;

	jmp	$LN4@Update

; 777  : 				}
; 778  : 				else

	jmp	SHORT $LN3@Update
$LN2@Update:

; 779  : 				{
; 780  : 					assert(res==REPLICA_CANCEL_PROCESS);

	cmp	DWORD PTR _res$[ebp], 2
	je	SHORT $LN3@Update
	mov	eax, DWORD PTR ?__LINE__Var@?1??Update@ReplicaManager@@MAEXPAVRakPeerInterface@@@Z@4JA
	add	eax, 331				; 0000014bH
	push	eax
	push	OFFSET ??_C@_1FG@CAHGPPEA@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAe?$AAp?$AAl?$AAi?$AAc?$AAa?$AAm@
	push	OFFSET ??_C@_1DI@HDKFLDGG@?$AAr?$AAe?$AAs?$AA?$DN?$AA?$DN?$AAR?$AAE?$AAP?$AAL?$AAI?$AAC?$AAA?$AA_?$AAC?$AAA?$AAN?$AAC?$AAE?$AAL?$AA_?$AAP?$AAR?$AAO?$AAC?$AAE?$AAS?$AAS?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@Update:

; 781  : 				}
; 782  : 			}
; 783  : 			
; 784  : 			// Done with this command, so delete it
; 785  : 			delete receivedCommand->userData;

	mov	eax, DWORD PTR _receivedCommand$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	mov	DWORD PTR $T9[ebp], ecx
	mov	edx, DWORD PTR $T9[ebp]
	mov	DWORD PTR $T8[ebp], edx
	cmp	DWORD PTR $T8[ebp], 0
	je	SHORT $LN79@Update
	push	1
	mov	ecx, DWORD PTR $T8[ebp]
	call	??_GBitStream@RakNet@@QAEPAXI@Z
	mov	DWORD PTR tv692[ebp], eax
	jmp	SHORT $LN80@Update
$LN79@Update:
	mov	DWORD PTR tv692[ebp], 0
$LN80@Update:

; 786  : 			delete receivedCommand;

	mov	eax, DWORD PTR _receivedCommand$[ebp]
	mov	DWORD PTR $T10[ebp], eax
	mov	ecx, DWORD PTR $T10[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 787  : 		}

	jmp	$LN5@Update
$LN4@Update:

; 788  : 	}

	jmp	$LN65@Update
$LN64@Update:

; 789  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _userDataBitstream$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _outBitstream$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
$LN68@Update:
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN95@Update
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 1180				; 0000049cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$LN95@Update:
	DD	10					; 0000000aH
	DD	$LN94@Update
$LN94@Update:
	DD	-81					; ffffffafH
	DD	1
	DD	$LN83@Update
	DD	-392					; fffffe78H
	DD	273					; 00000111H
	DD	$LN84@Update
	DD	-676					; fffffd5cH
	DD	273					; 00000111H
	DD	$LN85@Update
	DD	-697					; fffffd47H
	DD	1
	DD	$LN86@Update
	DD	-712					; fffffd38H
	DD	4
	DD	$LN87@Update
	DD	-724					; fffffd2cH
	DD	4
	DD	$LN88@Update
	DD	-736					; fffffd20H
	DD	4
	DD	$LN89@Update
	DD	-748					; fffffd14H
	DD	4
	DD	$LN90@Update
	DD	-780					; fffffcf4H
	DD	9
	DD	$LN91@Update
	DD	-800					; fffffce0H
	DD	9
	DD	$LN92@Update
$LN92@Update:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	111					; 0000006fH
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	79					; 0000004fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	0
$LN91@Update:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	111					; 0000006fH
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	79					; 0000004fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	0
$LN90@Update:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	0
$LN89@Update:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	105					; 00000069H
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	0
$LN88@Update:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	97					; 00000061H
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	121					; 00000079H
	DB	0
$LN87@Update:
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	121					; 00000079H
	DB	0
$LN86@Update:
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
$LN85@Update:
	DB	117					; 00000075H
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	66					; 00000042H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	0
$LN84@Update:
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	66					; 00000042H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	0
$LN83@Update:
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Update@ReplicaManager@@MAEXPAVRakPeerInterface@@@Z$0:
	lea	ecx, DWORD PTR _outBitstream$[ebp]
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__unwindfunclet$?Update@ReplicaManager@@MAEXPAVRakPeerInterface@@@Z$1:
	lea	ecx, DWORD PTR _userDataBitstream$[ebp]
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__ehhandler$?Update@ReplicaManager@@MAEXPAVRakPeerInterface@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1184]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Update@ReplicaManager@@MAEXPAVRakPeerInterface@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Update@ReplicaManager@@MAEXPAVRakPeerInterface@@@Z ENDP ; ReplicaManager::Update
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\replicamanager.cpp
;	COMDAT ?ProcessReceivedCommand@ReplicaManager@@IAE?AW4ReplicaReturnResult@@PAUParticipantStruct@1@PAUReceivedCommand@1@@Z
_TEXT	SEGMENT
$T1 = -257						; size = 1
_b$ = -56						; size = 4
_index$ = -44						; size = 4
_objectExists$ = -29					; size = 1
_replica$ = -20						; size = 4
_this$ = -8						; size = 4
_participantStruct$ = 8					; size = 4
_receivedCommand$ = 12					; size = 4
?ProcessReceivedCommand@ReplicaManager@@IAE?AW4ReplicaReturnResult@@PAUParticipantStruct@1@PAUReceivedCommand@1@@Z PROC ; ReplicaManager::ProcessReceivedCommand, COMDAT
; _this$ = ecx

; 920  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	BYTE PTR $T1[ebp], 0

; 921  : 	Replica *replica = (Replica*) NetworkIDGenerator::GET_BASE_OBJECT_FROM_ID(receivedCommand->networkID);

	mov	eax, DWORD PTR _receivedCommand$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	mov	edx, DWORD PTR [eax+6]
	push	edx
	call	?GET_BASE_OBJECT_FROM_ID@NetworkIDGenerator@@SAPAXUNetworkID@@@Z ; NetworkIDGenerator::GET_BASE_OBJECT_FROM_ID
	add	esp, 8
	mov	DWORD PTR _replica$[ebp], eax

; 922  : 	
; 923  : 	bool objectExists;
; 924  : 	unsigned index;
; 925  : 	ReplicaReturnResult b;
; 926  : 	if (replica)

	cmp	DWORD PTR _replica$[ebp], 0
	je	SHORT $LN17@ProcessRec

; 927  : 	{
; 928  : 		index = replicatedObjects.GetIndexFromKey(replica, &objectExists);

	lea	eax, DWORD PTR _objectExists$[ebp]
	push	eax
	lea	ecx, DWORD PTR _replica$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?GetIndexFromKey@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIABQAVReplica@@PA_N@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::GetIndexFromKey
	mov	BYTE PTR $T1[ebp], 1
	mov	DWORD PTR _index$[ebp], eax

; 929  : 		if (objectExists==false)

	movzx	eax, BYTE PTR _objectExists$[ebp]
	test	eax, eax
	jne	SHORT $LN17@ProcessRec

; 930  : 		{
; 931  : 			// Two ways to handle this.  One is to autoregister the object - but this is dangerous in that if you have a network object that is not
; 932  : 			// using the replica system it would be of the wrong type, read read invalid memory, and crash.
; 933  : 			// Construct(replica, playerId, broadcast, true);
; 934  : 
; 935  : 			// The other way is to assert and do nothing.  The disadvantage is now the user has to register the object in order to receive calls on it.
; 936  : #ifdef _DEBUG
; 937  : 			// If this assert hits, call ReferencePointer on your replica pointer after it is created.
; 938  : 			assert(0);

	xor	eax, eax
	jne	SHORT $LN20@ProcessRec
	mov	ecx, DWORD PTR ?__LINE__Var@?1??ProcessReceivedCommand@ReplicaManager@@IAE?AW4ReplicaReturnResult@@PAUParticipantStruct@2@PAUReceivedCommand@2@@Z@4JA
	add	ecx, 18					; 00000012H
	push	ecx
	push	OFFSET ??_C@_1FG@CAHGPPEA@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAe?$AAp?$AAl?$AAi?$AAc?$AAa?$AAm@
	push	OFFSET ??_C@_13COJANIEC@?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN20@ProcessRec:

; 939  : #endif
; 940  : 			return REPLICA_CANCEL_PROCESS;

	mov	eax, 2
	jmp	$LN18@ProcessRec
$LN17@ProcessRec:

; 941  : 		}
; 942  : 	}
; 943  : 
; 944  : 	if (receivedCommand->command==ID_REPLICA_MANAGER_SERIALIZE)

	mov	eax, DWORD PTR _receivedCommand$[ebp]
	cmp	DWORD PTR [eax+14], 59			; 0000003bH
	jne	$LN15@ProcessRec

; 945  : 	{
; 946  : 		if (replica && (replicatedObjects[index].allowedInterfaces & REPLICA_RECEIVE_SERIALIZE))

	cmp	DWORD PTR _replica$[ebp], 0
	je	$LN14@ProcessRec
	cmp	BYTE PTR $T1[ebp], 0
	jne	SHORT $LN22@ProcessRec
	push	OFFSET $LN23@ProcessRec
	call	__RTC_UninitUse
	add	esp, 4
$LN22@ProcessRec:
	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAURegisteredReplica@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::operator[]
	movzx	ecx, BYTE PTR [eax+8]
	and	ecx, 2
	je	$LN14@ProcessRec

; 947  : 		{
; 948  : 			b=replica->Deserialize(receivedCommand->userData, receivedCommand->u1, replicatedObjects[index].lastDeserializeTrue, receivedCommand->playerId);

	cmp	BYTE PTR $T1[ebp], 0
	jne	SHORT $LN24@ProcessRec
	push	OFFSET $LN23@ProcessRec
	call	__RTC_UninitUse
	add	esp, 4
$LN24@ProcessRec:
	mov	eax, DWORD PTR _receivedCommand$[ebp]
	mov	esi, esp
	sub	esp, 8
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	ax, WORD PTR [eax+4]
	mov	WORD PTR [ecx+4], ax
	mov	ecx, DWORD PTR _index$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAURegisteredReplica@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::operator[]
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR _receivedCommand$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	mov	edx, DWORD PTR _receivedCommand$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	mov	ecx, DWORD PTR _replica$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _replica$[ebp]
	mov	eax, DWORD PTR [edx+52]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _b$[ebp], eax

; 949  : 			if (b==REPLICA_PROCESSING_DONE)

	cmp	DWORD PTR _b$[ebp], 1
	jne	SHORT $LN13@ProcessRec

; 950  : 				replicatedObjects[index].lastDeserializeTrue=RakNet::GetTime();

	cmp	BYTE PTR $T1[ebp], 0
	jne	SHORT $LN25@ProcessRec
	push	OFFSET $LN23@ProcessRec
	call	__RTC_UninitUse
	add	esp, 4
$LN25@ProcessRec:
	call	?GetTime@RakNet@@YAIXZ			; RakNet::GetTime
	mov	esi, eax
	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAURegisteredReplica@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::operator[]
	mov	DWORD PTR [eax+4], esi
$LN13@ProcessRec:

; 951  : 			return b;

	mov	eax, DWORD PTR _b$[ebp]
	jmp	$LN18@ProcessRec
$LN14@ProcessRec:

; 952  : 		}
; 953  : 	}

	jmp	$LN12@ProcessRec
$LN15@ProcessRec:

; 954  : 	else if (receivedCommand->command==ID_REPLICA_MANAGER_CONSTRUCTION)

	mov	eax, DWORD PTR _receivedCommand$[ebp]
	cmp	DWORD PTR [eax+14], 56			; 00000038H
	jne	SHORT $LN11@ProcessRec

; 955  : 	{
; 956  : 		// If networkID already exists on this system, ignore the packet
; 957  : 		if (replica==0)

	cmp	DWORD PTR _replica$[ebp], 0
	jne	SHORT $LN10@ProcessRec

; 958  : 		{
; 959  : #ifdef _DEBUG
; 960  : 			assert(_constructionCB);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+28], 0
	jne	SHORT $LN21@ProcessRec
	mov	ecx, DWORD PTR ?__LINE__Var@?1??ProcessReceivedCommand@ReplicaManager@@IAE?AW4ReplicaReturnResult@@PAUParticipantStruct@2@PAUReceivedCommand@2@@Z@4JA
	add	ecx, 40					; 00000028H
	push	ecx
	push	OFFSET ??_C@_1FG@CAHGPPEA@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAe?$AAp?$AAl?$AAi?$AAc?$AAa?$AAm@
	push	OFFSET ??_C@_1CA@HAOFBOHJ@?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AAi?$AAo?$AAn?$AAC?$AAB?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN21@ProcessRec:

; 961  : #endif
; 962  : 			// Call the registered callback.  If it crashes, you forgot to register the callback in SetReceiveConstructionCB
; 963  : 			return _constructionCB(receivedCommand->userData, receivedCommand->u1, receivedCommand->networkID, receivedCommand->playerId, this);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _receivedCommand$[ebp]
	sub	esp, 8
	mov	edx, esp
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	cx, WORD PTR [ecx+4]
	mov	WORD PTR [edx+4], cx
	mov	edx, DWORD PTR _receivedCommand$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	mov	ecx, DWORD PTR [edx+6]
	push	ecx
	mov	edx, DWORD PTR _receivedCommand$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	mov	ecx, DWORD PTR _receivedCommand$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	call	ecx
	add	esp, 28					; 0000001cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	$LN18@ProcessRec
$LN10@ProcessRec:

; 964  : 		}
; 965  : 	}

	jmp	$LN12@ProcessRec
$LN11@ProcessRec:

; 966  : 	else if (receivedCommand->command==ID_REPLICA_MANAGER_SCOPE_CHANGE)

	mov	eax, DWORD PTR _receivedCommand$[ebp]
	cmp	DWORD PTR [eax+14], 58			; 0000003aH
	jne	SHORT $LN8@ProcessRec

; 967  : 	{
; 968  : 		if (replica && (replicatedObjects[index].allowedInterfaces & REPLICA_RECEIVE_SCOPE_CHANGE))

	cmp	DWORD PTR _replica$[ebp], 0
	je	SHORT $LN7@ProcessRec
	cmp	BYTE PTR $T1[ebp], 0
	jne	SHORT $LN26@ProcessRec
	push	OFFSET $LN23@ProcessRec
	call	__RTC_UninitUse
	add	esp, 4
$LN26@ProcessRec:
	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAURegisteredReplica@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::operator[]
	movzx	ecx, BYTE PTR [eax+8]
	and	ecx, 4
	je	SHORT $LN7@ProcessRec

; 969  : 		{
; 970  : 			return replica->ReceiveScopeChange(receivedCommand->userData, receivedCommand->playerId);

	mov	eax, DWORD PTR _receivedCommand$[ebp]
	mov	esi, esp
	sub	esp, 8
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	ax, WORD PTR [eax+4]
	mov	WORD PTR [ecx+4], ax
	mov	ecx, DWORD PTR _receivedCommand$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	mov	eax, DWORD PTR _replica$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _replica$[ebp]
	mov	eax, DWORD PTR [edx+44]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	$LN18@ProcessRec
$LN7@ProcessRec:

; 971  : 		}
; 972  : 	}

	jmp	$LN12@ProcessRec
$LN8@ProcessRec:

; 973  : 	else if (receivedCommand->command==ID_REPLICA_MANAGER_DESTRUCTION)

	mov	eax, DWORD PTR _receivedCommand$[ebp]
	cmp	DWORD PTR [eax+14], 57			; 00000039H
	jne	SHORT $LN5@ProcessRec

; 974  : 	{
; 975  : 		if (replica && (replicatedObjects[index].allowedInterfaces & REPLICA_RECEIVE_DESTRUCTION))

	cmp	DWORD PTR _replica$[ebp], 0
	je	SHORT $LN4@ProcessRec
	cmp	BYTE PTR $T1[ebp], 0
	jne	SHORT $LN27@ProcessRec
	push	OFFSET $LN23@ProcessRec
	call	__RTC_UninitUse
	add	esp, 4
$LN27@ProcessRec:
	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAURegisteredReplica@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::operator[]
	movzx	ecx, BYTE PTR [eax+8]
	and	ecx, 1
	je	SHORT $LN4@ProcessRec

; 976  : 		{
; 977  : 			return replica->ReceiveDestruction(receivedCommand->userData, receivedCommand->playerId);

	mov	eax, DWORD PTR _receivedCommand$[ebp]
	mov	esi, esp
	sub	esp, 8
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	ax, WORD PTR [eax+4]
	mov	WORD PTR [ecx+4], ax
	mov	ecx, DWORD PTR _receivedCommand$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	mov	eax, DWORD PTR _replica$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _replica$[ebp]
	mov	eax, DWORD PTR [edx+36]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN18@ProcessRec
$LN4@ProcessRec:

; 978  : 		}        
; 979  : 	}

	jmp	SHORT $LN12@ProcessRec
$LN5@ProcessRec:

; 980  : 	else if (receivedCommand->command==ID_REPLICA_MANAGER_DOWNLOAD_COMPLETE)

	mov	eax, DWORD PTR _receivedCommand$[ebp]
	cmp	DWORD PTR [eax+14], 60			; 0000003cH
	jne	SHORT $LN12@ProcessRec

; 981  : 	{
; 982  : 		if (_receiveDownloadCompleteCB)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN12@ProcessRec

; 983  : 		{
; 984  : 			return _receiveDownloadCompleteCB(receivedCommand->userData, receivedCommand->playerId, this);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _receivedCommand$[ebp]
	sub	esp, 8
	mov	edx, esp
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	cx, WORD PTR [ecx+4]
	mov	WORD PTR [edx+4], cx
	mov	edx, DWORD PTR _receivedCommand$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	call	edx
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN18@ProcessRec
$LN12@ProcessRec:

; 985  : 		}
; 986  : 	}
; 987  : 
; 988  : 	return REPLICA_CANCEL_PROCESS;

	mov	eax, 2
$LN18@ProcessRec:

; 989  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN31@ProcessRec
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$LN31@ProcessRec:
	DD	2
	DD	$LN30@ProcessRec
$LN30@ProcessRec:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN28@ProcessRec
	DD	-29					; ffffffe3H
	DD	1
	DD	$LN29@ProcessRec
$LN29@ProcessRec:
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
$LN28@ProcessRec:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	0
$LN23@ProcessRec:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	0
?ProcessReceivedCommand@ReplicaManager@@IAE?AW4ReplicaReturnResult@@PAUParticipantStruct@1@PAUReceivedCommand@1@@Z ENDP ; ReplicaManager::ProcessReceivedCommand
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\replicamanager.cpp
;	COMDAT ?Clear@ReplicaManager@@IAEXXZ
_TEXT	SEGMENT
tv77 = -244						; size = 4
$T1 = -236						; size = 4
$T2 = -224						; size = 4
_i$ = -20						; size = 4
_this$ = -8						; size = 4
?Clear@ReplicaManager@@IAEXXZ PROC			; ReplicaManager::Clear, COMDAT
; _this$ = ecx

; 436  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 437  : 	// Free all memory
; 438  : 	unsigned i;
; 439  : 	for (i=0; i < participantList.Size(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@Clear
$LN2@Clear:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@Clear:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?Size@?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN1@Clear

; 440  : 		delete participantList[i];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??A?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QBEAAPAUParticipantStruct@ReplicaManager@@I@Z ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T1[ebp], edx
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN6@Clear
	push	1
	mov	ecx, DWORD PTR $T1[ebp]
	call	??_GParticipantStruct@ReplicaManager@@QAEPAXI@Z
	mov	DWORD PTR tv77[ebp], eax
	jmp	SHORT $LN7@Clear
$LN6@Clear:
	mov	DWORD PTR tv77[ebp], 0
$LN7@Clear:
	jmp	SHORT $LN2@Clear
$LN1@Clear:

; 441  : 	participantList.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?Clear@?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QAEXXZ ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::Clear

; 442  : 	replicatedObjects.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Clear@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEXXZ ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::Clear

; 443  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@ReplicaManager@@IAEXXZ ENDP			; ReplicaManager::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\replicamanager.cpp
;	COMDAT ?ParticipantStructComp@ReplicaManager@@SAHABUPlayerID@@ABQAUParticipantStruct@1@@Z
_TEXT	SEGMENT
_key$ = 8						; size = 4
_data$ = 12						; size = 4
?ParticipantStructComp@ReplicaManager@@SAHABUPlayerID@@ABQAUParticipantStruct@1@@Z PROC ; ReplicaManager::ParticipantStructComp, COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 44   : 	if (key < data->playerId)

	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _key$[ebp]
	call	??MPlayerID@@QBE_NABU0@@Z		; PlayerID::operator<
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@Participan

; 45   : 		return -1;

	or	eax, -1
	jmp	SHORT $LN3@Participan
$LN2@Participan:

; 46   : 	if (key==data->playerId)

	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _key$[ebp]
	call	??8PlayerID@@QBE_NABU0@@Z		; PlayerID::operator==
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@Participan

; 47   : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN3@Participan
$LN1@Participan:

; 48   : 	return 1;

	mov	eax, 1
$LN3@Participan:

; 49   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?ParticipantStructComp@ReplicaManager@@SAHABUPlayerID@@ABQAUParticipantStruct@1@@Z ENDP ; ReplicaManager::ParticipantStructComp
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GParticipantStruct@ReplicaManager@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GParticipantStruct@ReplicaManager@@QAEPAXI@Z PROC	; ReplicaManager::ParticipantStruct::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ParticipantStruct@ReplicaManager@@QAE@XZ ; ReplicaManager::ParticipantStruct::~ParticipantStruct
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GParticipantStruct@ReplicaManager@@QAEPAXI@Z ENDP	; ReplicaManager::ParticipantStruct::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0ParticipantStruct@ReplicaManager@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0ParticipantStruct@ReplicaManager@@QAE@XZ PROC	; ReplicaManager::ParticipantStruct::ParticipantStruct, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0ParticipantStruct@ReplicaManager@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 7
	call	??0?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 19					; 00000013H
	call	??0?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 31					; 0000001fH
	call	??0?$Queue@PAUReceivedCommand@ReplicaManager@@@DataStructures@@QAE@XZ ; DataStructures::Queue<ReplicaManager::ReceivedCommand *>::Queue<ReplicaManager::ReceivedCommand *>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ParticipantStruct@ReplicaManager@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 7
	jmp	??1?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::~OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>
__unwindfunclet$??0ParticipantStruct@ReplicaManager@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 19					; 00000013H
	jmp	??1?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::~OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>
__ehhandler$??0ParticipantStruct@ReplicaManager@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0ParticipantStruct@ReplicaManager@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0ParticipantStruct@ReplicaManager@@QAE@XZ ENDP	; ReplicaManager::ParticipantStruct::ParticipantStruct
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ?Size@?$Queue@PAUReceivedCommand@ReplicaManager@@@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$Queue@PAUReceivedCommand@ReplicaManager@@@DataStructures@@QBEIXZ PROC ; DataStructures::Queue<ReplicaManager::ReceivedCommand *>::Size, COMDAT
; _this$ = ecx

; 62   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 63   : 		if ( head <= tail )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	ja	SHORT $LN2@Size

; 64   : 			return tail -head;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	jmp	SHORT $LN3@Size

; 65   : 		else

	jmp	SHORT $LN3@Size
$LN2@Size:

; 66   : 			return allocation_size -head + tail;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx+8]
$LN3@Size:

; 67   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$Queue@PAUReceivedCommand@ReplicaManager@@@DataStructures@@QBEIXZ ENDP ; DataStructures::Queue<ReplicaManager::ReceivedCommand *>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ?Pop@?$Queue@PAUReceivedCommand@ReplicaManager@@@DataStructures@@QAEPAUReceivedCommand@ReplicaManager@@XZ
_TEXT	SEGMENT
tv78 = -208						; size = 4
_this$ = -8						; size = 4
?Pop@?$Queue@PAUReceivedCommand@ReplicaManager@@@DataStructures@@QAEPAUReceivedCommand@ReplicaManager@@XZ PROC ; DataStructures::Queue<ReplicaManager::ReceivedCommand *>::Pop, COMDAT
; _this$ = ecx

; 99   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 100  : #ifdef _DEBUG
; 101  : 		assert( allocation_size > 0 && Size() >= 0 && head != tail);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jbe	SHORT $LN5@Pop
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$Queue@PAUReceivedCommand@ReplicaManager@@@DataStructures@@QBEIXZ ; DataStructures::Queue<ReplicaManager::ReceivedCommand *>::Size
	test	eax, eax
	jb	SHORT $LN5@Pop
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN6@Pop
$LN5@Pop:
	push	101					; 00000065H
	push	OFFSET ??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@
	push	OFFSET ??_C@_1GG@JDEIIJCO@?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN6@Pop:

; 102  : #endif
; 103  : 		//head=(head+1) % allocation_size;
; 104  : 
; 105  : 		if ( ++head == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	DWORD PTR tv78[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv78[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv78[ebp]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN2@Pop

; 106  : 			head = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
$LN2@Pop:

; 107  : 
; 108  : 		if ( head == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN1@Pop

; 109  : 			return ( queue_type ) array[ allocation_size -1 ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+ecx*4-4]
	jmp	SHORT $LN3@Pop
$LN1@Pop:

; 110  : 
; 111  : 		return ( queue_type ) array[ head -1 ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+ecx*4-4]
$LN3@Pop:

; 112  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Pop@?$Queue@PAUReceivedCommand@ReplicaManager@@@DataStructures@@QAEPAUReceivedCommand@ReplicaManager@@XZ ENDP ; DataStructures::Queue<ReplicaManager::ReceivedCommand *>::Pop
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ?PushAtHead@?$Queue@PAUReceivedCommand@ReplicaManager@@@DataStructures@@QAEXABQAUReceivedCommand@ReplicaManager@@I@Z
_TEXT	SEGMENT
$T1 = -272						; size = 4
$T2 = -260						; size = 4
$T3 = -248						; size = 4
_counter$4 = -44					; size = 4
_new_array$5 = -32					; size = 4
_count$ = -20						; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
_index$ = 12						; size = 4
?PushAtHead@?$Queue@PAUReceivedCommand@ReplicaManager@@@DataStructures@@QAEXABQAUReceivedCommand@ReplicaManager@@I@Z PROC ; DataStructures::Queue<ReplicaManager::ReceivedCommand *>::PushAtHead, COMDAT
; _this$ = ecx

; 116  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-276]
	mov	ecx, 69					; 00000045H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 117  : 		if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN9@PushAtHead

; 118  : 		{
; 119  : 			array = new queue_type[ 16 ];

	push	64					; 00000040H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax], ecx

; 120  : 			head = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 121  : 			tail = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 1

; 122  : 			array[ 0 ] = input;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+eax], edx

; 123  : 			allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 16			; 00000010H

; 124  : 			return ;

	jmp	$LN10@PushAtHead
$LN9@PushAtHead:

; 125  : 		}
; 126  : 
; 127  : 		if ( head == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN8@PushAtHead

; 128  : 			head = allocation_size - 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 129  : 		else

	jmp	SHORT $LN7@PushAtHead
$LN8@PushAtHead:

; 130  : 			--head;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
$LN7@PushAtHead:

; 131  : 
; 132  : 		unsigned count=0;

	mov	DWORD PTR _count$[ebp], 0
$LN6@PushAtHead:

; 133  : 		while (count < index)

	mov	eax, DWORD PTR _count$[ebp]
	cmp	eax, DWORD PTR _index$[ebp]
	jae	SHORT $LN5@PushAtHead

; 134  : 		{
; 135  : 			array[head+count]=array[head+count+1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _count$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+4]
	add	edx, DWORD PTR _count$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+ecx*4+4]
	mov	DWORD PTR [esi+edx*4], eax

; 136  : 			count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 137  : 		}

	jmp	SHORT $LN6@PushAtHead
$LN5@PushAtHead:

; 138  : 		array[ head+count ] = input;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _count$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [eax+ecx*4], edx

; 139  : 
; 140  : 		if ( tail == head )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+4]
	jne	$LN10@PushAtHead

; 141  : 		{
; 142  : 			//  unsigned int index=tail;
; 143  : 
; 144  : 			// Need to allocate more memory.
; 145  : 			queue_type * new_array;
; 146  : 			new_array = new queue_type[ allocation_size * 2 ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	shl	eax, 1
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _new_array$5[ebp], eax

; 147  : #ifdef _DEBUG
; 148  : 
; 149  : 			assert( new_array );

	cmp	DWORD PTR _new_array$5[ebp], 0
	jne	SHORT $LN12@PushAtHead
	push	149					; 00000095H
	push	OFFSET ??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@
	push	OFFSET ??_C@_1BE@OMEGJCHO@?$AAn?$AAe?$AAw?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN12@PushAtHead:

; 150  : #endif
; 151  : 
; 152  : 			for ( unsigned int counter = 0; counter < allocation_size; ++counter )

	mov	DWORD PTR _counter$4[ebp], 0
	jmp	SHORT $LN3@PushAtHead
$LN2@PushAtHead:
	mov	eax, DWORD PTR _counter$4[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$4[ebp], eax
$LN3@PushAtHead:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _counter$4[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN1@PushAtHead

; 153  : 				new_array[ counter ] = array[ ( head + counter ) % ( allocation_size ) ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, DWORD PTR _counter$4[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _counter$4[ebp]
	mov	esi, DWORD PTR _new_array$5[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [esi+eax*4], ecx
	jmp	SHORT $LN2@PushAtHead
$LN1@PushAtHead:

; 154  : 
; 155  : 			head = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 156  : 
; 157  : 			tail = allocation_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+8], edx

; 158  : 
; 159  : 			allocation_size *= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 160  : 
; 161  : 			// Delete the old array and move the pointer to the new array
; 162  : 			delete [] array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T3[ebp], ecx
	mov	edx, DWORD PTR $T3[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 163  : 
; 164  : 			array = new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$5[ebp]
	mov	DWORD PTR [eax], ecx
$LN10@PushAtHead:

; 165  : 		}
; 166  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?PushAtHead@?$Queue@PAUReceivedCommand@ReplicaManager@@@DataStructures@@QAEXABQAUReceivedCommand@ReplicaManager@@I@Z ENDP ; DataStructures::Queue<ReplicaManager::ReceivedCommand *>::PushAtHead
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ?Push@?$Queue@PAUReceivedCommand@ReplicaManager@@@DataStructures@@QAEXABQAUReceivedCommand@ReplicaManager@@@Z
_TEXT	SEGMENT
$T1 = -260						; size = 4
$T2 = -248						; size = 4
$T3 = -236						; size = 4
_counter$4 = -32					; size = 4
_new_array$5 = -20					; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
?Push@?$Queue@PAUReceivedCommand@ReplicaManager@@@DataStructures@@QAEXABQAUReceivedCommand@ReplicaManager@@@Z PROC ; DataStructures::Queue<ReplicaManager::ReceivedCommand *>::Push, COMDAT
; _this$ = ecx

; 182  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 183  : 		if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN6@Push

; 184  : 		{
; 185  : 			array = new queue_type[ 16 ];

	push	64					; 00000040H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax], ecx

; 186  : 			head = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 187  : 			tail = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 1

; 188  : 			array[ 0 ] = input;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+eax], edx

; 189  : 			allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 16			; 00000010H

; 190  : 			return ;

	jmp	$LN7@Push
$LN6@Push:

; 191  : 		}
; 192  : 
; 193  : 		array[ tail++ ] = input;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [eax+ecx*4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 194  : 
; 195  : 		if ( tail == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN5@Push

; 196  : 			tail = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
$LN5@Push:

; 197  : 
; 198  : 		if ( tail == head )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+4]
	jne	$LN7@Push

; 199  : 		{
; 200  : 			//  unsigned int index=tail;
; 201  : 
; 202  : 			// Need to allocate more memory.
; 203  : 			queue_type * new_array;
; 204  : 			new_array = new queue_type[ allocation_size * 2 ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	shl	eax, 1
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _new_array$5[ebp], eax

; 205  : #ifdef _DEBUG
; 206  : 
; 207  : 			assert( new_array );

	cmp	DWORD PTR _new_array$5[ebp], 0
	jne	SHORT $LN9@Push
	push	207					; 000000cfH
	push	OFFSET ??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@
	push	OFFSET ??_C@_1BE@OMEGJCHO@?$AAn?$AAe?$AAw?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN9@Push:

; 208  : #endif
; 209  : 
; 210  : 			for ( unsigned int counter = 0; counter < allocation_size; ++counter )

	mov	DWORD PTR _counter$4[ebp], 0
	jmp	SHORT $LN3@Push
$LN2@Push:
	mov	eax, DWORD PTR _counter$4[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$4[ebp], eax
$LN3@Push:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _counter$4[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN1@Push

; 211  : 				new_array[ counter ] = array[ ( head + counter ) % ( allocation_size ) ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, DWORD PTR _counter$4[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _counter$4[ebp]
	mov	esi, DWORD PTR _new_array$5[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [esi+eax*4], ecx
	jmp	SHORT $LN2@Push
$LN1@Push:

; 212  : 
; 213  : 			head = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 214  : 
; 215  : 			tail = allocation_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+8], edx

; 216  : 
; 217  : 			allocation_size *= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 218  : 
; 219  : 			// Delete the old array and move the pointer to the new array
; 220  : 			delete [] array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T3[ebp], ecx
	mov	edx, DWORD PTR $T3[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 221  : 
; 222  : 			array = new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$5[ebp]
	mov	DWORD PTR [eax], ecx
$LN7@Push:

; 223  : 		}
; 224  : 
; 225  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Push@?$Queue@PAUReceivedCommand@ReplicaManager@@@DataStructures@@QAEXABQAUReceivedCommand@ReplicaManager@@@Z ENDP ; DataStructures::Queue<ReplicaManager::ReceivedCommand *>::Push
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ??1?$Queue@PAUReceivedCommand@ReplicaManager@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
??1?$Queue@PAUReceivedCommand@ReplicaManager@@@DataStructures@@QAE@XZ PROC ; DataStructures::Queue<ReplicaManager::ReceivedCommand *>::~Queue<ReplicaManager::ReceivedCommand *>, COMDAT
; _this$ = ecx

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		if (allocation_size>0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jbe	SHORT $LN2@Queue

; 94   : 			delete [] array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@Queue:

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$Queue@PAUReceivedCommand@ReplicaManager@@@DataStructures@@QAE@XZ ENDP ; DataStructures::Queue<ReplicaManager::ReceivedCommand *>::~Queue<ReplicaManager::ReceivedCommand *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ??0?$Queue@PAUReceivedCommand@ReplicaManager@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
??0?$Queue@PAUReceivedCommand@ReplicaManager@@@DataStructures@@QAE@XZ PROC ; DataStructures::Queue<ReplicaManager::ReceivedCommand *>::Queue<ReplicaManager::ReceivedCommand *>, COMDAT
; _this$ = ecx

; 83   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 84   : 		allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 16			; 00000010H

; 85   : 		array = new queue_type[ allocation_size ];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax], ecx

; 86   : 		head = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 87   : 		tail = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 88   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$Queue@PAUReceivedCommand@ReplicaManager@@@DataStructures@@QAE@XZ ENDP ; DataStructures::Queue<ReplicaManager::ReceivedCommand *>::Queue<ReplicaManager::ReceivedCommand *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Clear@?$List@URemoteObject@ReplicaManager@@@DataStructures@@QAEX_N@Z
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
_doNotDeallocate$ = 8					; size = 1
?Clear@?$List@URemoteObject@ReplicaManager@@@DataStructures@@QAEX_N@Z PROC ; DataStructures::List<ReplicaManager::RemoteObject>::Clear, COMDAT
; _this$ = ecx

; 379  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  : 		if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Clear

; 381  : 			return;

	jmp	SHORT $LN3@Clear
$LN2@Clear:

; 382  : 
; 383  : 		if (allocation_size>512 && doNotDeallocate==false)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 512			; 00000200H
	jbe	SHORT $LN1@Clear
	movzx	eax, BYTE PTR _doNotDeallocate$[ebp]
	test	eax, eax
	jne	SHORT $LN1@Clear

; 384  : 		{
; 385  : 			delete [] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 386  : 			allocation_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 387  : 			listArray = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN1@Clear:

; 388  : 		}
; 389  : 		list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
$LN3@Clear:

; 390  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Clear@?$List@URemoteObject@ReplicaManager@@@DataStructures@@QAEX_N@Z ENDP ; DataStructures::List<ReplicaManager::RemoteObject>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Size@?$List@URemoteObject@ReplicaManager@@@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$List@URemoteObject@ReplicaManager@@@DataStructures@@QBEIXZ PROC ; DataStructures::List<ReplicaManager::RemoteObject>::Size, COMDAT
; _this$ = ecx

; 373  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 374  : 		return list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 375  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$List@URemoteObject@ReplicaManager@@@DataStructures@@QBEIXZ ENDP ; DataStructures::List<ReplicaManager::RemoteObject>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Del@?$List@URemoteObject@ReplicaManager@@@DataStructures@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_num$ = 8						; size = 4
?Del@?$List@URemoteObject@ReplicaManager@@@DataStructures@@QAEXI@Z PROC ; DataStructures::List<ReplicaManager::RemoteObject>::Del, COMDAT
; _this$ = ecx

; 353  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 354  : 		// Delete the last elements on the list.  No compression needed
; 355  : #ifdef _DEBUG
; 356  : 		assert(list_size>=num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _num$[ebp]
	jae	SHORT $LN3@Del
	push	356					; 00000164H
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1BO@JBFMBKMD@?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$DO?$AA?$DN?$AAn?$AAu?$AAm?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@Del:

; 357  : #endif
; 358  : 		list_size-=num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _num$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 359  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Del@?$List@URemoteObject@ReplicaManager@@@DataStructures@@QAEXI@Z ENDP ; DataStructures::List<ReplicaManager::RemoteObject>::Del
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?RemoveAtIndex@?$List@URemoteObject@ReplicaManager@@@DataStructures@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
?RemoveAtIndex@?$List@URemoteObject@ReplicaManager@@@DataStructures@@QAEXI@Z PROC ; DataStructures::List<ReplicaManager::RemoteObject>::RemoveAtIndex, COMDAT
; _this$ = ecx

; 333  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 334  : #ifdef _DEBUG
; 335  : 		assert( position < list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN4@RemoveAtIn
	push	335					; 0000014fH
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@RemoveAtIn:

; 336  : #endif
; 337  : 
; 338  : 		if ( position < list_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN2@RemoveAtIn

; 339  : 		{
; 340  : 			// Compress the array
; 341  : 			/*
; 342  : 			for ( unsigned int counter = position; counter < list_size - 1 ; ++counter )
; 343  : 			listArray[ counter ] = listArray[ counter + 1 ];
; 344  : 			*/
; 345  : 			memmove(listArray+position, listArray+position+1, (list_size-1-position) * sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	sub	ecx, DWORD PTR _position$[ebp]
	imul	edx, ecx, 9
	push	edx
	imul	eax, DWORD PTR _position$[ebp], 9
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax+9]
	push	eax
	imul	ecx, DWORD PTR _position$[ebp], 9
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	call	_memmove
	add	esp, 12					; 0000000cH

; 346  : 
; 347  : 			Del();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Del@?$List@URemoteObject@ReplicaManager@@@DataStructures@@QAEXI@Z ; DataStructures::List<ReplicaManager::RemoteObject>::Del
$LN2@RemoveAtIn:

; 348  : 		}
; 349  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveAtIndex@?$List@URemoteObject@ReplicaManager@@@DataStructures@@QAEXI@Z ENDP ; DataStructures::List<ReplicaManager::RemoteObject>::RemoveAtIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Insert@?$List@URemoteObject@ReplicaManager@@@DataStructures@@QAEXURemoteObject@ReplicaManager@@@Z
_TEXT	SEGMENT
$T1 = -236						; size = 4
$T2 = -224						; size = 4
_new_array$3 = -20					; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 9
?Insert@?$List@URemoteObject@ReplicaManager@@@DataStructures@@QAEXURemoteObject@ReplicaManager@@@Z PROC ; DataStructures::List<ReplicaManager::RemoteObject>::Insert, COMDAT
; _this$ = ecx

; 242  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 243  : 		// Reallocate list if necessary
; 244  : 
; 245  : 		if ( list_size == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	$LN3@Insert

; 246  : 		{
; 247  : 			// allocate twice the currently allocated memory
; 248  : 			list_type * new_array;
; 249  : 
; 250  : 			if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Insert

; 251  : 				allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 16			; 00000010H

; 252  : 			else

	jmp	SHORT $LN1@Insert
$LN2@Insert:

; 253  : 				allocation_size *= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN1@Insert:

; 254  : 
; 255  : 			new_array = new list_type [ allocation_size ];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, 9
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _new_array$3[ebp], eax

; 256  : 
; 257  : 			// copy old array over
; 258  : 			//	for ( unsigned int counter = 0; counter < list_size; ++counter )
; 259  : 			//		new_array[ counter ] = listArray[ counter ];
; 260  : 
; 261  : 			// Don't call constructors, assignment operators, etc.
; 262  : 			memcpy(new_array, listArray, list_size*sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [eax+4], 9
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _new_array$3[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 263  : 
; 264  : 			// set old array to point to the newly allocated and twice as large array
; 265  : 			delete[] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 266  : 
; 267  : 			listArray = new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$3[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Insert:

; 268  : 		}
; 269  : 
; 270  : 		// Insert the new item at the correct spot
; 271  : 		listArray[ list_size ] = input;

	mov	eax, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [eax+4], 9
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, ecx
	mov	ecx, DWORD PTR _input$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _input$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	cl, BYTE PTR _input$[ebp+8]
	mov	BYTE PTR [eax+8], cl

; 272  : 
; 273  : 		++list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 274  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Insert@?$List@URemoteObject@ReplicaManager@@@DataStructures@@QAEXURemoteObject@ReplicaManager@@@Z ENDP ; DataStructures::List<ReplicaManager::RemoteObject>::Insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Insert@?$List@URemoteObject@ReplicaManager@@@DataStructures@@QAEXURemoteObject@ReplicaManager@@I@Z
_TEXT	SEGMENT
$T1 = -236						; size = 4
$T2 = -224						; size = 4
_new_array$3 = -20					; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 9
_position$ = 20						; size = 4
?Insert@?$List@URemoteObject@ReplicaManager@@@DataStructures@@QAEXURemoteObject@ReplicaManager@@I@Z PROC ; DataStructures::List<ReplicaManager::RemoteObject>::Insert, COMDAT
; _this$ = ecx

; 194  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 195  : #ifdef _DEBUG
; 196  : 		assert( position <= list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jbe	SHORT $LN6@Insert
	push	196					; 000000c4H
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CM@FMCFHBCK@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN6@Insert:

; 197  : #endif
; 198  : 
; 199  : 		// Reallocate list if necessary
; 200  : 		if ( list_size == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	$LN3@Insert

; 201  : 		{
; 202  : 			// allocate twice the currently allocated memory
; 203  : 			list_type * new_array;
; 204  : 
; 205  : 			if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Insert

; 206  : 				allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 16			; 00000010H

; 207  : 			else

	jmp	SHORT $LN1@Insert
$LN2@Insert:

; 208  : 				allocation_size *= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN1@Insert:

; 209  : 
; 210  : 			new_array = new list_type [ allocation_size ];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, 9
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _new_array$3[ebp], eax

; 211  : 
; 212  : 			// copy old array over
; 213  : 			//for ( unsigned int counter = 0; counter < list_size; ++counter )
; 214  : 			//	new_array[ counter ] = listArray[ counter ];
; 215  : 
; 216  : 			// Don't call constructors, assignment operators, etc.
; 217  : 			memcpy(new_array, listArray, list_size*sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [eax+4], 9
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _new_array$3[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 218  : 
; 219  : 			// set old array to point to the newly allocated and twice as large array
; 220  : 			delete[] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 221  : 
; 222  : 			listArray = new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$3[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Insert:

; 223  : 		}
; 224  : 
; 225  : 		// Move the elements in the list to make room
; 226  : 		//for ( unsigned int counter = list_size; counter != position; counter-- )
; 227  : 		//	listArray[ counter ] = listArray[ counter - 1 ];
; 228  : 
; 229  : 		// Don't call constructors, assignment operators, etc.
; 230  : 		memmove(listArray+position+1, listArray+position, (list_size-position)*sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _position$[ebp]
	imul	edx, ecx, 9
	push	edx
	imul	eax, DWORD PTR _position$[ebp], 9
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	push	eax
	imul	edx, DWORD PTR _position$[ebp], 9
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+edx+9]
	push	edx
	call	_memmove
	add	esp, 12					; 0000000cH

; 231  : 
; 232  : 		// Insert the new item at the correct spot
; 233  : 		listArray[ position ] = input;

	imul	eax, DWORD PTR _position$[ebp], 9
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, eax
	mov	eax, DWORD PTR _input$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _input$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	al, BYTE PTR _input$[ebp+8]
	mov	BYTE PTR [edx+8], al

; 234  : 
; 235  : 		++list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 236  : 
; 237  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Insert@?$List@URemoteObject@ReplicaManager@@@DataStructures@@QAEXURemoteObject@ReplicaManager@@I@Z ENDP ; DataStructures::List<ReplicaManager::RemoteObject>::Insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??A?$List@URemoteObject@ReplicaManager@@@DataStructures@@QBEAAURemoteObject@ReplicaManager@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
??A?$List@URemoteObject@ReplicaManager@@@DataStructures@@QBEAAURemoteObject@ReplicaManager@@I@Z PROC ; DataStructures::List<ReplicaManager::RemoteObject>::operator[], COMDAT
; _this$ = ecx

; 185  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 186  : #ifdef _DEBUG
; 187  : 		assert ( position < list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN3@operator
	push	187					; 000000bbH
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@operator:

; 188  : #endif
; 189  : 		return listArray[ position ];

	imul	eax, DWORD PTR _position$[ebp], 9
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]

; 190  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@URemoteObject@ReplicaManager@@@DataStructures@@QBEAAURemoteObject@ReplicaManager@@I@Z ENDP ; DataStructures::List<ReplicaManager::RemoteObject>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??1?$List@URemoteObject@ReplicaManager@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
??1?$List@URemoteObject@ReplicaManager@@@DataStructures@@QAE@XZ PROC ; DataStructures::List<ReplicaManager::RemoteObject>::~List<ReplicaManager::RemoteObject>, COMDAT
; _this$ = ecx

; 121  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 122  : 		if (allocation_size>0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jbe	SHORT $LN2@List

; 123  : 			delete [] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@List:

; 124  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@URemoteObject@ReplicaManager@@@DataStructures@@QAE@XZ ENDP ; DataStructures::List<ReplicaManager::RemoteObject>::~List<ReplicaManager::RemoteObject>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??0?$List@URemoteObject@ReplicaManager@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$List@URemoteObject@ReplicaManager@@@DataStructures@@QAE@XZ PROC ; DataStructures::List<ReplicaManager::RemoteObject>::List<ReplicaManager::RemoteObject>, COMDAT
; _this$ = ecx

; 113  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 114  : 		allocation_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 115  : 		listArray = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 116  : 		list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 117  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@URemoteObject@ReplicaManager@@@DataStructures@@QAE@XZ ENDP ; DataStructures::List<ReplicaManager::RemoteObject>::List<ReplicaManager::RemoteObject>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?Clear@?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Clear@?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEXXZ PROC ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::Clear, COMDAT
; _this$ = ecx

; 219  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 220  : 		orderedList.Clear();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@URemoteObject@ReplicaManager@@@DataStructures@@QAEX_N@Z ; DataStructures::List<ReplicaManager::RemoteObject>::Clear

; 221  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEXXZ ENDP ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?RemoveAtIndex@?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_index$ = 8						; size = 4
?RemoveAtIndex@?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEXI@Z PROC ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::RemoveAtIndex, COMDAT
; _this$ = ecx

; 195  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 196  : 		orderedList.RemoveAtIndex(index);

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAtIndex@?$List@URemoteObject@ReplicaManager@@@DataStructures@@QAEXI@Z ; DataStructures::List<ReplicaManager::RemoteObject>::RemoveAtIndex

; 197  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveAtIndex@?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEXI@Z ENDP ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::RemoveAtIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ??A?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAURemoteObject@ReplicaManager@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
??A?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAURemoteObject@ReplicaManager@@I@Z PROC ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::operator[], COMDAT
; _this$ = ecx

; 225  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 226  : 		return orderedList[position];

	mov	eax, DWORD PTR _position$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@URemoteObject@ReplicaManager@@@DataStructures@@QBEAAURemoteObject@ReplicaManager@@I@Z ; DataStructures::List<ReplicaManager::RemoteObject>::operator[]

; 227  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAURemoteObject@ReplicaManager@@I@Z ENDP ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?Insert@?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEIABQAVReplica@@ABURemoteObject@ReplicaManager@@@Z
_TEXT	SEGMENT
_index$ = -32						; size = 4
_objectExists$ = -17					; size = 1
_this$ = -8						; size = 4
_key$ = 8						; size = 4
_data$ = 12						; size = 4
?Insert@?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEIABQAVReplica@@ABURemoteObject@ReplicaManager@@@Z PROC ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::Insert, COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		bool objectExists;
; 158  : 		unsigned index;
; 159  : 		index = GetIndexFromKey(key, &objectExists);

	lea	eax, DWORD PTR _objectExists$[ebp]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexFromKey@?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIABQAVReplica@@PA_N@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::GetIndexFromKey
	mov	DWORD PTR _index$[ebp], eax

; 160  : 
; 161  : 		// Don't allow duplicate insertion.
; 162  : 		if (objectExists)

	movzx	eax, BYTE PTR _objectExists$[ebp]
	test	eax, eax
	je	SHORT $LN3@Insert

; 163  : 			return (unsigned)-1;

	or	eax, -1
	jmp	SHORT $LN4@Insert
$LN3@Insert:

; 164  : 
; 165  : 		if (index>=orderedList.Size())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@URemoteObject@ReplicaManager@@@DataStructures@@QBEIXZ ; DataStructures::List<ReplicaManager::RemoteObject>::Size
	cmp	DWORD PTR _index$[ebp], eax
	jb	SHORT $LN2@Insert

; 166  : 		{
; 167  : 			orderedList.Insert(data);

	mov	eax, DWORD PTR _data$[ebp]
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	al, BYTE PTR [eax+8]
	mov	BYTE PTR [ecx+8], al
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Insert@?$List@URemoteObject@ReplicaManager@@@DataStructures@@QAEXURemoteObject@ReplicaManager@@@Z ; DataStructures::List<ReplicaManager::RemoteObject>::Insert

; 168  : 			return orderedList.Size()-1;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@URemoteObject@ReplicaManager@@@DataStructures@@QBEIXZ ; DataStructures::List<ReplicaManager::RemoteObject>::Size
	sub	eax, 1
	jmp	SHORT $LN4@Insert

; 169  : 		}
; 170  : 		else

	jmp	SHORT $LN4@Insert
$LN2@Insert:

; 171  : 		{
; 172  : 			orderedList.Insert(data,index);

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	cl, BYTE PTR [ecx+8]
	mov	BYTE PTR [edx+8], cl
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Insert@?$List@URemoteObject@ReplicaManager@@@DataStructures@@QAEXURemoteObject@ReplicaManager@@I@Z ; DataStructures::List<ReplicaManager::RemoteObject>::Insert

; 173  : 			return index;

	mov	eax, DWORD PTR _index$[ebp]
$LN4@Insert:

; 174  : 		}		
; 175  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@Insert
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN8@Insert:
	DD	1
	DD	$LN7@Insert
$LN7@Insert:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN6@Insert
$LN6@Insert:
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
?Insert@?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEIABQAVReplica@@ABURemoteObject@ReplicaManager@@@Z ENDP ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::Insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?GetIndexFromKey@?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIABQAVReplica@@PA_N@Z
_TEXT	SEGMENT
_res$ = -56						; size = 4
_lowerBound$ = -44					; size = 4
_upperBound$ = -32					; size = 4
_index$ = -20						; size = 4
_this$ = -8						; size = 4
_key$ = 8						; size = 4
_objectExists$ = 12					; size = 4
?GetIndexFromKey@?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIABQAVReplica@@PA_N@Z PROC ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::GetIndexFromKey, COMDAT
; _this$ = ecx

; 110  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 111  : 		int index, upperBound, lowerBound;
; 112  : 		int res;
; 113  : 
; 114  : 		if (orderedList.Size()==0)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@URemoteObject@ReplicaManager@@@DataStructures@@QBEIXZ ; DataStructures::List<ReplicaManager::RemoteObject>::Size
	test	eax, eax
	jne	SHORT $LN8@GetIndexFr

; 115  : 		{
; 116  : 			*objectExists=false;

	mov	eax, DWORD PTR _objectExists$[ebp]
	mov	BYTE PTR [eax], 0

; 117  : 			return 0;

	xor	eax, eax
	jmp	$LN9@GetIndexFr
$LN8@GetIndexFr:

; 118  : 		}
; 119  : 
; 120  : 		upperBound=(int)orderedList.Size()-1;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@URemoteObject@ReplicaManager@@@DataStructures@@QBEIXZ ; DataStructures::List<ReplicaManager::RemoteObject>::Size
	sub	eax, 1
	mov	DWORD PTR _upperBound$[ebp], eax

; 121  : 		lowerBound=0;

	mov	DWORD PTR _lowerBound$[ebp], 0

; 122  : 		index = (int)orderedList.Size()/2;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@URemoteObject@ReplicaManager@@@DataStructures@@QBEIXZ ; DataStructures::List<ReplicaManager::RemoteObject>::Size
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _index$[ebp], eax
$LN7@GetIndexFr:

; 123  : 
; 124  : #ifdef _MSC_VER
; 125  : 	#pragma warning( disable : 4127 ) // warning C4127: conditional expression is constant
; 126  : #endif
; 127  : 		while (1)

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN9@GetIndexFr

; 128  : 		{
; 129  : 			res = comparison_function(key,orderedList[index]);

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@URemoteObject@ReplicaManager@@@DataStructures@@QBEAAURemoteObject@ReplicaManager@@I@Z ; DataStructures::List<ReplicaManager::RemoteObject>::operator[]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	call	?RemoteObjectComp@ReplicaManager@@SAHABQAVReplica@@ABURemoteObject@1@@Z ; ReplicaManager::RemoteObjectComp
	add	esp, 8
	mov	DWORD PTR _res$[ebp], eax

; 130  : 			if (res==0)

	cmp	DWORD PTR _res$[ebp], 0
	jne	SHORT $LN5@GetIndexFr

; 131  : 			{
; 132  : 				*objectExists=true;

	mov	eax, DWORD PTR _objectExists$[ebp]
	mov	BYTE PTR [eax], 1

; 133  : 				return index;

	mov	eax, DWORD PTR _index$[ebp]
	jmp	SHORT $LN9@GetIndexFr
	jmp	SHORT $LN4@GetIndexFr
$LN5@GetIndexFr:

; 134  : 			}
; 135  : 			else if (res<0)

	cmp	DWORD PTR _res$[ebp], 0
	jge	SHORT $LN3@GetIndexFr

; 136  : 			{
; 137  : 				upperBound=index-1;

	mov	eax, DWORD PTR _index$[ebp]
	sub	eax, 1
	mov	DWORD PTR _upperBound$[ebp], eax

; 138  : 			}
; 139  : 			else// if (res>0)

	jmp	SHORT $LN4@GetIndexFr
$LN3@GetIndexFr:

; 140  : 			{
; 141  : 				lowerBound=index+1;

	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 1
	mov	DWORD PTR _lowerBound$[ebp], eax
$LN4@GetIndexFr:

; 142  : 			}
; 143  : 
; 144  : 			index=lowerBound+(upperBound-lowerBound)/2;

	mov	eax, DWORD PTR _upperBound$[ebp]
	sub	eax, DWORD PTR _lowerBound$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _lowerBound$[ebp]
	mov	DWORD PTR _index$[ebp], eax

; 145  : 
; 146  : 			if (lowerBound>upperBound)

	mov	eax, DWORD PTR _lowerBound$[ebp]
	cmp	eax, DWORD PTR _upperBound$[ebp]
	jle	SHORT $LN1@GetIndexFr

; 147  : 			{
; 148  : 				*objectExists=false;

	mov	eax, DWORD PTR _objectExists$[ebp]
	mov	BYTE PTR [eax], 0

; 149  : 				return lowerBound; // No match

	mov	eax, DWORD PTR _lowerBound$[ebp]
	jmp	SHORT $LN9@GetIndexFr
$LN1@GetIndexFr:

; 150  : 			}
; 151  : 		}

	jmp	SHORT $LN7@GetIndexFr
$LN9@GetIndexFr:

; 152  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?GetIndexFromKey@?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIABQAVReplica@@PA_N@Z ENDP ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::GetIndexFromKey
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?HasData@?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBE_NABQAVReplica@@@Z
_TEXT	SEGMENT
_index$ = -32						; size = 4
_objectExists$ = -17					; size = 1
_this$ = -8						; size = 4
_key$ = 8						; size = 4
?HasData@?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBE_NABQAVReplica@@@Z PROC ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::HasData, COMDAT
; _this$ = ecx

; 91   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 92   : 		bool objectExists;
; 93   : 		unsigned index;
; 94   : 		index = GetIndexFromKey(key, &objectExists);

	lea	eax, DWORD PTR _objectExists$[ebp]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexFromKey@?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIABQAVReplica@@PA_N@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::GetIndexFromKey
	mov	DWORD PTR _index$[ebp], eax

; 95   : 		return objectExists;

	mov	al, BYTE PTR _objectExists$[ebp]

; 96   : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@HasData
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$LN5@HasData:
	DD	1
	DD	$LN4@HasData
$LN4@HasData:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN3@HasData
$LN3@HasData:
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
?HasData@?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBE_NABQAVReplica@@@Z ENDP ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::HasData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ??1?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ PROC ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::~OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>, COMDAT
; _this$ = ecx

; 72   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 73   : 		Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEXXZ ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::Clear

; 74   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$List@URemoteObject@ReplicaManager@@@DataStructures@@QAE@XZ ; DataStructures::List<ReplicaManager::RemoteObject>::~List<ReplicaManager::RemoteObject>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$List@URemoteObject@ReplicaManager@@@DataStructures@@QAE@XZ ; DataStructures::List<ReplicaManager::RemoteObject>::~List<ReplicaManager::RemoteObject>
__ehhandler$??1?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ ENDP ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::~OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ??0?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ PROC ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>, COMDAT
; _this$ = ecx

; 67   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$List@URemoteObject@ReplicaManager@@@DataStructures@@QAE@XZ ; DataStructures::List<ReplicaManager::RemoteObject>::List<ReplicaManager::RemoteObject>

; 68   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ ENDP ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Clear@?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QAEX_N@Z
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
_doNotDeallocate$ = 8					; size = 1
?Clear@?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QAEX_N@Z PROC ; DataStructures::List<ReplicaManager::CommandStruct>::Clear, COMDAT
; _this$ = ecx

; 379  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  : 		if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Clear

; 381  : 			return;

	jmp	SHORT $LN3@Clear
$LN2@Clear:

; 382  : 
; 383  : 		if (allocation_size>512 && doNotDeallocate==false)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 512			; 00000200H
	jbe	SHORT $LN1@Clear
	movzx	eax, BYTE PTR _doNotDeallocate$[ebp]
	test	eax, eax
	jne	SHORT $LN1@Clear

; 384  : 		{
; 385  : 			delete [] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 386  : 			allocation_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 387  : 			listArray = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN1@Clear:

; 388  : 		}
; 389  : 		list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
$LN3@Clear:

; 390  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Clear@?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QAEX_N@Z ENDP ; DataStructures::List<ReplicaManager::CommandStruct>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Size@?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QBEIXZ PROC ; DataStructures::List<ReplicaManager::CommandStruct>::Size, COMDAT
; _this$ = ecx

; 373  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 374  : 		return list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 375  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QBEIXZ ENDP ; DataStructures::List<ReplicaManager::CommandStruct>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Del@?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_num$ = 8						; size = 4
?Del@?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QAEXI@Z PROC ; DataStructures::List<ReplicaManager::CommandStruct>::Del, COMDAT
; _this$ = ecx

; 353  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 354  : 		// Delete the last elements on the list.  No compression needed
; 355  : #ifdef _DEBUG
; 356  : 		assert(list_size>=num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _num$[ebp]
	jae	SHORT $LN3@Del
	push	356					; 00000164H
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1BO@JBFMBKMD@?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$DO?$AA?$DN?$AAn?$AAu?$AAm?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@Del:

; 357  : #endif
; 358  : 		list_size-=num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _num$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 359  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Del@?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QAEXI@Z ENDP ; DataStructures::List<ReplicaManager::CommandStruct>::Del
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?RemoveAtIndex@?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
?RemoveAtIndex@?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QAEXI@Z PROC ; DataStructures::List<ReplicaManager::CommandStruct>::RemoveAtIndex, COMDAT
; _this$ = ecx

; 333  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 334  : #ifdef _DEBUG
; 335  : 		assert( position < list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN4@RemoveAtIn
	push	335					; 0000014fH
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@RemoveAtIn:

; 336  : #endif
; 337  : 
; 338  : 		if ( position < list_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN2@RemoveAtIn

; 339  : 		{
; 340  : 			// Compress the array
; 341  : 			/*
; 342  : 			for ( unsigned int counter = position; counter < list_size - 1 ; ++counter )
; 343  : 			listArray[ counter ] = listArray[ counter + 1 ];
; 344  : 			*/
; 345  : 			memmove(listArray+position, listArray+position+1, (list_size-1-position) * sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	sub	ecx, DWORD PTR _position$[ebp]
	imul	edx, ecx, 5
	push	edx
	imul	eax, DWORD PTR _position$[ebp], 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax+5]
	push	eax
	imul	ecx, DWORD PTR _position$[ebp], 5
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	call	_memmove
	add	esp, 12					; 0000000cH

; 346  : 
; 347  : 			Del();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Del@?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QAEXI@Z ; DataStructures::List<ReplicaManager::CommandStruct>::Del
$LN2@RemoveAtIn:

; 348  : 		}
; 349  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveAtIndex@?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QAEXI@Z ENDP ; DataStructures::List<ReplicaManager::CommandStruct>::RemoveAtIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Insert@?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QAEXUCommandStruct@ReplicaManager@@@Z
_TEXT	SEGMENT
$T1 = -236						; size = 4
$T2 = -224						; size = 4
_new_array$3 = -20					; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 5
?Insert@?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QAEXUCommandStruct@ReplicaManager@@@Z PROC ; DataStructures::List<ReplicaManager::CommandStruct>::Insert, COMDAT
; _this$ = ecx

; 242  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 243  : 		// Reallocate list if necessary
; 244  : 
; 245  : 		if ( list_size == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	$LN3@Insert

; 246  : 		{
; 247  : 			// allocate twice the currently allocated memory
; 248  : 			list_type * new_array;
; 249  : 
; 250  : 			if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Insert

; 251  : 				allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 16			; 00000010H

; 252  : 			else

	jmp	SHORT $LN1@Insert
$LN2@Insert:

; 253  : 				allocation_size *= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN1@Insert:

; 254  : 
; 255  : 			new_array = new list_type [ allocation_size ];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, 5
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _new_array$3[ebp], eax

; 256  : 
; 257  : 			// copy old array over
; 258  : 			//	for ( unsigned int counter = 0; counter < list_size; ++counter )
; 259  : 			//		new_array[ counter ] = listArray[ counter ];
; 260  : 
; 261  : 			// Don't call constructors, assignment operators, etc.
; 262  : 			memcpy(new_array, listArray, list_size*sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [eax+4], 5
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _new_array$3[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 263  : 
; 264  : 			// set old array to point to the newly allocated and twice as large array
; 265  : 			delete[] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 266  : 
; 267  : 			listArray = new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$3[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Insert:

; 268  : 		}
; 269  : 
; 270  : 		// Insert the new item at the correct spot
; 271  : 		listArray[ list_size ] = input;

	mov	eax, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [eax+4], 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, ecx
	mov	ecx, DWORD PTR _input$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dl, BYTE PTR _input$[ebp+4]
	mov	BYTE PTR [eax+4], dl

; 272  : 
; 273  : 		++list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 274  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?Insert@?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QAEXUCommandStruct@ReplicaManager@@@Z ENDP ; DataStructures::List<ReplicaManager::CommandStruct>::Insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Insert@?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QAEXUCommandStruct@ReplicaManager@@I@Z
_TEXT	SEGMENT
$T1 = -236						; size = 4
$T2 = -224						; size = 4
_new_array$3 = -20					; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 5
_position$ = 16						; size = 4
?Insert@?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QAEXUCommandStruct@ReplicaManager@@I@Z PROC ; DataStructures::List<ReplicaManager::CommandStruct>::Insert, COMDAT
; _this$ = ecx

; 194  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 195  : #ifdef _DEBUG
; 196  : 		assert( position <= list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jbe	SHORT $LN6@Insert
	push	196					; 000000c4H
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CM@FMCFHBCK@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN6@Insert:

; 197  : #endif
; 198  : 
; 199  : 		// Reallocate list if necessary
; 200  : 		if ( list_size == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	$LN3@Insert

; 201  : 		{
; 202  : 			// allocate twice the currently allocated memory
; 203  : 			list_type * new_array;
; 204  : 
; 205  : 			if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Insert

; 206  : 				allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 16			; 00000010H

; 207  : 			else

	jmp	SHORT $LN1@Insert
$LN2@Insert:

; 208  : 				allocation_size *= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN1@Insert:

; 209  : 
; 210  : 			new_array = new list_type [ allocation_size ];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, 5
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _new_array$3[ebp], eax

; 211  : 
; 212  : 			// copy old array over
; 213  : 			//for ( unsigned int counter = 0; counter < list_size; ++counter )
; 214  : 			//	new_array[ counter ] = listArray[ counter ];
; 215  : 
; 216  : 			// Don't call constructors, assignment operators, etc.
; 217  : 			memcpy(new_array, listArray, list_size*sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [eax+4], 5
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _new_array$3[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 218  : 
; 219  : 			// set old array to point to the newly allocated and twice as large array
; 220  : 			delete[] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 221  : 
; 222  : 			listArray = new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$3[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Insert:

; 223  : 		}
; 224  : 
; 225  : 		// Move the elements in the list to make room
; 226  : 		//for ( unsigned int counter = list_size; counter != position; counter-- )
; 227  : 		//	listArray[ counter ] = listArray[ counter - 1 ];
; 228  : 
; 229  : 		// Don't call constructors, assignment operators, etc.
; 230  : 		memmove(listArray+position+1, listArray+position, (list_size-position)*sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _position$[ebp]
	imul	edx, ecx, 5
	push	edx
	imul	eax, DWORD PTR _position$[ebp], 5
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	push	eax
	imul	edx, DWORD PTR _position$[ebp], 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+edx+5]
	push	edx
	call	_memmove
	add	esp, 12					; 0000000cH

; 231  : 
; 232  : 		// Insert the new item at the correct spot
; 233  : 		listArray[ position ] = input;

	imul	eax, DWORD PTR _position$[ebp], 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, eax
	mov	eax, DWORD PTR _input$[ebp]
	mov	DWORD PTR [edx], eax
	mov	cl, BYTE PTR _input$[ebp+4]
	mov	BYTE PTR [edx+4], cl

; 234  : 
; 235  : 		++list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 236  : 
; 237  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Insert@?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QAEXUCommandStruct@ReplicaManager@@I@Z ENDP ; DataStructures::List<ReplicaManager::CommandStruct>::Insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??A?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QBEAAUCommandStruct@ReplicaManager@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
??A?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QBEAAUCommandStruct@ReplicaManager@@I@Z PROC ; DataStructures::List<ReplicaManager::CommandStruct>::operator[], COMDAT
; _this$ = ecx

; 185  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 186  : #ifdef _DEBUG
; 187  : 		assert ( position < list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN3@operator
	push	187					; 000000bbH
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@operator:

; 188  : #endif
; 189  : 		return listArray[ position ];

	imul	eax, DWORD PTR _position$[ebp], 5
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]

; 190  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QBEAAUCommandStruct@ReplicaManager@@I@Z ENDP ; DataStructures::List<ReplicaManager::CommandStruct>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??1?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
??1?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QAE@XZ PROC ; DataStructures::List<ReplicaManager::CommandStruct>::~List<ReplicaManager::CommandStruct>, COMDAT
; _this$ = ecx

; 121  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 122  : 		if (allocation_size>0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jbe	SHORT $LN2@List

; 123  : 			delete [] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@List:

; 124  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QAE@XZ ENDP ; DataStructures::List<ReplicaManager::CommandStruct>::~List<ReplicaManager::CommandStruct>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??0?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QAE@XZ PROC ; DataStructures::List<ReplicaManager::CommandStruct>::List<ReplicaManager::CommandStruct>, COMDAT
; _this$ = ecx

; 113  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 114  : 		allocation_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 115  : 		listArray = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 116  : 		list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 117  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QAE@XZ ENDP ; DataStructures::List<ReplicaManager::CommandStruct>::List<ReplicaManager::CommandStruct>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?Size@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIXZ PROC ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::Size, COMDAT
; _this$ = ecx

; 231  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 232  : 		return orderedList.Size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QBEIXZ ; DataStructures::List<ReplicaManager::CommandStruct>::Size

; 233  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIXZ ENDP ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?Clear@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Clear@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEXXZ PROC ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::Clear, COMDAT
; _this$ = ecx

; 219  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 220  : 		orderedList.Clear();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QAEX_N@Z ; DataStructures::List<ReplicaManager::CommandStruct>::Clear

; 221  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEXXZ ENDP ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?RemoveAtIndex@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_index$ = 8						; size = 4
?RemoveAtIndex@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEXI@Z PROC ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::RemoveAtIndex, COMDAT
; _this$ = ecx

; 195  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 196  : 		orderedList.RemoveAtIndex(index);

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAtIndex@?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QAEXI@Z ; DataStructures::List<ReplicaManager::CommandStruct>::RemoveAtIndex

; 197  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveAtIndex@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEXI@Z ENDP ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::RemoveAtIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ??A?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAUCommandStruct@ReplicaManager@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
??A?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAUCommandStruct@ReplicaManager@@I@Z PROC ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::operator[], COMDAT
; _this$ = ecx

; 225  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 226  : 		return orderedList[position];

	mov	eax, DWORD PTR _position$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QBEAAUCommandStruct@ReplicaManager@@I@Z ; DataStructures::List<ReplicaManager::CommandStruct>::operator[]

; 227  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAUCommandStruct@ReplicaManager@@I@Z ENDP ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?Insert@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEIABQAVReplica@@ABUCommandStruct@ReplicaManager@@@Z
_TEXT	SEGMENT
_index$ = -32						; size = 4
_objectExists$ = -17					; size = 1
_this$ = -8						; size = 4
_key$ = 8						; size = 4
_data$ = 12						; size = 4
?Insert@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEIABQAVReplica@@ABUCommandStruct@ReplicaManager@@@Z PROC ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::Insert, COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		bool objectExists;
; 158  : 		unsigned index;
; 159  : 		index = GetIndexFromKey(key, &objectExists);

	lea	eax, DWORD PTR _objectExists$[ebp]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexFromKey@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIABQAVReplica@@PA_N@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::GetIndexFromKey
	mov	DWORD PTR _index$[ebp], eax

; 160  : 
; 161  : 		// Don't allow duplicate insertion.
; 162  : 		if (objectExists)

	movzx	eax, BYTE PTR _objectExists$[ebp]
	test	eax, eax
	je	SHORT $LN3@Insert

; 163  : 			return (unsigned)-1;

	or	eax, -1
	jmp	SHORT $LN4@Insert
$LN3@Insert:

; 164  : 
; 165  : 		if (index>=orderedList.Size())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QBEIXZ ; DataStructures::List<ReplicaManager::CommandStruct>::Size
	cmp	DWORD PTR _index$[ebp], eax
	jb	SHORT $LN2@Insert

; 166  : 		{
; 167  : 			orderedList.Insert(data);

	mov	eax, DWORD PTR _data$[ebp]
	sub	esp, 8
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	al, BYTE PTR [eax+4]
	mov	BYTE PTR [ecx+4], al
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Insert@?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QAEXUCommandStruct@ReplicaManager@@@Z ; DataStructures::List<ReplicaManager::CommandStruct>::Insert

; 168  : 			return orderedList.Size()-1;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QBEIXZ ; DataStructures::List<ReplicaManager::CommandStruct>::Size
	sub	eax, 1
	jmp	SHORT $LN4@Insert

; 169  : 		}
; 170  : 		else

	jmp	SHORT $LN4@Insert
$LN2@Insert:

; 171  : 		{
; 172  : 			orderedList.Insert(data,index);

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	sub	esp, 8
	mov	edx, esp
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	cl, BYTE PTR [ecx+4]
	mov	BYTE PTR [edx+4], cl
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Insert@?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QAEXUCommandStruct@ReplicaManager@@I@Z ; DataStructures::List<ReplicaManager::CommandStruct>::Insert

; 173  : 			return index;

	mov	eax, DWORD PTR _index$[ebp]
$LN4@Insert:

; 174  : 		}		
; 175  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@Insert
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN8@Insert:
	DD	1
	DD	$LN7@Insert
$LN7@Insert:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN6@Insert
$LN6@Insert:
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
?Insert@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEIABQAVReplica@@ABUCommandStruct@ReplicaManager@@@Z ENDP ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::Insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?GetIndexFromKey@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIABQAVReplica@@PA_N@Z
_TEXT	SEGMENT
_res$ = -56						; size = 4
_lowerBound$ = -44					; size = 4
_upperBound$ = -32					; size = 4
_index$ = -20						; size = 4
_this$ = -8						; size = 4
_key$ = 8						; size = 4
_objectExists$ = 12					; size = 4
?GetIndexFromKey@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIABQAVReplica@@PA_N@Z PROC ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::GetIndexFromKey, COMDAT
; _this$ = ecx

; 110  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 111  : 		int index, upperBound, lowerBound;
; 112  : 		int res;
; 113  : 
; 114  : 		if (orderedList.Size()==0)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QBEIXZ ; DataStructures::List<ReplicaManager::CommandStruct>::Size
	test	eax, eax
	jne	SHORT $LN8@GetIndexFr

; 115  : 		{
; 116  : 			*objectExists=false;

	mov	eax, DWORD PTR _objectExists$[ebp]
	mov	BYTE PTR [eax], 0

; 117  : 			return 0;

	xor	eax, eax
	jmp	$LN9@GetIndexFr
$LN8@GetIndexFr:

; 118  : 		}
; 119  : 
; 120  : 		upperBound=(int)orderedList.Size()-1;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QBEIXZ ; DataStructures::List<ReplicaManager::CommandStruct>::Size
	sub	eax, 1
	mov	DWORD PTR _upperBound$[ebp], eax

; 121  : 		lowerBound=0;

	mov	DWORD PTR _lowerBound$[ebp], 0

; 122  : 		index = (int)orderedList.Size()/2;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QBEIXZ ; DataStructures::List<ReplicaManager::CommandStruct>::Size
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _index$[ebp], eax
$LN7@GetIndexFr:

; 123  : 
; 124  : #ifdef _MSC_VER
; 125  : 	#pragma warning( disable : 4127 ) // warning C4127: conditional expression is constant
; 126  : #endif
; 127  : 		while (1)

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN9@GetIndexFr

; 128  : 		{
; 129  : 			res = comparison_function(key,orderedList[index]);

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QBEAAUCommandStruct@ReplicaManager@@I@Z ; DataStructures::List<ReplicaManager::CommandStruct>::operator[]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	call	?CommandStructComp@ReplicaManager@@SAHABQAVReplica@@ABUCommandStruct@1@@Z ; ReplicaManager::CommandStructComp
	add	esp, 8
	mov	DWORD PTR _res$[ebp], eax

; 130  : 			if (res==0)

	cmp	DWORD PTR _res$[ebp], 0
	jne	SHORT $LN5@GetIndexFr

; 131  : 			{
; 132  : 				*objectExists=true;

	mov	eax, DWORD PTR _objectExists$[ebp]
	mov	BYTE PTR [eax], 1

; 133  : 				return index;

	mov	eax, DWORD PTR _index$[ebp]
	jmp	SHORT $LN9@GetIndexFr
	jmp	SHORT $LN4@GetIndexFr
$LN5@GetIndexFr:

; 134  : 			}
; 135  : 			else if (res<0)

	cmp	DWORD PTR _res$[ebp], 0
	jge	SHORT $LN3@GetIndexFr

; 136  : 			{
; 137  : 				upperBound=index-1;

	mov	eax, DWORD PTR _index$[ebp]
	sub	eax, 1
	mov	DWORD PTR _upperBound$[ebp], eax

; 138  : 			}
; 139  : 			else// if (res>0)

	jmp	SHORT $LN4@GetIndexFr
$LN3@GetIndexFr:

; 140  : 			{
; 141  : 				lowerBound=index+1;

	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 1
	mov	DWORD PTR _lowerBound$[ebp], eax
$LN4@GetIndexFr:

; 142  : 			}
; 143  : 
; 144  : 			index=lowerBound+(upperBound-lowerBound)/2;

	mov	eax, DWORD PTR _upperBound$[ebp]
	sub	eax, DWORD PTR _lowerBound$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _lowerBound$[ebp]
	mov	DWORD PTR _index$[ebp], eax

; 145  : 
; 146  : 			if (lowerBound>upperBound)

	mov	eax, DWORD PTR _lowerBound$[ebp]
	cmp	eax, DWORD PTR _upperBound$[ebp]
	jle	SHORT $LN1@GetIndexFr

; 147  : 			{
; 148  : 				*objectExists=false;

	mov	eax, DWORD PTR _objectExists$[ebp]
	mov	BYTE PTR [eax], 0

; 149  : 				return lowerBound; // No match

	mov	eax, DWORD PTR _lowerBound$[ebp]
	jmp	SHORT $LN9@GetIndexFr
$LN1@GetIndexFr:

; 150  : 			}
; 151  : 		}

	jmp	SHORT $LN7@GetIndexFr
$LN9@GetIndexFr:

; 152  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?GetIndexFromKey@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIABQAVReplica@@PA_N@Z ENDP ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::GetIndexFromKey
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?HasData@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBE_NABQAVReplica@@@Z
_TEXT	SEGMENT
_index$ = -32						; size = 4
_objectExists$ = -17					; size = 1
_this$ = -8						; size = 4
_key$ = 8						; size = 4
?HasData@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBE_NABQAVReplica@@@Z PROC ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::HasData, COMDAT
; _this$ = ecx

; 91   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 92   : 		bool objectExists;
; 93   : 		unsigned index;
; 94   : 		index = GetIndexFromKey(key, &objectExists);

	lea	eax, DWORD PTR _objectExists$[ebp]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexFromKey@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIABQAVReplica@@PA_N@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::GetIndexFromKey
	mov	DWORD PTR _index$[ebp], eax

; 95   : 		return objectExists;

	mov	al, BYTE PTR _objectExists$[ebp]

; 96   : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@HasData
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$LN5@HasData:
	DD	1
	DD	$LN4@HasData
$LN4@HasData:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN3@HasData
$LN3@HasData:
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
?HasData@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBE_NABQAVReplica@@@Z ENDP ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::HasData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ??1?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ PROC ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::~OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>, COMDAT
; _this$ = ecx

; 72   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 73   : 		Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEXXZ ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::Clear

; 74   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QAE@XZ ; DataStructures::List<ReplicaManager::CommandStruct>::~List<ReplicaManager::CommandStruct>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QAE@XZ ; DataStructures::List<ReplicaManager::CommandStruct>::~List<ReplicaManager::CommandStruct>
__ehhandler$??1?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ ENDP ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::~OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ??0?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ PROC ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>, COMDAT
; _this$ = ecx

; 67   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$List@UCommandStruct@ReplicaManager@@@DataStructures@@QAE@XZ ; DataStructures::List<ReplicaManager::CommandStruct>::List<ReplicaManager::CommandStruct>

; 68   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ ENDP ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\replicamanager.cpp
;	COMDAT ??1ParticipantStruct@ReplicaManager@@QAE@XZ
_TEXT	SEGMENT
tv82 = -268						; size = 4
$T2 = -260						; size = 4
$T3 = -248						; size = 4
$T4 = -236						; size = 4
_receivedCommand$ = -32					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1ParticipantStruct@ReplicaManager@@QAE@XZ PROC	; ReplicaManager::ParticipantStruct::~ParticipantStruct, COMDAT
; _this$ = ecx

; 992  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1ParticipantStruct@ReplicaManager@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-268]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 2
$LN2@Participan:

; 993  : 	ReceivedCommand *receivedCommand;
; 994  : 	while ( pendingCommands.Size() )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 31					; 0000001fH
	call	?Size@?$Queue@PAUReceivedCommand@ReplicaManager@@@DataStructures@@QBEIXZ ; DataStructures::Queue<ReplicaManager::ReceivedCommand *>::Size
	test	eax, eax
	je	SHORT $LN3@Participan

; 995  : 	{
; 996  : 		receivedCommand=pendingCommands.Pop();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 31					; 0000001fH
	call	?Pop@?$Queue@PAUReceivedCommand@ReplicaManager@@@DataStructures@@QAEPAUReceivedCommand@ReplicaManager@@XZ ; DataStructures::Queue<ReplicaManager::ReceivedCommand *>::Pop
	mov	DWORD PTR _receivedCommand$[ebp], eax

; 997  : 		delete receivedCommand->userData;

	mov	eax, DWORD PTR _receivedCommand$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	mov	DWORD PTR $T3[ebp], ecx
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR $T2[ebp], edx
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN5@Participan
	push	1
	mov	ecx, DWORD PTR $T2[ebp]
	call	??_GBitStream@RakNet@@QAEPAXI@Z
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $LN6@Participan
$LN5@Participan:
	mov	DWORD PTR tv82[ebp], 0
$LN6@Participan:

; 998  : 		delete receivedCommand;

	mov	eax, DWORD PTR _receivedCommand$[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	ecx, DWORD PTR $T4[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 999  : 	}

	jmp	SHORT $LN2@Participan
$LN3@Participan:

; 1000 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 31					; 0000001fH
	call	??1?$Queue@PAUReceivedCommand@ReplicaManager@@@DataStructures@@QAE@XZ ; DataStructures::Queue<ReplicaManager::ReceivedCommand *>::~Queue<ReplicaManager::ReceivedCommand *>
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 19					; 00000013H
	call	??1?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::~OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 7
	call	??1?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::~OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 268				; 0000010cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1ParticipantStruct@ReplicaManager@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 7
	jmp	??1?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::~OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>
__unwindfunclet$??1ParticipantStruct@ReplicaManager@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 19					; 00000013H
	jmp	??1?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::~OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>
__unwindfunclet$??1ParticipantStruct@ReplicaManager@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 31					; 0000001fH
	jmp	??1?$Queue@PAUReceivedCommand@ReplicaManager@@@DataStructures@@QAE@XZ ; DataStructures::Queue<ReplicaManager::ReceivedCommand *>::~Queue<ReplicaManager::ReceivedCommand *>
__ehhandler$??1ParticipantStruct@ReplicaManager@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-272]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1ParticipantStruct@ReplicaManager@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1ParticipantStruct@ReplicaManager@@QAE@XZ ENDP	; ReplicaManager::ParticipantStruct::~ParticipantStruct
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\replicamanager.cpp
;	COMDAT ?CommandStructComp@ReplicaManager@@SAHABQAVReplica@@ABUCommandStruct@1@@Z
_TEXT	SEGMENT
_key$ = 8						; size = 4
_data$ = 12						; size = 4
?CommandStructComp@ReplicaManager@@SAHABQAVReplica@@ABUCommandStruct@1@@Z PROC ; ReplicaManager::CommandStructComp, COMDAT

; 16   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 17   : 	if (key < data.replica)

	mov	eax, DWORD PTR _key$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jae	SHORT $LN2@CommandStr

; 18   : 		return -1;

	or	eax, -1
	jmp	SHORT $LN3@CommandStr
$LN2@CommandStr:

; 19   : 	if (key==data.replica)

	mov	eax, DWORD PTR _key$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN1@CommandStr

; 20   : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN3@CommandStr
$LN1@CommandStr:

; 21   : 	return 1;

	mov	eax, 1
$LN3@CommandStr:

; 22   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CommandStructComp@ReplicaManager@@SAHABQAVReplica@@ABUCommandStruct@1@@Z ENDP ; ReplicaManager::CommandStructComp
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\replicamanager.cpp
;	COMDAT ?RemoteObjectComp@ReplicaManager@@SAHABQAVReplica@@ABURemoteObject@1@@Z
_TEXT	SEGMENT
_key$ = 8						; size = 4
_data$ = 12						; size = 4
?RemoteObjectComp@ReplicaManager@@SAHABQAVReplica@@ABURemoteObject@1@@Z PROC ; ReplicaManager::RemoteObjectComp, COMDAT

; 34   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 35   : 	if (key < data.replica)

	mov	eax, DWORD PTR _key$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jae	SHORT $LN2@RemoteObje

; 36   : 		return -1;

	or	eax, -1
	jmp	SHORT $LN3@RemoteObje
$LN2@RemoteObje:

; 37   : 	if (key==data.replica)

	mov	eax, DWORD PTR _key$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN1@RemoteObje

; 38   : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN3@RemoteObje
$LN1@RemoteObje:

; 39   : 	return 1;

	mov	eax, 1
$LN3@RemoteObje:

; 40   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoteObjectComp@ReplicaManager@@SAHABQAVReplica@@ABURemoteObject@1@@Z ENDP ; ReplicaManager::RemoteObjectComp
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\replicamanager.cpp
;	COMDAT ?RegisteredReplicaComp@ReplicaManager@@SAHABQAVReplica@@ABURegisteredReplica@1@@Z
_TEXT	SEGMENT
_key$ = 8						; size = 4
_data$ = 12						; size = 4
?RegisteredReplicaComp@ReplicaManager@@SAHABQAVReplica@@ABURegisteredReplica@1@@Z PROC ; ReplicaManager::RegisteredReplicaComp, COMDAT

; 25   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 26   : 	if (key < data.replica)

	mov	eax, DWORD PTR _key$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jae	SHORT $LN2@Registered

; 27   : 		return -1;

	or	eax, -1
	jmp	SHORT $LN3@Registered
$LN2@Registered:

; 28   : 	if (key==data.replica)

	mov	eax, DWORD PTR _key$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN1@Registered

; 29   : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN3@Registered
$LN1@Registered:

; 30   : 	return 1;

	mov	eax, 1
$LN3@Registered:

; 31   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RegisteredReplicaComp@ReplicaManager@@SAHABQAVReplica@@ABURegisteredReplica@1@@Z ENDP ; ReplicaManager::RegisteredReplicaComp
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\replicamanager.cpp
;	COMDAT ?GetReplicaAtIndex@ReplicaManager@@QAEPAVReplica@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_index$ = 8						; size = 4
?GetReplicaAtIndex@ReplicaManager@@QAEPAVReplica@@I@Z PROC ; ReplicaManager::GetReplicaAtIndex, COMDAT
; _this$ = ecx

; 432  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 433  : 	return replicatedObjects[index].replica;

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAURegisteredReplica@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::operator[]
	mov	eax, DWORD PTR [eax]

; 434  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetReplicaAtIndex@ReplicaManager@@QAEPAVReplica@@I@Z ENDP ; ReplicaManager::GetReplicaAtIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\replicamanager.cpp
;	COMDAT ?GetReplicaCount@ReplicaManager@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetReplicaCount@ReplicaManager@@QBEIXZ PROC		; ReplicaManager::GetReplicaCount, COMDAT
; _this$ = ecx

; 428  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 429  : 	return replicatedObjects.Size();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Size@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::Size

; 430  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetReplicaCount@ReplicaManager@@QBEIXZ ENDP		; ReplicaManager::GetReplicaCount
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\replicamanager.cpp
;	COMDAT ?IsInScope@ReplicaManager@@QAE_NPAVReplica@@UPlayerID@@@Z
_TEXT	SEGMENT
_remoteObjectListIndex$1 = -44				; size = 4
_objectExists$2 = -29					; size = 1
_participantStruct$ = -20				; size = 4
_this$ = -8						; size = 4
_replica$ = 8						; size = 4
_playerId$ = 12						; size = 6
?IsInScope@ReplicaManager@@QAE_NPAVReplica@@UPlayerID@@@Z PROC ; ReplicaManager::IsInScope, COMDAT
; _this$ = ecx

; 416  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 417  : 	ParticipantStruct *participantStruct = GetParticipantByPlayerID(playerId);

	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetParticipantByPlayerID@ReplicaManager@@IBEPAUParticipantStruct@1@UPlayerID@@@Z ; ReplicaManager::GetParticipantByPlayerID
	mov	DWORD PTR _participantStruct$[ebp], eax

; 418  : 	if (participantStruct)

	cmp	DWORD PTR _participantStruct$[ebp], 0
	je	SHORT $LN2@IsInScope

; 419  : 	{
; 420  : 		bool objectExists;
; 421  : 		unsigned remoteObjectListIndex = participantStruct->remoteObjectList.GetIndexFromKey(replica, &objectExists);

	lea	eax, DWORD PTR _objectExists$2[ebp]
	push	eax
	lea	ecx, DWORD PTR _replica$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 19					; 00000013H
	call	?GetIndexFromKey@?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIABQAVReplica@@PA_N@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::GetIndexFromKey
	mov	DWORD PTR _remoteObjectListIndex$1[ebp], eax

; 422  : 		if (objectExists)

	movzx	eax, BYTE PTR _objectExists$2[ebp]
	test	eax, eax
	je	SHORT $LN2@IsInScope

; 423  : 			return participantStruct->remoteObjectList[remoteObjectListIndex].inScope;

	mov	eax, DWORD PTR _remoteObjectListIndex$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 19					; 00000013H
	call	??A?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAURemoteObject@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::operator[]
	mov	al, BYTE PTR [eax+4]
	jmp	SHORT $LN3@IsInScope
$LN2@IsInScope:

; 424  : 	}
; 425  : 	return false;

	xor	al, al
$LN3@IsInScope:

; 426  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@IsInScope
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	3
$LN7@IsInScope:
	DD	1
	DD	$LN6@IsInScope
$LN6@IsInScope:
	DD	-29					; ffffffe3H
	DD	1
	DD	$LN5@IsInScope
$LN5@IsInScope:
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
?IsInScope@ReplicaManager@@QAE_NPAVReplica@@UPlayerID@@@Z ENDP ; ReplicaManager::IsInScope
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\replicamanager.cpp
;	COMDAT ?IsConstructed@ReplicaManager@@QAE_NPAVReplica@@UPlayerID@@@Z
_TEXT	SEGMENT
_objectExists$1 = -29					; size = 1
_participantStruct$ = -20				; size = 4
_this$ = -8						; size = 4
_replica$ = 8						; size = 4
_playerId$ = 12						; size = 6
?IsConstructed@ReplicaManager@@QAE_NPAVReplica@@UPlayerID@@@Z PROC ; ReplicaManager::IsConstructed, COMDAT
; _this$ = ecx

; 405  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 406  : 	ParticipantStruct *participantStruct = GetParticipantByPlayerID(playerId);

	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetParticipantByPlayerID@ReplicaManager@@IBEPAUParticipantStruct@1@UPlayerID@@@Z ; ReplicaManager::GetParticipantByPlayerID
	mov	DWORD PTR _participantStruct$[ebp], eax

; 407  : 	if (participantStruct)

	cmp	DWORD PTR _participantStruct$[ebp], 0
	je	SHORT $LN1@IsConstruc

; 408  : 	{
; 409  : 		bool objectExists;
; 410  : 		participantStruct->remoteObjectList.GetIndexFromKey(replica, &objectExists);

	lea	eax, DWORD PTR _objectExists$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _replica$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 19					; 00000013H
	call	?GetIndexFromKey@?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIABQAVReplica@@PA_N@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::GetIndexFromKey

; 411  : 		return objectExists;

	mov	al, BYTE PTR _objectExists$1[ebp]
	jmp	SHORT $LN2@IsConstruc
$LN1@IsConstruc:

; 412  : 	}
; 413  : 	return false;

	xor	al, al
$LN2@IsConstruc:

; 414  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@IsConstruc
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	1
$LN6@IsConstruc:
	DD	1
	DD	$LN5@IsConstruc
$LN5@IsConstruc:
	DD	-29					; ffffffe3H
	DD	1
	DD	$LN4@IsConstruc
$LN4@IsConstruc:
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
?IsConstructed@ReplicaManager@@QAE_NPAVReplica@@UPlayerID@@@Z ENDP ; ReplicaManager::IsConstructed
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\replicamanager.cpp
;	COMDAT ?DisableReplicaInterfaces@ReplicaManager@@QAEXPAVReplica@@E@Z
_TEXT	SEGMENT
tv85 = -232						; size = 4
_replicatedObjectsIndex$ = -32				; size = 4
_objectExists$ = -17					; size = 1
_this$ = -8						; size = 4
_replica$ = 8						; size = 4
_interfaceFlags$ = 12					; size = 1
?DisableReplicaInterfaces@ReplicaManager@@QAEXPAVReplica@@E@Z PROC ; ReplicaManager::DisableReplicaInterfaces, COMDAT
; _this$ = ecx

; 391  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 392  : 	bool objectExists;
; 393  : 	unsigned replicatedObjectsIndex;
; 394  : 	replicatedObjectsIndex = replicatedObjects.GetIndexFromKey(replica, &objectExists);

	lea	eax, DWORD PTR _objectExists$[ebp]
	push	eax
	lea	ecx, DWORD PTR _replica$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?GetIndexFromKey@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIABQAVReplica@@PA_N@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::GetIndexFromKey
	mov	DWORD PTR _replicatedObjectsIndex$[ebp], eax

; 395  : 	if (objectExists==false)

	movzx	eax, BYTE PTR _objectExists$[ebp]
	test	eax, eax
	jne	SHORT $LN1@DisableRep

; 396  : 	{
; 397  : 		// Autoreference the pointer if necessary.  This way the user can call functions on an object without having to worry
; 398  : 		// About the order of operations.
; 399  : 		ReferencePointer(replica);

	mov	eax, DWORD PTR _replica$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReferencePointer@ReplicaManager@@QAEXPAVReplica@@@Z ; ReplicaManager::ReferencePointer

; 400  : 		replicatedObjectsIndex = replicatedObjects.GetIndexFromKey(replica, &objectExists);

	lea	eax, DWORD PTR _objectExists$[ebp]
	push	eax
	lea	ecx, DWORD PTR _replica$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?GetIndexFromKey@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIABQAVReplica@@PA_N@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::GetIndexFromKey
	mov	DWORD PTR _replicatedObjectsIndex$[ebp], eax
$LN1@DisableRep:

; 401  : 	}
; 402  : 	replicatedObjects[replicatedObjectsIndex].allowedInterfaces&= 0xFF ^ interfaceFlags;

	mov	eax, DWORD PTR _replicatedObjectsIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAURegisteredReplica@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::operator[]
	add	eax, 8
	mov	DWORD PTR tv85[ebp], eax
	movzx	ecx, BYTE PTR _interfaceFlags$[ebp]
	xor	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR tv85[ebp]
	movzx	eax, BYTE PTR [edx]
	and	eax, ecx
	mov	ecx, DWORD PTR tv85[ebp]
	mov	BYTE PTR [ecx], al

; 403  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@DisableRep
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN6@DisableRep:
	DD	1
	DD	$LN5@DisableRep
$LN5@DisableRep:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@DisableRep
$LN4@DisableRep:
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
?DisableReplicaInterfaces@ReplicaManager@@QAEXPAVReplica@@E@Z ENDP ; ReplicaManager::DisableReplicaInterfaces
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\replicamanager.cpp
;	COMDAT ?EnableReplicaInterfaces@ReplicaManager@@QAEXPAVReplica@@E@Z
_TEXT	SEGMENT
tv84 = -232						; size = 4
_replicatedObjectsIndex$ = -32				; size = 4
_objectExists$ = -17					; size = 1
_this$ = -8						; size = 4
_replica$ = 8						; size = 4
_interfaceFlags$ = 12					; size = 1
?EnableReplicaInterfaces@ReplicaManager@@QAEXPAVReplica@@E@Z PROC ; ReplicaManager::EnableReplicaInterfaces, COMDAT
; _this$ = ecx

; 377  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 378  : 	bool objectExists;
; 379  : 	unsigned replicatedObjectsIndex;
; 380  : 	replicatedObjectsIndex = replicatedObjects.GetIndexFromKey(replica, &objectExists);

	lea	eax, DWORD PTR _objectExists$[ebp]
	push	eax
	lea	ecx, DWORD PTR _replica$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?GetIndexFromKey@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIABQAVReplica@@PA_N@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::GetIndexFromKey
	mov	DWORD PTR _replicatedObjectsIndex$[ebp], eax

; 381  : 	if (objectExists==false)

	movzx	eax, BYTE PTR _objectExists$[ebp]
	test	eax, eax
	jne	SHORT $LN1@EnableRepl

; 382  : 	{
; 383  : 		// Autoreference the pointer if necessary.  This way the user can call functions on an object without having to worry
; 384  : 		// About the order of operations.
; 385  : 		ReferencePointer(replica);

	mov	eax, DWORD PTR _replica$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReferencePointer@ReplicaManager@@QAEXPAVReplica@@@Z ; ReplicaManager::ReferencePointer

; 386  : 		replicatedObjectsIndex = replicatedObjects.GetIndexFromKey(replica, &objectExists);

	lea	eax, DWORD PTR _objectExists$[ebp]
	push	eax
	lea	ecx, DWORD PTR _replica$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?GetIndexFromKey@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIABQAVReplica@@PA_N@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::GetIndexFromKey
	mov	DWORD PTR _replicatedObjectsIndex$[ebp], eax
$LN1@EnableRepl:

; 387  : 	}
; 388  : 	replicatedObjects[replicatedObjectsIndex].allowedInterfaces|=interfaceFlags;

	mov	eax, DWORD PTR _replicatedObjectsIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAURegisteredReplica@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::operator[]
	add	eax, 8
	mov	DWORD PTR tv84[ebp], eax
	movzx	ecx, BYTE PTR _interfaceFlags$[ebp]
	mov	edx, DWORD PTR tv84[ebp]
	movzx	eax, BYTE PTR [edx]
	or	eax, ecx
	mov	ecx, DWORD PTR tv84[ebp]
	mov	BYTE PTR [ecx], al

; 389  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@EnableRepl
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN6@EnableRepl:
	DD	1
	DD	$LN5@EnableRepl
$LN5@EnableRepl:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN4@EnableRepl
$LN4@EnableRepl:
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
?EnableReplicaInterfaces@ReplicaManager@@QAEXPAVReplica@@E@Z ENDP ; ReplicaManager::EnableReplicaInterfaces
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\replicamanager.cpp
;	COMDAT ?SetDefaultScope@ReplicaManager@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_scope$ = 8						; size = 1
?SetDefaultScope@ReplicaManager@@QAEX_N@Z PROC		; ReplicaManager::SetDefaultScope, COMDAT
; _this$ = ecx

; 373  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 374  : 	defaultScope=scope;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _scope$[ebp]
	mov	BYTE PTR [eax+42], cl

; 375  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetDefaultScope@ReplicaManager@@QAEX_N@Z ENDP		; ReplicaManager::SetDefaultScope
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\replicamanager.cpp
;	COMDAT ?SetAutoConstructToNewParticipants@ReplicaManager@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_autoConstruct$ = 8					; size = 1
?SetAutoConstructToNewParticipants@ReplicaManager@@QAEX_N@Z PROC ; ReplicaManager::SetAutoConstructToNewParticipants, COMDAT
; _this$ = ecx

; 369  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 370  : 	autoConstructToNewParticipants=autoConstruct;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _autoConstruct$[ebp]
	mov	BYTE PTR [eax+43], cl

; 371  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetAutoConstructToNewParticipants@ReplicaManager@@QAEX_N@Z ENDP ; ReplicaManager::SetAutoConstructToNewParticipants
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\replicamanager.cpp
;	COMDAT ?SetSendChannel@ReplicaManager@@QAEXE@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_channel$ = 8						; size = 1
?SetSendChannel@ReplicaManager@@QAEXE@Z PROC		; ReplicaManager::SetSendChannel, COMDAT
; _this$ = ecx

; 364  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 365  : 	// Change the send channel from the default of 0
; 366  : 	sendChannel=channel;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _channel$[ebp]
	mov	BYTE PTR [eax+40], cl

; 367  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSendChannel@ReplicaManager@@QAEXE@Z ENDP		; ReplicaManager::SetSendChannel
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\replicamanager.cpp
;	COMDAT ?SetDownloadCompleteCB@ReplicaManager@@QAEXP6A?AW4ReplicaReturnResult@@PAVBitStream@RakNet@@IUPlayerID@@PAV1@@ZP6A?AW42@012@Z@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_sendDownloadCompleteCB$ = 8				; size = 4
_receiveDownloadCompleteCB$ = 12			; size = 4
?SetDownloadCompleteCB@ReplicaManager@@QAEXP6A?AW4ReplicaReturnResult@@PAVBitStream@RakNet@@IUPlayerID@@PAV1@@ZP6A?AW42@012@Z@Z PROC ; ReplicaManager::SetDownloadCompleteCB, COMDAT
; _this$ = ecx

; 358  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 359  : 	// Just overwrite the send and receive download complete pointers.
; 360  : 	_sendDownloadCompleteCB=sendDownloadCompleteCB;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _sendDownloadCompleteCB$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 361  : 	_receiveDownloadCompleteCB=receiveDownloadCompleteCB;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _receiveDownloadCompleteCB$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 362  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetDownloadCompleteCB@ReplicaManager@@QAEXP6A?AW4ReplicaReturnResult@@PAVBitStream@RakNet@@IUPlayerID@@PAV1@@ZP6A?AW42@012@Z@Z ENDP ; ReplicaManager::SetDownloadCompleteCB
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\replicamanager.cpp
;	COMDAT ?SetReceiveConstructionCB@ReplicaManager@@QAEXP6A?AW4ReplicaReturnResult@@PAVBitStream@RakNet@@IUNetworkID@@UPlayerID@@PAV1@@Z@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_constructionCB$ = 8					; size = 4
?SetReceiveConstructionCB@ReplicaManager@@QAEXP6A?AW4ReplicaReturnResult@@PAVBitStream@RakNet@@IUNetworkID@@UPlayerID@@PAV1@@Z@Z PROC ; ReplicaManager::SetReceiveConstructionCB, COMDAT
; _this$ = ecx

; 353  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 354  : 	// Just overwrite the construction callback pointer
; 355  : 	_constructionCB=constructionCB;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _constructionCB$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 356  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetReceiveConstructionCB@ReplicaManager@@QAEXP6A?AW4ReplicaReturnResult@@PAVBitStream@RakNet@@IUNetworkID@@UPlayerID@@PAV1@@Z@Z ENDP ; ReplicaManager::SetReceiveConstructionCB
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\replicamanager.cpp
;	COMDAT ?SignalSerializeNeeded@ReplicaManager@@QAEXPAVReplica@@UPlayerID@@_N@Z
_TEXT	SEGMENT
tv147 = -272						; size = 4
_replicaAndCommand$ = -72				; size = 5
_index$ = -56						; size = 4
_objectExists$ = -41					; size = 1
_participantStruct$ = -32				; size = 4
_i$ = -20						; size = 4
_this$ = -8						; size = 4
_replica$ = 8						; size = 4
_playerId$ = 12						; size = 6
_broadcast$ = 20					; size = 1
?SignalSerializeNeeded@ReplicaManager@@QAEXPAVReplica@@UPlayerID@@_N@Z PROC ; ReplicaManager::SignalSerializeNeeded, COMDAT
; _this$ = ecx

; 314  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 272				; 00000110H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-272]
	mov	ecx, 68					; 00000044H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 315  : 	assert(replica);

	cmp	DWORD PTR _replica$[ebp], 0
	jne	SHORT $LN12@SignalSeri
	mov	eax, DWORD PTR ?__LINE__Var@?1??SignalSerializeNeeded@ReplicaManager@@QAEXPAVReplica@@UPlayerID@@_N@Z@4JA
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_1FG@CAHGPPEA@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAe?$AAp?$AAl?$AAi?$AAc?$AAa?$AAm@
	push	OFFSET ??_C@_1BA@GODDPAJM@?$AAr?$AAe?$AAp?$AAl?$AAi?$AAc?$AAa?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN12@SignalSeri:

; 316  : 
; 317  : 	// Autoreference the pointer if necessary.  This way the user can call functions on an object without having to worry
; 318  : 	// About the order of operations.
; 319  : 	if (replicatedObjects.HasData(replica)==false)

	lea	eax, DWORD PTR _replica$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?HasData@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBE_NABQAVReplica@@@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::HasData
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN9@SignalSeri

; 320  : 		ReferencePointer(replica);

	mov	eax, DWORD PTR _replica$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReferencePointer@ReplicaManager@@QAEXPAVReplica@@@Z ; ReplicaManager::ReferencePointer
$LN9@SignalSeri:

; 321  : 
; 322  : 	// For each player that we want, if this object exists on that system, flag to call Serialize
; 323  : 	// (this may not necessarily happen - it depends on if the object is inScope when Update actually processes it.)
; 324  : 	unsigned i;
; 325  : 	ParticipantStruct *participantStruct;
; 326  : 	bool objectExists;
; 327  : 	unsigned index;
; 328  : 	CommandStruct replicaAndCommand;
; 329  : 	replicaAndCommand.command=REPLICA_SERIALIZE;

	mov	BYTE PTR _replicaAndCommand$[ebp+4], 16	; 00000010H

; 330  : 	replicaAndCommand.replica=replica;

	mov	eax, DWORD PTR _replica$[ebp]
	mov	DWORD PTR _replicaAndCommand$[ebp], eax

; 331  : 	for (i=0; i < participantList.Size(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN8@SignalSeri
$LN7@SignalSeri:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN8@SignalSeri:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?Size@?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	$LN10@SignalSeri

; 332  : 	{
; 333  : 		participantStruct=participantList[i];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??A?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QBEAAPAUParticipantStruct@ReplicaManager@@I@Z ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _participantStruct$[ebp], ecx

; 334  : 
; 335  : 		if ((broadcast==true && playerId!=participantStruct->playerId) || 
; 336  : 			(broadcast==false && playerId==participantStruct->playerId))

	movzx	eax, BYTE PTR _broadcast$[ebp]
	cmp	eax, 1
	jne	SHORT $LN3@SignalSeri
	mov	eax, DWORD PTR _participantStruct$[ebp]
	push	eax
	lea	ecx, DWORD PTR _playerId$[ebp]
	call	??9PlayerID@@QBE_NABU0@@Z		; PlayerID::operator!=
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN4@SignalSeri
$LN3@SignalSeri:
	movzx	eax, BYTE PTR _broadcast$[ebp]
	test	eax, eax
	jne	SHORT $LN5@SignalSeri
	mov	eax, DWORD PTR _participantStruct$[ebp]
	push	eax
	lea	ecx, DWORD PTR _playerId$[ebp]
	call	??8PlayerID@@QBE_NABU0@@Z		; PlayerID::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@SignalSeri
$LN4@SignalSeri:

; 337  : 		{
; 338  : 			// If there is already a pending command for this object, add to it.  Otherwise, add a new pending command
; 339  : 			index = participantStruct->commandList.GetIndexFromKey(replica, &objectExists);

	lea	eax, DWORD PTR _objectExists$[ebp]
	push	eax
	lea	ecx, DWORD PTR _replica$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 7
	call	?GetIndexFromKey@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIABQAVReplica@@PA_N@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::GetIndexFromKey
	mov	DWORD PTR _index$[ebp], eax

; 340  : 			if (objectExists)

	movzx	eax, BYTE PTR _objectExists$[ebp]
	test	eax, eax
	je	SHORT $LN2@SignalSeri

; 341  : 			{
; 342  : 				participantStruct->commandList[index].command|=REPLICA_SERIALIZE; // Set this bit			

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 7
	call	??A?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAUCommandStruct@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::operator[]
	add	eax, 4
	mov	DWORD PTR tv147[ebp], eax
	mov	ecx, DWORD PTR tv147[ebp]
	movzx	edx, BYTE PTR [ecx]
	or	edx, 16					; 00000010H
	mov	eax, DWORD PTR tv147[ebp]
	mov	BYTE PTR [eax], dl

; 343  : 			}
; 344  : 			else

	jmp	SHORT $LN5@SignalSeri
$LN2@SignalSeri:

; 345  : 			{
; 346  : 				// Add a new command, since there are no pending commands for this object
; 347  : 				participantStruct->commandList.Insert(replicaAndCommand.replica,replicaAndCommand);

	lea	eax, DWORD PTR _replicaAndCommand$[ebp]
	push	eax
	lea	ecx, DWORD PTR _replicaAndCommand$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 7
	call	?Insert@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEIABQAVReplica@@ABUCommandStruct@ReplicaManager@@@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::Insert
$LN5@SignalSeri:

; 348  : 			}
; 349  : 		}
; 350  : 	}

	jmp	$LN7@SignalSeri
$LN10@SignalSeri:

; 351  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN16@SignalSeri
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 272				; 00000110H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN16@SignalSeri:
	DD	2
	DD	$LN15@SignalSeri
$LN15@SignalSeri:
	DD	-41					; ffffffd7H
	DD	1
	DD	$LN13@SignalSeri
	DD	-72					; ffffffb8H
	DD	5
	DD	$LN14@SignalSeri
$LN14@SignalSeri:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	65					; 00000041H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	0
$LN13@SignalSeri:
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
?SignalSerializeNeeded@ReplicaManager@@QAEXPAVReplica@@UPlayerID@@_N@Z ENDP ; ReplicaManager::SignalSerializeNeeded
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\replicamanager.cpp
;	COMDAT ?SetScope@ReplicaManager@@QAEXPAVReplica@@_NUPlayerID@@1@Z
_TEXT	SEGMENT
tv178 = -272						; size = 4
tv169 = -272						; size = 4
tv160 = -272						; size = 4
tv151 = -272						; size = 4
_replicaAndCommand$ = -72				; size = 5
_index$ = -56						; size = 4
_objectExists$ = -41					; size = 1
_participantStruct$ = -32				; size = 4
_i$ = -20						; size = 4
_this$ = -8						; size = 4
_replica$ = 8						; size = 4
_inScope$ = 12						; size = 1
_playerId$ = 16						; size = 6
_broadcast$ = 24					; size = 1
?SetScope@ReplicaManager@@QAEXPAVReplica@@_NUPlayerID@@1@Z PROC ; ReplicaManager::SetScope, COMDAT
; _this$ = ecx

; 263  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 272				; 00000110H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-272]
	mov	ecx, 68					; 00000044H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 264  : 	assert(replica);

	cmp	DWORD PTR _replica$[ebp], 0
	jne	SHORT $LN16@SetScope
	mov	eax, DWORD PTR ?__LINE__Var@?1??SetScope@ReplicaManager@@QAEXPAVReplica@@_NUPlayerID@@1@Z@4JA
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_1FG@CAHGPPEA@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAe?$AAp?$AAl?$AAi?$AAc?$AAa?$AAm@
	push	OFFSET ??_C@_1BA@GODDPAJM@?$AAr?$AAe?$AAp?$AAl?$AAi?$AAc?$AAa?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN16@SetScope:

; 265  : 
; 266  : 	// Autoreference the pointer if necessary.  This way the user can call functions on an object without having to worry
; 267  : 	// About the order of operations.
; 268  : 	if (replicatedObjects.HasData(replica)==false)

	lea	eax, DWORD PTR _replica$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?HasData@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBE_NABQAVReplica@@@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::HasData
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN13@SetScope

; 269  : 		ReferencePointer(replica);

	mov	eax, DWORD PTR _replica$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReferencePointer@ReplicaManager@@QAEXPAVReplica@@@Z ; ReplicaManager::ReferencePointer
$LN13@SetScope:

; 270  : 
; 271  : 	// For each player that we want, flag to call SendScopeChange if inScope is different from what they already have
; 272  : 	unsigned i;
; 273  : 	ParticipantStruct *participantStruct;
; 274  : 	bool objectExists;
; 275  : 	unsigned index;
; 276  : 	CommandStruct replicaAndCommand;
; 277  : 	if (inScope)

	movzx	eax, BYTE PTR _inScope$[ebp]
	test	eax, eax
	je	SHORT $LN12@SetScope

; 278  : 		replicaAndCommand.command=REPLICA_SCOPE_TRUE;

	mov	BYTE PTR _replicaAndCommand$[ebp+4], 4

; 279  : 	else

	jmp	SHORT $LN11@SetScope
$LN12@SetScope:

; 280  : 		replicaAndCommand.command=REPLICA_SCOPE_FALSE;

	mov	BYTE PTR _replicaAndCommand$[ebp+4], 8
$LN11@SetScope:

; 281  : 	replicaAndCommand.replica=replica;

	mov	eax, DWORD PTR _replica$[ebp]
	mov	DWORD PTR _replicaAndCommand$[ebp], eax

; 282  : 	for (i=0; i < participantList.Size(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@SetScope
$LN9@SetScope:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@SetScope:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?Size@?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	$LN14@SetScope

; 283  : 	{
; 284  : 		participantStruct=participantList[i];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??A?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QBEAAPAUParticipantStruct@ReplicaManager@@I@Z ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _participantStruct$[ebp], ecx

; 285  : 
; 286  : 		if ((broadcast==true && playerId!=participantStruct->playerId) || 
; 287  : 			(broadcast==false && playerId==participantStruct->playerId))

	movzx	eax, BYTE PTR _broadcast$[ebp]
	cmp	eax, 1
	jne	SHORT $LN5@SetScope
	mov	eax, DWORD PTR _participantStruct$[ebp]
	push	eax
	lea	ecx, DWORD PTR _playerId$[ebp]
	call	??9PlayerID@@QBE_NABU0@@Z		; PlayerID::operator!=
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN6@SetScope
$LN5@SetScope:
	movzx	eax, BYTE PTR _broadcast$[ebp]
	test	eax, eax
	jne	$LN7@SetScope
	mov	eax, DWORD PTR _participantStruct$[ebp]
	push	eax
	lea	ecx, DWORD PTR _playerId$[ebp]
	call	??8PlayerID@@QBE_NABU0@@Z		; PlayerID::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	$LN7@SetScope
$LN6@SetScope:

; 288  : 		{
; 289  : 			// If there is already a pending command for this object, add to it.  Otherwise, add a new pending command
; 290  : 			index = participantStruct->commandList.GetIndexFromKey(replica, &objectExists);

	lea	eax, DWORD PTR _objectExists$[ebp]
	push	eax
	lea	ecx, DWORD PTR _replica$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 7
	call	?GetIndexFromKey@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIABQAVReplica@@PA_N@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::GetIndexFromKey
	mov	DWORD PTR _index$[ebp], eax

; 291  :             if (objectExists)

	movzx	eax, BYTE PTR _objectExists$[ebp]
	test	eax, eax
	je	$LN4@SetScope

; 292  : 			{
; 293  : 				// Update a pending command
; 294  : 				if (inScope)

	movzx	eax, BYTE PTR _inScope$[ebp]
	test	eax, eax
	je	SHORT $LN3@SetScope

; 295  : 				{
; 296  : 					participantStruct->commandList[index].command&=0xFF ^ REPLICA_SCOPE_FALSE; // Unset this bit

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 7
	call	??A?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAUCommandStruct@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::operator[]
	add	eax, 4
	mov	DWORD PTR tv151[ebp], eax
	mov	ecx, DWORD PTR tv151[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	edx, 247				; 000000f7H
	mov	eax, DWORD PTR tv151[ebp]
	mov	BYTE PTR [eax], dl

; 297  : 					participantStruct->commandList[index].command|=REPLICA_SCOPE_TRUE; // Set this bit

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 7
	call	??A?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAUCommandStruct@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::operator[]
	add	eax, 4
	mov	DWORD PTR tv160[ebp], eax
	mov	ecx, DWORD PTR tv160[ebp]
	movzx	edx, BYTE PTR [ecx]
	or	edx, 4
	mov	eax, DWORD PTR tv160[ebp]
	mov	BYTE PTR [eax], dl

; 298  : 				}
; 299  : 				else

	jmp	SHORT $LN2@SetScope
$LN3@SetScope:

; 300  : 				{
; 301  : 					participantStruct->commandList[index].command&=0xFF ^ REPLICA_SCOPE_TRUE; // Unset this bit

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 7
	call	??A?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAUCommandStruct@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::operator[]
	add	eax, 4
	mov	DWORD PTR tv169[ebp], eax
	mov	ecx, DWORD PTR tv169[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	edx, 251				; 000000fbH
	mov	eax, DWORD PTR tv169[ebp]
	mov	BYTE PTR [eax], dl

; 302  : 					participantStruct->commandList[index].command|=REPLICA_SCOPE_FALSE; // Set this bit

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 7
	call	??A?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAUCommandStruct@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::operator[]
	add	eax, 4
	mov	DWORD PTR tv178[ebp], eax
	mov	ecx, DWORD PTR tv178[ebp]
	movzx	edx, BYTE PTR [ecx]
	or	edx, 8
	mov	eax, DWORD PTR tv178[ebp]
	mov	BYTE PTR [eax], dl
$LN2@SetScope:

; 303  : 				}						
; 304  : 			}
; 305  : 			else

	jmp	SHORT $LN7@SetScope
$LN4@SetScope:

; 306  : 			{
; 307  : 				// Add a new command, since there are no pending commands for this object
; 308  : 				participantStruct->commandList.Insert(replicaAndCommand.replica,replicaAndCommand);

	lea	eax, DWORD PTR _replicaAndCommand$[ebp]
	push	eax
	lea	ecx, DWORD PTR _replicaAndCommand$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 7
	call	?Insert@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEIABQAVReplica@@ABUCommandStruct@ReplicaManager@@@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::Insert
$LN7@SetScope:

; 309  : 			}
; 310  : 		}
; 311  : 	}

	jmp	$LN9@SetScope
$LN14@SetScope:

; 312  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN20@SetScope
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 272				; 00000110H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
	npad	2
$LN20@SetScope:
	DD	2
	DD	$LN19@SetScope
$LN19@SetScope:
	DD	-41					; ffffffd7H
	DD	1
	DD	$LN17@SetScope
	DD	-72					; ffffffb8H
	DD	5
	DD	$LN18@SetScope
$LN18@SetScope:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	65					; 00000041H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	0
$LN17@SetScope:
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
?SetScope@ReplicaManager@@QAEXPAVReplica@@_NUPlayerID@@1@Z ENDP ; ReplicaManager::SetScope
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\replicamanager.cpp
;	COMDAT ?DereferencePointer@ReplicaManager@@QAEXPAVReplica@@@Z
_TEXT	SEGMENT
_i$ = -68						; size = 4
_participantStruct$ = -56				; size = 4
_tempIndex$ = -44					; size = 4
_replicatedObjectsIndex$ = -32				; size = 4
_objectExists$ = -17					; size = 1
_this$ = -8						; size = 4
_replica$ = 8						; size = 4
?DereferencePointer@ReplicaManager@@QAEXPAVReplica@@@Z PROC ; ReplicaManager::DereferencePointer, COMDAT
; _this$ = ecx

; 236  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 237  : 	bool objectExists;
; 238  : 	unsigned replicatedObjectsIndex;
; 239  : 	unsigned tempIndex;
; 240  : 	replicatedObjectsIndex = replicatedObjects.GetIndexFromKey(replica, &objectExists);

	lea	eax, DWORD PTR _objectExists$[ebp]
	push	eax
	lea	ecx, DWORD PTR _replica$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?GetIndexFromKey@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIABQAVReplica@@PA_N@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::GetIndexFromKey
	mov	DWORD PTR _replicatedObjectsIndex$[ebp], eax

; 241  : 	if (objectExists==false)

	movzx	eax, BYTE PTR _objectExists$[ebp]
	test	eax, eax
	jne	SHORT $LN6@Dereferenc

; 242  : 		return;

	jmp	$LN7@Dereferenc
$LN6@Dereferenc:

; 243  : 	replicatedObjects.RemoveAtIndex(replicatedObjectsIndex);

	mov	eax, DWORD PTR _replicatedObjectsIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?RemoveAtIndex@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEXI@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::RemoveAtIndex

; 244  : 
; 245  : 	ParticipantStruct *participantStruct;
; 246  : 	unsigned i;
; 247  : 	for (i=0; i < participantList.Size(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN5@Dereferenc
$LN4@Dereferenc:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN5@Dereferenc:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?Size@?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN7@Dereferenc

; 248  : 	{
; 249  : 		participantStruct=participantList[i];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??A?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QBEAAPAUParticipantStruct@ReplicaManager@@I@Z ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _participantStruct$[ebp], ecx

; 250  : 
; 251  : 		// Remove any pending commands that reference this object for any player
; 252  : 		tempIndex = participantStruct->commandList.GetIndexFromKey(replica, &objectExists);

	lea	eax, DWORD PTR _objectExists$[ebp]
	push	eax
	lea	ecx, DWORD PTR _replica$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 7
	call	?GetIndexFromKey@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIABQAVReplica@@PA_N@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::GetIndexFromKey
	mov	DWORD PTR _tempIndex$[ebp], eax

; 253  : 		if (objectExists)

	movzx	eax, BYTE PTR _objectExists$[ebp]
	test	eax, eax
	je	SHORT $LN2@Dereferenc

; 254  : 			participantStruct->commandList.RemoveAtIndex(tempIndex);

	mov	eax, DWORD PTR _tempIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 7
	call	?RemoveAtIndex@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEXI@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::RemoveAtIndex
$LN2@Dereferenc:

; 255  : 
; 256  : 		// Remove any remote object state tracking for this object for any player
; 257  : 		tempIndex = participantStruct->remoteObjectList.GetIndexFromKey(replica, &objectExists);

	lea	eax, DWORD PTR _objectExists$[ebp]
	push	eax
	lea	ecx, DWORD PTR _replica$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 19					; 00000013H
	call	?GetIndexFromKey@?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIABQAVReplica@@PA_N@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::GetIndexFromKey
	mov	DWORD PTR _tempIndex$[ebp], eax

; 258  : 		if (objectExists)

	movzx	eax, BYTE PTR _objectExists$[ebp]
	test	eax, eax
	je	SHORT $LN1@Dereferenc

; 259  : 			participantStruct->remoteObjectList.RemoveAtIndex(tempIndex);

	mov	eax, DWORD PTR _tempIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 19					; 00000013H
	call	?RemoveAtIndex@?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEXI@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::RemoveAtIndex
$LN1@Dereferenc:

; 260  : 	}

	jmp	$LN4@Dereferenc
$LN7@Dereferenc:

; 261  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@Dereferenc
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN11@Dereferenc:
	DD	1
	DD	$LN10@Dereferenc
$LN10@Dereferenc:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN9@Dereferenc
$LN9@Dereferenc:
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
?DereferencePointer@ReplicaManager@@QAEXPAVReplica@@@Z ENDP ; ReplicaManager::DereferencePointer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\replicamanager.cpp
;	COMDAT ?ReferencePointer@ReplicaManager@@QAEXPAVReplica@@@Z
_TEXT	SEGMENT
_replicaAndTime$1 = -28					; size = 9
_this$ = -8						; size = 4
_replica$ = 8						; size = 4
?ReferencePointer@ReplicaManager@@QAEXPAVReplica@@@Z PROC ; ReplicaManager::ReferencePointer, COMDAT
; _this$ = ecx

; 224  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 224				; 000000e0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-224]
	mov	ecx, 56					; 00000038H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 225  : 	// Start tracking this object, if we are not already
; 226  : 	if (replicatedObjects.HasData(replica)==false)

	lea	eax, DWORD PTR _replica$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?HasData@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBE_NABQAVReplica@@@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::HasData
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@ReferenceP

; 227  : 	{
; 228  : 		RegisteredReplica replicaAndTime;
; 229  : 		replicaAndTime.replica=replica;

	mov	eax, DWORD PTR _replica$[ebp]
	mov	DWORD PTR _replicaAndTime$1[ebp], eax

; 230  : 		replicaAndTime.lastDeserializeTrue=0;

	mov	DWORD PTR _replicaAndTime$1[ebp+4], 0

; 231  : 		replicaAndTime.allowedInterfaces=REPLICA_SET_ALL;

	mov	BYTE PTR _replicaAndTime$1[ebp+8], 255	; 000000ffH

; 232  : 		replicatedObjects.Insert(replica,replicaAndTime);

	lea	eax, DWORD PTR _replicaAndTime$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _replica$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Insert@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEIABQAVReplica@@ABURegisteredReplica@ReplicaManager@@@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::Insert
$LN2@ReferenceP:

; 233  : 	}
; 234  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@ReferenceP
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 224				; 000000e0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$LN6@ReferenceP:
	DD	1
	DD	$LN5@ReferenceP
$LN5@ReferenceP:
	DD	-28					; ffffffe4H
	DD	9
	DD	$LN4@ReferenceP
$LN4@ReferenceP:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	65					; 00000041H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
?ReferencePointer@ReplicaManager@@QAEXPAVReplica@@@Z ENDP ; ReplicaManager::ReferencePointer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\replicamanager.cpp
;	COMDAT ?Destruct@ReplicaManager@@QAEXPAVReplica@@UPlayerID@@_N@Z
_TEXT	SEGMENT
$T2 = -604						; size = 8
$T3 = -588						; size = 8
_participantStruct$ = -380				; size = 4
_replicaReferenced$ = -365				; size = 1
_tempIndex$ = -356					; size = 4
_i$ = -344						; size = 4
_outBitstream$ = -332					; size = 273
_replicatedObjectsIndex$ = -48				; size = 4
_objectExists$ = -33					; size = 1
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_replica$ = 8						; size = 4
_playerId$ = 12						; size = 6
_broadcast$ = 20					; size = 1
?Destruct@ReplicaManager@@QAEXPAVReplica@@UPlayerID@@_N@Z PROC ; ReplicaManager::Destruct, COMDAT
; _this$ = ecx

; 164  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Destruct@ReplicaManager@@QAEXPAVReplica@@UPlayerID@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 596				; 00000254H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-608]
	mov	ecx, 149				; 00000095H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 	assert(replica);

	cmp	DWORD PTR _replica$[ebp], 0
	jne	SHORT $LN20@Destruct
	mov	eax, DWORD PTR ?__LINE__Var@?1??Destruct@ReplicaManager@@QAEXPAVReplica@@UPlayerID@@_N@Z@4JA
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_1FG@CAHGPPEA@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAe?$AAp?$AAl?$AAi?$AAc?$AAa?$AAm@
	push	OFFSET ??_C@_1BA@GODDPAJM@?$AAr?$AAe?$AAp?$AAl?$AAi?$AAc?$AAa?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN20@Destruct:

; 166  : 
; 167  : 	bool objectExists;
; 168  : 	unsigned replicatedObjectsIndex;
; 169  : 	replicatedObjectsIndex = replicatedObjects.GetIndexFromKey(replica, &objectExists);

	lea	eax, DWORD PTR _objectExists$[ebp]
	push	eax
	lea	ecx, DWORD PTR _replica$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?GetIndexFromKey@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIABQAVReplica@@PA_N@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::GetIndexFromKey
	mov	DWORD PTR _replicatedObjectsIndex$[ebp], eax

; 170  : 	if (objectExists==false)

	movzx	eax, BYTE PTR _objectExists$[ebp]
	test	eax, eax
	jne	SHORT $LN17@Destruct

; 171  : 		return;

	jmp	$LN18@Destruct
$LN17@Destruct:

; 172  : 
; 173  : 	// For each existing participant, send a packet telling them of this object destruction
; 174  : 	RakNet::BitStream outBitstream;

	lea	ecx, DWORD PTR _outBitstream$[ebp]
	call	??0BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 175  : 	unsigned i,tempIndex;
; 176  : 	bool replicaReferenced;
; 177  : 	ParticipantStruct *participantStruct;
; 178  : 	replicaReferenced=false;

	mov	BYTE PTR _replicaReferenced$[ebp], 0

; 179  : 	for (i=0; i < participantList.Size(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN16@Destruct
$LN15@Destruct:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN16@Destruct:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?Size@?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	$LN14@Destruct

; 180  : 	{
; 181  : 		participantStruct=participantList[i];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??A?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QBEAAPAUParticipantStruct@ReplicaManager@@I@Z ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _participantStruct$[ebp], ecx

; 182  : 
; 183  : 		if ((broadcast==true && playerId!=participantStruct->playerId) || 
; 184  : 			(broadcast==false && playerId==participantStruct->playerId))

	movzx	eax, BYTE PTR _broadcast$[ebp]
	cmp	eax, 1
	jne	SHORT $LN11@Destruct
	mov	eax, DWORD PTR _participantStruct$[ebp]
	push	eax
	lea	ecx, DWORD PTR _playerId$[ebp]
	call	??9PlayerID@@QBE_NABU0@@Z		; PlayerID::operator!=
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN12@Destruct
$LN11@Destruct:
	movzx	eax, BYTE PTR _broadcast$[ebp]
	test	eax, eax
	jne	$LN13@Destruct
	mov	eax, DWORD PTR _participantStruct$[ebp]
	push	eax
	lea	ecx, DWORD PTR _playerId$[ebp]
	call	??8PlayerID@@QBE_NABU0@@Z		; PlayerID::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	$LN13@Destruct
$LN12@Destruct:

; 185  : 		{
; 186  : 			// Send the destruction packet immediately
; 187  : 			if (replica->GetNetworkID()!=UNASSIGNED_NETWORK_ID && (replicatedObjects[replicatedObjectsIndex].allowedInterfaces & REPLICA_SEND_DESTRUCTION))

	push	OFFSET _UNASSIGNED_NETWORK_ID
	mov	esi, esp
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _replica$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _replica$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, eax
	call	??9NetworkID@@QBE_NABU0@@Z		; NetworkID::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	$LN10@Destruct
	mov	eax, DWORD PTR _replicatedObjectsIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAURegisteredReplica@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::operator[]
	movzx	ecx, BYTE PTR [eax+8]
	and	ecx, 16					; 00000010H
	je	$LN10@Destruct

; 188  : 			{
; 189  : 				outBitstream.Reset();

	lea	ecx, DWORD PTR _outBitstream$[ebp]
	call	?Reset@BitStream@RakNet@@QAEXXZ		; RakNet::BitStream::Reset

; 190  : 				outBitstream.Write((unsigned char)ID_REPLICA_MANAGER_DESTRUCTION);

	push	57					; 00000039H
	lea	ecx, DWORD PTR _outBitstream$[ebp]
	call	??$Write@E@BitStream@RakNet@@QAEXE@Z	; RakNet::BitStream::Write<unsigned char>

; 191  : 				outBitstream.Write(replica->GetNetworkID());

	mov	esi, esp
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _replica$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _replica$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	ecx, DWORD PTR _outBitstream$[ebp]
	call	??$Write@UNetworkID@@@BitStream@RakNet@@QAEXUNetworkID@@@Z ; RakNet::BitStream::Write<NetworkID>

; 192  : 				replica->SendDestruction(&outBitstream, participantStruct->playerId);

	mov	eax, DWORD PTR _participantStruct$[ebp]
	mov	esi, esp
	sub	esp, 8
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	ax, WORD PTR [eax+4]
	mov	WORD PTR [ecx+4], ax
	lea	ecx, DWORD PTR _outBitstream$[ebp]
	push	ecx
	mov	edx, DWORD PTR _replica$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _replica$[ebp]
	mov	edx, DWORD PTR [eax+32]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 193  : 				if (outBitstream.GetNumberOfBitsUsed()>0)

	lea	ecx, DWORD PTR _outBitstream$[ebp]
	call	?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBitsUsed
	test	eax, eax
	jle	SHORT $LN10@Destruct

; 194  : 				{
; 195  : 					rakPeer->Send(&outBitstream, HIGH_PRIORITY, RELIABLE_ORDERED, sendChannel, participantStruct->playerId, false);

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR _participantStruct$[ebp]
	sub	esp, 8
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	ax, WORD PTR [eax+4]
	mov	WORD PTR [ecx+4], ax
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+40]
	push	edx
	push	3
	push	1
	lea	eax, DWORD PTR _outBitstream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+44]
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@Destruct:

; 196  : 				}
; 197  : 			}
; 198  : 
; 199  : 			// Remove any pending commands that reference this object, for this player
; 200  : 			tempIndex = participantStruct->commandList.GetIndexFromKey(replica, &objectExists);

	lea	eax, DWORD PTR _objectExists$[ebp]
	push	eax
	lea	ecx, DWORD PTR _replica$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 7
	call	?GetIndexFromKey@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIABQAVReplica@@PA_N@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::GetIndexFromKey
	mov	DWORD PTR _tempIndex$[ebp], eax

; 201  : 			if (objectExists)

	movzx	eax, BYTE PTR _objectExists$[ebp]
	test	eax, eax
	je	SHORT $LN8@Destruct

; 202  : 				participantStruct->commandList.RemoveAtIndex(tempIndex);

	mov	eax, DWORD PTR _tempIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 7
	call	?RemoveAtIndex@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEXI@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::RemoveAtIndex
$LN8@Destruct:

; 203  : 
; 204  : 			// Remove any remote object state tracking for this object, for this player
; 205  : 			tempIndex = participantStruct->remoteObjectList.GetIndexFromKey(replica, &objectExists);

	lea	eax, DWORD PTR _objectExists$[ebp]
	push	eax
	lea	ecx, DWORD PTR _replica$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 19					; 00000013H
	call	?GetIndexFromKey@?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIABQAVReplica@@PA_N@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::GetIndexFromKey
	mov	DWORD PTR _tempIndex$[ebp], eax

; 206  : 			if (objectExists)

	movzx	eax, BYTE PTR _objectExists$[ebp]
	test	eax, eax
	je	SHORT $LN7@Destruct

; 207  : 				participantStruct->remoteObjectList.RemoveAtIndex(tempIndex);

	mov	eax, DWORD PTR _tempIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 19					; 00000013H
	call	?RemoveAtIndex@?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEXI@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::RemoveAtIndex
$LN7@Destruct:

; 208  : 		}

	jmp	SHORT $LN6@Destruct
$LN13@Destruct:

; 209  : 		else if (replicaReferenced==false)

	movzx	eax, BYTE PTR _replicaReferenced$[ebp]
	test	eax, eax
	jne	SHORT $LN6@Destruct

; 210  : 		{
; 211  : 			// See if any commands or objects reference replica
; 212  : 			if (participantStruct->commandList.HasData(replica))

	lea	eax, DWORD PTR _replica$[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 7
	call	?HasData@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBE_NABQAVReplica@@@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::HasData
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@Destruct

; 213  : 				replicaReferenced=true;

	mov	BYTE PTR _replicaReferenced$[ebp], 1
	jmp	SHORT $LN6@Destruct
$LN4@Destruct:

; 214  : 			else if (participantStruct->remoteObjectList.HasData(replica))

	lea	eax, DWORD PTR _replica$[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 19					; 00000013H
	call	?HasData@?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBE_NABQAVReplica@@@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::HasData
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@Destruct

; 215  : 				replicaReferenced=true;

	mov	BYTE PTR _replicaReferenced$[ebp], 1
$LN6@Destruct:

; 216  : 		}
; 217  : 	}

	jmp	$LN15@Destruct
$LN14@Destruct:

; 218  : 
; 219  : 	// Remove replica from the list if no commands and no remote objects reference it
; 220  : 	if (replicaReferenced==false)

	movzx	eax, BYTE PTR _replicaReferenced$[ebp]
	test	eax, eax
	jne	SHORT $LN1@Destruct

; 221  : 		replicatedObjects.RemoveAtIndex(replicatedObjectsIndex);

	mov	eax, DWORD PTR _replicatedObjectsIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?RemoveAtIndex@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEXI@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::RemoveAtIndex
$LN1@Destruct:

; 222  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _outBitstream$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
$LN18@Destruct:
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN26@Destruct
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 608				; 00000260H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	npad	1
$LN26@Destruct:
	DD	2
	DD	$LN25@Destruct
$LN25@Destruct:
	DD	-33					; ffffffdfH
	DD	1
	DD	$LN22@Destruct
	DD	-332					; fffffeb4H
	DD	273					; 00000111H
	DD	$LN23@Destruct
$LN23@Destruct:
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	66					; 00000042H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	0
$LN22@Destruct:
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Destruct@ReplicaManager@@QAEXPAVReplica@@UPlayerID@@_N@Z$0:
	lea	ecx, DWORD PTR _outBitstream$[ebp]
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__ehhandler$?Destruct@ReplicaManager@@QAEXPAVReplica@@UPlayerID@@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-612]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Destruct@ReplicaManager@@QAEXPAVReplica@@UPlayerID@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Destruct@ReplicaManager@@QAEXPAVReplica@@UPlayerID@@_N@Z ENDP ; ReplicaManager::Destruct
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\replicamanager.cpp
;	COMDAT ?Construct@ReplicaManager@@QAEXPAVReplica@@_NUPlayerID@@1@Z
_TEXT	SEGMENT
tv163 = -272						; size = 4
tv154 = -272						; size = 4
_objectExists$ = -69					; size = 1
_index$ = -60						; size = 4
_replicaAndCommand$ = -48				; size = 5
_participantStruct$ = -32				; size = 4
_i$ = -20						; size = 4
_this$ = -8						; size = 4
_replica$ = 8						; size = 4
_isCopy$ = 12						; size = 1
_playerId$ = 16						; size = 6
_broadcast$ = 24					; size = 1
?Construct@ReplicaManager@@QAEXPAVReplica@@_NUPlayerID@@1@Z PROC ; ReplicaManager::Construct, COMDAT
; _this$ = ecx

; 120  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 272				; 00000110H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-272]
	mov	ecx, 68					; 00000044H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 121  : 	assert(replica);

	cmp	DWORD PTR _replica$[ebp], 0
	jne	SHORT $LN14@Construct
	mov	eax, DWORD PTR ?__LINE__Var@?1??Construct@ReplicaManager@@QAEXPAVReplica@@_NUPlayerID@@1@Z@4JA
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_1FG@CAHGPPEA@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAe?$AAp?$AAl?$AAi?$AAc?$AAa?$AAm@
	push	OFFSET ??_C@_1BA@GODDPAJM@?$AAr?$AAe?$AAp?$AAl?$AAi?$AAc?$AAa?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN14@Construct:

; 122  : 
; 123  : 	unsigned i;
; 124  : 	ParticipantStruct *participantStruct;
; 125  : 	CommandStruct replicaAndCommand;
; 126  : 	unsigned index;
; 127  : 	bool objectExists;
; 128  : 	replicaAndCommand.replica=replica;

	mov	eax, DWORD PTR _replica$[ebp]
	mov	DWORD PTR _replicaAndCommand$[ebp], eax

; 129  : 
; 130  : 	ReferencePointer(replica);

	mov	eax, DWORD PTR _replica$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReferencePointer@ReplicaManager@@QAEXPAVReplica@@@Z ; ReplicaManager::ReferencePointer

; 131  : 
; 132  : 	for (i=0; i < participantList.Size(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN11@Construct
$LN10@Construct:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN11@Construct:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?Size@?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	$LN12@Construct

; 133  : 	{
; 134  : 		participantStruct=participantList[i];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??A?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QBEAAPAUParticipantStruct@ReplicaManager@@I@Z ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _participantStruct$[ebp], ecx

; 135  : 		if ((broadcast==true && playerId!=participantStruct->playerId) || 
; 136  : 			(broadcast==false && playerId==participantStruct->playerId))

	movzx	eax, BYTE PTR _broadcast$[ebp]
	cmp	eax, 1
	jne	SHORT $LN6@Construct
	mov	eax, DWORD PTR _participantStruct$[ebp]
	push	eax
	lea	ecx, DWORD PTR _playerId$[ebp]
	call	??9PlayerID@@QBE_NABU0@@Z		; PlayerID::operator!=
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN7@Construct
$LN6@Construct:
	movzx	eax, BYTE PTR _broadcast$[ebp]
	test	eax, eax
	jne	$LN8@Construct
	mov	eax, DWORD PTR _participantStruct$[ebp]
	push	eax
	lea	ecx, DWORD PTR _playerId$[ebp]
	call	??8PlayerID@@QBE_NABU0@@Z		; PlayerID::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	$LN8@Construct
$LN7@Construct:

; 137  : 		{
; 138  : 			if (participantStruct->remoteObjectList.HasData(replica)==false)

	lea	eax, DWORD PTR _replica$[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 19					; 00000013H
	call	?HasData@?$OrderedList@PAVReplica@@URemoteObject@ReplicaManager@@$1?RemoteObjectComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBE_NABQAVReplica@@@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RemoteObject,&ReplicaManager::RemoteObjectComp>::HasData
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN8@Construct

; 139  : 			{
; 140  : 				index = participantStruct->commandList.GetIndexFromKey(replica, &objectExists);

	lea	eax, DWORD PTR _objectExists$[ebp]
	push	eax
	lea	ecx, DWORD PTR _replica$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 7
	call	?GetIndexFromKey@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIABQAVReplica@@PA_N@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::GetIndexFromKey
	mov	DWORD PTR _index$[ebp], eax

; 141  : 				if (objectExists)

	movzx	eax, BYTE PTR _objectExists$[ebp]
	test	eax, eax
	je	$LN4@Construct

; 142  : 				{
; 143  : #ifdef _DEBUG
; 144  : 					// Implicit is only used for objects that were not already registered.
; 145  : 					assert(isCopy==false);

	movzx	eax, BYTE PTR _isCopy$[ebp]
	test	eax, eax
	je	SHORT $LN15@Construct
	mov	ecx, DWORD PTR ?__LINE__Var@?1??Construct@ReplicaManager@@QAEXPAVReplica@@_NUPlayerID@@1@Z@4JA
	add	ecx, 25					; 00000019H
	push	ecx
	push	OFFSET ??_C@_1FG@CAHGPPEA@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAe?$AAp?$AAl?$AAi?$AAc?$AAa?$AAm@
	push	OFFSET ??_C@_1BM@DOEBGNAM@?$AAi?$AAs?$AAC?$AAo?$AAp?$AAy?$AA?$DN?$AA?$DN?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN15@Construct:

; 146  : #endif
; 147  : 					participantStruct->commandList[index].command|=REPLICA_EXPLICIT_CONSTRUCTION; // Set this bit

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 7
	call	??A?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAUCommandStruct@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::operator[]
	add	eax, 4
	mov	DWORD PTR tv154[ebp], eax
	mov	ecx, DWORD PTR tv154[ebp]
	movzx	edx, BYTE PTR [ecx]
	or	edx, 1
	mov	eax, DWORD PTR tv154[ebp]
	mov	BYTE PTR [eax], dl

; 148  : 					participantStruct->commandList[index].command&=0xFF ^ REPLICA_IMPLICIT_CONSTRUCTION; // Unset this bit

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 7
	call	??A?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAUCommandStruct@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::operator[]
	add	eax, 4
	mov	DWORD PTR tv163[ebp], eax
	mov	ecx, DWORD PTR tv163[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	edx, 253				; 000000fdH
	mov	eax, DWORD PTR tv163[ebp]
	mov	BYTE PTR [eax], dl

; 149  : 				}
; 150  : 				else

	jmp	SHORT $LN8@Construct
$LN4@Construct:

; 151  : 				{
; 152  : 					if (isCopy)

	movzx	eax, BYTE PTR _isCopy$[ebp]
	test	eax, eax
	je	SHORT $LN2@Construct

; 153  : 						replicaAndCommand.command=REPLICA_IMPLICIT_CONSTRUCTION; // Set this bit

	mov	BYTE PTR _replicaAndCommand$[ebp+4], 2

; 154  : 					else

	jmp	SHORT $LN1@Construct
$LN2@Construct:

; 155  : 						replicaAndCommand.command=REPLICA_EXPLICIT_CONSTRUCTION; // Set this bit

	mov	BYTE PTR _replicaAndCommand$[ebp+4], 1
$LN1@Construct:

; 156  : 
; 157  : 					participantStruct->commandList.Insert(replicaAndCommand.replica,replicaAndCommand);

	lea	eax, DWORD PTR _replicaAndCommand$[ebp]
	push	eax
	lea	ecx, DWORD PTR _replicaAndCommand$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 7
	call	?Insert@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEIABQAVReplica@@ABUCommandStruct@ReplicaManager@@@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::Insert
$LN8@Construct:

; 158  : 				}
; 159  : 			}
; 160  : 		}
; 161  : 	}

	jmp	$LN10@Construct
$LN12@Construct:

; 162  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN19@Construct
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 272				; 00000110H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
	npad	3
$LN19@Construct:
	DD	2
	DD	$LN18@Construct
$LN18@Construct:
	DD	-48					; ffffffd0H
	DD	5
	DD	$LN16@Construct
	DD	-69					; ffffffbbH
	DD	1
	DD	$LN17@Construct
$LN17@Construct:
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
$LN16@Construct:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	65					; 00000041H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	0
?Construct@ReplicaManager@@QAEXPAVReplica@@_NUPlayerID@@1@Z ENDP ; ReplicaManager::Construct
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\replicamanager.cpp
;	COMDAT ?RemoveParticipant@ReplicaManager@@QAEXUPlayerID@@@Z
_TEXT	SEGMENT
tv85 = -244						; size = 4
$T1 = -236						; size = 4
$T2 = -224						; size = 4
_participantStruct$ = -20				; size = 4
_this$ = -8						; size = 4
_playerId$ = 8						; size = 6
?RemoveParticipant@ReplicaManager@@QAEXUPlayerID@@@Z PROC ; ReplicaManager::RemoveParticipant, COMDAT
; _this$ = ecx

; 104  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 105  : 	assert(playerId!=UNASSIGNED_PLAYER_ID);

	push	OFFSET _UNASSIGNED_PLAYER_ID
	lea	ecx, DWORD PTR _playerId$[ebp]
	call	??9PlayerID@@QBE_NABU0@@Z		; PlayerID::operator!=
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@RemovePart
	mov	ecx, DWORD PTR ?__LINE__Var@?1??RemoveParticipant@ReplicaManager@@QAEXUPlayerID@@@Z@4JA
	add	ecx, 1
	push	ecx
	push	OFFSET ??_C@_1FG@CAHGPPEA@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAe?$AAp?$AAl?$AAi?$AAc?$AAa?$AAm@
	push	OFFSET ??_C@_1DO@FONFJDEJ@?$AAp?$AAl?$AAa?$AAy?$AAe?$AAr?$AAI?$AAd?$AA?$CB?$AA?$DN?$AAU?$AAN?$AAA?$AAS?$AAS?$AAI?$AAG?$AAN?$AAE?$AAD?$AA_?$AAP?$AAL?$AAA?$AAY?$AAE?$AAR?$AA_?$AAI?$AAD?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@RemovePart:

; 106  : 
; 107  : 	// Find this participant by playerId
; 108  : 	ParticipantStruct *participantStruct;
; 109  : 	participantStruct=GetParticipantByPlayerID(playerId);

	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetParticipantByPlayerID@ReplicaManager@@IBEPAUParticipantStruct@1@UPlayerID@@@Z ; ReplicaManager::GetParticipantByPlayerID
	mov	DWORD PTR _participantStruct$[ebp], eax

; 110  : 
; 111  : 	// If found, remove and free this participant structure
; 112  : 	if (participantStruct)

	cmp	DWORD PTR _participantStruct$[ebp], 0
	je	SHORT $LN2@RemovePart

; 113  : 	{
; 114  : 		participantList.Remove(playerId);

	lea	eax, DWORD PTR _playerId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?Remove@?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QAEIABUPlayerID@@@Z ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::Remove

; 115  : 		delete participantStruct;

	mov	eax, DWORD PTR _participantStruct$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN5@RemovePart
	push	1
	mov	ecx, DWORD PTR $T1[ebp]
	call	??_GParticipantStruct@ReplicaManager@@QAEPAXI@Z
	mov	DWORD PTR tv85[ebp], eax
	jmp	SHORT $LN2@RemovePart
$LN5@RemovePart:
	mov	DWORD PTR tv85[ebp], 0
$LN2@RemovePart:

; 116  : 	}
; 117  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?RemoveParticipant@ReplicaManager@@QAEXUPlayerID@@@Z ENDP ; ReplicaManager::RemoveParticipant
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\replicamanager.cpp
;	COMDAT ?AddParticipant@ReplicaManager@@QAEXUPlayerID@@@Z
_TEXT	SEGMENT
tv85 = -284						; size = 4
$T2 = -276						; size = 4
$T3 = -264						; size = 4
_replicaAndCommand$4 = -60				; size = 5
_i$5 = -44						; size = 4
_participantStruct$ = -32				; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_playerId$ = 8						; size = 6
?AddParticipant@ReplicaManager@@QAEXUPlayerID@@@Z PROC	; ReplicaManager::AddParticipant, COMDAT
; _this$ = ecx

; 71   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddParticipant@ReplicaManager@@QAEXUPlayerID@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 272				; 00000110H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-284]
	mov	ecx, 68					; 00000044H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 72   : 	assert(playerId!=UNASSIGNED_PLAYER_ID);

	push	OFFSET _UNASSIGNED_PLAYER_ID
	lea	ecx, DWORD PTR _playerId$[ebp]
	call	??9PlayerID@@QBE_NABU0@@Z		; PlayerID::operator!=
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN8@AddPartici
	mov	ecx, DWORD PTR ?__LINE__Var@?1??AddParticipant@ReplicaManager@@QAEXUPlayerID@@@Z@4JA
	add	ecx, 1
	push	ecx
	push	OFFSET ??_C@_1FG@CAHGPPEA@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAe?$AAp?$AAl?$AAi?$AAc?$AAa?$AAm@
	push	OFFSET ??_C@_1DO@FONFJDEJ@?$AAp?$AAl?$AAa?$AAy?$AAe?$AAr?$AAI?$AAd?$AA?$CB?$AA?$DN?$AAU?$AAN?$AAA?$AAS?$AAS?$AAI?$AAG?$AAN?$AAE?$AAD?$AA_?$AAP?$AAL?$AAA?$AAY?$AAE?$AAR?$AA_?$AAI?$AAD?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN8@AddPartici:

; 73   : 
; 74   : 	// If this player is already in the list of participants, just return.
; 75   : 	ParticipantStruct *participantStruct;
; 76   : 	participantStruct=GetParticipantByPlayerID(playerId);

	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetParticipantByPlayerID@ReplicaManager@@IBEPAUParticipantStruct@1@UPlayerID@@@Z ; ReplicaManager::GetParticipantByPlayerID
	mov	DWORD PTR _participantStruct$[ebp], eax

; 77   : 	if (participantStruct)

	cmp	DWORD PTR _participantStruct$[ebp], 0
	je	SHORT $LN5@AddPartici

; 78   : 		return;

	jmp	$LN6@AddPartici
$LN5@AddPartici:

; 79   : 
; 80   : 	// Create a new participant with this playerID
; 81   : 	participantStruct = new ParticipantStruct;

	push	47					; 0000002fH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN9@AddPartici
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0ParticipantStruct@ReplicaManager@@QAE@XZ
	mov	DWORD PTR tv85[ebp], eax
	jmp	SHORT $LN10@AddPartici
$LN9@AddPartici:
	mov	DWORD PTR tv85[ebp], 0
$LN10@AddPartici:
	mov	eax, DWORD PTR tv85[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _participantStruct$[ebp], ecx

; 82   : 	participantStruct->playerId=playerId;

	lea	eax, DWORD PTR _playerId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	call	??4PlayerID@@QAEAAU0@ABU0@@Z		; PlayerID::operator=

; 83   : 
; 84   : 	// Signal that when done sending SendConstruction for each existing object, we call sendDownloadCompleteCB
; 85   : 	participantStruct->callDownloadCompleteCB=true;

	mov	eax, DWORD PTR _participantStruct$[ebp]
	mov	BYTE PTR [eax+6], 1

; 86   : 
; 87   :     // Add the new participant to the list of participants
; 88   : 	participantList.Insert(playerId,participantStruct);

	lea	eax, DWORD PTR _participantStruct$[ebp]
	push	eax
	lea	ecx, DWORD PTR _playerId$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?Insert@?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QAEIABUPlayerID@@ABQAUParticipantStruct@ReplicaManager@@@Z ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::Insert

; 89   : 
; 90   : 	if (autoConstructToNewParticipants)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+43]
	test	ecx, ecx
	je	SHORT $LN6@AddPartici

; 91   : 	{
; 92   : 		// Signal that we need to call SendConstruction for each existing object to this participant
; 93   : 		unsigned i;
; 94   : 		CommandStruct replicaAndCommand;
; 95   : 		replicaAndCommand.command=REPLICA_EXPLICIT_CONSTRUCTION;

	mov	BYTE PTR _replicaAndCommand$4[ebp+4], 1

; 96   : 		for (i=0; i < replicatedObjects.Size(); i++)

	mov	DWORD PTR _i$5[ebp], 0
	jmp	SHORT $LN3@AddPartici
$LN2@AddPartici:
	mov	eax, DWORD PTR _i$5[ebp]
	add	eax, 1
	mov	DWORD PTR _i$5[ebp], eax
$LN3@AddPartici:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Size@?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEIXZ ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::Size
	cmp	DWORD PTR _i$5[ebp], eax
	jae	SHORT $LN6@AddPartici

; 97   : 		{
; 98   : 			replicaAndCommand.replica=replicatedObjects[i].replica;

	mov	eax, DWORD PTR _i$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QBEAAURegisteredReplica@ReplicaManager@@I@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _replicaAndCommand$4[ebp], ecx

; 99   : 			participantStruct->commandList.Insert(replicaAndCommand.replica,replicaAndCommand);

	lea	eax, DWORD PTR _replicaAndCommand$4[ebp]
	push	eax
	lea	ecx, DWORD PTR _replicaAndCommand$4[ebp]
	push	ecx
	mov	ecx, DWORD PTR _participantStruct$[ebp]
	add	ecx, 7
	call	?Insert@?$OrderedList@PAVReplica@@UCommandStruct@ReplicaManager@@$1?CommandStructComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAEIABQAVReplica@@ABUCommandStruct@ReplicaManager@@@Z ; DataStructures::OrderedList<Replica *,ReplicaManager::CommandStruct,&ReplicaManager::CommandStructComp>::Insert

; 100  : 		}

	jmp	SHORT $LN2@AddPartici
$LN6@AddPartici:

; 101  : 	}
; 102  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN16@AddPartici
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 284				; 0000011cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN16@AddPartici:
	DD	2
	DD	$LN15@AddPartici
$LN15@AddPartici:
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN12@AddPartici
	DD	-60					; ffffffc4H
	DD	5
	DD	$LN13@AddPartici
$LN13@AddPartici:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	65					; 00000041H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	0
$LN12@AddPartici:
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	105					; 00000069H
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	117					; 00000075H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddParticipant@ReplicaManager@@QAEXUPlayerID@@@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?AddParticipant@ReplicaManager@@QAEXUPlayerID@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-288]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddParticipant@ReplicaManager@@QAEXUPlayerID@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddParticipant@ReplicaManager@@QAEXUPlayerID@@@Z ENDP	; ReplicaManager::AddParticipant
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\replicamanager.cpp
;	COMDAT ?SetAutoParticipateNewConnections@ReplicaManager@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_autoAdd$ = 8						; size = 1
?SetAutoParticipateNewConnections@ReplicaManager@@QAEX_N@Z PROC ; ReplicaManager::SetAutoParticipateNewConnections, COMDAT
; _this$ = ecx

; 67   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 68   : 	autoParticipateNewConnections=autoAdd;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _autoAdd$[ebp]
	mov	BYTE PTR [eax+41], cl

; 69   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetAutoParticipateNewConnections@ReplicaManager@@QAEX_N@Z ENDP ; ReplicaManager::SetAutoParticipateNewConnections
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\replicamanager.cpp
;	COMDAT ??1ReplicaManager@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1ReplicaManager@@QAE@XZ PROC				; ReplicaManager::~ReplicaManager, COMDAT
; _this$ = ecx

; 63   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1ReplicaManager@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7ReplicaManager@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 64   : 	Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@ReplicaManager@@IAEXXZ		; ReplicaManager::Clear

; 65   : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??1?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::~OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::~OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1ReplicaManager@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::~OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>
__unwindfunclet$??1ReplicaManager@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::~OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>
__ehhandler$??1ReplicaManager@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1ReplicaManager@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1ReplicaManager@@QAE@XZ ENDP				; ReplicaManager::~ReplicaManager
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\replicamanager.cpp
;	COMDAT ??0ReplicaManager@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0ReplicaManager@@QAE@XZ PROC				; ReplicaManager::ReplicaManager, COMDAT
; _this$ = ecx

; 52   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0ReplicaManager@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0PluginInterface@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7ReplicaManager@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??0?$OrderedList@UPlayerID@@PAUParticipantStruct@ReplicaManager@@$1?ParticipantStructComp@3@SAHABU1@ABQAU23@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>::OrderedList<PlayerID,ReplicaManager::ParticipantStruct *,&ReplicaManager::ParticipantStructComp>

; 53   : 	_constructionCB=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 54   : 	_sendDownloadCompleteCB=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32], 0

; 55   : 	_receiveDownloadCompleteCB=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], 0

; 56   : 	rakPeer=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+44], 0

; 57   : 	sendChannel=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+40], 0

; 58   : 	autoParticipateNewConnections=false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+41], 0

; 59   : 	defaultScope=false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+42], 0

; 60   : 	autoConstructToNewParticipants=false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+43], 0

; 61   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ReplicaManager@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$OrderedList@PAVReplica@@URegisteredReplica@ReplicaManager@@$1?RegisteredReplicaComp@3@SAHABQAV1@ABU23@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>::~OrderedList<Replica *,ReplicaManager::RegisteredReplica,&ReplicaManager::RegisteredReplicaComp>
__ehhandler$??0ReplicaManager@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0ReplicaManager@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0ReplicaManager@@QAE@XZ ENDP				; ReplicaManager::ReplicaManager
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0PluginInterface@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0PluginInterface@@QAE@XZ PROC				; PluginInterface::PluginInterface, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7PluginInterface@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0PluginInterface@@QAE@XZ ENDP				; PluginInterface::PluginInterface
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\networktypes.h
;	COMDAT ??4PlayerID@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_input$ = 8						; size = 4
??4PlayerID@@QAEAAU0@ABU0@@Z PROC			; PlayerID::operator=, COMDAT
; _this$ = ecx

; 74   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 75   : 		binaryAddress = input.binaryAddress;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 76   : 		port = input.port;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _input$[ebp]
	mov	dx, WORD PTR [ecx+4]
	mov	WORD PTR [eax+4], dx

; 77   : 		return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 78   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4PlayerID@@QAEAAU0@ABU0@@Z ENDP			; PlayerID::operator=
_TEXT	ENDS
END
