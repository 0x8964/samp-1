; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.31101.0 

	TITLE	Z:\sampsrc\02Xu1\raknet\TEABlockEncryptor.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?initObsDelta@TEABlockEncryptor@@1IA		; TEABlockEncryptor::initObsDelta
_DATA	SEGMENT
?initObsDelta@TEABlockEncryptor@@1IA DD 0c0a3da76H	; TEABlockEncryptor::initObsDelta
_DATA	ENDS
PUBLIC	??0TEABlockEncryptor@@QAE@XZ			; TEABlockEncryptor::TEABlockEncryptor
PUBLIC	??1TEABlockEncryptor@@QAE@XZ			; TEABlockEncryptor::~TEABlockEncryptor
PUBLIC	?IsKeySet@TEABlockEncryptor@@QBE_NXZ		; TEABlockEncryptor::IsKeySet
PUBLIC	?SetKey@TEABlockEncryptor@@QAEXQBE@Z		; TEABlockEncryptor::SetKey
PUBLIC	?UnsetKey@TEABlockEncryptor@@QAEXXZ		; TEABlockEncryptor::UnsetKey
PUBLIC	?Encrypt@TEABlockEncryptor@@QAEXPAEH0PAH@Z	; TEABlockEncryptor::Encrypt
PUBLIC	?Decrypt@TEABlockEncryptor@@QAE_NPAEH0PAH@Z	; TEABlockEncryptor::Decrypt
PUBLIC	?EncryptBlock@TEABlockEncryptor@@IAEXAAI0@Z	; TEABlockEncryptor::EncryptBlock
PUBLIC	?DecryptBlock@TEABlockEncryptor@@IAEXAAI0@Z	; TEABlockEncryptor::DecryptBlock
PUBLIC	??0CheckSum@@QAE@XZ				; CheckSum::CheckSum
PUBLIC	?Clear@CheckSum@@QAEXXZ				; CheckSum::Clear
PUBLIC	?Get@CheckSum@@QAEIXZ				; CheckSum::Get
PUBLIC	?DumpMemory@@YAXPBDPBEI@Z			; DumpMemory
PUBLIC	??_C@_04PFAOODAA@?$CFs?3?5?$AA@			; `string'
PUBLIC	??_C@_05CNDJFPDP@?$CF02x?5?$AA@			; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_05GHMHKIJK@ClKey?$AA@			; `string'
PUBLIC	?__LINE__Var@?1??Encrypt@TEABlockEncryptor@@QAEXPAEH0PAH@Z@4JA ; `TEABlockEncryptor::Encrypt'::`2'::__LINE__Var
PUBLIC	??_C@_1FM@CBDMDHFA@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAt?$AAe?$AAa?$AAb?$AAl?$AAo?$AAc?$AAk@ ; `string'
PUBLIC	??_C@_1O@DAMBNKLB@?$AAk?$AAe?$AAy?$AAS?$AAe?$AAt?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CK@LGOIMEII@?$AAi?$AAn?$AAp?$AAu?$AAt?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAp?$AAu?$AAt?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?$AA@ ; `string'
PUBLIC	??_C@_0M@BFDDMLOH@Pre?5Encrypt?$AA@		; `string'
PUBLIC	??_C@_0M@HFFPKDPO@PostEncrypt?$AA@		; `string'
PUBLIC	?__LINE__Var@?1??Decrypt@TEABlockEncryptor@@QAE_NPAEH0PAH@Z@4JA ; `TEABlockEncryptor::Decrypt'::`2'::__LINE__Var
PUBLIC	??_C@_0M@NLJOJPID@Pre?5Decrypt?$AA@		; `string'
PUBLIC	??_C@_0M@LLPCPHJK@PostDecrypt?$AA@		; `string'
EXTRN	_sprintf:PROC
EXTRN	??0DataBlockEncryptor@@QAE@XZ:PROC		; DataBlockEncryptor::DataBlockEncryptor
EXTRN	??1DataBlockEncryptor@@QAE@XZ:PROC		; DataBlockEncryptor::~DataBlockEncryptor
EXTRN	?Add@CheckSum@@QAEXPAEI@Z:PROC			; CheckSum::Add
EXTRN	?randomMT@@YAIXZ:PROC				; randomMT
EXTRN	__wassert:PROC
EXTRN	_memcpy:PROC
EXTRN	_strcat:PROC
EXTRN	_memmove:PROC
EXTRN	__imp__OutputDebugStringA@4:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0M@LLPCPHJK@PostDecrypt?$AA@
CONST	SEGMENT
??_C@_0M@LLPCPHJK@PostDecrypt?$AA@ DB 'PostDecrypt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NLJOJPID@Pre?5Decrypt?$AA@
CONST	SEGMENT
??_C@_0M@NLJOJPID@Pre?5Decrypt?$AA@ DB 'Pre Decrypt', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??Decrypt@TEABlockEncryptor@@QAE_NPAEH0PAH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??Decrypt@TEABlockEncryptor@@QAE_NPAEH0PAH@Z@4JA DD 099H ; `TEABlockEncryptor::Decrypt'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0M@HFFPKDPO@PostEncrypt?$AA@
CONST	SEGMENT
??_C@_0M@HFFPKDPO@PostEncrypt?$AA@ DB 'PostEncrypt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BFDDMLOH@Pre?5Encrypt?$AA@
CONST	SEGMENT
??_C@_0M@BFDDMLOH@Pre?5Encrypt?$AA@ DB 'Pre Encrypt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@LGOIMEII@?$AAi?$AAn?$AAp?$AAu?$AAt?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAp?$AAu?$AAt?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@LGOIMEII@?$AAi?$AAn?$AAp?$AAu?$AAt?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAp?$AAu?$AAt?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?$AA@ DB 'i'
	DB	00H, 'n', 00H, 'p', 00H, 'u', 00H, 't', 00H, ' ', 00H, '&', 00H
	DB	'&', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't'
	DB	00H, 'L', 00H, 'e', 00H, 'n', 00H, 'g', 00H, 't', 00H, 'h', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@DAMBNKLB@?$AAk?$AAe?$AAy?$AAS?$AAe?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1O@DAMBNKLB@?$AAk?$AAe?$AAy?$AAS?$AAe?$AAt?$AA?$AA@ DB 'k', 00H, 'e'
	DB	00H, 'y', 00H, 'S', 00H, 'e', 00H, 't', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FM@CBDMDHFA@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAt?$AAe?$AAa?$AAb?$AAl?$AAo?$AAc?$AAk@
CONST	SEGMENT
??_C@_1FM@CBDMDHFA@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAt?$AAe?$AAa?$AAb?$AAl?$AAo?$AAc?$AAk@ DB 'z'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H
	DB	's', 00H, 'r', 00H, 'c', 00H, '\', 00H, '0', 00H, '2', 00H, 'x'
	DB	00H, 'u', 00H, '1', 00H, '\', 00H, 'r', 00H, 'a', 00H, 'k', 00H
	DB	'n', 00H, 'e', 00H, 't', 00H, '\', 00H, 't', 00H, 'e', 00H, 'a'
	DB	00H, 'b', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, 'e', 00H
	DB	'n', 00H, 'c', 00H, 'r', 00H, 'y', 00H, 'p', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, '.', 00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??Encrypt@TEABlockEncryptor@@QAEXPAEH0PAH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??Encrypt@TEABlockEncryptor@@QAEXPAEH0PAH@Z@4JA DD 04bH ; `TEABlockEncryptor::Encrypt'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_05GHMHKIJK@ClKey?$AA@
CONST	SEGMENT
??_C@_05GHMHKIJK@ClKey?$AA@ DB 'ClKey', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05CNDJFPDP@?$CF02x?5?$AA@
CONST	SEGMENT
??_C@_05CNDJFPDP@?$CF02x?5?$AA@ DB '%02x ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PFAOODAA@?$CFs?3?5?$AA@
CONST	SEGMENT
??_C@_04PFAOODAA@?$CFs?3?5?$AA@ DB '%s: ', 00H		; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\teablockencryptor.cpp
;	COMDAT ?DumpMemory@@YAXPBDPBEI@Z
_TEXT	SEGMENT
_i$1 = -2036						; size = 4
_temp$ = -2024						; size = 5
_buffer$ = -2008					; size = 2000
__$ArrayPad$ = -4					; size = 4
_preText$ = 8						; size = 4
_data$ = 12						; size = 4
_count$ = 16						; size = 4
?DumpMemory@@YAXPBDPBEI@Z PROC				; DumpMemory, COMDAT

; 20   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2232				; 000008b8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-2232]
	mov	ecx, 558				; 0000022eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 21   : 	return;

	jmp	$LN4@DumpMemory

; 22   : 
; 23   : 	char buffer[2000];
; 24   : 	char temp[5];
; 25   : 	sprintf(buffer, "%s: ", preText);

	mov	eax, DWORD PTR _preText$[ebp]
	push	eax
	push	OFFSET ??_C@_04PFAOODAA@?$CFs?3?5?$AA@
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 26   : 	for(unsigned int i=0; i<count; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN3@DumpMemory
$LN2@DumpMemory:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN3@DumpMemory:
	mov	eax, DWORD PTR _i$1[ebp]
	cmp	eax, DWORD PTR _count$[ebp]
	jae	SHORT $LN1@DumpMemory

; 27   : 	{
; 28   : 		sprintf(temp, "%02x ", data[i]);

	mov	eax, DWORD PTR _data$[ebp]
	add	eax, DWORD PTR _i$1[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	push	OFFSET ??_C@_05CNDJFPDP@?$CF02x?5?$AA@
	lea	edx, DWORD PTR _temp$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 29   : 		strcat(buffer, temp);

	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 30   : 	}

	jmp	SHORT $LN2@DumpMemory
$LN1@DumpMemory:

; 31   : 	strcat(buffer, "\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 32   : 	OutputDebugString(buffer);

	mov	esi, esp
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__OutputDebugStringA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@DumpMemory:

; 33   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@DumpMemory
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 2232				; 000008b8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN9@DumpMemory:
	DD	2
	DD	$LN8@DumpMemory
$LN8@DumpMemory:
	DD	-2008					; fffff828H
	DD	2000					; 000007d0H
	DD	$LN6@DumpMemory
	DD	-2024					; fffff818H
	DD	5
	DD	$LN7@DumpMemory
$LN7@DumpMemory:
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
$LN6@DumpMemory:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
?DumpMemory@@YAXPBDPBEI@Z ENDP				; DumpMemory
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\checksum.h
;	COMDAT ?Get@CheckSum@@QAEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Get@CheckSum@@QAEIXZ PROC				; CheckSum::Get, COMDAT
; _this$ = ecx

; 41   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 42   : 		return sum;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+6]

; 43   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Get@CheckSum@@QAEIXZ ENDP				; CheckSum::Get
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\checksum.h
;	COMDAT ?Clear@CheckSum@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Clear@CheckSum@@QAEXXZ PROC				; CheckSum::Clear, COMDAT
; _this$ = ecx

; 24   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 25   : 		sum = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+6], 0

; 26   : 		r = 55665;

	mov	eax, 55665				; 0000d971H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx], ax

; 27   : 		c1 = 52845;

	mov	eax, 52845				; 0000ce6dH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+2], ax

; 28   : 		c2 = 22719;

	mov	eax, 22719				; 000058bfH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+4], ax

; 29   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@CheckSum@@QAEXXZ ENDP				; CheckSum::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\checksum.h
;	COMDAT ??0CheckSum@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0CheckSum@@QAE@XZ PROC				; CheckSum::CheckSum, COMDAT
; _this$ = ecx

; 18   : 	CheckSum()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 19   : 	{
; 20   : 		Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@CheckSum@@QAEXXZ			; CheckSum::Clear

; 21   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0CheckSum@@QAE@XZ ENDP				; CheckSum::CheckSum
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\teablockencryptor.cpp
;	COMDAT ?DecryptBlock@TEABlockEncryptor@@IAEXAAI0@Z
_TEXT	SEGMENT
_i$1 = -32						; size = 4
_sum$ = -20						; size = 4
_this$ = -8						; size = 4
_V0$ = 8						; size = 4
_V1$ = 12						; size = 4
?DecryptBlock@TEABlockEncryptor@@IAEXAAI0@Z PROC	; TEABlockEncryptor::DecryptBlock, COMDAT
; _this$ = ecx

; 230  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 231  : 	unsigned int sum = initSum;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+602]
	mov	DWORD PTR _sum$[ebp], ecx

; 232  : 
; 233  :     for(unsigned int i=0; i<TEA_ROUNDS; i++) 

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN3@DecryptBlo
$LN2@DecryptBlo:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN3@DecryptBlo:
	cmp	DWORD PTR _i$1[ebp], 32			; 00000020H
	jae	$LN4@DecryptBlo

; 234  : 	{
; 235  :         V1 -= ((V0 << 4 ^ V0 >> 5) + V0) ^ (sum + key[sum>>11 & 3]);

	mov	eax, DWORD PTR _V0$[ebp]
	mov	ecx, DWORD PTR [eax]
	shl	ecx, 4
	mov	edx, DWORD PTR _V0$[ebp]
	mov	eax, DWORD PTR [edx]
	shr	eax, 5
	xor	ecx, eax
	mov	edx, DWORD PTR _V0$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR _sum$[ebp]
	shr	eax, 11					; 0000000bH
	and	eax, 3
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+eax+586]
	add	eax, DWORD PTR _sum$[ebp]
	xor	ecx, eax
	mov	edx, DWORD PTR _V1$[ebp]
	mov	eax, DWORD PTR [edx]
	sub	eax, ecx
	mov	ecx, DWORD PTR _V1$[ebp]
	mov	DWORD PTR [ecx], eax

; 236  :         sum -= initDelta;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _sum$[ebp]
	sub	ecx, DWORD PTR [eax+606]
	mov	DWORD PTR _sum$[ebp], ecx

; 237  :         V0 -= ((V1 << 4 ^ V1 >> 5) + V1) ^ (sum + key[sum & 3]);

	mov	eax, DWORD PTR _V1$[ebp]
	mov	ecx, DWORD PTR [eax]
	shl	ecx, 4
	mov	edx, DWORD PTR _V1$[ebp]
	mov	eax, DWORD PTR [edx]
	shr	eax, 5
	xor	ecx, eax
	mov	edx, DWORD PTR _V1$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR _sum$[ebp]
	and	eax, 3
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+eax+586]
	add	eax, DWORD PTR _sum$[ebp]
	xor	ecx, eax
	mov	edx, DWORD PTR _V0$[ebp]
	mov	eax, DWORD PTR [edx]
	sub	eax, ecx
	mov	ecx, DWORD PTR _V0$[ebp]
	mov	DWORD PTR [ecx], eax

; 238  :     }

	jmp	$LN2@DecryptBlo
$LN4@DecryptBlo:

; 239  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?DecryptBlock@TEABlockEncryptor@@IAEXAAI0@Z ENDP	; TEABlockEncryptor::DecryptBlock
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\teablockencryptor.cpp
;	COMDAT ?EncryptBlock@TEABlockEncryptor@@IAEXAAI0@Z
_TEXT	SEGMENT
_i$1 = -32						; size = 4
_sum$ = -20						; size = 4
_this$ = -8						; size = 4
_V0$ = 8						; size = 4
_V1$ = 12						; size = 4
?EncryptBlock@TEABlockEncryptor@@IAEXAAI0@Z PROC	; TEABlockEncryptor::EncryptBlock, COMDAT
; _this$ = ecx

; 218  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 219  : 	unsigned int sum = 0;

	mov	DWORD PTR _sum$[ebp], 0

; 220  : 
; 221  : 	for(unsigned int i=0; i<TEA_ROUNDS; i++) 

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN3@EncryptBlo
$LN2@EncryptBlo:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN3@EncryptBlo:
	cmp	DWORD PTR _i$1[ebp], 32			; 00000020H
	jae	$LN4@EncryptBlo

; 222  : 	{
; 223  : 		V0 += ((V1 << 4 ^ V1 >> 5) + V1) ^ (sum + key[sum & 3]);

	mov	eax, DWORD PTR _V1$[ebp]
	mov	ecx, DWORD PTR [eax]
	shl	ecx, 4
	mov	edx, DWORD PTR _V1$[ebp]
	mov	eax, DWORD PTR [edx]
	shr	eax, 5
	xor	ecx, eax
	mov	edx, DWORD PTR _V1$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR _sum$[ebp]
	and	eax, 3
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+eax+586]
	add	eax, DWORD PTR _sum$[ebp]
	xor	ecx, eax
	mov	edx, DWORD PTR _V0$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR _V0$[ebp]
	mov	DWORD PTR [eax], ecx

; 224  : 		sum += initDelta;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _sum$[ebp]
	add	ecx, DWORD PTR [eax+606]
	mov	DWORD PTR _sum$[ebp], ecx

; 225  : 		V1 += ((V0 << 4 ^ V0 >> 5) + V0) ^ (sum + key[sum>>11 & 3]);

	mov	eax, DWORD PTR _V0$[ebp]
	mov	ecx, DWORD PTR [eax]
	shl	ecx, 4
	mov	edx, DWORD PTR _V0$[ebp]
	mov	eax, DWORD PTR [edx]
	shr	eax, 5
	xor	ecx, eax
	mov	edx, DWORD PTR _V0$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR _sum$[ebp]
	shr	eax, 11					; 0000000bH
	and	eax, 3
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+eax+586]
	add	eax, DWORD PTR _sum$[ebp]
	xor	ecx, eax
	mov	edx, DWORD PTR _V1$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR _V1$[ebp]
	mov	DWORD PTR [eax], ecx

; 226  : 	}

	jmp	$LN2@EncryptBlo
$LN4@EncryptBlo:

; 227  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?EncryptBlock@TEABlockEncryptor@@IAEXAAI0@Z ENDP	; TEABlockEncryptor::EncryptBlock
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\teablockencryptor.cpp
;	COMDAT ?Decrypt@TEABlockEncryptor@@QAE_NPAEH0PAH@Z
_TEXT	SEGMENT
_V1$1 = -112						; size = 4
_V0$2 = -100						; size = 4
_i$3 = -88						; size = 4
_checkSumCalculator$ = -76				; size = 10
_encodedPad$ = -53					; size = 1
_paddingBytes$ = -41					; size = 1
_checkSumInt$ = -32					; size = 4
_checkSum$ = -17					; size = 1
_this$ = -8						; size = 4
_input$ = 8						; size = 4
_inputLength$ = 12					; size = 4
_output$ = 16						; size = 4
_outputLength$ = 20					; size = 4
?Decrypt@TEABlockEncryptor@@QAE_NPAEH0PAH@Z PROC	; TEABlockEncryptor::Decrypt, COMDAT
; _this$ = ecx

; 153  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 308				; 00000134H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-308]
	mov	ecx, 77					; 0000004dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 154  : 	unsigned char checkSum;
; 155  : 	unsigned int checkSumInt;
; 156  : 	unsigned char paddingBytes;
; 157  : 	unsigned char encodedPad;
; 158  : 	CheckSum checkSumCalculator;

	lea	ecx, DWORD PTR _checkSumCalculator$[ebp]
	call	??0CheckSum@@QAE@XZ			; CheckSum::CheckSum

; 159  : 
; 160  : #ifdef _DEBUG
; 161  : 	assert( keySet );

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+585]
	test	ecx, ecx
	jne	SHORT $LN11@Decrypt
	mov	edx, DWORD PTR ?__LINE__Var@?1??Decrypt@TEABlockEncryptor@@QAE_NPAEH0PAH@Z@4JA
	add	edx, 8
	push	edx
	push	OFFSET ??_C@_1FM@CBDMDHFA@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAt?$AAe?$AAa?$AAb?$AAl?$AAo?$AAc?$AAk@
	push	OFFSET ??_C@_1O@DAMBNKLB@?$AAk?$AAe?$AAy?$AAS?$AAe?$AAt?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN11@Decrypt:

; 162  : #endif
; 163  : 
; 164  : 	if ( input == 0 || inputLength < 8 || ( inputLength % 8 ) != 0 )

	cmp	DWORD PTR _input$[ebp], 0
	je	SHORT $LN7@Decrypt
	cmp	DWORD PTR _inputLength$[ebp], 8
	jl	SHORT $LN7@Decrypt
	mov	eax, DWORD PTR _inputLength$[ebp]
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN15@Decrypt
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN15@Decrypt:
	test	eax, eax
	je	SHORT $LN8@Decrypt
$LN7@Decrypt:

; 165  : 	{
; 166  : 		return false;

	xor	al, al
	jmp	$LN9@Decrypt
$LN8@Decrypt:

; 167  : 	}
; 168  : 
; 169  : #ifdef _DEBUG
; 170  : 	DumpMemory("Pre Decrypt", input, inputLength);

	mov	eax, DWORD PTR _inputLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _input$[ebp]
	push	ecx
	push	OFFSET ??_C@_0M@NLJOJPID@Pre?5Decrypt?$AA@
	call	?DumpMemory@@YAXPBDPBEI@Z		; DumpMemory
	add	esp, 12					; 0000000cH

; 171  : #endif
; 172  : 
; 173  : 	for(int i=0; i<inputLength; i+=8)

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN6@Decrypt
$LN5@Decrypt:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 8
	mov	DWORD PTR _i$3[ebp], eax
$LN6@Decrypt:
	mov	eax, DWORD PTR _i$3[ebp]
	cmp	eax, DWORD PTR _inputLength$[ebp]
	jge	SHORT $LN4@Decrypt

; 174  : 	{
; 175  : 		unsigned int &V0 = *(reinterpret_cast<unsigned int*>(input+i));

	mov	eax, DWORD PTR _input$[ebp]
	add	eax, DWORD PTR _i$3[ebp]
	mov	DWORD PTR _V0$2[ebp], eax

; 176  : 		unsigned int &V1 = *(reinterpret_cast<unsigned int*>(input+i+sizeof(unsigned int)));

	mov	eax, DWORD PTR _i$3[ebp]
	mov	ecx, DWORD PTR _input$[ebp]
	lea	edx, DWORD PTR [ecx+eax+4]
	mov	DWORD PTR _V1$1[ebp], edx

; 177  : 		DecryptBlock(V0, V1);

	mov	eax, DWORD PTR _V1$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _V0$2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DecryptBlock@TEABlockEncryptor@@IAEXAAI0@Z ; TEABlockEncryptor::DecryptBlock

; 178  : 		//*(reinterpret_cast<unsigned int*>(input+i)+0) = V0;
; 179  : 		//*(reinterpret_cast<unsigned int*>(input+i)+1) = V1;
; 180  : 	}

	jmp	SHORT $LN5@Decrypt
$LN4@Decrypt:

; 181  : 
; 182  : #ifdef _DEBUG
; 183  : 	DumpMemory("PostDecrypt", input, inputLength);

	mov	eax, DWORD PTR _inputLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _input$[ebp]
	push	ecx
	push	OFFSET ??_C@_0M@LLPCPHJK@PostDecrypt?$AA@
	call	?DumpMemory@@YAXPBDPBEI@Z		; DumpMemory
	add	esp, 12					; 0000000cH

; 184  : #endif
; 185  : 
; 186  : 	// Read checksum
; 187  : 	checkSum = *(output);

	mov	eax, DWORD PTR _output$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _checkSum$[ebp], cl

; 188  : 
; 189  : 	// Read the pad size variable
; 190  : 	encodedPad = *(output + sizeof( checkSum ));

	mov	eax, DWORD PTR _output$[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR _encodedPad$[ebp], cl

; 191  : 
; 192  : 	// Only care about the last 4 bits
; 193  : 	paddingBytes = encodedPad & 0x0F;

	movzx	eax, BYTE PTR _encodedPad$[ebp]
	and	eax, 15					; 0000000fH
	mov	BYTE PTR _paddingBytes$[ebp], al

; 194  : 
; 195  : 	// Get the data length
; 196  : 	*outputLength = inputLength - sizeof( checkSum ) - sizeof( encodedPad ) - paddingBytes;

	mov	eax, DWORD PTR _inputLength$[ebp]
	sub	eax, 2
	movzx	ecx, BYTE PTR _paddingBytes$[ebp]
	sub	eax, ecx
	mov	edx, DWORD PTR _outputLength$[ebp]
	mov	DWORD PTR [edx], eax

; 197  : 
; 198  : 	// Calculate the checksum on the data.
; 199  : 	checkSumCalculator.Add( input + sizeof( checkSum ), *outputLength + sizeof( encodedPad ) + paddingBytes );

	mov	eax, DWORD PTR _outputLength$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR _paddingBytes$[ebp]
	lea	eax, DWORD PTR [ecx+edx+1]
	push	eax
	mov	ecx, DWORD PTR _input$[ebp]
	add	ecx, 1
	push	ecx
	lea	ecx, DWORD PTR _checkSumCalculator$[ebp]
	call	?Add@CheckSum@@QAEXPAEI@Z		; CheckSum::Add

; 200  : 	
; 201  : 	checkSumInt = checkSumCalculator.Get();

	lea	ecx, DWORD PTR _checkSumCalculator$[ebp]
	call	?Get@CheckSum@@QAEIXZ			; CheckSum::Get
	mov	DWORD PTR _checkSumInt$[ebp], eax

; 202  : 	checkSumInt = ( (checkSumInt << 4) ^ (checkSumInt) ) & 0xFF;

	mov	eax, DWORD PTR _checkSumInt$[ebp]
	shl	eax, 4
	xor	eax, DWORD PTR _checkSumInt$[ebp]
	and	eax, 255				; 000000ffH
	mov	DWORD PTR _checkSumInt$[ebp], eax

; 203  : 
; 204  : 	if ( (unsigned char)checkSumInt != checkSum )

	movzx	eax, BYTE PTR _checkSumInt$[ebp]
	movzx	ecx, BYTE PTR _checkSum$[ebp]
	cmp	eax, ecx
	je	SHORT $LN3@Decrypt

; 205  : 		return false;

	xor	al, al
	jmp	SHORT $LN9@Decrypt
$LN3@Decrypt:

; 206  : 
; 207  : 	// Read the data
; 208  : 	if ( input == output )

	mov	eax, DWORD PTR _input$[ebp]
	cmp	eax, DWORD PTR _output$[ebp]
	jne	SHORT $LN2@Decrypt

; 209  : 		memmove( output, input + sizeof( checkSum ) + sizeof( encodedPad ) + paddingBytes, *outputLength );

	mov	eax, DWORD PTR _outputLength$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	movzx	edx, BYTE PTR _paddingBytes$[ebp]
	mov	eax, DWORD PTR _input$[ebp]
	lea	ecx, DWORD PTR [eax+edx+2]
	push	ecx
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_memmove
	add	esp, 12					; 0000000cH

; 210  : 	else

	jmp	SHORT $LN1@Decrypt
$LN2@Decrypt:

; 211  : 		memcpy( output, input + sizeof( checkSum ) + sizeof( encodedPad ) + paddingBytes, *outputLength );

	mov	eax, DWORD PTR _outputLength$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	movzx	edx, BYTE PTR _paddingBytes$[ebp]
	mov	eax, DWORD PTR _input$[ebp]
	lea	ecx, DWORD PTR [eax+edx+2]
	push	ecx
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN1@Decrypt:

; 212  : 
; 213  : 	return true;

	mov	al, 1
$LN9@Decrypt:

; 214  : 
; 215  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN14@Decrypt
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 308				; 00000134H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	npad	1
$LN14@Decrypt:
	DD	1
	DD	$LN13@Decrypt
$LN13@Decrypt:
	DD	-76					; ffffffb4H
	DD	10					; 0000000aH
	DD	$LN12@Decrypt
$LN12@Decrypt:
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	83					; 00000053H
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	0
?Decrypt@TEABlockEncryptor@@QAE_NPAEH0PAH@Z ENDP	; TEABlockEncryptor::Decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\teablockencryptor.cpp
;	COMDAT ?Encrypt@TEABlockEncryptor@@QAEXPAEH0PAH@Z
_TEXT	SEGMENT
_V1$1 = -136						; size = 4
_V0$2 = -124						; size = 4
_i$3 = -112						; size = 4
_index$4 = -100						; size = 4
_checkSumCalculator$ = -88				; size = 10
_totalLength$ = -68					; size = 4
_encodedPad$ = -53					; size = 1
_paddingBytes$ = -41					; size = 1
_checkSumInt$ = -32					; size = 4
_checkSum$ = -17					; size = 1
_this$ = -8						; size = 4
_input$ = 8						; size = 4
_inputLength$ = 12					; size = 4
_output$ = 16						; size = 4
_outputLength$ = 20					; size = 4
?Encrypt@TEABlockEncryptor@@QAEXPAEH0PAH@Z PROC		; TEABlockEncryptor::Encrypt, COMDAT
; _this$ = ecx

; 75   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 332				; 0000014cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-332]
	mov	ecx, 83					; 00000053H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 76   : 	unsigned char checkSum;
; 77   : 	unsigned int checkSumInt;
; 78   : 	unsigned char paddingBytes;
; 79   : 	unsigned char encodedPad;
; 80   : 	unsigned int totalLength;
; 81   : 	CheckSum checkSumCalculator;

	lea	ecx, DWORD PTR _checkSumCalculator$[ebp]
	call	??0CheckSum@@QAE@XZ			; CheckSum::CheckSum

; 82   : 
; 83   : #ifdef _DEBUG
; 84   : 	assert( keySet );

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+585]
	test	ecx, ecx
	jne	SHORT $LN12@Encrypt
	mov	edx, DWORD PTR ?__LINE__Var@?1??Encrypt@TEABlockEncryptor@@QAEXPAEH0PAH@Z@4JA
	add	edx, 9
	push	edx
	push	OFFSET ??_C@_1FM@CBDMDHFA@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAt?$AAe?$AAa?$AAb?$AAl?$AAo?$AAc?$AAk@
	push	OFFSET ??_C@_1O@DAMBNKLB@?$AAk?$AAe?$AAy?$AAS?$AAe?$AAt?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN12@Encrypt:

; 85   : #endif
; 86   : 
; 87   : 	assert( input && inputLength );

	cmp	DWORD PTR _input$[ebp], 0
	je	SHORT $LN13@Encrypt
	cmp	DWORD PTR _inputLength$[ebp], 0
	jne	SHORT $LN14@Encrypt
$LN13@Encrypt:
	mov	eax, DWORD PTR ?__LINE__Var@?1??Encrypt@TEABlockEncryptor@@QAEXPAEH0PAH@Z@4JA
	add	eax, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_1FM@CBDMDHFA@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAt?$AAe?$AAa?$AAb?$AAl?$AAo?$AAc?$AAk@
	push	OFFSET ??_C@_1CK@LGOIMEII@?$AAi?$AAn?$AAp?$AAu?$AAt?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAp?$AAu?$AAt?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN14@Encrypt:

; 88   : 
; 89   : 	// # of padding bytes
; 90   : 	totalLength = inputLength + sizeof( checkSum ) + sizeof( encodedPad );

	mov	eax, DWORD PTR _inputLength$[ebp]
	add	eax, 2
	mov	DWORD PTR _totalLength$[ebp], eax

; 91   : 	paddingBytes = 0;

	mov	BYTE PTR _paddingBytes$[ebp], 0

; 92   : 
; 93   : 	/*if (totalLength < 16)
; 94   : 	{
; 95   : 		paddingBytes = 16 - totalLength;
; 96   : 	}
; 97   : 	else 
; 98   : 	*/
; 99   : 	if ((totalLength % 8) != 0)

	mov	eax, DWORD PTR _totalLength$[ebp]
	xor	edx, edx
	mov	ecx, 8
	div	ecx
	test	edx, edx
	je	SHORT $LN9@Encrypt

; 100  : 	{
; 101  : 		paddingBytes = 8 - (totalLength % 8);

	mov	eax, DWORD PTR _totalLength$[ebp]
	xor	edx, edx
	mov	ecx, 8
	div	ecx
	mov	eax, 8
	sub	eax, edx
	mov	BYTE PTR _paddingBytes$[ebp], al
$LN9@Encrypt:

; 102  : 	}
; 103  : 
; 104  : 	*outputLength = totalLength + paddingBytes;

	movzx	eax, BYTE PTR _paddingBytes$[ebp]
	add	eax, DWORD PTR _totalLength$[ebp]
	mov	ecx, DWORD PTR _outputLength$[ebp]
	mov	DWORD PTR [ecx], eax

; 105  : 
; 106  : 	// Randomize the pad size variable
; 107  : 	encodedPad = (unsigned char) randomMT();

	call	?randomMT@@YAIXZ			; randomMT
	mov	BYTE PTR _encodedPad$[ebp], al

; 108  : 	encodedPad <<= 4;

	mov	al, BYTE PTR _encodedPad$[ebp]
	shl	al, 4
	mov	BYTE PTR _encodedPad$[ebp], al

; 109  : 	encodedPad |= paddingBytes;

	movzx	eax, BYTE PTR _paddingBytes$[ebp]
	movzx	ecx, BYTE PTR _encodedPad$[ebp]
	or	ecx, eax
	mov	BYTE PTR _encodedPad$[ebp], cl

; 110  : 
; 111  : 	// Write the data first, in case we are overwriting ourselves
; 112  : 	if ( input == output )

	mov	eax, DWORD PTR _input$[ebp]
	cmp	eax, DWORD PTR _output$[ebp]
	jne	SHORT $LN8@Encrypt

; 113  : 		memmove( output + sizeof( checkSum ) + sizeof( encodedPad ) + paddingBytes, input, inputLength );

	mov	eax, DWORD PTR _inputLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _input$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _paddingBytes$[ebp]
	mov	eax, DWORD PTR _output$[ebp]
	lea	ecx, DWORD PTR [eax+edx+2]
	push	ecx
	call	_memmove
	add	esp, 12					; 0000000cH

; 114  : 	else

	jmp	SHORT $LN7@Encrypt
$LN8@Encrypt:

; 115  : 		memcpy( output + sizeof( checkSum ) + sizeof( encodedPad ) + paddingBytes, input, inputLength );

	mov	eax, DWORD PTR _inputLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _input$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _paddingBytes$[ebp]
	mov	eax, DWORD PTR _output$[ebp]
	lea	ecx, DWORD PTR [eax+edx+2]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN7@Encrypt:

; 116  : 
; 117  : 	// Write the pad size variable
; 118  : 	*(output + sizeof( checkSum )) = encodedPad;

	mov	eax, DWORD PTR _output$[ebp]
	mov	cl, BYTE PTR _encodedPad$[ebp]
	mov	BYTE PTR [eax+1], cl

; 119  : 
; 120  : 	// Write the padding
; 121  : 	for (unsigned int index = 0; index < paddingBytes; index++ )

	mov	DWORD PTR _index$4[ebp], 0
	jmp	SHORT $LN6@Encrypt
$LN5@Encrypt:
	mov	eax, DWORD PTR _index$4[ebp]
	add	eax, 1
	mov	DWORD PTR _index$4[ebp], eax
$LN6@Encrypt:
	movzx	eax, BYTE PTR _paddingBytes$[ebp]
	cmp	DWORD PTR _index$4[ebp], eax
	jae	SHORT $LN4@Encrypt

; 122  : 		*( output + sizeof( checkSum ) + sizeof( encodedPad ) + index ) = (unsigned char) randomMT();

	call	?randomMT@@YAIXZ			; randomMT
	mov	ecx, DWORD PTR _output$[ebp]
	add	ecx, DWORD PTR _index$4[ebp]
	mov	BYTE PTR [ecx+2], al
	jmp	SHORT $LN5@Encrypt
$LN4@Encrypt:

; 123  : 
; 124  : 	// Calculate the checksum on the data
; 125  : 	checkSumCalculator.Add( output + sizeof( checkSum ), inputLength + sizeof( encodedPad ) + paddingBytes );

	movzx	eax, BYTE PTR _paddingBytes$[ebp]
	mov	ecx, DWORD PTR _inputLength$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	push	edx
	mov	eax, DWORD PTR _output$[ebp]
	add	eax, 1
	push	eax
	lea	ecx, DWORD PTR _checkSumCalculator$[ebp]
	call	?Add@CheckSum@@QAEXPAEI@Z		; CheckSum::Add

; 126  : 
; 127  : 	checkSumInt = checkSumCalculator.Get();

	lea	ecx, DWORD PTR _checkSumCalculator$[ebp]
	call	?Get@CheckSum@@QAEIXZ			; CheckSum::Get
	mov	DWORD PTR _checkSumInt$[ebp], eax

; 128  : 	checkSum = (unsigned char) ( (checkSumInt << 4) ^ (checkSumInt) );

	mov	eax, DWORD PTR _checkSumInt$[ebp]
	shl	eax, 4
	xor	eax, DWORD PTR _checkSumInt$[ebp]
	mov	BYTE PTR _checkSum$[ebp], al

; 129  : 
; 130  : 	// Write checksum
; 131  : 	*(output) = checkSum;

	mov	eax, DWORD PTR _output$[ebp]
	mov	cl, BYTE PTR _checkSum$[ebp]
	mov	BYTE PTR [eax], cl

; 132  : 
; 133  : #ifdef _DEBUG
; 134  : 	DumpMemory("Pre Encrypt", output, *outputLength);

	mov	eax, DWORD PTR _outputLength$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	push	OFFSET ??_C@_0M@BFDDMLOH@Pre?5Encrypt?$AA@
	call	?DumpMemory@@YAXPBDPBEI@Z		; DumpMemory
	add	esp, 12					; 0000000cH

; 135  : #endif
; 136  : 
; 137  : 	for(int i=0; i < (*outputLength); i+=8)

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN3@Encrypt
$LN2@Encrypt:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 8
	mov	DWORD PTR _i$3[ebp], eax
$LN3@Encrypt:
	mov	eax, DWORD PTR _outputLength$[ebp]
	mov	ecx, DWORD PTR _i$3[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN1@Encrypt

; 138  : 	{
; 139  : 		unsigned int &V0 = *(reinterpret_cast<unsigned int*>(output+i));

	mov	eax, DWORD PTR _output$[ebp]
	add	eax, DWORD PTR _i$3[ebp]
	mov	DWORD PTR _V0$2[ebp], eax

; 140  : 		unsigned int &V1 = *(reinterpret_cast<unsigned int*>(output+i+sizeof(unsigned int)));

	mov	eax, DWORD PTR _i$3[ebp]
	mov	ecx, DWORD PTR _output$[ebp]
	lea	edx, DWORD PTR [ecx+eax+4]
	mov	DWORD PTR _V1$1[ebp], edx

; 141  : 		EncryptBlock(V0, V1);

	mov	eax, DWORD PTR _V1$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _V0$2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EncryptBlock@TEABlockEncryptor@@IAEXAAI0@Z ; TEABlockEncryptor::EncryptBlock

; 142  : 		//*(reinterpret_cast<unsigned int*>(output+i)+0) = V0;
; 143  : 		//*(reinterpret_cast<unsigned int*>(output+i)+1) = V1;
; 144  : 	}

	jmp	SHORT $LN2@Encrypt
$LN1@Encrypt:

; 145  : 
; 146  : #ifdef _DEBUG
; 147  : 	DumpMemory("PostEncrypt", output, *outputLength);

	mov	eax, DWORD PTR _outputLength$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	push	OFFSET ??_C@_0M@HFFPKDPO@PostEncrypt?$AA@
	call	?DumpMemory@@YAXPBDPBEI@Z		; DumpMemory
	add	esp, 12					; 0000000cH

; 148  : #endif
; 149  : 
; 150  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN17@Encrypt
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 332				; 0000014cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN17@Encrypt:
	DD	1
	DD	$LN16@Encrypt
$LN16@Encrypt:
	DD	-88					; ffffffa8H
	DD	10					; 0000000aH
	DD	$LN15@Encrypt
$LN15@Encrypt:
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	83					; 00000053H
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	0
?Encrypt@TEABlockEncryptor@@QAEXPAEH0PAH@Z ENDP		; TEABlockEncryptor::Encrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\teablockencryptor.cpp
;	COMDAT ?UnsetKey@TEABlockEncryptor@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?UnsetKey@TEABlockEncryptor@@QAEXXZ PROC		; TEABlockEncryptor::UnsetKey, COMDAT
; _this$ = ecx

; 70   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 71   : 	keySet = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+585], 0

; 72   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UnsetKey@TEABlockEncryptor@@QAEXXZ ENDP		; TEABlockEncryptor::UnsetKey
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\teablockencryptor.cpp
;	COMDAT ?SetKey@TEABlockEncryptor@@QAEXQBE@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_key$ = 8						; size = 4
?SetKey@TEABlockEncryptor@@QAEXQBE@Z PROC		; TEABlockEncryptor::SetKey, COMDAT
; _this$ = ecx

; 56   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 57   : #ifdef _DEBUG
; 58   : #ifdef SAMPSRV
; 59   : 	DumpMemory("SvKey", &key[0], 16);
; 60   : #else
; 61   : 	DumpMemory("ClKey", &key[0], 16);

	push	16					; 00000010H
	mov	eax, 1
	imul	ecx, eax, 0
	add	ecx, DWORD PTR _key$[ebp]
	push	ecx
	push	OFFSET ??_C@_05GHMHKIJK@ClKey?$AA@
	call	?DumpMemory@@YAXPBDPBEI@Z		; DumpMemory
	add	esp, 12					; 0000000cH

; 62   : #endif
; 63   : #endif
; 64   : 
; 65   : 	key = key;

	mov	eax, DWORD PTR _key$[ebp]
	mov	DWORD PTR _key$[ebp], eax

; 66   : 	keySet = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+585], 1

; 67   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetKey@TEABlockEncryptor@@QAEXQBE@Z ENDP		; TEABlockEncryptor::SetKey
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\teablockencryptor.cpp
;	COMDAT ?IsKeySet@TEABlockEncryptor@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?IsKeySet@TEABlockEncryptor@@QBE_NXZ PROC		; TEABlockEncryptor::IsKeySet, COMDAT
; _this$ = ecx

; 51   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 52   : 	return keySet;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+585]

; 53   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsKeySet@TEABlockEncryptor@@QBE_NXZ ENDP		; TEABlockEncryptor::IsKeySet
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\teablockencryptor.cpp
;	COMDAT ??1TEABlockEncryptor@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1TEABlockEncryptor@@QAE@XZ PROC			; TEABlockEncryptor::~TEABlockEncryptor, COMDAT
; _this$ = ecx

; 45   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 46   : 	// Note: This is not virtual
; 47   : 	//       Make it cascaded virtual before adding any code here!
; 48   : }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DataBlockEncryptor@@QAE@XZ		; DataBlockEncryptor::~DataBlockEncryptor
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1TEABlockEncryptor@@QAE@XZ ENDP			; TEABlockEncryptor::~TEABlockEncryptor
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\teablockencryptor.cpp
;	COMDAT ??0TEABlockEncryptor@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0TEABlockEncryptor@@QAE@XZ PROC			; TEABlockEncryptor::TEABlockEncryptor, COMDAT
; _this$ = ecx

; 37   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0DataBlockEncryptor@@QAE@XZ		; DataBlockEncryptor::DataBlockEncryptor

; 38   : 	initDelta = initObsDelta ^ TEA_XOR_MASK;

	mov	eax, DWORD PTR ?initObsDelta@TEABlockEncryptor@@1IA ; TEABlockEncryptor::initObsDelta
	xor	eax, 1586799567				; 5e94a3cfH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+606], eax

; 39   : 	initSum = initDelta * TEA_ROUNDS;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+606]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+602], ecx

; 40   : 
; 41   : 	keySet = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+585], 0

; 42   : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0TEABlockEncryptor@@QAE@XZ ENDP			; TEABlockEncryptor::TEABlockEncryptor
_TEXT	ENDS
END
