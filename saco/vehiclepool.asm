; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.31101.0 

	TITLE	Z:\sampsrc\02Xu1\saco\net\vehiclepool.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
_disable_marker DW 0164H
	DB	'i', 00H
	ORG $+14
CONST	ENDS
PUBLIC	??$Write@G@BitStream@RakNet@@QAEXG@Z		; RakNet::BitStream::Write<unsigned short>
PUBLIC	?GetVirtualWorld@CLocalPlayer@@QAEEXZ		; CLocalPlayer::GetVirtualWorld
PUBLIC	?GetLocalPlayer@CPlayerPool@@QAEPAVCLocalPlayer@@XZ ; CPlayerPool::GetLocalPlayer
PUBLIC	??0CVehiclePool@@QAE@XZ				; CVehiclePool::CVehiclePool
PUBLIC	??1CVehiclePool@@QAE@XZ				; CVehiclePool::~CVehiclePool
PUBLIC	?New@CVehiclePool@@QAEHGHPAU_VECTOR@@MHH0MHPAD@Z ; CVehiclePool::New
PUBLIC	?Delete@CVehiclePool@@QAEHG@Z			; CVehiclePool::Delete
PUBLIC	?GetSlotState@CVehiclePool@@QAEHG@Z		; CVehiclePool::GetSlotState
PUBLIC	?Spawn@CVehiclePool@@QAEHGHPAU_VECTOR@@MHHHPADHH@Z ; CVehiclePool::Spawn
PUBLIC	?ProcessForVirtualWorld@CVehiclePool@@QAEXGE@Z	; CVehiclePool::ProcessForVirtualWorld
PUBLIC	?Process@CVehiclePool@@QAEXXZ			; CVehiclePool::Process
PUBLIC	?NotifyVehicleDeath@CVehiclePool@@QAEXG@Z	; CVehiclePool::NotifyVehicleDeath
PUBLIC	?FindNearestToLocalPlayerPed@CVehiclePool@@QAEHXZ ; CVehiclePool::FindNearestToLocalPlayerPed
PUBLIC	?AssignSpecialParamsToVehicle@CVehiclePool@@QAEXGEE@Z ; CVehiclePool::AssignSpecialParamsToVehicle
PUBLIC	?SetForRespawn@CVehiclePool@@QAEXGH@Z		; CVehiclePool::SetForRespawn
PUBLIC	?LinkToInterior@CVehiclePool@@QAEXGH@Z		; CVehiclePool::LinkToInterior
PUBLIC	?FindIDFromGtaPtr@CVehiclePool@@QAEGPAU_VEHICLE_TYPE@@@Z ; CVehiclePool::FindIDFromGtaPtr
PUBLIC	?FindGtaIDFromID@CVehiclePool@@QAEHH@Z		; CVehiclePool::FindGtaIDFromID
PUBLIC	?FindGtaIDFromGtaPtr@CVehiclePool@@QAEHPAU_VEHICLE_TYPE@@@Z ; CVehiclePool::FindGtaIDFromGtaPtr
PUBLIC	?GetPlayerPool@CNetGame@@QAEPAVCPlayerPool@@XZ	; CNetGame::GetPlayerPool
PUBLIC	?GetRakClient@CNetGame@@QAEPAVRakClientInterface@@XZ ; CNetGame::GetRakClient
PUBLIC	??_C@_0CI@IHKPOFFI@Inactive?5vehicle?5getting?5respawn@ ; `string'
PUBLIC	??_C@_02JPDDFAPL@dm?$AA@			; `string'
PUBLIC	__real@00000000
PUBLIC	__real@43480000
PUBLIC	__real@461c4000
EXTRN	_sprintf:PROC
EXTRN	_memset:PROC
EXTRN	__imp__OutputDebugStringA@4:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	?IsAdded@CEntity@@QAEHXZ:PROC			; CEntity::IsAdded
EXTRN	?GetMatrix@CEntity@@QAEXPAU_MATRIX4X4@@@Z:PROC	; CEntity::GetMatrix
EXTRN	?TeleportTo@CEntity@@QAEXMMM@Z:PROC		; CEntity::TeleportTo
EXTRN	?GetDistanceFromLocalPlayerPed@CEntity@@QAEMXZ:PROC ; CEntity::GetDistanceFromLocalPlayerPed
EXTRN	?ProcessMarkers@CVehicle@@QAEXXZ:PROC		; CVehicle::ProcessMarkers
EXTRN	?GetVehicleSubtype@CVehicle@@QAEIXZ:PROC	; CVehicle::GetVehicleSubtype
EXTRN	?GetHealth@CVehicle@@QAEMXZ:PROC		; CVehicle::GetHealth
EXTRN	?SetColor@CVehicle@@QAEXHH@Z:PROC		; CVehicle::SetColor
EXTRN	?HasSunk@CVehicle@@QAEHXZ:PROC			; CVehicle::HasSunk
EXTRN	?IsDriverLocalPlayer@CVehicle@@QAEHXZ:PROC	; CVehicle::IsDriverLocalPlayer
EXTRN	?SetInvulnerable@CVehicle@@QAEXH@Z:PROC		; CVehicle::SetInvulnerable
EXTRN	?SetEngineState@CVehicle@@QAEXH@Z:PROC		; CVehicle::SetEngineState
EXTRN	?SetDoorState@CVehicle@@QAEXH@Z:PROC		; CVehicle::SetDoorState
EXTRN	?LinkToInterior@CVehicle@@QAEXH@Z:PROC		; CVehicle::LinkToInterior
EXTRN	?GetTrailer@CVehicle@@QAEPAV1@XZ:PROC		; CVehicle::GetTrailer
EXTRN	?IsOccupied@CVehicle@@QAEHXZ:PROC		; CVehicle::IsOccupied
EXTRN	?UpdateLastDrivenTime@CVehicle@@QAEHXZ:PROC	; CVehicle::UpdateLastDrivenTime
EXTRN	?SetHornState@CVehicle@@QAEXE@Z:PROC		; CVehicle::SetHornState
EXTRN	?HasADriver@CVehicle@@QAEHXZ:PROC		; CVehicle::HasADriver
EXTRN	?ScriptCommand@@YAHPBUSCRIPT_COMMAND@@ZZ:PROC	; ScriptCommand
EXTRN	?NewVehicle@CGame@@QAEPAVCVehicle@@HMMMMPAD@Z:PROC ; CGame::NewVehicle
EXTRN	??0BitStream@RakNet@@QAE@XZ:PROC		; RakNet::BitStream::BitStream
EXTRN	??1BitStream@RakNet@@QAE@XZ:PROC		; RakNet::BitStream::~BitStream
EXTRN	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z:PROC	; RakNet::BitStream::WriteBits
EXTRN	?GamePool_Vehicle_GetIndex@@YGKPAU_VEHICLE_TYPE@@@Z:PROC ; GamePool_Vehicle_GetIndex
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?pNetGame@@3PAVCNetGame@@A:DWORD		; pNetGame
EXTRN	?pGame@@3PAVCGame@@A:DWORD			; pGame
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __real@461c4000
CONST	SEGMENT
__real@461c4000 DD 0461c4000r			; 10000
CONST	ENDS
;	COMDAT __real@43480000
CONST	SEGMENT
__real@43480000 DD 043480000r			; 200
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_02JPDDFAPL@dm?$AA@
CONST	SEGMENT
??_C@_02JPDDFAPL@dm?$AA@ DB 'dm', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@IHKPOFFI@Inactive?5vehicle?5getting?5respawn@
CONST	SEGMENT
??_C@_0CI@IHKPOFFI@Inactive?5vehicle?5getting?5respawn@ DB 'Inactive vehi'
	DB	'cle getting respawned: %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?NotifyVehicleDeath@CVehiclePool@@QAEXG@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?NotifyVehicleDeath@CVehiclePool@@QAEXG@Z$0
__ehfuncinfo$?NotifyVehicleDeath@CVehiclePool@@QAEXG@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?NotifyVehicleDeath@CVehiclePool@@QAEXG@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\net\netgame.h
;	COMDAT ?GetRakClient@CNetGame@@QAEPAVRakClientInterface@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetRakClient@CNetGame@@QAEPAVRakClientInterface@@XZ PROC ; CNetGame::GetRakClient, COMDAT
; _this$ = ecx

; 103  : 	RakClientInterface * GetRakClient() { return m_pRakClient; };

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+28]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetRakClient@CNetGame@@QAEPAVRakClientInterface@@XZ ENDP ; CNetGame::GetRakClient
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\net\netgame.h
;	COMDAT ?GetPlayerPool@CNetGame@@QAEPAVCPlayerPool@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetPlayerPool@CNetGame@@QAEPAVCPlayerPool@@XZ PROC	; CNetGame::GetPlayerPool, COMDAT
; _this$ = ecx

; 96   : 	CPlayerPool * GetPlayerPool() { return m_pPlayerPool; };

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPlayerPool@CNetGame@@QAEPAVCPlayerPool@@XZ ENDP	; CNetGame::GetPlayerPool
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\net\vehiclepool.cpp
;	COMDAT ?FindGtaIDFromGtaPtr@CVehiclePool@@QAEHPAU_VEHICLE_TYPE@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pGtaVehicle$ = 8					; size = 4
?FindGtaIDFromGtaPtr@CVehiclePool@@QAEHPAU_VEHICLE_TYPE@@@Z PROC ; CVehiclePool::FindGtaIDFromGtaPtr, COMDAT
; _this$ = ecx

; 175  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 176  : 	return GamePool_Vehicle_GetIndex(pGtaVehicle);

	mov	eax, DWORD PTR _pGtaVehicle$[ebp]
	push	eax
	call	?GamePool_Vehicle_GetIndex@@YGKPAU_VEHICLE_TYPE@@@Z ; GamePool_Vehicle_GetIndex

; 177  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?FindGtaIDFromGtaPtr@CVehiclePool@@QAEHPAU_VEHICLE_TYPE@@@Z ENDP ; CVehiclePool::FindGtaIDFromGtaPtr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\net\vehiclepool.cpp
;	COMDAT ?FindGtaIDFromID@CVehiclePool@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_iID$ = 8						; size = 4
?FindGtaIDFromID@CVehiclePool@@QAEHH@Z PROC		; CVehiclePool::FindGtaIDFromID, COMDAT
; _this$ = ecx

; 168  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 169  : 	return GamePool_Vehicle_GetIndex(m_pGTAVehicles[iID]);

	mov	eax, DWORD PTR _iID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+5616]
	push	edx
	call	?GamePool_Vehicle_GetIndex@@YGKPAU_VEHICLE_TYPE@@@Z ; GamePool_Vehicle_GetIndex

; 170  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?FindGtaIDFromID@CVehiclePool@@QAEHH@Z ENDP		; CVehiclePool::FindGtaIDFromID
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\net\vehiclepool.cpp
;	COMDAT ?FindIDFromGtaPtr@CVehiclePool@@QAEGPAU_VEHICLE_TYPE@@@Z
_TEXT	SEGMENT
_x$ = -20						; size = 4
_this$ = -8						; size = 4
_pGtaVehicle$ = 8					; size = 4
?FindIDFromGtaPtr@CVehiclePool@@QAEGPAU_VEHICLE_TYPE@@@Z PROC ; CVehiclePool::FindIDFromGtaPtr, COMDAT
; _this$ = ecx

; 154  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 	int x=1;

	mov	DWORD PTR _x$[ebp], 1
$LN3@FindIDFrom:

; 156  : 	
; 157  : 	while(x!=MAX_VEHICLES) {

	cmp	DWORD PTR _x$[ebp], 702			; 000002beH
	je	SHORT $LN2@FindIDFrom

; 158  : 		if(pGtaVehicle == m_pGTAVehicles[x]) return x;

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pGtaVehicle$[ebp]
	cmp	edx, DWORD PTR [ecx+eax*4+5616]
	jne	SHORT $LN1@FindIDFrom
	mov	ax, WORD PTR _x$[ebp]
	jmp	SHORT $LN4@FindIDFrom
$LN1@FindIDFrom:

; 159  : 		x++;

	mov	eax, DWORD PTR _x$[ebp]
	add	eax, 1
	mov	DWORD PTR _x$[ebp], eax

; 160  : 	}

	jmp	SHORT $LN3@FindIDFrom
$LN2@FindIDFrom:

; 161  : 
; 162  : 	return INVALID_VEHICLE_ID;

	mov	eax, 65535				; 0000ffffH
$LN4@FindIDFrom:

; 163  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?FindIDFromGtaPtr@CVehiclePool@@QAEGPAU_VEHICLE_TYPE@@@Z ENDP ; CVehiclePool::FindIDFromGtaPtr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\net\vehiclepool.cpp
;	COMDAT ?LinkToInterior@CVehiclePool@@QAEXGH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_VehicleID$ = 8						; size = 2
_iInterior$ = 12					; size = 4
?LinkToInterior@CVehiclePool@@QAEXGH@Z PROC		; CVehiclePool::LinkToInterior, COMDAT
; _this$ = ecx

; 123  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 	if(m_bVehicleSlotState[VehicleID]) {

	movzx	eax, WORD PTR _VehicleID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $LN2@LinkToInte

; 125  : 		m_SpawnInfo[VehicleID].iInterior = iInterior;

	movzx	eax, WORD PTR _VehicleID$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iInterior$[ebp]
	mov	DWORD PTR [edx+ecx+14076], eax

; 126  : 		m_pVehicles[VehicleID]->LinkToInterior(iInterior);

	mov	eax, DWORD PTR _iInterior$[ebp]
	push	eax
	movzx	ecx, WORD PTR _VehicleID$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+2808]
	call	?LinkToInterior@CVehicle@@QAEXH@Z	; CVehicle::LinkToInterior
$LN2@LinkToInte:

; 127  : 	}
; 128  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?LinkToInterior@CVehiclePool@@QAEXGH@Z ENDP		; CVehiclePool::LinkToInterior
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\net\vehiclepool.cpp
;	COMDAT ?SetForRespawn@CVehiclePool@@QAEXGH@Z
_TEXT	SEGMENT
_pVehicle$ = -20					; size = 4
_this$ = -8						; size = 4
_VehicleID$ = 8						; size = 2
_iRespawnDelay$ = 12					; size = 4
?SetForRespawn@CVehiclePool@@QAEXGH@Z PROC		; CVehiclePool::SetForRespawn, COMDAT
; _this$ = ecx

; 345  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 346  : 	CVehicle *pVehicle = m_pVehicles[VehicleID];

	movzx	eax, WORD PTR _VehicleID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+2808]
	mov	DWORD PTR _pVehicle$[ebp], edx

; 347  : 
; 348  : 	if(pVehicle) {

	cmp	DWORD PTR _pVehicle$[ebp], 0
	je	SHORT $LN2@SetForResp

; 349  : 		m_bIsActive[VehicleID] = FALSE;

	movzx	eax, WORD PTR _VehicleID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+8424], 0

; 350  : 		m_bIsWasted[VehicleID] = TRUE;

	movzx	eax, WORD PTR _VehicleID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+11232], 1

; 351  : 		m_iRespawnDelay[VehicleID] = iRespawnDelay;

	movzx	eax, WORD PTR _VehicleID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iRespawnDelay$[ebp]
	mov	DWORD PTR [ecx+eax*4+42120], edx
$LN2@SetForResp:

; 352  : 	}
; 353  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetForRespawn@CVehiclePool@@QAEXGH@Z ENDP		; CVehiclePool::SetForRespawn
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\net\vehiclepool.cpp
;	COMDAT ?AssignSpecialParamsToVehicle@CVehiclePool@@QAEXGEE@Z
_TEXT	SEGMENT
_pVehicle$ = -20					; size = 4
_this$ = -8						; size = 4
_VehicleID$ = 8						; size = 2
_byteObjective$ = 12					; size = 1
_byteDoorsLocked$ = 16					; size = 1
?AssignSpecialParamsToVehicle@CVehiclePool@@QAEXGEE@Z PROC ; CVehiclePool::AssignSpecialParamsToVehicle, COMDAT
; _this$ = ecx

; 133  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 134  : 	if(!GetSlotState(VehicleID)) return;

	movzx	eax, WORD PTR _VehicleID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSlotState@CVehiclePool@@QAEHG@Z	; CVehiclePool::GetSlotState
	test	eax, eax
	jne	SHORT $LN3@AssignSpec
	jmp	SHORT $LN4@AssignSpec
$LN3@AssignSpec:

; 135  : 
; 136  : 	m_SpawnInfo[VehicleID].iObjective = byteObjective;

	movzx	eax, BYTE PTR _byteObjective$[ebp]
	movzx	ecx, WORD PTR _VehicleID$[ebp]
	imul	edx, ecx, 40
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx+14068], eax

; 137  : 	m_SpawnInfo[VehicleID].iDoorsLocked = byteDoorsLocked;

	movzx	eax, BYTE PTR _byteDoorsLocked$[ebp]
	movzx	ecx, WORD PTR _VehicleID$[ebp]
	imul	edx, ecx, 40
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx+14072], eax

; 138  : 	
; 139  : 	CVehicle *pVehicle = m_pVehicles[VehicleID];

	movzx	eax, WORD PTR _VehicleID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+2808]
	mov	DWORD PTR _pVehicle$[ebp], edx

; 140  : 
; 141  : 	if(pVehicle && m_bIsActive[VehicleID]) {

	cmp	DWORD PTR _pVehicle$[ebp], 0
	je	SHORT $LN4@AssignSpec
	movzx	eax, WORD PTR _VehicleID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4+8424], 0
	je	SHORT $LN4@AssignSpec

; 142  : 		if (byteObjective)

	movzx	eax, BYTE PTR _byteObjective$[ebp]
	test	eax, eax
	je	SHORT $LN1@AssignSpec

; 143  : 		{
; 144  : 			pVehicle->m_byteObjectiveVehicle = 1;

	mov	eax, DWORD PTR _pVehicle$[ebp]
	mov	BYTE PTR [eax+32], 1

; 145  : 			pVehicle->m_bSpecialMarkerEnabled = false;

	mov	eax, DWORD PTR _pVehicle$[ebp]
	mov	DWORD PTR [eax+33], 0
$LN1@AssignSpec:

; 146  : 		}
; 147  : 		pVehicle->SetDoorState(byteDoorsLocked);

	movzx	eax, BYTE PTR _byteDoorsLocked$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pVehicle$[ebp]
	call	?SetDoorState@CVehicle@@QAEXH@Z		; CVehicle::SetDoorState
$LN4@AssignSpec:

; 148  : 	}
; 149  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?AssignSpecialParamsToVehicle@CVehiclePool@@QAEXGEE@Z ENDP ; CVehiclePool::AssignSpecialParamsToVehicle
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\net\vehiclepool.cpp
;	COMDAT ?FindNearestToLocalPlayerPed@CVehiclePool@@QAEHXZ
_TEXT	SEGMENT
_x$ = -56						; size = 2
_ClosestSoFar$ = -44					; size = 2
_fThisDistance$ = -32					; size = 4
_fLeastDistance$ = -20					; size = 4
_this$ = -8						; size = 4
?FindNearestToLocalPlayerPed@CVehiclePool@@QAEHXZ PROC	; CVehiclePool::FindNearestToLocalPlayerPed, COMDAT
; _this$ = ecx

; 368  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 369  : 	float fLeastDistance=10000.0f;

	movss	xmm0, DWORD PTR __real@461c4000
	movss	DWORD PTR _fLeastDistance$[ebp], xmm0

; 370  : 	float fThisDistance;
; 371  : 	VEHICLEID ClosestSoFar=INVALID_VEHICLE_ID;

	mov	eax, 65535				; 0000ffffH
	mov	WORD PTR _ClosestSoFar$[ebp], ax

; 372  : 
; 373  : 	VEHICLEID x=0;

	xor	eax, eax
	mov	WORD PTR _x$[ebp], ax
$LN4@FindNeares:

; 374  : 	while(x < MAX_VEHICLES) {

	movzx	eax, WORD PTR _x$[ebp]
	cmp	eax, 702				; 000002beH
	jge	SHORT $LN3@FindNeares

; 375  : 		if(GetSlotState(x) && m_bIsActive[x]) {

	movzx	eax, WORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSlotState@CVehiclePool@@QAEHG@Z	; CVehiclePool::GetSlotState
	test	eax, eax
	je	SHORT $LN1@FindNeares
	movzx	eax, WORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4+8424], 0
	je	SHORT $LN1@FindNeares

; 376  : 			fThisDistance = m_pVehicles[x]->GetDistanceFromLocalPlayerPed();

	movzx	eax, WORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+2808]
	call	?GetDistanceFromLocalPlayerPed@CEntity@@QAEMXZ ; CEntity::GetDistanceFromLocalPlayerPed
	fstp	DWORD PTR _fThisDistance$[ebp]

; 377  : 			if(fThisDistance < fLeastDistance) {

	movss	xmm0, DWORD PTR _fLeastDistance$[ebp]
	comiss	xmm0, DWORD PTR _fThisDistance$[ebp]
	jbe	SHORT $LN1@FindNeares

; 378  : 				fLeastDistance = fThisDistance;

	movss	xmm0, DWORD PTR _fThisDistance$[ebp]
	movss	DWORD PTR _fLeastDistance$[ebp], xmm0

; 379  : 				ClosestSoFar = x;

	mov	ax, WORD PTR _x$[ebp]
	mov	WORD PTR _ClosestSoFar$[ebp], ax
$LN1@FindNeares:

; 380  : 			}
; 381  : 		}
; 382  : 		x++;

	mov	ax, WORD PTR _x$[ebp]
	add	ax, 1
	mov	WORD PTR _x$[ebp], ax

; 383  : 	}

	jmp	SHORT $LN4@FindNeares
$LN3@FindNeares:

; 384  : 
; 385  : 	return ClosestSoFar;

	movzx	eax, WORD PTR _ClosestSoFar$[ebp]

; 386  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?FindNearestToLocalPlayerPed@CVehiclePool@@QAEHXZ ENDP	; CVehiclePool::FindNearestToLocalPlayerPed
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\net\vehiclepool.cpp
;	COMDAT ?NotifyVehicleDeath@CVehiclePool@@QAEXG@Z
_TEXT	SEGMENT
tv72 = -508						; size = 4
_bsDeath$ = -308					; size = 273
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_VehicleID$ = 8						; size = 2
?NotifyVehicleDeath@CVehiclePool@@QAEXG@Z PROC		; CVehiclePool::NotifyVehicleDeath, COMDAT
; _this$ = ecx

; 358  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?NotifyVehicleDeath@CVehiclePool@@QAEXG@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 496				; 000001f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-508]
	mov	ecx, 124				; 0000007cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 359  : 	RakNet::BitStream bsDeath;

	lea	ecx, DWORD PTR _bsDeath$[ebp]
	call	??0BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 360  : 	bsDeath.Write(VehicleID);

	movzx	eax, WORD PTR _VehicleID$[ebp]
	push	eax
	lea	ecx, DWORD PTR _bsDeath$[ebp]
	call	??$Write@G@BitStream@RakNet@@QAEXG@Z	; RakNet::BitStream::Write<unsigned short>

; 361  : 	pNetGame->GetRakClient()->RPC(RPC_VehicleDestroyed, &bsDeath, HIGH_PRIORITY, RELIABLE_SEQUENCED, 0, false);

	mov	ecx, DWORD PTR ?pNetGame@@3PAVCNetGame@@A ; pNetGame
	call	?GetRakClient@CNetGame@@QAEPAVRakClientInterface@@XZ ; CNetGame::GetRakClient
	mov	DWORD PTR tv72[ebp], eax
	mov	esi, esp
	push	0
	push	0
	push	4
	push	1
	lea	eax, DWORD PTR _bsDeath$[ebp]
	push	eax
	push	OFFSET ??_C@_02JPDDFAPL@dm?$AA@
	mov	ecx, DWORD PTR tv72[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv72[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 362  : 	pNetGame->GetPlayerPool()->GetLocalPlayer()->m_LastVehicle = 0xFFFF; // Mark as notification sent

	mov	ecx, DWORD PTR ?pNetGame@@3PAVCNetGame@@A ; pNetGame
	call	?GetPlayerPool@CNetGame@@QAEPAVCPlayerPool@@XZ ; CNetGame::GetPlayerPool
	mov	ecx, eax
	call	?GetLocalPlayer@CPlayerPool@@QAEPAVCLocalPlayer@@XZ ; CPlayerPool::GetLocalPlayer
	mov	ecx, 65535				; 0000ffffH
	mov	WORD PTR [eax+37], cx

; 363  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _bsDeath$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@NotifyVehi
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 508				; 000001fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN7@NotifyVehi:
	DD	1
	DD	$LN6@NotifyVehi
$LN6@NotifyVehi:
	DD	-308					; fffffeccH
	DD	273					; 00000111H
	DD	$LN4@NotifyVehi
$LN4@NotifyVehi:
	DB	98					; 00000062H
	DB	115					; 00000073H
	DB	68					; 00000044H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?NotifyVehicleDeath@CVehiclePool@@QAEXG@Z$0:
	lea	ecx, DWORD PTR _bsDeath$[ebp]
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__ehhandler$?NotifyVehicleDeath@CVehiclePool@@QAEXG@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-512]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?NotifyVehicleDeath@CVehiclePool@@QAEXG@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?NotifyVehicleDeath@CVehiclePool@@QAEXG@Z ENDP		; CVehiclePool::NotifyVehicleDeath
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\net\vehiclepool.cpp
;	COMDAT ?Process@CVehiclePool@@QAEXXZ
_TEXT	SEGMENT
tv349 = -1400						; size = 4
tv335 = -1400						; size = 4
_szBuffer2$1 = -1200					; size = 1024
_matPos$2 = -168					; size = 64
_pTrailer$3 = -96					; size = 4
_x$4 = -84						; size = 2
_localVW$ = -69						; size = 1
_pLocalPlayer$ = -60					; size = 4
_pPlayerPool$ = -48					; size = 4
_dwThisTime$ = -36					; size = 4
_pVehicle$ = -24					; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?Process@CVehiclePool@@QAEXXZ PROC			; CVehiclePool::Process, COMDAT
; _this$ = ecx

; 197  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1400				; 00000578H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-1400]
	mov	ecx, 350				; 0000015eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 198  : 	// Process all vehicles in the vehicle pool.
; 199  : 	CVehicle *pVehicle;
; 200  : 	DWORD dwThisTime = GetTickCount();

	mov	esi, esp
	call	DWORD PTR __imp__GetTickCount@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _dwThisTime$[ebp], eax

; 201  : 	CPlayerPool* pPlayerPool = pNetGame->GetPlayerPool();

	mov	ecx, DWORD PTR ?pNetGame@@3PAVCNetGame@@A ; pNetGame
	call	?GetPlayerPool@CNetGame@@QAEPAVCPlayerPool@@XZ ; CNetGame::GetPlayerPool
	mov	DWORD PTR _pPlayerPool$[ebp], eax

; 202  : 	CLocalPlayer* pLocalPlayer = pPlayerPool->GetLocalPlayer();

	mov	ecx, DWORD PTR _pPlayerPool$[ebp]
	call	?GetLocalPlayer@CPlayerPool@@QAEPAVCLocalPlayer@@XZ ; CPlayerPool::GetLocalPlayer
	mov	DWORD PTR _pLocalPlayer$[ebp], eax

; 203  : 
; 204  : 	//if(!pLocalPlayer->IsActive()) return;
; 205  : 	
; 206  : 	BYTE localVW = 0;

	mov	BYTE PTR _localVW$[ebp], 0

; 207  : 	if (pLocalPlayer) localVW = pLocalPlayer->GetVirtualWorld();

	cmp	DWORD PTR _pLocalPlayer$[ebp], 0
	je	SHORT $LN21@Process
	mov	ecx, DWORD PTR _pLocalPlayer$[ebp]
	call	?GetVirtualWorld@CLocalPlayer@@QAEEXZ	; CLocalPlayer::GetVirtualWorld
	mov	BYTE PTR _localVW$[ebp], al
$LN21@Process:

; 208  : 
; 209  : 	for(VEHICLEID x = 0; x != MAX_VEHICLES; x++)

	xor	eax, eax
	mov	WORD PTR _x$4[ebp], ax
	jmp	SHORT $LN20@Process
$LN19@Process:
	mov	ax, WORD PTR _x$4[ebp]
	add	ax, 1
	mov	WORD PTR _x$4[ebp], ax
$LN20@Process:
	movzx	eax, WORD PTR _x$4[ebp]
	cmp	eax, 702				; 000002beH
	je	$LN18@Process

; 210  : 	{
; 211  : 		if(GetSlotState(x) == TRUE)

	movzx	eax, WORD PTR _x$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSlotState@CVehiclePool@@QAEHG@Z	; CVehiclePool::GetSlotState
	cmp	eax, 1
	jne	$LN1@Process

; 212  : 		{
; 213  : 			// It's in use.
; 214  : 			pVehicle = m_pVehicles[x];

	movzx	eax, WORD PTR _x$4[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+2808]
	mov	DWORD PTR _pVehicle$[ebp], edx

; 215  : 
; 216  : 			if(m_bIsActive[x])

	movzx	eax, WORD PTR _x$4[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4+8424], 0
	je	$LN16@Process

; 217  : 			{
; 218  : 				/*
; 219  : 				if(!pVehicle->IsOccupied()) {
; 220  : 					pVehicle->ProcessEngineAudio(0);
; 221  : 				}*/
; 222  : 
; 223  : 				if(pVehicle->IsDriverLocalPlayer()) {

	mov	ecx, DWORD PTR _pVehicle$[ebp]
	call	?IsDriverLocalPlayer@CVehicle@@QAEHXZ	; CVehicle::IsDriverLocalPlayer
	test	eax, eax
	je	SHORT $LN15@Process

; 224  : 					pVehicle->SetInvulnerable(FALSE);

	push	0
	mov	ecx, DWORD PTR _pVehicle$[ebp]
	call	?SetInvulnerable@CVehicle@@QAEXH@Z	; CVehicle::SetInvulnerable

; 225  : 				} else {

	jmp	SHORT $LN14@Process
$LN15@Process:

; 226  : 					pVehicle->SetInvulnerable(TRUE);

	push	1
	mov	ecx, DWORD PTR _pVehicle$[ebp]
	call	?SetInvulnerable@CVehicle@@QAEXH@Z	; CVehicle::SetInvulnerable
$LN14@Process:

; 227  : 				}
; 228  : 
; 229  : 				if (pVehicle->GetHealth() == 0.0f) // || pVehicle->IsWrecked()) // It's dead

	mov	ecx, DWORD PTR _pVehicle$[ebp]
	call	?GetHealth@CVehicle@@QAEMXZ		; CVehicle::GetHealth
	fstp	DWORD PTR tv335[ebp]
	movss	xmm0, DWORD PTR tv335[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN13@Process

; 230  : 				{
; 231  : 					if (pLocalPlayer->m_LastVehicle == x) // Notify server of death

	mov	eax, DWORD PTR _pLocalPlayer$[ebp]
	movzx	ecx, WORD PTR [eax+37]
	movzx	edx, WORD PTR _x$4[ebp]
	cmp	ecx, edx
	jne	SHORT $LN12@Process

; 232  : 					{
; 233  : 						NotifyVehicleDeath(x);

	movzx	eax, WORD PTR _x$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NotifyVehicleDeath@CVehiclePool@@QAEXG@Z ; CVehiclePool::NotifyVehicleDeath
$LN12@Process:

; 234  : 					}
; 235  : 					continue;

	jmp	$LN19@Process
$LN13@Process:

; 236  : 				}
; 237  : 				
; 238  : 				// Peter: This caused every vehicle outside the worldbounds
; 239  : 				// that's not occupied to respawn every time this is called.
; 240  : 
; 241  : 				/*if(pVehicle->HasExceededWorldBoundries(
; 242  : 					pNetGame->m_WorldBounds[0],pNetGame->m_WorldBounds[1],
; 243  : 					pNetGame->m_WorldBounds[2],pNetGame->m_WorldBounds[3]))
; 244  : 				{
; 245  : 					if (!pVehicle->IsOccupied()) {
; 246  : 						SetForRespawn(x);
; 247  : 						continue;
; 248  : 					}
; 249  : 				}*/
; 250  : 
; 251  : 				if( pVehicle->GetVehicleSubtype() != VEHICLE_SUBTYPE_BOAT &&
; 252  : 					pVehicle->HasSunk() ) // Not boat and has sunk.

	mov	ecx, DWORD PTR _pVehicle$[ebp]
	call	?GetVehicleSubtype@CVehicle@@QAEIXZ	; CVehicle::GetVehicleSubtype
	cmp	eax, 4
	je	SHORT $LN11@Process
	mov	ecx, DWORD PTR _pVehicle$[ebp]
	call	?HasSunk@CVehicle@@QAEHXZ		; CVehicle::HasSunk
	test	eax, eax
	je	SHORT $LN11@Process

; 253  : 				{
; 254  : 					if (pLocalPlayer->m_LastVehicle == x) {

	mov	eax, DWORD PTR _pLocalPlayer$[ebp]
	movzx	ecx, WORD PTR [eax+37]
	movzx	edx, WORD PTR _x$4[ebp]
	cmp	ecx, edx
	jne	SHORT $LN10@Process

; 255  : 						NotifyVehicleDeath(x);

	movzx	eax, WORD PTR _x$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NotifyVehicleDeath@CVehiclePool@@QAEXG@Z ; CVehiclePool::NotifyVehicleDeath
$LN10@Process:

; 256  : 					}
; 257  : 					continue;

	jmp	$LN19@Process
$LN11@Process:

; 258  : 				}
; 259  : 				
; 260  : 				// Code to respawn vehicle after it has been idle for the amount of time specified
; 261  : 				pVehicle->UpdateLastDrivenTime();

	mov	ecx, DWORD PTR _pVehicle$[ebp]
	call	?UpdateLastDrivenTime@CVehicle@@QAEHXZ	; CVehicle::UpdateLastDrivenTime

; 262  : 
; 263  : 				// Active and in world.
; 264  : 
; 265  : /*		
; 266  : #ifdef _DEBUG
; 267  : 				CHAR szBuffer2[1024];
; 268  : 				if (!pVehicle->IsAdded() && pVehicle->GetDistanceFromLocalPlayerPed() < LOCKING_DISTANCE) {
; 269  : 					sprintf(szBuffer2, "Vehicle streamed into locking distance: %d:%u\n", x,m_byteVirtualWorld[x]);
; 270  : 					OutputDebugString(szBuffer2);
; 271  : 				}
; 272  : 				if (pVehicle->IsAdded() && pVehicle->GetDistanceFromLocalPlayerPed() >= LOCKING_DISTANCE) {
; 273  : 					sprintf(szBuffer2, "Vehicle streamed out of locking distance: %d:%u\n", x,m_byteVirtualWorld[x]);				
; 274  : 					OutputDebugString(szBuffer2);
; 275  : 				}
; 276  : #endif */
; 277  : 				// Remove or Add vehicles as they leave/enter a radius around the player
; 278  : 				if( (pVehicle->GetDistanceFromLocalPlayerPed() < LOCKING_DISTANCE)
; 279  : 					&& m_byteVirtualWorld[x] == localVW ) {

	mov	ecx, DWORD PTR _pVehicle$[ebp]
	call	?GetDistanceFromLocalPlayerPed@CEntity@@QAEMXZ ; CEntity::GetDistanceFromLocalPlayerPed
	fstp	DWORD PTR tv349[ebp]
	movss	xmm0, DWORD PTR __real@43480000
	comiss	xmm0, DWORD PTR tv349[ebp]
	jbe	$LN9@Process
	movzx	eax, WORD PTR _x$4[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+44928]
	movzx	eax, BYTE PTR _localVW$[ebp]
	cmp	edx, eax
	jne	$LN9@Process

; 280  : 
; 281  : 					pVehicle->Add();

	mov	eax, DWORD PTR _pVehicle$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR _pVehicle$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 282  : 					//pVehicle->SetLockedState(0);
; 283  : 					
; 284  : 
; 285  : 					CVehicle* pTrailer = pVehicle->GetTrailer();

	mov	ecx, DWORD PTR _pVehicle$[ebp]
	call	?GetTrailer@CVehicle@@QAEPAV1@XZ	; CVehicle::GetTrailer
	mov	DWORD PTR _pTrailer$3[ebp], eax

; 286  : 					if (pTrailer && !pTrailer->IsAdded())

	cmp	DWORD PTR _pTrailer$3[ebp], 0
	je	SHORT $LN8@Process
	mov	ecx, DWORD PTR _pTrailer$3[ebp]
	call	?IsAdded@CEntity@@QAEHXZ		; CEntity::IsAdded
	test	eax, eax
	jne	SHORT $LN8@Process

; 287  : 					{
; 288  : 						MATRIX4X4 matPos;
; 289  : 						pVehicle->GetMatrix(&matPos);

	lea	eax, DWORD PTR _matPos$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _pVehicle$[ebp]
	call	?GetMatrix@CEntity@@QAEXPAU_MATRIX4X4@@@Z ; CEntity::GetMatrix

; 290  : 						pTrailer->TeleportTo(matPos.pos.X, matPos.pos.Y, matPos.pos.Z);

	push	ecx
	movss	xmm0, DWORD PTR _matPos$2[ebp+56]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _matPos$2[ebp+52]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _matPos$2[ebp+48]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _pTrailer$3[ebp]
	call	?TeleportTo@CEntity@@QAEXMMM@Z		; CEntity::TeleportTo

; 291  : 						pTrailer->Add();

	mov	eax, DWORD PTR _pTrailer$3[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR _pTrailer$3[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN8@Process:

; 292  : 					}
; 293  : 
; 294  : 				} else {

	jmp	SHORT $LN7@Process
$LN9@Process:

; 295  : 					//pVehicle->SetLockedState(1);
; 296  : 					pVehicle->Remove();					

	mov	eax, DWORD PTR _pVehicle$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR _pVehicle$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@Process:

; 297  : 				}
; 298  : 
; 299  : 				pVehicle->ProcessMarkers(); // car scanning shit

	mov	ecx, DWORD PTR _pVehicle$[ebp]
	call	?ProcessMarkers@CVehicle@@QAEXXZ	; CVehicle::ProcessMarkers

; 300  : 
; 301  : 				/*
; 302  : 				if( (pVehicle->GetVehicleSubtype() == VEHICLE_SUBTYPE_PLANE ||
; 303  : 					pVehicle->GetVehicleSubtype() == VEHICLE_SUBTYPE_HELI) &&
; 304  : 					!pVehicle->IsOccupied() ) {
; 305  : 					pVehicle->SetEngineState(FALSE);
; 306  : 				}*/
; 307  : 
; 308  : 				if(!pVehicle->HasADriver()) {

	mov	ecx, DWORD PTR _pVehicle$[ebp]
	call	?HasADriver@CVehicle@@QAEHXZ		; CVehicle::HasADriver
	test	eax, eax
	jne	SHORT $LN6@Process

; 309  : 					pVehicle->SetHornState(0);

	push	0
	mov	ecx, DWORD PTR _pVehicle$[ebp]
	call	?SetHornState@CVehicle@@QAEXE@Z		; CVehicle::SetHornState

; 310  : 					pVehicle->SetEngineState(FALSE);

	push	0
	mov	ecx, DWORD PTR _pVehicle$[ebp]
	call	?SetEngineState@CVehicle@@QAEXH@Z	; CVehicle::SetEngineState
$LN6@Process:

; 311  : 				}
; 312  : 
; 313  : 				// Update the actual ingame pointer if it's not
; 314  : 				// the same as the one we have listed.
; 315  : 				if(pVehicle->m_pVehicle != m_pGTAVehicles[x]) {

	movzx	eax, WORD PTR _x$4[ebp]
	mov	ecx, DWORD PTR _pVehicle$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+16]
	cmp	ecx, DWORD PTR [edx+eax*4+5616]
	je	SHORT $LN5@Process

; 316  : 					m_pGTAVehicles[x] = pVehicle->m_pVehicle;

	movzx	eax, WORD PTR _x$4[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pVehicle$[ebp]
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+eax*4+5616], edx
$LN5@Process:

; 317  : 				}
; 318  : 				// Put at the END so other processing is still done!
; 319  : 				ProcessForVirtualWorld(x, localVW);

	movzx	eax, BYTE PTR _localVW$[ebp]
	push	eax
	movzx	ecx, WORD PTR _x$4[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ProcessForVirtualWorld@CVehiclePool@@QAEXGE@Z ; CVehiclePool::ProcessForVirtualWorld

; 320  : 			}
; 321  : 			else // !m_bIsActive

	jmp	$LN1@Process
$LN16@Process:

; 322  : 			{
; 323  : 				if(!pVehicle->IsOccupied()) {

	mov	ecx, DWORD PTR _pVehicle$[ebp]
	call	?IsOccupied@CVehicle@@QAEHXZ		; CVehicle::IsOccupied
	test	eax, eax
	jne	$LN1@Process

; 324  : 					if(m_iRespawnDelay[x] > 0) {

	movzx	eax, WORD PTR _x$4[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4+42120], 0
	jle	SHORT $LN2@Process

; 325  : 						m_iRespawnDelay[x]--;

	movzx	eax, WORD PTR _x$4[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+42120]
	sub	edx, 1
	movzx	eax, WORD PTR _x$4[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+42120], edx

; 326  : 					}
; 327  : 					else {

	jmp	$LN1@Process
$LN2@Process:

; 328  : #ifdef _DEBUG
; 329  : 						CHAR szBuffer2[1024];
; 330  : 						sprintf(szBuffer2, "Inactive vehicle getting respawned: %d\n", x);

	movzx	eax, WORD PTR _x$4[ebp]
	push	eax
	push	OFFSET ??_C@_0CI@IHKPOFFI@Inactive?5vehicle?5getting?5respawn@
	lea	ecx, DWORD PTR _szBuffer2$1[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 331  : 						OutputDebugString(szBuffer2);

	mov	esi, esp
	lea	eax, DWORD PTR _szBuffer2$1[ebp]
	push	eax
	call	DWORD PTR __imp__OutputDebugStringA@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 332  : #endif
; 333  : 						Spawn(x,m_SpawnInfo[x].iVehicleType,&m_SpawnInfo[x].vecPos, m_SpawnInfo[x].fRotation,
; 334  : 							m_SpawnInfo[x].iColor1,m_SpawnInfo[x].iColor2,m_SpawnInfo[x].iInterior,m_charNumberPlate[x],m_SpawnInfo[x].iObjective,m_SpawnInfo[x].iDoorsLocked);

	movzx	eax, WORD PTR _x$4[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+14072]
	push	eax
	movzx	ecx, WORD PTR _x$4[ebp]
	imul	edx, ecx, 40
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+14068]
	push	ecx
	movzx	edx, WORD PTR _x$4[ebp]
	imul	eax, edx, 9
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+45630]
	push	edx
	movzx	eax, WORD PTR _x$4[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+14076]
	push	eax
	movzx	ecx, WORD PTR _x$4[ebp]
	imul	edx, ecx, 40
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+14064]
	push	ecx
	movzx	edx, WORD PTR _x$4[ebp]
	imul	eax, edx, 40
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+14060]
	push	edx
	movzx	eax, WORD PTR _x$4[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+ecx+14056]
	movss	DWORD PTR [esp], xmm0
	movzx	eax, WORD PTR _x$4[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+14044]
	push	eax
	movzx	ecx, WORD PTR _x$4[ebp]
	imul	edx, ecx, 40
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+14040]
	push	ecx
	movzx	edx, WORD PTR _x$4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Spawn@CVehiclePool@@QAEHGHPAU_VECTOR@@MHHHPADHH@Z ; CVehiclePool::Spawn
$LN1@Process:

; 335  : 					}
; 336  : 				}	
; 337  : 			}			
; 338  : 		}
; 339  : 	} // end for each vehicle

	jmp	$LN19@Process
$LN18@Process:

; 340  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN27@Process
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 1400				; 00000578H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN27@Process:
	DD	2
	DD	$LN26@Process
$LN26@Process:
	DD	-168					; ffffff58H
	DD	64					; 00000040H
	DD	$LN24@Process
	DD	-1200					; fffffb50H
	DD	1024					; 00000400H
	DD	$LN25@Process
$LN25@Process:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	50					; 00000032H
	DB	0
$LN24@Process:
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	80					; 00000050H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	0
?Process@CVehiclePool@@QAEXXZ ENDP			; CVehiclePool::Process
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\net\vehiclepool.cpp
;	COMDAT ?ProcessForVirtualWorld@CVehiclePool@@QAEXGE@Z
_TEXT	SEGMENT
_byteVehicleVW$ = -17					; size = 1
_this$ = -8						; size = 4
_vehicleId$ = 8						; size = 2
_bytePlayerWorld$ = 12					; size = 1
?ProcessForVirtualWorld@CVehiclePool@@QAEXGE@Z PROC	; CVehiclePool::ProcessForVirtualWorld, COMDAT
; _this$ = ecx

; 182  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 183  : 	BYTE byteVehicleVW = m_byteVirtualWorld[vehicleId];

	movzx	eax, WORD PTR _vehicleId$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+eax+44928]
	mov	BYTE PTR _byteVehicleVW$[ebp], dl

; 184  : 	if (bytePlayerWorld != byteVehicleVW)

	movzx	eax, BYTE PTR _bytePlayerWorld$[ebp]
	movzx	ecx, BYTE PTR _byteVehicleVW$[ebp]
	cmp	eax, ecx
	je	SHORT $LN3@ProcessFor

; 185  : 	{
; 186  : 		if(m_pVehicles[vehicleId]->m_dwMarkerID)

	movzx	eax, WORD PTR _vehicleId$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+2808]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN3@ProcessFor

; 187  : 		{
; 188  : 			ScriptCommand(&disable_marker, m_pVehicles[vehicleId]->m_dwMarkerID);

	movzx	eax, WORD PTR _vehicleId$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+2808]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	push	OFFSET _disable_marker
	call	?ScriptCommand@@YAHPBUSCRIPT_COMMAND@@ZZ ; ScriptCommand
	add	esp, 8

; 189  : 			m_pVehicles[vehicleId]->m_dwMarkerID = 0;

	movzx	eax, WORD PTR _vehicleId$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+2808]
	mov	DWORD PTR [edx+12], 0
$LN3@ProcessFor:

; 190  : 		}
; 191  : 	}
; 192  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?ProcessForVirtualWorld@CVehiclePool@@QAEXGE@Z ENDP	; CVehiclePool::ProcessForVirtualWorld
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\net\vehiclepool.cpp
;	COMDAT ?Spawn@CVehiclePool@@QAEHGHPAU_VECTOR@@MHHHPADHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_VehicleID$ = 8						; size = 2
_iVehicleType$ = 12					; size = 4
_vecPos$ = 16						; size = 4
_fRotation$ = 20					; size = 4
_iColor1$ = 24						; size = 4
_iColor2$ = 28						; size = 4
_iInterior$ = 32					; size = 4
_szNumberPlate$ = 36					; size = 4
_iObjective$ = 40					; size = 4
_iDoorsLocked$ = 44					; size = 4
?Spawn@CVehiclePool@@QAEHGHPAU_VECTOR@@MHHHPADHH@Z PROC	; CVehiclePool::Spawn, COMDAT
; _this$ = ecx

; 85   : {	

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 86   : 
; 87   : 	if(m_pVehicles[VehicleID] != NULL) {

	movzx	eax, WORD PTR _VehicleID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4+2808], 0
	je	SHORT $LN8@Spawn

; 88   : 		Delete(VehicleID);

	movzx	eax, WORD PTR _VehicleID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Delete@CVehiclePool@@QAEHG@Z		; CVehiclePool::Delete
$LN8@Spawn:

; 89   : 	}
; 90   : 
; 91   : 	m_pVehicles[VehicleID] = pGame->NewVehicle(iVehicleType,
; 92   : 		vecPos->X,vecPos->Y,vecPos->Z,fRotation, szNumberPlate);

	mov	eax, DWORD PTR _szNumberPlate$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _fRotation$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _vecPos$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+8]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _vecPos$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+4]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _vecPos$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _iVehicleType$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?pGame@@3PAVCGame@@A	; pGame
	call	?NewVehicle@CGame@@QAEPAVCVehicle@@HMMMMPAD@Z ; CGame::NewVehicle
	movzx	edx, WORD PTR _VehicleID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx*4+2808], eax

; 93   : 
; 94   : 	if(m_pVehicles[VehicleID])

	movzx	eax, WORD PTR _VehicleID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4+2808], 0
	je	$LN7@Spawn

; 95   : 	{	
; 96   : 		if(iColor1 != -1 || iColor2 != -1) {

	cmp	DWORD PTR _iColor1$[ebp], -1
	jne	SHORT $LN5@Spawn
	cmp	DWORD PTR _iColor2$[ebp], -1
	je	SHORT $LN6@Spawn
$LN5@Spawn:

; 97   : 			m_pVehicles[VehicleID]->SetColor(iColor1,iColor2);

	mov	eax, DWORD PTR _iColor2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iColor1$[ebp]
	push	ecx
	movzx	edx, WORD PTR _VehicleID$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+2808]
	call	?SetColor@CVehicle@@QAEXHH@Z		; CVehicle::SetColor
$LN6@Spawn:

; 98   : 		}
; 99   : 
; 100  : 		m_pGTAVehicles[VehicleID] = m_pVehicles[VehicleID]->m_pVehicle;

	movzx	eax, WORD PTR _VehicleID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+2808]
	movzx	eax, WORD PTR _VehicleID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+eax*4+5616], edx

; 101  : 		m_bVehicleSlotState[VehicleID] = TRUE;

	movzx	eax, WORD PTR _VehicleID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4], 1

; 102  : 
; 103  : 		if(iObjective) m_pVehicles[VehicleID]->m_byteObjectiveVehicle = 1;

	cmp	DWORD PTR _iObjective$[ebp], 0
	je	SHORT $LN4@Spawn
	movzx	eax, WORD PTR _VehicleID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+2808]
	mov	BYTE PTR [edx+32], 1
$LN4@Spawn:

; 104  : 		if(iDoorsLocked) m_pVehicles[VehicleID]->SetDoorState(1);

	cmp	DWORD PTR _iDoorsLocked$[ebp], 0
	je	SHORT $LN3@Spawn
	push	1
	movzx	eax, WORD PTR _VehicleID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+2808]
	call	?SetDoorState@CVehicle@@QAEXH@Z		; CVehicle::SetDoorState
$LN3@Spawn:

; 105  : 		if (iInterior > 0)

	cmp	DWORD PTR _iInterior$[ebp], 0
	jle	SHORT $LN2@Spawn

; 106  : 		{
; 107  : 			LinkToInterior(VehicleID, iInterior);

	mov	eax, DWORD PTR _iInterior$[ebp]
	push	eax
	movzx	ecx, WORD PTR _VehicleID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LinkToInterior@CVehiclePool@@QAEXGH@Z	; CVehiclePool::LinkToInterior
$LN2@Spawn:

; 108  : 		}
; 109  : 
; 110  : 		m_bIsActive[VehicleID] = TRUE;

	movzx	eax, WORD PTR _VehicleID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+8424], 1

; 111  : 		m_bIsWasted[VehicleID] = FALSE;

	movzx	eax, WORD PTR _VehicleID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+11232], 0

; 112  : 		m_charNumberPlate[VehicleID][0] = 0;

	movzx	eax, WORD PTR _VehicleID$[ebp]
	imul	ecx, eax, 9
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+45630]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	BYTE PTR [eax+edx], 0

; 113  : 
; 114  : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $LN1@Spawn

; 115  : 	}
; 116  : 	else

	jmp	SHORT $LN1@Spawn
$LN7@Spawn:

; 117  : 	{
; 118  : 		return FALSE;

	xor	eax, eax
$LN1@Spawn:

; 119  : 	}
; 120  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	40					; 00000028H
?Spawn@CVehiclePool@@QAEHGHPAU_VECTOR@@MHHHPADHH@Z ENDP	; CVehiclePool::Spawn
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\net\vehiclepool.h
;	COMDAT ?GetSlotState@CVehiclePool@@QAEHG@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_VehicleID$ = 8						; size = 2
?GetSlotState@CVehiclePool@@QAEHG@Z PROC		; CVehiclePool::GetSlotState, COMDAT
; _this$ = ecx

; 64   : 	BOOL GetSlotState(VEHICLEID VehicleID) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 65   : 		if(VehicleID >= MAX_VEHICLES) { return FALSE; }

	movzx	eax, WORD PTR _VehicleID$[ebp]
	cmp	eax, 702				; 000002beH
	jl	SHORT $LN1@GetSlotSta
	xor	eax, eax
	jmp	SHORT $LN2@GetSlotSta
$LN1@GetSlotSta:

; 66   : 		return m_bVehicleSlotState[VehicleID];

	movzx	eax, WORD PTR _VehicleID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
$LN2@GetSlotSta:

; 67   : 	};

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetSlotState@CVehiclePool@@QAEHG@Z ENDP		; CVehiclePool::GetSlotState
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\net\vehiclepool.cpp
;	COMDAT ?Delete@CVehiclePool@@QAEHG@Z
_TEXT	SEGMENT
tv91 = -232						; size = 4
$T1 = -224						; size = 4
$T2 = -212						; size = 4
_this$ = -8						; size = 4
_VehicleID$ = 8						; size = 2
?Delete@CVehiclePool@@QAEHG@Z PROC			; CVehiclePool::Delete, COMDAT
; _this$ = ecx

; 66   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 67   : 	if(!GetSlotState(VehicleID) || !m_pVehicles[VehicleID])

	movzx	eax, WORD PTR _VehicleID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSlotState@CVehiclePool@@QAEHG@Z	; CVehiclePool::GetSlotState
	test	eax, eax
	je	SHORT $LN1@Delete
	movzx	eax, WORD PTR _VehicleID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4+2808], 0
	jne	SHORT $LN2@Delete
$LN1@Delete:

; 68   : 	{
; 69   : 		return FALSE; // Vehicle already deleted or not used.

	xor	eax, eax
	jmp	SHORT $LN3@Delete
$LN2@Delete:

; 70   : 	}
; 71   : 
; 72   : 	m_bVehicleSlotState[VehicleID] = FALSE;

	movzx	eax, WORD PTR _VehicleID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4], 0

; 73   : 	delete m_pVehicles[VehicleID];

	movzx	eax, WORD PTR _VehicleID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+2808]
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN5@Delete
	mov	esi, esp
	push	1
	mov	ecx, DWORD PTR $T1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv91[ebp], eax
	jmp	SHORT $LN6@Delete
$LN5@Delete:
	mov	DWORD PTR tv91[ebp], 0
$LN6@Delete:

; 74   : 	m_pVehicles[VehicleID] = NULL;

	movzx	eax, WORD PTR _VehicleID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+2808], 0

; 75   : 
; 76   : 	return TRUE;

	mov	eax, 1
$LN3@Delete:

; 77   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Delete@CVehiclePool@@QAEHG@Z ENDP			; CVehiclePool::Delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\net\vehiclepool.cpp
;	COMDAT ?New@CVehiclePool@@QAEHGHPAU_VECTOR@@MHH0MHPAD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_VehicleID$ = 8						; size = 2
_iVehicleType$ = 12					; size = 4
_vecPos$ = 16						; size = 4
_fRotation$ = 20					; size = 4
_iColor1$ = 24						; size = 4
_iColor2$ = 28						; size = 4
_vecSpawnPos$ = 32					; size = 4
_fSpawnRotation$ = 36					; size = 4
_iInterior$ = 40					; size = 4
_szNumberPlate$ = 44					; size = 4
?New@CVehiclePool@@QAEHGHPAU_VECTOR@@MHH0MHPAD@Z PROC	; CVehiclePool::New, COMDAT
; _this$ = ecx

; 45   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 46   : 	memset(&m_SpawnInfo[VehicleID],0,sizeof(VEHICLE_SPAWN_INFO));

	push	40					; 00000028H
	push	0
	movzx	eax, WORD PTR _VehicleID$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+14040]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 47   : 
; 48   : 	// Setup the spawninfo for the next respawn.
; 49   : 	m_SpawnInfo[VehicleID].iVehicleType = iVehicleType;

	movzx	eax, WORD PTR _VehicleID$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iVehicleType$[ebp]
	mov	DWORD PTR [edx+ecx+14040], eax

; 50   : 	m_SpawnInfo[VehicleID].vecPos.X = vecSpawnPos->X;

	movzx	eax, WORD PTR _VehicleID$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _vecSpawnPos$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx+ecx+14044], eax

; 51   : 	m_SpawnInfo[VehicleID].vecPos.Y = vecSpawnPos->Y;

	movzx	eax, WORD PTR _VehicleID$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _vecSpawnPos$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+ecx+14048], eax

; 52   : 	m_SpawnInfo[VehicleID].vecPos.Z = vecSpawnPos->Z;

	movzx	eax, WORD PTR _VehicleID$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _vecSpawnPos$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+ecx+14052], eax

; 53   : 	m_SpawnInfo[VehicleID].fRotation = fSpawnRotation;

	movzx	eax, WORD PTR _VehicleID$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _fSpawnRotation$[ebp]
	movss	DWORD PTR [edx+ecx+14056], xmm0

; 54   : 	m_SpawnInfo[VehicleID].iColor1 = iColor1;

	movzx	eax, WORD PTR _VehicleID$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iColor1$[ebp]
	mov	DWORD PTR [edx+ecx+14060], eax

; 55   : 	m_SpawnInfo[VehicleID].iColor2 = iColor2;

	movzx	eax, WORD PTR _VehicleID$[ebp]
	imul	ecx, eax, 40
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iColor2$[ebp]
	mov	DWORD PTR [edx+ecx+14064], eax

; 56   : 	
; 57   : 	m_byteVirtualWorld[VehicleID] = 0;

	movzx	eax, WORD PTR _VehicleID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+eax+44928], 0

; 58   : 
; 59   : 	// Now go ahead and spawn it at the location we got passed.
; 60   : 	return Spawn(VehicleID,iVehicleType,vecPos,fRotation,iColor1,iColor2,iInterior,szNumberPlate);

	push	0
	push	0
	mov	eax, DWORD PTR _szNumberPlate$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iInterior$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iColor2$[ebp]
	push	edx
	mov	eax, DWORD PTR _iColor1$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _fRotation$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _vecPos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iVehicleType$[ebp]
	push	edx
	movzx	eax, WORD PTR _VehicleID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Spawn@CVehiclePool@@QAEHGHPAU_VECTOR@@MHHHPADHH@Z ; CVehiclePool::Spawn

; 61   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	40					; 00000028H
?New@CVehiclePool@@QAEHGHPAU_VECTOR@@MHH0MHPAD@Z ENDP	; CVehiclePool::New
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\net\vehiclepool.cpp
;	COMDAT ??1CVehiclePool@@QAE@XZ
_TEXT	SEGMENT
_VehicleID$1 = -20					; size = 2
_this$ = -8						; size = 4
??1CVehiclePool@@QAE@XZ PROC				; CVehiclePool::~CVehiclePool, COMDAT
; _this$ = ecx

; 32   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 33   : 	for(VEHICLEID VehicleID = 0; VehicleID < MAX_VEHICLES; VehicleID++) {

	xor	eax, eax
	mov	WORD PTR _VehicleID$1[ebp], ax
	jmp	SHORT $LN3@CVehiclePo
$LN2@CVehiclePo:
	mov	ax, WORD PTR _VehicleID$1[ebp]
	add	ax, 1
	mov	WORD PTR _VehicleID$1[ebp], ax
$LN3@CVehiclePo:
	movzx	eax, WORD PTR _VehicleID$1[ebp]
	cmp	eax, 702				; 000002beH
	jge	SHORT $LN4@CVehiclePo

; 34   : 		Delete(VehicleID);

	movzx	eax, WORD PTR _VehicleID$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Delete@CVehiclePool@@QAEHG@Z		; CVehiclePool::Delete

; 35   : 	}

	jmp	SHORT $LN2@CVehiclePo
$LN4@CVehiclePo:

; 36   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1CVehiclePool@@QAE@XZ ENDP				; CVehiclePool::~CVehiclePool
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\net\vehiclepool.cpp
;	COMDAT ??0CVehiclePool@@QAE@XZ
_TEXT	SEGMENT
_VehicleID$1 = -20					; size = 2
_this$ = -8						; size = 4
??0CVehiclePool@@QAE@XZ PROC				; CVehiclePool::CVehiclePool, COMDAT
; _this$ = ecx

; 19   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 20   : 	// loop through and initialize all vehicle properties to 0
; 21   : 	for(VEHICLEID VehicleID = 0; VehicleID < MAX_VEHICLES; VehicleID++) {

	xor	eax, eax
	mov	WORD PTR _VehicleID$1[ebp], ax
	jmp	SHORT $LN3@CVehiclePo
$LN2@CVehiclePo:
	mov	ax, WORD PTR _VehicleID$1[ebp]
	add	ax, 1
	mov	WORD PTR _VehicleID$1[ebp], ax
$LN3@CVehiclePo:
	movzx	eax, WORD PTR _VehicleID$1[ebp]
	cmp	eax, 702				; 000002beH
	jge	SHORT $LN4@CVehiclePo

; 22   : 		m_bVehicleSlotState[VehicleID] = FALSE;

	movzx	eax, WORD PTR _VehicleID$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4], 0

; 23   : 		m_pVehicles[VehicleID] = NULL;

	movzx	eax, WORD PTR _VehicleID$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+2808], 0

; 24   : 		m_pGTAVehicles[VehicleID] = NULL;

	movzx	eax, WORD PTR _VehicleID$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+5616], 0

; 25   : 		m_byteVirtualWorld[VehicleID] = 0;

	movzx	eax, WORD PTR _VehicleID$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+eax+44928], 0

; 26   : 	}

	jmp	SHORT $LN2@CVehiclePo
$LN4@CVehiclePo:

; 27   : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CVehiclePool@@QAE@XZ ENDP				; CVehiclePool::CVehiclePool
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\net\playerpool.h
;	COMDAT ?GetLocalPlayer@CPlayerPool@@QAEPAVCLocalPlayer@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetLocalPlayer@CPlayerPool@@QAEPAVCLocalPlayer@@XZ PROC ; CPlayerPool::GetLocalPlayer, COMDAT
; _this$ = ecx

; 46   : 	CLocalPlayer * GetLocalPlayer() { return m_pLocalPlayer; };

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLocalPlayer@CPlayerPool@@QAEPAVCLocalPlayer@@XZ ENDP ; CPlayerPool::GetLocalPlayer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\net\localplayer.h
;	COMDAT ?GetVirtualWorld@CLocalPlayer@@QAEEXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetVirtualWorld@CLocalPlayer@@QAEEXZ PROC		; CLocalPlayer::GetVirtualWorld, COMDAT
; _this$ = ecx

; 248  : 	BYTE GetVirtualWorld() { return m_byteVirtualWorld; };

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+24]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetVirtualWorld@CLocalPlayer@@QAEEXZ ENDP		; CLocalPlayer::GetVirtualWorld
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Write@G@BitStream@RakNet@@QAEXG@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 2
??$Write@G@BitStream@RakNet@@QAEXG@Z PROC		; RakNet::BitStream::Write<unsigned short>, COMDAT
; _this$ = ecx

; 729  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 730  : #ifdef _MSC_VER
; 731  : #pragma warning(disable:4127)   // conditional expression is constant
; 732  : #endif
; 733  : 		if (sizeof(var)==1)

	xor	eax, eax
	je	SHORT $LN2@Write

; 734  : 			WriteBits( ( unsigned char* ) & var, sizeof( templateType ) * 8, true );

	push	1
	push	16					; 00000010H
	lea	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z ; RakNet::BitStream::WriteBits

; 735  : 		else

	jmp	SHORT $LN3@Write
$LN2@Write:

; 736  : 		{
; 737  : #ifndef __BITSTREAM_NATIVE_END
; 738  : 			if (DoEndianSwap())
; 739  : 			{
; 740  : 				unsigned char output[sizeof(templateType)];
; 741  : 				ReverseBytes((unsigned char*)&var, output, sizeof(templateType));
; 742  : 				WriteBits( ( unsigned char* ) output, sizeof(templateType) * 8, true );
; 743  : 			}
; 744  : 			else
; 745  : #endif
; 746  : 				WriteBits( ( unsigned char* ) & var, sizeof(templateType) * 8, true );

	push	1
	push	16					; 00000010H
	lea	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z ; RakNet::BitStream::WriteBits
$LN3@Write:

; 747  : 		}
; 748  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$Write@G@BitStream@RakNet@@QAEXG@Z ENDP		; RakNet::BitStream::Write<unsigned short>
_TEXT	ENDS
END
