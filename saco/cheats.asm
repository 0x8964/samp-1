; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.31101.0 

	TITLE	Z:\sampsrc\02Xu1\saco\game\cheats.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?iMoneyStored@@3HA				; iMoneyStored
PUBLIC	?byteWeaponData@@3PAEA				; byteWeaponData
PUBLIC	?dwHealth@@3KA					; dwHealth
PUBLIC	?dwArmour@@3KA					; dwArmour
PUBLIC	?matStore@@3U_MATRIX4X4@@A			; matStore
PUBLIC	?dwCamTargetEnt1@@3KA				; dwCamTargetEnt1
PUBLIC	?dwCamTargetEnt2@@3KA				; dwCamTargetEnt2
PUBLIC	?iTimesDataModified@@3HA			; iTimesDataModified
PUBLIC	?iDupeD3D9DllsWasVerified@@3HA			; iDupeD3D9DllsWasVerified
PUBLIC	?dwD3D9DllBaseAddr@@3KA				; dwD3D9DllBaseAddr
PUBLIC	?dwD3D9DllSize@@3KA				; dwD3D9DllSize
_BSS	SEGMENT
?iMoneyStored@@3HA DD 01H DUP (?)			; iMoneyStored
?byteWeaponData@@3PAEA DB 016cH DUP (?)			; byteWeaponData
?dwHealth@@3KA DD 01H DUP (?)				; dwHealth
?dwArmour@@3KA DD 01H DUP (?)				; dwArmour
?matStore@@3U_MATRIX4X4@@A DB 040H DUP (?)		; matStore
?dwCamTargetEnt1@@3KA DD 01H DUP (?)			; dwCamTargetEnt1
?dwCamTargetEnt2@@3KA DD 01H DUP (?)			; dwCamTargetEnt2
?iTimesDataModified@@3HA DD 01H DUP (?)			; iTimesDataModified
?iDupeD3D9DllsWasVerified@@3HA DD 01H DUP (?)		; iDupeD3D9DllsWasVerified
?dwD3D9DllBaseAddr@@3KA DD 01H DUP (?)			; dwD3D9DllBaseAddr
?dwD3D9DllSize@@3KA DD 01H DUP (?)			; dwD3D9DllSize
_BSS	ENDS
PUBLIC	?FindPlayerPed@CGame@@QAEPAVCPlayerPed@@XZ	; CGame::FindPlayerPed
PUBLIC	?DoCheatDataStoring@@YAXXZ			; DoCheatDataStoring
PUBLIC	?CheckDuplicateD3D9Dlls@@YAXXZ			; CheckDuplicateD3D9Dlls
PUBLIC	?DoCheatDataComparing@@YAXXZ			; DoCheatDataComparing
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	_strcpy:PROC
EXTRN	_strcmp:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__GetCurrentProcessId@0:PROC
EXTRN	__imp__GetModuleHandleA@4:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	??0CPlayerPed@@QAE@XZ:PROC			; CPlayerPed::CPlayerPed
EXTRN	?IsMenuActive@CGame@@QAEHXZ:PROC		; CGame::IsMenuActive
EXTRN	?GetLocalMoney@CGame@@QAEHXZ:PROC		; CGame::GetLocalMoney
EXTRN	?GameForcedExit@@YAXH@Z:PROC			; GameForcedExit
EXTRN	?K_DecodeString@@YAPADPAE@Z:PROC		; K_DecodeString
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?pGame@@3PAVCGame@@A:DWORD			; pGame
EXTRN	?bFirstSpawn@@3HA:DWORD				; bFirstSpawn
EXTRN	?pNetGame@@3PAVCNetGame@@A:DWORD		; pNetGame
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?FindPlayerPed@CGame@@QAEPAVCPlayerPed@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindPlayerPed@CGame@@QAEPAVCPlayerPed@@XZ$0
__ehfuncinfo$?FindPlayerPed@CGame@@QAEPAVCPlayerPed@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FindPlayerPed@CGame@@QAEPAVCPlayerPed@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\game\cheats.cpp
;	COMDAT ?DoCheatDataComparing@@YAXXZ
_TEXT	SEGMENT
_dwTempArmour$ = -32					; size = 4
_dwTempHealth$ = -20					; size = 4
_pPed$ = -8						; size = 4
?DoCheatDataComparing@@YAXXZ PROC			; DoCheatDataComparing, COMDAT

; 163  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 164  : 	if(!pNetGame) return;

	cmp	DWORD PTR ?pNetGame@@3PAVCNetGame@@A, 0	; pNetGame
	jne	SHORT $LN7@DoCheatDat
	jmp	$LN8@DoCheatDat
$LN7@DoCheatDat:

; 165  : 
; 166  : 	PED_TYPE *pPed = pGame->FindPlayerPed()->m_pPed;

	mov	ecx, DWORD PTR ?pGame@@3PAVCGame@@A	; pGame
	call	?FindPlayerPed@CGame@@QAEPAVCPlayerPed@@XZ ; CGame::FindPlayerPed
	mov	eax, DWORD PTR [eax+28]
	mov	DWORD PTR _pPed$[ebp], eax

; 167  : 	DWORD dwTempHealth;
; 168  : 	DWORD dwTempArmour;
; 169  : 
; 170  : 	// Repair the camera's target entity.
; 171  : 	*(PDWORD)0xB6F3B8 = dwCamTargetEnt1;

	mov	eax, DWORD PTR ?dwCamTargetEnt1@@3KA	; dwCamTargetEnt1
	mov	DWORD PTR ds:11989944, eax

; 172  : 	*(PDWORD)0xB6F5F0 = dwCamTargetEnt2;

	mov	eax, DWORD PTR ?dwCamTargetEnt2@@3KA	; dwCamTargetEnt2
	mov	DWORD PTR ds:11990512, eax

; 173  : 
; 174  : 	if(!bFirstSpawn && !pGame->IsMenuActive()) {

	cmp	DWORD PTR ?bFirstSpawn@@3HA, 0		; bFirstSpawn
	jne	$LN8@DoCheatDat
	mov	ecx, DWORD PTR ?pGame@@3PAVCGame@@A	; pGame
	call	?IsMenuActive@CGame@@QAEHXZ		; CGame::IsMenuActive
	test	eax, eax
	jne	$LN8@DoCheatDat

; 175  : 
; 176  : 		// MONEY CHECK
; 177  : 		_asm mov edx, iMoneyStored

	mov	edx, DWORD PTR ?iMoneyStored@@3HA	; iMoneyStored

; 178  : 		_asm rol edx, 5

	rol	edx, 5

; 179  : 		_asm mov iMoneyStored, edx

	mov	DWORD PTR ?iMoneyStored@@3HA, edx	; iMoneyStored

; 180  : 
; 181  : 		if(pGame->GetLocalMoney() != iMoneyStored) {

	mov	ecx, DWORD PTR ?pGame@@3PAVCGame@@A	; pGame
	call	?GetLocalMoney@CGame@@QAEHXZ		; CGame::GetLocalMoney
	cmp	eax, DWORD PTR ?iMoneyStored@@3HA	; iMoneyStored
	je	SHORT $LN5@DoCheatDat

; 182  : 			//if(pChatWindow) pChatWindow->AddDebugMessage("Money modified");
; 183  : 			iTimesDataModified++;

	mov	eax, DWORD PTR ?iTimesDataModified@@3HA	; iTimesDataModified
	add	eax, 1
	mov	DWORD PTR ?iTimesDataModified@@3HA, eax	; iTimesDataModified
$LN5@DoCheatDat:

; 184  : 		}
; 185  : 
; 186  : 		// WEAPON DATA CHECK
; 187  : 		if(memcmp(&pPed->WeaponSlots[0],byteWeaponData,WEAPON_DATA_SIZE) != 0) {

	push	364					; 0000016cH
	push	OFFSET ?byteWeaponData@@3PAEA		; byteWeaponData
	mov	eax, 28					; 0000001cH
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pPed$[ebp]
	lea	eax, DWORD PTR [edx+ecx+1440]
	push	eax
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN4@DoCheatDat

; 188  : 			//if(pChatWindow) pChatWindow->AddDebugMessage("Weapon Data modified");
; 189  : 			iTimesDataModified++;

	mov	eax, DWORD PTR ?iTimesDataModified@@3HA	; iTimesDataModified
	add	eax, 1
	mov	DWORD PTR ?iTimesDataModified@@3HA, eax	; iTimesDataModified
$LN4@DoCheatDat:

; 190  : 		}
; 191  : 
; 192  : 		// HEALTH CHECK
; 193  : 		memcpy(&dwTempHealth,&pPed->fHealth,4);

	push	4
	mov	eax, DWORD PTR _pPed$[ebp]
	add	eax, 1344				; 00000540H
	push	eax
	lea	ecx, DWORD PTR _dwTempHealth$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 194  : 
; 195  : 		_asm mov edx, dwHealth

	mov	edx, DWORD PTR ?dwHealth@@3KA		; dwHealth

; 196  : 		_asm rol edx, 5

	rol	edx, 5

; 197  : 		_asm mov dwHealth, edx

	mov	DWORD PTR ?dwHealth@@3KA, edx		; dwHealth

; 198  : 
; 199  : 		if(dwTempHealth != dwHealth) {

	mov	eax, DWORD PTR _dwTempHealth$[ebp]
	cmp	eax, DWORD PTR ?dwHealth@@3KA		; dwHealth
	je	SHORT $LN3@DoCheatDat

; 200  : 			//if(pChatWindow) pChatWindow->AddDebugMessage("Health modified");
; 201  : 			iTimesDataModified++;

	mov	eax, DWORD PTR ?iTimesDataModified@@3HA	; iTimesDataModified
	add	eax, 1
	mov	DWORD PTR ?iTimesDataModified@@3HA, eax	; iTimesDataModified
$LN3@DoCheatDat:

; 202  : 		}
; 203  : 	
; 204  : 		// ARMOUR CHECK
; 205  : 		memcpy(&dwTempArmour,&pPed->fArmour,4);

	push	4
	mov	eax, DWORD PTR _pPed$[ebp]
	add	eax, 1352				; 00000548H
	push	eax
	lea	ecx, DWORD PTR _dwTempArmour$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 206  : 
; 207  : 		_asm mov edx, dwArmour

	mov	edx, DWORD PTR ?dwArmour@@3KA		; dwArmour

; 208  : 		_asm rol edx, 5

	rol	edx, 5

; 209  : 		_asm mov dwArmour, edx

	mov	DWORD PTR ?dwArmour@@3KA, edx		; dwArmour

; 210  : 
; 211  : 		if(dwTempArmour != dwArmour) {

	mov	eax, DWORD PTR _dwTempArmour$[ebp]
	cmp	eax, DWORD PTR ?dwArmour@@3KA		; dwArmour
	je	SHORT $LN2@DoCheatDat

; 212  : 			//if(pChatWindow) pChatWindow->AddDebugMessage("Armour modified");
; 213  : 			iTimesDataModified++;

	mov	eax, DWORD PTR ?iTimesDataModified@@3HA	; iTimesDataModified
	add	eax, 1
	mov	DWORD PTR ?iTimesDataModified@@3HA, eax	; iTimesDataModified
$LN2@DoCheatDat:

; 214  : 		}
; 215  : 
; 216  : 		// PLAYER MATRIX CHECK
; 217  : 		if(memcmp(&matStore,pPed->entity.mat,sizeof(MATRIX4X4)) != 0) {

	push	64					; 00000040H
	mov	eax, DWORD PTR _pPed$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	push	OFFSET ?matStore@@3U_MATRIX4X4@@A	; matStore
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN8@DoCheatDat

; 218  : 			//if(pChatWindow) pChatWindow->AddDebugMessage("Matrix modified");
; 219  : 			iTimesDataModified++;

	mov	eax, DWORD PTR ?iTimesDataModified@@3HA	; iTimesDataModified
	add	eax, 1
	mov	DWORD PTR ?iTimesDataModified@@3HA, eax	; iTimesDataModified
$LN8@DoCheatDat:

; 220  : 		}
; 221  : 
; 222  : 	}
; 223  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN13@DoCheatDat
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN13@DoCheatDat:
	DD	2
	DD	$LN12@DoCheatDat
$LN12@DoCheatDat:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN10@DoCheatDat
	DD	-32					; ffffffe0H
	DD	4
	DD	$LN11@DoCheatDat
$LN11@DoCheatDat:
	DB	100					; 00000064H
	DB	119					; 00000077H
	DB	84					; 00000054H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	65					; 00000041H
	DB	114					; 00000072H
	DB	109					; 0000006dH
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	0
$LN10@DoCheatDat:
	DB	100					; 00000064H
	DB	119					; 00000077H
	DB	84					; 00000054H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	72					; 00000048H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
?DoCheatDataComparing@@YAXXZ ENDP			; DoCheatDataComparing
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\game\cheats.cpp
;	COMDAT ?CheckDuplicateD3D9Dlls@@YAXXZ
_TEXT	SEGMENT
_kernel32$ = -1076					; size = 4
_szModule32NextEnc$ = -1064				; size = 13
_szModule32FirstEnc$ = -1040				; size = 14
_szCreateToolhelp32SnapshotEnc$ = -1016			; size = 25
_szKernel32Dec$ = -980					; size = 4
_szKernel32Enc$ = -968					; size = 13
_szD3D9Dec$ = -944					; size = 4
_szD3D9Enc$ = -932					; size = 9
_dwCurDllBase$ = -912					; size = 4
_dwCurImageSize$ = -900					; size = 4
_szModule$ = -888					; size = 261
_iFoundD3D9Dll$ = -616					; size = 4
_me32$ = -604						; size = 548
_hModuleSnap$ = -48					; size = 4
_fnModule32Next$ = -36					; size = 4
_fnModule32First$ = -24					; size = 4
_fnCreateToolhelp32Snapshot$ = -12			; size = 4
__$ArrayPad$ = -4					; size = 4
?CheckDuplicateD3D9Dlls@@YAXXZ PROC			; CheckDuplicateD3D9Dlls, COMDAT

; 92   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1272				; 000004f8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-1272]
	mov	ecx, 318				; 0000013eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 93   : 	CREATETOOLHELP32SNAPSHOT fnCreateToolhelp32Snapshot = NULL;

	mov	DWORD PTR _fnCreateToolhelp32Snapshot$[ebp], 0

; 94   : 	MODULE32FIRST fnModule32First = NULL;

	mov	DWORD PTR _fnModule32First$[ebp], 0

; 95   : 	MODULE32NEXT fnModule32Next = NULL;

	mov	DWORD PTR _fnModule32Next$[ebp], 0

; 96   :     HANDLE hModuleSnap = NULL;

	mov	DWORD PTR _hModuleSnap$[ebp], 0

; 97   : 	MODULEENTRY32 me32;
; 98   : 
; 99   : 	int iFoundD3D9Dll=0;

	mov	DWORD PTR _iFoundD3D9Dll$[ebp], 0

; 100  : 	char szModule[MAX_PATH+1];
; 101  : 
; 102  : 	DWORD dwCurImageSize=0;

	mov	DWORD PTR _dwCurImageSize$[ebp], 0

; 103  : 	DWORD dwCurDllBase=0;

	mov	DWORD PTR _dwCurDllBase$[ebp], 0

; 104  : 
; 105  : 	BYTE szD3D9Enc[9] = {0x8C,0x66,0x8C,0x27,0xC5,0x8C,0x8D,0x8D,0}; // d3d9.dll

	mov	BYTE PTR _szD3D9Enc$[ebp], 140		; 0000008cH
	mov	BYTE PTR _szD3D9Enc$[ebp+1], 102	; 00000066H
	mov	BYTE PTR _szD3D9Enc$[ebp+2], 140	; 0000008cH
	mov	BYTE PTR _szD3D9Enc$[ebp+3], 39		; 00000027H
	mov	BYTE PTR _szD3D9Enc$[ebp+4], 197	; 000000c5H
	mov	BYTE PTR _szD3D9Enc$[ebp+5], 140	; 0000008cH
	mov	BYTE PTR _szD3D9Enc$[ebp+6], 141	; 0000008dH
	mov	BYTE PTR _szD3D9Enc$[ebp+7], 141	; 0000008dH
	mov	BYTE PTR _szD3D9Enc$[ebp+8], 0

; 106  : 	char *szD3D9Dec = K_DecodeString(szD3D9Enc);

	lea	eax, DWORD PTR _szD3D9Enc$[ebp]
	push	eax
	call	?K_DecodeString@@YAPADPAE@Z		; K_DecodeString
	add	esp, 4
	mov	DWORD PTR _szD3D9Dec$[ebp], eax

; 107  : 
; 108  : 	BYTE szKernel32Enc[13] = {0x6D,0xAC,0x4E,0xCD,0xAC,0x8D,0x66,0x46,0xC5,0x8C,0x8D,0x8D,0}; // kernel32.dll

	mov	BYTE PTR _szKernel32Enc$[ebp], 109	; 0000006dH
	mov	BYTE PTR _szKernel32Enc$[ebp+1], 172	; 000000acH
	mov	BYTE PTR _szKernel32Enc$[ebp+2], 78	; 0000004eH
	mov	BYTE PTR _szKernel32Enc$[ebp+3], 205	; 000000cdH
	mov	BYTE PTR _szKernel32Enc$[ebp+4], 172	; 000000acH
	mov	BYTE PTR _szKernel32Enc$[ebp+5], 141	; 0000008dH
	mov	BYTE PTR _szKernel32Enc$[ebp+6], 102	; 00000066H
	mov	BYTE PTR _szKernel32Enc$[ebp+7], 70	; 00000046H
	mov	BYTE PTR _szKernel32Enc$[ebp+8], 197	; 000000c5H
	mov	BYTE PTR _szKernel32Enc$[ebp+9], 140	; 0000008cH
	mov	BYTE PTR _szKernel32Enc$[ebp+10], 141	; 0000008dH
	mov	BYTE PTR _szKernel32Enc$[ebp+11], 141	; 0000008dH
	mov	BYTE PTR _szKernel32Enc$[ebp+12], 0

; 109  :     char *szKernel32Dec = K_DecodeString(szKernel32Enc);

	lea	eax, DWORD PTR _szKernel32Enc$[ebp]
	push	eax
	call	?K_DecodeString@@YAPADPAE@Z		; K_DecodeString
	add	esp, 4
	mov	DWORD PTR _szKernel32Dec$[ebp], eax

; 110  : 
; 111  :     BYTE szCreateToolhelp32SnapshotEnc[25] = {0x68,0x4E,0xAC,0x2C,0x8E,0xAC,0x8A,0xED,0xED,0x8D,0xD,0xAC,0x8D,0xE,0x66,0x46,0x6A,0xCD,0x2C,0xE,0x6E,0xD,0xED,0x8E,0}; // CreateToolhelp32Snapshot

	mov	BYTE PTR _szCreateToolhelp32SnapshotEnc$[ebp], 104 ; 00000068H
	mov	BYTE PTR _szCreateToolhelp32SnapshotEnc$[ebp+1], 78 ; 0000004eH
	mov	BYTE PTR _szCreateToolhelp32SnapshotEnc$[ebp+2], 172 ; 000000acH
	mov	BYTE PTR _szCreateToolhelp32SnapshotEnc$[ebp+3], 44 ; 0000002cH
	mov	BYTE PTR _szCreateToolhelp32SnapshotEnc$[ebp+4], 142 ; 0000008eH
	mov	BYTE PTR _szCreateToolhelp32SnapshotEnc$[ebp+5], 172 ; 000000acH
	mov	BYTE PTR _szCreateToolhelp32SnapshotEnc$[ebp+6], 138 ; 0000008aH
	mov	BYTE PTR _szCreateToolhelp32SnapshotEnc$[ebp+7], 237 ; 000000edH
	mov	BYTE PTR _szCreateToolhelp32SnapshotEnc$[ebp+8], 237 ; 000000edH
	mov	BYTE PTR _szCreateToolhelp32SnapshotEnc$[ebp+9], 141 ; 0000008dH
	mov	BYTE PTR _szCreateToolhelp32SnapshotEnc$[ebp+10], 13 ; 0000000dH
	mov	BYTE PTR _szCreateToolhelp32SnapshotEnc$[ebp+11], 172 ; 000000acH
	mov	BYTE PTR _szCreateToolhelp32SnapshotEnc$[ebp+12], 141 ; 0000008dH
	mov	BYTE PTR _szCreateToolhelp32SnapshotEnc$[ebp+13], 14 ; 0000000eH
	mov	BYTE PTR _szCreateToolhelp32SnapshotEnc$[ebp+14], 102 ; 00000066H
	mov	BYTE PTR _szCreateToolhelp32SnapshotEnc$[ebp+15], 70 ; 00000046H
	mov	BYTE PTR _szCreateToolhelp32SnapshotEnc$[ebp+16], 106 ; 0000006aH
	mov	BYTE PTR _szCreateToolhelp32SnapshotEnc$[ebp+17], 205 ; 000000cdH
	mov	BYTE PTR _szCreateToolhelp32SnapshotEnc$[ebp+18], 44 ; 0000002cH
	mov	BYTE PTR _szCreateToolhelp32SnapshotEnc$[ebp+19], 14 ; 0000000eH
	mov	BYTE PTR _szCreateToolhelp32SnapshotEnc$[ebp+20], 110 ; 0000006eH
	mov	BYTE PTR _szCreateToolhelp32SnapshotEnc$[ebp+21], 13 ; 0000000dH
	mov	BYTE PTR _szCreateToolhelp32SnapshotEnc$[ebp+22], 237 ; 000000edH
	mov	BYTE PTR _szCreateToolhelp32SnapshotEnc$[ebp+23], 142 ; 0000008eH
	mov	BYTE PTR _szCreateToolhelp32SnapshotEnc$[ebp+24], 0

; 112  : 	BYTE szModule32FirstEnc[14] = {0xA9,0xED,0x8C,0xAE,0x8D,0xAC,0x66,0x46,0xC8,0x2D,0x4E,0x6E,0x8E,0}; // Module32First

	mov	BYTE PTR _szModule32FirstEnc$[ebp], 169	; 000000a9H
	mov	BYTE PTR _szModule32FirstEnc$[ebp+1], 237 ; 000000edH
	mov	BYTE PTR _szModule32FirstEnc$[ebp+2], 140 ; 0000008cH
	mov	BYTE PTR _szModule32FirstEnc$[ebp+3], 174 ; 000000aeH
	mov	BYTE PTR _szModule32FirstEnc$[ebp+4], 141 ; 0000008dH
	mov	BYTE PTR _szModule32FirstEnc$[ebp+5], 172 ; 000000acH
	mov	BYTE PTR _szModule32FirstEnc$[ebp+6], 102 ; 00000066H
	mov	BYTE PTR _szModule32FirstEnc$[ebp+7], 70 ; 00000046H
	mov	BYTE PTR _szModule32FirstEnc$[ebp+8], 200 ; 000000c8H
	mov	BYTE PTR _szModule32FirstEnc$[ebp+9], 45 ; 0000002dH
	mov	BYTE PTR _szModule32FirstEnc$[ebp+10], 78 ; 0000004eH
	mov	BYTE PTR _szModule32FirstEnc$[ebp+11], 110 ; 0000006eH
	mov	BYTE PTR _szModule32FirstEnc$[ebp+12], 142 ; 0000008eH
	mov	BYTE PTR _szModule32FirstEnc$[ebp+13], 0

; 113  : 	BYTE szModule32NextEnc[13] = {0xA9,0xED,0x8C,0xAE,0x8D,0xAC,0x66,0x46,0xC9,0xAC,0xF,0x8E,0}; // Module32Next

	mov	BYTE PTR _szModule32NextEnc$[ebp], 169	; 000000a9H
	mov	BYTE PTR _szModule32NextEnc$[ebp+1], 237 ; 000000edH
	mov	BYTE PTR _szModule32NextEnc$[ebp+2], 140 ; 0000008cH
	mov	BYTE PTR _szModule32NextEnc$[ebp+3], 174 ; 000000aeH
	mov	BYTE PTR _szModule32NextEnc$[ebp+4], 141 ; 0000008dH
	mov	BYTE PTR _szModule32NextEnc$[ebp+5], 172 ; 000000acH
	mov	BYTE PTR _szModule32NextEnc$[ebp+6], 102 ; 00000066H
	mov	BYTE PTR _szModule32NextEnc$[ebp+7], 70	; 00000046H
	mov	BYTE PTR _szModule32NextEnc$[ebp+8], 201 ; 000000c9H
	mov	BYTE PTR _szModule32NextEnc$[ebp+9], 172 ; 000000acH
	mov	BYTE PTR _szModule32NextEnc$[ebp+10], 15 ; 0000000fH
	mov	BYTE PTR _szModule32NextEnc$[ebp+11], 142 ; 0000008eH
	mov	BYTE PTR _szModule32NextEnc$[ebp+12], 0

; 114  : 
; 115  : 	HMODULE kernel32 = GetModuleHandle(szKernel32Dec);

	mov	esi, esp
	mov	eax, DWORD PTR _szKernel32Dec$[ebp]
	push	eax
	call	DWORD PTR __imp__GetModuleHandleA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _kernel32$[ebp], eax

; 116  : 
; 117  : 	fnCreateToolhelp32Snapshot = (CREATETOOLHELP32SNAPSHOT)GetProcAddress(kernel32,K_DecodeString(szCreateToolhelp32SnapshotEnc));

	lea	eax, DWORD PTR _szCreateToolhelp32SnapshotEnc$[ebp]
	push	eax
	call	?K_DecodeString@@YAPADPAE@Z		; K_DecodeString
	add	esp, 4
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _kernel32$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetProcAddress@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _fnCreateToolhelp32Snapshot$[ebp], eax

; 118  : 	fnModule32First = (MODULE32FIRST)GetProcAddress(kernel32,K_DecodeString(szModule32FirstEnc));

	lea	eax, DWORD PTR _szModule32FirstEnc$[ebp]
	push	eax
	call	?K_DecodeString@@YAPADPAE@Z		; K_DecodeString
	add	esp, 4
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _kernel32$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetProcAddress@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _fnModule32First$[ebp], eax

; 119  : 	fnModule32Next = (MODULE32NEXT)GetProcAddress(kernel32,K_DecodeString(szModule32NextEnc));

	lea	eax, DWORD PTR _szModule32NextEnc$[ebp]
	push	eax
	call	?K_DecodeString@@YAPADPAE@Z		; K_DecodeString
	add	esp, 4
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _kernel32$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetProcAddress@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _fnModule32Next$[ebp], eax

; 120  :     
; 121  : 	hModuleSnap = fnCreateToolhelp32Snapshot(TH32CS_SNAPMODULE, GetCurrentProcessId()); 

	mov	esi, esp
	call	DWORD PTR __imp__GetCurrentProcessId@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	push	eax
	push	8
	call	DWORD PTR _fnCreateToolhelp32Snapshot$[ebp]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hModuleSnap$[ebp], eax

; 122  : 
; 123  : 	if(hModuleSnap == INVALID_HANDLE_VALUE)	return;

	cmp	DWORD PTR _hModuleSnap$[ebp], -1
	jne	SHORT $LN10@CheckDupli
	jmp	$LN11@CheckDupli
$LN10@CheckDupli:

; 124  : 
; 125  : 	me32.dwSize = sizeof(MODULEENTRY32);

	mov	DWORD PTR _me32$[ebp], 548		; 00000224H

; 126  : 
; 127  : 	if(!fnModule32First(hModuleSnap,&me32))

	mov	esi, esp
	lea	eax, DWORD PTR _me32$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hModuleSnap$[ebp]
	push	ecx
	call	DWORD PTR _fnModule32First$[ebp]
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $LN8@CheckDupli

; 128  : 	{
; 129  : 		CloseHandle( hModuleSnap );

	mov	esi, esp
	mov	eax, DWORD PTR _hModuleSnap$[ebp]
	push	eax
	call	DWORD PTR __imp__CloseHandle@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 130  : 		return;

	jmp	$LN11@CheckDupli
$LN8@CheckDupli:

; 131  : 	}
; 132  : 
; 133  : 	do
; 134  : 	{
; 135  : 		strcpy(szModule,me32.szModule);

	lea	eax, DWORD PTR _me32$[ebp+32]
	push	eax
	lea	ecx, DWORD PTR _szModule$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 136  : 		dwCurImageSize = me32.modBaseSize;

	mov	eax, DWORD PTR _me32$[ebp+24]
	mov	DWORD PTR _dwCurImageSize$[ebp], eax

; 137  : 		dwCurDllBase = (DWORD)me32.modBaseAddr;

	mov	eax, DWORD PTR _me32$[ebp+20]
	mov	DWORD PTR _dwCurDllBase$[ebp], eax

; 138  : 		
; 139  : 		if(!strcmp(szD3D9Dec,szModule))

	lea	eax, DWORD PTR _szModule$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szD3D9Dec$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN7@CheckDupli

; 140  : 		{
; 141  : 			dwD3D9DllBaseAddr = dwCurDllBase ^ 0xACACACAC;

	mov	eax, DWORD PTR _dwCurDllBase$[ebp]
	xor	eax, -1397969748			; acacacacH
	mov	DWORD PTR ?dwD3D9DllBaseAddr@@3KA, eax	; dwD3D9DllBaseAddr

; 142  : 			dwD3D9DllSize = dwCurImageSize;

	mov	eax, DWORD PTR _dwCurImageSize$[ebp]
	mov	DWORD PTR ?dwD3D9DllSize@@3KA, eax	; dwD3D9DllSize

; 143  : 			iFoundD3D9Dll++;

	mov	eax, DWORD PTR _iFoundD3D9Dll$[ebp]
	add	eax, 1
	mov	DWORD PTR _iFoundD3D9Dll$[ebp], eax
$LN7@CheckDupli:

; 144  : 		}
; 145  : 
; 146  : 	} while( fnModule32Next( hModuleSnap, &me32 ) );

	mov	esi, esp
	lea	eax, DWORD PTR _me32$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hModuleSnap$[ebp]
	push	ecx
	call	DWORD PTR _fnModule32Next$[ebp]
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	$LN8@CheckDupli

; 147  : 
; 148  : 	iDupeD3D9DllsWasVerified = 1;

	mov	DWORD PTR ?iDupeD3D9DllsWasVerified@@3HA, 1 ; iDupeD3D9DllsWasVerified

; 149  : 	
; 150  : 	// If there is more than 1 d3d9.dll or its image size is less than
; 151  : 	// 0x00100005 FORCE_EXIT.
; 152  : 	if(iFoundD3D9Dll > 1 || dwD3D9DllSize < 0x00100005) {

	cmp	DWORD PTR _iFoundD3D9Dll$[ebp], 1
	jg	SHORT $LN3@CheckDupli
	cmp	DWORD PTR ?dwD3D9DllSize@@3KA, 1048581	; dwD3D9DllSize, 00100005H
	jae	SHORT $LN4@CheckDupli
$LN3@CheckDupli:

; 153  : 		FORCE_EXIT( 11 );

	push	11					; 0000000bH
	call	?GameForcedExit@@YAXH@Z			; GameForcedExit
	add	esp, 4
$LN2@CheckDupli:
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN4@CheckDupli
	jmp	SHORT $LN2@CheckDupli
$LN4@CheckDupli:

; 154  : 	}
; 155  : 
; 156  : 	CloseHandle( hModuleSnap );

	mov	esi, esp
	mov	eax, DWORD PTR _hModuleSnap$[ebp]
	push	eax
	call	DWORD PTR __imp__CloseHandle@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN11@CheckDupli:

; 157  : 	return;
; 158  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN21@CheckDupli
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 1272				; 000004f8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN21@CheckDupli:
	DD	7
	DD	$LN20@CheckDupli
$LN20@CheckDupli:
	DD	-604					; fffffda4H
	DD	548					; 00000224H
	DD	$LN13@CheckDupli
	DD	-888					; fffffc88H
	DD	261					; 00000105H
	DD	$LN14@CheckDupli
	DD	-932					; fffffc5cH
	DD	9
	DD	$LN15@CheckDupli
	DD	-968					; fffffc38H
	DD	13					; 0000000dH
	DD	$LN16@CheckDupli
	DD	-1016					; fffffc08H
	DD	25					; 00000019H
	DD	$LN17@CheckDupli
	DD	-1040					; fffffbf0H
	DD	14					; 0000000eH
	DD	$LN18@CheckDupli
	DD	-1064					; fffffbd8H
	DD	13					; 0000000dH
	DD	$LN19@CheckDupli
$LN19@CheckDupli:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	77					; 0000004dH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	51					; 00000033H
	DB	50					; 00000032H
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	69					; 00000045H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	0
$LN18@CheckDupli:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	77					; 0000004dH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	51					; 00000033H
	DB	50					; 00000032H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	114					; 00000072H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	69					; 00000045H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	0
$LN17@CheckDupli:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	67					; 00000043H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	84					; 00000054H
	DB	111					; 0000006fH
	DB	111					; 0000006fH
	DB	108					; 0000006cH
	DB	104					; 00000068H
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	51					; 00000033H
	DB	50					; 00000032H
	DB	83					; 00000053H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	115					; 00000073H
	DB	104					; 00000068H
	DB	111					; 0000006fH
	DB	116					; 00000074H
	DB	69					; 00000045H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	0
$LN16@CheckDupli:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	75					; 0000004bH
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	51					; 00000033H
	DB	50					; 00000032H
	DB	69					; 00000045H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	0
$LN15@CheckDupli:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	68					; 00000044H
	DB	51					; 00000033H
	DB	68					; 00000044H
	DB	57					; 00000039H
	DB	69					; 00000045H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	0
$LN14@CheckDupli:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	77					; 0000004dH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
$LN13@CheckDupli:
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	51					; 00000033H
	DB	50					; 00000032H
	DB	0
?CheckDuplicateD3D9Dlls@@YAXXZ ENDP			; CheckDuplicateD3D9Dlls
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\game\cheats.cpp
;	COMDAT ?DoCheatDataStoring@@YAXXZ
_TEXT	SEGMENT
_pPed$ = -8						; size = 4
?DoCheatDataStoring@@YAXXZ PROC				; DoCheatDataStoring, COMDAT

; 52   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 53   : 	if(!pNetGame) return;

	cmp	DWORD PTR ?pNetGame@@3PAVCNetGame@@A, 0	; pNetGame
	jne	SHORT $LN1@DoCheatDat
	jmp	$LN2@DoCheatDat
$LN1@DoCheatDat:

; 54   : 
; 55   : 	PED_TYPE *pPed = pGame->FindPlayerPed()->m_pPed;

	mov	ecx, DWORD PTR ?pGame@@3PAVCGame@@A	; pGame
	call	?FindPlayerPed@CGame@@QAEPAVCPlayerPed@@XZ ; CGame::FindPlayerPed
	mov	eax, DWORD PTR [eax+28]
	mov	DWORD PTR _pPed$[ebp], eax

; 56   : 
; 57   : 	// Store the current money
; 58   : 	iMoneyStored = pGame->GetLocalMoney();

	mov	ecx, DWORD PTR ?pGame@@3PAVCGame@@A	; pGame
	call	?GetLocalMoney@CGame@@QAEHXZ		; CGame::GetLocalMoney
	mov	DWORD PTR ?iMoneyStored@@3HA, eax	; iMoneyStored

; 59   : 	_asm mov edx, iMoneyStored

	mov	edx, DWORD PTR ?iMoneyStored@@3HA	; iMoneyStored

; 60   : 	_asm ror edx, 5

	ror	edx, 5

; 61   : 	_asm mov iMoneyStored, edx

	mov	DWORD PTR ?iMoneyStored@@3HA, edx	; iMoneyStored

; 62   : 
; 63   : 	// Store the weapon data
; 64   : 	memcpy(byteWeaponData,&pPed->WeaponSlots[0],WEAPON_DATA_SIZE);

	push	364					; 0000016cH
	mov	eax, 28					; 0000001cH
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pPed$[ebp]
	lea	eax, DWORD PTR [edx+ecx+1440]
	push	eax
	push	OFFSET ?byteWeaponData@@3PAEA		; byteWeaponData
	call	_memcpy
	add	esp, 12					; 0000000cH

; 65   : 
; 66   : 	// Store the health and armour
; 67   : 	memcpy(&dwHealth,&pPed->fHealth,4);

	push	4
	mov	eax, DWORD PTR _pPed$[ebp]
	add	eax, 1344				; 00000540H
	push	eax
	push	OFFSET ?dwHealth@@3KA			; dwHealth
	call	_memcpy
	add	esp, 12					; 0000000cH

; 68   : 	_asm mov edx, dwHealth

	mov	edx, DWORD PTR ?dwHealth@@3KA		; dwHealth

; 69   : 	_asm ror edx, 5

	ror	edx, 5

; 70   : 	_asm mov dwHealth, edx

	mov	DWORD PTR ?dwHealth@@3KA, edx		; dwHealth

; 71   : 
; 72   : 	memcpy(&dwArmour,&pPed->fArmour,4);

	push	4
	mov	eax, DWORD PTR _pPed$[ebp]
	add	eax, 1352				; 00000548H
	push	eax
	push	OFFSET ?dwArmour@@3KA			; dwArmour
	call	_memcpy
	add	esp, 12					; 0000000cH

; 73   : 	_asm mov edx, dwArmour

	mov	edx, DWORD PTR ?dwArmour@@3KA		; dwArmour

; 74   : 	_asm ror edx, 5

	ror	edx, 5

; 75   : 	_asm mov dwArmour, edx

	mov	DWORD PTR ?dwArmour@@3KA, edx		; dwArmour

; 76   : 
; 77   : 	// Store the player matrix
; 78   : 	memcpy(&matStore,pPed->entity.mat,sizeof(MATRIX4X4));

	push	64					; 00000040H
	mov	eax, DWORD PTR _pPed$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	push	OFFSET ?matStore@@3U_MATRIX4X4@@A	; matStore
	call	_memcpy
	add	esp, 12					; 0000000cH

; 79   : 
; 80   : 	// Fuck with the Camera's target ent since
; 81   : 	// cheats use it to obtain the player addr.
; 82   : 	dwCamTargetEnt1 = *(PDWORD)0xB6F3B8;

	mov	eax, DWORD PTR ds:11989944
	mov	DWORD PTR ?dwCamTargetEnt1@@3KA, eax	; dwCamTargetEnt1

; 83   : 	*(PDWORD)0xB6F3B8 = 0;

	mov	DWORD PTR ds:11989944, 0

; 84   : 
; 85   : 	dwCamTargetEnt2 = *(PDWORD)0xB6F5F0;

	mov	eax, DWORD PTR ds:11990512
	mov	DWORD PTR ?dwCamTargetEnt2@@3KA, eax	; dwCamTargetEnt2

; 86   : 	*(PDWORD)0xB6F5F0 = 0;

	mov	DWORD PTR ds:11990512, 0
$LN2@DoCheatDat:

; 87   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DoCheatDataStoring@@YAXXZ ENDP				; DoCheatDataStoring
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\game\game.h
;	COMDAT ?FindPlayerPed@CGame@@QAEPAVCPlayerPed@@XZ
_TEXT	SEGMENT
tv74 = -244						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?FindPlayerPed@CGame@@QAEPAVCPlayerPed@@XZ PROC		; CGame::FindPlayerPed, COMDAT
; _this$ = ecx

; 142  : 	CPlayerPed  *FindPlayerPed() {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?FindPlayerPed@CGame@@QAEPAVCPlayerPed@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 143  : 		if(m_pGamePlayer==NULL)	m_pGamePlayer = new CPlayerPed();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN1@FindPlayer
	push	70					; 00000046H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN4@FindPlayer
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0CPlayerPed@@QAE@XZ			; CPlayerPed::CPlayerPed
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN5@FindPlayer
$LN4@FindPlayer:
	mov	DWORD PTR tv74[ebp], 0
$LN5@FindPlayer:
	mov	eax, DWORD PTR tv74[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [ecx+4], edx
$LN1@FindPlayer:

; 144  : 		return m_pGamePlayer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 145  : 	};

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindPlayerPed@CGame@@QAEPAVCPlayerPed@@XZ$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?FindPlayerPed@CGame@@QAEPAVCPlayerPed@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?FindPlayerPed@CGame@@QAEPAVCPlayerPed@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindPlayerPed@CGame@@QAEPAVCPlayerPed@@XZ ENDP		; CGame::FindPlayerPed
END
