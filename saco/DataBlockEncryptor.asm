; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.31101.0 

	TITLE	Z:\sampsrc\02Xu1\raknet\DataBlockEncryptor.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	??0DataBlockEncryptor@@QAE@XZ			; DataBlockEncryptor::DataBlockEncryptor
PUBLIC	??1DataBlockEncryptor@@QAE@XZ			; DataBlockEncryptor::~DataBlockEncryptor
PUBLIC	?IsKeySet@DataBlockEncryptor@@QBE_NXZ		; DataBlockEncryptor::IsKeySet
PUBLIC	?SetKey@DataBlockEncryptor@@QAEXQBE@Z		; DataBlockEncryptor::SetKey
PUBLIC	?UnsetKey@DataBlockEncryptor@@QAEXXZ		; DataBlockEncryptor::UnsetKey
PUBLIC	?Encrypt@DataBlockEncryptor@@QAEXPAEH0PAH@Z	; DataBlockEncryptor::Encrypt
PUBLIC	?Decrypt@DataBlockEncryptor@@QAE_NPAEH0PAH@Z	; DataBlockEncryptor::Decrypt
PUBLIC	??0CheckSum@@QAE@XZ				; CheckSum::CheckSum
PUBLIC	?Clear@CheckSum@@QAEXXZ				; CheckSum::Clear
PUBLIC	?Get@CheckSum@@QAEIXZ				; CheckSum::Get
PUBLIC	?__LINE__Var@?1??Encrypt@DataBlockEncryptor@@QAEXPAEH0PAH@Z@4JA ; `DataBlockEncryptor::Encrypt'::`2'::__LINE__Var
PUBLIC	??_C@_1FO@IBBMPLAN@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAa?$AAt?$AAa?$AAb?$AAl?$AAo?$AAc@ ; `string'
PUBLIC	??_C@_1O@DAMBNKLB@?$AAk?$AAe?$AAy?$AAS?$AAe?$AAt?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CK@LGOIMEII@?$AAi?$AAn?$AAp?$AAu?$AAt?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAp?$AAu?$AAt?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??Decrypt@DataBlockEncryptor@@QAE_NPAEH0PAH@Z@4JA ; `DataBlockEncryptor::Decrypt'::`2'::__LINE__Var
EXTRN	?makeKey@@YAHPAUkeyInstance@@EHPAD@Z:PROC	; makeKey
EXTRN	?cipherInit@@YAHPAUcipherInstance@@EPAD@Z:PROC	; cipherInit
EXTRN	?blockEncrypt@@YAHPAUcipherInstance@@PAUkeyInstance@@PAEH2@Z:PROC ; blockEncrypt
EXTRN	?blockDecrypt@@YAHPAUcipherInstance@@PAUkeyInstance@@PAEH2@Z:PROC ; blockDecrypt
EXTRN	?Add@CheckSum@@QAEXPAEI@Z:PROC			; CheckSum::Add
EXTRN	?randomMT@@YAIXZ:PROC				; randomMT
EXTRN	__wassert:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ?__LINE__Var@?1??Decrypt@DataBlockEncryptor@@QAE_NPAEH0PAH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??Decrypt@DataBlockEncryptor@@QAE_NPAEH0PAH@Z@4JA DD 089H ; `DataBlockEncryptor::Decrypt'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1CK@LGOIMEII@?$AAi?$AAn?$AAp?$AAu?$AAt?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAp?$AAu?$AAt?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@LGOIMEII@?$AAi?$AAn?$AAp?$AAu?$AAt?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAp?$AAu?$AAt?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?$AA@ DB 'i'
	DB	00H, 'n', 00H, 'p', 00H, 'u', 00H, 't', 00H, ' ', 00H, '&', 00H
	DB	'&', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't'
	DB	00H, 'L', 00H, 'e', 00H, 'n', 00H, 'g', 00H, 't', 00H, 'h', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@DAMBNKLB@?$AAk?$AAe?$AAy?$AAS?$AAe?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1O@DAMBNKLB@?$AAk?$AAe?$AAy?$AAS?$AAe?$AAt?$AA?$AA@ DB 'k', 00H, 'e'
	DB	00H, 'y', 00H, 'S', 00H, 'e', 00H, 't', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FO@IBBMPLAN@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAa?$AAt?$AAa?$AAb?$AAl?$AAo?$AAc@
CONST	SEGMENT
??_C@_1FO@IBBMPLAN@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAa?$AAt?$AAa?$AAb?$AAl?$AAo?$AAc@ DB 'z'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H
	DB	's', 00H, 'r', 00H, 'c', 00H, '\', 00H, '0', 00H, '2', 00H, 'x'
	DB	00H, 'u', 00H, '1', 00H, '\', 00H, 'r', 00H, 'a', 00H, 'k', 00H
	DB	'n', 00H, 'e', 00H, 't', 00H, '\', 00H, 'd', 00H, 'a', 00H, 't'
	DB	00H, 'a', 00H, 'b', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H
	DB	'e', 00H, 'n', 00H, 'c', 00H, 'r', 00H, 'y', 00H, 'p', 00H, 't'
	DB	00H, 'o', 00H, 'r', 00H, '.', 00H, 'c', 00H, 'p', 00H, 'p', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??Encrypt@DataBlockEncryptor@@QAEXPAEH0PAH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??Encrypt@DataBlockEncryptor@@QAEXPAEH0PAH@Z@4JA DD 036H ; `DataBlockEncryptor::Encrypt'::`2'::__LINE__Var
_DATA	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\checksum.h
;	COMDAT ?Get@CheckSum@@QAEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Get@CheckSum@@QAEIXZ PROC				; CheckSum::Get, COMDAT
; _this$ = ecx

; 41   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 42   : 		return sum;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+6]

; 43   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Get@CheckSum@@QAEIXZ ENDP				; CheckSum::Get
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\checksum.h
;	COMDAT ?Clear@CheckSum@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Clear@CheckSum@@QAEXXZ PROC				; CheckSum::Clear, COMDAT
; _this$ = ecx

; 24   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 25   : 		sum = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+6], 0

; 26   : 		r = 55665;

	mov	eax, 55665				; 0000d971H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx], ax

; 27   : 		c1 = 52845;

	mov	eax, 52845				; 0000ce6dH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+2], ax

; 28   : 		c2 = 22719;

	mov	eax, 22719				; 000058bfH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+4], ax

; 29   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@CheckSum@@QAEXXZ ENDP				; CheckSum::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\checksum.h
;	COMDAT ??0CheckSum@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0CheckSum@@QAE@XZ PROC				; CheckSum::CheckSum, COMDAT
; _this$ = ecx

; 18   : 	CheckSum()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 19   : 	{
; 20   : 		Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@CheckSum@@QAEXXZ			; CheckSum::Clear

; 21   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0CheckSum@@QAE@XZ ENDP				; CheckSum::CheckSum
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\datablockencryptor.cpp
;	COMDAT ?Decrypt@DataBlockEncryptor@@QAE_NPAEH0PAH@Z
_TEXT	SEGMENT
_checkSumCalculator$ = -112				; size = 10
_encodedPad$ = -77					; size = 1
_paddingBytes$ = -65					; size = 1
_checkSum$ = -56					; size = 4
_lastBlock$ = -44					; size = 4
_byteIndex$ = -32					; size = 4
_index$ = -20						; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
_inputLength$ = 12					; size = 4
_output$ = 16						; size = 4
_outputLength$ = 20					; size = 4
?Decrypt@DataBlockEncryptor@@QAE_NPAEH0PAH@Z PROC	; DataBlockEncryptor::Decrypt, COMDAT
; _this$ = ecx

; 137  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 308				; 00000134H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-308]
	mov	ecx, 77					; 0000004dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 138  : 	unsigned index, byteIndex, lastBlock;
; 139  : 	unsigned int checkSum;
; 140  : 	unsigned char paddingBytes;
; 141  : 	unsigned char encodedPad;
; 142  : 	unsigned char randomChar;
; 143  : 	CheckSum checkSumCalculator;

	lea	ecx, DWORD PTR _checkSumCalculator$[ebp]
	call	??0CheckSum@@QAE@XZ			; CheckSum::CheckSum

; 144  : #ifdef _DEBUG
; 145  : 
; 146  : 	assert( keySet );

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+585]
	test	ecx, ecx
	jne	SHORT $LN16@Decrypt
	mov	edx, DWORD PTR ?__LINE__Var@?1??Decrypt@DataBlockEncryptor@@QAE_NPAEH0PAH@Z@4JA
	add	edx, 9
	push	edx
	push	OFFSET ??_C@_1FO@IBBMPLAN@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAa?$AAt?$AAa?$AAb?$AAl?$AAo?$AAc@
	push	OFFSET ??_C@_1O@DAMBNKLB@?$AAk?$AAe?$AAy?$AAS?$AAe?$AAt?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN16@Decrypt:

; 147  : #endif
; 148  : 
; 149  : 	if ( input == 0 || inputLength < 16 || ( inputLength % 16 ) != 0 )

	cmp	DWORD PTR _input$[ebp], 0
	je	SHORT $LN12@Decrypt
	cmp	DWORD PTR _inputLength$[ebp], 16	; 00000010H
	jl	SHORT $LN12@Decrypt
	mov	eax, DWORD PTR _inputLength$[ebp]
	and	eax, -2147483633			; 8000000fH
	jns	SHORT $LN22@Decrypt
	dec	eax
	or	eax, -16				; fffffff0H
	inc	eax
$LN22@Decrypt:
	test	eax, eax
	je	SHORT $LN13@Decrypt
$LN12@Decrypt:

; 150  : 	{
; 151  : 		return false;

	xor	al, al
	jmp	$LN14@Decrypt
$LN13@Decrypt:

; 152  : 	}
; 153  : 
; 154  : 	// Unchain in reverse order
; 155  : 	for ( index = 16; ( int ) index <= inputLength - 16;index += 16 )

	mov	DWORD PTR _index$[ebp], 16		; 00000010H
	jmp	SHORT $LN11@Decrypt
$LN10@Decrypt:
	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _index$[ebp], eax
$LN11@Decrypt:
	mov	eax, DWORD PTR _inputLength$[ebp]
	sub	eax, 16					; 00000010H
	cmp	DWORD PTR _index$[ebp], eax
	jg	$LN9@Decrypt

; 156  : 	{
; 157  : 	//	secretKeyAES128.decrypt16( input + index );
; 158  : 		blockDecrypt(&cipherInst, &keyDecrypt, input + index, 16, input + index);

	mov	eax, DWORD PTR _input$[ebp]
	add	eax, DWORD PTR _index$[ebp]
	push	eax
	push	16					; 00000010H
	mov	ecx, DWORD PTR _input$[ebp]
	add	ecx, DWORD PTR _index$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 282				; 0000011aH
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 564				; 00000234H
	push	eax
	call	?blockDecrypt@@YAHPAUcipherInstance@@PAUkeyInstance@@PAEH2@Z ; blockDecrypt
	add	esp, 20					; 00000014H

; 159  : 
; 160  : 		for ( byteIndex = 0; byteIndex < 16; byteIndex++ )

	mov	DWORD PTR _byteIndex$[ebp], 0
	jmp	SHORT $LN8@Decrypt
$LN7@Decrypt:
	mov	eax, DWORD PTR _byteIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _byteIndex$[ebp], eax
$LN8@Decrypt:
	cmp	DWORD PTR _byteIndex$[ebp], 16		; 00000010H
	jae	SHORT $LN6@Decrypt

; 161  : 		{
; 162  : 			if ( index + 16 == ( unsigned ) inputLength )

	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 16					; 00000010H
	cmp	eax, DWORD PTR _inputLength$[ebp]
	jne	SHORT $LN5@Decrypt

; 163  : 				input[ index + byteIndex ] ^= input[ byteIndex ];

	mov	eax, DWORD PTR _index$[ebp]
	add	eax, DWORD PTR _byteIndex$[ebp]
	mov	ecx, DWORD PTR _input$[ebp]
	add	ecx, DWORD PTR _byteIndex$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	ecx, DWORD PTR _input$[ebp]
	movzx	eax, BYTE PTR [ecx+eax]
	xor	eax, edx
	mov	ecx, DWORD PTR _index$[ebp]
	add	ecx, DWORD PTR _byteIndex$[ebp]
	mov	edx, DWORD PTR _input$[ebp]
	mov	BYTE PTR [edx+ecx], al

; 164  : 			else

	jmp	SHORT $LN4@Decrypt
$LN5@Decrypt:

; 165  : 				input[ index + byteIndex ] ^= input[ index + 16 + byteIndex ];

	mov	eax, DWORD PTR _index$[ebp]
	add	eax, DWORD PTR _byteIndex$[ebp]
	mov	ecx, DWORD PTR _byteIndex$[ebp]
	mov	edx, DWORD PTR _index$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+16]
	mov	edx, DWORD PTR _input$[ebp]
	movzx	ecx, BYTE PTR [edx+ecx]
	mov	edx, DWORD PTR _input$[ebp]
	movzx	eax, BYTE PTR [edx+eax]
	xor	eax, ecx
	mov	ecx, DWORD PTR _index$[ebp]
	add	ecx, DWORD PTR _byteIndex$[ebp]
	mov	edx, DWORD PTR _input$[ebp]
	mov	BYTE PTR [edx+ecx], al
$LN4@Decrypt:

; 166  : 		}

	jmp	SHORT $LN7@Decrypt
$LN6@Decrypt:

; 167  : 
; 168  : 		lastBlock = index;

	mov	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR _lastBlock$[ebp], eax

; 169  : 	};

	jmp	$LN10@Decrypt
$LN9@Decrypt:

; 170  : 
; 171  : 	// Decrypt the first block
; 172  : 	//secretKeyAES128.decrypt16( input );
; 173  : 	blockDecrypt(&cipherInst, &keyDecrypt, input, 16, input);

	mov	eax, DWORD PTR _input$[ebp]
	push	eax
	push	16					; 00000010H
	mov	ecx, DWORD PTR _input$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 282				; 0000011aH
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 564				; 00000234H
	push	eax
	call	?blockDecrypt@@YAHPAUcipherInstance@@PAUkeyInstance@@PAEH2@Z ; blockDecrypt
	add	esp, 20					; 00000014H

; 174  : 
; 175  : 	// Read checksum
; 176  : #ifdef HOST_ENDIAN_IS_BIG
; 177  : 	checkSum = (unsigned int)input[0] | (unsigned int)(input[1]<<8) |
; 178  : 		(unsigned int)(input[2]<<16)|(unsigned int)(input[3]<<24);
; 179  : #else
; 180  : 	memcpy( ( char* ) & checkSum, input, sizeof( checkSum ) );

	push	4
	mov	eax, DWORD PTR _input$[ebp]
	push	eax
	lea	ecx, DWORD PTR _checkSum$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 181  : #endif
; 182  : 
; 183  : 	// Read the pad size variable
; 184  : 	memcpy( ( char* ) & encodedPad, input + sizeof( randomChar ) + sizeof( checkSum ), sizeof( encodedPad ) );

	push	1
	mov	eax, DWORD PTR _input$[ebp]
	add	eax, 5
	push	eax
	lea	ecx, DWORD PTR _encodedPad$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 185  : 
; 186  : 	// Ignore the high 4 bytes
; 187  : 	paddingBytes = encodedPad & 0x0F;

	movzx	eax, BYTE PTR _encodedPad$[ebp]
	and	eax, 15					; 0000000fH
	mov	BYTE PTR _paddingBytes$[ebp], al

; 188  : 
; 189  : 
; 190  : 	// Get the data length
; 191  : 	*outputLength = inputLength - sizeof( randomChar ) - sizeof( checkSum ) - sizeof( encodedPad ) - paddingBytes;

	mov	eax, DWORD PTR _inputLength$[ebp]
	sub	eax, 6
	movzx	ecx, BYTE PTR _paddingBytes$[ebp]
	sub	eax, ecx
	mov	edx, DWORD PTR _outputLength$[ebp]
	mov	DWORD PTR [edx], eax

; 192  : 
; 193  : 	// Calculate the checksum on the data.
; 194  : 	checkSumCalculator.Add( input + sizeof( checkSum ), *outputLength + sizeof( randomChar ) + sizeof( encodedPad ) + paddingBytes );

	mov	eax, DWORD PTR _outputLength$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR _paddingBytes$[ebp]
	lea	eax, DWORD PTR [ecx+edx+2]
	push	eax
	mov	ecx, DWORD PTR _input$[ebp]
	add	ecx, 4
	push	ecx
	lea	ecx, DWORD PTR _checkSumCalculator$[ebp]
	call	?Add@CheckSum@@QAEXPAEI@Z		; CheckSum::Add

; 195  : 
; 196  : 	if ( checkSum != checkSumCalculator.Get() )

	lea	ecx, DWORD PTR _checkSumCalculator$[ebp]
	call	?Get@CheckSum@@QAEIXZ			; CheckSum::Get
	cmp	DWORD PTR _checkSum$[ebp], eax
	je	SHORT $LN3@Decrypt

; 197  : 		return false;

	xor	al, al
	jmp	SHORT $LN14@Decrypt
$LN3@Decrypt:

; 198  : 
; 199  : 	// Read the data
; 200  : 	if ( input == output )

	mov	eax, DWORD PTR _input$[ebp]
	cmp	eax, DWORD PTR _output$[ebp]
	jne	SHORT $LN2@Decrypt

; 201  : 		memmove( output, input + sizeof( randomChar ) + sizeof( checkSum ) + sizeof( encodedPad ) + paddingBytes, *outputLength );

	mov	eax, DWORD PTR _outputLength$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	movzx	edx, BYTE PTR _paddingBytes$[ebp]
	mov	eax, DWORD PTR _input$[ebp]
	lea	ecx, DWORD PTR [eax+edx+6]
	push	ecx
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_memmove
	add	esp, 12					; 0000000cH

; 202  : 	else

	jmp	SHORT $LN1@Decrypt
$LN2@Decrypt:

; 203  : 		memcpy( output, input + sizeof( randomChar ) + sizeof( checkSum ) + sizeof( encodedPad ) + paddingBytes, *outputLength );

	mov	eax, DWORD PTR _outputLength$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	movzx	edx, BYTE PTR _paddingBytes$[ebp]
	mov	eax, DWORD PTR _input$[ebp]
	lea	ecx, DWORD PTR [eax+edx+6]
	push	ecx
	mov	edx, DWORD PTR _output$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN1@Decrypt:

; 204  : 
; 205  : 
; 206  : 	return true;

	mov	al, 1
$LN14@Decrypt:

; 207  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN21@Decrypt
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 308				; 00000134H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	npad	3
$LN21@Decrypt:
	DD	3
	DD	$LN20@Decrypt
$LN20@Decrypt:
	DD	-56					; ffffffc8H
	DD	4
	DD	$LN17@Decrypt
	DD	-77					; ffffffb3H
	DD	1
	DD	$LN18@Decrypt
	DD	-112					; ffffff90H
	DD	10					; 0000000aH
	DD	$LN19@Decrypt
$LN19@Decrypt:
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	83					; 00000053H
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	0
$LN18@Decrypt:
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	0
$LN17@Decrypt:
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	83					; 00000053H
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	0
?Decrypt@DataBlockEncryptor@@QAE_NPAEH0PAH@Z ENDP	; DataBlockEncryptor::Decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\datablockencryptor.cpp
;	COMDAT ?Encrypt@DataBlockEncryptor@@QAEXPAEH0PAH@Z
_TEXT	SEGMENT
_checkSumCalculator$ = -112				; size = 10
_randomChar$ = -89					; size = 1
_encodedPad$ = -77					; size = 1
_paddingBytes$ = -65					; size = 1
_checkSum$ = -56					; size = 4
_lastBlock$ = -44					; size = 4
_byteIndex$ = -32					; size = 4
_index$ = -20						; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
_inputLength$ = 12					; size = 4
_output$ = 16						; size = 4
_outputLength$ = 20					; size = 4
?Encrypt@DataBlockEncryptor@@QAEXPAEH0PAH@Z PROC	; DataBlockEncryptor::Encrypt, COMDAT
; _this$ = ecx

; 54   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 308				; 00000134H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-308]
	mov	ecx, 77					; 0000004dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 55   : 	unsigned index, byteIndex, lastBlock;
; 56   : 	unsigned int checkSum;
; 57   : 	unsigned char paddingBytes;
; 58   : 	unsigned char encodedPad;
; 59   : 	unsigned char randomChar;
; 60   : 	CheckSum checkSumCalculator;

	lea	ecx, DWORD PTR _checkSumCalculator$[ebp]
	call	??0CheckSum@@QAE@XZ			; CheckSum::CheckSum

; 61   : 
; 62   : #ifdef _DEBUG
; 63   : 
; 64   : 	assert( keySet );

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+585]
	test	ecx, ecx
	jne	SHORT $LN14@Encrypt
	mov	edx, DWORD PTR ?__LINE__Var@?1??Encrypt@DataBlockEncryptor@@QAEXPAEH0PAH@Z@4JA
	add	edx, 10					; 0000000aH
	push	edx
	push	OFFSET ??_C@_1FO@IBBMPLAN@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAa?$AAt?$AAa?$AAb?$AAl?$AAo?$AAc@
	push	OFFSET ??_C@_1O@DAMBNKLB@?$AAk?$AAe?$AAy?$AAS?$AAe?$AAt?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN14@Encrypt:

; 65   : #endif
; 66   : 
; 67   : 	assert( input && inputLength );

	cmp	DWORD PTR _input$[ebp], 0
	je	SHORT $LN15@Encrypt
	cmp	DWORD PTR _inputLength$[ebp], 0
	jne	SHORT $LN16@Encrypt
$LN15@Encrypt:
	mov	eax, DWORD PTR ?__LINE__Var@?1??Encrypt@DataBlockEncryptor@@QAEXPAEH0PAH@Z@4JA
	add	eax, 13					; 0000000dH
	push	eax
	push	OFFSET ??_C@_1FO@IBBMPLAN@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAa?$AAt?$AAa?$AAb?$AAl?$AAo?$AAc@
	push	OFFSET ??_C@_1CK@LGOIMEII@?$AAi?$AAn?$AAp?$AAu?$AAt?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAn?$AAp?$AAu?$AAt?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN16@Encrypt:

; 68   : 
; 69   : 
; 70   : 	// randomChar will randomize the data so the same data sent twice will not look the same
; 71   : 	randomChar = (unsigned char) randomMT();

	call	?randomMT@@YAIXZ			; randomMT
	mov	BYTE PTR _randomChar$[ebp], al

; 72   : 
; 73   : 	// 16-(((x-1) % 16)+1)
; 74   : 
; 75   : 	// # of padding bytes is 16 -(((input_length + extra_data -1) % 16)+1)
; 76   : 	paddingBytes = (unsigned char) ( 16 - ( ( ( inputLength + sizeof( randomChar ) + sizeof( checkSum ) + sizeof( encodedPad ) - 1 ) % 16 ) + 1 ) );

	mov	eax, DWORD PTR _inputLength$[ebp]
	add	eax, 5
	xor	edx, edx
	mov	ecx, 16					; 00000010H
	div	ecx
	add	edx, 1
	mov	eax, 16					; 00000010H
	sub	eax, edx
	mov	BYTE PTR _paddingBytes$[ebp], al

; 77   : 
; 78   : 	// Randomize the pad size variable
; 79   : 	encodedPad = (unsigned char) randomMT();

	call	?randomMT@@YAIXZ			; randomMT
	mov	BYTE PTR _encodedPad$[ebp], al

; 80   : 	encodedPad <<= 4;

	mov	al, BYTE PTR _encodedPad$[ebp]
	shl	al, 4
	mov	BYTE PTR _encodedPad$[ebp], al

; 81   : 	encodedPad |= paddingBytes;

	movzx	eax, BYTE PTR _paddingBytes$[ebp]
	movzx	ecx, BYTE PTR _encodedPad$[ebp]
	or	ecx, eax
	mov	BYTE PTR _encodedPad$[ebp], cl

; 82   : 
; 83   : 	*outputLength = inputLength + sizeof( randomChar ) + sizeof( checkSum ) + sizeof( encodedPad ) + paddingBytes;

	movzx	eax, BYTE PTR _paddingBytes$[ebp]
	mov	ecx, DWORD PTR _inputLength$[ebp]
	lea	edx, DWORD PTR [ecx+eax+6]
	mov	eax, DWORD PTR _outputLength$[ebp]
	mov	DWORD PTR [eax], edx

; 84   : 
; 85   : 	// Write the data first, in case we are overwriting ourselves
; 86   : 
; 87   : 	if ( input == output )

	mov	eax, DWORD PTR _input$[ebp]
	cmp	eax, DWORD PTR _output$[ebp]
	jne	SHORT $LN11@Encrypt

; 88   : 		memmove( output + sizeof( checkSum ) + sizeof( randomChar ) + sizeof( encodedPad ) + paddingBytes, input, inputLength );

	mov	eax, DWORD PTR _inputLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _input$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _paddingBytes$[ebp]
	mov	eax, DWORD PTR _output$[ebp]
	lea	ecx, DWORD PTR [eax+edx+6]
	push	ecx
	call	_memmove
	add	esp, 12					; 0000000cH

; 89   : 	else

	jmp	SHORT $LN10@Encrypt
$LN11@Encrypt:

; 90   : 		memcpy( output + sizeof( checkSum ) + sizeof( randomChar ) + sizeof( encodedPad ) + paddingBytes, input, inputLength );

	mov	eax, DWORD PTR _inputLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _input$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _paddingBytes$[ebp]
	mov	eax, DWORD PTR _output$[ebp]
	lea	ecx, DWORD PTR [eax+edx+6]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@Encrypt:

; 91   : 
; 92   : 	// Write the random char
; 93   : 	memcpy( output + sizeof( checkSum ), ( char* ) & randomChar, sizeof( randomChar ) );

	push	1
	lea	eax, DWORD PTR _randomChar$[ebp]
	push	eax
	mov	ecx, DWORD PTR _output$[ebp]
	add	ecx, 4
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 94   : 
; 95   : 	// Write the pad size variable
; 96   : 	memcpy( output + sizeof( checkSum ) + sizeof( randomChar ), ( char* ) & encodedPad, sizeof( encodedPad ) );

	push	1
	lea	eax, DWORD PTR _encodedPad$[ebp]
	push	eax
	mov	ecx, DWORD PTR _output$[ebp]
	add	ecx, 5
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 97   : 
; 98   : 	// Write the padding
; 99   : 	for ( index = 0; index < paddingBytes; index++ )

	mov	DWORD PTR _index$[ebp], 0
	jmp	SHORT $LN9@Encrypt
$LN8@Encrypt:
	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 1
	mov	DWORD PTR _index$[ebp], eax
$LN9@Encrypt:
	movzx	eax, BYTE PTR _paddingBytes$[ebp]
	cmp	DWORD PTR _index$[ebp], eax
	jae	SHORT $LN7@Encrypt

; 100  : 		*( output + sizeof( checkSum ) + sizeof( randomChar ) + sizeof( encodedPad ) + index ) = (unsigned char) randomMT();

	call	?randomMT@@YAIXZ			; randomMT
	mov	ecx, DWORD PTR _output$[ebp]
	add	ecx, DWORD PTR _index$[ebp]
	mov	BYTE PTR [ecx+6], al
	jmp	SHORT $LN8@Encrypt
$LN7@Encrypt:

; 101  : 
; 102  : 	// Calculate the checksum on the data
; 103  : 	checkSumCalculator.Add( output + sizeof( checkSum ), inputLength + sizeof( randomChar ) + sizeof( encodedPad ) + paddingBytes );

	movzx	eax, BYTE PTR _paddingBytes$[ebp]
	mov	ecx, DWORD PTR _inputLength$[ebp]
	lea	edx, DWORD PTR [ecx+eax+2]
	push	edx
	mov	eax, DWORD PTR _output$[ebp]
	add	eax, 4
	push	eax
	lea	ecx, DWORD PTR _checkSumCalculator$[ebp]
	call	?Add@CheckSum@@QAEXPAEI@Z		; CheckSum::Add

; 104  : 
; 105  : 	checkSum = checkSumCalculator.Get();

	lea	ecx, DWORD PTR _checkSumCalculator$[ebp]
	call	?Get@CheckSum@@QAEIXZ			; CheckSum::Get
	mov	DWORD PTR _checkSum$[ebp], eax

; 106  : 
; 107  : 	// Write checksum
; 108  : #ifdef HOST_ENDIAN_IS_BIG
; 109  : 	output[0] = checkSum&0xFF;
; 110  : 	output[1] = (checkSum>>8)&0xFF;
; 111  : 	output[2] = (checkSum>>16)&0xFF;
; 112  : 	output[3] = (checkSum>>24)&0xFF;
; 113  : #else
; 114  : 	memcpy( output, ( char* ) & checkSum, sizeof( checkSum ) );

	push	4
	lea	eax, DWORD PTR _checkSum$[ebp]
	push	eax
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 115  : #endif
; 116  : 
; 117  : 	// AES on the first block
; 118  : //	secretKeyAES128.encrypt16( output );
; 119  : 	blockEncrypt(&cipherInst, &keyEncrypt, output, 16, output);

	mov	eax, DWORD PTR _output$[ebp]
	push	eax
	push	16					; 00000010H
	mov	ecx, DWORD PTR _output$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 564				; 00000234H
	push	eax
	call	?blockEncrypt@@YAHPAUcipherInstance@@PAUkeyInstance@@PAEH2@Z ; blockEncrypt
	add	esp, 20					; 00000014H

; 120  : 
; 121  : 	lastBlock = 0;

	mov	DWORD PTR _lastBlock$[ebp], 0

; 122  : 
; 123  : 	// Now do AES on every other block from back to front
; 124  : 	for ( index = *outputLength - 16; index >= 16; index -= 16 )

	mov	eax, DWORD PTR _outputLength$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 16					; 00000010H
	mov	DWORD PTR _index$[ebp], ecx
	jmp	SHORT $LN6@Encrypt
$LN5@Encrypt:
	mov	eax, DWORD PTR _index$[ebp]
	sub	eax, 16					; 00000010H
	mov	DWORD PTR _index$[ebp], eax
$LN6@Encrypt:
	cmp	DWORD PTR _index$[ebp], 16		; 00000010H
	jb	SHORT $LN12@Encrypt

; 125  : 	{
; 126  : 		for ( byteIndex = 0; byteIndex < 16; byteIndex++ )

	mov	DWORD PTR _byteIndex$[ebp], 0
	jmp	SHORT $LN3@Encrypt
$LN2@Encrypt:
	mov	eax, DWORD PTR _byteIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _byteIndex$[ebp], eax
$LN3@Encrypt:
	cmp	DWORD PTR _byteIndex$[ebp], 16		; 00000010H
	jae	SHORT $LN1@Encrypt

; 127  : 			output[ index + byteIndex ] ^= output[ lastBlock + byteIndex ];

	mov	eax, DWORD PTR _index$[ebp]
	add	eax, DWORD PTR _byteIndex$[ebp]
	mov	ecx, DWORD PTR _lastBlock$[ebp]
	add	ecx, DWORD PTR _byteIndex$[ebp]
	mov	edx, DWORD PTR _output$[ebp]
	movzx	ecx, BYTE PTR [edx+ecx]
	mov	edx, DWORD PTR _output$[ebp]
	movzx	eax, BYTE PTR [edx+eax]
	xor	eax, ecx
	mov	ecx, DWORD PTR _index$[ebp]
	add	ecx, DWORD PTR _byteIndex$[ebp]
	mov	edx, DWORD PTR _output$[ebp]
	mov	BYTE PTR [edx+ecx], al
	jmp	SHORT $LN2@Encrypt
$LN1@Encrypt:

; 128  : 
; 129  : 		//secretKeyAES128.encrypt16( output + index );
; 130  : 		blockEncrypt(&cipherInst, &keyEncrypt, output+index, 16, output+index);

	mov	eax, DWORD PTR _output$[ebp]
	add	eax, DWORD PTR _index$[ebp]
	push	eax
	push	16					; 00000010H
	mov	ecx, DWORD PTR _output$[ebp]
	add	ecx, DWORD PTR _index$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 564				; 00000234H
	push	eax
	call	?blockEncrypt@@YAHPAUcipherInstance@@PAUkeyInstance@@PAEH2@Z ; blockEncrypt
	add	esp, 20					; 00000014H

; 131  : 
; 132  : 		lastBlock = index;

	mov	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR _lastBlock$[ebp], eax

; 133  : 	}

	jmp	SHORT $LN5@Encrypt
$LN12@Encrypt:

; 134  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN22@Encrypt
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 308				; 00000134H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	npad	3
$LN22@Encrypt:
	DD	4
	DD	$LN21@Encrypt
$LN21@Encrypt:
	DD	-56					; ffffffc8H
	DD	4
	DD	$LN17@Encrypt
	DD	-77					; ffffffb3H
	DD	1
	DD	$LN18@Encrypt
	DD	-89					; ffffffa7H
	DD	1
	DD	$LN19@Encrypt
	DD	-112					; ffffff90H
	DD	10					; 0000000aH
	DD	$LN20@Encrypt
$LN20@Encrypt:
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	83					; 00000053H
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	0
$LN19@Encrypt:
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	111					; 0000006fH
	DB	109					; 0000006dH
	DB	67					; 00000043H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	0
$LN18@Encrypt:
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	0
$LN17@Encrypt:
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	83					; 00000053H
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	0
?Encrypt@DataBlockEncryptor@@QAEXPAEH0PAH@Z ENDP	; DataBlockEncryptor::Encrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\datablockencryptor.cpp
;	COMDAT ?UnsetKey@DataBlockEncryptor@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?UnsetKey@DataBlockEncryptor@@QAEXXZ PROC		; DataBlockEncryptor::UnsetKey, COMDAT
; _this$ = ecx

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 50   : 	keySet = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+585], 0

; 51   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UnsetKey@DataBlockEncryptor@@QAEXXZ ENDP		; DataBlockEncryptor::UnsetKey
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\datablockencryptor.cpp
;	COMDAT ?SetKey@DataBlockEncryptor@@QAEXQBE@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_key$ = 8						; size = 4
?SetKey@DataBlockEncryptor@@QAEXQBE@Z PROC		; DataBlockEncryptor::SetKey, COMDAT
; _this$ = ecx

; 40   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 	keySet = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+585], 1

; 42   : 	//secretKeyAES128.set_key( key );
; 43   : 	makeKey(&keyEncrypt, DIR_ENCRYPT, 16, (char*)key);

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	push	16					; 00000010H
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?makeKey@@YAHPAUkeyInstance@@EHPAD@Z	; makeKey
	add	esp, 16					; 00000010H

; 44   : 	makeKey(&keyDecrypt, DIR_DECRYPT, 16, (char*)key);

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	push	16					; 00000010H
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 282				; 0000011aH
	push	ecx
	call	?makeKey@@YAHPAUkeyInstance@@EHPAD@Z	; makeKey
	add	esp, 16					; 00000010H

; 45   : 	cipherInit(&cipherInst, MODE_ECB, 0); // ECB is not secure except that I chain manually farther down.

	push	0
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 564				; 00000234H
	push	eax
	call	?cipherInit@@YAHPAUcipherInstance@@EPAD@Z ; cipherInit
	add	esp, 12					; 0000000cH

; 46   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetKey@DataBlockEncryptor@@QAEXQBE@Z ENDP		; DataBlockEncryptor::SetKey
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\datablockencryptor.cpp
;	COMDAT ?IsKeySet@DataBlockEncryptor@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?IsKeySet@DataBlockEncryptor@@QBE_NXZ PROC		; DataBlockEncryptor::IsKeySet, COMDAT
; _this$ = ecx

; 35   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 36   : 	return keySet;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+585]

; 37   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsKeySet@DataBlockEncryptor@@QBE_NXZ ENDP		; DataBlockEncryptor::IsKeySet
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\datablockencryptor.cpp
;	COMDAT ??1DataBlockEncryptor@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1DataBlockEncryptor@@QAE@XZ PROC			; DataBlockEncryptor::~DataBlockEncryptor, COMDAT
; _this$ = ecx

; 32   : {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1DataBlockEncryptor@@QAE@XZ ENDP			; DataBlockEncryptor::~DataBlockEncryptor
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\datablockencryptor.cpp
;	COMDAT ??0DataBlockEncryptor@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0DataBlockEncryptor@@QAE@XZ PROC			; DataBlockEncryptor::DataBlockEncryptor, COMDAT
; _this$ = ecx

; 27   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 28   : 	keySet = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+585], 0

; 29   : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0DataBlockEncryptor@@QAE@XZ ENDP			; DataBlockEncryptor::DataBlockEncryptor
_TEXT	ENDS
END
