; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.31101.0 

	TITLE	Z:\sampsrc\02Xu1\saco\game\scripting.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?gst@@3PAUGAME_SCRIPT_THREAD@@A			; gst
PUBLIC	?ProcessOneCommand@@3P6GHXZA			; ProcessOneCommand
PUBLIC	?ScriptBuf@@3PAEA				; ScriptBuf
PUBLIC	?pdwParamVars@@3PAPAKA				; pdwParamVars
PUBLIC	?dwScmOpcodeDebug@@3KA				; dwScmOpcodeDebug
PUBLIC	?bScmLocalDebug@@3HA				; bScmLocalDebug
PUBLIC	?bExceptionDisplayed@@3HA			; bExceptionDisplayed
_BSS	SEGMENT
?gst@@3PAUGAME_SCRIPT_THREAD@@A DD 01H DUP (?)		; gst
?ScriptBuf@@3PAEA DB 0ffH DUP (?)			; ScriptBuf
	ALIGN	4

?pdwParamVars@@3PAPAKA DD 012H DUP (?)			; pdwParamVars
?dwScmOpcodeDebug@@3KA DD 01H DUP (?)			; dwScmOpcodeDebug
?bScmLocalDebug@@3HA DD 01H DUP (?)			; bScmLocalDebug
?bExceptionDisplayed@@3HA DD 01H DUP (?)		; bExceptionDisplayed
_BSS	ENDS
_DATA	SEGMENT
?ProcessOneCommand@@3P6GHXZA DD 0469eb0H		; ProcessOneCommand
_DATA	ENDS
PUBLIC	?InitScripting@@YAXXZ				; InitScripting
PUBLIC	?ScriptCommand@@YAHPBUSCRIPT_COMMAND@@ZZ	; ScriptCommand
PUBLIC	?ExecuteScriptBuf@@YAHXZ			; ExecuteScriptBuf
PUBLIC	??_C@_0CC@MGOBGFLO@Warning?3?5error?5using?5opcode?3?50x?$CF@ ; `string'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strlen:PROC
EXTRN	?AddDebugMessage@CChatWindow@@QAAXPADZZ:PROC	; CChatWindow::AddDebugMessage
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?pChatWindow@@3PAVCChatWindow@@A:DWORD		; pChatWindow
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0CC@MGOBGFLO@Warning?3?5error?5using?5opcode?3?50x?$CF@
CONST	SEGMENT
??_C@_0CC@MGOBGFLO@Warning?3?5error?5using?5opcode?3?50x?$CF@ DB 'Warning'
	DB	': error using opcode: 0x%X', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?ScriptCommand@@YAHPBUSCRIPT_COMMAND@@ZZ$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?ScriptCommand@@YAHPBUSCRIPT_COMMAND@@ZZ$0
__unwindtable$?ScriptCommand@@YAHPBUSCRIPT_COMMAND@@ZZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?ScriptCommand@@YAHPBUSCRIPT_COMMAND@@ZZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?ScriptCommand@@YAHPBUSCRIPT_COMMAND@@ZZ$2
__ehfuncinfo$?ScriptCommand@@YAHPBUSCRIPT_COMMAND@@ZZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ScriptCommand@@YAHPBUSCRIPT_COMMAND@@ZZ
	DD	01H
	DD	FLAT:__tryblocktable$?ScriptCommand@@YAHPBUSCRIPT_COMMAND@@ZZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\game\scripting.cpp
;	COMDAT ?ExecuteScriptBuf@@YAHXZ
_TEXT	SEGMENT
?ExecuteScriptBuf@@YAHXZ PROC				; ExecuteScriptBuf, COMDAT

; 25   : 	__asm
; 26   : 	{
; 27   : 		mov bScmLocalDebug, 1;

	mov	DWORD PTR ?bScmLocalDebug@@3HA, 1	; bScmLocalDebug

; 28   : 
; 29   : 		mov eax, OFFSET ScriptBuf	// Move our script buffer base into eax.

	mov	eax, OFFSET ?ScriptBuf@@3PAEA

; 30   : 
; 31   : 		mov ecx, gst				// Move GAME_SCRIPT_THREAD structure into ecx.

	mov	ecx, DWORD PTR ?gst@@3PAUGAME_SCRIPT_THREAD@@A ; gst

; 32   : 		mov [ecx+0x14], eax			// Move eax into the gst->dwScriptIP.

	mov	DWORD PTR [ecx+20], eax

; 33   : 
; 34   : 		call ProcessOneCommand		// Call the game's script opcode processor.

	call	DWORD PTR ?ProcessOneCommand@@3P6GHXZA	; ProcessOneCommand

; 35   : 
; 36   : 		mov ecx, gst				// Move game script thread into ecx again.

	mov	ecx, DWORD PTR ?gst@@3PAUGAME_SCRIPT_THREAD@@A ; gst

; 37   : 		mov eax, [ecx+0xC5]			// Move the dwIfFlag into eax (return value).

	mov	eax, DWORD PTR [ecx+197]

; 38   : 
; 39   : 		mov bScmLocalDebug, 0;

	mov	DWORD PTR ?bScmLocalDebug@@3HA, 0	; bScmLocalDebug

; 40   : 
; 41   : 		ret							// return.

	ret	0
?ExecuteScriptBuf@@YAHXZ ENDP				; ExecuteScriptBuf
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\game\scripting.cpp
;	COMDAT ?ScriptCommand@@YAHPBUSCRIPT_COMMAND@@ZZ
_TEXT	SEGMENT
tv205 = -368						; size = 4
tv80 = -368						; size = 4
$T2 = -360						; size = 4
_i$3 = -156						; size = 4
_result$ = -144						; size = 4
_aLen$4 = -129						; size = 1
_sz$5 = -120						; size = 4
_v$6 = -108						; size = 4
_f$7 = -96						; size = 4
_i$8 = -84						; size = 4
_i$9 = -72						; size = 4
_var_pos$ = -60						; size = 2
_buf_pos$ = -48						; size = 4
_p$ = -36						; size = 4
_ap$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
_pScriptCommand$ = 8					; size = 4
?ScriptCommand@@YAHPBUSCRIPT_COMMAND@@ZZ PROC		; ScriptCommand, COMDAT

; 47   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ScriptCommand@@YAHPBUSCRIPT_COMMAND@@ZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 352				; 00000160H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-368]
	mov	ecx, 88					; 00000058H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 48   : 	va_list ap;
; 49   : 	const char* p = pScriptCommand->Params;	// Get parameter string.

	mov	eax, DWORD PTR _pScriptCommand$[ebp]
	add	eax, 2
	mov	DWORD PTR _p$[ebp], eax

; 50   : 	va_start(ap, pScriptCommand);			// Initialize varargs.

	lea	eax, DWORD PTR _pScriptCommand$[ebp+4]
	mov	DWORD PTR _ap$[ebp], eax

; 51   : 	memcpy(&ScriptBuf, &pScriptCommand->OpCode, 2);	// Copy opcode to script buf.

	push	2
	mov	eax, DWORD PTR _pScriptCommand$[ebp]
	push	eax
	push	OFFSET ?ScriptBuf@@3PAEA		; ScriptBuf
	call	_memcpy
	add	esp, 12					; 0000000cH

; 52   : 	int buf_pos = 2;	// Position in buffer after opcode.

	mov	DWORD PTR _buf_pos$[ebp], 2

; 53   : 	WORD var_pos = 0;	// Init var_pos.

	xor	eax, eax
	mov	WORD PTR _var_pos$[ebp], ax

; 54   : 	
; 55   : 	// (aru) Reset all vars before proceeding (To fix some nasty 0x00465CB4 crashes)
; 56   : 	// May cause problems with functions that use local vars returned from previous calls
; 57   : 	
; 58   : 	for(int i=0; i<18; i++)

	mov	DWORD PTR _i$9[ebp], 0
	jmp	SHORT $LN19@ScriptComm
$LN18@ScriptComm:
	mov	eax, DWORD PTR _i$9[ebp]
	add	eax, 1
	mov	DWORD PTR _i$9[ebp], eax
$LN19@ScriptComm:
	cmp	DWORD PTR _i$9[ebp], 18			; 00000012H
	jge	SHORT $LN17@ScriptComm

; 59   : 		gst->dwLocalVar[i] = 0;

	mov	eax, DWORD PTR _i$9[ebp]
	mov	ecx, DWORD PTR ?gst@@3PAUGAME_SCRIPT_THREAD@@A ; gst
	mov	DWORD PTR [ecx+eax*4+60], 0
	jmp	SHORT $LN18@ScriptComm
$LN17@ScriptComm:

; 60   : 
; 61   : 	dwScmOpcodeDebug = pScriptCommand->OpCode;

	mov	eax, DWORD PTR _pScriptCommand$[ebp]
	movzx	ecx, WORD PTR [eax]
	mov	DWORD PTR ?dwScmOpcodeDebug@@3KA, ecx	; dwScmOpcodeDebug
$LN16@ScriptComm:

; 62   : 
; 63   : 	while(*p)			// While we've not ran out of parameters...

	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN15@ScriptComm

; 64   : 	{
; 65   : 		switch(*p)		// Switch current parameter.

	mov	eax, DWORD PTR _p$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv80[ebp], ecx
	mov	edx, DWORD PTR tv80[ebp]
	sub	edx, 102				; 00000066H
	mov	DWORD PTR tv80[ebp], edx
	cmp	DWORD PTR tv80[ebp], 20			; 00000014H
	ja	$LN7@ScriptComm
	mov	eax, DWORD PTR tv80[ebp]
	movzx	ecx, BYTE PTR $LN28@ScriptComm[eax]
	jmp	DWORD PTR $LN35@ScriptComm[ecx*4]
$LN12@ScriptComm:

; 66   : 		{
; 67   : 			case 'i':	// If integer...
; 68   : 			{
; 69   : 				int i = va_arg(ap, int);			// Grab an int off the stack.

	mov	eax, DWORD PTR _ap$[ebp]
	add	eax, 4
	mov	DWORD PTR _ap$[ebp], eax
	mov	ecx, DWORD PTR _ap$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	mov	DWORD PTR _i$8[ebp], edx

; 70   : 				ScriptBuf[buf_pos] = 0x01;			// Variable data type = 0x01 (4b int).

	mov	eax, DWORD PTR _buf_pos$[ebp]
	mov	BYTE PTR ?ScriptBuf@@3PAEA[eax], 1

; 71   : 				buf_pos++;;							// Increment buffer position.

	mov	eax, DWORD PTR _buf_pos$[ebp]
	add	eax, 1
	mov	DWORD PTR _buf_pos$[ebp], eax

; 72   : 				memcpy(&ScriptBuf[buf_pos], &i, 4);	// Insert the int.

	push	4
	lea	eax, DWORD PTR _i$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf_pos$[ebp]
	add	ecx, OFFSET ?ScriptBuf@@3PAEA		; ScriptBuf
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 73   : 				buf_pos += 4;						// Increment buffer by 4b.

	mov	eax, DWORD PTR _buf_pos$[ebp]
	add	eax, 4
	mov	DWORD PTR _buf_pos$[ebp], eax

; 74   : 				break;

	jmp	$LN13@ScriptComm
$LN11@ScriptComm:

; 75   : 			}
; 76   : 			case 'f':	// If float...
; 77   : 			{
; 78   : 				/*	Take note, MSVC++ puts a double on the stack
; 79   : 					even if you typecase as a float. <3 Microsoft.	*/
; 80   : 				float f = (float)va_arg(ap, double);	// Get float off the stack.

	mov	eax, DWORD PTR _ap$[ebp]
	add	eax, 8
	mov	DWORD PTR _ap$[ebp], eax
	mov	ecx, DWORD PTR _ap$[ebp]
	movsd	xmm0, QWORD PTR [ecx-8]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _f$7[ebp], xmm0

; 81   : 				ScriptBuf[buf_pos] = 0x06;				// Variable data type = 0x06 (float).

	mov	eax, DWORD PTR _buf_pos$[ebp]
	mov	BYTE PTR ?ScriptBuf@@3PAEA[eax], 6

; 82   : 				buf_pos++;								// Increment buffer position.

	mov	eax, DWORD PTR _buf_pos$[ebp]
	add	eax, 1
	mov	DWORD PTR _buf_pos$[ebp], eax

; 83   : 				memcpy(&ScriptBuf[buf_pos], &f, 4);		// Copy float into script buf.

	push	4
	lea	eax, DWORD PTR _f$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf_pos$[ebp]
	add	ecx, OFFSET ?ScriptBuf@@3PAEA		; ScriptBuf
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 84   : 				buf_pos += 4;							// Increment buffer by 4b.

	mov	eax, DWORD PTR _buf_pos$[ebp]
	add	eax, 4
	mov	DWORD PTR _buf_pos$[ebp], eax

; 85   : 				break;

	jmp	$LN13@ScriptComm
$LN10@ScriptComm:

; 86   : 			}
; 87   : 			case 'v':	// If variable...
; 88   : 			{
; 89   : 				DWORD* v = va_arg(ap, DWORD*);				// Get the pointer to the passed variable.

	mov	eax, DWORD PTR _ap$[ebp]
	add	eax, 4
	mov	DWORD PTR _ap$[ebp], eax
	mov	ecx, DWORD PTR _ap$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	mov	DWORD PTR _v$6[ebp], edx

; 90   : 				ScriptBuf[buf_pos] = 0x03;					// Variable data type = 0x03 (Local Var).

	mov	eax, DWORD PTR _buf_pos$[ebp]
	mov	BYTE PTR ?ScriptBuf@@3PAEA[eax], 3

; 91   : 				buf_pos++;									// Increment buffer position.

	mov	eax, DWORD PTR _buf_pos$[ebp]
	add	eax, 1
	mov	DWORD PTR _buf_pos$[ebp], eax

; 92   : 				pdwParamVars[var_pos] = v;					// Save pointer to passed variable.

	movzx	eax, WORD PTR _var_pos$[ebp]
	mov	ecx, DWORD PTR _v$6[ebp]
	mov	DWORD PTR ?pdwParamVars@@3PAPAKA[eax*4], ecx

; 93   : 				gst->dwLocalVar[var_pos] = *v;				// Put value of passed variable into local.

	movzx	eax, WORD PTR _var_pos$[ebp]
	mov	ecx, DWORD PTR ?gst@@3PAUGAME_SCRIPT_THREAD@@A ; gst
	mov	edx, DWORD PTR _v$6[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+eax*4+60], edx

; 94   : 				memcpy(&ScriptBuf[buf_pos], &var_pos, 2);	// Copy the offset into the script.

	push	2
	lea	eax, DWORD PTR _var_pos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buf_pos$[ebp]
	add	ecx, OFFSET ?ScriptBuf@@3PAEA		; ScriptBuf
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 95   : 				buf_pos += 2;								// Increment buffer by 2b.

	mov	eax, DWORD PTR _buf_pos$[ebp]
	add	eax, 2
	mov	DWORD PTR _buf_pos$[ebp], eax

; 96   : 				var_pos++;									// Increment the variable position.

	mov	ax, WORD PTR _var_pos$[ebp]
	add	ax, 1
	mov	WORD PTR _var_pos$[ebp], ax

; 97   : 				break;

	jmp	$LN13@ScriptComm
$LN9@ScriptComm:

; 98   : 			}
; 99   : 			case 's':	// If string... Updated 13th Jan 06.. (kyeman) SA string support
; 100  : 			{
; 101  : 				char* sz = va_arg(ap, char*);

	mov	eax, DWORD PTR _ap$[ebp]
	add	eax, 4
	mov	DWORD PTR _ap$[ebp], eax
	mov	ecx, DWORD PTR _ap$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	mov	DWORD PTR _sz$5[ebp], edx

; 102  : 				unsigned char aLen = strlen(sz);

	mov	eax, DWORD PTR _sz$5[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	BYTE PTR _aLen$4[ebp], al

; 103  : 				ScriptBuf[buf_pos] = 0x0E;

	mov	eax, DWORD PTR _buf_pos$[ebp]
	mov	BYTE PTR ?ScriptBuf@@3PAEA[eax], 14	; 0000000eH

; 104  : 				buf_pos++;

	mov	eax, DWORD PTR _buf_pos$[ebp]
	add	eax, 1
	mov	DWORD PTR _buf_pos$[ebp], eax

; 105  : 				ScriptBuf[buf_pos] = aLen;

	mov	eax, DWORD PTR _buf_pos$[ebp]
	mov	cl, BYTE PTR _aLen$4[ebp]
	mov	BYTE PTR ?ScriptBuf@@3PAEA[eax], cl

; 106  : 				buf_pos++;

	mov	eax, DWORD PTR _buf_pos$[ebp]
	add	eax, 1
	mov	DWORD PTR _buf_pos$[ebp], eax

; 107  : 				memcpy(&ScriptBuf[buf_pos],sz,aLen);				

	movzx	eax, BYTE PTR _aLen$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _sz$5[ebp]
	push	ecx
	mov	edx, DWORD PTR _buf_pos$[ebp]
	add	edx, OFFSET ?ScriptBuf@@3PAEA		; ScriptBuf
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 108  : 				buf_pos += aLen;

	movzx	eax, BYTE PTR _aLen$4[ebp]
	add	eax, DWORD PTR _buf_pos$[ebp]
	mov	DWORD PTR _buf_pos$[ebp], eax

; 109  : 				break;

	jmp	SHORT $LN13@ScriptComm
$LN8@ScriptComm:

; 110  : 			}
; 111  : 			case 'z':	// If the params need zero-terminating...
; 112  : 			{
; 113  : 				ScriptBuf[buf_pos] = 0x00;			

	mov	eax, DWORD PTR _buf_pos$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	cmp	DWORD PTR $T2[ebp], 255			; 000000ffH
	jae	SHORT $LN22@ScriptComm
	jmp	SHORT $LN23@ScriptComm
$LN22@ScriptComm:
	call	___report_rangecheckfailure
$LN23@ScriptComm:
	mov	ecx, DWORD PTR $T2[ebp]
	mov	BYTE PTR ?ScriptBuf@@3PAEA[ecx], 0

; 114  : 				buf_pos++;

	mov	eax, DWORD PTR _buf_pos$[ebp]
	add	eax, 1
	mov	DWORD PTR _buf_pos$[ebp], eax

; 115  : 				break;

	jmp	SHORT $LN13@ScriptComm
$LN7@ScriptComm:

; 116  : 			}
; 117  : 			default:
; 118  : 			{
; 119  : 				return 0;

	xor	eax, eax
	jmp	$LN20@ScriptComm
$LN13@ScriptComm:

; 120  : 			}
; 121  : 		}
; 122  : 		++p;		// Next parameter

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
	mov	DWORD PTR _p$[ebp], eax

; 123  : 	}

	jmp	$LN16@ScriptComm
$LN15@ScriptComm:

; 124  : 	va_end(ap);		// End varargs.

	mov	DWORD PTR _ap$[ebp], 0

; 125  : 
; 126  : 	// Execute script stub.
; 127  : 	int result =0;

	mov	DWORD PTR _result$[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 128  : 	
; 129  : 	try {
; 130  : 
; 131  : 		// Enable SCM
; 132  : 		*(PBYTE)0x469EF5 = 0xFF;

	mov	BYTE PTR ds:4628213, 255		; 000000ffH

; 133  : 		*(PBYTE)0x469EF6 = 0xD2;

	mov	BYTE PTR ds:4628214, 210		; 000000d2H

; 134  : 
; 135  : 		result = ExecuteScriptBuf();

	call	?ExecuteScriptBuf@@YAHXZ		; ExecuteScriptBuf
	mov	DWORD PTR tv205[ebp], eax
	mov	eax, DWORD PTR tv205[ebp]
	mov	DWORD PTR _result$[ebp], eax

; 136  : 		if (var_pos)	// if we've used a variable...

	movzx	eax, WORD PTR _var_pos$[ebp]
	test	eax, eax
	je	SHORT $LN2@ScriptComm

; 137  : 		{
; 138  : 			for (int i=0; i<var_pos; i++)		// For every passed variable...

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN4@ScriptComm
$LN3@ScriptComm:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN4@ScriptComm:
	movzx	eax, WORD PTR _var_pos$[ebp]
	cmp	DWORD PTR _i$3[ebp], eax
	jge	SHORT $LN2@ScriptComm

; 139  : 			{
; 140  : 				*pdwParamVars[i] = gst->dwLocalVar[i];	// Retrieve variable from local var.

	mov	eax, DWORD PTR _i$3[ebp]
	mov	ecx, DWORD PTR ?pdwParamVars@@3PAPAKA[eax*4]
	mov	edx, DWORD PTR _i$3[ebp]
	mov	eax, DWORD PTR ?gst@@3PAUGAME_SCRIPT_THREAD@@A ; gst
	mov	edx, DWORD PTR [eax+edx*4+60]
	mov	DWORD PTR [ecx], edx

; 141  : 			}

	jmp	SHORT $LN3@ScriptComm
$LN2@ScriptComm:

; 142  : 		}
; 143  : 
; 144  : 		// Disable SCM
; 145  : 		*(PBYTE)0x469EF5 = 0x8B;

	mov	BYTE PTR ds:4628213, 139		; 0000008bH

; 146  : 		*(PBYTE)0x469EF6 = 0xD0;

	mov	BYTE PTR ds:4628214, 208		; 000000d0H
	jmp	SHORT $LN24@ScriptComm
__catch$?ScriptCommand@@YAHPBUSCRIPT_COMMAND@@ZZ$0:

; 147  : 
; 148  : 	} catch(...) {
; 149  : 		if(pChatWindow && !bExceptionDisplayed) {

	cmp	DWORD PTR ?pChatWindow@@3PAVCChatWindow@@A, 0 ; pChatWindow
	je	SHORT $LN1@ScriptComm
	cmp	DWORD PTR ?bExceptionDisplayed@@3HA, 0	; bExceptionDisplayed
	jne	SHORT $LN1@ScriptComm

; 150  : 			pChatWindow->AddDebugMessage("Warning: error using opcode: 0x%X",pScriptCommand->OpCode);

	mov	eax, DWORD PTR _pScriptCommand$[ebp]
	movzx	ecx, WORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_0CC@MGOBGFLO@Warning?3?5error?5using?5opcode?3?50x?$CF@
	mov	edx, DWORD PTR ?pChatWindow@@3PAVCChatWindow@@A ; pChatWindow
	push	edx
	call	?AddDebugMessage@CChatWindow@@QAAXPADZZ	; CChatWindow::AddDebugMessage
	add	esp, 12					; 0000000cH

; 151  : 			bExceptionDisplayed = TRUE;

	mov	DWORD PTR ?bExceptionDisplayed@@3HA, 1	; bExceptionDisplayed
$LN1@ScriptComm:

; 152  : 		}
; 153  : 	}

	mov	eax, $LN27@ScriptComm
	ret	0
$LN24@ScriptComm:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT $LN26@ScriptComm
$LN27@ScriptComm:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN26@ScriptComm:

; 154  : 
; 155  : 
; 156  : 	return result;

	mov	eax, DWORD PTR _result$[ebp]
$LN20@ScriptComm:

; 157  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN34@ScriptComm
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 368				; 00000170H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN34@ScriptComm:
	DD	3
	DD	$LN33@ScriptComm
$LN33@ScriptComm:
	DD	-60					; ffffffc4H
	DD	2
	DD	$LN29@ScriptComm
	DD	-84					; ffffffacH
	DD	4
	DD	$LN30@ScriptComm
	DD	-96					; ffffffa0H
	DD	4
	DD	$LN31@ScriptComm
$LN31@ScriptComm:
	DB	102					; 00000066H
	DB	0
$LN30@ScriptComm:
	DB	105					; 00000069H
	DB	0
$LN29@ScriptComm:
	DB	118					; 00000076H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	95					; 0000005fH
	DB	112					; 00000070H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	0
$LN35@ScriptComm:
	DD	$LN11@ScriptComm
	DD	$LN12@ScriptComm
	DD	$LN9@ScriptComm
	DD	$LN10@ScriptComm
	DD	$LN8@ScriptComm
	DD	$LN7@ScriptComm
$LN28@ScriptComm:
	DB	0
	DB	5
	DB	5
	DB	1
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	2
	DB	5
	DB	5
	DB	3
	DB	5
	DB	5
	DB	5
	DB	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?ScriptCommand@@YAHPBUSCRIPT_COMMAND@@ZZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-372]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ScriptCommand@@YAHPBUSCRIPT_COMMAND@@ZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ScriptCommand@@YAHPBUSCRIPT_COMMAND@@ZZ ENDP		; ScriptCommand
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\game\scripting.cpp
;	COMDAT ?InitScripting@@YAXXZ
_TEXT	SEGMENT
$T1 = -200						; size = 4
?InitScripting@@YAXXZ PROC				; InitScripting, COMDAT

; 161  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 162  : 	gst = new GAME_SCRIPT_THREAD;

	push	224					; 000000e0H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR ?gst@@3PAUGAME_SCRIPT_THREAD@@A, eax ; gst

; 163  : 	ZeroMemory(gst, sizeof(GAME_SCRIPT_THREAD));

	push	224					; 000000e0H
	push	0
	mov	eax, DWORD PTR ?gst@@3PAUGAME_SCRIPT_THREAD@@A ; gst
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 164  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?InitScripting@@YAXXZ ENDP				; InitScripting
_TEXT	ENDS
END
