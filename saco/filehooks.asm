; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.31101.0 

	TITLE	Z:\sampsrc\02Xu1\saco\filehooks.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?dwCaller@@3KA					; dwCaller
PUBLIC	?dbgmsg@@3PADA					; dbgmsg
PUBLIC	?Real_GetFileSize@@3P6GKPAXPAK@ZA		; Real_GetFileSize
PUBLIC	?Real_SetFilePointer@@3P6GKPAXJPAJK@ZA		; Real_SetFilePointer
PUBLIC	?Real_CreateFileA@@3P6GPAXPBDKKPAU_SECURITY_ATTRIBUTES@@KKPAX@ZA ; Real_CreateFileA
PUBLIC	?Real_CreateFileW@@3P6GPAXPAGKKPAU_SECURITY_ATTRIBUTES@@KKPAX@ZA ; Real_CreateFileW
PUBLIC	?Real_ReadFile@@3P6GHPAX0KPAKPAU_OVERLAPPED@@@ZA ; Real_ReadFile
PUBLIC	?Real_CloseHandle@@3P6GHPAX@ZA			; Real_CloseHandle
PUBLIC	?Real_GetFileType@@3P6GKPAX@ZA			; Real_GetFileType
PUBLIC	?Real_GetAsyncKeyState@@3P6GFH@ZA		; Real_GetAsyncKeyState
PUBLIC	?Real_GetModuleHandleA@@3P6GPAUHINSTANCE__@@PBD@ZA ; Real_GetModuleHandleA
PUBLIC	?OpenArchRecords@@3PAU_ARCH_FILE_RECORD@@A	; OpenArchRecords
PUBLIC	?bArchRecordSlotState@@3PAHA			; bArchRecordSlotState
PUBLIC	?bFileHooksInstalled@@3HA			; bFileHooksInstalled
PUBLIC	?iCustomHandle@@3HA				; iCustomHandle
_BSS	SEGMENT
?dwCaller@@3KA DD 01H DUP (?)				; dwCaller
?dbgmsg@@3PADA DB 0100H DUP (?)				; dbgmsg
?Real_GetFileSize@@3P6GKPAXPAK@ZA DD 01H DUP (?)	; Real_GetFileSize
?Real_SetFilePointer@@3P6GKPAXJPAJK@ZA DD 01H DUP (?)	; Real_SetFilePointer
?Real_CreateFileA@@3P6GPAXPBDKKPAU_SECURITY_ATTRIBUTES@@KKPAX@ZA DD 01H DUP (?) ; Real_CreateFileA
?Real_CreateFileW@@3P6GPAXPAGKKPAU_SECURITY_ATTRIBUTES@@KKPAX@ZA DD 01H DUP (?) ; Real_CreateFileW
?Real_ReadFile@@3P6GHPAX0KPAKPAU_OVERLAPPED@@@ZA DD 01H DUP (?) ; Real_ReadFile
?Real_CloseHandle@@3P6GHPAX@ZA DD 01H DUP (?)		; Real_CloseHandle
?Real_GetFileType@@3P6GKPAX@ZA DD 01H DUP (?)		; Real_GetFileType
?Real_GetAsyncKeyState@@3P6GFH@ZA DD 01H DUP (?)	; Real_GetAsyncKeyState
?Real_GetModuleHandleA@@3P6GPAUHINSTANCE__@@PBD@ZA DD 01H DUP (?) ; Real_GetModuleHandleA
?OpenArchRecords@@3PAU_ARCH_FILE_RECORD@@A DB 03e8H DUP (?) ; OpenArchRecords
?bArchRecordSlotState@@3PAHA DD 032H DUP (?)		; bArchRecordSlotState
?bFileHooksInstalled@@3HA DD 01H DUP (?)		; bFileHooksInstalled
_BSS	ENDS
_DATA	SEGMENT
?iCustomHandle@@3HA DD 0ff000001H			; iCustomHandle
_DATA	ENDS
PUBLIC	?InstallFileSystemHooks@@YAXXZ			; InstallFileSystemHooks
PUBLIC	?UninstallFileSystemHooks@@YAXXZ		; UninstallFileSystemHooks
PUBLIC	?FileNameOnly@@YAPADPAD@Z			; FileNameOnly
PUBLIC	?ExtensionOnly@@YAPADPAD@Z			; ExtensionOnly
PUBLIC	?strtolower@@YAPADPAD@Z				; strtolower
PUBLIC	?IsCustomFileHandle@@YAHK@Z			; IsCustomFileHandle
PUBLIC	?FindUnusedArchRecordIndex@@YAHXZ		; FindUnusedArchRecordIndex
PUBLIC	?FindArchRecordIndexFromHandle@@YAHPAX@Z	; FindArchRecordIndexFromHandle
PUBLIC	?CreateArchRecord@@YAPAXK@Z			; CreateArchRecord
PUBLIC	?Arch_CreateFileA@@YGPAXPBDKKPAU_SECURITY_ATTRIBUTES@@KKPAX@Z ; Arch_CreateFileA
PUBLIC	?Arch_CreateFileW@@YGPAXPAGKKPAU_SECURITY_ATTRIBUTES@@KKPAX@Z ; Arch_CreateFileW
PUBLIC	?Arch_ReadFile@@YGHPAX0KPAKPAU_OVERLAPPED@@@Z	; Arch_ReadFile
PUBLIC	?Arch_GetFileSize@@YGKPAXPAK@Z			; Arch_GetFileSize
PUBLIC	?Arch_SetFilePointer@@YGKPAXJPAJK@Z		; Arch_SetFilePointer
PUBLIC	?Arch_CloseHandle@@YGHPAX@Z			; Arch_CloseHandle
PUBLIC	?Arch_GetFileType@@YGKPAX@Z			; Arch_GetFileType
PUBLIC	?Arch_GetAsyncKeyState@@YGFH@Z			; Arch_GetAsyncKeyState
PUBLIC	?Arch_GetModuleHandleA@@YGPAUHINSTANCE__@@PBD@Z	; Arch_GetModuleHandleA
PUBLIC	??_C@_0BH@PKIEBAMB@GetAsyncKeyState?$CI0x?$CFX?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BN@CGMCCCO@Installing?5File?5System?5Hooks?$AA@ ; `string'
EXTRN	_tolower:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__OutputDebugStringA@4:PROC
EXTRN	__imp__SetLastError@4:PROC
EXTRN	__imp__SetEvent@4:PROC
EXTRN	_sprintf:PROC
EXTRN	_DetourFunction@8:PROC
EXTRN	_DetourRemove@8:PROC
EXTRN	_DetourFindFunction@8:PROC
EXTRN	?IsCheckableFile@@YAHPAD@Z:PROC			; IsCheckableFile
EXTRN	?CheckFileHash@@YAXHPAX@Z:PROC			; CheckFileHash
EXTRN	?GetFileNameHash@@YAHPAD@Z:PROC			; GetFileNameHash
EXTRN	?K_DecodeString@@YAPADPAE@Z:PROC		; K_DecodeString
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	?pFileSystem@@3PAVCFileSystem@@A:DWORD		; pFileSystem
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0BN@CGMCCCO@Installing?5File?5System?5Hooks?$AA@
CONST	SEGMENT
??_C@_0BN@CGMCCCO@Installing?5File?5System?5Hooks?$AA@ DB 'Installing Fil'
	DB	'e System Hooks', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PKIEBAMB@GetAsyncKeyState?$CI0x?$CFX?$CJ?$AA@
CONST	SEGMENT
??_C@_0BH@PKIEBAMB@GetAsyncKeyState?$CI0x?$CFX?$CJ?$AA@ DB 'GetAsyncKeySt'
	DB	'ate(0x%X)', 00H				; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\filehooks.cpp
;	COMDAT ?Arch_GetModuleHandleA@@YGPAUHINSTANCE__@@PBD@Z
_TEXT	SEGMENT
_lpszModule$ = 8					; size = 4
?Arch_GetModuleHandleA@@YGPAUHINSTANCE__@@PBD@Z PROC	; Arch_GetModuleHandleA, COMDAT

; 353  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 354  : 	//sprintf(dbgmsg,"GetModuleHandleA(%s)",lpszModule);
; 355  : 	//OutputDebugString(dbgmsg);
; 356  : 
; 357  : 	if( lpszModule && strlen(lpszModule) == 8 && lpszModule[0] == 's' )

	cmp	DWORD PTR _lpszModule$[ebp], 0
	je	SHORT $LN1@Arch_GetMo
	mov	eax, DWORD PTR _lpszModule$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	cmp	eax, 8
	jne	SHORT $LN1@Arch_GetMo
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpszModule$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 115				; 00000073H
	jne	SHORT $LN1@Arch_GetMo

; 358  : 	{
; 359  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN2@Arch_GetMo
$LN1@Arch_GetMo:

; 360  : 	}
; 361  : 
; 362  :     return Real_GetModuleHandleA(lpszModule);

	mov	esi, esp
	mov	eax, DWORD PTR _lpszModule$[ebp]
	push	eax
	call	DWORD PTR ?Real_GetModuleHandleA@@3P6GPAUHINSTANCE__@@PBD@ZA ; Real_GetModuleHandleA
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Arch_GetMo:

; 363  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Arch_GetModuleHandleA@@YGPAUHINSTANCE__@@PBD@Z ENDP	; Arch_GetModuleHandleA
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\filehooks.cpp
;	COMDAT ?Arch_GetAsyncKeyState@@YGFH@Z
_TEXT	SEGMENT
_hKey$ = 8						; size = 4
?Arch_GetAsyncKeyState@@YGFH@Z PROC			; Arch_GetAsyncKeyState, COMDAT

; 340  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 341  : 	_asm mov eax, [esp]

	mov	eax, DWORD PTR [esp]

; 342  : 	_asm mov dwCaller, eax

	mov	DWORD PTR ?dwCaller@@3KA, eax		; dwCaller

; 343  : 
; 344  : 	sprintf(dbgmsg,"GetAsyncKeyState(0x%X)",dwCaller);

	mov	eax, DWORD PTR ?dwCaller@@3KA		; dwCaller
	push	eax
	push	OFFSET ??_C@_0BH@PKIEBAMB@GetAsyncKeyState?$CI0x?$CFX?$CJ?$AA@
	push	OFFSET ?dbgmsg@@3PADA			; dbgmsg
	call	_sprintf
	add	esp, 12					; 0000000cH

; 345  : 	OutputDebugStringA(dbgmsg);

	mov	esi, esp
	push	OFFSET ?dbgmsg@@3PADA			; dbgmsg
	call	DWORD PTR __imp__OutputDebugStringA@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 346  : 
; 347  : 	return Real_GetAsyncKeyState(hKey);

	mov	esi, esp
	mov	eax, DWORD PTR _hKey$[ebp]
	push	eax
	call	DWORD PTR ?Real_GetAsyncKeyState@@3P6GFH@ZA ; Real_GetAsyncKeyState
	cmp	esi, esp
	call	__RTC_CheckEsp

; 348  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Arch_GetAsyncKeyState@@YGFH@Z ENDP			; Arch_GetAsyncKeyState
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\filehooks.cpp
;	COMDAT ?Arch_GetFileType@@YGKPAX@Z
_TEXT	SEGMENT
_iArch$ = -8						; size = 4
_hFile$ = 8						; size = 4
?Arch_GetFileType@@YGKPAX@Z PROC			; Arch_GetFileType, COMDAT

; 322  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 323  : 	int iArch;
; 324  : 
; 325  : 	if( IsCustomFileHandle((DWORD)hFile) && 
; 326  : 		((iArch = FindArchRecordIndexFromHandle(hFile)) != (-1)))

	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	call	?IsCustomFileHandle@@YAHK@Z		; IsCustomFileHandle
	add	esp, 4
	test	eax, eax
	je	SHORT $LN1@Arch_GetFi
	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	call	?FindArchRecordIndexFromHandle@@YAHPAX@Z ; FindArchRecordIndexFromHandle
	add	esp, 4
	mov	DWORD PTR _iArch$[ebp], eax
	cmp	DWORD PTR _iArch$[ebp], -1
	je	SHORT $LN1@Arch_GetFi

; 327  : 	{
; 328  : 		return FILE_TYPE_DISK;

	mov	eax, 1
	jmp	SHORT $LN2@Arch_GetFi
$LN1@Arch_GetFi:

; 329  : 	}
; 330  : 
; 331  : 	return Real_GetFileType(hFile);

	mov	esi, esp
	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	call	DWORD PTR ?Real_GetFileType@@3P6GKPAX@ZA ; Real_GetFileType
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Arch_GetFi:

; 332  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Arch_GetFileType@@YGKPAX@Z ENDP			; Arch_GetFileType
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\filehooks.cpp
;	COMDAT ?Arch_CloseHandle@@YGHPAX@Z
_TEXT	SEGMENT
_iArch$ = -8						; size = 4
_hObject$ = 8						; size = 4
?Arch_CloseHandle@@YGHPAX@Z PROC			; Arch_CloseHandle, COMDAT

; 306  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 307  : 	int iArch;
; 308  : 
; 309  : 	if( IsCustomFileHandle((DWORD)hObject) && 
; 310  : 		((iArch = FindArchRecordIndexFromHandle(hObject)) != (-1)))

	mov	eax, DWORD PTR _hObject$[ebp]
	push	eax
	call	?IsCustomFileHandle@@YAHK@Z		; IsCustomFileHandle
	add	esp, 4
	test	eax, eax
	je	SHORT $LN1@Arch_Close
	mov	eax, DWORD PTR _hObject$[ebp]
	push	eax
	call	?FindArchRecordIndexFromHandle@@YAHPAX@Z ; FindArchRecordIndexFromHandle
	add	esp, 4
	mov	DWORD PTR _iArch$[ebp], eax
	cmp	DWORD PTR _iArch$[ebp], -1
	je	SHORT $LN1@Arch_Close

; 311  : 	{
; 312  : 		bArchRecordSlotState[iArch] = FALSE;

	mov	eax, DWORD PTR _iArch$[ebp]
	mov	DWORD PTR ?bArchRecordSlotState@@3PAHA[eax*4], 0

; 313  : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $LN2@Arch_Close
$LN1@Arch_Close:

; 314  : 	}
; 315  : 
; 316  : 	return Real_CloseHandle(hObject);

	mov	esi, esp
	mov	eax, DWORD PTR _hObject$[ebp]
	push	eax
	call	DWORD PTR ?Real_CloseHandle@@3P6GHPAX@ZA ; Real_CloseHandle
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Arch_Close:

; 317  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Arch_CloseHandle@@YGHPAX@Z ENDP			; Arch_CloseHandle
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\filehooks.cpp
;	COMDAT ?Arch_SetFilePointer@@YGKPAXJPAJK@Z
_TEXT	SEGMENT
_iArch$ = -8						; size = 4
_hFile$ = 8						; size = 4
_lDistanceToMove$ = 12					; size = 4
_lpDistanceToMoveHigh$ = 16				; size = 4
_dwMoveMethod$ = 20					; size = 4
?Arch_SetFilePointer@@YGKPAXJPAJK@Z PROC		; Arch_SetFilePointer, COMDAT

; 275  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 276  : 	int iArch;
; 277  : 
; 278  : 	if( IsCustomFileHandle((DWORD)hFile) && 
; 279  : 		((iArch = FindArchRecordIndexFromHandle(hFile)) != (-1)))

	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	call	?IsCustomFileHandle@@YAHK@Z		; IsCustomFileHandle
	add	esp, 4
	test	eax, eax
	je	$LN6@Arch_SetFi
	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	call	?FindArchRecordIndexFromHandle@@YAHPAX@Z ; FindArchRecordIndexFromHandle
	add	esp, 4
	mov	DWORD PTR _iArch$[ebp], eax
	cmp	DWORD PTR _iArch$[ebp], -1
	je	$LN6@Arch_SetFi

; 280  : 	{
; 281  : 		//char s[256];
; 282  : 		//sprintf(s,"SetFilePointer(0x%X)",hFile);
; 283  : 		//OutputDebugString(s);
; 284  : 
; 285  : 		if(dwMoveMethod ==  FILE_BEGIN) {

	cmp	DWORD PTR _dwMoveMethod$[ebp], 0
	jne	SHORT $LN5@Arch_SetFi

; 286  : 			OpenArchRecords[iArch].dwReadPosition = lDistanceToMove;

	imul	eax, DWORD PTR _iArch$[ebp], 20
	mov	ecx, DWORD PTR _lDistanceToMove$[ebp]
	mov	DWORD PTR ?OpenArchRecords@@3PAU_ARCH_FILE_RECORD@@A[eax+4], ecx

; 287  : 			OpenArchRecords[iArch].pbyteDataCurrent = OpenArchRecords[iArch].pbyteDataStart + lDistanceToMove;

	imul	eax, DWORD PTR _iArch$[ebp], 20
	mov	ecx, DWORD PTR ?OpenArchRecords@@3PAU_ARCH_FILE_RECORD@@A[eax+12]
	add	ecx, DWORD PTR _lDistanceToMove$[ebp]
	imul	edx, DWORD PTR _iArch$[ebp], 20
	mov	DWORD PTR ?OpenArchRecords@@3PAU_ARCH_FILE_RECORD@@A[edx+16], ecx
	jmp	SHORT $LN4@Arch_SetFi
$LN5@Arch_SetFi:

; 288  : 		}
; 289  : 		else if(dwMoveMethod == FILE_CURRENT) {

	cmp	DWORD PTR _dwMoveMethod$[ebp], 1
	jne	SHORT $LN3@Arch_SetFi

; 290  : 			OpenArchRecords[iArch].dwReadPosition += lDistanceToMove;

	imul	eax, DWORD PTR _iArch$[ebp], 20
	mov	ecx, DWORD PTR ?OpenArchRecords@@3PAU_ARCH_FILE_RECORD@@A[eax+4]
	add	ecx, DWORD PTR _lDistanceToMove$[ebp]
	imul	edx, DWORD PTR _iArch$[ebp], 20
	mov	DWORD PTR ?OpenArchRecords@@3PAU_ARCH_FILE_RECORD@@A[edx+4], ecx

; 291  : 			OpenArchRecords[iArch].pbyteDataCurrent += lDistanceToMove;

	imul	eax, DWORD PTR _iArch$[ebp], 20
	mov	ecx, DWORD PTR ?OpenArchRecords@@3PAU_ARCH_FILE_RECORD@@A[eax+16]
	add	ecx, DWORD PTR _lDistanceToMove$[ebp]
	imul	edx, DWORD PTR _iArch$[ebp], 20
	mov	DWORD PTR ?OpenArchRecords@@3PAU_ARCH_FILE_RECORD@@A[edx+16], ecx
	jmp	SHORT $LN4@Arch_SetFi
$LN3@Arch_SetFi:

; 292  : 		}
; 293  : 		else if(dwMoveMethod == FILE_END) {

	cmp	DWORD PTR _dwMoveMethod$[ebp], 2
	jne	SHORT $LN4@Arch_SetFi

; 294  : 			OpenArchRecords[iArch].dwReadPosition = OpenArchRecords[iArch].dwFileSize;

	imul	eax, DWORD PTR _iArch$[ebp], 20
	imul	ecx, DWORD PTR _iArch$[ebp], 20
	mov	edx, DWORD PTR ?OpenArchRecords@@3PAU_ARCH_FILE_RECORD@@A[eax+8]
	mov	DWORD PTR ?OpenArchRecords@@3PAU_ARCH_FILE_RECORD@@A[ecx+4], edx

; 295  : 			OpenArchRecords[iArch].pbyteDataCurrent = 
; 296  : 				OpenArchRecords[iArch].pbyteDataStart + OpenArchRecords[iArch].dwFileSize;

	imul	eax, DWORD PTR _iArch$[ebp], 20
	imul	ecx, DWORD PTR _iArch$[ebp], 20
	mov	edx, DWORD PTR ?OpenArchRecords@@3PAU_ARCH_FILE_RECORD@@A[eax+12]
	add	edx, DWORD PTR ?OpenArchRecords@@3PAU_ARCH_FILE_RECORD@@A[ecx+8]
	imul	eax, DWORD PTR _iArch$[ebp], 20
	mov	DWORD PTR ?OpenArchRecords@@3PAU_ARCH_FILE_RECORD@@A[eax+16], edx
$LN4@Arch_SetFi:

; 297  : 		}
; 298  : 		return OpenArchRecords[iArch].dwReadPosition;

	imul	eax, DWORD PTR _iArch$[ebp], 20
	mov	eax, DWORD PTR ?OpenArchRecords@@3PAU_ARCH_FILE_RECORD@@A[eax+4]
	jmp	SHORT $LN7@Arch_SetFi
$LN6@Arch_SetFi:

; 299  : 	}
; 300  : 	return Real_SetFilePointer(hFile,lDistanceToMove,lpDistanceToMoveHigh,dwMoveMethod);

	mov	esi, esp
	mov	eax, DWORD PTR _dwMoveMethod$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDistanceToMoveHigh$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lDistanceToMove$[ebp]
	push	edx
	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	call	DWORD PTR ?Real_SetFilePointer@@3P6GKPAXJPAJK@ZA ; Real_SetFilePointer
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@Arch_SetFi:

; 301  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Arch_SetFilePointer@@YGKPAXJPAJK@Z ENDP		; Arch_SetFilePointer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\filehooks.cpp
;	COMDAT ?Arch_GetFileSize@@YGKPAXPAK@Z
_TEXT	SEGMENT
_iArch$ = -8						; size = 4
_hFile$ = 8						; size = 4
_pdwSize$ = 12						; size = 4
?Arch_GetFileSize@@YGKPAXPAK@Z PROC			; Arch_GetFileSize, COMDAT

; 254  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 255  : 	int iArch;
; 256  : 
; 257  : 	if( IsCustomFileHandle((DWORD)hFile) && 
; 258  : 		((iArch = FindArchRecordIndexFromHandle(hFile)) != (-1)))

	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	call	?IsCustomFileHandle@@YAHK@Z		; IsCustomFileHandle
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@Arch_GetFi
	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	call	?FindArchRecordIndexFromHandle@@YAHPAX@Z ; FindArchRecordIndexFromHandle
	add	esp, 4
	mov	DWORD PTR _iArch$[ebp], eax
	cmp	DWORD PTR _iArch$[ebp], -1
	je	SHORT $LN2@Arch_GetFi

; 259  : 	{
; 260  : 		//char s[256];
; 261  : 		//sprintf(s,"GetFileSize(0x%X)",hFile);
; 262  : 		//OutputDebugString(s);
; 263  : 
; 264  : 		if (pdwSize)

	cmp	DWORD PTR _pdwSize$[ebp], 0
	je	SHORT $LN1@Arch_GetFi

; 265  : 			*pdwSize = 0;

	mov	eax, DWORD PTR _pdwSize$[ebp]
	mov	DWORD PTR [eax], 0
$LN1@Arch_GetFi:

; 266  : 		return OpenArchRecords[iArch].dwFileSize;

	imul	eax, DWORD PTR _iArch$[ebp], 20
	mov	eax, DWORD PTR ?OpenArchRecords@@3PAU_ARCH_FILE_RECORD@@A[eax+8]
	jmp	SHORT $LN3@Arch_GetFi
$LN2@Arch_GetFi:

; 267  : 	}
; 268  : 	return Real_GetFileSize(hFile,pdwSize);

	mov	esi, esp
	mov	eax, DWORD PTR _pdwSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFile$[ebp]
	push	ecx
	call	DWORD PTR ?Real_GetFileSize@@3P6GKPAXPAK@ZA ; Real_GetFileSize
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Arch_GetFi:

; 269  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?Arch_GetFileSize@@YGKPAXPAK@Z ENDP			; Arch_GetFileSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\filehooks.cpp
;	COMDAT ?Arch_ReadFile@@YGHPAX0KPAKPAU_OVERLAPPED@@@Z
_TEXT	SEGMENT
_dwOverHang$1 = -68					; size = 4
_dwEndPoint$2 = -56					; size = 4
_dwNumBytesRead$3 = -44					; size = 4
_dwFileSize$4 = -32					; size = 4
_hEvent$ = -20						; size = 4
_iArch$ = -8						; size = 4
_hFile$ = 8						; size = 4
_lpBuffer$ = 12						; size = 4
_nNumberOfBytesToRead$ = 16				; size = 4
_lpNumberOfBytesRead$ = 20				; size = 4
_lpOverlapped$ = 24					; size = 4
?Arch_ReadFile@@YGHPAX0KPAKPAU_OVERLAPPED@@@Z PROC	; Arch_ReadFile, COMDAT

; 182  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 183  : 	int iArch=0;

	mov	DWORD PTR _iArch$[ebp], 0

; 184  : 	HANDLE hEvent=0;

	mov	DWORD PTR _hEvent$[ebp], 0

; 185  : 
; 186  : 	if( IsCustomFileHandle((DWORD)hFile) && 
; 187  : 		((iArch = FindArchRecordIndexFromHandle(hFile)) != (-1)))

	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	call	?IsCustomFileHandle@@YAHK@Z		; IsCustomFileHandle
	add	esp, 4
	test	eax, eax
	je	$LN10@Arch_ReadF
	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	call	?FindArchRecordIndexFromHandle@@YAHPAX@Z ; FindArchRecordIndexFromHandle
	add	esp, 4
	mov	DWORD PTR _iArch$[ebp], eax
	cmp	DWORD PTR _iArch$[ebp], -1
	je	$LN10@Arch_ReadF

; 188  : 	{
; 189  : 		//char s[256];
; 190  : 		//sprintf(s,"ReadFile(0x%X)",hFile);
; 191  : 		//OutputDebugString(s);
; 192  : 
; 193  : 		DWORD dwFileSize = OpenArchRecords[iArch].dwFileSize;

	imul	eax, DWORD PTR _iArch$[ebp], 20
	mov	ecx, DWORD PTR ?OpenArchRecords@@3PAU_ARCH_FILE_RECORD@@A[eax+8]
	mov	DWORD PTR _dwFileSize$4[ebp], ecx

; 194  : 		DWORD dwNumBytesRead;
; 195  : 
; 196  : 		if(lpOverlapped) {

	cmp	DWORD PTR _lpOverlapped$[ebp], 0
	je	SHORT $LN9@Arch_ReadF

; 197  : 			OpenArchRecords[iArch].dwReadPosition = lpOverlapped->Offset;

	imul	eax, DWORD PTR _iArch$[ebp], 20
	mov	ecx, DWORD PTR _lpOverlapped$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR ?OpenArchRecords@@3PAU_ARCH_FILE_RECORD@@A[eax+4], edx

; 198  : 			OpenArchRecords[iArch].pbyteDataCurrent =
; 199  : 				OpenArchRecords[iArch].pbyteDataStart + lpOverlapped->Offset;

	imul	eax, DWORD PTR _iArch$[ebp], 20
	mov	ecx, DWORD PTR ?OpenArchRecords@@3PAU_ARCH_FILE_RECORD@@A[eax+12]
	mov	edx, DWORD PTR _lpOverlapped$[ebp]
	add	ecx, DWORD PTR [edx+8]
	imul	eax, DWORD PTR _iArch$[ebp], 20
	mov	DWORD PTR ?OpenArchRecords@@3PAU_ARCH_FILE_RECORD@@A[eax+16], ecx

; 200  : 			hEvent = lpOverlapped->hEvent;

	mov	eax, DWORD PTR _lpOverlapped$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _hEvent$[ebp], ecx
$LN9@Arch_ReadF:

; 201  : 		}
; 202  : 
; 203  : 		// First condition: EOF
; 204  : 		if(OpenArchRecords[iArch].dwReadPosition >= dwFileSize)

	imul	eax, DWORD PTR _iArch$[ebp], 20
	mov	ecx, DWORD PTR ?OpenArchRecords@@3PAU_ARCH_FILE_RECORD@@A[eax+4]
	cmp	ecx, DWORD PTR _dwFileSize$4[ebp]
	jb	SHORT $LN8@Arch_ReadF

; 205  : 		{
; 206  : 			if(lpNumberOfBytesRead)	*lpNumberOfBytesRead = 0;

	cmp	DWORD PTR _lpNumberOfBytesRead$[ebp], 0
	je	SHORT $LN7@Arch_ReadF
	mov	eax, DWORD PTR _lpNumberOfBytesRead$[ebp]
	mov	DWORD PTR [eax], 0
$LN7@Arch_ReadF:

; 207  : 			if(hEvent) SetEvent(hEvent);

	cmp	DWORD PTR _hEvent$[ebp], 0
	je	SHORT $LN6@Arch_ReadF
	mov	esi, esp
	mov	eax, DWORD PTR _hEvent$[ebp]
	push	eax
	call	DWORD PTR __imp__SetEvent@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@Arch_ReadF:

; 208  : 
; 209  : 			SetLastError(ERROR_HANDLE_EOF);

	mov	esi, esp
	push	38					; 00000026H
	call	DWORD PTR __imp__SetLastError@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 210  : 			return TRUE;

	mov	eax, 1
	jmp	$LN11@Arch_ReadF
$LN8@Arch_ReadF:

; 211  : 		}
; 212  : 
; 213  : 		DWORD dwEndPoint = (nNumberOfBytesToRead + OpenArchRecords[iArch].dwReadPosition);

	imul	eax, DWORD PTR _iArch$[ebp], 20
	mov	ecx, DWORD PTR _nNumberOfBytesToRead$[ebp]
	add	ecx, DWORD PTR ?OpenArchRecords@@3PAU_ARCH_FILE_RECORD@@A[eax+4]
	mov	DWORD PTR _dwEndPoint$2[ebp], ecx

; 214  : 				
; 215  : 		// Second condition: Read will exceed or match EOF
; 216  : 		if( dwEndPoint >= dwFileSize ) {

	mov	eax, DWORD PTR _dwEndPoint$2[ebp]
	cmp	eax, DWORD PTR _dwFileSize$4[ebp]
	jb	$LN5@Arch_ReadF

; 217  : 
; 218  : 			DWORD dwOverHang = dwEndPoint - dwFileSize;

	mov	eax, DWORD PTR _dwEndPoint$2[ebp]
	sub	eax, DWORD PTR _dwFileSize$4[ebp]
	mov	DWORD PTR _dwOverHang$1[ebp], eax

; 219  : 			dwNumBytesRead = nNumberOfBytesToRead - dwOverHang;

	mov	eax, DWORD PTR _nNumberOfBytesToRead$[ebp]
	sub	eax, DWORD PTR _dwOverHang$1[ebp]
	mov	DWORD PTR _dwNumBytesRead$3[ebp], eax

; 220  : 	
; 221  : 			memcpy(lpBuffer,OpenArchRecords[iArch].pbyteDataCurrent,dwNumBytesRead);

	mov	eax, DWORD PTR _dwNumBytesRead$3[ebp]
	push	eax
	imul	ecx, DWORD PTR _iArch$[ebp], 20
	mov	edx, DWORD PTR ?OpenArchRecords@@3PAU_ARCH_FILE_RECORD@@A[ecx+16]
	push	edx
	mov	eax, DWORD PTR _lpBuffer$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 222  : 			OpenArchRecords[iArch].pbyteDataCurrent += dwNumBytesRead;

	imul	eax, DWORD PTR _iArch$[ebp], 20
	mov	ecx, DWORD PTR ?OpenArchRecords@@3PAU_ARCH_FILE_RECORD@@A[eax+16]
	add	ecx, DWORD PTR _dwNumBytesRead$3[ebp]
	imul	edx, DWORD PTR _iArch$[ebp], 20
	mov	DWORD PTR ?OpenArchRecords@@3PAU_ARCH_FILE_RECORD@@A[edx+16], ecx

; 223  : 			OpenArchRecords[iArch].dwReadPosition += dwNumBytesRead;

	imul	eax, DWORD PTR _iArch$[ebp], 20
	mov	ecx, DWORD PTR ?OpenArchRecords@@3PAU_ARCH_FILE_RECORD@@A[eax+4]
	add	ecx, DWORD PTR _dwNumBytesRead$3[ebp]
	imul	edx, DWORD PTR _iArch$[ebp], 20
	mov	DWORD PTR ?OpenArchRecords@@3PAU_ARCH_FILE_RECORD@@A[edx+4], ecx

; 224  : 			
; 225  : 			if(lpNumberOfBytesRead) *lpNumberOfBytesRead = dwNumBytesRead;

	cmp	DWORD PTR _lpNumberOfBytesRead$[ebp], 0
	je	SHORT $LN4@Arch_ReadF
	mov	eax, DWORD PTR _lpNumberOfBytesRead$[ebp]
	mov	ecx, DWORD PTR _dwNumBytesRead$3[ebp]
	mov	DWORD PTR [eax], ecx
$LN4@Arch_ReadF:

; 226  : 			if(hEvent) SetEvent(hEvent);

	cmp	DWORD PTR _hEvent$[ebp], 0
	je	SHORT $LN3@Arch_ReadF
	mov	esi, esp
	mov	eax, DWORD PTR _hEvent$[ebp]
	push	eax
	call	DWORD PTR __imp__SetEvent@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Arch_ReadF:

; 227  : 
; 228  : 			SetLastError(ERROR_HANDLE_EOF);

	mov	esi, esp
	push	38					; 00000026H
	call	DWORD PTR __imp__SetLastError@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 229  : 
; 230  : 			return TRUE;

	mov	eax, 1
	jmp	$LN11@Arch_ReadF
$LN5@Arch_ReadF:

; 231  : 		}
; 232  : 		
; 233  : 		// Read will not exceed EOF
; 234  : 		memcpy(lpBuffer,OpenArchRecords[iArch].pbyteDataCurrent,nNumberOfBytesToRead);

	mov	eax, DWORD PTR _nNumberOfBytesToRead$[ebp]
	push	eax
	imul	ecx, DWORD PTR _iArch$[ebp], 20
	mov	edx, DWORD PTR ?OpenArchRecords@@3PAU_ARCH_FILE_RECORD@@A[ecx+16]
	push	edx
	mov	eax, DWORD PTR _lpBuffer$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 235  : 		
; 236  : 		dwNumBytesRead = nNumberOfBytesToRead;

	mov	eax, DWORD PTR _nNumberOfBytesToRead$[ebp]
	mov	DWORD PTR _dwNumBytesRead$3[ebp], eax

; 237  : 		OpenArchRecords[iArch].pbyteDataCurrent += dwNumBytesRead;

	imul	eax, DWORD PTR _iArch$[ebp], 20
	mov	ecx, DWORD PTR ?OpenArchRecords@@3PAU_ARCH_FILE_RECORD@@A[eax+16]
	add	ecx, DWORD PTR _dwNumBytesRead$3[ebp]
	imul	edx, DWORD PTR _iArch$[ebp], 20
	mov	DWORD PTR ?OpenArchRecords@@3PAU_ARCH_FILE_RECORD@@A[edx+16], ecx

; 238  : 		OpenArchRecords[iArch].dwReadPosition += dwNumBytesRead;

	imul	eax, DWORD PTR _iArch$[ebp], 20
	mov	ecx, DWORD PTR ?OpenArchRecords@@3PAU_ARCH_FILE_RECORD@@A[eax+4]
	add	ecx, DWORD PTR _dwNumBytesRead$3[ebp]
	imul	edx, DWORD PTR _iArch$[ebp], 20
	mov	DWORD PTR ?OpenArchRecords@@3PAU_ARCH_FILE_RECORD@@A[edx+4], ecx

; 239  : 		
; 240  : 		if(lpNumberOfBytesRead)	*lpNumberOfBytesRead = dwNumBytesRead;

	cmp	DWORD PTR _lpNumberOfBytesRead$[ebp], 0
	je	SHORT $LN2@Arch_ReadF
	mov	eax, DWORD PTR _lpNumberOfBytesRead$[ebp]
	mov	ecx, DWORD PTR _dwNumBytesRead$3[ebp]
	mov	DWORD PTR [eax], ecx
$LN2@Arch_ReadF:

; 241  : 		if(hEvent) SetEvent(hEvent);

	cmp	DWORD PTR _hEvent$[ebp], 0
	je	SHORT $LN1@Arch_ReadF
	mov	esi, esp
	mov	eax, DWORD PTR _hEvent$[ebp]
	push	eax
	call	DWORD PTR __imp__SetEvent@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@Arch_ReadF:

; 242  : 
; 243  : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $LN11@Arch_ReadF
$LN10@Arch_ReadF:

; 244  : 
; 245  : 	}
; 246  : 
; 247  : 	return Real_ReadFile(hFile,lpBuffer,nNumberOfBytesToRead,
; 248  : 		lpNumberOfBytesRead,lpOverlapped);

	mov	esi, esp
	mov	eax, DWORD PTR _lpOverlapped$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNumberOfBytesRead$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nNumberOfBytesToRead$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpBuffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFile$[ebp]
	push	ecx
	call	DWORD PTR ?Real_ReadFile@@3P6GHPAX0KPAKPAU_OVERLAPPED@@@ZA ; Real_ReadFile
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN11@Arch_ReadF:

; 249  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?Arch_ReadFile@@YGHPAX0KPAKPAU_OVERLAPPED@@@Z ENDP	; Arch_ReadFile
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\filehooks.cpp
;	COMDAT ?Arch_CreateFileW@@YGPAXPAGKKPAU_SECURITY_ATTRIBUTES@@KKPAX@Z
_TEXT	SEGMENT
_ret$ = -8						; size = 4
_lpFileName$ = 8					; size = 4
_dwDesiredAccess$ = 12					; size = 4
_dwShareMode$ = 16					; size = 4
_lpSecurityAttributes$ = 20				; size = 4
_dwCreationDisposition$ = 24				; size = 4
_dwFlagsAndAttributes$ = 28				; size = 4
_hTemplateFile$ = 32					; size = 4
?Arch_CreateFileW@@YGPAXPAGKKPAU_SECURITY_ATTRIBUTES@@KKPAX@Z PROC ; Arch_CreateFileW, COMDAT

; 157  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 158  : 
; 159  : #ifdef _DEBUG
; 160  : /*
; 161  : 	wchar_t wszBuffer[FILENAME_MAX];
; 162  : 	swprintf(wszBuffer, L"CreateFileW: %s\n", lpFileName);
; 163  : 	OutputDebugStringW(wszBuffer);
; 164  : */
; 165  : #endif
; 166  : 
; 167  : 	HANDLE ret=Real_CreateFileW(lpFileName,dwDesiredAccess,dwShareMode,
; 168  : 		lpSecurityAttributes,dwCreationDisposition,dwFlagsAndAttributes,hTemplateFile);

	mov	esi, esp
	mov	eax, DWORD PTR _hTemplateFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwFlagsAndAttributes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwCreationDisposition$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSecurityAttributes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwShareMode$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwDesiredAccess$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpFileName$[ebp]
	push	eax
	call	DWORD PTR ?Real_CreateFileW@@3P6GPAXPAGKKPAU_SECURITY_ATTRIBUTES@@KKPAX@ZA ; Real_CreateFileW
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 169  : 	if (IsCheckableFile(ExtensionOnly((PCHAR)lpFileName)))

	mov	eax, DWORD PTR _lpFileName$[ebp]
	push	eax
	call	?ExtensionOnly@@YAPADPAD@Z		; ExtensionOnly
	add	esp, 4
	push	eax
	call	?IsCheckableFile@@YAHPAD@Z		; IsCheckableFile
	add	esp, 4
	test	eax, eax
	je	SHORT $LN1@Arch_Creat

; 170  : 	{
; 171  : 		CheckFileHash(GetFileNameHash(strtolower(FileNameOnly((PCHAR)lpFileName))), ret);

	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpFileName$[ebp]
	push	ecx
	call	?FileNameOnly@@YAPADPAD@Z		; FileNameOnly
	add	esp, 4
	push	eax
	call	?strtolower@@YAPADPAD@Z			; strtolower
	add	esp, 4
	push	eax
	call	?GetFileNameHash@@YAHPAD@Z		; GetFileNameHash
	add	esp, 4
	push	eax
	call	?CheckFileHash@@YAXHPAX@Z		; CheckFileHash
	add	esp, 8
$LN1@Arch_Creat:

; 172  : 	}
; 173  : 	return ret;

	mov	eax, DWORD PTR _ret$[ebp]

; 174  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?Arch_CreateFileW@@YGPAXPAGKKPAU_SECURITY_ATTRIBUTES@@KKPAX@Z ENDP ; Arch_CreateFileW
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\filehooks.cpp
;	COMDAT ?Arch_CreateFileA@@YGPAXPBDKKPAU_SECURITY_ATTRIBUTES@@KKPAX@Z
_TEXT	SEGMENT
_ret$ = -20						; size = 4
_dwFileIndex$ = -8					; size = 4
_lpFileName$ = 8					; size = 4
_dwDesiredAccess$ = 12					; size = 4
_dwShareMode$ = 16					; size = 4
_lpSecurityAttributes$ = 20				; size = 4
_dwCreationDisposition$ = 24				; size = 4
_dwFlagsAndAttributes$ = 28				; size = 4
_hTemplateFile$ = 32					; size = 4
?Arch_CreateFileA@@YGPAXPBDKKPAU_SECURITY_ATTRIBUTES@@KKPAX@Z PROC ; Arch_CreateFileA, COMDAT

; 111  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 112  : 
; 113  : #ifdef _DEBUG
; 114  : /*
; 115  : 	char szBuffer[FILENAME_MAX];
; 116  : 	sprintf(szBuffer, "CreateFileA: %s\n", lpFileName);
; 117  : 	OutputDebugString(szBuffer);
; 118  : */
; 119  : #endif
; 120  : 
; 121  : 	DWORD dwFileIndex = pFileSystem->GetFileIndex(FileNameOnly((PCHAR)lpFileName));

	mov	eax, DWORD PTR _lpFileName$[ebp]
	push	eax
	call	?FileNameOnly@@YAPADPAD@Z		; FileNameOnly
	add	esp, 4
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR ?pFileSystem@@3PAVCFileSystem@@A ; pFileSystem
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?pFileSystem@@3PAVCFileSystem@@A ; pFileSystem
	mov	eax, DWORD PTR [edx+12]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _dwFileIndex$[ebp], eax

; 122  : 
; 123  : 	HANDLE ret=0;

	mov	DWORD PTR _ret$[ebp], 0

; 124  : 
; 125  : 	if(dwFileIndex != FS_INVALID_FILE)

	cmp	DWORD PTR _dwFileIndex$[ebp], -1
	je	SHORT $LN3@Arch_Creat

; 126  : 	{
; 127  : 		// The request file is in the archive, so we should return the handle.
; 128  : 		ret = CreateArchRecord(dwFileIndex);

	mov	eax, DWORD PTR _dwFileIndex$[ebp]
	push	eax
	call	?CreateArchRecord@@YAPAXK@Z		; CreateArchRecord
	add	esp, 4
	mov	DWORD PTR _ret$[ebp], eax

; 129  : 		
; 130  : 		/*
; 131  : 		sprintf(s,"Opening Archive File %s(0x%X:%u)",FileNameOnly((PCHAR)lpFileName),ret,dwFileIndex);
; 132  : 		OutputDebugString(s);
; 133  : 		*/
; 134  : 
; 135  : 	}
; 136  : 	else

	jmp	SHORT $LN2@Arch_Creat
$LN3@Arch_Creat:

; 137  : 	{
; 138  : 		// Don't check if it's in the archive
; 139  : 		ret = Real_CreateFileA(lpFileName,dwDesiredAccess,dwShareMode,
; 140  : 			lpSecurityAttributes,dwCreationDisposition,dwFlagsAndAttributes,hTemplateFile);

	mov	esi, esp
	mov	eax, DWORD PTR _hTemplateFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwFlagsAndAttributes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwCreationDisposition$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSecurityAttributes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwShareMode$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwDesiredAccess$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpFileName$[ebp]
	push	eax
	call	DWORD PTR ?Real_CreateFileA@@3P6GPAXPBDKKPAU_SECURITY_ATTRIBUTES@@KKPAX@ZA ; Real_CreateFileA
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 141  : 
; 142  : 		if (IsCheckableFile(ExtensionOnly((PCHAR)lpFileName)))

	mov	eax, DWORD PTR _lpFileName$[ebp]
	push	eax
	call	?ExtensionOnly@@YAPADPAD@Z		; ExtensionOnly
	add	esp, 4
	push	eax
	call	?IsCheckableFile@@YAHPAD@Z		; IsCheckableFile
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@Arch_Creat

; 143  : 		{
; 144  : 			CheckFileHash(GetFileNameHash(strtolower(FileNameOnly((PCHAR)lpFileName))), ret);

	mov	eax, DWORD PTR _ret$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpFileName$[ebp]
	push	ecx
	call	?FileNameOnly@@YAPADPAD@Z		; FileNameOnly
	add	esp, 4
	push	eax
	call	?strtolower@@YAPADPAD@Z			; strtolower
	add	esp, 4
	push	eax
	call	?GetFileNameHash@@YAHPAD@Z		; GetFileNameHash
	add	esp, 4
	push	eax
	call	?CheckFileHash@@YAXHPAX@Z		; CheckFileHash
	add	esp, 8
$LN2@Arch_Creat:

; 145  : 		}
; 146  : 	}
; 147  : 	
; 148  : 	return ret;

	mov	eax, DWORD PTR _ret$[ebp]

; 149  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?Arch_CreateFileA@@YGPAXPBDKKPAU_SECURITY_ATTRIBUTES@@KKPAX@Z ENDP ; Arch_CreateFileA
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\filehooks.cpp
;	COMDAT ?CreateArchRecord@@YAPAXK@Z
_TEXT	SEGMENT
_iArchRecordIndex$ = -8					; size = 4
_dwFileIndex$ = 8					; size = 4
?CreateArchRecord@@YAPAXK@Z PROC			; CreateArchRecord, COMDAT

; 87   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 88   : 	int iArchRecordIndex = FindUnusedArchRecordIndex();

	call	?FindUnusedArchRecordIndex@@YAHXZ	; FindUnusedArchRecordIndex
	mov	DWORD PTR _iArchRecordIndex$[ebp], eax

; 89   : 
; 90   : 	if(iArchRecordIndex == (-1)) return 0;

	cmp	DWORD PTR _iArchRecordIndex$[ebp], -1
	jne	SHORT $LN1@CreateArch
	xor	eax, eax
	jmp	$LN2@CreateArch
$LN1@CreateArch:

; 91   : 	
; 92   : 	bArchRecordSlotState[iArchRecordIndex] = TRUE;

	mov	eax, DWORD PTR _iArchRecordIndex$[ebp]
	mov	DWORD PTR ?bArchRecordSlotState@@3PAHA[eax*4], 1

; 93   : 
; 94   : 	OpenArchRecords[iArchRecordIndex].hHandle = (HANDLE)iCustomHandle;

	imul	eax, DWORD PTR _iArchRecordIndex$[ebp], 20
	mov	ecx, DWORD PTR ?iCustomHandle@@3HA	; iCustomHandle
	mov	DWORD PTR ?OpenArchRecords@@3PAU_ARCH_FILE_RECORD@@A[eax], ecx

; 95   : 	iCustomHandle+=2;

	mov	eax, DWORD PTR ?iCustomHandle@@3HA	; iCustomHandle
	add	eax, 2
	mov	DWORD PTR ?iCustomHandle@@3HA, eax	; iCustomHandle

; 96   : 
; 97   : 	OpenArchRecords[iArchRecordIndex].dwReadPosition = 0;

	imul	eax, DWORD PTR _iArchRecordIndex$[ebp], 20
	mov	DWORD PTR ?OpenArchRecords@@3PAU_ARCH_FILE_RECORD@@A[eax+4], 0

; 98   : 	OpenArchRecords[iArchRecordIndex].dwFileSize = pFileSystem->GetFileSize(dwFileIndex);

	mov	esi, esp
	mov	eax, DWORD PTR _dwFileIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?pFileSystem@@3PAVCFileSystem@@A ; pFileSystem
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?pFileSystem@@3PAVCFileSystem@@A ; pFileSystem
	mov	eax, DWORD PTR [edx+16]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	imul	ecx, DWORD PTR _iArchRecordIndex$[ebp], 20
	mov	DWORD PTR ?OpenArchRecords@@3PAU_ARCH_FILE_RECORD@@A[ecx+8], eax

; 99   : 	OpenArchRecords[iArchRecordIndex].pbyteDataStart = pFileSystem->GetFileData(dwFileIndex);

	mov	esi, esp
	mov	eax, DWORD PTR _dwFileIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?pFileSystem@@3PAVCFileSystem@@A ; pFileSystem
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?pFileSystem@@3PAVCFileSystem@@A ; pFileSystem
	mov	eax, DWORD PTR [edx+20]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	imul	ecx, DWORD PTR _iArchRecordIndex$[ebp], 20
	mov	DWORD PTR ?OpenArchRecords@@3PAU_ARCH_FILE_RECORD@@A[ecx+12], eax

; 100  : 	OpenArchRecords[iArchRecordIndex].pbyteDataCurrent = OpenArchRecords[iArchRecordIndex].pbyteDataStart;

	imul	eax, DWORD PTR _iArchRecordIndex$[ebp], 20
	imul	ecx, DWORD PTR _iArchRecordIndex$[ebp], 20
	mov	edx, DWORD PTR ?OpenArchRecords@@3PAU_ARCH_FILE_RECORD@@A[eax+12]
	mov	DWORD PTR ?OpenArchRecords@@3PAU_ARCH_FILE_RECORD@@A[ecx+16], edx

; 101  : 
; 102  : 	return OpenArchRecords[iArchRecordIndex].hHandle;

	imul	eax, DWORD PTR _iArchRecordIndex$[ebp], 20
	mov	eax, DWORD PTR ?OpenArchRecords@@3PAU_ARCH_FILE_RECORD@@A[eax]
$LN2@CreateArch:

; 103  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?CreateArchRecord@@YAPAXK@Z ENDP			; CreateArchRecord
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\filehooks.cpp
;	COMDAT ?FindArchRecordIndexFromHandle@@YAHPAX@Z
_TEXT	SEGMENT
_x$ = -8						; size = 4
_hFile$ = 8						; size = 4
?FindArchRecordIndexFromHandle@@YAHPAX@Z PROC		; FindArchRecordIndexFromHandle, COMDAT

; 71   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 72   : 	int x=0;

	mov	DWORD PTR _x$[ebp], 0
$LN4@FindArchRe:

; 73   : 	while(x!=MAX_OPEN_ARCH_FILES) {

	cmp	DWORD PTR _x$[ebp], 50			; 00000032H
	je	SHORT $LN3@FindArchRe

; 74   : 		if(bArchRecordSlotState[x] == TRUE) {

	mov	eax, DWORD PTR _x$[ebp]
	cmp	DWORD PTR ?bArchRecordSlotState@@3PAHA[eax*4], 1
	jne	SHORT $LN2@FindArchRe

; 75   : 			if(OpenArchRecords[x].hHandle == hFile) {

	imul	eax, DWORD PTR _x$[ebp], 20
	mov	ecx, DWORD PTR ?OpenArchRecords@@3PAU_ARCH_FILE_RECORD@@A[eax]
	cmp	ecx, DWORD PTR _hFile$[ebp]
	jne	SHORT $LN2@FindArchRe

; 76   : 				return x;

	mov	eax, DWORD PTR _x$[ebp]
	jmp	SHORT $LN5@FindArchRe
$LN2@FindArchRe:

; 77   : 			}				
; 78   : 		}
; 79   : 		x++;

	mov	eax, DWORD PTR _x$[ebp]
	add	eax, 1
	mov	DWORD PTR _x$[ebp], eax

; 80   : 	}

	jmp	SHORT $LN4@FindArchRe
$LN3@FindArchRe:

; 81   : 	return (-1);

	or	eax, -1
$LN5@FindArchRe:

; 82   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FindArchRecordIndexFromHandle@@YAHPAX@Z ENDP		; FindArchRecordIndexFromHandle
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\filehooks.cpp
;	COMDAT ?FindUnusedArchRecordIndex@@YAHXZ
_TEXT	SEGMENT
_x$ = -8						; size = 4
?FindUnusedArchRecordIndex@@YAHXZ PROC			; FindUnusedArchRecordIndex, COMDAT

; 57   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 58   : 	int x=0;

	mov	DWORD PTR _x$[ebp], 0
$LN3@FindUnused:

; 59   : 	while(x!=MAX_OPEN_ARCH_FILES) {

	cmp	DWORD PTR _x$[ebp], 50			; 00000032H
	je	SHORT $LN2@FindUnused

; 60   : 		if(bArchRecordSlotState[x] == FALSE) {

	mov	eax, DWORD PTR _x$[ebp]
	cmp	DWORD PTR ?bArchRecordSlotState@@3PAHA[eax*4], 0
	jne	SHORT $LN1@FindUnused

; 61   : 			return x;

	mov	eax, DWORD PTR _x$[ebp]
	jmp	SHORT $LN4@FindUnused
$LN1@FindUnused:

; 62   : 		}
; 63   : 		x++;

	mov	eax, DWORD PTR _x$[ebp]
	add	eax, 1
	mov	DWORD PTR _x$[ebp], eax

; 64   : 	}

	jmp	SHORT $LN3@FindUnused
$LN2@FindUnused:

; 65   : 	return (-1);

	or	eax, -1
$LN4@FindUnused:

; 66   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FindUnusedArchRecordIndex@@YAHXZ ENDP			; FindUnusedArchRecordIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\filehooks.cpp
;	COMDAT ?IsCustomFileHandle@@YAHK@Z
_TEXT	SEGMENT
_handle$ = 8						; size = 4
?IsCustomFileHandle@@YAHK@Z PROC			; IsCustomFileHandle, COMDAT

; 47   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 48   : 	if(handle >= CUSTOM_HANDLE_BASE && handle < CUSTOM_HANDLE_LIMIT) {

	cmp	DWORD PTR _handle$[ebp], -16777215	; ff000001H
	jb	SHORT $LN1@IsCustomFi
	cmp	DWORD PTR _handle$[ebp], -16776959	; ff000101H
	jae	SHORT $LN1@IsCustomFi

; 49   : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $LN2@IsCustomFi
$LN1@IsCustomFi:

; 50   : 	}
; 51   : 	return FALSE;

	xor	eax, eax
$LN2@IsCustomFi:

; 52   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsCustomFileHandle@@YAHK@Z ENDP			; IsCustomFileHandle
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\filehooks.cpp
;	COMDAT ?strtolower@@YAPADPAD@Z
_TEXT	SEGMENT
_ret$ = -8						; size = 4
_sz$ = 8						; size = 4
?strtolower@@YAPADPAD@Z PROC				; strtolower, COMDAT

; 493  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 494  : 	char* ret = sz;

	mov	eax, DWORD PTR _sz$[ebp]
	mov	DWORD PTR _ret$[ebp], eax
$LN2@strtolower:

; 495  : 	while (*sz)

	mov	eax, DWORD PTR _sz$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN1@strtolower

; 496  : 	{
; 497  : 		*sz = tolower(*sz);

	mov	eax, DWORD PTR _sz$[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	call	_tolower
	add	esp, 4
	mov	edx, DWORD PTR _sz$[ebp]
	mov	BYTE PTR [edx], al

; 498  : 		sz++;

	mov	eax, DWORD PTR _sz$[ebp]
	add	eax, 1
	mov	DWORD PTR _sz$[ebp], eax

; 499  : 	}

	jmp	SHORT $LN2@strtolower
$LN1@strtolower:

; 500  : 	return ret;

	mov	eax, DWORD PTR _ret$[ebp]

; 501  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?strtolower@@YAPADPAD@Z ENDP				; strtolower
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\filehooks.cpp
;	COMDAT ?ExtensionOnly@@YAPADPAD@Z
_TEXT	SEGMENT
_search$ = -20						; size = 4
_org$ = -8						; size = 4
_sz$ = 8						; size = 4
?ExtensionOnly@@YAPADPAD@Z PROC				; ExtensionOnly, COMDAT

; 472  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 473  : 	// remove the trailing space, if it's there.
; 474  : 	if(sz[strlen(sz) - 1] == ' ') {

	mov	eax, DWORD PTR _sz$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _sz$[ebp]
	movsx	edx, BYTE PTR [ecx+eax-1]
	cmp	edx, 32					; 00000020H
	jne	SHORT $LN4@ExtensionO

; 475  : 		sz[strlen(sz) - 1] = '\0';

	mov	eax, DWORD PTR _sz$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _sz$[ebp]
	mov	BYTE PTR [ecx+eax-1], 0
$LN4@ExtensionO:

; 476  : 	}
; 477  : 
; 478  : 	char * org = sz;

	mov	eax, DWORD PTR _sz$[ebp]
	mov	DWORD PTR _org$[ebp], eax

; 479  : 	char * search = sz + strlen(sz);

	mov	eax, DWORD PTR _sz$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, DWORD PTR _sz$[ebp]
	mov	DWORD PTR _search$[ebp], eax
$LN3@ExtensionO:

; 480  : 
; 481  : 	while(search != org) {

	mov	eax, DWORD PTR _search$[ebp]
	cmp	eax, DWORD PTR _org$[ebp]
	je	SHORT $LN2@ExtensionO

; 482  : 		if(*search == '.') {

	mov	eax, DWORD PTR _search$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 46					; 0000002eH
	jne	SHORT $LN1@ExtensionO

; 483  : 			return (search+1);

	mov	eax, DWORD PTR _search$[ebp]
	add	eax, 1
	jmp	SHORT $LN5@ExtensionO
$LN1@ExtensionO:

; 484  : 		}
; 485  : 		search--;

	mov	eax, DWORD PTR _search$[ebp]
	sub	eax, 1
	mov	DWORD PTR _search$[ebp], eax

; 486  : 	}

	jmp	SHORT $LN3@ExtensionO
$LN2@ExtensionO:

; 487  : 	return org;

	mov	eax, DWORD PTR _org$[ebp]
$LN5@ExtensionO:

; 488  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?ExtensionOnly@@YAPADPAD@Z ENDP				; ExtensionOnly
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\filehooks.cpp
;	COMDAT ?FileNameOnly@@YAPADPAD@Z
_TEXT	SEGMENT
_search$ = -20						; size = 4
_org$ = -8						; size = 4
_sz$ = 8						; size = 4
?FileNameOnly@@YAPADPAD@Z PROC				; FileNameOnly, COMDAT

; 451  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 452  : 	// remove the trailing space, if it's there.
; 453  : 	if(sz[strlen(sz) - 1] == ' ') {

	mov	eax, DWORD PTR _sz$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _sz$[ebp]
	movsx	edx, BYTE PTR [ecx+eax-1]
	cmp	edx, 32					; 00000020H
	jne	SHORT $LN5@FileNameOn

; 454  : 		sz[strlen(sz) - 1] = '\0';

	mov	eax, DWORD PTR _sz$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _sz$[ebp]
	mov	BYTE PTR [ecx+eax-1], 0
$LN5@FileNameOn:

; 455  : 	}
; 456  : 
; 457  : 	char * org = sz;

	mov	eax, DWORD PTR _sz$[ebp]
	mov	DWORD PTR _org$[ebp], eax

; 458  : 	char * search = sz + strlen(sz);

	mov	eax, DWORD PTR _sz$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, DWORD PTR _sz$[ebp]
	mov	DWORD PTR _search$[ebp], eax
$LN4@FileNameOn:

; 459  : 
; 460  : 	while(search != org) {

	mov	eax, DWORD PTR _search$[ebp]
	cmp	eax, DWORD PTR _org$[ebp]
	je	SHORT $LN3@FileNameOn

; 461  : 		if(*search == '/' || *search == '\\') {

	mov	eax, DWORD PTR _search$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	je	SHORT $LN1@FileNameOn
	mov	eax, DWORD PTR _search$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	jne	SHORT $LN2@FileNameOn
$LN1@FileNameOn:

; 462  : 			return (search+1);

	mov	eax, DWORD PTR _search$[ebp]
	add	eax, 1
	jmp	SHORT $LN6@FileNameOn
$LN2@FileNameOn:

; 463  : 		}
; 464  : 		search--;

	mov	eax, DWORD PTR _search$[ebp]
	sub	eax, 1
	mov	DWORD PTR _search$[ebp], eax

; 465  : 	}

	jmp	SHORT $LN4@FileNameOn
$LN3@FileNameOn:

; 466  : 	return org;

	mov	eax, DWORD PTR _org$[ebp]
$LN6@FileNameOn:

; 467  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?FileNameOnly@@YAPADPAD@Z ENDP				; FileNameOnly
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\filehooks.cpp
;	COMDAT ?UninstallFileSystemHooks@@YAXXZ
_TEXT	SEGMENT
?UninstallFileSystemHooks@@YAXXZ PROC			; UninstallFileSystemHooks, COMDAT

; 434  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 435  : 	if(bFileHooksInstalled) {

	cmp	DWORD PTR ?bFileHooksInstalled@@3HA, 0	; bFileHooksInstalled
	je	SHORT $LN2@UninstallF

; 436  : 		DetourRemove((PBYTE)Real_CreateFileA,(PBYTE)Arch_CreateFileA);

	push	OFFSET ?Arch_CreateFileA@@YGPAXPBDKKPAU_SECURITY_ATTRIBUTES@@KKPAX@Z ; Arch_CreateFileA
	mov	eax, DWORD PTR ?Real_CreateFileA@@3P6GPAXPBDKKPAU_SECURITY_ATTRIBUTES@@KKPAX@ZA ; Real_CreateFileA
	push	eax
	call	_DetourRemove@8

; 437  : 		DetourRemove((PBYTE)Real_ReadFile,(PBYTE)Arch_ReadFile);

	push	OFFSET ?Arch_ReadFile@@YGHPAX0KPAKPAU_OVERLAPPED@@@Z ; Arch_ReadFile
	mov	eax, DWORD PTR ?Real_ReadFile@@3P6GHPAX0KPAKPAU_OVERLAPPED@@@ZA ; Real_ReadFile
	push	eax
	call	_DetourRemove@8

; 438  : 		DetourRemove((PBYTE)Real_GetFileSize,(PBYTE)Arch_GetFileSize);

	push	OFFSET ?Arch_GetFileSize@@YGKPAXPAK@Z	; Arch_GetFileSize
	mov	eax, DWORD PTR ?Real_GetFileSize@@3P6GKPAXPAK@ZA ; Real_GetFileSize
	push	eax
	call	_DetourRemove@8

; 439  : 		DetourRemove((PBYTE)Real_SetFilePointer,(PBYTE)Arch_SetFilePointer);

	push	OFFSET ?Arch_SetFilePointer@@YGKPAXJPAJK@Z ; Arch_SetFilePointer
	mov	eax, DWORD PTR ?Real_SetFilePointer@@3P6GKPAXJPAJK@ZA ; Real_SetFilePointer
	push	eax
	call	_DetourRemove@8

; 440  : 		DetourRemove((PBYTE)Real_CloseHandle,(PBYTE)Arch_CloseHandle);

	push	OFFSET ?Arch_CloseHandle@@YGHPAX@Z	; Arch_CloseHandle
	mov	eax, DWORD PTR ?Real_CloseHandle@@3P6GHPAX@ZA ; Real_CloseHandle
	push	eax
	call	_DetourRemove@8

; 441  : 		DetourRemove((PBYTE)Real_GetFileType,(PBYTE)Arch_GetFileType);

	push	OFFSET ?Arch_GetFileType@@YGKPAX@Z	; Arch_GetFileType
	mov	eax, DWORD PTR ?Real_GetFileType@@3P6GKPAX@ZA ; Real_GetFileType
	push	eax
	call	_DetourRemove@8

; 442  : 		DetourRemove((PBYTE)Real_GetModuleHandleA,(PBYTE)Arch_GetModuleHandleA);

	push	OFFSET ?Arch_GetModuleHandleA@@YGPAUHINSTANCE__@@PBD@Z ; Arch_GetModuleHandleA
	mov	eax, DWORD PTR ?Real_GetModuleHandleA@@3P6GPAUHINSTANCE__@@PBD@ZA ; Real_GetModuleHandleA
	push	eax
	call	_DetourRemove@8

; 443  : 		//DetourRemove((PBYTE)Real_GetAsyncKeyState,(PBYTE)Arch_GetAsyncKeyState);
; 444  : 		bFileHooksInstalled = FALSE;

	mov	DWORD PTR ?bFileHooksInstalled@@3HA, 0	; bFileHooksInstalled
$LN2@UninstallF:

; 445  : 	}
; 446  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?UninstallFileSystemHooks@@YAXXZ ENDP			; UninstallFileSystemHooks
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\filehooks.cpp
;	COMDAT ?InstallFileSystemHooks@@YAXXZ
_TEXT	SEGMENT
_szGetModuleHandleAEnc$ = -188				; size = 17
_szGetFileTypeEnc$ = -160				; size = 12
_szCloseHandleEnc$ = -140				; size = 12
_szSetFilePointerEnc$ = -120				; size = 15
_szGetFileSizeEnc$ = -96				; size = 12
_szReadFileEnc$ = -76					; size = 9
_szCreateFileAEnc$ = -56				; size = 12
_szKernel32Dec$ = -36					; size = 4
_szKernel32Enc$ = -24					; size = 13
__$ArrayPad$ = -4					; size = 4
?InstallFileSystemHooks@@YAXXZ PROC			; InstallFileSystemHooks, COMDAT

; 368  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 384				; 00000180H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-384]
	mov	ecx, 96					; 00000060H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 369  : 	BYTE szKernel32Enc[13] = {0x6D,0xAC,0x4E,0xCD,0xAC,0x8D,0x66,0x46,0xC5,0x8C,0x8D,0x8D,0}; // kernel32.dll

	mov	BYTE PTR _szKernel32Enc$[ebp], 109	; 0000006dH
	mov	BYTE PTR _szKernel32Enc$[ebp+1], 172	; 000000acH
	mov	BYTE PTR _szKernel32Enc$[ebp+2], 78	; 0000004eH
	mov	BYTE PTR _szKernel32Enc$[ebp+3], 205	; 000000cdH
	mov	BYTE PTR _szKernel32Enc$[ebp+4], 172	; 000000acH
	mov	BYTE PTR _szKernel32Enc$[ebp+5], 141	; 0000008dH
	mov	BYTE PTR _szKernel32Enc$[ebp+6], 102	; 00000066H
	mov	BYTE PTR _szKernel32Enc$[ebp+7], 70	; 00000046H
	mov	BYTE PTR _szKernel32Enc$[ebp+8], 197	; 000000c5H
	mov	BYTE PTR _szKernel32Enc$[ebp+9], 140	; 0000008cH
	mov	BYTE PTR _szKernel32Enc$[ebp+10], 141	; 0000008dH
	mov	BYTE PTR _szKernel32Enc$[ebp+11], 141	; 0000008dH
	mov	BYTE PTR _szKernel32Enc$[ebp+12], 0

; 370  :     char *szKernel32Dec = NULL;

	mov	DWORD PTR _szKernel32Dec$[ebp], 0

; 371  : 
; 372  : 	BYTE szCreateFileAEnc[12] = {0x68,0x4E,0xAC,0x2C,0x8E,0xAC,0xC8,0x2D,0x8D,0xAC,0x28,0}; // CreateFileA

	mov	BYTE PTR _szCreateFileAEnc$[ebp], 104	; 00000068H
	mov	BYTE PTR _szCreateFileAEnc$[ebp+1], 78	; 0000004eH
	mov	BYTE PTR _szCreateFileAEnc$[ebp+2], 172	; 000000acH
	mov	BYTE PTR _szCreateFileAEnc$[ebp+3], 44	; 0000002cH
	mov	BYTE PTR _szCreateFileAEnc$[ebp+4], 142	; 0000008eH
	mov	BYTE PTR _szCreateFileAEnc$[ebp+5], 172	; 000000acH
	mov	BYTE PTR _szCreateFileAEnc$[ebp+6], 200	; 000000c8H
	mov	BYTE PTR _szCreateFileAEnc$[ebp+7], 45	; 0000002dH
	mov	BYTE PTR _szCreateFileAEnc$[ebp+8], 141	; 0000008dH
	mov	BYTE PTR _szCreateFileAEnc$[ebp+9], 172	; 000000acH
	mov	BYTE PTR _szCreateFileAEnc$[ebp+10], 40	; 00000028H
	mov	BYTE PTR _szCreateFileAEnc$[ebp+11], 0

; 373  : 	BYTE szReadFileEnc[9] = {0x4A,0xAC,0x2C,0x8C,0xC8,0x2D,0x8D,0xAC,0}; // ReadFile

	mov	BYTE PTR _szReadFileEnc$[ebp], 74	; 0000004aH
	mov	BYTE PTR _szReadFileEnc$[ebp+1], 172	; 000000acH
	mov	BYTE PTR _szReadFileEnc$[ebp+2], 44	; 0000002cH
	mov	BYTE PTR _szReadFileEnc$[ebp+3], 140	; 0000008cH
	mov	BYTE PTR _szReadFileEnc$[ebp+4], 200	; 000000c8H
	mov	BYTE PTR _szReadFileEnc$[ebp+5], 45	; 0000002dH
	mov	BYTE PTR _szReadFileEnc$[ebp+6], 141	; 0000008dH
	mov	BYTE PTR _szReadFileEnc$[ebp+7], 172	; 000000acH
	mov	BYTE PTR _szReadFileEnc$[ebp+8], 0

; 374  : 	BYTE szGetFileSizeEnc[12] = {0xE8,0xAC,0x8E,0xC8,0x2D,0x8D,0xAC,0x6A,0x2D,0x4F,0xAC,0}; // GetFileSize

	mov	BYTE PTR _szGetFileSizeEnc$[ebp], 232	; 000000e8H
	mov	BYTE PTR _szGetFileSizeEnc$[ebp+1], 172	; 000000acH
	mov	BYTE PTR _szGetFileSizeEnc$[ebp+2], 142	; 0000008eH
	mov	BYTE PTR _szGetFileSizeEnc$[ebp+3], 200	; 000000c8H
	mov	BYTE PTR _szGetFileSizeEnc$[ebp+4], 45	; 0000002dH
	mov	BYTE PTR _szGetFileSizeEnc$[ebp+5], 141	; 0000008dH
	mov	BYTE PTR _szGetFileSizeEnc$[ebp+6], 172	; 000000acH
	mov	BYTE PTR _szGetFileSizeEnc$[ebp+7], 106	; 0000006aH
	mov	BYTE PTR _szGetFileSizeEnc$[ebp+8], 45	; 0000002dH
	mov	BYTE PTR _szGetFileSizeEnc$[ebp+9], 79	; 0000004fH
	mov	BYTE PTR _szGetFileSizeEnc$[ebp+10], 172 ; 000000acH
	mov	BYTE PTR _szGetFileSizeEnc$[ebp+11], 0

; 375  : 	BYTE szSetFilePointerEnc[15] = {0x6A,0xAC,0x8E,0xC8,0x2D,0x8D,0xAC,0xA,0xED,0x2D,0xCD,0x8E,0xAC,0x4E,0}; // SetFilePointer

	mov	BYTE PTR _szSetFilePointerEnc$[ebp], 106 ; 0000006aH
	mov	BYTE PTR _szSetFilePointerEnc$[ebp+1], 172 ; 000000acH
	mov	BYTE PTR _szSetFilePointerEnc$[ebp+2], 142 ; 0000008eH
	mov	BYTE PTR _szSetFilePointerEnc$[ebp+3], 200 ; 000000c8H
	mov	BYTE PTR _szSetFilePointerEnc$[ebp+4], 45 ; 0000002dH
	mov	BYTE PTR _szSetFilePointerEnc$[ebp+5], 141 ; 0000008dH
	mov	BYTE PTR _szSetFilePointerEnc$[ebp+6], 172 ; 000000acH
	mov	BYTE PTR _szSetFilePointerEnc$[ebp+7], 10 ; 0000000aH
	mov	BYTE PTR _szSetFilePointerEnc$[ebp+8], 237 ; 000000edH
	mov	BYTE PTR _szSetFilePointerEnc$[ebp+9], 45 ; 0000002dH
	mov	BYTE PTR _szSetFilePointerEnc$[ebp+10], 205 ; 000000cdH
	mov	BYTE PTR _szSetFilePointerEnc$[ebp+11], 142 ; 0000008eH
	mov	BYTE PTR _szSetFilePointerEnc$[ebp+12], 172 ; 000000acH
	mov	BYTE PTR _szSetFilePointerEnc$[ebp+13], 78 ; 0000004eH
	mov	BYTE PTR _szSetFilePointerEnc$[ebp+14], 0

; 376  : 	BYTE szCloseHandleEnc[12] = {0x68,0x8D,0xED,0x6E,0xAC,0x9,0x2C,0xCD,0x8C,0x8D,0xAC,0}; // CloseHandle

	mov	BYTE PTR _szCloseHandleEnc$[ebp], 104	; 00000068H
	mov	BYTE PTR _szCloseHandleEnc$[ebp+1], 141	; 0000008dH
	mov	BYTE PTR _szCloseHandleEnc$[ebp+2], 237	; 000000edH
	mov	BYTE PTR _szCloseHandleEnc$[ebp+3], 110	; 0000006eH
	mov	BYTE PTR _szCloseHandleEnc$[ebp+4], 172	; 000000acH
	mov	BYTE PTR _szCloseHandleEnc$[ebp+5], 9
	mov	BYTE PTR _szCloseHandleEnc$[ebp+6], 44	; 0000002cH
	mov	BYTE PTR _szCloseHandleEnc$[ebp+7], 205	; 000000cdH
	mov	BYTE PTR _szCloseHandleEnc$[ebp+8], 140	; 0000008cH
	mov	BYTE PTR _szCloseHandleEnc$[ebp+9], 141	; 0000008dH
	mov	BYTE PTR _szCloseHandleEnc$[ebp+10], 172 ; 000000acH
	mov	BYTE PTR _szCloseHandleEnc$[ebp+11], 0

; 377  : 	BYTE szGetFileTypeEnc[12] = {0xE8,0xAC,0x8E,0xC8,0x2D,0x8D,0xAC,0x8A,0x2F,0xE,0xAC,0}; // GetFileType

	mov	BYTE PTR _szGetFileTypeEnc$[ebp], 232	; 000000e8H
	mov	BYTE PTR _szGetFileTypeEnc$[ebp+1], 172	; 000000acH
	mov	BYTE PTR _szGetFileTypeEnc$[ebp+2], 142	; 0000008eH
	mov	BYTE PTR _szGetFileTypeEnc$[ebp+3], 200	; 000000c8H
	mov	BYTE PTR _szGetFileTypeEnc$[ebp+4], 45	; 0000002dH
	mov	BYTE PTR _szGetFileTypeEnc$[ebp+5], 141	; 0000008dH
	mov	BYTE PTR _szGetFileTypeEnc$[ebp+6], 172	; 000000acH
	mov	BYTE PTR _szGetFileTypeEnc$[ebp+7], 138	; 0000008aH
	mov	BYTE PTR _szGetFileTypeEnc$[ebp+8], 47	; 0000002fH
	mov	BYTE PTR _szGetFileTypeEnc$[ebp+9], 14	; 0000000eH
	mov	BYTE PTR _szGetFileTypeEnc$[ebp+10], 172 ; 000000acH
	mov	BYTE PTR _szGetFileTypeEnc$[ebp+11], 0

; 378  : 	BYTE szGetModuleHandleAEnc[17] = {0xE8,0xAC,0x8E,0xA9,0xED,0x8C,0xAE,0x8D,0xAC,0x9,0x2C,0xCD,0x8C,0x8D,0xAC,0x28,0}; // GetModuleHandleA

	mov	BYTE PTR _szGetModuleHandleAEnc$[ebp], 232 ; 000000e8H
	mov	BYTE PTR _szGetModuleHandleAEnc$[ebp+1], 172 ; 000000acH
	mov	BYTE PTR _szGetModuleHandleAEnc$[ebp+2], 142 ; 0000008eH
	mov	BYTE PTR _szGetModuleHandleAEnc$[ebp+3], 169 ; 000000a9H
	mov	BYTE PTR _szGetModuleHandleAEnc$[ebp+4], 237 ; 000000edH
	mov	BYTE PTR _szGetModuleHandleAEnc$[ebp+5], 140 ; 0000008cH
	mov	BYTE PTR _szGetModuleHandleAEnc$[ebp+6], 174 ; 000000aeH
	mov	BYTE PTR _szGetModuleHandleAEnc$[ebp+7], 141 ; 0000008dH
	mov	BYTE PTR _szGetModuleHandleAEnc$[ebp+8], 172 ; 000000acH
	mov	BYTE PTR _szGetModuleHandleAEnc$[ebp+9], 9
	mov	BYTE PTR _szGetModuleHandleAEnc$[ebp+10], 44 ; 0000002cH
	mov	BYTE PTR _szGetModuleHandleAEnc$[ebp+11], 205 ; 000000cdH
	mov	BYTE PTR _szGetModuleHandleAEnc$[ebp+12], 140 ; 0000008cH
	mov	BYTE PTR _szGetModuleHandleAEnc$[ebp+13], 141 ; 0000008dH
	mov	BYTE PTR _szGetModuleHandleAEnc$[ebp+14], 172 ; 000000acH
	mov	BYTE PTR _szGetModuleHandleAEnc$[ebp+15], 40 ; 00000028H
	mov	BYTE PTR _szGetModuleHandleAEnc$[ebp+16], 0

; 379  : 
; 380  : 	if(!bFileHooksInstalled) {

	cmp	DWORD PTR ?bFileHooksInstalled@@3HA, 0	; bFileHooksInstalled
	jne	$LN2@InstallFil

; 381  : 		OutputDebugString("Installing File System Hooks");

	mov	esi, esp
	push	OFFSET ??_C@_0BN@CGMCCCO@Installing?5File?5System?5Hooks?$AA@
	call	DWORD PTR __imp__OutputDebugStringA@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 382  : 
; 383  : 		// reset our structures memory
; 384  : 		memset(OpenArchRecords,0,sizeof(ARCH_FILE_RECORD) * MAX_OPEN_ARCH_FILES);

	push	1000					; 000003e8H
	push	0
	push	OFFSET ?OpenArchRecords@@3PAU_ARCH_FILE_RECORD@@A ; OpenArchRecords
	call	_memset
	add	esp, 12					; 0000000cH

; 385  : 		memset(bArchRecordSlotState,FALSE,sizeof(BOOL) * MAX_OPEN_ARCH_FILES);

	push	200					; 000000c8H
	push	0
	push	OFFSET ?bArchRecordSlotState@@3PAHA	; bArchRecordSlotState
	call	_memset
	add	esp, 12					; 0000000cH

; 386  : 
; 387  : 		szKernel32Dec = K_DecodeString(szKernel32Enc);

	lea	eax, DWORD PTR _szKernel32Enc$[ebp]
	push	eax
	call	?K_DecodeString@@YAPADPAE@Z		; K_DecodeString
	add	esp, 4
	mov	DWORD PTR _szKernel32Dec$[ebp], eax

; 388  : 
; 389  : 		Real_CreateFileA = (def_CreateFileA)DetourFunction(
; 390  : 			(PBYTE)DetourFindFunction(szKernel32Dec, K_DecodeString(szCreateFileAEnc)),
; 391  : 			(PBYTE)Arch_CreateFileA);

	push	OFFSET ?Arch_CreateFileA@@YGPAXPBDKKPAU_SECURITY_ATTRIBUTES@@KKPAX@Z ; Arch_CreateFileA
	lea	eax, DWORD PTR _szCreateFileAEnc$[ebp]
	push	eax
	call	?K_DecodeString@@YAPADPAE@Z		; K_DecodeString
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _szKernel32Dec$[ebp]
	push	ecx
	call	_DetourFindFunction@8
	push	eax
	call	_DetourFunction@8
	mov	DWORD PTR ?Real_CreateFileA@@3P6GPAXPBDKKPAU_SECURITY_ATTRIBUTES@@KKPAX@ZA, eax ; Real_CreateFileA

; 392  : 
; 393  : 		/*
; 394  : 		Real_CreateFileW = (def_CreateFileW)DetourFunction(
; 395  : 			(PBYTE)DetourFindFunction(szKernel32Dec, "CreateFileW"),
; 396  : 			(PBYTE)Arch_CreateFileW);*/
; 397  : 
; 398  : 		Real_ReadFile = (def_ReadFile)DetourFunction(
; 399  : 			(PBYTE)DetourFindFunction(szKernel32Dec, K_DecodeString(szReadFileEnc)),
; 400  : 			(PBYTE)Arch_ReadFile);

	push	OFFSET ?Arch_ReadFile@@YGHPAX0KPAKPAU_OVERLAPPED@@@Z ; Arch_ReadFile
	lea	eax, DWORD PTR _szReadFileEnc$[ebp]
	push	eax
	call	?K_DecodeString@@YAPADPAE@Z		; K_DecodeString
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _szKernel32Dec$[ebp]
	push	ecx
	call	_DetourFindFunction@8
	push	eax
	call	_DetourFunction@8
	mov	DWORD PTR ?Real_ReadFile@@3P6GHPAX0KPAKPAU_OVERLAPPED@@@ZA, eax ; Real_ReadFile

; 401  : 
; 402  : 		Real_GetFileSize = (def_GetFileSize)DetourFunction(
; 403  : 			(PBYTE)DetourFindFunction(szKernel32Dec, K_DecodeString(szGetFileSizeEnc)),
; 404  : 			(PBYTE)Arch_GetFileSize);

	push	OFFSET ?Arch_GetFileSize@@YGKPAXPAK@Z	; Arch_GetFileSize
	lea	eax, DWORD PTR _szGetFileSizeEnc$[ebp]
	push	eax
	call	?K_DecodeString@@YAPADPAE@Z		; K_DecodeString
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _szKernel32Dec$[ebp]
	push	ecx
	call	_DetourFindFunction@8
	push	eax
	call	_DetourFunction@8
	mov	DWORD PTR ?Real_GetFileSize@@3P6GKPAXPAK@ZA, eax ; Real_GetFileSize

; 405  : 
; 406  : 		Real_SetFilePointer = (def_SetFilePointer)DetourFunction(
; 407  : 			(PBYTE)DetourFindFunction(szKernel32Dec, K_DecodeString(szSetFilePointerEnc)),
; 408  : 			(PBYTE)Arch_SetFilePointer);

	push	OFFSET ?Arch_SetFilePointer@@YGKPAXJPAJK@Z ; Arch_SetFilePointer
	lea	eax, DWORD PTR _szSetFilePointerEnc$[ebp]
	push	eax
	call	?K_DecodeString@@YAPADPAE@Z		; K_DecodeString
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _szKernel32Dec$[ebp]
	push	ecx
	call	_DetourFindFunction@8
	push	eax
	call	_DetourFunction@8
	mov	DWORD PTR ?Real_SetFilePointer@@3P6GKPAXJPAJK@ZA, eax ; Real_SetFilePointer

; 409  : 
; 410  : 		Real_CloseHandle = (def_CloseHandle)DetourFunction(
; 411  : 			(PBYTE)DetourFindFunction(szKernel32Dec, K_DecodeString(szCloseHandleEnc)),
; 412  : 			(PBYTE)Arch_CloseHandle);

	push	OFFSET ?Arch_CloseHandle@@YGHPAX@Z	; Arch_CloseHandle
	lea	eax, DWORD PTR _szCloseHandleEnc$[ebp]
	push	eax
	call	?K_DecodeString@@YAPADPAE@Z		; K_DecodeString
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _szKernel32Dec$[ebp]
	push	ecx
	call	_DetourFindFunction@8
	push	eax
	call	_DetourFunction@8
	mov	DWORD PTR ?Real_CloseHandle@@3P6GHPAX@ZA, eax ; Real_CloseHandle

; 413  : 
; 414  : 		Real_GetFileType = (def_GetFileType)DetourFunction(
; 415  : 			(PBYTE)DetourFindFunction(szKernel32Dec, K_DecodeString(szGetFileTypeEnc)),
; 416  : 			(PBYTE)Arch_GetFileType);

	push	OFFSET ?Arch_GetFileType@@YGKPAX@Z	; Arch_GetFileType
	lea	eax, DWORD PTR _szGetFileTypeEnc$[ebp]
	push	eax
	call	?K_DecodeString@@YAPADPAE@Z		; K_DecodeString
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _szKernel32Dec$[ebp]
	push	ecx
	call	_DetourFindFunction@8
	push	eax
	call	_DetourFunction@8
	mov	DWORD PTR ?Real_GetFileType@@3P6GKPAX@ZA, eax ; Real_GetFileType

; 417  : 
; 418  : 		Real_GetModuleHandleA = (def_GetModuleHandleA)DetourFunction(
; 419  : 			(PBYTE)DetourFindFunction(szKernel32Dec, K_DecodeString(szGetModuleHandleAEnc)),
; 420  : 			(PBYTE)Arch_GetModuleHandleA);

	push	OFFSET ?Arch_GetModuleHandleA@@YGPAUHINSTANCE__@@PBD@Z ; Arch_GetModuleHandleA
	lea	eax, DWORD PTR _szGetModuleHandleAEnc$[ebp]
	push	eax
	call	?K_DecodeString@@YAPADPAE@Z		; K_DecodeString
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _szKernel32Dec$[ebp]
	push	ecx
	call	_DetourFindFunction@8
	push	eax
	call	_DetourFunction@8
	mov	DWORD PTR ?Real_GetModuleHandleA@@3P6GPAUHINSTANCE__@@PBD@ZA, eax ; Real_GetModuleHandleA

; 421  : 
; 422  : 		/*
; 423  : 		Real_GetAsyncKeyState = (def_GetAsyncKeyState)DetourFunction(
; 424  : 			(PBYTE)DetourFindFunction("user32.dll", "GetAsyncKeyState"),
; 425  : 			(PBYTE)Arch_GetAsyncKeyState);*/
; 426  : 
; 427  : 		bFileHooksInstalled = TRUE;

	mov	DWORD PTR ?bFileHooksInstalled@@3HA, 1	; bFileHooksInstalled
$LN2@InstallFil:

; 428  : 	}
; 429  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN13@InstallFil
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 384				; 00000180H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN13@InstallFil:
	DD	8
	DD	$LN12@InstallFil
$LN12@InstallFil:
	DD	-24					; ffffffe8H
	DD	13					; 0000000dH
	DD	$LN4@InstallFil
	DD	-56					; ffffffc8H
	DD	12					; 0000000cH
	DD	$LN5@InstallFil
	DD	-76					; ffffffb4H
	DD	9
	DD	$LN6@InstallFil
	DD	-96					; ffffffa0H
	DD	12					; 0000000cH
	DD	$LN7@InstallFil
	DD	-120					; ffffff88H
	DD	15					; 0000000fH
	DD	$LN8@InstallFil
	DD	-140					; ffffff74H
	DD	12					; 0000000cH
	DD	$LN9@InstallFil
	DD	-160					; ffffff60H
	DD	12					; 0000000cH
	DD	$LN10@InstallFil
	DD	-188					; ffffff44H
	DD	17					; 00000011H
	DD	$LN11@InstallFil
$LN11@InstallFil:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	71					; 00000047H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	77					; 0000004dH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	72					; 00000048H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	65					; 00000041H
	DB	69					; 00000045H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	0
$LN10@InstallFil:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	71					; 00000047H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	84					; 00000054H
	DB	121					; 00000079H
	DB	112					; 00000070H
	DB	101					; 00000065H
	DB	69					; 00000045H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	0
$LN9@InstallFil:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	67					; 00000043H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	72					; 00000048H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	69					; 00000045H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	0
$LN8@InstallFil:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	83					; 00000053H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	80					; 00000050H
	DB	111					; 0000006fH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	69					; 00000045H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	0
$LN7@InstallFil:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	71					; 00000047H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	69					; 00000045H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	0
$LN6@InstallFil:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	82					; 00000052H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	69					; 00000045H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	0
$LN5@InstallFil:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	67					; 00000043H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	65					; 00000041H
	DB	69					; 00000045H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	0
$LN4@InstallFil:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	75					; 0000004bH
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	51					; 00000033H
	DB	50					; 00000032H
	DB	69					; 00000045H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	0
?InstallFileSystemHooks@@YAXXZ ENDP			; InstallFileSystemHooks
_TEXT	ENDS
END
