; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.31101.0 

	TITLE	Z:\sampsrc\02Xu1\raknet\Rand.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_left	DD	0ffffffffH
_DATA	ENDS
PUBLIC	?seedMT@@YAXI@Z					; seedMT
PUBLIC	?reloadMT@@YAIXZ				; reloadMT
PUBLIC	?randomMT@@YAIXZ				; randomMT
PUBLIC	?frandomMT@@YAMXZ				; frandomMT
PUBLIC	__real@41f0000000000000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_state	DD	0271H DUP (?)
_next	DD	01H DUP (?)
_BSS	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@41f0000000000000
CONST	SEGMENT
__real@41f0000000000000 DQ 041f0000000000000r	; 4.29497e+009
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rand.cpp
;	COMDAT ?frandomMT@@YAMXZ
_TEXT	SEGMENT
tv75 = -200						; size = 4
tv71 = -196						; size = 4
?frandomMT@@YAMXZ PROC					; frandomMT, COMDAT

; 181  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-200]
	mov	ecx, 50					; 00000032H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 182  : 	return ( float ) ( ( double ) randomMT() / 4294967296.0 );

	call	?randomMT@@YAIXZ			; randomMT
	mov	DWORD PTR tv71[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv71[ebp]
	mov	eax, DWORD PTR tv71[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	divsd	xmm0, QWORD PTR __real@41f0000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv75[ebp], xmm0
	fld	DWORD PTR tv75[ebp]

; 183  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 200				; 000000c8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?frandomMT@@YAMXZ ENDP					; frandomMT
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rand.cpp
;	COMDAT ?randomMT@@YAIXZ
_TEXT	SEGMENT
_y$ = -8						; size = 4
?randomMT@@YAIXZ PROC					; randomMT, COMDAT

; 160  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 161  : 	unsigned int y;
; 162  : 
; 163  : 	if ( --left < 0 )

	mov	eax, DWORD PTR _left
	sub	eax, 1
	mov	DWORD PTR _left, eax
	jns	SHORT $LN1@randomMT

; 164  : 		return ( reloadMT() );

	call	?reloadMT@@YAIXZ			; reloadMT
	jmp	SHORT $LN2@randomMT
$LN1@randomMT:

; 165  : 
; 166  : 	y = *next++;

	mov	eax, DWORD PTR _next
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _y$[ebp], ecx
	mov	edx, DWORD PTR _next
	add	edx, 4
	mov	DWORD PTR _next, edx

; 167  : 
; 168  : 	y ^= ( y >> 11 );

	mov	eax, DWORD PTR _y$[ebp]
	shr	eax, 11					; 0000000bH
	xor	eax, DWORD PTR _y$[ebp]
	mov	DWORD PTR _y$[ebp], eax

; 169  : 
; 170  : 	y ^= ( y << 7 ) & 0x9D2C5680U;

	mov	eax, DWORD PTR _y$[ebp]
	shl	eax, 7
	and	eax, -1658038656			; 9d2c5680H
	xor	eax, DWORD PTR _y$[ebp]
	mov	DWORD PTR _y$[ebp], eax

; 171  : 
; 172  : 	y ^= ( y << 15 ) & 0xEFC60000U;

	mov	eax, DWORD PTR _y$[ebp]
	shl	eax, 15					; 0000000fH
	and	eax, -272236544				; efc60000H
	xor	eax, DWORD PTR _y$[ebp]
	mov	DWORD PTR _y$[ebp], eax

; 173  : 
; 174  : 	return ( y ^ ( y >> 18 ) );

	mov	eax, DWORD PTR _y$[ebp]
	shr	eax, 18					; 00000012H
	xor	eax, DWORD PTR _y$[ebp]
$LN2@randomMT:

; 175  : 
; 176  : 	// This change made so the value returned is in the same range as what rand() returns
; 177  : 	// return(y ^ (y >> 18)) % 32767;
; 178  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?randomMT@@YAIXZ ENDP					; randomMT
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rand.cpp
;	COMDAT ?reloadMT@@YAIXZ
_TEXT	SEGMENT
tv142 = -268						; size = 4
tv131 = -268						; size = 4
tv85 = -268						; size = 4
_j$ = -68						; size = 4
_s1$ = -56						; size = 4
_s0$ = -44						; size = 4
_pM$ = -32						; size = 4
_p2$ = -20						; size = 4
_p0$ = -8						; size = 4
?reloadMT@@YAIXZ PROC					; reloadMT, COMDAT

; 132  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-268]
	mov	ecx, 67					; 00000043H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 133  : 	register unsigned int * p0 = state, *p2 = state + 2, *pM = state + M, s0, s1;

	mov	DWORD PTR _p0$[ebp], OFFSET _state
	mov	DWORD PTR _p2$[ebp], OFFSET _state+8
	mov	DWORD PTR _pM$[ebp], OFFSET _state+1588

; 134  : 	register int j;
; 135  : 
; 136  : 	if ( left < -1 )

	cmp	DWORD PTR _left, -1
	jge	SHORT $LN7@reloadMT

; 137  : 		seedMT( 4357U );

	push	4357					; 00001105H
	call	?seedMT@@YAXI@Z				; seedMT
	add	esp, 4
$LN7@reloadMT:

; 138  : 
; 139  : 	left = N - 1, next = state + 1;

	mov	DWORD PTR _left, 623			; 0000026fH
	mov	DWORD PTR _next, OFFSET _state+4

; 140  : 
; 141  : 	for ( s0 = state[ 0 ], s1 = state[ 1 ], j = N - M + 1; --j; s0 = s1, s1 = *p2++ )

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _state[ecx]
	mov	DWORD PTR _s0$[ebp], edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _state[eax]
	mov	DWORD PTR _s1$[ebp], ecx
	mov	DWORD PTR _j$[ebp], 228			; 000000e4H
	jmp	SHORT $LN6@reloadMT
$LN5@reloadMT:
	mov	eax, DWORD PTR _s1$[ebp]
	mov	DWORD PTR _s0$[ebp], eax
	mov	ecx, DWORD PTR _p2$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _s1$[ebp], edx
	mov	eax, DWORD PTR _p2$[ebp]
	add	eax, 4
	mov	DWORD PTR _p2$[ebp], eax
$LN6@reloadMT:
	mov	eax, DWORD PTR _j$[ebp]
	sub	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	je	SHORT $LN4@reloadMT

; 142  : 		* p0++ = *pM++ ^ ( mixBits( s0, s1 ) >> 1 ) ^ ( loBit( s1 ) ? K : 0U );

	mov	eax, DWORD PTR _s1$[ebp]
	and	eax, 1
	je	SHORT $LN10@reloadMT
	mov	DWORD PTR tv85[ebp], -1727483681	; 9908b0dfH
	jmp	SHORT $LN11@reloadMT
$LN10@reloadMT:
	mov	DWORD PTR tv85[ebp], 0
$LN11@reloadMT:
	mov	ecx, DWORD PTR _s0$[ebp]
	and	ecx, -2147483648			; 80000000H
	mov	edx, DWORD PTR _s1$[ebp]
	and	edx, 2147483647				; 7fffffffH
	or	ecx, edx
	shr	ecx, 1
	mov	eax, DWORD PTR _pM$[ebp]
	xor	ecx, DWORD PTR [eax]
	xor	ecx, DWORD PTR tv85[ebp]
	mov	edx, DWORD PTR _p0$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR _p0$[ebp]
	add	eax, 4
	mov	DWORD PTR _p0$[ebp], eax
	mov	ecx, DWORD PTR _pM$[ebp]
	add	ecx, 4
	mov	DWORD PTR _pM$[ebp], ecx
	jmp	SHORT $LN5@reloadMT
$LN4@reloadMT:

; 143  : 
; 144  : 	for ( pM = state, j = M; --j; s0 = s1, s1 = *p2++ )

	mov	DWORD PTR _pM$[ebp], OFFSET _state
	mov	DWORD PTR _j$[ebp], 397			; 0000018dH
	jmp	SHORT $LN3@reloadMT
$LN2@reloadMT:
	mov	eax, DWORD PTR _s1$[ebp]
	mov	DWORD PTR _s0$[ebp], eax
	mov	ecx, DWORD PTR _p2$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _s1$[ebp], edx
	mov	eax, DWORD PTR _p2$[ebp]
	add	eax, 4
	mov	DWORD PTR _p2$[ebp], eax
$LN3@reloadMT:
	mov	eax, DWORD PTR _j$[ebp]
	sub	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	je	SHORT $LN1@reloadMT

; 145  : 		* p0++ = *pM++ ^ ( mixBits( s0, s1 ) >> 1 ) ^ ( loBit( s1 ) ? K : 0U );

	mov	eax, DWORD PTR _s1$[ebp]
	and	eax, 1
	je	SHORT $LN12@reloadMT
	mov	DWORD PTR tv131[ebp], -1727483681	; 9908b0dfH
	jmp	SHORT $LN13@reloadMT
$LN12@reloadMT:
	mov	DWORD PTR tv131[ebp], 0
$LN13@reloadMT:
	mov	ecx, DWORD PTR _s0$[ebp]
	and	ecx, -2147483648			; 80000000H
	mov	edx, DWORD PTR _s1$[ebp]
	and	edx, 2147483647				; 7fffffffH
	or	ecx, edx
	shr	ecx, 1
	mov	eax, DWORD PTR _pM$[ebp]
	xor	ecx, DWORD PTR [eax]
	xor	ecx, DWORD PTR tv131[ebp]
	mov	edx, DWORD PTR _p0$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR _p0$[ebp]
	add	eax, 4
	mov	DWORD PTR _p0$[ebp], eax
	mov	ecx, DWORD PTR _pM$[ebp]
	add	ecx, 4
	mov	DWORD PTR _pM$[ebp], ecx
	jmp	SHORT $LN2@reloadMT
$LN1@reloadMT:

; 146  : 
; 147  : 	s1 = state[ 0 ], *p0 = *pM ^ ( mixBits( s0, s1 ) >> 1 ) ^ ( loBit( s1 ) ? K : 0U );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _state[ecx]
	mov	DWORD PTR _s1$[ebp], edx
	mov	eax, DWORD PTR _s1$[ebp]
	and	eax, 1
	je	SHORT $LN14@reloadMT
	mov	DWORD PTR tv142[ebp], -1727483681	; 9908b0dfH
	jmp	SHORT $LN15@reloadMT
$LN14@reloadMT:
	mov	DWORD PTR tv142[ebp], 0
$LN15@reloadMT:
	mov	ecx, DWORD PTR _s0$[ebp]
	and	ecx, -2147483648			; 80000000H
	mov	edx, DWORD PTR _s1$[ebp]
	and	edx, 2147483647				; 7fffffffH
	or	ecx, edx
	shr	ecx, 1
	mov	eax, DWORD PTR _pM$[ebp]
	xor	ecx, DWORD PTR [eax]
	xor	ecx, DWORD PTR tv142[ebp]
	mov	edx, DWORD PTR _p0$[ebp]
	mov	DWORD PTR [edx], ecx

; 148  : 
; 149  : 	s1 ^= ( s1 >> 11 );

	mov	eax, DWORD PTR _s1$[ebp]
	shr	eax, 11					; 0000000bH
	xor	eax, DWORD PTR _s1$[ebp]
	mov	DWORD PTR _s1$[ebp], eax

; 150  : 
; 151  : 	s1 ^= ( s1 << 7 ) & 0x9D2C5680U;

	mov	eax, DWORD PTR _s1$[ebp]
	shl	eax, 7
	and	eax, -1658038656			; 9d2c5680H
	xor	eax, DWORD PTR _s1$[ebp]
	mov	DWORD PTR _s1$[ebp], eax

; 152  : 
; 153  : 	s1 ^= ( s1 << 15 ) & 0xEFC60000U;

	mov	eax, DWORD PTR _s1$[ebp]
	shl	eax, 15					; 0000000fH
	and	eax, -272236544				; efc60000H
	xor	eax, DWORD PTR _s1$[ebp]
	mov	DWORD PTR _s1$[ebp], eax

; 154  : 
; 155  : 	return ( s1 ^ ( s1 >> 18 ) );

	mov	eax, DWORD PTR _s1$[ebp]
	shr	eax, 18					; 00000012H
	xor	eax, DWORD PTR _s1$[ebp]

; 156  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 268				; 0000010cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?reloadMT@@YAIXZ ENDP					; reloadMT
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rand.cpp
;	COMDAT ?seedMT@@YAXI@Z
_TEXT	SEGMENT
_j$ = -32						; size = 4
_s$ = -20						; size = 4
_x$ = -8						; size = 4
_seed$ = 8						; size = 4
?seedMT@@YAXI@Z PROC					; seedMT, COMDAT

; 74   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 75   : 	//
; 76   : 	// We initialize state[0..(N-1)] via the generator
; 77   : 	//
; 78   : 	//  x_new = (69069 * x_old) mod 2^32
; 79   : 	//
; 80   : 	// from Line 15 of Table 1, p. 106, Sec. 3.3.4 of Knuth's
; 81   : 	// _The Art of Computer Programming_, Volume 2, 3rd ed.
; 82   : 	//
; 83   : 	// Notes (SJC): I do not know what the initial state requirements
; 84   : 	// of the Mersenne Twister are, but it seems this seeding generator
; 85   : 	// could be better.  It achieves the maximum period for its modulus
; 86   : 	// (2^30) iff x_initial is odd (p. 20-21, Sec. 3.2.1.2, Knuth); if
; 87   : 	// x_initial can be even, you have sequences like 0, 0, 0, ...;
; 88   : 	// 2^31, 2^31, 2^31, ...; 2^30, 2^30, 2^30, ...; 2^29, 2^29 + 2^31,
; 89   : 	// 2^29, 2^29 + 2^31, ..., etc. so I force seed to be odd below.
; 90   : 	//
; 91   : 	// Even if x_initial is odd, if x_initial is 1 mod 4 then
; 92   : 	//
; 93   : 	//  the   lowest bit of x is always 1,
; 94   : 	//  the  next-to-lowest bit of x is always 0,
; 95   : 	//  the 2nd-from-lowest bit of x alternates   ... 0 1 0 1 0 1 0 1 ... ,
; 96   : 	//  the 3rd-from-lowest bit of x 4-cycles   ... 0 1 1 0 0 1 1 0 ... ,
; 97   : 	//  the 4th-from-lowest bit of x has the 8-cycle ... 0 0 0 1 1 1 1 0 ... ,
; 98   : 	//   ...
; 99   : 	//
; 100  : 	// and if x_initial is 3 mod 4 then
; 101  : 	//
; 102  : 	//  the   lowest bit of x is always 1,
; 103  : 	//  the  next-to-lowest bit of x is always 1,
; 104  : 	//  the 2nd-from-lowest bit of x alternates   ... 0 1 0 1 0 1 0 1 ... ,
; 105  : 	//  the 3rd-from-lowest bit of x 4-cycles   ... 0 0 1 1 0 0 1 1 ... ,
; 106  : 	//  the 4th-from-lowest bit of x has the 8-cycle ... 0 0 1 1 1 1 0 0 ... ,
; 107  : 	//   ...
; 108  : 	//
; 109  : 	// The generator's potency (min. s>=0 with (69069-1)^s = 0 mod 2^32) is
; 110  : 	// 16, which seems to be alright by p. 25, Sec. 3.2.1.3 of Knuth.  It
; 111  : 	// also does well in the dimension 2..5 spectral tests, but it could be
; 112  : 	// better in dimension 6 (Line 15, Table 1, p. 106, Sec. 3.3.4, Knuth).
; 113  : 	//
; 114  : 	// Note that the random number user does not see the values generated
; 115  : 	// here directly since reloadMT() will always munge them first, so maybe
; 116  : 	// none of all of this matters.  In fact, the seed values made here could
; 117  : 	// even be extra-special desirable if the Mersenne Twister theory says
; 118  : 	// so-- that's why the only change I made is to restrict to odd seeds.
; 119  : 	//
; 120  : 
; 121  : 	register unsigned int x = ( seed | 1U ) & 0xFFFFFFFFU, *s = state;

	mov	eax, DWORD PTR _seed$[ebp]
	or	eax, 1
	mov	DWORD PTR _x$[ebp], eax
	mov	DWORD PTR _s$[ebp], OFFSET _state

; 122  : 	register int j;
; 123  : 
; 124  : 	for ( left = 0, *s++ = x, j = N; --j;

	mov	DWORD PTR _left, 0
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _x$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 4
	mov	DWORD PTR _s$[ebp], edx
	mov	DWORD PTR _j$[ebp], 624			; 00000270H
	jmp	SHORT $LN3@seedMT
$LN2@seedMT:

; 125  : 		*s++ = ( x *= 69069U ) & 0xFFFFFFFFU )

	imul	eax, DWORD PTR _x$[ebp], 69069
	mov	DWORD PTR _x$[ebp], eax
	mov	ecx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _x$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 4
	mov	DWORD PTR _s$[ebp], eax
$LN3@seedMT:
	mov	eax, DWORD PTR _j$[ebp]
	sub	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	je	SHORT $LN4@seedMT

; 126  : 
; 127  : 		;

	jmp	SHORT $LN2@seedMT
$LN4@seedMT:

; 128  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?seedMT@@YAXI@Z ENDP					; seedMT
_TEXT	ENDS
END
