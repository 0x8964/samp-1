; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.31101.0 

	TITLE	Z:\sampsrc\02Xu1\raknet\GetTime.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_BSS	SEGMENT
_initialized DB	01H DUP (?)
_BSS	ENDS
PUBLIC	?GetTime@RakNet@@YAIXZ				; RakNet::GetTime
PUBLIC	?GetTimeNS@RakNet@@YA_JXZ			; RakNet::GetTimeNS
EXTRN	__imp__QueryPerformanceCounter@4:PROC
EXTRN	__imp__QueryPerformanceFrequency@4:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__alldiv:PROC
EXTRN	__allmul:PROC
EXTRN	__allrem:PROC
_BSS	SEGMENT
	ALIGN	4

_yo	DQ	01H DUP (?)
_BSS	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\gettime.cpp
;	COMDAT ?GetTimeNS@RakNet@@YA_JXZ
_TEXT	SEGMENT
_remainder$ = -44					; size = 8
_quotient$ = -28					; size = 8
_PerfVal$ = -12						; size = 8
?GetTimeNS@RakNet@@YA_JXZ PROC				; RakNet::GetTimeNS, COMDAT

; 72   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 73   : 	if ( initialized == false )

	movzx	eax, BYTE PTR _initialized
	test	eax, eax
	jne	SHORT $LN1@GetTimeNS

; 74   : 	{
; 75   : #ifdef _WIN32
; 76   : 		QueryPerformanceFrequency( &yo );

	mov	esi, esp
	push	OFFSET _yo
	call	DWORD PTR __imp__QueryPerformanceFrequency@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 77   : 		// The original code shifted right 10 bits
; 78   : 		//counts = yo.QuadPart >> 10;
; 79   : 		// It gives the wrong value since 2^10 is not 1000
; 80   : 		//	counts = yo.QuadPart;// / 1000;
; 81   : #else
; 82   : 		gettimeofday( &initialTime, 0 );
; 83   : #endif
; 84   : 
; 85   : 		initialized = true;

	mov	BYTE PTR _initialized, 1
$LN1@GetTimeNS:

; 86   : 	}
; 87   : 
; 88   : #ifdef _WIN32
; 89   : 	LARGE_INTEGER PerfVal;
; 90   : 
; 91   : 	QueryPerformanceCounter( &PerfVal );

	mov	esi, esp
	lea	eax, DWORD PTR _PerfVal$[ebp]
	push	eax
	call	DWORD PTR __imp__QueryPerformanceCounter@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 92   : 
; 93   : 	__int64 quotient, remainder;
; 94   : 	quotient=((PerfVal.QuadPart*1000) / yo.QuadPart);

	push	0
	push	1000					; 000003e8H
	mov	eax, DWORD PTR _PerfVal$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _PerfVal$[ebp]
	push	ecx
	call	__allmul
	mov	ecx, DWORD PTR _yo+4
	push	ecx
	mov	ecx, DWORD PTR _yo
	push	ecx
	push	edx
	push	eax
	call	__alldiv
	mov	DWORD PTR _quotient$[ebp], eax
	mov	DWORD PTR _quotient$[ebp+4], edx

; 95   : 	remainder=((PerfVal.QuadPart*1000) % yo.QuadPart);

	push	0
	push	1000					; 000003e8H
	mov	eax, DWORD PTR _PerfVal$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _PerfVal$[ebp]
	push	ecx
	call	__allmul
	mov	ecx, DWORD PTR _yo+4
	push	ecx
	mov	ecx, DWORD PTR _yo
	push	ecx
	push	edx
	push	eax
	call	__allrem
	mov	DWORD PTR _remainder$[ebp], eax
	mov	DWORD PTR _remainder$[ebp+4], edx

; 96   : 	//return (PerfVal.QuadPart*1000 / (yo.QuadPart/1000));
; 97   : 	return quotient*1000 + (remainder*1000 / yo.QuadPart);

	push	0
	push	1000					; 000003e8H
	mov	eax, DWORD PTR _quotient$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _quotient$[ebp]
	push	ecx
	call	__allmul
	mov	esi, eax
	mov	edi, edx
	push	0
	push	1000					; 000003e8H
	mov	edx, DWORD PTR _remainder$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _remainder$[ebp]
	push	eax
	call	__allmul
	mov	ecx, DWORD PTR _yo+4
	push	ecx
	mov	ecx, DWORD PTR _yo
	push	ecx
	push	edx
	push	eax
	call	__alldiv
	add	esi, eax
	adc	edi, edx
	mov	eax, esi
	mov	edx, edi

; 98   : 
; 99   : #else
; 100  : 	gettimeofday( &tp, 0 );
; 101  : 
; 102  : 	return ( tp.tv_sec - initialTime.tv_sec ) * (RakNetTimeNS) 1000000 + ( tp.tv_usec - initialTime.tv_usec );
; 103  : 
; 104  : #endif
; 105  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetTimeNS
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@GetTimeNS:
	DD	1
	DD	$LN5@GetTimeNS
$LN5@GetTimeNS:
	DD	-12					; fffffff4H
	DD	8
	DD	$LN4@GetTimeNS
$LN4@GetTimeNS:
	DB	80					; 00000050H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	102					; 00000066H
	DB	86					; 00000056H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	0
?GetTimeNS@RakNet@@YA_JXZ ENDP				; RakNet::GetTimeNS
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\gettime.cpp
;	COMDAT ?GetTime@RakNet@@YAIXZ
_TEXT	SEGMENT
_PerfVal$ = -12						; size = 8
?GetTime@RakNet@@YAIXZ PROC				; RakNet::GetTime, COMDAT

; 39   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 40   : 	if ( initialized == false )

	movzx	eax, BYTE PTR _initialized
	test	eax, eax
	jne	SHORT $LN1@GetTime

; 41   : 	{
; 42   : #ifdef _WIN32
; 43   : 		QueryPerformanceFrequency( &yo );

	mov	esi, esp
	push	OFFSET _yo
	call	DWORD PTR __imp__QueryPerformanceFrequency@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 44   : 		// The original code shifted right 10 bits
; 45   : 		//counts = yo.QuadPart >> 10;
; 46   : 		// It gives the wrong value since 2^10 is not 1000
; 47   : 	//	counts = yo.QuadPart;// / 1000;
; 48   : #else
; 49   : 		gettimeofday( &initialTime, 0 );
; 50   : #endif
; 51   : 		
; 52   : 		initialized = true;

	mov	BYTE PTR _initialized, 1
$LN1@GetTime:

; 53   : 	}
; 54   : 	
; 55   : #ifdef _WIN32
; 56   : 	LARGE_INTEGER PerfVal;
; 57   : 	
; 58   : 	QueryPerformanceCounter( &PerfVal );

	mov	esi, esp
	lea	eax, DWORD PTR _PerfVal$[ebp]
	push	eax
	call	DWORD PTR __imp__QueryPerformanceCounter@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 59   : 	
; 60   : 	return (RakNetTime)(PerfVal.QuadPart*1000 / yo.QuadPart);

	push	0
	push	1000					; 000003e8H
	mov	eax, DWORD PTR _PerfVal$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _PerfVal$[ebp]
	push	ecx
	call	__allmul
	mov	ecx, DWORD PTR _yo+4
	push	ecx
	mov	ecx, DWORD PTR _yo
	push	ecx
	push	edx
	push	eax
	call	__alldiv

; 61   : #else
; 62   : 	gettimeofday( &tp, 0 );
; 63   : 	
; 64   : 	// Seconds to ms and microseconds to ms
; 65   : 	return ( tp.tv_sec - initialTime.tv_sec ) * 1000 + ( tp.tv_usec - initialTime.tv_usec ) / 1000;
; 66   : 	
; 67   : #endif
; 68   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@GetTime
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@GetTime:
	DD	1
	DD	$LN5@GetTime
$LN5@GetTime:
	DD	-12					; fffffff4H
	DD	8
	DD	$LN4@GetTime
$LN4@GetTime:
	DB	80					; 00000050H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	102					; 00000066H
	DB	86					; 00000056H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	0
?GetTime@RakNet@@YAIXZ ENDP				; RakNet::GetTime
_TEXT	ENDS
END
