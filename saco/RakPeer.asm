; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.31101.0 

	TITLE	Z:\sampsrc\02Xu1\raknet\RakPeer.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
_UNASSIGNED_PLAYER_ID DD 0ffffffffH
	DW	0ffffH
	ORG $+2
_UNASSIGNED_NETWORK_ID DD 0ffffffffH
	DW	0ffffH
	DW	0ffffH
_PRIME_TABLE DW	03H
	DW	05H
	DW	07H
	DW	0bH
	DW	0dH
	DW	011H
	DW	013H
	DW	017H
	DW	01dH
	DW	01fH
	DW	025H
	DW	029H
	DW	02bH
	DW	02fH
	DW	035H
	DW	03bH
	DW	03dH
	DW	043H
	DW	047H
	DW	049H
	DW	04fH
	DW	053H
	DW	059H
	DW	061H
	DW	065H
	DW	067H
	DW	06bH
	DW	06dH
	DW	071H
	DW	07fH
	DW	083H
	DW	089H
	DW	08bH
	DW	095H
	DW	097H
	DW	09dH
	DW	0a3H
	DW	0a7H
	DW	0adH
	DW	0b3H
	DW	0b5H
	DW	0bfH
	DW	0c1H
	DW	0c5H
	DW	0c7H
	DW	0d3H
	DW	0dfH
	DW	0e3H
	DW	0e5H
	DW	0e9H
	DW	0efH
	DW	0f1H
	DW	0fbH
	DW	0101H
	DW	0107H
	DW	010dH
	DW	010fH
	DW	0115H
	DW	0119H
	DW	011bH
	DW	0125H
	DW	0133H
	DW	0137H
	DW	0139H
	DW	013dH
	DW	014bH
	DW	0151H
	DW	015bH
	DW	015dH
	DW	0161H
	DW	0167H
	DW	016fH
	DW	0175H
	DW	017bH
	DW	017fH
	DW	0185H
	DW	018dH
	DW	0191H
	DW	0199H
	DW	01a3H
	DW	01a5H
	DW	01afH
	DW	01b1H
	DW	01b7H
	DW	01bbH
	DW	01c1H
	DW	01c9H
	DW	01cdH
	DW	01cfH
	DW	01d3H
	DW	01dfH
	DW	01e7H
	DW	01ebH
	DW	01f3H
	DW	01f7H
	DW	01fdH
	DW	0209H
	DW	020bH
	DW	021dH
	DW	0223H
	DW	022dH
	DW	0233H
	DW	0239H
	DW	023bH
	DW	0241H
	DW	024bH
	DW	0251H
	DW	0257H
	DW	0259H
	DW	025fH
	DW	0265H
	DW	0269H
	DW	026bH
	DW	0277H
	DW	0281H
	DW	0283H
	DW	0287H
	DW	028dH
	DW	0293H
	DW	0295H
	DW	02a1H
	DW	02a5H
	DW	02abH
	DW	02b3H
	DW	02bdH
	DW	02c5H
	DW	02cfH
	DW	02d7H
	DW	02ddH
	DW	02e3H
	DW	02e7H
	DW	02efH
	DW	02f5H
	DW	02f9H
	DW	0301H
	DW	0305H
	DW	0313H
	DW	031dH
	DW	0329H
	DW	032bH
	DW	0335H
	DW	0337H
	DW	033bH
	DW	033dH
	DW	0347H
	DW	0355H
	DW	0359H
	DW	035bH
	DW	035fH
	DW	036dH
	DW	0371H
	DW	0373H
	DW	0377H
	DW	038bH
	DW	038fH
	DW	0397H
	DW	03a1H
	DW	03a9H
	DW	03adH
	DW	03b3H
	DW	03b9H
	DW	03c7H
	DW	03cbH
	DW	03d1H
	DW	03d7H
	DW	03dfH
	DW	03e5H
	DW	03f1H
	DW	03f5H
	DW	03fbH
	DW	03fdH
	DW	0407H
	DW	0409H
	DW	040fH
	DW	0419H
	DW	041bH
	DW	0425H
	DW	0427H
	DW	042dH
	DW	043fH
	DW	0443H
	DW	0445H
	DW	0449H
	DW	044fH
	DW	0455H
	DW	045dH
	DW	0463H
	DW	0469H
	DW	047fH
	DW	0481H
	DW	048bH
	DW	0493H
	DW	049dH
	DW	04a3H
	DW	04a9H
	DW	04b1H
	DW	04bdH
	DW	04c1H
	DW	04c7H
	DW	04cdH
	DW	04cfH
	DW	04d5H
	DW	04e1H
	DW	04ebH
	DW	04fdH
	DW	04ffH
	DW	0503H
	DW	0509H
	DW	050bH
	DW	0511H
	DW	0515H
	DW	0517H
	DW	051bH
	DW	0527H
	DW	0529H
	DW	052fH
	DW	0551H
	DW	0557H
	DW	055dH
	DW	0565H
	DW	0577H
	DW	0581H
	DW	058fH
	DW	0593H
	DW	0595H
	DW	0599H
	DW	059fH
	DW	05a7H
	DW	05abH
	DW	05adH
	DW	05b3H
	DW	05bfH
	DW	05c9H
	DW	05cbH
	DW	05cfH
	DW	05d1H
	DW	05d5H
	DW	05dbH
	DW	05e7H
	DW	05f3H
	DW	05fbH
	DW	0607H
	DW	060dH
	DW	0611H
	DW	0617H
	DW	061fH
	DW	0623H
	DW	062bH
	DW	062fH
	DW	063dH
	DW	0641H
	DW	0647H
	DW	0649H
	DW	064dH
	DW	0653H
	DW	0655H
CONST	ENDS
PUBLIC	??4PlayerID@@QAEAAU0@ABU0@@Z			; PlayerID::operator=
PUBLIC	??1RakPeerInterface@@UAE@XZ			; RakPeerInterface::~RakPeerInterface
PUBLIC	??0RakPeerInterface@@QAE@XZ			; RakPeerInterface::RakPeerInterface
PUBLIC	??_GRakPeerInterface@@UAEPAXI@Z			; RakPeerInterface::`scalar deleting destructor'
PUBLIC	?Instance@SocketLayer@@SAPAV1@XZ		; SocketLayer::Instance
PUBLIC	?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ	; RakNet::BitStream::GetNumberOfBitsUsed
PUBLIC	?GetWriteOffset@BitStream@RakNet@@QBEHXZ	; RakNet::BitStream::GetWriteOffset
PUBLIC	?GetNumberOfBytesUsed@BitStream@RakNet@@QBEHXZ	; RakNet::BitStream::GetNumberOfBytesUsed
PUBLIC	?GetNumberOfUnreadBits@BitStream@RakNet@@QBEHXZ	; RakNet::BitStream::GetNumberOfUnreadBits
PUBLIC	?GetData@BitStream@RakNet@@QBEPAEXZ		; RakNet::BitStream::GetData
PUBLIC	??$Write@_N@BitStream@RakNet@@QAEX_N@Z		; RakNet::BitStream::Write<bool>
PUBLIC	??$Write@UPlayerID@@@BitStream@RakNet@@QAEXUPlayerID@@@Z ; RakNet::BitStream::Write<PlayerID>
PUBLIC	??$Write@I@BitStream@RakNet@@QAEXI@Z		; RakNet::BitStream::Write<unsigned int>
PUBLIC	??$Write@G@BitStream@RakNet@@QAEXG@Z		; RakNet::BitStream::Write<unsigned short>
PUBLIC	??$Write@UNetworkID@@@BitStream@RakNet@@QAEXUNetworkID@@@Z ; RakNet::BitStream::Write<NetworkID>
PUBLIC	??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z	; RakNet::BitStream::Read<bool>
PUBLIC	??$Read@UPlayerID@@@BitStream@RakNet@@QAE_NAAUPlayerID@@@Z ; RakNet::BitStream::Read<PlayerID>
PUBLIC	??$Read@I@BitStream@RakNet@@QAE_NAAI@Z		; RakNet::BitStream::Read<unsigned int>
PUBLIC	??$Read@G@BitStream@RakNet@@QAE_NAAG@Z		; RakNet::BitStream::Read<unsigned short>
PUBLIC	??$Read@UNetworkID@@@BitStream@RakNet@@QAE_NAAUNetworkID@@@Z ; RakNet::BitStream::Read<NetworkID>
PUBLIC	??YRakNetStatisticsStruct@@QAE?AU0@ABU0@@Z	; RakNetStatisticsStruct::operator+=
PUBLIC	??4PlayerIDAndIndex@@QAEAAU0@ABU0@@Z		; PlayerIDAndIndex::operator=
PUBLIC	?PlayerIDAndIndexComp@@YAHABUPlayerID@@ABUPlayerIDAndIndex@@@Z ; PlayerIDAndIndexComp
PUBLIC	??0RakPeer@@QAE@XZ				; RakPeer::RakPeer
PUBLIC	??1RakPeer@@UAE@XZ				; RakPeer::~RakPeer
PUBLIC	?Initialize@RakPeer@@UAE_NGGHPBD@Z		; RakPeer::Initialize
PUBLIC	?InitializeSecurity@RakPeer@@UAEXPBD000@Z	; RakPeer::InitializeSecurity
PUBLIC	?DisableSecurity@RakPeer@@UAEXXZ		; RakPeer::DisableSecurity
PUBLIC	?SetMaximumIncomingConnections@RakPeer@@UAEXG@Z	; RakPeer::SetMaximumIncomingConnections
PUBLIC	?GetMaximumIncomingConnections@RakPeer@@UBEGXZ	; RakPeer::GetMaximumIncomingConnections
PUBLIC	?SetIncomingPassword@RakPeer@@UAEXPBDH@Z	; RakPeer::SetIncomingPassword
PUBLIC	?GetIncomingPassword@RakPeer@@UAEXPADPAH@Z	; RakPeer::GetIncomingPassword
PUBLIC	?Connect@RakPeer@@UAE_NPBDGPADH@Z		; RakPeer::Connect
PUBLIC	?Disconnect@RakPeer@@UAEXIE@Z			; RakPeer::Disconnect
PUBLIC	?IsActive@RakPeer@@UBE_NXZ			; RakPeer::IsActive
PUBLIC	?GetConnectionList@RakPeer@@UBE_NPAUPlayerID@@PAG@Z ; RakPeer::GetConnectionList
PUBLIC	?Send@RakPeer@@UAE_NPBDHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N@Z ; RakPeer::Send
PUBLIC	?Send@RakPeer@@UAE_NPAVBitStream@RakNet@@W4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N@Z ; RakPeer::Send
PUBLIC	?Receive@RakPeer@@UAEPAUPacket@@XZ		; RakPeer::Receive
PUBLIC	?DeallocatePacket@RakPeer@@UAEXPAUPacket@@@Z	; RakPeer::DeallocatePacket
PUBLIC	?GetMaximumNumberOfPeers@RakPeer@@UBEGXZ	; RakPeer::GetMaximumNumberOfPeers
PUBLIC	?RegisterAsRemoteProcedureCall@RakPeer@@UAEXPADP6AXPAURPCParameters@@@Z@Z ; RakPeer::RegisterAsRemoteProcedureCall
PUBLIC	?RegisterClassMemberRPC@RakPeer@@UAEXPADPAX@Z	; RakPeer::RegisterClassMemberRPC
PUBLIC	?UnregisterAsRemoteProcedureCall@RakPeer@@UAEXPAD@Z ; RakPeer::UnregisterAsRemoteProcedureCall
PUBLIC	?RPC@RakPeer@@UAE_NPADPBDIW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N5UNetworkID@@PAVBitStream@RakNet@@@Z ; RakPeer::RPC
PUBLIC	?RPC@RakPeer@@UAE_NPADPAVBitStream@RakNet@@W4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N5UNetworkID@@1@Z ; RakPeer::RPC
PUBLIC	?CloseConnection@RakPeer@@UAEXUPlayerID@@_NE@Z	; RakPeer::CloseConnection
PUBLIC	?GetIndexFromPlayerID@RakPeer@@UAEHUPlayerID@@@Z ; RakPeer::GetIndexFromPlayerID
PUBLIC	?GetPlayerIDFromIndex@RakPeer@@UAE?AUPlayerID@@H@Z ; RakPeer::GetPlayerIDFromIndex
PUBLIC	?AddToBanList@RakPeer@@UAEXPBDI@Z		; RakPeer::AddToBanList
PUBLIC	?RemoveFromBanList@RakPeer@@UAEXPBD@Z		; RakPeer::RemoveFromBanList
PUBLIC	?ClearBanList@RakPeer@@UAEXXZ			; RakPeer::ClearBanList
PUBLIC	?IsBanned@RakPeer@@UAE_NPBD@Z			; RakPeer::IsBanned
PUBLIC	?Ping@RakPeer@@UAEXUPlayerID@@@Z		; RakPeer::Ping
PUBLIC	?Ping@RakPeer@@UAEXPBDG_N@Z			; RakPeer::Ping
PUBLIC	?GetAveragePing@RakPeer@@UAEHUPlayerID@@@Z	; RakPeer::GetAveragePing
PUBLIC	?GetLastPing@RakPeer@@UBEHUPlayerID@@@Z		; RakPeer::GetLastPing
PUBLIC	?GetLowestPing@RakPeer@@UBEHUPlayerID@@@Z	; RakPeer::GetLowestPing
PUBLIC	?SetOccasionalPing@RakPeer@@UAEX_N@Z		; RakPeer::SetOccasionalPing
PUBLIC	?GetRemoteStaticData@RakPeer@@UAEPAVBitStream@RakNet@@UPlayerID@@@Z ; RakPeer::GetRemoteStaticData
PUBLIC	?SetRemoteStaticData@RakPeer@@UAEXUPlayerID@@PBDH@Z ; RakPeer::SetRemoteStaticData
PUBLIC	?SendStaticData@RakPeer@@UAEXUPlayerID@@@Z	; RakPeer::SendStaticData
PUBLIC	?SetOfflinePingResponse@RakPeer@@UAEXPBDI@Z	; RakPeer::SetOfflinePingResponse
PUBLIC	?GetInternalID@RakPeer@@UBE?AUPlayerID@@XZ	; RakPeer::GetInternalID
PUBLIC	?GetExternalID@RakPeer@@UBE?AUPlayerID@@U2@@Z	; RakPeer::GetExternalID
PUBLIC	?SetTimeoutTime@RakPeer@@UAEXIUPlayerID@@@Z	; RakPeer::SetTimeoutTime
PUBLIC	?SetMTUSize@RakPeer@@UAE_NH@Z			; RakPeer::SetMTUSize
PUBLIC	?GetMTUSize@RakPeer@@UBEHXZ			; RakPeer::GetMTUSize
PUBLIC	?GetNumberOfAddresses@RakPeer@@UAEIXZ		; RakPeer::GetNumberOfAddresses
PUBLIC	?GetLocalIP@RakPeer@@UAEPBDI@Z			; RakPeer::GetLocalIP
PUBLIC	?PlayerIDToDottedIP@RakPeer@@UBEPBDUPlayerID@@@Z ; RakPeer::PlayerIDToDottedIP
PUBLIC	?IPToPlayerID@RakPeer@@UAEXPBDGPAUPlayerID@@@Z	; RakPeer::IPToPlayerID
PUBLIC	?AllowConnectionResponseIPMigration@RakPeer@@UAEX_N@Z ; RakPeer::AllowConnectionResponseIPMigration
PUBLIC	?AdvertiseSystem@RakPeer@@UAEXPBDG0H@Z		; RakPeer::AdvertiseSystem
PUBLIC	?SetSplitMessageProgressInterval@RakPeer@@UAEXH@Z ; RakPeer::SetSplitMessageProgressInterval
PUBLIC	?SetUnreliableTimeout@RakPeer@@UAEXI@Z		; RakPeer::SetUnreliableTimeout
PUBLIC	?SetCompileFrequencyTable@RakPeer@@UAEX_N@Z	; RakPeer::SetCompileFrequencyTable
PUBLIC	?GetOutgoingFrequencyTable@RakPeer@@UAE_NQAI@Z	; RakPeer::GetOutgoingFrequencyTable
PUBLIC	?GenerateCompressionLayer@RakPeer@@UAE_NQAI_N@Z	; RakPeer::GenerateCompressionLayer
PUBLIC	?DeleteCompressionLayer@RakPeer@@UAE_N_N@Z	; RakPeer::DeleteCompressionLayer
PUBLIC	?GetCompressionRatio@RakPeer@@UBEMXZ		; RakPeer::GetCompressionRatio
PUBLIC	?GetDecompressionRatio@RakPeer@@UBEMXZ		; RakPeer::GetDecompressionRatio
PUBLIC	?AttachPlugin@RakPeer@@UAEXPAVPluginInterface@@@Z ; RakPeer::AttachPlugin
PUBLIC	?DetachPlugin@RakPeer@@UAEXPAVPluginInterface@@@Z ; RakPeer::DetachPlugin
PUBLIC	?PushBackPacket@RakPeer@@UAEXPAUPacket@@_N@Z	; RakPeer::PushBackPacket
PUBLIC	?SetRouterInterface@RakPeer@@UAEXPAVRouterInterface@@@Z ; RakPeer::SetRouterInterface
PUBLIC	?RemoveRouterInterface@RakPeer@@UAEXPAVRouterInterface@@@Z ; RakPeer::RemoveRouterInterface
PUBLIC	?ApplyNetworkSimulator@RakPeer@@UAEXNGG@Z	; RakPeer::ApplyNetworkSimulator
PUBLIC	?IsNetworkSimulatorActive@RakPeer@@UAE_NXZ	; RakPeer::IsNetworkSimulatorActive
PUBLIC	?GetStatistics@RakPeer@@UAEQAURakNetStatisticsStruct@@UPlayerID@@@Z ; RakPeer::GetStatistics
PUBLIC	?GetRPCMap@RakPeer@@UAEPAURPCMap@@UPlayerID@@@Z	; RakPeer::GetRPCMap
PUBLIC	??0RemoteSystemStruct@RakPeer@@QAE@XZ		; RakPeer::RemoteSystemStruct::RemoteSystemStruct
PUBLIC	??1RemoteSystemStruct@RakPeer@@QAE@XZ		; RakPeer::RemoteSystemStruct::~RemoteSystemStruct
PUBLIC	??_ERemoteSystemStruct@RakPeer@@QAEPAXI@Z	; RakPeer::RemoteSystemStruct::`vector deleting destructor'
PUBLIC	?ProcessPortUnreachable@@YGXIGPAVRakPeer@@@Z	; ProcessPortUnreachable
PUBLIC	?ProcessNetworkPacket@@YGXIGPBDHPAVRakPeer@@@Z	; ProcessNetworkPacket
PUBLIC	?UpdateNetworkLoop@@YGIPAX@Z			; UpdateNetworkLoop
PUBLIC	?ReceiveIgnoreRPC@RakPeer@@IAEPAUPacket@@XZ	; RakPeer::ReceiveIgnoreRPC
PUBLIC	?GetIndexFromPlayerID@RakPeer@@IAEHUPlayerID@@_N@Z ; RakPeer::GetIndexFromPlayerID
PUBLIC	?SendConnectionRequest@RakPeer@@IAE_NPBDGPADH@Z	; RakPeer::SendConnectionRequest
PUBLIC	?GetRemoteSystemFromPlayerID@RakPeer@@IBEPAURemoteSystemStruct@1@UPlayerID@@_N1@Z ; RakPeer::GetRemoteSystemFromPlayerID
PUBLIC	?ParseConnectionRequestPacket@RakPeer@@IAEXPAURemoteSystemStruct@1@UPlayerID@@PBDH@Z ; RakPeer::ParseConnectionRequestPacket
PUBLIC	?OnConnectionRequest@RakPeer@@IAEXPAURemoteSystemStruct@1@PAE_N@Z ; RakPeer::OnConnectionRequest
PUBLIC	?NotifyAndFlagForDisconnect@RakPeer@@IAEXUPlayerID@@_NE@Z ; RakPeer::NotifyAndFlagForDisconnect
PUBLIC	?GetNumberOfRemoteInitiatedConnections@RakPeer@@IBEGXZ ; RakPeer::GetNumberOfRemoteInitiatedConnections
PUBLIC	?AssignPlayerIDToRemoteSystemList@RakPeer@@IAEPAURemoteSystemStruct@1@UPlayerID@@W4ConnectMode@21@@Z ; RakPeer::AssignPlayerIDToRemoteSystemList
PUBLIC	?ShiftIncomingTimestamp@RakPeer@@IBEXPAEUPlayerID@@@Z ; RakPeer::ShiftIncomingTimestamp
PUBLIC	?GetBestClockDifferential@RakPeer@@IBEIUPlayerID@@@Z ; RakPeer::GetBestClockDifferential
PUBLIC	?HandleRPCPacket@RakPeer@@IAE_NPBDHUPlayerID@@@Z ; RakPeer::HandleRPCPacket
PUBLIC	?HandleRPCReplyPacket@RakPeer@@IAEXPBDHUPlayerID@@@Z ; RakPeer::HandleRPCReplyPacket
PUBLIC	??0?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>
PUBLIC	??1?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>::~OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>
PUBLIC	?GetIndexFromKey@?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QBEIABUPlayerID@@PA_N@Z ; DataStructures::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>::GetIndexFromKey
PUBLIC	?Insert@?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QAEIABUPlayerID@@ABUPlayerIDAndIndex@@@Z ; DataStructures::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>::Insert
PUBLIC	?Remove@?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QAEIABUPlayerID@@@Z ; DataStructures::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>::Remove
PUBLIC	??A?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QBEAAUPlayerIDAndIndex@@I@Z ; DataStructures::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>::operator[]
PUBLIC	?Clear@?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QAEXXZ ; DataStructures::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>::Clear
PUBLIC	??0?$List@UPlayerIDAndIndex@@@DataStructures@@QAE@XZ ; DataStructures::List<PlayerIDAndIndex>::List<PlayerIDAndIndex>
PUBLIC	??1?$List@UPlayerIDAndIndex@@@DataStructures@@QAE@XZ ; DataStructures::List<PlayerIDAndIndex>::~List<PlayerIDAndIndex>
PUBLIC	??A?$List@UPlayerIDAndIndex@@@DataStructures@@QBEAAUPlayerIDAndIndex@@I@Z ; DataStructures::List<PlayerIDAndIndex>::operator[]
PUBLIC	?Insert@?$List@UPlayerIDAndIndex@@@DataStructures@@QAEXUPlayerIDAndIndex@@I@Z ; DataStructures::List<PlayerIDAndIndex>::Insert
PUBLIC	?Insert@?$List@UPlayerIDAndIndex@@@DataStructures@@QAEXUPlayerIDAndIndex@@@Z ; DataStructures::List<PlayerIDAndIndex>::Insert
PUBLIC	?RemoveAtIndex@?$List@UPlayerIDAndIndex@@@DataStructures@@QAEXI@Z ; DataStructures::List<PlayerIDAndIndex>::RemoveAtIndex
PUBLIC	?Del@?$List@UPlayerIDAndIndex@@@DataStructures@@QAEXI@Z ; DataStructures::List<PlayerIDAndIndex>::Del
PUBLIC	?Size@?$List@UPlayerIDAndIndex@@@DataStructures@@QBEIXZ ; DataStructures::List<PlayerIDAndIndex>::Size
PUBLIC	?Clear@?$List@UPlayerIDAndIndex@@@DataStructures@@QAEX_N@Z ; DataStructures::List<PlayerIDAndIndex>::Clear
PUBLIC	??0?$List@PAUBanStruct@RakPeer@@@DataStructures@@QAE@XZ ; DataStructures::List<RakPeer::BanStruct *>::List<RakPeer::BanStruct *>
PUBLIC	??1?$List@PAUBanStruct@RakPeer@@@DataStructures@@QAE@XZ ; DataStructures::List<RakPeer::BanStruct *>::~List<RakPeer::BanStruct *>
PUBLIC	??A?$List@PAUBanStruct@RakPeer@@@DataStructures@@QBEAAPAUBanStruct@RakPeer@@I@Z ; DataStructures::List<RakPeer::BanStruct *>::operator[]
PUBLIC	?Insert@?$List@PAUBanStruct@RakPeer@@@DataStructures@@QAEXQAUBanStruct@RakPeer@@@Z ; DataStructures::List<RakPeer::BanStruct *>::Insert
PUBLIC	?RemoveAtIndex@?$List@PAUBanStruct@RakPeer@@@DataStructures@@QAEXI@Z ; DataStructures::List<RakPeer::BanStruct *>::RemoveAtIndex
PUBLIC	?Del@?$List@PAUBanStruct@RakPeer@@@DataStructures@@QAEXI@Z ; DataStructures::List<RakPeer::BanStruct *>::Del
PUBLIC	?Size@?$List@PAUBanStruct@RakPeer@@@DataStructures@@QBEIXZ ; DataStructures::List<RakPeer::BanStruct *>::Size
PUBLIC	?Clear@?$List@PAUBanStruct@RakPeer@@@DataStructures@@QAEX_N@Z ; DataStructures::List<RakPeer::BanStruct *>::Clear
PUBLIC	??0?$List@PAVPluginInterface@@@DataStructures@@QAE@XZ ; DataStructures::List<PluginInterface *>::List<PluginInterface *>
PUBLIC	??1?$List@PAVPluginInterface@@@DataStructures@@QAE@XZ ; DataStructures::List<PluginInterface *>::~List<PluginInterface *>
PUBLIC	??A?$List@PAVPluginInterface@@@DataStructures@@QBEAAPAVPluginInterface@@I@Z ; DataStructures::List<PluginInterface *>::operator[]
PUBLIC	?Insert@?$List@PAVPluginInterface@@@DataStructures@@QAEXQAVPluginInterface@@@Z ; DataStructures::List<PluginInterface *>::Insert
PUBLIC	?Del@?$List@PAVPluginInterface@@@DataStructures@@QAEXI@Z ; DataStructures::List<PluginInterface *>::Del
PUBLIC	?GetIndexOf@?$List@PAVPluginInterface@@@DataStructures@@QAEIQAVPluginInterface@@@Z ; DataStructures::List<PluginInterface *>::GetIndexOf
PUBLIC	?Size@?$List@PAVPluginInterface@@@DataStructures@@QBEIXZ ; DataStructures::List<PluginInterface *>::Size
PUBLIC	??0?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAE@XZ ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>
PUBLIC	??1?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAE@XZ ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::~SingleProducerConsumer<RakPeer::RequestedConnectionStruct>
PUBLIC	?WriteLock@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEPAURequestedConnectionStruct@RakPeer@@XZ ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::WriteLock
PUBLIC	?WriteUnlock@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEXXZ ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::WriteUnlock
PUBLIC	?ReadLock@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEPAURequestedConnectionStruct@RakPeer@@XZ ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::ReadLock
PUBLIC	?CancelReadLock@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEXPAURequestedConnectionStruct@RakPeer@@@Z ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::CancelReadLock
PUBLIC	?ReadUnlock@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEXXZ ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::ReadUnlock
PUBLIC	?Clear@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEXXZ ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::Clear
PUBLIC	?GenerateSYNCookieRandomNumber@RakPeer@@IAEXXZ	; RakPeer::GenerateSYNCookieRandomNumber
PUBLIC	?SecuredConnectionResponse@RakPeer@@IAEXUPlayerID@@@Z ; RakPeer::SecuredConnectionResponse
PUBLIC	?SecuredConnectionConfirmation@RakPeer@@IAEXPAURemoteSystemStruct@1@PAD@Z ; RakPeer::SecuredConnectionConfirmation
PUBLIC	?RunUpdateCycle@RakPeer@@IAE_NXZ		; RakPeer::RunUpdateCycle
PUBLIC	??0?$SingleProducerConsumer@UBufferedCommandStruct@RakPeer@@@DataStructures@@QAE@XZ ; DataStructures::SingleProducerConsumer<RakPeer::BufferedCommandStruct>::SingleProducerConsumer<RakPeer::BufferedCommandStruct>
PUBLIC	??1?$SingleProducerConsumer@UBufferedCommandStruct@RakPeer@@@DataStructures@@QAE@XZ ; DataStructures::SingleProducerConsumer<RakPeer::BufferedCommandStruct>::~SingleProducerConsumer<RakPeer::BufferedCommandStruct>
PUBLIC	?WriteLock@?$SingleProducerConsumer@UBufferedCommandStruct@RakPeer@@@DataStructures@@QAEPAUBufferedCommandStruct@RakPeer@@XZ ; DataStructures::SingleProducerConsumer<RakPeer::BufferedCommandStruct>::WriteLock
PUBLIC	?WriteUnlock@?$SingleProducerConsumer@UBufferedCommandStruct@RakPeer@@@DataStructures@@QAEXXZ ; DataStructures::SingleProducerConsumer<RakPeer::BufferedCommandStruct>::WriteUnlock
PUBLIC	?ReadLock@?$SingleProducerConsumer@UBufferedCommandStruct@RakPeer@@@DataStructures@@QAEPAUBufferedCommandStruct@RakPeer@@XZ ; DataStructures::SingleProducerConsumer<RakPeer::BufferedCommandStruct>::ReadLock
PUBLIC	?ReadUnlock@?$SingleProducerConsumer@UBufferedCommandStruct@RakPeer@@@DataStructures@@QAEXXZ ; DataStructures::SingleProducerConsumer<RakPeer::BufferedCommandStruct>::ReadUnlock
PUBLIC	?Clear@?$SingleProducerConsumer@UBufferedCommandStruct@RakPeer@@@DataStructures@@QAEXXZ ; DataStructures::SingleProducerConsumer<RakPeer::BufferedCommandStruct>::Clear
PUBLIC	?AllowIncomingConnections@RakPeer@@IBE_NXZ	; RakPeer::AllowIncomingConnections
PUBLIC	?SendStaticDataInternal@RakPeer@@IAEXUPlayerID@@_N@Z ; RakPeer::SendStaticDataInternal
PUBLIC	?PingInternal@RakPeer@@IAEXUPlayerID@@_N@Z	; RakPeer::PingInternal
PUBLIC	?ValidSendTarget@RakPeer@@IAE_NUPlayerID@@_N@Z	; RakPeer::ValidSendTarget
PUBLIC	?CloseConnectionInternal@RakPeer@@IAEXUPlayerID@@_N1E@Z ; RakPeer::CloseConnectionInternal
PUBLIC	?SendBuffered@RakPeer@@IAEXPBDHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_NW4ConnectMode@RemoteSystemStruct@1@@Z ; RakPeer::SendBuffered
PUBLIC	?SendImmediate@RakPeer@@IAE_NPADHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N4_J@Z ; RakPeer::SendImmediate
PUBLIC	?ClearBufferedCommands@RakPeer@@IAEXXZ		; RakPeer::ClearBufferedCommands
PUBLIC	?ClearRequestedConnectionList@RakPeer@@IAEXXZ	; RakPeer::ClearRequestedConnectionList
PUBLIC	?AddPacketToProducer@RakPeer@@IAEXPAUPacket@@@Z	; RakPeer::AddPacketToProducer
PUBLIC	??0?$RSACrypt@$$BY07I@big@@QAE@XZ		; big::RSACrypt<unsigned int [8]>::RSACrypt<unsigned int [8]>
PUBLIC	??1?$RSACrypt@$$BY07I@big@@QAE@XZ		; big::RSACrypt<unsigned int [8]>::~RSACrypt<unsigned int [8]>
PUBLIC	?reset@?$RSACrypt@$$BY07I@big@@QAEXXZ		; big::RSACrypt<unsigned int [8]>::reset
PUBLIC	?generateKeys@?$RSACrypt@$$BY07I@big@@QAEXXZ	; big::RSACrypt<unsigned int [8]>::generateKeys
PUBLIC	?setPublicKey@?$RSACrypt@$$BY07I@big@@QAEXIAAY07I@Z ; big::RSACrypt<unsigned int [8]>::setPublicKey
PUBLIC	?getPublicKey@?$RSACrypt@$$BY07I@big@@QAEXAAIAAY07I@Z ; big::RSACrypt<unsigned int [8]>::getPublicKey
PUBLIC	?encrypt@?$RSACrypt@$$BY07I@big@@QAEXAAY07I0@Z	; big::RSACrypt<unsigned int [8]>::encrypt
PUBLIC	?decrypt@?$RSACrypt@$$BY07I@big@@QAEXAAY07I0@Z	; big::RSACrypt<unsigned int [8]>::decrypt
PUBLIC	??0?$SingleProducerConsumer@PAUPacket@@@DataStructures@@QAE@XZ ; DataStructures::SingleProducerConsumer<Packet *>::SingleProducerConsumer<Packet *>
PUBLIC	??1?$SingleProducerConsumer@PAUPacket@@@DataStructures@@QAE@XZ ; DataStructures::SingleProducerConsumer<Packet *>::~SingleProducerConsumer<Packet *>
PUBLIC	?WriteLock@?$SingleProducerConsumer@PAUPacket@@@DataStructures@@QAEPAPAUPacket@@XZ ; DataStructures::SingleProducerConsumer<Packet *>::WriteLock
PUBLIC	?WriteUnlock@?$SingleProducerConsumer@PAUPacket@@@DataStructures@@QAEXXZ ; DataStructures::SingleProducerConsumer<Packet *>::WriteUnlock
PUBLIC	?ReadLock@?$SingleProducerConsumer@PAUPacket@@@DataStructures@@QAEPAPAUPacket@@XZ ; DataStructures::SingleProducerConsumer<Packet *>::ReadLock
PUBLIC	?ReadUnlock@?$SingleProducerConsumer@PAUPacket@@@DataStructures@@QAEXXZ ; DataStructures::SingleProducerConsumer<Packet *>::ReadUnlock
PUBLIC	?Clear@?$SingleProducerConsumer@PAUPacket@@@DataStructures@@QAEXXZ ; DataStructures::SingleProducerConsumer<Packet *>::Clear
PUBLIC	??0?$Queue@PAUPacket@@@DataStructures@@QAE@XZ	; DataStructures::Queue<Packet *>::Queue<Packet *>
PUBLIC	??1?$Queue@PAUPacket@@@DataStructures@@QAE@XZ	; DataStructures::Queue<Packet *>::~Queue<Packet *>
PUBLIC	?Push@?$Queue@PAUPacket@@@DataStructures@@QAEXABQAUPacket@@@Z ; DataStructures::Queue<Packet *>::Push
PUBLIC	?PushAtHead@?$Queue@PAUPacket@@@DataStructures@@QAEXABQAUPacket@@I@Z ; DataStructures::Queue<Packet *>::PushAtHead
PUBLIC	??A?$Queue@PAUPacket@@@DataStructures@@QBEAAPAUPacket@@I@Z ; DataStructures::Queue<Packet *>::operator[]
PUBLIC	?Pop@?$Queue@PAUPacket@@@DataStructures@@QAEPAUPacket@@XZ ; DataStructures::Queue<Packet *>::Pop
PUBLIC	?Size@?$Queue@PAUPacket@@@DataStructures@@QBEIXZ ; DataStructures::Queue<Packet *>::Size
PUBLIC	?Clear@?$Queue@PAUPacket@@@DataStructures@@QAEXXZ ; DataStructures::Queue<Packet *>::Clear
PUBLIC	??_GRakPeer@@UAEPAXI@Z				; RakPeer::`scalar deleting destructor'
PUBLIC	??_GHuffmanEncodingTree@@QAEPAXI@Z		; HuffmanEncodingTree::`scalar deleting destructor'
PUBLIC	?AllocPacket@@YAPAUPacket@@I@Z			; AllocPacket
PUBLIC	?AllocPacket@@YAPAUPacket@@IPAE@Z		; AllocPacket
PUBLIC	??$setPrivateKey@$$BY03I@?$RSACrypt@$$BY07I@big@@QAEXAAY03I0@Z ; big::RSACrypt<unsigned int [8]>::setPrivateKey<unsigned int [4]>
PUBLIC	??$Write@E@BitStream@RakNet@@QAEXE@Z		; RakNet::BitStream::Write<unsigned char>
PUBLIC	??$WriteCompressed@E@BitStream@RakNet@@QAEXE@Z	; RakNet::BitStream::WriteCompressed<unsigned char>
PUBLIC	??$WriteCompressed@I@BitStream@RakNet@@QAEXI@Z	; RakNet::BitStream::WriteCompressed<unsigned int>
PUBLIC	??$ReadCompressed@E@BitStream@RakNet@@QAE_NAAE@Z ; RakNet::BitStream::ReadCompressed<unsigned char>
PUBLIC	??$ReadCompressed@I@BitStream@RakNet@@QAE_NAAI@Z ; RakNet::BitStream::ReadCompressed<unsigned int>
PUBLIC	??$generateStrongPseudoPrime@$$BY03I@big@@YAXAAY03I@Z ; big::generateStrongPseudoPrime<unsigned int [4]>
PUBLIC	??$usetw@$$BY07I@big@@YAXAAY07II@Z		; big::usetw<unsigned int [8]>
PUBLIC	??$set@$$BY07I@big@@YAXAAY07I0@Z		; big::set<unsigned int [8]>
PUBLIC	??$computeNRinverse@$$BY07I@big@@YAXAAY07I0@Z	; big::computeNRinverse<unsigned int [8]>
PUBLIC	??$rModn@$$BY07I@big@@YAXAAY07I0@Z		; big::rModn<unsigned int [8]>
PUBLIC	??$CRTModExp@$$BY03I$$BY07I@big@@YAXAAY07I00AAY03I111111@Z ; big::CRTModExp<unsigned int [4],unsigned int [8]>
PUBLIC	??$simpleModExp@$$BY07I@big@@YAXAAY07I000@Z	; big::simpleModExp<unsigned int [8]>
PUBLIC	??$zero@$$BY07I@big@@YAXAAY07I@Z		; big::zero<unsigned int [8]>
PUBLIC	??$zero@$$BY03I@big@@YAXAAY03I@Z		; big::zero<unsigned int [4]>
PUBLIC	??$ugreater@$$BY03I@big@@YA_NAAY03I0@Z		; big::ugreater<unsigned int [4]>
PUBLIC	??$set@$$BY03I@big@@YAXAAY03I0@Z		; big::set<unsigned int [4]>
PUBLIC	??$decrement@$$BY03I@big@@YAXAAY03I@Z		; big::decrement<unsigned int [4]>
PUBLIC	??$umultiply@$$BY03I$$BY07I@big@@YAXAAY03I0AAY07I@Z ; big::umultiply<unsigned int [4],unsigned int [8]>
PUBLIC	??$computePublicExponent@$$BY07I@big@@YAXAAY07I0@Z ; big::computePublicExponent<unsigned int [8]>
PUBLIC	??$computePrivateExponent@$$BY07I@big@@YAXAAY07I00@Z ; big::computePrivateExponent<unsigned int [8]>
PUBLIC	??$computeModularInverse@$$BY03I@big@@YAXAAY03I00@Z ; big::computeModularInverse<unsigned int [4]>
PUBLIC	??$computeNRinverse@$$BY03I@big@@YAXAAY03I0@Z	; big::computeNRinverse<unsigned int [4]>
PUBLIC	??$rModn@$$BY03I@big@@YAXAAY03I0@Z		; big::rModn<unsigned int [4]>
PUBLIC	??$RabinMillerPrimalityTest@$$BY03I@big@@YA_NAAY03II@Z ; big::RabinMillerPrimalityTest<unsigned int [4]>
PUBLIC	??$computeRinverse@$$BY07I@big@@YAXAAY07I0@Z	; big::computeRinverse<unsigned int [8]>
PUBLIC	??$sethigh@$$BY07I$$BY0BA@I@big@@YAXAAY0BA@IAAY07I@Z ; big::sethigh<unsigned int [8],unsigned int [16]>
PUBLIC	??$decrement@$$BY0BA@I@big@@YAXAAY0BA@I@Z	; big::decrement<unsigned int [16]>
PUBLIC	??$usetlow@$$BY07I$$BY0BA@I@big@@YAXAAY0BA@IAAY07I@Z ; big::usetlow<unsigned int [8],unsigned int [16]>
PUBLIC	??$udivide@$$BY0BA@I@big@@YAXAAY0BA@I000@Z	; big::udivide<unsigned int [16]>
PUBLIC	??$takelow@$$BY07I$$BY0BA@I@big@@YAXAAY07IAAY0BA@I@Z ; big::takelow<unsigned int [8],unsigned int [16]>
PUBLIC	??$umodulo@$$BY0BA@I@big@@YAXAAY0BA@I00@Z	; big::umodulo<unsigned int [16]>
PUBLIC	??$usetlow@$$BY03I$$BY07I@big@@YAXAAY07IAAY03I@Z ; big::usetlow<unsigned int [4],unsigned int [8]>
PUBLIC	??$decrement@$$BY07I@big@@YAXAAY07I@Z		; big::decrement<unsigned int [8]>
PUBLIC	??$umodulo@$$BY07I@big@@YAXAAY07I00@Z		; big::umodulo<unsigned int [8]>
PUBLIC	??$takelow@$$BY03I$$BY07I@big@@YAXAAY03IAAY07I@Z ; big::takelow<unsigned int [4],unsigned int [8]>
PUBLIC	??$simpleModExp@$$BY03I@big@@YAXAAY03I000@Z	; big::simpleModExp<unsigned int [4]>
PUBLIC	??$subtract@$$BY03I@big@@YAXAAY03I0@Z		; big::subtract<unsigned int [4]>
PUBLIC	??$add@$$BY03I@big@@YAXAAY03I0@Z		; big::add<unsigned int [4]>
PUBLIC	??$umultiply@$$BY07I$$BY07I@big@@YAXAAY07I0@Z	; big::umultiply<unsigned int [8],unsigned int [8]>
PUBLIC	??$add@$$BY07I@big@@YAXAAY07I0@Z		; big::add<unsigned int [8]>
PUBLIC	??$usetw@$$BY0BA@I@big@@YAXAAY0BA@II@Z		; big::usetw<unsigned int [16]>
PUBLIC	??$usquare@$$BY0BA@I@big@@YAXAAY0BA@I@Z		; big::usquare<unsigned int [16]>
PUBLIC	??$umultiply@$$BY0BA@I$$BY0BA@I@big@@YAXAAY0BA@I00@Z ; big::umultiply<unsigned int [16],unsigned int [16]>
PUBLIC	??$shiftLeft@$$BY07I@big@@YAXAAY07II@Z		; big::shiftLeft<unsigned int [8]>
PUBLIC	??$ugreater@$$BY07I@big@@YA_NAAY07I0@Z		; big::ugreater<unsigned int [8]>
PUBLIC	??$GCD@$$BY07I@big@@YAXAAY07I00@Z		; big::GCD<unsigned int [8]>
PUBLIC	??$equal@$$BY07I@big@@YA_NAAY07I0@Z		; big::equal<unsigned int [8]>
PUBLIC	??$computeModularInverse@$$BY07I@big@@YAXAAY07I00@Z ; big::computeModularInverse<unsigned int [8]>
PUBLIC	??$usetw@$$BY03I@big@@YAXAAY03II@Z		; big::usetw<unsigned int [4]>
PUBLIC	??$udivide@$$BY03I@big@@YAXAAY03I000@Z		; big::udivide<unsigned int [4]>
PUBLIC	??$isZero@$$BY03I@big@@YA_NAAY03I@Z		; big::isZero<unsigned int [4]>
PUBLIC	??$SubMulMod@$$BY03I@big@@YAXAAY03I0000@Z	; big::SubMulMod<unsigned int [4]>
PUBLIC	??$computeRinverse@$$BY03I@big@@YAXAAY03I0@Z	; big::computeRinverse<unsigned int [4]>
PUBLIC	??$sethigh@$$BY03I$$BY07I@big@@YAXAAY07IAAY03I@Z ; big::sethigh<unsigned int [4],unsigned int [8]>
PUBLIC	??$udivide@$$BY07I@big@@YAXAAY07I000@Z		; big::udivide<unsigned int [8]>
PUBLIC	??$umodulo@$$BY03I@big@@YAXAAY03I00@Z		; big::umodulo<unsigned int [4]>
PUBLIC	??$ushiftRight1@$$BY03I@big@@YAXAAY03I@Z	; big::ushiftRight1<unsigned int [4]>
PUBLIC	??$equal@$$BY03I@big@@YA_NAAY03I0@Z		; big::equal<unsigned int [4]>
PUBLIC	??$isZero@$$BY07I@big@@YA_NAAY07I@Z		; big::isZero<unsigned int [8]>
PUBLIC	??$subtract@$$BY07I@big@@YAXAAY07I0@Z		; big::subtract<unsigned int [8]>
PUBLIC	??$SubMulMod@$$BY07I@big@@YAXAAY07I0000@Z	; big::SubMulMod<unsigned int [8]>
PUBLIC	??$set@$$BY0BA@I@big@@YAXAAY0BA@I0@Z		; big::set<unsigned int [16]>
PUBLIC	??$zero@$$BY0BA@I@big@@YAXAAY0BA@I@Z		; big::zero<unsigned int [16]>
PUBLIC	??$ugreater@$$BY0BA@I@big@@YA_NAAY0BA@I0@Z	; big::ugreater<unsigned int [16]>
PUBLIC	??$shiftLeft@$$BY0BA@I@big@@YAXAAY0BA@II@Z	; big::shiftLeft<unsigned int [16]>
PUBLIC	??$shiftLeft1@$$BY0BA@I@big@@YAXAAY0BA@I@Z	; big::shiftLeft1<unsigned int [16]>
PUBLIC	??$ushiftRight1@$$BY0BA@I@big@@YAXAAY0BA@I@Z	; big::ushiftRight1<unsigned int [16]>
PUBLIC	??$subtract@$$BY0BA@I@big@@YAXAAY0BA@I0@Z	; big::subtract<unsigned int [16]>
PUBLIC	??$shiftLeft1@$$BY07I@big@@YAXAAY07I@Z		; big::shiftLeft1<unsigned int [8]>
PUBLIC	??$ushiftRight1@$$BY07I@big@@YAXAAY07I@Z	; big::ushiftRight1<unsigned int [8]>
PUBLIC	??$usquare@$$BY07I@big@@YAXAAY07I@Z		; big::usquare<unsigned int [8]>
PUBLIC	??$umultiply@$$BY07I$$BY07I@big@@YAXAAY07I00@Z	; big::umultiply<unsigned int [8],unsigned int [8]>
PUBLIC	??$add@$$BY0BA@I@big@@YAXAAY0BA@I0@Z		; big::add<unsigned int [16]>
PUBLIC	??$usetlow@$$BY0BA@I$$BY0BA@I@big@@YAXAAY0BA@I0@Z ; big::usetlow<unsigned int [16],unsigned int [16]>
PUBLIC	??$shiftLeft@$$BY03I@big@@YAXAAY03II@Z		; big::shiftLeft<unsigned int [4]>
PUBLIC	??$shiftLeft1@$$BY03I@big@@YAXAAY03I@Z		; big::shiftLeft1<unsigned int [4]>
PUBLIC	??$umultiply@$$BY03I$$BY07I@big@@YAXAAY07IAAY03I@Z ; big::umultiply<unsigned int [4],unsigned int [8]>
PUBLIC	??$umultiply@$$BY07I$$BY0BA@I@big@@YAXAAY0BA@IAAY07I@Z ; big::umultiply<unsigned int [8],unsigned int [16]>
PUBLIC	??$usetlow@$$BY07I$$BY07I@big@@YAXAAY07I0@Z	; big::usetlow<unsigned int [8],unsigned int [8]>
PUBLIC	??_7RakPeerInterface@@6B@			; RakPeerInterface::`vftable'
PUBLIC	??_7RakPeer@@6B@				; RakPeer::`vftable'
PUBLIC	?__LINE__Var@?1??Initialize@RakPeer@@UAE_NGGHPBD@Z@4JA ; `RakPeer::Initialize'::`2'::__LINE__Var
PUBLIC	??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@ ; `string'
PUBLIC	??_C@_1CG@FBMJBJBI@?$AAm?$AAa?$AAx?$AAC?$AAo?$AAn?$AAn?$AAe?$AAc?$AAt?$AAi?$AAo?$AAn?$AAs?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??InitializeSecurity@RakPeer@@UAEXPBD000@Z@4JA ; `RakPeer::InitializeSecurity'::`2'::__LINE__Var
PUBLIC	??_C@_13COJANIEC@?$AA0?$AA?$AA@			; `string'
PUBLIC	??_C@_09PFCHIMEP@127?40?40?41?$AA@		; `string'
PUBLIC	??_C@_07OHKHACFK@0?40?40?40?$AA@		; `string'
PUBLIC	?__LINE__Var@?1??Send@RakPeer@@UAE_NPBDHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N@Z@4JA ; `RakPeer::Send'::`2'::__LINE__Var
PUBLIC	??_C@_1CG@KMHNBCAF@?$AAd?$AAa?$AAt?$AAa?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??Send@RakPeer@@UAE_NPAVBitStream@RakNet@@W4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N@Z@4JA ; `RakPeer::Send'::`2'::__LINE__Var
PUBLIC	??_C@_1EM@PPKFOLDM@?$AAb?$AAi?$AAt?$AAS?$AAt?$AAr?$AAe?$AAa?$AAm?$AA?9?$AA?$DO?$AAG?$AAe?$AAt?$AAN?$AAu?$AAm?$AAb?$AAe?$AAr?$AAO?$AAf?$AAB?$AAy?$AAt?$AAe?$AAs?$AAU?$AAs?$AAe?$AAd?$AA?$CI@ ; `string'
PUBLIC	?__LINE__Var@?1??ReceiveIgnoreRPC@RakPeer@@IAEPAUPacket@@XZ@4JA ; `RakPeer::ReceiveIgnoreRPC'::`2'::__LINE__Var
PUBLIC	??_C@_1BK@NGDKLLMA@?$AAp?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??UnregisterAsRemoteProcedureCall@RakPeer@@UAEXPAD@Z@4JA ; `RakPeer::UnregisterAsRemoteProcedureCall'::`2'::__LINE__Var
PUBLIC	??_C@_1CE@HHNGILKN@?$AAI?$AAs?$AAA?$AAc?$AAt?$AAi?$AAv?$AAe?$AA?$CI?$AA?$CJ?$AA?$DN?$AA?$DN?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??RPC@RakPeer@@UAE_NPADPBDIW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N5UNetworkID@@PAVBitStream@RakNet@@@Z@4JA ; `RakPeer::RPC'::`2'::__LINE__Var
PUBLIC	??_C@_1DE@MNMFCGFF@?$AAu?$AAn?$AAi?$AAq?$AAu?$AAe?$AAI?$AAD?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAu?$AAn?$AAi?$AAq?$AAu?$AAe?$AAI?$AAD?$AA?$FL?$AA?5?$AA0?$AA?5?$AA?$FN?$AA?$AA@ ; `string'
PUBLIC	??_C@_1FI@DAMMCKDJ@?$AAo?$AAr?$AAd?$AAe?$AAr?$AAi?$AAn?$AAg?$AAC?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AA?5?$AA?$DO?$AA?$DN?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAo?$AAr?$AAd?$AAe?$AAr?$AAi?$AAn?$AAg?$AAC@ ; `string'
PUBLIC	?__LINE__Var@?1??SetOfflinePingResponse@RakPeer@@UAEXPBDI@Z@4JA ; `RakPeer::SetOfflinePingResponse'::`2'::__LINE__Var
PUBLIC	??_C@_1BK@PNPFLKAA@?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DM?$AA?5?$AA4?$AA0?$AA0?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??AdvertiseSystem@RakPeer@@UAEXPBDG0H@Z@4JA ; `RakPeer::AdvertiseSystem'::`2'::__LINE__Var
PUBLIC	??_C@_1EM@PPGDKCEI@?$AAd?$AAa?$AAt?$AAa?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAM?$AAA?$AAX?$AA_?$AAO?$AAF?$AAF?$AAL?$AAI?$AAN?$AAE?$AA_?$AAD?$AAA?$AAT?$AAA?$AA_?$AAL@ ; `string'
PUBLIC	??_C@_1BM@DNMMOAPD@?$AAd?$AAa?$AAt?$AAa?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?$DO?$AA?$DN?$AA0?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??SetSplitMessageProgressInterval@RakPeer@@UAEXH@Z@4JA ; `RakPeer::SetSplitMessageProgressInterval'::`2'::__LINE__Var
PUBLIC	??_C@_1BI@DGKOLLFG@?$AAi?$AAn?$AAt?$AAe?$AAr?$AAv?$AAa?$AAl?$AA?$DO?$AA?$DN?$AA0?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??SetUnreliableTimeout@RakPeer@@UAEXI@Z@4JA ; `RakPeer::SetUnreliableTimeout'::`2'::__LINE__Var
PUBLIC	??_C@_1BK@MHECFOMI@?$AAt?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AAM?$AAS?$AA?$DO?$AA?$DN?$AA0?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??PushBackPacket@RakPeer@@UAEXPAUPacket@@_N@Z@4JA ; `RakPeer::PushBackPacket'::`2'::__LINE__Var
PUBLIC	??_C@_1O@HMOJLPKG@?$AAp?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??GetIndexFromPlayerID@RakPeer@@IAEHUPlayerID@@_N@Z@4JA ; `RakPeer::GetIndexFromPlayerID'::`2'::__LINE__Var
PUBLIC	??_C@_1IK@PCGACABH@?$AAr?$AAe?$AAm?$AAo?$AAt?$AAe?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AAL?$AAi?$AAs?$AAt?$AA?$FL?$AAr?$AAe?$AAm?$AAo?$AAt?$AAe?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AAL?$AAo?$AAo@ ; `string'
PUBLIC	?__LINE__Var@?1??SendConnectionRequest@RakPeer@@IAE_NPBDGPADH@Z@4JA ; `RakPeer::SendConnectionRequest'::`2'::__LINE__Var
PUBLIC	??_C@_1DE@MHEPBEIO@?$AAp?$AAa?$AAs?$AAs?$AAw?$AAo?$AAr?$AAd?$AAD?$AAa?$AAt?$AAa?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA2?$AA5?$AA6?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??GetRemoteSystemFromPlayerID@RakPeer@@IBEPAURemoteSystemStruct@2@UPlayerID@@_N1@Z@4JA ; `RakPeer::GetRemoteSystemFromPlayerID'::`2'::__LINE__Var
PUBLIC	??_C@_1IO@IHOLNDOE@?$AAr?$AAe?$AAm?$AAo?$AAt?$AAe?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AAL?$AAi?$AAs?$AAt?$AA?$FL?$AA?5?$AAr?$AAe?$AAm?$AAo?$AAt?$AAe?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AAL?$AAo@ ; `string'
PUBLIC	?__LINE__Var@?1??AssignPlayerIDToRemoteSystemList@RakPeer@@IAEPAURemoteSystemStruct@2@UPlayerID@@W4ConnectMode@32@@Z@4JA ; `RakPeer::AssignPlayerIDToRemoteSystemList'::`2'::__LINE__Var
PUBLIC	??_C@_1DO@FONFJDEJ@?$AAp?$AAl?$AAa?$AAy?$AAe?$AAr?$AAI?$AAd?$AA?$CB?$AA?$DN?$AAU?$AAN?$AAA?$AAS?$AAS?$AAI?$AAG?$AAN?$AAE?$AAD?$AA_?$AAP?$AAL?$AAA?$AAY?$AAE?$AAR?$AA_?$AAI?$AAD?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??ShiftIncomingTimestamp@RakPeer@@IBEXPAEUPlayerID@@@Z@4JA ; `RakPeer::ShiftIncomingTimestamp'::`2'::__LINE__Var
PUBLIC	??_C@_1BG@FGPJADG@?$AAI?$AAs?$AAA?$AAc?$AAt?$AAi?$AAv?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_19MLBBEMBH@?$AAd?$AAa?$AAt?$AAa?$AA?$AA@	; `string'
PUBLIC	?__LINE__Var@?1??HandleRPCPacket@RakPeer@@IAE_NPBDHUPlayerID@@@Z@4JA ; `RakPeer::HandleRPCPacket'::`2'::__LINE__Var
PUBLIC	?__LINE__Var@?1??CloseConnectionInternal@RakPeer@@IAEXUPlayerID@@_N1E@Z@4JA ; `RakPeer::CloseConnectionInternal'::`2'::__LINE__Var
PUBLIC	?__LINE__Var@?1??SendBuffered@RakPeer@@IAEXPBDHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_NW4ConnectMode@RemoteSystemStruct@2@@Z@4JA ; `RakPeer::SendBuffered'::`2'::__LINE__Var
PUBLIC	??_C@_1BE@LOOBMGDN@?$AAb?$AAc?$AAs?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??ProcessNetworkPacket@@YGXIGPBDHPAVRakPeer@@@Z@4JA ; `ProcessNetworkPacket'::`2'::__LINE__Var
PUBLIC	??_C@_1HO@KBDHKDHK@?$AAr?$AAc?$AAs?$AA?9?$AA?$DO?$AAa?$AAc?$AAt?$AAi?$AAo?$AAn?$AAT?$AAo?$AAT?$AAa?$AAk?$AAe?$AA?$DN?$AA?$DN?$AAR?$AAa?$AAk?$AAP?$AAe?$AAe?$AAr?$AA?3?$AA?3?$AAR?$AAe?$AAq?$AAu@ ; `string'
PUBLIC	?__LINE__Var@?1??RunUpdateCycle@RakPeer@@IAE_NXZ@4JA ; `RakPeer::RunUpdateCycle'::`2'::__LINE__Var
PUBLIC	??_C@_1HE@GIGKOHOC@?$AAb?$AAc?$AAs?$AA?9?$AA?$DO?$AAc?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AA?$DN?$AA?$DN?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAe?$AAd?$AAC?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AAS?$AAt?$AAr@ ; `string'
PUBLIC	??_C@_1BK@CNLEAJJK@?$AAp?$AAi?$AAn?$AAg?$AA?5?$AA?$DM?$AA?5?$AA1?$AA0?$AA0?$AA0?$AA0?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1??UpdateNetworkLoop@@YGIPAX@Z@4JA ; `UpdateNetworkLoop'::`2'::__LINE__Var
PUBLIC	??_C@_1BI@JFBHHBPJ@?$AAt?$AAi?$AAm?$AAe?$AAr?$AAH?$AAa?$AAn?$AAd?$AAl?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BA@ICANLBCA@?$AAs?$AAu?$AAc?$AAc?$AAe?$AAs?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@ ; `string'
PUBLIC	??_C@_1GG@JDEIIJCO@?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN@ ; `string'
PUBLIC	??_C@_1FC@PKHPOOLI@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAo?$AAr?$AAd?$AAe?$AAr@ ; `string'
PUBLIC	??_C@_1CG@FNLJFNDG@?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAE?$AAx?$AAi?$AAs?$AAt?$AAs?$AA?$DN?$AA?$DN?$AAt?$AAr?$AAu?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@ ; `string'
PUBLIC	??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BO@JBFMBKMD@?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$DO?$AA?$DN?$AAn?$AAu?$AAm?$AA?$AA@ ; `string'
PUBLIC	??_C@_1GC@EGJKEKIF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAs?$AAi?$AAn?$AAg?$AAl?$AAe?$AAp?$AAr@ ; `string'
PUBLIC	??_C@_1DA@FABPCGM@?$AAw?$AAr?$AAi?$AAt?$AAe?$AAA?$AAh?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EA@OAIJHOON@?$AAw?$AAr?$AAi?$AAt?$AAe?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AA?$CB?$AA?$DN?$AAr?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EA@LEKNHFBP@?$AAw?$AAr?$AAi?$AAt?$AAe?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$CB?$AA?$DN?$AAw?$AAr?$AAi?$AAt?$AAe?$AAA?$AAh?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DE@PPJJMKJI@?$AAr?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$CB?$AA?$DN?$AAw?$AAr?$AAi?$AAt?$AAe?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DM@HLMOCDPL@?$AAr?$AAe?$AAa?$AAd?$AAA?$AAh?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$CB?$AA?$DN?$AAr?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DE@FCOMCLAG@?$AAw?$AAr?$AAi?$AAt?$AAe?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$CB?$AA?$DN?$AAr?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BE@OMEGJCHO@?$AAn?$AAe?$AAw?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CE@CLDOPLDF@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CM@FMCFHBCK@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_R4RakPeerInterface@@6B@			; RakPeerInterface::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVRakPeerInterface@@@8			; RakPeerInterface `RTTI Type Descriptor'
PUBLIC	??_R3RakPeerInterface@@8			; RakPeerInterface::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2RakPeerInterface@@8			; RakPeerInterface::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@RakPeerInterface@@8		; RakPeerInterface::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4RakPeer@@6B@				; RakPeer::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVRakPeer@@@8				; RakPeer `RTTI Type Descriptor'
PUBLIC	??_R3RakPeer@@8					; RakPeer::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2RakPeer@@8					; RakPeer::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@RakPeer@@8			; RakPeer::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	___report_rangecheckfailure:PROC
EXTRN	??8PlayerID@@QBE_NABU0@@Z:PROC			; PlayerID::operator==
EXTRN	??9PlayerID@@QBE_NABU0@@Z:PROC			; PlayerID::operator!=
EXTRN	??MPlayerID@@QBE_NABU0@@Z:PROC			; PlayerID::operator<
EXTRN	?IsPeerToPeerMode@NetworkID@@SA_NXZ:PROC	; NetworkID::IsPeerToPeerMode
EXTRN	??8NetworkID@@QBE_NABU0@@Z:PROC			; NetworkID::operator==
EXTRN	??_ERakPeerInterface@@UAEPAXI@Z:PROC		; RakPeerInterface::`vector deleting destructor'
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strcpy:PROC
EXTRN	_strcmp:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__SetWaitableTimer@24:PROC
EXTRN	__imp__CreateWaitableTimerA@12:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	__imp__closesocket@4:PROC
EXTRN	__imp__inet_addr@4:PROC
EXTRN	__imp__inet_ntoa@4:PROC
EXTRN	?CreateBoundSocket@SocketLayer@@QAEIG_NPBD@Z:PROC ; SocketLayer::CreateBoundSocket
EXTRN	?DomainNameToIP@SocketLayer@@QAEPBDPBD@Z:PROC	; SocketLayer::DomainNameToIP
EXTRN	?RecvFrom@SocketLayer@@QAEHIPAVRakPeer@@PAH@Z:PROC ; SocketLayer::RecvFrom
EXTRN	?GetMyIP@SocketLayer@@QAEXQAY0BA@D@Z:PROC	; SocketLayer::GetMyIP
EXTRN	?SendTo@SocketLayer@@QAEHIPBDHQADG@Z:PROC	; SocketLayer::SendTo
EXTRN	?SendTo@SocketLayer@@QAEHIPBDHIG@Z:PROC		; SocketLayer::SendTo
EXTRN	?GetLocalPort@SocketLayer@@QAEGI@Z:PROC		; SocketLayer::GetLocalPort
EXTRN	__wassert:PROC
EXTRN	??0BitStream@RakNet@@QAE@XZ:PROC		; RakNet::BitStream::BitStream
EXTRN	??0BitStream@RakNet@@QAE@H@Z:PROC		; RakNet::BitStream::BitStream
EXTRN	??0BitStream@RakNet@@QAE@PAEI_N@Z:PROC		; RakNet::BitStream::BitStream
EXTRN	??1BitStream@RakNet@@QAE@XZ:PROC		; RakNet::BitStream::~BitStream
EXTRN	?Reset@BitStream@RakNet@@QAEXXZ:PROC		; RakNet::BitStream::Reset
EXTRN	?Write@BitStream@RakNet@@QAEXPBDH@Z:PROC	; RakNet::BitStream::Write
EXTRN	?ResetWritePointer@BitStream@RakNet@@QAEXXZ:PROC ; RakNet::BitStream::ResetWritePointer
EXTRN	?IgnoreBits@BitStream@RakNet@@QAEXH@Z:PROC	; RakNet::BitStream::IgnoreBits
EXTRN	?SetWriteOffset@BitStream@RakNet@@QAEXH@Z:PROC	; RakNet::BitStream::SetWriteOffset
EXTRN	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z:PROC	; RakNet::BitStream::WriteBits
EXTRN	?WriteAlignedBytes@BitStream@RakNet@@QAEXPBEH@Z:PROC ; RakNet::BitStream::WriteAlignedBytes
EXTRN	?ReadBits@BitStream@RakNet@@QAE_NPAEH_N@Z:PROC	; RakNet::BitStream::ReadBits
EXTRN	?Write0@BitStream@RakNet@@QAEXXZ:PROC		; RakNet::BitStream::Write0
EXTRN	?Write1@BitStream@RakNet@@QAEXXZ:PROC		; RakNet::BitStream::Write1
EXTRN	?WriteCompressed@BitStream@RakNet@@AAEXPBEH_N@Z:PROC ; RakNet::BitStream::WriteCompressed
EXTRN	?ReadCompressed@BitStream@RakNet@@AAE_NPAEH_N@Z:PROC ; RakNet::BitStream::ReadCompressed
EXTRN	??0CSHA1@@QAE@XZ:PROC				; CSHA1::CSHA1
EXTRN	??1CSHA1@@UAE@XZ:PROC				; CSHA1::~CSHA1
EXTRN	?Reset@CSHA1@@QAEXXZ:PROC			; CSHA1::Reset
EXTRN	?Update@CSHA1@@QAEXPAEI@Z:PROC			; CSHA1::Update
EXTRN	?Final@CSHA1@@QAEXXZ:PROC			; CSHA1::Final
EXTRN	?GetHash@CSHA1@@QBEPAEXZ:PROC			; CSHA1::GetHash
EXTRN	??0ReliabilityLayer@@QAE@XZ:PROC		; ReliabilityLayer::ReliabilityLayer
EXTRN	??1ReliabilityLayer@@QAE@XZ:PROC		; ReliabilityLayer::~ReliabilityLayer
EXTRN	?Reset@ReliabilityLayer@@QAEX_N@Z:PROC		; ReliabilityLayer::Reset
EXTRN	?SetEncryptionKey@ReliabilityLayer@@QAEXPBE@Z:PROC ; ReliabilityLayer::SetEncryptionKey
EXTRN	?SetTimeoutTime@ReliabilityLayer@@QAEXI@Z:PROC	; ReliabilityLayer::SetTimeoutTime
EXTRN	?GetTimeoutTime@ReliabilityLayer@@QAEIXZ:PROC	; ReliabilityLayer::GetTimeoutTime
EXTRN	?HandleSocketReceiveFromConnectedPlayer@ReliabilityLayer@@QAE_NPBDHUPlayerID@@AAV?$List@PAVPluginInterface@@@DataStructures@@H@Z:PROC ; ReliabilityLayer::HandleSocketReceiveFromConnectedPlayer
EXTRN	?Receive@ReliabilityLayer@@QAEHPAPAE@Z:PROC	; ReliabilityLayer::Receive
EXTRN	?Send@ReliabilityLayer@@QAE_NPADHW4PacketPriority@@W4PacketReliability@@E_NH_J@Z:PROC ; ReliabilityLayer::Send
EXTRN	?Update@ReliabilityLayer@@QAEXIUPlayerID@@H_JAAV?$List@PAVPluginInterface@@@DataStructures@@@Z:PROC ; ReliabilityLayer::Update
EXTRN	?IsCheater@ReliabilityLayer@@QBE_NXZ:PROC	; ReliabilityLayer::IsCheater
EXTRN	?IsDeadConnection@ReliabilityLayer@@QBE_NXZ:PROC ; ReliabilityLayer::IsDeadConnection
EXTRN	?SetPing@ReliabilityLayer@@QAEXI@Z:PROC		; ReliabilityLayer::SetPing
EXTRN	?GetStatistics@ReliabilityLayer@@QAEQAURakNetStatisticsStruct@@XZ:PROC ; ReliabilityLayer::GetStatistics
EXTRN	?IsDataWaiting@ReliabilityLayer@@QAE_NXZ:PROC	; ReliabilityLayer::IsDataWaiting
EXTRN	?AreAcksWaiting@ReliabilityLayer@@QAE_NXZ:PROC	; ReliabilityLayer::AreAcksWaiting
EXTRN	?ApplyNetworkSimulator@ReliabilityLayer@@QAEXNII@Z:PROC ; ReliabilityLayer::ApplyNetworkSimulator
EXTRN	?SetSplitMessageProgressInterval@ReliabilityLayer@@QAEXH@Z:PROC ; ReliabilityLayer::SetSplitMessageProgressInterval
EXTRN	?SetUnreliableTimeout@ReliabilityLayer@@QAEXI@Z:PROC ; ReliabilityLayer::SetUnreliableTimeout
EXTRN	?seedMT@@YAXI@Z:PROC				; seedMT
EXTRN	?randomMT@@YAIXZ:PROC				; randomMT
EXTRN	??0RPCMap@@QAE@XZ:PROC				; RPCMap::RPCMap
EXTRN	??1RPCMap@@QAE@XZ:PROC				; RPCMap::~RPCMap
EXTRN	?Clear@RPCMap@@QAEXXZ:PROC			; RPCMap::Clear
EXTRN	?GetNodeFromIndex@RPCMap@@QAEPAURPCNode@@E@Z:PROC ; RPCMap::GetNodeFromIndex
EXTRN	?GetIndexFromFunctionName@RPCMap@@QAEEPAD@Z:PROC ; RPCMap::GetIndexFromFunctionName
EXTRN	?AddIdentifierWithFunction@RPCMap@@QAEXPADPAX_N@Z:PROC ; RPCMap::AddIdentifierWithFunction
EXTRN	?AddIdentifierAtIndex@RPCMap@@QAEXPADE@Z:PROC	; RPCMap::AddIdentifierAtIndex
EXTRN	?RemoveNode@RPCMap@@QAEXPAD@Z:PROC		; RPCMap::RemoveNode
EXTRN	??0SimpleMutex@@QAE@XZ:PROC			; SimpleMutex::SimpleMutex
EXTRN	??1SimpleMutex@@QAE@XZ:PROC			; SimpleMutex::~SimpleMutex
EXTRN	?Lock@SimpleMutex@@QAEXXZ:PROC			; SimpleMutex::Lock
EXTRN	?Unlock@SimpleMutex@@QAEXXZ:PROC		; SimpleMutex::Unlock
EXTRN	??_ERakPeer@@UAEPAXI@Z:PROC			; RakPeer::`vector deleting destructor'
EXTRN	__beginthreadex:PROC
EXTRN	?GetTime@RakNet@@YAIXZ:PROC			; RakNet::GetTime
EXTRN	?GetTimeNS@RakNet@@YA_JXZ:PROC			; RakNet::GetTimeNS
EXTRN	??0HuffmanEncodingTree@@QAE@XZ:PROC		; HuffmanEncodingTree::HuffmanEncodingTree
EXTRN	??1HuffmanEncodingTree@@QAE@XZ:PROC		; HuffmanEncodingTree::~HuffmanEncodingTree
EXTRN	?EncodeArray@HuffmanEncodingTree@@QAEXPAEIPAVBitStream@RakNet@@@Z:PROC ; HuffmanEncodingTree::EncodeArray
EXTRN	?DecodeArray@HuffmanEncodingTree@@QAEXPAEIPAVBitStream@RakNet@@@Z:PROC ; HuffmanEncodingTree::DecodeArray
EXTRN	?GenerateFromFrequencyTable@HuffmanEncodingTree@@QAEXQAI@Z:PROC ; HuffmanEncodingTree::GenerateFromFrequencyTable
EXTRN	?Instance@StringCompressor@@SAPAV1@XZ:PROC	; StringCompressor::Instance
EXTRN	?EncodeString@StringCompressor@@QAEXPBDHPAVBitStream@RakNet@@H@Z:PROC ; StringCompressor::EncodeString
EXTRN	?DecodeString@StringCompressor@@QAE_NPADHPAVBitStream@RakNet@@H@Z:PROC ; StringCompressor::DecodeString
EXTRN	?AddReference@StringCompressor@@SAXXZ:PROC	; StringCompressor::AddReference
EXTRN	?RemoveReference@StringCompressor@@SAXXZ:PROC	; StringCompressor::RemoveReference
EXTRN	?AddReference@StringTable@@SAXXZ:PROC		; StringTable::AddReference
EXTRN	?RemoveReference@StringTable@@SAXXZ:PROC	; StringTable::RemoveReference
EXTRN	?GET_OBJECT_FROM_ID@NetworkIDGenerator@@SAPAXUNetworkID@@@Z:PROC ; NetworkIDGenerator::GET_OBJECT_FROM_ID
EXTRN	?RakSleep@@YAXI@Z:PROC				; RakSleep
EXTRN	@_RTC_AllocaHelper@12:PROC
EXTRN	@_RTC_CheckStackVars2@12:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_UninitUse:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__alldiv:PROC
EXTRN	__alloca_probe_16:PROC
EXTRN	?I@SocketLayer@@0V1@A:BYTE			; SocketLayer::I
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?ipList@?1??GetLocalIP@RakPeer@@UAEPBDI@Z@4PAY0BA@DA DB 0a0H DUP (?) ; `RakPeer::GetLocalIP'::`2'::ipList
?sum@?4??GetStatistics@RakPeer@@UAEQAURakNetStatisticsStruct@@UPlayerID@@@Z@4U3@A DB 0c4H DUP (?) ; `RakPeer::GetStatistics'::`5'::sum
_BSS	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_R1A@?0A@EA@RakPeer@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@RakPeer@@8 DD FLAT:??_R0?AVRakPeer@@@8	; RakPeer::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3RakPeer@@8
rdata$r	ENDS
;	COMDAT ??_R2RakPeer@@8
rdata$r	SEGMENT
??_R2RakPeer@@8 DD FLAT:??_R1A@?0A@EA@RakPeer@@8	; RakPeer::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@RakPeerInterface@@8
rdata$r	ENDS
;	COMDAT ??_R3RakPeer@@8
rdata$r	SEGMENT
??_R3RakPeer@@8 DD 00H					; RakPeer::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2RakPeer@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVRakPeer@@@8
data$r	SEGMENT
??_R0?AVRakPeer@@@8 DD FLAT:??_7type_info@@6B@		; RakPeer `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVRakPeer@@', 00H
data$r	ENDS
;	COMDAT ??_R4RakPeer@@6B@
rdata$r	SEGMENT
??_R4RakPeer@@6B@ DD 00H				; RakPeer::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVRakPeer@@@8
	DD	FLAT:??_R3RakPeer@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@RakPeerInterface@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@RakPeerInterface@@8 DD FLAT:??_R0?AVRakPeerInterface@@@8 ; RakPeerInterface::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3RakPeerInterface@@8
rdata$r	ENDS
;	COMDAT ??_R2RakPeerInterface@@8
rdata$r	SEGMENT
??_R2RakPeerInterface@@8 DD FLAT:??_R1A@?0A@EA@RakPeerInterface@@8 ; RakPeerInterface::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3RakPeerInterface@@8
rdata$r	SEGMENT
??_R3RakPeerInterface@@8 DD 00H				; RakPeerInterface::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2RakPeerInterface@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVRakPeerInterface@@@8
data$r	SEGMENT
??_R0?AVRakPeerInterface@@@8 DD FLAT:??_7type_info@@6B@	; RakPeerInterface `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVRakPeerInterface@@', 00H
data$r	ENDS
;	COMDAT ??_R4RakPeerInterface@@6B@
rdata$r	SEGMENT
??_R4RakPeerInterface@@6B@ DD 00H			; RakPeerInterface::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVRakPeerInterface@@@8
	DD	FLAT:??_R3RakPeerInterface@@8
rdata$r	ENDS
;	COMDAT ??_C@_1CM@FMCFHBCK@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@FMCFHBCK@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ DB 'p'
	DB	00H, 'o', 00H, 's', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'o', 00H
	DB	'n', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'l', 00H, 'i'
	DB	00H, 's', 00H, 't', 00H, '_', 00H, 's', 00H, 'i', 00H, 'z', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@CLDOPLDF@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@CLDOPLDF@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@ DB 'p'
	DB	00H, 'o', 00H, 's', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'o', 00H
	DB	'n', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'S', 00H, 'i', 00H, 'z'
	DB	00H, 'e', 00H, '(', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@OMEGJCHO@?$AAn?$AAe?$AAw?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@OMEGJCHO@?$AAn?$AAe?$AAw?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?$AA@ DB 'n'
	DB	00H, 'e', 00H, 'w', 00H, '_', 00H, 'a', 00H, 'r', 00H, 'r', 00H
	DB	'a', 00H, 'y', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1DE@FCOMCLAG@?$AAw?$AAr?$AAi?$AAt?$AAe?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$CB?$AA?$DN?$AAr?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@FCOMCLAG@?$AAw?$AAr?$AAi?$AAt?$AAe?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$CB?$AA?$DN?$AAr?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ DB 'w'
	DB	00H, 'r', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'P', 00H, 'o', 00H
	DB	'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, '!', 00H, '='
	DB	00H, 'r', 00H, 'e', 00H, 'a', 00H, 'd', 00H, 'P', 00H, 'o', 00H
	DB	'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DM@HLMOCDPL@?$AAr?$AAe?$AAa?$AAd?$AAA?$AAh?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$CB?$AA?$DN?$AAr?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1DM@HLMOCDPL@?$AAr?$AAe?$AAa?$AAd?$AAA?$AAh?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$CB?$AA?$DN?$AAr?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ DB 'r'
	DB	00H, 'e', 00H, 'a', 00H, 'd', 00H, 'A', 00H, 'h', 00H, 'e', 00H
	DB	'a', 00H, 'd', 00H, 'P', 00H, 'o', 00H, 'i', 00H, 'n', 00H, 't'
	DB	00H, 'e', 00H, 'r', 00H, '!', 00H, '=', 00H, 'r', 00H, 'e', 00H
	DB	'a', 00H, 'd', 00H, 'P', 00H, 'o', 00H, 'i', 00H, 'n', 00H, 't'
	DB	00H, 'e', 00H, 'r', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DE@PPJJMKJI@?$AAr?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$CB?$AA?$DN?$AAw?$AAr?$AAi?$AAt?$AAe?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@PPJJMKJI@?$AAr?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$CB?$AA?$DN?$AAw?$AAr?$AAi?$AAt?$AAe?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ DB 'r'
	DB	00H, 'e', 00H, 'a', 00H, 'd', 00H, 'P', 00H, 'o', 00H, 'i', 00H
	DB	'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, '!', 00H, '=', 00H, 'w'
	DB	00H, 'r', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'P', 00H, 'o', 00H
	DB	'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@LEKNHFBP@?$AAw?$AAr?$AAi?$AAt?$AAe?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$CB?$AA?$DN?$AAw?$AAr?$AAi?$AAt?$AAe?$AAA?$AAh?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1EA@LEKNHFBP@?$AAw?$AAr?$AAi?$AAt?$AAe?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$CB?$AA?$DN?$AAw?$AAr?$AAi?$AAt?$AAe?$AAA?$AAh?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ DB 'w'
	DB	00H, 'r', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'P', 00H, 'o', 00H
	DB	'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, '!', 00H, '='
	DB	00H, 'w', 00H, 'r', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'A', 00H
	DB	'h', 00H, 'e', 00H, 'a', 00H, 'd', 00H, 'P', 00H, 'o', 00H, 'i'
	DB	00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@OAIJHOON@?$AAw?$AAr?$AAi?$AAt?$AAe?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AA?$CB?$AA?$DN?$AAr?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1EA@OAIJHOON@?$AAw?$AAr?$AAi?$AAt?$AAe?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AA?$CB?$AA?$DN?$AAr?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ DB 'w'
	DB	00H, 'r', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'P', 00H, 'o', 00H
	DB	'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, '-', 00H, '>'
	DB	00H, 'n', 00H, 'e', 00H, 'x', 00H, 't', 00H, '!', 00H, '=', 00H
	DB	'r', 00H, 'e', 00H, 'a', 00H, 'd', 00H, 'P', 00H, 'o', 00H, 'i'
	DB	00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@FABPCGM@?$AAw?$AAr?$AAi?$AAt?$AAe?$AAA?$AAh?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@FABPCGM@?$AAw?$AAr?$AAi?$AAt?$AAe?$AAA?$AAh?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AA?$AA@ DB 'w'
	DB	00H, 'r', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'A', 00H, 'h', 00H
	DB	'e', 00H, 'a', 00H, 'd', 00H, 'P', 00H, 'o', 00H, 'i', 00H, 'n'
	DB	00H, 't', 00H, 'e', 00H, 'r', 00H, '-', 00H, '>', 00H, 'n', 00H
	DB	'e', 00H, 'x', 00H, 't', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1GC@EGJKEKIF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAs?$AAi?$AAn?$AAg?$AAl?$AAe?$AAp?$AAr@
CONST	SEGMENT
??_C@_1GC@EGJKEKIF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAs?$AAi?$AAn?$AAg?$AAl?$AAe?$AAp?$AAr@ DB 'z'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H
	DB	's', 00H, 'r', 00H, 'c', 00H, '\', 00H, '0', 00H, '2', 00H, 'x'
	DB	00H, 'u', 00H, '1', 00H, '\', 00H, 'r', 00H, 'a', 00H, 'k', 00H
	DB	'n', 00H, 'e', 00H, 't', 00H, '\', 00H, 's', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, 'l', 00H, 'e', 00H, 'p', 00H, 'r', 00H, 'o', 00H
	DB	'd', 00H, 'u', 00H, 'c', 00H, 'e', 00H, 'r', 00H, 'c', 00H, 'o'
	DB	00H, 'n', 00H, 's', 00H, 'u', 00H, 'm', 00H, 'e', 00H, 'r', 00H
	DB	'.', 00H, 'h', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@JBFMBKMD@?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$DO?$AA?$DN?$AAn?$AAu?$AAm?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@JBFMBKMD@?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$DO?$AA?$DN?$AAn?$AAu?$AAm?$AA?$AA@ DB 'l'
	DB	00H, 'i', 00H, 's', 00H, 't', 00H, '_', 00H, 's', 00H, 'i', 00H
	DB	'z', 00H, 'e', 00H, '>', 00H, '=', 00H, 'n', 00H, 'u', 00H, 'm'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ DB 'p'
	DB	00H, 'o', 00H, 's', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'o', 00H
	DB	'n', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'l', 00H, 'i', 00H, 's'
	DB	00H, 't', 00H, '_', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
CONST	SEGMENT
??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@ DB 'z'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H
	DB	's', 00H, 'r', 00H, 'c', 00H, '\', 00H, '0', 00H, '2', 00H, 'x'
	DB	00H, 'u', 00H, '1', 00H, '\', 00H, 'r', 00H, 'a', 00H, 'k', 00H
	DB	'n', 00H, 'e', 00H, 't', 00H, '\', 00H, 'd', 00H, 's', 00H, '_'
	DB	00H, 'l', 00H, 'i', 00H, 's', 00H, 't', 00H, '.', 00H, 'h', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@FNLJFNDG@?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAE?$AAx?$AAi?$AAs?$AAt?$AAs?$AA?$DN?$AA?$DN?$AAt?$AAr?$AAu?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@FNLJFNDG@?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAE?$AAx?$AAi?$AAs?$AAt?$AAs?$AA?$DN?$AA?$DN?$AAt?$AAr?$AAu?$AAe?$AA?$AA@ DB 'o'
	DB	00H, 'b', 00H, 'j', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'E', 00H
	DB	'x', 00H, 'i', 00H, 's', 00H, 't', 00H, 's', 00H, '=', 00H, '='
	DB	00H, 't', 00H, 'r', 00H, 'u', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FC@PKHPOOLI@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAo?$AAr?$AAd?$AAe?$AAr@
CONST	SEGMENT
??_C@_1FC@PKHPOOLI@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAo?$AAr?$AAd?$AAe?$AAr@ DB 'z'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H
	DB	's', 00H, 'r', 00H, 'c', 00H, '\', 00H, '0', 00H, '2', 00H, 'x'
	DB	00H, 'u', 00H, '1', 00H, '\', 00H, 'r', 00H, 'a', 00H, 'k', 00H
	DB	'n', 00H, 'e', 00H, 't', 00H, '\', 00H, 'd', 00H, 's', 00H, '_'
	DB	00H, 'o', 00H, 'r', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 'e', 00H
	DB	'd', 00H, 'l', 00H, 'i', 00H, 's', 00H, 't', 00H, '.', 00H, 'h'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1GG@JDEIIJCO@?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN@
CONST	SEGMENT
??_C@_1GG@JDEIIJCO@?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN@ DB 'a'
	DB	00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H
	DB	'i', 00H, 'o', 00H, 'n', 00H, '_', 00H, 's', 00H, 'i', 00H, 'z'
	DB	00H, 'e', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e'
	DB	00H, '(', 00H, ')', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H
	DB	'0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'h', 00H, 'e'
	DB	00H, 'a', 00H, 'd', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H
	DB	't', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@
CONST	SEGMENT
??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@ DB 'z'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H
	DB	's', 00H, 'r', 00H, 'c', 00H, '\', 00H, '0', 00H, '2', 00H, 'x'
	DB	00H, 'u', 00H, '1', 00H, '\', 00H, 'r', 00H, 'a', 00H, 'k', 00H
	DB	'n', 00H, 'e', 00H, 't', 00H, '\', 00H, 'd', 00H, 's', 00H, '_'
	DB	00H, 'q', 00H, 'u', 00H, 'e', 00H, 'u', 00H, 'e', 00H, '.', 00H
	DB	'h', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BA@ICANLBCA@?$AAs?$AAu?$AAc?$AAc?$AAe?$AAs?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1BA@ICANLBCA@?$AAs?$AAu?$AAc?$AAc?$AAe?$AAs?$AAs?$AA?$AA@ DB 's', 00H
	DB	'u', 00H, 'c', 00H, 'c', 00H, 'e', 00H, 's', 00H, 's', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@JFBHHBPJ@?$AAt?$AAi?$AAm?$AAe?$AAr?$AAH?$AAa?$AAn?$AAd?$AAl?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@JFBHHBPJ@?$AAt?$AAi?$AAm?$AAe?$AAr?$AAH?$AAa?$AAn?$AAd?$AAl?$AAe?$AA?$AA@ DB 't'
	DB	00H, 'i', 00H, 'm', 00H, 'e', 00H, 'r', 00H, 'H', 00H, 'a', 00H
	DB	'n', 00H, 'd', 00H, 'l', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??UpdateNetworkLoop@@YGIPAX@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??UpdateNetworkLoop@@YGIPAX@Z@4JA DD 01361H ; `UpdateNetworkLoop'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1BK@CNLEAJJK@?$AAp?$AAi?$AAn?$AAg?$AA?5?$AA?$DM?$AA?5?$AA1?$AA0?$AA0?$AA0?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@CNLEAJJK@?$AAp?$AAi?$AAn?$AAg?$AA?5?$AA?$DM?$AA?5?$AA1?$AA0?$AA0?$AA0?$AA0?$AA?$AA@ DB 'p'
	DB	00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, '<', 00H, ' ', 00H
	DB	'1', 00H, '0', 00H, '0', 00H, '0', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1HE@GIGKOHOC@?$AAb?$AAc?$AAs?$AA?9?$AA?$DO?$AAc?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AA?$DN?$AA?$DN?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAe?$AAd?$AAC?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AAS?$AAt?$AAr@
CONST	SEGMENT
??_C@_1HE@GIGKOHOC@?$AAb?$AAc?$AAs?$AA?9?$AA?$DO?$AAc?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AA?$DN?$AA?$DN?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAe?$AAd?$AAC?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AAS?$AAt?$AAr@ DB 'b'
	DB	00H, 'c', 00H, 's', 00H, '-', 00H, '>', 00H, 'c', 00H, 'o', 00H
	DB	'm', 00H, 'm', 00H, 'a', 00H, 'n', 00H, 'd', 00H, '=', 00H, '='
	DB	00H, 'B', 00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H
	DB	'e', 00H, 'd', 00H, 'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'a'
	DB	00H, 'n', 00H, 'd', 00H, 'S', 00H, 't', 00H, 'r', 00H, 'u', 00H
	DB	'c', 00H, 't', 00H, ':', 00H, ':', 00H, 'B', 00H, 'C', 00H, 'S'
	DB	00H, '_', 00H, 'C', 00H, 'L', 00H, 'O', 00H, 'S', 00H, 'E', 00H
	DB	'_', 00H, 'C', 00H, 'O', 00H, 'N', 00H, 'N', 00H, 'E', 00H, 'C'
	DB	00H, 'T', 00H, 'I', 00H, 'O', 00H, 'N', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??RunUpdateCycle@RakPeer@@IAE_NXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?1??RunUpdateCycle@RakPeer@@IAE_NXZ@4JA DD 0107dH ; `RakPeer::RunUpdateCycle'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1HO@KBDHKDHK@?$AAr?$AAc?$AAs?$AA?9?$AA?$DO?$AAa?$AAc?$AAt?$AAi?$AAo?$AAn?$AAT?$AAo?$AAT?$AAa?$AAk?$AAe?$AA?$DN?$AA?$DN?$AAR?$AAa?$AAk?$AAP?$AAe?$AAe?$AAr?$AA?3?$AA?3?$AAR?$AAe?$AAq?$AAu@
CONST	SEGMENT
??_C@_1HO@KBDHKDHK@?$AAr?$AAc?$AAs?$AA?9?$AA?$DO?$AAa?$AAc?$AAt?$AAi?$AAo?$AAn?$AAT?$AAo?$AAT?$AAa?$AAk?$AAe?$AA?$DN?$AA?$DN?$AAR?$AAa?$AAk?$AAP?$AAe?$AAe?$AAr?$AA?3?$AA?3?$AAR?$AAe?$AAq?$AAu@ DB 'r'
	DB	00H, 'c', 00H, 's', 00H, '-', 00H, '>', 00H, 'a', 00H, 'c', 00H
	DB	't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 'T', 00H, 'o', 00H, 'T'
	DB	00H, 'a', 00H, 'k', 00H, 'e', 00H, '=', 00H, '=', 00H, 'R', 00H
	DB	'a', 00H, 'k', 00H, 'P', 00H, 'e', 00H, 'e', 00H, 'r', 00H, ':'
	DB	00H, ':', 00H, 'R', 00H, 'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H
	DB	's', 00H, 't', 00H, 'e', 00H, 'd', 00H, 'C', 00H, 'o', 00H, 'n'
	DB	00H, 'n', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'i', 00H, 'o', 00H
	DB	'n', 00H, 'S', 00H, 't', 00H, 'r', 00H, 'u', 00H, 'c', 00H, 't'
	DB	00H, ':', 00H, ':', 00H, 'C', 00H, 'O', 00H, 'N', 00H, 'N', 00H
	DB	'E', 00H, 'C', 00H, 'T', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??ProcessNetworkPacket@@YGXIGPBDHPAVRakPeer@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??ProcessNetworkPacket@@YGXIGPBDHPAVRakPeer@@@Z@4JA DD 0f1fH ; `ProcessNetworkPacket'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1BE@LOOBMGDN@?$AAb?$AAc?$AAs?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@LOOBMGDN@?$AAb?$AAc?$AAs?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?$AA@ DB 'b'
	DB	00H, 'c', 00H, 's', 00H, '-', 00H, '>', 00H, 'd', 00H, 'a', 00H
	DB	't', 00H, 'a', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??SendBuffered@RakPeer@@IAEXPBDHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_NW4ConnectMode@RemoteSystemStruct@2@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??SendBuffered@RakPeer@@IAEXPBDHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_NW4ConnectMode@RemoteSystemStruct@2@@Z@4JA DD 0da7H ; `RakPeer::SendBuffered'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??CloseConnectionInternal@RakPeer@@IAEXUPlayerID@@_N1E@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??CloseConnectionInternal@RakPeer@@IAEXUPlayerID@@_N1E@Z@4JA DD 0d4fH ; `RakPeer::CloseConnectionInternal'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?1??HandleRPCPacket@RakPeer@@IAE_NPBDHUPlayerID@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??HandleRPCPacket@RakPeer@@IAE_NPBDHUPlayerID@@@Z@4JA DD 0b62H ; `RakPeer::HandleRPCPacket'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_19MLBBEMBH@?$AAd?$AAa?$AAt?$AAa?$AA?$AA@
CONST	SEGMENT
??_C@_19MLBBEMBH@?$AAd?$AAa?$AAt?$AAa?$AA?$AA@ DB 'd', 00H, 'a', 00H, 't', 00H
	DB	'a', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@FGPJADG@?$AAI?$AAs?$AAA?$AAc?$AAt?$AAi?$AAv?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@FGPJADG@?$AAI?$AAs?$AAA?$AAc?$AAt?$AAi?$AAv?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@ DB 'I'
	DB	00H, 's', 00H, 'A', 00H, 'c', 00H, 't', 00H, 'i', 00H, 'v', 00H
	DB	'e', 00H, '(', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??ShiftIncomingTimestamp@RakPeer@@IBEXPAEUPlayerID@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??ShiftIncomingTimestamp@RakPeer@@IBEXPAEUPlayerID@@@Z@4JA DD 0b26H ; `RakPeer::ShiftIncomingTimestamp'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1DO@FONFJDEJ@?$AAp?$AAl?$AAa?$AAy?$AAe?$AAr?$AAI?$AAd?$AA?$CB?$AA?$DN?$AAU?$AAN?$AAA?$AAS?$AAS?$AAI?$AAG?$AAN?$AAE?$AAD?$AA_?$AAP?$AAL?$AAA?$AAY?$AAE?$AAR?$AA_?$AAI?$AAD?$AA?$AA@
CONST	SEGMENT
??_C@_1DO@FONFJDEJ@?$AAp?$AAl?$AAa?$AAy?$AAe?$AAr?$AAI?$AAd?$AA?$CB?$AA?$DN?$AAU?$AAN?$AAA?$AAS?$AAS?$AAI?$AAG?$AAN?$AAE?$AAD?$AA_?$AAP?$AAL?$AAA?$AAY?$AAE?$AAR?$AA_?$AAI?$AAD?$AA?$AA@ DB 'p'
	DB	00H, 'l', 00H, 'a', 00H, 'y', 00H, 'e', 00H, 'r', 00H, 'I', 00H
	DB	'd', 00H, '!', 00H, '=', 00H, 'U', 00H, 'N', 00H, 'A', 00H, 'S'
	DB	00H, 'S', 00H, 'I', 00H, 'G', 00H, 'N', 00H, 'E', 00H, 'D', 00H
	DB	'_', 00H, 'P', 00H, 'L', 00H, 'A', 00H, 'Y', 00H, 'E', 00H, 'R'
	DB	00H, '_', 00H, 'I', 00H, 'D', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??AssignPlayerIDToRemoteSystemList@RakPeer@@IAEPAURemoteSystemStruct@2@UPlayerID@@W4ConnectMode@32@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??AssignPlayerIDToRemoteSystemList@RakPeer@@IAEPAURemoteSystemStruct@2@UPlayerID@@W4ConnectMode@32@@Z@4JA DD 0aebH ; `RakPeer::AssignPlayerIDToRemoteSystemList'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1IO@IHOLNDOE@?$AAr?$AAe?$AAm?$AAo?$AAt?$AAe?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AAL?$AAi?$AAs?$AAt?$AA?$FL?$AA?5?$AAr?$AAe?$AAm?$AAo?$AAt?$AAe?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AAL?$AAo@
CONST	SEGMENT
??_C@_1IO@IHOLNDOE@?$AAr?$AAe?$AAm?$AAo?$AAt?$AAe?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AAL?$AAi?$AAs?$AAt?$AA?$FL?$AA?5?$AAr?$AAe?$AAm?$AAo?$AAt?$AAe?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AAL?$AAo@ DB 'r'
	DB	00H, 'e', 00H, 'm', 00H, 'o', 00H, 't', 00H, 'e', 00H, 'S', 00H
	DB	'y', 00H, 's', 00H, 't', 00H, 'e', 00H, 'm', 00H, 'L', 00H, 'i'
	DB	00H, 's', 00H, 't', 00H, '[', 00H, ' ', 00H, 'r', 00H, 'e', 00H
	DB	'm', 00H, 'o', 00H, 't', 00H, 'e', 00H, 'S', 00H, 'y', 00H, 's'
	DB	00H, 't', 00H, 'e', 00H, 'm', 00H, 'L', 00H, 'o', 00H, 'o', 00H
	DB	'k', 00H, 'u', 00H, 'p', 00H, '[', 00H, 'i', 00H, 'n', 00H, 'd'
	DB	00H, 'e', 00H, 'x', 00H, ']', 00H, '.', 00H, 'i', 00H, 'n', 00H
	DB	'd', 00H, 'e', 00H, 'x', 00H, ' ', 00H, ']', 00H, '.', 00H, 'p'
	DB	00H, 'l', 00H, 'a', 00H, 'y', 00H, 'e', 00H, 'r', 00H, 'I', 00H
	DB	'd', 00H, '=', 00H, '=', 00H, 'p', 00H, 'l', 00H, 'a', 00H, 'y'
	DB	00H, 'e', 00H, 'r', 00H, 'I', 00H, 'D', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??GetRemoteSystemFromPlayerID@RakPeer@@IBEPAURemoteSystemStruct@2@UPlayerID@@_N1@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??GetRemoteSystemFromPlayerID@RakPeer@@IBEPAURemoteSystemStruct@2@UPlayerID@@_N1@Z@4JA DD 0a27H ; `RakPeer::GetRemoteSystemFromPlayerID'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1DE@MHEPBEIO@?$AAp?$AAa?$AAs?$AAs?$AAw?$AAo?$AAr?$AAd?$AAD?$AAa?$AAt?$AAa?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA2?$AA5?$AA6?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@MHEPBEIO@?$AAp?$AAa?$AAs?$AAs?$AAw?$AAo?$AAr?$AAd?$AAD?$AAa?$AAt?$AAa?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA2?$AA5?$AA6?$AA?$AA@ DB 'p'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, 'w', 00H, 'o', 00H, 'r', 00H
	DB	'd', 00H, 'D', 00H, 'a', 00H, 't', 00H, 'a', 00H, 'L', 00H, 'e'
	DB	00H, 'n', 00H, 'g', 00H, 't', 00H, 'h', 00H, ' ', 00H, '<', 00H
	DB	'=', 00H, ' ', 00H, '2', 00H, '5', 00H, '6', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??SendConnectionRequest@RakPeer@@IAE_NPBDGPADH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??SendConnectionRequest@RakPeer@@IAE_NPBDGPADH@Z@4JA DD 09fcH ; `RakPeer::SendConnectionRequest'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1IK@PCGACABH@?$AAr?$AAe?$AAm?$AAo?$AAt?$AAe?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AAL?$AAi?$AAs?$AAt?$AA?$FL?$AAr?$AAe?$AAm?$AAo?$AAt?$AAe?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AAL?$AAo?$AAo@
CONST	SEGMENT
??_C@_1IK@PCGACABH@?$AAr?$AAe?$AAm?$AAo?$AAt?$AAe?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AAL?$AAi?$AAs?$AAt?$AA?$FL?$AAr?$AAe?$AAm?$AAo?$AAt?$AAe?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AAL?$AAo?$AAo@ DB 'r'
	DB	00H, 'e', 00H, 'm', 00H, 'o', 00H, 't', 00H, 'e', 00H, 'S', 00H
	DB	'y', 00H, 's', 00H, 't', 00H, 'e', 00H, 'm', 00H, 'L', 00H, 'i'
	DB	00H, 's', 00H, 't', 00H, '[', 00H, 'r', 00H, 'e', 00H, 'm', 00H
	DB	'o', 00H, 't', 00H, 'e', 00H, 'S', 00H, 'y', 00H, 's', 00H, 't'
	DB	00H, 'e', 00H, 'm', 00H, 'L', 00H, 'o', 00H, 'o', 00H, 'k', 00H
	DB	'u', 00H, 'p', 00H, '[', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'e'
	DB	00H, 'x', 00H, ']', 00H, '.', 00H, 'i', 00H, 'n', 00H, 'd', 00H
	DB	'e', 00H, 'x', 00H, ']', 00H, '.', 00H, 'p', 00H, 'l', 00H, 'a'
	DB	00H, 'y', 00H, 'e', 00H, 'r', 00H, 'I', 00H, 'd', 00H, '=', 00H
	DB	'=', 00H, 'p', 00H, 'l', 00H, 'a', 00H, 'y', 00H, 'e', 00H, 'r'
	DB	00H, 'I', 00H, 'd', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??GetIndexFromPlayerID@RakPeer@@IAEHUPlayerID@@_N@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??GetIndexFromPlayerID@RakPeer@@IAEHUPlayerID@@_N@Z@4JA DD 09ddH ; `RakPeer::GetIndexFromPlayerID'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1O@HMOJLPKG@?$AAp?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1O@HMOJLPKG@?$AAp?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?$AA@ DB 'p', 00H, 'a'
	DB	00H, 'c', 00H, 'k', 00H, 'e', 00H, 't', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??PushBackPacket@RakPeer@@UAEXPAUPacket@@_N@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??PushBackPacket@RakPeer@@UAEXPAUPacket@@_N@Z@4JA DD 095cH ; `RakPeer::PushBackPacket'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1BK@MHECFOMI@?$AAt?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AAM?$AAS?$AA?$DO?$AA?$DN?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@MHECFOMI@?$AAt?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AAM?$AAS?$AA?$DO?$AA?$DN?$AA0?$AA?$AA@ DB 't'
	DB	00H, 'i', 00H, 'm', 00H, 'e', 00H, 'o', 00H, 'u', 00H, 't', 00H
	DB	'M', 00H, 'S', 00H, '>', 00H, '=', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??SetUnreliableTimeout@RakPeer@@UAEXI@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??SetUnreliableTimeout@RakPeer@@UAEXI@Z@4JA DD 0897H ; `RakPeer::SetUnreliableTimeout'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1BI@DGKOLLFG@?$AAi?$AAn?$AAt?$AAe?$AAr?$AAv?$AAa?$AAl?$AA?$DO?$AA?$DN?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@DGKOLLFG@?$AAi?$AAn?$AAt?$AAe?$AAr?$AAv?$AAa?$AAl?$AA?$DO?$AA?$DN?$AA0?$AA?$AA@ DB 'i'
	DB	00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'v', 00H, 'a', 00H
	DB	'l', 00H, '>', 00H, '=', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??SetSplitMessageProgressInterval@RakPeer@@UAEXH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??SetSplitMessageProgressInterval@RakPeer@@UAEXH@Z@4JA DD 0889H ; `RakPeer::SetSplitMessageProgressInterval'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1BM@DNMMOAPD@?$AAd?$AAa?$AAt?$AAa?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?$DO?$AA?$DN?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@DNMMOAPD@?$AAd?$AAa?$AAt?$AAa?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?$DO?$AA?$DN?$AA0?$AA?$AA@ DB 'd'
	DB	00H, 'a', 00H, 't', 00H, 'a', 00H, 'L', 00H, 'e', 00H, 'n', 00H
	DB	'g', 00H, 't', 00H, 'h', 00H, '>', 00H, '=', 00H, '0', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1EM@PPGDKCEI@?$AAd?$AAa?$AAt?$AAa?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAM?$AAA?$AAX?$AA_?$AAO?$AAF?$AAF?$AAL?$AAI?$AAN?$AAE?$AA_?$AAD?$AAA?$AAT?$AAA?$AA_?$AAL@
CONST	SEGMENT
??_C@_1EM@PPGDKCEI@?$AAd?$AAa?$AAt?$AAa?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAM?$AAA?$AAX?$AA_?$AAO?$AAF?$AAF?$AAL?$AAI?$AAN?$AAE?$AA_?$AAD?$AAA?$AAT?$AAA?$AA_?$AAL@ DB 'd'
	DB	00H, 'a', 00H, 't', 00H, 'a', 00H, 'L', 00H, 'e', 00H, 'n', 00H
	DB	'g', 00H, 't', 00H, 'h', 00H, ' ', 00H, '<', 00H, '=', 00H, ' '
	DB	00H, 'M', 00H, 'A', 00H, 'X', 00H, '_', 00H, 'O', 00H, 'F', 00H
	DB	'F', 00H, 'L', 00H, 'I', 00H, 'N', 00H, 'E', 00H, '_', 00H, 'D'
	DB	00H, 'A', 00H, 'T', 00H, 'A', 00H, '_', 00H, 'L', 00H, 'E', 00H
	DB	'N', 00H, 'G', 00H, 'T', 00H, 'H', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??AdvertiseSystem@RakPeer@@UAEXPBDG0H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??AdvertiseSystem@RakPeer@@UAEXPBDG0H@Z@4JA DD 0833H ; `RakPeer::AdvertiseSystem'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1BK@PNPFLKAA@?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DM?$AA?5?$AA4?$AA0?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@PNPFLKAA@?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DM?$AA?5?$AA4?$AA0?$AA0?$AA?$AA@ DB 'l'
	DB	00H, 'e', 00H, 'n', 00H, 'g', 00H, 't', 00H, 'h', 00H, ' ', 00H
	DB	'<', 00H, ' ', 00H, '4', 00H, '0', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??SetOfflinePingResponse@RakPeer@@UAEXPBDI@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??SetOfflinePingResponse@RakPeer@@UAEXPBDI@Z@4JA DD 0767H ; `RakPeer::SetOfflinePingResponse'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1FI@DAMMCKDJ@?$AAo?$AAr?$AAd?$AAe?$AAr?$AAi?$AAn?$AAg?$AAC?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AA?5?$AA?$DO?$AA?$DN?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAo?$AAr?$AAd?$AAe?$AAr?$AAi?$AAn?$AAg?$AAC@
CONST	SEGMENT
??_C@_1FI@DAMMCKDJ@?$AAo?$AAr?$AAd?$AAe?$AAr?$AAi?$AAn?$AAg?$AAC?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AA?5?$AA?$DO?$AA?$DN?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAo?$AAr?$AAd?$AAe?$AAr?$AAi?$AAn?$AAg?$AAC@ DB 'o'
	DB	00H, 'r', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, 'C', 00H, 'h', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'e'
	DB	00H, 'l', 00H, ' ', 00H, '>', 00H, '=', 00H, '0', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, 'o', 00H, 'r', 00H, 'd', 00H, 'e'
	DB	00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 'C', 00H, 'h', 00H
	DB	'a', 00H, 'n', 00H, 'n', 00H, 'e', 00H, 'l', 00H, ' ', 00H, '<'
	DB	00H, ' ', 00H, '3', 00H, '2', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DE@MNMFCGFF@?$AAu?$AAn?$AAi?$AAq?$AAu?$AAe?$AAI?$AAD?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAu?$AAn?$AAi?$AAq?$AAu?$AAe?$AAI?$AAD?$AA?$FL?$AA?5?$AA0?$AA?5?$AA?$FN?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@MNMFCGFF@?$AAu?$AAn?$AAi?$AAq?$AAu?$AAe?$AAI?$AAD?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAu?$AAn?$AAi?$AAq?$AAu?$AAe?$AAI?$AAD?$AA?$FL?$AA?5?$AA0?$AA?5?$AA?$FN?$AA?$AA@ DB 'u'
	DB	00H, 'n', 00H, 'i', 00H, 'q', 00H, 'u', 00H, 'e', 00H, 'I', 00H
	DB	'D', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'u', 00H, 'n'
	DB	00H, 'i', 00H, 'q', 00H, 'u', 00H, 'e', 00H, 'I', 00H, 'D', 00H
	DB	'[', 00H, ' ', 00H, '0', 00H, ' ', 00H, ']', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??RPC@RakPeer@@UAE_NPADPBDIW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N5UNetworkID@@PAVBitStream@RakNet@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??RPC@RakPeer@@UAE_NPADPBDIW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N5UNetworkID@@PAVBitStream@RakNet@@@Z@4JA DD 0488H ; `RakPeer::RPC'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1CE@HHNGILKN@?$AAI?$AAs?$AAA?$AAc?$AAt?$AAi?$AAv?$AAe?$AA?$CI?$AA?$CJ?$AA?$DN?$AA?$DN?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@HHNGILKN@?$AAI?$AAs?$AAA?$AAc?$AAt?$AAi?$AAv?$AAe?$AA?$CI?$AA?$CJ?$AA?$DN?$AA?$DN?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@ DB 'I'
	DB	00H, 's', 00H, 'A', 00H, 'c', 00H, 't', 00H, 'i', 00H, 'v', 00H
	DB	'e', 00H, '(', 00H, ')', 00H, '=', 00H, '=', 00H, 'f', 00H, 'a'
	DB	00H, 'l', 00H, 's', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??UnregisterAsRemoteProcedureCall@RakPeer@@UAEXPAD@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??UnregisterAsRemoteProcedureCall@RakPeer@@UAEXPAD@Z@4JA DD 044fH ; `RakPeer::UnregisterAsRemoteProcedureCall'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1BK@NGDKLLMA@?$AAp?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@NGDKLLMA@?$AAp?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?$AA@ DB 'p'
	DB	00H, 'a', 00H, 'c', 00H, 'k', 00H, 'e', 00H, 't', 00H, '-', 00H
	DB	'>', 00H, 'd', 00H, 'a', 00H, 't', 00H, 'a', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??ReceiveIgnoreRPC@RakPeer@@IAEPAUPacket@@XZ@4JA
_DATA	SEGMENT
?__LINE__Var@?1??ReceiveIgnoreRPC@RakPeer@@IAEPAUPacket@@XZ@4JA DD 039fH ; `RakPeer::ReceiveIgnoreRPC'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1EM@PPKFOLDM@?$AAb?$AAi?$AAt?$AAS?$AAt?$AAr?$AAe?$AAa?$AAm?$AA?9?$AA?$DO?$AAG?$AAe?$AAt?$AAN?$AAu?$AAm?$AAb?$AAe?$AAr?$AAO?$AAf?$AAB?$AAy?$AAt?$AAe?$AAs?$AAU?$AAs?$AAe?$AAd?$AA?$CI@
CONST	SEGMENT
??_C@_1EM@PPKFOLDM@?$AAb?$AAi?$AAt?$AAS?$AAt?$AAr?$AAe?$AAa?$AAm?$AA?9?$AA?$DO?$AAG?$AAe?$AAt?$AAN?$AAu?$AAm?$AAb?$AAe?$AAr?$AAO?$AAf?$AAB?$AAy?$AAt?$AAe?$AAs?$AAU?$AAs?$AAe?$AAd?$AA?$CI@ DB 'b'
	DB	00H, 'i', 00H, 't', 00H, 'S', 00H, 't', 00H, 'r', 00H, 'e', 00H
	DB	'a', 00H, 'm', 00H, '-', 00H, '>', 00H, 'G', 00H, 'e', 00H, 't'
	DB	00H, 'N', 00H, 'u', 00H, 'm', 00H, 'b', 00H, 'e', 00H, 'r', 00H
	DB	'O', 00H, 'f', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's'
	DB	00H, 'U', 00H, 's', 00H, 'e', 00H, 'd', 00H, '(', 00H, ')', 00H
	DB	' ', 00H, '>', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??Send@RakPeer@@UAE_NPAVBitStream@RakNet@@W4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??Send@RakPeer@@UAE_NPAVBitStream@RakNet@@W4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N@Z@4JA DD 0362H ; `RakPeer::Send'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1CG@KMHNBCAF@?$AAd?$AAa?$AAt?$AAa?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@KMHNBCAF@?$AAd?$AAa?$AAt?$AAa?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB 'd'
	DB	00H, 'a', 00H, 't', 00H, 'a', 00H, ' ', 00H, '&', 00H, '&', 00H
	DB	' ', 00H, 'l', 00H, 'e', 00H, 'n', 00H, 'g', 00H, 't', 00H, 'h'
	DB	00H, ' ', 00H, '>', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??Send@RakPeer@@UAE_NPBDHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??Send@RakPeer@@UAE_NPBDHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N@Z@4JA DD 0347H ; `RakPeer::Send'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_07OHKHACFK@0?40?40?40?$AA@
CONST	SEGMENT
??_C@_07OHKHACFK@0?40?40?40?$AA@ DB '0.0.0.0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09PFCHIMEP@127?40?40?41?$AA@
CONST	SEGMENT
??_C@_09PFCHIMEP@127?40?40?41?$AA@ DB '127.0.0.1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_13COJANIEC@?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_13COJANIEC@?$AA0?$AA?$AA@ DB '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??InitializeSecurity@RakPeer@@UAEXPBD000@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??InitializeSecurity@RakPeer@@UAEXPBD000@Z@4JA DD 01a9H ; `RakPeer::InitializeSecurity'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1CG@FBMJBJBI@?$AAm?$AAa?$AAx?$AAC?$AAo?$AAn?$AAn?$AAe?$AAc?$AAt?$AAi?$AAo?$AAn?$AAs?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@FBMJBJBI@?$AAm?$AAa?$AAx?$AAC?$AAo?$AAn?$AAn?$AAe?$AAc?$AAt?$AAi?$AAo?$AAn?$AAs?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB 'm'
	DB	00H, 'a', 00H, 'x', 00H, 'C', 00H, 'o', 00H, 'n', 00H, 'n', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 's'
	DB	00H, ' ', 00H, '>', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
CONST	SEGMENT
??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@ DB 'z'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H
	DB	's', 00H, 'r', 00H, 'c', 00H, '\', 00H, '0', 00H, '2', 00H, 'x'
	DB	00H, 'u', 00H, '1', 00H, '\', 00H, 'r', 00H, 'a', 00H, 'k', 00H
	DB	'n', 00H, 'e', 00H, 't', 00H, '\', 00H, 'r', 00H, 'a', 00H, 'k'
	DB	00H, 'p', 00H, 'e', 00H, 'e', 00H, 'r', 00H, '.', 00H, 'c', 00H
	DB	'p', 00H, 'p', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??Initialize@RakPeer@@UAE_NGGHPBD@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??Initialize@RakPeer@@UAE_NGGHPBD@Z@4JA DD 0efH ; `RakPeer::Initialize'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_7RakPeer@@6B@
CONST	SEGMENT
??_7RakPeer@@6B@ DD FLAT:??_R4RakPeer@@6B@		; RakPeer::`vftable'
	DD	FLAT:??_ERakPeer@@UAEPAXI@Z
	DD	FLAT:?Initialize@RakPeer@@UAE_NGGHPBD@Z
	DD	FLAT:?InitializeSecurity@RakPeer@@UAEXPBD000@Z
	DD	FLAT:?DisableSecurity@RakPeer@@UAEXXZ
	DD	FLAT:?SetMaximumIncomingConnections@RakPeer@@UAEXG@Z
	DD	FLAT:?GetMaximumIncomingConnections@RakPeer@@UBEGXZ
	DD	FLAT:?SetIncomingPassword@RakPeer@@UAEXPBDH@Z
	DD	FLAT:?GetIncomingPassword@RakPeer@@UAEXPADPAH@Z
	DD	FLAT:?Connect@RakPeer@@UAE_NPBDGPADH@Z
	DD	FLAT:?Disconnect@RakPeer@@UAEXIE@Z
	DD	FLAT:?IsActive@RakPeer@@UBE_NXZ
	DD	FLAT:?GetConnectionList@RakPeer@@UBE_NPAUPlayerID@@PAG@Z
	DD	FLAT:?Send@RakPeer@@UAE_NPAVBitStream@RakNet@@W4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N@Z
	DD	FLAT:?Send@RakPeer@@UAE_NPBDHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N@Z
	DD	FLAT:?Receive@RakPeer@@UAEPAUPacket@@XZ
	DD	FLAT:?DeallocatePacket@RakPeer@@UAEXPAUPacket@@@Z
	DD	FLAT:?GetMaximumNumberOfPeers@RakPeer@@UBEGXZ
	DD	FLAT:?RegisterAsRemoteProcedureCall@RakPeer@@UAEXPADP6AXPAURPCParameters@@@Z@Z
	DD	FLAT:?RegisterClassMemberRPC@RakPeer@@UAEXPADPAX@Z
	DD	FLAT:?UnregisterAsRemoteProcedureCall@RakPeer@@UAEXPAD@Z
	DD	FLAT:?RPC@RakPeer@@UAE_NPADPAVBitStream@RakNet@@W4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N5UNetworkID@@1@Z
	DD	FLAT:?RPC@RakPeer@@UAE_NPADPBDIW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N5UNetworkID@@PAVBitStream@RakNet@@@Z
	DD	FLAT:?CloseConnection@RakPeer@@UAEXUPlayerID@@_NE@Z
	DD	FLAT:?GetIndexFromPlayerID@RakPeer@@UAEHUPlayerID@@@Z
	DD	FLAT:?GetPlayerIDFromIndex@RakPeer@@UAE?AUPlayerID@@H@Z
	DD	FLAT:?AddToBanList@RakPeer@@UAEXPBDI@Z
	DD	FLAT:?RemoveFromBanList@RakPeer@@UAEXPBD@Z
	DD	FLAT:?ClearBanList@RakPeer@@UAEXXZ
	DD	FLAT:?IsBanned@RakPeer@@UAE_NPBD@Z
	DD	FLAT:?Ping@RakPeer@@UAEXPBDG_N@Z
	DD	FLAT:?Ping@RakPeer@@UAEXUPlayerID@@@Z
	DD	FLAT:?GetAveragePing@RakPeer@@UAEHUPlayerID@@@Z
	DD	FLAT:?GetLastPing@RakPeer@@UBEHUPlayerID@@@Z
	DD	FLAT:?GetLowestPing@RakPeer@@UBEHUPlayerID@@@Z
	DD	FLAT:?SetOccasionalPing@RakPeer@@UAEX_N@Z
	DD	FLAT:?GetRemoteStaticData@RakPeer@@UAEPAVBitStream@RakNet@@UPlayerID@@@Z
	DD	FLAT:?SetRemoteStaticData@RakPeer@@UAEXUPlayerID@@PBDH@Z
	DD	FLAT:?SendStaticData@RakPeer@@UAEXUPlayerID@@@Z
	DD	FLAT:?SetOfflinePingResponse@RakPeer@@UAEXPBDI@Z
	DD	FLAT:?GetInternalID@RakPeer@@UBE?AUPlayerID@@XZ
	DD	FLAT:?GetExternalID@RakPeer@@UBE?AUPlayerID@@U2@@Z
	DD	FLAT:?SetTimeoutTime@RakPeer@@UAEXIUPlayerID@@@Z
	DD	FLAT:?SetMTUSize@RakPeer@@UAE_NH@Z
	DD	FLAT:?GetMTUSize@RakPeer@@UBEHXZ
	DD	FLAT:?GetNumberOfAddresses@RakPeer@@UAEIXZ
	DD	FLAT:?GetLocalIP@RakPeer@@UAEPBDI@Z
	DD	FLAT:?PlayerIDToDottedIP@RakPeer@@UBEPBDUPlayerID@@@Z
	DD	FLAT:?IPToPlayerID@RakPeer@@UAEXPBDGPAUPlayerID@@@Z
	DD	FLAT:?AllowConnectionResponseIPMigration@RakPeer@@UAEX_N@Z
	DD	FLAT:?AdvertiseSystem@RakPeer@@UAEXPBDG0H@Z
	DD	FLAT:?SetSplitMessageProgressInterval@RakPeer@@UAEXH@Z
	DD	FLAT:?SetUnreliableTimeout@RakPeer@@UAEXI@Z
	DD	FLAT:?SetCompileFrequencyTable@RakPeer@@UAEX_N@Z
	DD	FLAT:?GetOutgoingFrequencyTable@RakPeer@@UAE_NQAI@Z
	DD	FLAT:?GenerateCompressionLayer@RakPeer@@UAE_NQAI_N@Z
	DD	FLAT:?DeleteCompressionLayer@RakPeer@@UAE_N_N@Z
	DD	FLAT:?GetCompressionRatio@RakPeer@@UBEMXZ
	DD	FLAT:?GetDecompressionRatio@RakPeer@@UBEMXZ
	DD	FLAT:?AttachPlugin@RakPeer@@UAEXPAVPluginInterface@@@Z
	DD	FLAT:?DetachPlugin@RakPeer@@UAEXPAVPluginInterface@@@Z
	DD	FLAT:?PushBackPacket@RakPeer@@UAEXPAUPacket@@_N@Z
	DD	FLAT:?SetRouterInterface@RakPeer@@UAEXPAVRouterInterface@@@Z
	DD	FLAT:?RemoveRouterInterface@RakPeer@@UAEXPAVRouterInterface@@@Z
	DD	FLAT:?ApplyNetworkSimulator@RakPeer@@UAEXNGG@Z
	DD	FLAT:?IsNetworkSimulatorActive@RakPeer@@UAE_NXZ
	DD	FLAT:?GetStatistics@RakPeer@@UAEQAURakNetStatisticsStruct@@UPlayerID@@@Z
	DD	FLAT:?GetRPCMap@RakPeer@@UAEPAURPCMap@@UPlayerID@@@Z
CONST	ENDS
;	COMDAT ??_7RakPeerInterface@@6B@
CONST	SEGMENT
??_7RakPeerInterface@@6B@ DD FLAT:??_R4RakPeerInterface@@6B@ ; RakPeerInterface::`vftable'
	DD	FLAT:??_ERakPeerInterface@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SendImmediate@RakPeer@@IAE_NPADHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N4_J@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SendImmediate@RakPeer@@IAE_NPADHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N4_J@Z$0
__ehfuncinfo$?SendImmediate@RakPeer@@IAE_NPADHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N4_J@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SendImmediate@RakPeer@@IAE_NPADHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N4_J@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?PingInternal@RakPeer@@IAEXUPlayerID@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PingInternal@RakPeer@@IAEXUPlayerID@@_N@Z$0
__ehfuncinfo$?PingInternal@RakPeer@@IAEXUPlayerID@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PingInternal@RakPeer@@IAEXUPlayerID@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SendStaticDataInternal@RakPeer@@IAEXUPlayerID@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SendStaticDataInternal@RakPeer@@IAEXUPlayerID@@_N@Z$0
__ehfuncinfo$?SendStaticDataInternal@RakPeer@@IAEXUPlayerID@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SendStaticDataInternal@RakPeer@@IAEXUPlayerID@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?RunUpdateCycle@RakPeer@@IAE_NXZ DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?RunUpdateCycle@RakPeer@@IAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?RunUpdateCycle@RakPeer@@IAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RunUpdateCycle@RakPeer@@IAE_NXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?RunUpdateCycle@RakPeer@@IAE_NXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?RunUpdateCycle@RakPeer@@IAE_NXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?RunUpdateCycle@RakPeer@@IAE_NXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?RunUpdateCycle@RakPeer@@IAE_NXZ$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?RunUpdateCycle@RakPeer@@IAE_NXZ$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?RunUpdateCycle@RakPeer@@IAE_NXZ$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?RunUpdateCycle@RakPeer@@IAE_NXZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$?RunUpdateCycle@RakPeer@@IAE_NXZ$8
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SecuredConnectionConfirmation@RakPeer@@IAEXPAURemoteSystemStruct@1@PAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SecuredConnectionConfirmation@RakPeer@@IAEXPAURemoteSystemStruct@1@PAD@Z$0
__ehfuncinfo$?SecuredConnectionConfirmation@RakPeer@@IAEXPAURemoteSystemStruct@1@PAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SecuredConnectionConfirmation@RakPeer@@IAEXPAURemoteSystemStruct@1@PAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SecuredConnectionResponse@RakPeer@@IAEXUPlayerID@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SecuredConnectionResponse@RakPeer@@IAEXUPlayerID@@@Z$0
__ehfuncinfo$?SecuredConnectionResponse@RakPeer@@IAEXUPlayerID@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SecuredConnectionResponse@RakPeer@@IAEXUPlayerID@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QAE@XZ$0
__ehfuncinfo$??1?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?HandleRPCPacket@RakPeer@@IAE_NPBDHUPlayerID@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?HandleRPCPacket@RakPeer@@IAE_NPBDHUPlayerID@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?HandleRPCPacket@RakPeer@@IAE_NPBDHUPlayerID@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?HandleRPCPacket@RakPeer@@IAE_NPBDHUPlayerID@@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?HandleRPCPacket@RakPeer@@IAE_NPBDHUPlayerID@@@Z$3
__ehfuncinfo$?HandleRPCPacket@RakPeer@@IAE_NPBDHUPlayerID@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?HandleRPCPacket@RakPeer@@IAE_NPBDHUPlayerID@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ShiftIncomingTimestamp@RakPeer@@IBEXPAEUPlayerID@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ShiftIncomingTimestamp@RakPeer@@IBEXPAEUPlayerID@@@Z$0
__ehfuncinfo$?ShiftIncomingTimestamp@RakPeer@@IBEXPAEUPlayerID@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ShiftIncomingTimestamp@RakPeer@@IBEXPAEUPlayerID@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?NotifyAndFlagForDisconnect@RakPeer@@IAEXUPlayerID@@_NE@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?NotifyAndFlagForDisconnect@RakPeer@@IAEXUPlayerID@@_NE@Z$0
__ehfuncinfo$?NotifyAndFlagForDisconnect@RakPeer@@IAEXUPlayerID@@_NE@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?NotifyAndFlagForDisconnect@RakPeer@@IAEXUPlayerID@@_NE@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?OnConnectionRequest@RakPeer@@IAEXPAURemoteSystemStruct@1@PAE_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnConnectionRequest@RakPeer@@IAEXPAURemoteSystemStruct@1@PAE_N@Z$0
__ehfuncinfo$?OnConnectionRequest@RakPeer@@IAEXPAURemoteSystemStruct@1@PAE_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?OnConnectionRequest@RakPeer@@IAEXPAURemoteSystemStruct@1@PAE_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ProcessNetworkPacket@@YGXIGPBDHPAVRakPeer@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessNetworkPacket@@YGXIGPBDHPAVRakPeer@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessNetworkPacket@@YGXIGPBDHPAVRakPeer@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ProcessNetworkPacket@@YGXIGPBDHPAVRakPeer@@@Z$2
__ehfuncinfo$?ProcessNetworkPacket@@YGXIGPBDHPAVRakPeer@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?ProcessNetworkPacket@@YGXIGPBDHPAVRakPeer@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1RemoteSystemStruct@RakPeer@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1RemoteSystemStruct@RakPeer@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1RemoteSystemStruct@RakPeer@@QAE@XZ$1
__ehfuncinfo$??1RemoteSystemStruct@RakPeer@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1RemoteSystemStruct@RakPeer@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0RemoteSystemStruct@RakPeer@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0RemoteSystemStruct@RakPeer@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0RemoteSystemStruct@RakPeer@@QAE@XZ$1
__ehfuncinfo$??0RemoteSystemStruct@RakPeer@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0RemoteSystemStruct@RakPeer@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GenerateCompressionLayer@RakPeer@@UAE_NQAI_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GenerateCompressionLayer@RakPeer@@UAE_NQAI_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GenerateCompressionLayer@RakPeer@@UAE_NQAI_N@Z$1
__ehfuncinfo$?GenerateCompressionLayer@RakPeer@@UAE_NQAI_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GenerateCompressionLayer@RakPeer@@UAE_NQAI_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?AdvertiseSystem@RakPeer@@UAEXPBDG0H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AdvertiseSystem@RakPeer@@UAEXPBDG0H@Z$0
__ehfuncinfo$?AdvertiseSystem@RakPeer@@UAEXPBDG0H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AdvertiseSystem@RakPeer@@UAEXPBDG0H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Ping@RakPeer@@UAEXPBDG_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Ping@RakPeer@@UAEXPBDG_N@Z$0
__ehfuncinfo$?Ping@RakPeer@@UAEXPBDG_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Ping@RakPeer@@UAEXPBDG_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?RPC@RakPeer@@UAE_NPADPBDIW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N5UNetworkID@@PAVBitStream@RakNet@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RPC@RakPeer@@UAE_NPADPBDIW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N5UNetworkID@@PAVBitStream@RakNet@@@Z$0
__ehfuncinfo$?RPC@RakPeer@@UAE_NPADPBDIW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N5UNetworkID@@PAVBitStream@RakNet@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RPC@RakPeer@@UAE_NPADPBDIW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N5UNetworkID@@PAVBitStream@RakNet@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Initialize@RakPeer@@UAE_NGGHPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Initialize@RakPeer@@UAE_NGGHPBD@Z$0
__ehfuncinfo$?Initialize@RakPeer@@UAE_NGGHPBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Initialize@RakPeer@@UAE_NGGHPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1RakPeer@@UAE@XZ DD 019930522H
	DD	0fH
	DD	FLAT:__unwindtable$??1RakPeer@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1RakPeer@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1RakPeer@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1RakPeer@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1RakPeer@@UAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1RakPeer@@UAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1RakPeer@@UAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1RakPeer@@UAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1RakPeer@@UAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1RakPeer@@UAE@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??1RakPeer@@UAE@XZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$??1RakPeer@@UAE@XZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$??1RakPeer@@UAE@XZ$10
	DD	0aH
	DD	FLAT:__unwindfunclet$??1RakPeer@@UAE@XZ$11
	DD	0bH
	DD	FLAT:__unwindfunclet$??1RakPeer@@UAE@XZ$12
	DD	0cH
	DD	FLAT:__unwindfunclet$??1RakPeer@@UAE@XZ$13
	DD	0dH
	DD	FLAT:__unwindfunclet$??1RakPeer@@UAE@XZ$14
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0RakPeer@@QAE@XZ DD 019930522H
	DD	0fH
	DD	FLAT:__unwindtable$??0RakPeer@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0RakPeer@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0RakPeer@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0RakPeer@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0RakPeer@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0RakPeer@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0RakPeer@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0RakPeer@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0RakPeer@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??0RakPeer@@QAE@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??0RakPeer@@QAE@XZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$??0RakPeer@@QAE@XZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$??0RakPeer@@QAE@XZ$10
	DD	0aH
	DD	FLAT:__unwindfunclet$??0RakPeer@@QAE@XZ$11
	DD	0bH
	DD	FLAT:__unwindfunclet$??0RakPeer@@QAE@XZ$12
	DD	0cH
	DD	FLAT:__unwindfunclet$??0RakPeer@@QAE@XZ$13
	DD	0dH
	DD	FLAT:__unwindfunclet$??0RakPeer@@QAE@XZ$14
xdata$x	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$usetlow@$$BY07I$$BY07I@big@@YAXAAY07I0@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$usetlow@$$BY07I$$BY07I@big@@YAXAAY07I0@Z PROC	; big::usetlow<unsigned int [8],unsigned int [8]>, COMDAT

; 314  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 315  : 		memcpy( a, b, sizeof( T ) );

	push	32					; 00000020H
	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 316  : #ifdef _MSC_VER
; 317  : #pragma warning( disable : 4318 ) // warning C4318: passing constant zero as the length to memset
; 318  : #endif
; 319  : 		memset( a + BIGWORDCOUNT( T ), 0, sizeof( Bigger ) - sizeof( T ) );

	push	0
	push	0
	mov	eax, DWORD PTR _a$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 320  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$usetlow@$$BY07I$$BY07I@big@@YAXAAY07I0@Z ENDP	; big::usetlow<unsigned int [8],unsigned int [8]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$umultiply@$$BY07I$$BY0BA@I@big@@YAXAAY0BA@IAAY07I@Z
_TEXT	SEGMENT
_ctr$1 = -120						; size = 2
_w_i$2 = -108						; size = 4
_ii$3 = -96						; size = 4
_shifts$ = -84						; size = 4
_a$ = -72						; size = 64
__$ArrayPad$ = -4					; size = 4
_a0$ = 8						; size = 4
_b0$ = 12						; size = 4
??$umultiply@$$BY07I$$BY0BA@I@big@@YAXAAY0BA@IAAY07I@Z PROC ; big::umultiply<unsigned int [8],unsigned int [16]>, COMDAT

; 956  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 316				; 0000013cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-316]
	mov	ecx, 79					; 0000004fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 957  : 		Bigger a;
; 958  : 		
; 959  : 		set ( a, a0 )
; 960  : 		
; 961  : 		;

	mov	eax, DWORD PTR _a0$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	??$set@$$BY0BA@I@big@@YAXAAY0BA@I0@Z	; big::set<unsigned int [16]>
	add	esp, 8

; 962  : 		
; 963  : 		zero( a0 );

	mov	eax, DWORD PTR _a0$[ebp]
	push	eax
	call	??$zero@$$BY0BA@I@big@@YAXAAY0BA@I@Z	; big::zero<unsigned int [16]>
	add	esp, 4

; 964  : 		
; 965  : 		u32 shifts = 0;

	mov	DWORD PTR _shifts$[ebp], 0

; 966  : 		
; 967  : 		for ( u32 ii = 0; ii < BIGWORDCOUNT( T ); ++ii )

	mov	DWORD PTR _ii$3[ebp], 0
	jmp	SHORT $LN7@umultiply
$LN6@umultiply:
	mov	eax, DWORD PTR _ii$3[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$3[ebp], eax
$LN7@umultiply:
	cmp	DWORD PTR _ii$3[ebp], 8
	jae	SHORT $LN8@umultiply

; 968  : 		{
; 969  : 			word w_i = b0[ ii ];

	mov	eax, DWORD PTR _ii$3[ebp]
	mov	ecx, DWORD PTR _b0$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _w_i$2[ebp], edx

; 970  : 			
; 971  : 			u16 ctr = WORDBITS;

	mov	eax, 32					; 00000020H
	mov	WORD PTR _ctr$1[ebp], ax
$LN4@umultiply:

; 972  : 			
; 973  : 			while ( w_i )

	cmp	DWORD PTR _w_i$2[ebp], 0
	je	SHORT $LN3@umultiply

; 974  : 			{
; 975  : 				if ( w_i & 1 )

	mov	eax, DWORD PTR _w_i$2[ebp]
	and	eax, 1
	je	SHORT $LN2@umultiply

; 976  : 				{
; 977  : 					if ( shifts )

	cmp	DWORD PTR _shifts$[ebp], 0
	je	SHORT $LN1@umultiply

; 978  : 					{
; 979  : 						shiftLeft( a, shifts );

	mov	eax, DWORD PTR _shifts$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	??$shiftLeft@$$BY0BA@I@big@@YAXAAY0BA@II@Z ; big::shiftLeft<unsigned int [16]>
	add	esp, 8

; 980  : 						shifts = 0;

	mov	DWORD PTR _shifts$[ebp], 0
$LN1@umultiply:

; 981  : 					}
; 982  : 					
; 983  : 					add ( a0, a )
; 984  : 					
; 985  : 					;

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a0$[ebp]
	push	ecx
	call	??$add@$$BY0BA@I@big@@YAXAAY0BA@I0@Z	; big::add<unsigned int [16]>
	add	esp, 8
$LN2@umultiply:

; 986  : 				}
; 987  : 				
; 988  : 				w_i >>= 1;

	mov	eax, DWORD PTR _w_i$2[ebp]
	shr	eax, 1
	mov	DWORD PTR _w_i$2[ebp], eax

; 989  : 				++shifts;

	mov	eax, DWORD PTR _shifts$[ebp]
	add	eax, 1
	mov	DWORD PTR _shifts$[ebp], eax

; 990  : 				--ctr;

	mov	ax, WORD PTR _ctr$1[ebp]
	sub	ax, 1
	mov	WORD PTR _ctr$1[ebp], ax

; 991  : 			}

	jmp	SHORT $LN4@umultiply
$LN3@umultiply:

; 992  : 			
; 993  : 			shifts += ctr;

	movzx	eax, WORD PTR _ctr$1[ebp]
	add	eax, DWORD PTR _shifts$[ebp]
	mov	DWORD PTR _shifts$[ebp], eax

; 994  : 		}

	jmp	$LN6@umultiply
$LN8@umultiply:

; 995  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@umultiply
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@umultiply:
	DD	1
	DD	$LN11@umultiply
$LN11@umultiply:
	DD	-72					; ffffffb8H
	DD	64					; 00000040H
	DD	$LN10@umultiply
$LN10@umultiply:
	DB	97					; 00000061H
	DB	0
??$umultiply@$$BY07I$$BY0BA@I@big@@YAXAAY0BA@IAAY07I@Z ENDP ; big::umultiply<unsigned int [8],unsigned int [16]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$umultiply@$$BY03I$$BY07I@big@@YAXAAY07IAAY03I@Z
_TEXT	SEGMENT
_ctr$1 = -88						; size = 2
_w_i$2 = -76						; size = 4
_ii$3 = -64						; size = 4
_shifts$ = -52						; size = 4
_a$ = -40						; size = 32
__$ArrayPad$ = -4					; size = 4
_a0$ = 8						; size = 4
_b0$ = 12						; size = 4
??$umultiply@$$BY03I$$BY07I@big@@YAXAAY07IAAY03I@Z PROC	; big::umultiply<unsigned int [4],unsigned int [8]>, COMDAT

; 956  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 284				; 0000011cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-284]
	mov	ecx, 71					; 00000047H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 957  : 		Bigger a;
; 958  : 		
; 959  : 		set ( a, a0 )
; 960  : 		
; 961  : 		;

	mov	eax, DWORD PTR _a0$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	??$set@$$BY07I@big@@YAXAAY07I0@Z	; big::set<unsigned int [8]>
	add	esp, 8

; 962  : 		
; 963  : 		zero( a0 );

	mov	eax, DWORD PTR _a0$[ebp]
	push	eax
	call	??$zero@$$BY07I@big@@YAXAAY07I@Z	; big::zero<unsigned int [8]>
	add	esp, 4

; 964  : 		
; 965  : 		u32 shifts = 0;

	mov	DWORD PTR _shifts$[ebp], 0

; 966  : 		
; 967  : 		for ( u32 ii = 0; ii < BIGWORDCOUNT( T ); ++ii )

	mov	DWORD PTR _ii$3[ebp], 0
	jmp	SHORT $LN7@umultiply
$LN6@umultiply:
	mov	eax, DWORD PTR _ii$3[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$3[ebp], eax
$LN7@umultiply:
	cmp	DWORD PTR _ii$3[ebp], 4
	jae	SHORT $LN8@umultiply

; 968  : 		{
; 969  : 			word w_i = b0[ ii ];

	mov	eax, DWORD PTR _ii$3[ebp]
	mov	ecx, DWORD PTR _b0$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _w_i$2[ebp], edx

; 970  : 			
; 971  : 			u16 ctr = WORDBITS;

	mov	eax, 32					; 00000020H
	mov	WORD PTR _ctr$1[ebp], ax
$LN4@umultiply:

; 972  : 			
; 973  : 			while ( w_i )

	cmp	DWORD PTR _w_i$2[ebp], 0
	je	SHORT $LN3@umultiply

; 974  : 			{
; 975  : 				if ( w_i & 1 )

	mov	eax, DWORD PTR _w_i$2[ebp]
	and	eax, 1
	je	SHORT $LN2@umultiply

; 976  : 				{
; 977  : 					if ( shifts )

	cmp	DWORD PTR _shifts$[ebp], 0
	je	SHORT $LN1@umultiply

; 978  : 					{
; 979  : 						shiftLeft( a, shifts );

	mov	eax, DWORD PTR _shifts$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	??$shiftLeft@$$BY07I@big@@YAXAAY07II@Z	; big::shiftLeft<unsigned int [8]>
	add	esp, 8

; 980  : 						shifts = 0;

	mov	DWORD PTR _shifts$[ebp], 0
$LN1@umultiply:

; 981  : 					}
; 982  : 					
; 983  : 					add ( a0, a )
; 984  : 					
; 985  : 					;

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a0$[ebp]
	push	ecx
	call	??$add@$$BY07I@big@@YAXAAY07I0@Z	; big::add<unsigned int [8]>
	add	esp, 8
$LN2@umultiply:

; 986  : 				}
; 987  : 				
; 988  : 				w_i >>= 1;

	mov	eax, DWORD PTR _w_i$2[ebp]
	shr	eax, 1
	mov	DWORD PTR _w_i$2[ebp], eax

; 989  : 				++shifts;

	mov	eax, DWORD PTR _shifts$[ebp]
	add	eax, 1
	mov	DWORD PTR _shifts$[ebp], eax

; 990  : 				--ctr;

	mov	ax, WORD PTR _ctr$1[ebp]
	sub	ax, 1
	mov	WORD PTR _ctr$1[ebp], ax

; 991  : 			}

	jmp	SHORT $LN4@umultiply
$LN3@umultiply:

; 992  : 			
; 993  : 			shifts += ctr;

	movzx	eax, WORD PTR _ctr$1[ebp]
	add	eax, DWORD PTR _shifts$[ebp]
	mov	DWORD PTR _shifts$[ebp], eax

; 994  : 		}

	jmp	$LN6@umultiply
$LN8@umultiply:

; 995  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@umultiply
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 284				; 0000011cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@umultiply:
	DD	1
	DD	$LN11@umultiply
$LN11@umultiply:
	DD	-40					; ffffffd8H
	DD	32					; 00000020H
	DD	$LN10@umultiply
$LN10@umultiply:
	DB	97					; 00000061H
	DB	0
??$umultiply@$$BY03I$$BY07I@big@@YAXAAY07IAAY03I@Z ENDP	; big::umultiply<unsigned int [4],unsigned int [8]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$shiftLeft1@$$BY03I@big@@YAXAAY03I@Z
_TEXT	SEGMENT
_ii$1 = -32						; size = 4
_carry$ = -20						; size = 4
_w_i$ = -8						; size = 4
_n$ = 8							; size = 4
??$shiftLeft1@$$BY03I@big@@YAXAAY03I@Z PROC		; big::shiftLeft1<unsigned int [4]>, COMDAT

; 463  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 464  : 		register word w_i, carry = 0;

	mov	DWORD PTR _carry$[ebp], 0

; 465  : 		
; 466  : 		for ( u32 ii = 0; ii < BIGWORDCOUNT( T ); ++ii )

	mov	DWORD PTR _ii$1[ebp], 0
	jmp	SHORT $LN3@shiftLeft1
$LN2@shiftLeft1:
	mov	eax, DWORD PTR _ii$1[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$1[ebp], eax
$LN3@shiftLeft1:
	cmp	DWORD PTR _ii$1[ebp], 4
	jae	SHORT $LN4@shiftLeft1

; 467  : 		{
; 468  : 			w_i = n[ ii ];

	mov	eax, DWORD PTR _ii$1[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _w_i$[ebp], edx

; 469  : 			
; 470  : 			n[ ii ] = ( w_i << 1 ) | carry;

	mov	eax, DWORD PTR _w_i$[ebp]
	shl	eax, 1
	or	eax, DWORD PTR _carry$[ebp]
	mov	ecx, DWORD PTR _ii$1[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 471  : 			carry = w_i >> ( WORDBITS - 1 );

	mov	eax, DWORD PTR _w_i$[ebp]
	shr	eax, 31					; 0000001fH
	mov	DWORD PTR _carry$[ebp], eax

; 472  : 		}

	jmp	SHORT $LN2@shiftLeft1
$LN4@shiftLeft1:

; 473  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$shiftLeft1@$$BY03I@big@@YAXAAY03I@Z ENDP		; big::shiftLeft1<unsigned int [4]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$shiftLeft@$$BY03I@big@@YAXAAY03II@Z
_TEXT	SEGMENT
_ii$1 = -68						; size = 4
_carry$2 = -56						; size = 4
_w_i$3 = -44						; size = 4
_bits$ = -32						; size = 4
_bases$ = -20						; size = 4
_ii$ = -8						; size = 4
_n$ = 8							; size = 4
_s$ = 12						; size = 4
??$shiftLeft@$$BY03I@big@@YAXAAY03II@Z PROC		; big::shiftLeft<unsigned int [4]>, COMDAT

; 477  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 478  : 		register s32 ii;
; 479  : 		register u32 bases = s / WORDBITS;

	mov	eax, DWORD PTR _s$[ebp]
	shr	eax, 5
	mov	DWORD PTR _bases$[ebp], eax

; 480  : 		u32 bits = s % WORDBITS;

	mov	eax, DWORD PTR _s$[ebp]
	xor	edx, edx
	mov	ecx, 32					; 00000020H
	div	ecx
	mov	DWORD PTR _bits$[ebp], edx

; 481  : 		
; 482  : 		// move whole bases first
; 483  : 		
; 484  : 		if ( bases )

	cmp	DWORD PTR _bases$[ebp], 0
	je	SHORT $LN8@shiftLeft

; 485  : 		{
; 486  : 			// shift bases
; 487  : 			
; 488  : 			for ( ii = BIGWORDCOUNT( T ) - 1 - bases; ii >= 0; --ii )

	mov	eax, 3
	sub	eax, DWORD PTR _bases$[ebp]
	mov	DWORD PTR _ii$[ebp], eax
	jmp	SHORT $LN7@shiftLeft
$LN6@shiftLeft:
	mov	eax, DWORD PTR _ii$[ebp]
	sub	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
$LN7@shiftLeft:
	cmp	DWORD PTR _ii$[ebp], 0
	jl	SHORT $LN5@shiftLeft

; 489  : 				n[ ii + bases ] = n[ ii ];

	mov	eax, DWORD PTR _ii$[ebp]
	add	eax, DWORD PTR _bases$[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _ii$[ebp]
	mov	esi, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax*4], edx
	jmp	SHORT $LN6@shiftLeft
$LN5@shiftLeft:

; 490  : 				
; 491  : 			// clear the original locii of those bases
; 492  : 			memset( n, 0, bases * sizeof( word ) );

	mov	eax, DWORD PTR _bases$[ebp]
	shl	eax, 2
	push	eax
	push	0
	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
$LN8@shiftLeft:

; 493  : 		}
; 494  : 		
; 495  : 		if ( bits )

	cmp	DWORD PTR _bits$[ebp], 0
	je	SHORT $LN9@shiftLeft

; 496  : 		{
; 497  : 			register word w_i, carry = 0;

	mov	DWORD PTR _carry$2[ebp], 0

; 498  : 			
; 499  : 			for ( u32 ii = 0; ii < BIGWORDCOUNT( T ); ++ii )

	mov	DWORD PTR _ii$1[ebp], 0
	jmp	SHORT $LN3@shiftLeft
$LN2@shiftLeft:
	mov	eax, DWORD PTR _ii$1[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$1[ebp], eax
$LN3@shiftLeft:
	cmp	DWORD PTR _ii$1[ebp], 4
	jae	SHORT $LN9@shiftLeft

; 500  : 			{
; 501  : 				w_i = n[ ii ];

	mov	eax, DWORD PTR _ii$1[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _w_i$3[ebp], edx

; 502  : 				
; 503  : 				n[ ii ] = ( w_i << bits ) | carry;

	mov	eax, DWORD PTR _w_i$3[ebp]
	mov	ecx, DWORD PTR _bits$[ebp]
	shl	eax, cl
	or	eax, DWORD PTR _carry$2[ebp]
	mov	ecx, DWORD PTR _ii$1[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 504  : 				carry = w_i >> ( WORDBITS - bits );

	mov	ecx, 32					; 00000020H
	sub	ecx, DWORD PTR _bits$[ebp]
	mov	eax, DWORD PTR _w_i$3[ebp]
	shr	eax, cl
	mov	DWORD PTR _carry$2[ebp], eax

; 505  : 			}

	jmp	SHORT $LN2@shiftLeft
$LN9@shiftLeft:

; 506  : 		}
; 507  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$shiftLeft@$$BY03I@big@@YAXAAY03II@Z ENDP		; big::shiftLeft<unsigned int [4]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$usetlow@$$BY0BA@I$$BY0BA@I@big@@YAXAAY0BA@I0@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$usetlow@$$BY0BA@I$$BY0BA@I@big@@YAXAAY0BA@I0@Z PROC	; big::usetlow<unsigned int [16],unsigned int [16]>, COMDAT

; 314  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 315  : 		memcpy( a, b, sizeof( T ) );

	push	64					; 00000040H
	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 316  : #ifdef _MSC_VER
; 317  : #pragma warning( disable : 4318 ) // warning C4318: passing constant zero as the length to memset
; 318  : #endif
; 319  : 		memset( a + BIGWORDCOUNT( T ), 0, sizeof( Bigger ) - sizeof( T ) );

	push	0
	push	0
	mov	eax, DWORD PTR _a$[ebp]
	add	eax, 64					; 00000040H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 320  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$usetlow@$$BY0BA@I$$BY0BA@I@big@@YAXAAY0BA@I0@Z ENDP	; big::usetlow<unsigned int [16],unsigned int [16]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$add@$$BY0BA@I@big@@YAXAAY0BA@I0@Z
_TEXT	SEGMENT
_qc1$ = -8						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$add@$$BY0BA@I@big@@YAXAAY0BA@I0@Z PROC		; big::add<unsigned int [16]>, COMDAT

; 658  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 659  : #if defined(NO_TEMPLATE_INLINE_ASSEMBLY) && defined(ASSEMBLY_INTEL_SYNTAX)
; 660  : 		const u32 qc1 = BIGWORDCOUNT( T ) / 4 - 1;
; 661  : 		
; 662  : 		BorlandAdd( a, b, qc1 );
; 663  : 		
; 664  : #elif defined(ASSEMBLY_INTEL_SYNTAX)
; 665  : 		
; 666  : 		const u32 qc1 = BIGWORDCOUNT( T ) / 4 - 1;

	mov	DWORD PTR _qc1$[ebp], 3

; 667  : 		
; 668  : 		ASSEMBLY_BLOCK // VS.NET, x86, 32-bit words
; 669  : 		{
; 670  : 		        mov esi, b

	mov	esi, DWORD PTR _b$[ebp]

; 671  : 		        mov edi, a

	mov	edi, DWORD PTR _a$[ebp]

; 672  : 		        mov ecx, qc1

	mov	ecx, DWORD PTR _qc1$[ebp]

; 673  : 		
; 674  : 		        // unrolled loop since word count is a multiple of 4 >= 4
; 675  : 		        mov eax, [ esi ]

	mov	eax, DWORD PTR [esi]

; 676  : 		        xor edx, edx  // edx used later to index later words >= 4

	xor	edx, edx

; 677  : 		
; 678  : 		        add [ edi ], eax  // and now we can use ADD instead of ADC on the first addition

	add	DWORD PTR [edi], eax

; 679  : 		        mov eax, [ esi + 4 ]

	mov	eax, DWORD PTR [esi+4]

; 680  : 		        adc [ edi + 4 ], eax

	adc	DWORD PTR [edi+4], eax

; 681  : 		        mov eax, [ esi + 8 ]

	mov	eax, DWORD PTR [esi+8]

; 682  : 		        adc [ edi + 8 ], eax

	adc	DWORD PTR [edi+8], eax

; 683  : 		        mov eax, [ esi + 12 ]

	mov	eax, DWORD PTR [esi+12]

; 684  : 		        adc [ edi + 12 ], eax

	adc	DWORD PTR [edi+12], eax

; 685  : 		
; 686  : 		        jecxz done_already

	jecxz	$done_already$3
$next_word$4:

; 687  : 		
; 688  : 	        next_word:
; 689  : 		        inc edx

	inc	edx

; 690  : 		        inc edx

	inc	edx

; 691  : 		
; 692  : 		        // unrolled loop since word count is a multiple of 4 >= 4
; 693  : 		        mov eax, [ esi + edx * 8 ]

	mov	eax, DWORD PTR [esi+edx*8]

; 694  : 		        adc [ edi + edx * 8 ], eax

	adc	DWORD PTR [edi+edx*8], eax

; 695  : 		        mov eax, [ esi + edx * 8 + 4 ]

	mov	eax, DWORD PTR [esi+edx*8+4]

; 696  : 		        adc [ edi + edx * 8 + 4 ], eax

	adc	DWORD PTR [edi+edx*8+4], eax

; 697  : 		        mov eax, [ esi + edx * 8 + 8 ]

	mov	eax, DWORD PTR [esi+edx*8+8]

; 698  : 		        adc [ edi + edx * 8 + 8 ], eax

	adc	DWORD PTR [edi+edx*8+8], eax

; 699  : 		        mov eax, [ esi + edx * 8 + 12 ]

	mov	eax, DWORD PTR [esi+edx*8+12]

; 700  : 		        adc [ edi + edx * 8 + 12 ], eax

	adc	DWORD PTR [edi+edx*8+12], eax

; 701  : 		
; 702  : 		        loop next_word

	loop	$next_word$4
$done_already$3:

; 703  : 		
; 704  : 	        done_already:
; 705  : 		}
; 706  : #else
; 707  : 		register word carry = 0;
; 708  : 		
; 709  : 		for ( u32 ii = 0; ii < BIGWORDCOUNT( T ); ++ii )
; 710  : 		{
; 711  : 			word a_i = a[ ii ];
; 712  : 			word b_i = b[ ii ];
; 713  : 			a[ ii ] += b_i + carry;
; 714  : 		
; 715  : 			carry = ( ( a_i & ( WORDALLBITS >> 1 ) ) + ( b_i & ( WORDALLBITS >> 1 ) ) + carry ) >> ( WORDBITS - 1 );
; 716  : 			carry += ( a_i >> ( WORDBITS - 1 ) ) + ( b_i >> ( WORDBITS - 1 ) );
; 717  : 			carry >>= 1;
; 718  : 		}
; 719  : 		
; 720  : #endif
; 721  : 		
; 722  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$add@$$BY0BA@I@big@@YAXAAY0BA@I0@Z ENDP		; big::add<unsigned int [16]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$umultiply@$$BY07I$$BY07I@big@@YAXAAY07I00@Z
_TEXT	SEGMENT
_ctr$1 = -88						; size = 2
_w_i$2 = -76						; size = 4
_ii$3 = -64						; size = 4
_shifts$ = -52						; size = 4
_a$ = -40						; size = 32
__$ArrayPad$ = -4					; size = 4
_a0$ = 8						; size = 4
_b0$ = 12						; size = 4
_m$ = 16						; size = 4
??$umultiply@$$BY07I$$BY07I@big@@YAXAAY07I00@Z PROC	; big::umultiply<unsigned int [8],unsigned int [8]>, COMDAT

; 916  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 284				; 0000011cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-284]
	mov	ecx, 71					; 00000047H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 917  : 		Bigger a;
; 918  : 		usetlow( a, a0 );

	mov	eax, DWORD PTR _a0$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	??$usetlow@$$BY07I$$BY07I@big@@YAXAAY07I0@Z ; big::usetlow<unsigned int [8],unsigned int [8]>
	add	esp, 8

; 919  : 		
; 920  : 		zero( m );

	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	call	??$zero@$$BY07I@big@@YAXAAY07I@Z	; big::zero<unsigned int [8]>
	add	esp, 4

; 921  : 		
; 922  : 		u32 shifts = 0;

	mov	DWORD PTR _shifts$[ebp], 0

; 923  : 		
; 924  : 		for ( u32 ii = 0; ii < BIGWORDCOUNT( T ); ++ii )

	mov	DWORD PTR _ii$3[ebp], 0
	jmp	SHORT $LN7@umultiply
$LN6@umultiply:
	mov	eax, DWORD PTR _ii$3[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$3[ebp], eax
$LN7@umultiply:
	cmp	DWORD PTR _ii$3[ebp], 8
	jae	SHORT $LN8@umultiply

; 925  : 		{
; 926  : 			word w_i = b0[ ii ];

	mov	eax, DWORD PTR _ii$3[ebp]
	mov	ecx, DWORD PTR _b0$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _w_i$2[ebp], edx

; 927  : 			
; 928  : 			u16 ctr = WORDBITS;

	mov	eax, 32					; 00000020H
	mov	WORD PTR _ctr$1[ebp], ax
$LN4@umultiply:

; 929  : 			
; 930  : 			while ( w_i )

	cmp	DWORD PTR _w_i$2[ebp], 0
	je	SHORT $LN3@umultiply

; 931  : 			{
; 932  : 				if ( w_i & 1 )

	mov	eax, DWORD PTR _w_i$2[ebp]
	and	eax, 1
	je	SHORT $LN2@umultiply

; 933  : 				{
; 934  : 					if ( shifts )

	cmp	DWORD PTR _shifts$[ebp], 0
	je	SHORT $LN1@umultiply

; 935  : 					{
; 936  : 						shiftLeft( a, shifts );

	mov	eax, DWORD PTR _shifts$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	??$shiftLeft@$$BY07I@big@@YAXAAY07II@Z	; big::shiftLeft<unsigned int [8]>
	add	esp, 8

; 937  : 						shifts = 0;

	mov	DWORD PTR _shifts$[ebp], 0
$LN1@umultiply:

; 938  : 					}
; 939  : 					
; 940  : 					add ( m, a )
; 941  : 					
; 942  : 					;

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	mov	ecx, DWORD PTR _m$[ebp]
	push	ecx
	call	??$add@$$BY07I@big@@YAXAAY07I0@Z	; big::add<unsigned int [8]>
	add	esp, 8
$LN2@umultiply:

; 943  : 				}
; 944  : 				
; 945  : 				w_i >>= 1;

	mov	eax, DWORD PTR _w_i$2[ebp]
	shr	eax, 1
	mov	DWORD PTR _w_i$2[ebp], eax

; 946  : 				++shifts;

	mov	eax, DWORD PTR _shifts$[ebp]
	add	eax, 1
	mov	DWORD PTR _shifts$[ebp], eax

; 947  : 				--ctr;

	mov	ax, WORD PTR _ctr$1[ebp]
	sub	ax, 1
	mov	WORD PTR _ctr$1[ebp], ax

; 948  : 			}

	jmp	SHORT $LN4@umultiply
$LN3@umultiply:

; 949  : 			
; 950  : 			shifts += ctr;

	movzx	eax, WORD PTR _ctr$1[ebp]
	add	eax, DWORD PTR _shifts$[ebp]
	mov	DWORD PTR _shifts$[ebp], eax

; 951  : 		}

	jmp	$LN6@umultiply
$LN8@umultiply:

; 952  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@umultiply
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 284				; 0000011cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@umultiply:
	DD	1
	DD	$LN11@umultiply
$LN11@umultiply:
	DD	-40					; ffffffd8H
	DD	32					; 00000020H
	DD	$LN10@umultiply
$LN10@umultiply:
	DB	97					; 00000061H
	DB	0
??$umultiply@$$BY07I$$BY07I@big@@YAXAAY07I00@Z ENDP	; big::umultiply<unsigned int [8],unsigned int [8]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$usquare@$$BY07I@big@@YAXAAY07I@Z
_TEXT	SEGMENT
_ctr$1 = -128						; size = 2
_w_i$2 = -116						; size = 4
_ii$3 = -104						; size = 4
_shifts$ = -92						; size = 4
_a1$ = -80						; size = 32
_a0$ = -40						; size = 32
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
??$usquare@$$BY07I@big@@YAXAAY07I@Z PROC		; big::usquare<unsigned int [8]>, COMDAT

; 871  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 324				; 00000144H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-324]
	mov	ecx, 81					; 00000051H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 872  : 		T a0, a1;
; 873  : 		
; 874  : 		set ( a0, a )
; 875  : 		
; 876  : 		;

	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a0$[ebp]
	push	ecx
	call	??$set@$$BY07I@big@@YAXAAY07I0@Z	; big::set<unsigned int [8]>
	add	esp, 8

; 877  : 		set ( a1, a )
; 878  : 		
; 879  : 		;

	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a1$[ebp]
	push	ecx
	call	??$set@$$BY07I@big@@YAXAAY07I0@Z	; big::set<unsigned int [8]>
	add	esp, 8

; 880  : 		zero( a );

	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	??$zero@$$BY07I@big@@YAXAAY07I@Z	; big::zero<unsigned int [8]>
	add	esp, 4

; 881  : 		
; 882  : 		u32 shifts = 0;

	mov	DWORD PTR _shifts$[ebp], 0

; 883  : 		
; 884  : 		for ( u32 ii = 0; ii < BIGWORDCOUNT( T ); ++ii )

	mov	DWORD PTR _ii$3[ebp], 0
	jmp	SHORT $LN7@usquare
$LN6@usquare:
	mov	eax, DWORD PTR _ii$3[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$3[ebp], eax
$LN7@usquare:
	cmp	DWORD PTR _ii$3[ebp], 8
	jae	SHORT $LN8@usquare

; 885  : 		{
; 886  : 			word w_i = a0[ ii ];

	mov	eax, DWORD PTR _ii$3[ebp]
	mov	ecx, DWORD PTR _a0$[ebp+eax*4]
	mov	DWORD PTR _w_i$2[ebp], ecx

; 887  : 			
; 888  : 			u16 ctr = WORDBITS;

	mov	eax, 32					; 00000020H
	mov	WORD PTR _ctr$1[ebp], ax
$LN4@usquare:

; 889  : 			
; 890  : 			while ( w_i )

	cmp	DWORD PTR _w_i$2[ebp], 0
	je	SHORT $LN3@usquare

; 891  : 			{
; 892  : 				if ( w_i & 1 )

	mov	eax, DWORD PTR _w_i$2[ebp]
	and	eax, 1
	je	SHORT $LN2@usquare

; 893  : 				{
; 894  : 					if ( shifts )

	cmp	DWORD PTR _shifts$[ebp], 0
	je	SHORT $LN1@usquare

; 895  : 					{
; 896  : 						shiftLeft( a1, shifts );

	mov	eax, DWORD PTR _shifts$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a1$[ebp]
	push	ecx
	call	??$shiftLeft@$$BY07I@big@@YAXAAY07II@Z	; big::shiftLeft<unsigned int [8]>
	add	esp, 8

; 897  : 						shifts = 0;

	mov	DWORD PTR _shifts$[ebp], 0
$LN1@usquare:

; 898  : 					}
; 899  : 					
; 900  : 					add ( a, a1 )
; 901  : 					
; 902  : 					;

	lea	eax, DWORD PTR _a1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	??$add@$$BY07I@big@@YAXAAY07I0@Z	; big::add<unsigned int [8]>
	add	esp, 8
$LN2@usquare:

; 903  : 				}
; 904  : 				
; 905  : 				w_i >>= 1;

	mov	eax, DWORD PTR _w_i$2[ebp]
	shr	eax, 1
	mov	DWORD PTR _w_i$2[ebp], eax

; 906  : 				++shifts;

	mov	eax, DWORD PTR _shifts$[ebp]
	add	eax, 1
	mov	DWORD PTR _shifts$[ebp], eax

; 907  : 				--ctr;

	mov	ax, WORD PTR _ctr$1[ebp]
	sub	ax, 1
	mov	WORD PTR _ctr$1[ebp], ax

; 908  : 			}

	jmp	SHORT $LN4@usquare
$LN3@usquare:

; 909  : 			
; 910  : 			shifts += ctr;

	movzx	eax, WORD PTR _ctr$1[ebp]
	add	eax, DWORD PTR _shifts$[ebp]
	mov	DWORD PTR _shifts$[ebp], eax

; 911  : 		}

	jmp	$LN6@usquare
$LN8@usquare:

; 912  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN13@usquare
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 324				; 00000144H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN13@usquare:
	DD	2
	DD	$LN12@usquare
$LN12@usquare:
	DD	-40					; ffffffd8H
	DD	32					; 00000020H
	DD	$LN10@usquare
	DD	-80					; ffffffb0H
	DD	32					; 00000020H
	DD	$LN11@usquare
$LN11@usquare:
	DB	97					; 00000061H
	DB	49					; 00000031H
	DB	0
$LN10@usquare:
	DB	97					; 00000061H
	DB	48					; 00000030H
	DB	0
??$usquare@$$BY07I@big@@YAXAAY07I@Z ENDP		; big::usquare<unsigned int [8]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$ushiftRight1@$$BY07I@big@@YAXAAY07I@Z
_TEXT	SEGMENT
_ii$1 = -32						; size = 4
_carry$ = -20						; size = 4
_w_i$ = -8						; size = 4
_n$ = 8							; size = 4
??$ushiftRight1@$$BY07I@big@@YAXAAY07I@Z PROC		; big::ushiftRight1<unsigned int [8]>, COMDAT

; 511  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 512  : 		register word w_i, carry = 0;

	mov	DWORD PTR _carry$[ebp], 0

; 513  : 		
; 514  : 		for ( s32 ii = BIGWORDCOUNT( T ) - 1; ii >= 0; --ii )

	mov	DWORD PTR _ii$1[ebp], 7
	jmp	SHORT $LN3@ushiftRigh
$LN2@ushiftRigh:
	mov	eax, DWORD PTR _ii$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _ii$1[ebp], eax
$LN3@ushiftRigh:
	cmp	DWORD PTR _ii$1[ebp], 0
	jl	SHORT $LN4@ushiftRigh

; 515  : 		{
; 516  : 			w_i = n[ ii ];

	mov	eax, DWORD PTR _ii$1[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _w_i$[ebp], edx

; 517  : 			
; 518  : 			n[ ii ] = carry | ( w_i >> 1 );

	mov	eax, DWORD PTR _w_i$[ebp]
	shr	eax, 1
	or	eax, DWORD PTR _carry$[ebp]
	mov	ecx, DWORD PTR _ii$1[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 519  : 			carry = w_i << ( WORDBITS - 1 );

	mov	eax, DWORD PTR _w_i$[ebp]
	shl	eax, 31					; 0000001fH
	mov	DWORD PTR _carry$[ebp], eax

; 520  : 		}

	jmp	SHORT $LN2@ushiftRigh
$LN4@ushiftRigh:

; 521  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$ushiftRight1@$$BY07I@big@@YAXAAY07I@Z ENDP		; big::ushiftRight1<unsigned int [8]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$shiftLeft1@$$BY07I@big@@YAXAAY07I@Z
_TEXT	SEGMENT
_ii$1 = -32						; size = 4
_carry$ = -20						; size = 4
_w_i$ = -8						; size = 4
_n$ = 8							; size = 4
??$shiftLeft1@$$BY07I@big@@YAXAAY07I@Z PROC		; big::shiftLeft1<unsigned int [8]>, COMDAT

; 463  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 464  : 		register word w_i, carry = 0;

	mov	DWORD PTR _carry$[ebp], 0

; 465  : 		
; 466  : 		for ( u32 ii = 0; ii < BIGWORDCOUNT( T ); ++ii )

	mov	DWORD PTR _ii$1[ebp], 0
	jmp	SHORT $LN3@shiftLeft1
$LN2@shiftLeft1:
	mov	eax, DWORD PTR _ii$1[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$1[ebp], eax
$LN3@shiftLeft1:
	cmp	DWORD PTR _ii$1[ebp], 8
	jae	SHORT $LN4@shiftLeft1

; 467  : 		{
; 468  : 			w_i = n[ ii ];

	mov	eax, DWORD PTR _ii$1[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _w_i$[ebp], edx

; 469  : 			
; 470  : 			n[ ii ] = ( w_i << 1 ) | carry;

	mov	eax, DWORD PTR _w_i$[ebp]
	shl	eax, 1
	or	eax, DWORD PTR _carry$[ebp]
	mov	ecx, DWORD PTR _ii$1[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 471  : 			carry = w_i >> ( WORDBITS - 1 );

	mov	eax, DWORD PTR _w_i$[ebp]
	shr	eax, 31					; 0000001fH
	mov	DWORD PTR _carry$[ebp], eax

; 472  : 		}

	jmp	SHORT $LN2@shiftLeft1
$LN4@shiftLeft1:

; 473  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$shiftLeft1@$$BY07I@big@@YAXAAY07I@Z ENDP		; big::shiftLeft1<unsigned int [8]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$subtract@$$BY0BA@I@big@@YAXAAY0BA@I0@Z
_TEXT	SEGMENT
_qc1$ = -8						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$subtract@$$BY0BA@I@big@@YAXAAY0BA@I0@Z PROC		; big::subtract<unsigned int [16]>, COMDAT

; 780  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 781  : #if defined(NO_TEMPLATE_INLINE_ASSEMBLY) && defined(ASSEMBLY_INTEL_SYNTAX)
; 782  : 		const u32 qc1 = BIGWORDCOUNT( T ) / 4 - 1;
; 783  : 		
; 784  : 		BorlandSubtract( a, b, qc1 );
; 785  : 		
; 786  : #elif defined(ASSEMBLY_INTEL_SYNTAX)
; 787  : 		
; 788  : 		const u32 qc1 = BIGWORDCOUNT( T ) / 4 - 1;

	mov	DWORD PTR _qc1$[ebp], 3

; 789  : 		
; 790  : 		ASSEMBLY_BLOCK // VS.NET, x86, 32-bit words
; 791  : 		{
; 792  : 		        mov esi, b

	mov	esi, DWORD PTR _b$[ebp]

; 793  : 		        mov edi, a

	mov	edi, DWORD PTR _a$[ebp]

; 794  : 		        mov ecx, qc1

	mov	ecx, DWORD PTR _qc1$[ebp]

; 795  : 		
; 796  : 		        // unrolled loop since word count is a multiple of 4 >= 4
; 797  : 		        mov eax, [ esi ]

	mov	eax, DWORD PTR [esi]

; 798  : 		        xor edx, edx  // edx used later to index later words >= 4

	xor	edx, edx

; 799  : 		        sub [ edi ], eax  // first subtraction doesn't need to borrow

	sub	DWORD PTR [edi], eax

; 800  : 		        mov eax, [ esi + 4 ]

	mov	eax, DWORD PTR [esi+4]

; 801  : 		        sbb [ edi + 4 ], eax

	sbb	DWORD PTR [edi+4], eax

; 802  : 		        mov eax, [ esi + 8 ]

	mov	eax, DWORD PTR [esi+8]

; 803  : 		        sbb [ edi + 8 ], eax

	sbb	DWORD PTR [edi+8], eax

; 804  : 		        mov eax, [ esi + 12 ]

	mov	eax, DWORD PTR [esi+12]

; 805  : 		        sbb [ edi + 12 ], eax

	sbb	DWORD PTR [edi+12], eax

; 806  : 		
; 807  : 		        jecxz done_already

	jecxz	$done_already$3
$next_word$4:

; 808  : 		
; 809  : 	        next_word:
; 810  : 		        inc edx

	inc	edx

; 811  : 		        inc edx

	inc	edx

; 812  : 		
; 813  : 		        // unrolled loop since word count is a multiple of 4 >= 4
; 814  : 		        mov eax, [ esi + edx * 8 ]

	mov	eax, DWORD PTR [esi+edx*8]

; 815  : 		        sbb [ edi + edx * 8 ], eax

	sbb	DWORD PTR [edi+edx*8], eax

; 816  : 		        mov eax, [ esi + edx * 8 + 4 ]

	mov	eax, DWORD PTR [esi+edx*8+4]

; 817  : 		        sbb [ edi + edx * 8 + 4 ], eax

	sbb	DWORD PTR [edi+edx*8+4], eax

; 818  : 		        mov eax, [ esi + edx * 8 + 8 ]

	mov	eax, DWORD PTR [esi+edx*8+8]

; 819  : 		        sbb [ edi + edx * 8 + 8 ], eax

	sbb	DWORD PTR [edi+edx*8+8], eax

; 820  : 		        mov eax, [ esi + edx * 8 + 12 ]

	mov	eax, DWORD PTR [esi+edx*8+12]

; 821  : 		        sbb [ edi + edx * 8 + 12 ], eax

	sbb	DWORD PTR [edi+edx*8+12], eax

; 822  : 		
; 823  : 		        loop next_word

	loop	$next_word$4
$done_already$3:

; 824  : 		
; 825  : 	        done_already:
; 826  : 		}
; 827  : #else
; 828  : 		register word borrow = 0;
; 829  : 		
; 830  : 		for ( u32 ii = 0; ii < BIGWORDCOUNT( T ); ++ii )
; 831  : 		{
; 832  : 			word a_i = a[ ii ];
; 833  : 			word b_i = b[ ii ];
; 834  : 			a[ ii ] -= b_i + borrow;
; 835  : 		
; 836  : 			borrow = ( ( a_i & ( WORDALLBITS >> 1 ) ) - ( b_i & ( WORDALLBITS >> 1 ) ) - borrow ) >> ( WORDBITS - 1 );
; 837  : 			borrow += ( b_i >> ( WORDBITS - 1 ) ) - ( a_i >> ( WORDBITS - 1 ) );
; 838  : 			++borrow;
; 839  : 			borrow >>= 1;
; 840  : 		}
; 841  : 		
; 842  : #endif
; 843  : 		
; 844  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$subtract@$$BY0BA@I@big@@YAXAAY0BA@I0@Z ENDP		; big::subtract<unsigned int [16]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$ushiftRight1@$$BY0BA@I@big@@YAXAAY0BA@I@Z
_TEXT	SEGMENT
_ii$1 = -32						; size = 4
_carry$ = -20						; size = 4
_w_i$ = -8						; size = 4
_n$ = 8							; size = 4
??$ushiftRight1@$$BY0BA@I@big@@YAXAAY0BA@I@Z PROC	; big::ushiftRight1<unsigned int [16]>, COMDAT

; 511  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 512  : 		register word w_i, carry = 0;

	mov	DWORD PTR _carry$[ebp], 0

; 513  : 		
; 514  : 		for ( s32 ii = BIGWORDCOUNT( T ) - 1; ii >= 0; --ii )

	mov	DWORD PTR _ii$1[ebp], 15		; 0000000fH
	jmp	SHORT $LN3@ushiftRigh
$LN2@ushiftRigh:
	mov	eax, DWORD PTR _ii$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _ii$1[ebp], eax
$LN3@ushiftRigh:
	cmp	DWORD PTR _ii$1[ebp], 0
	jl	SHORT $LN4@ushiftRigh

; 515  : 		{
; 516  : 			w_i = n[ ii ];

	mov	eax, DWORD PTR _ii$1[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _w_i$[ebp], edx

; 517  : 			
; 518  : 			n[ ii ] = carry | ( w_i >> 1 );

	mov	eax, DWORD PTR _w_i$[ebp]
	shr	eax, 1
	or	eax, DWORD PTR _carry$[ebp]
	mov	ecx, DWORD PTR _ii$1[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 519  : 			carry = w_i << ( WORDBITS - 1 );

	mov	eax, DWORD PTR _w_i$[ebp]
	shl	eax, 31					; 0000001fH
	mov	DWORD PTR _carry$[ebp], eax

; 520  : 		}

	jmp	SHORT $LN2@ushiftRigh
$LN4@ushiftRigh:

; 521  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$ushiftRight1@$$BY0BA@I@big@@YAXAAY0BA@I@Z ENDP	; big::ushiftRight1<unsigned int [16]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$shiftLeft1@$$BY0BA@I@big@@YAXAAY0BA@I@Z
_TEXT	SEGMENT
_ii$1 = -32						; size = 4
_carry$ = -20						; size = 4
_w_i$ = -8						; size = 4
_n$ = 8							; size = 4
??$shiftLeft1@$$BY0BA@I@big@@YAXAAY0BA@I@Z PROC		; big::shiftLeft1<unsigned int [16]>, COMDAT

; 463  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 464  : 		register word w_i, carry = 0;

	mov	DWORD PTR _carry$[ebp], 0

; 465  : 		
; 466  : 		for ( u32 ii = 0; ii < BIGWORDCOUNT( T ); ++ii )

	mov	DWORD PTR _ii$1[ebp], 0
	jmp	SHORT $LN3@shiftLeft1
$LN2@shiftLeft1:
	mov	eax, DWORD PTR _ii$1[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$1[ebp], eax
$LN3@shiftLeft1:
	cmp	DWORD PTR _ii$1[ebp], 16		; 00000010H
	jae	SHORT $LN4@shiftLeft1

; 467  : 		{
; 468  : 			w_i = n[ ii ];

	mov	eax, DWORD PTR _ii$1[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _w_i$[ebp], edx

; 469  : 			
; 470  : 			n[ ii ] = ( w_i << 1 ) | carry;

	mov	eax, DWORD PTR _w_i$[ebp]
	shl	eax, 1
	or	eax, DWORD PTR _carry$[ebp]
	mov	ecx, DWORD PTR _ii$1[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 471  : 			carry = w_i >> ( WORDBITS - 1 );

	mov	eax, DWORD PTR _w_i$[ebp]
	shr	eax, 31					; 0000001fH
	mov	DWORD PTR _carry$[ebp], eax

; 472  : 		}

	jmp	SHORT $LN2@shiftLeft1
$LN4@shiftLeft1:

; 473  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$shiftLeft1@$$BY0BA@I@big@@YAXAAY0BA@I@Z ENDP		; big::shiftLeft1<unsigned int [16]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$shiftLeft@$$BY0BA@I@big@@YAXAAY0BA@II@Z
_TEXT	SEGMENT
_ii$1 = -68						; size = 4
_carry$2 = -56						; size = 4
_w_i$3 = -44						; size = 4
_bits$ = -32						; size = 4
_bases$ = -20						; size = 4
_ii$ = -8						; size = 4
_n$ = 8							; size = 4
_s$ = 12						; size = 4
??$shiftLeft@$$BY0BA@I@big@@YAXAAY0BA@II@Z PROC		; big::shiftLeft<unsigned int [16]>, COMDAT

; 477  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 478  : 		register s32 ii;
; 479  : 		register u32 bases = s / WORDBITS;

	mov	eax, DWORD PTR _s$[ebp]
	shr	eax, 5
	mov	DWORD PTR _bases$[ebp], eax

; 480  : 		u32 bits = s % WORDBITS;

	mov	eax, DWORD PTR _s$[ebp]
	xor	edx, edx
	mov	ecx, 32					; 00000020H
	div	ecx
	mov	DWORD PTR _bits$[ebp], edx

; 481  : 		
; 482  : 		// move whole bases first
; 483  : 		
; 484  : 		if ( bases )

	cmp	DWORD PTR _bases$[ebp], 0
	je	SHORT $LN8@shiftLeft

; 485  : 		{
; 486  : 			// shift bases
; 487  : 			
; 488  : 			for ( ii = BIGWORDCOUNT( T ) - 1 - bases; ii >= 0; --ii )

	mov	eax, 15					; 0000000fH
	sub	eax, DWORD PTR _bases$[ebp]
	mov	DWORD PTR _ii$[ebp], eax
	jmp	SHORT $LN7@shiftLeft
$LN6@shiftLeft:
	mov	eax, DWORD PTR _ii$[ebp]
	sub	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
$LN7@shiftLeft:
	cmp	DWORD PTR _ii$[ebp], 0
	jl	SHORT $LN5@shiftLeft

; 489  : 				n[ ii + bases ] = n[ ii ];

	mov	eax, DWORD PTR _ii$[ebp]
	add	eax, DWORD PTR _bases$[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _ii$[ebp]
	mov	esi, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax*4], edx
	jmp	SHORT $LN6@shiftLeft
$LN5@shiftLeft:

; 490  : 				
; 491  : 			// clear the original locii of those bases
; 492  : 			memset( n, 0, bases * sizeof( word ) );

	mov	eax, DWORD PTR _bases$[ebp]
	shl	eax, 2
	push	eax
	push	0
	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
$LN8@shiftLeft:

; 493  : 		}
; 494  : 		
; 495  : 		if ( bits )

	cmp	DWORD PTR _bits$[ebp], 0
	je	SHORT $LN9@shiftLeft

; 496  : 		{
; 497  : 			register word w_i, carry = 0;

	mov	DWORD PTR _carry$2[ebp], 0

; 498  : 			
; 499  : 			for ( u32 ii = 0; ii < BIGWORDCOUNT( T ); ++ii )

	mov	DWORD PTR _ii$1[ebp], 0
	jmp	SHORT $LN3@shiftLeft
$LN2@shiftLeft:
	mov	eax, DWORD PTR _ii$1[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$1[ebp], eax
$LN3@shiftLeft:
	cmp	DWORD PTR _ii$1[ebp], 16		; 00000010H
	jae	SHORT $LN9@shiftLeft

; 500  : 			{
; 501  : 				w_i = n[ ii ];

	mov	eax, DWORD PTR _ii$1[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _w_i$3[ebp], edx

; 502  : 				
; 503  : 				n[ ii ] = ( w_i << bits ) | carry;

	mov	eax, DWORD PTR _w_i$3[ebp]
	mov	ecx, DWORD PTR _bits$[ebp]
	shl	eax, cl
	or	eax, DWORD PTR _carry$2[ebp]
	mov	ecx, DWORD PTR _ii$1[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 504  : 				carry = w_i >> ( WORDBITS - bits );

	mov	ecx, 32					; 00000020H
	sub	ecx, DWORD PTR _bits$[ebp]
	mov	eax, DWORD PTR _w_i$3[ebp]
	shr	eax, cl
	mov	DWORD PTR _carry$2[ebp], eax

; 505  : 			}

	jmp	SHORT $LN2@shiftLeft
$LN9@shiftLeft:

; 506  : 		}
; 507  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$shiftLeft@$$BY0BA@I@big@@YAXAAY0BA@II@Z ENDP		; big::shiftLeft<unsigned int [16]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$ugreater@$$BY0BA@I@big@@YA_NAAY0BA@I0@Z
_TEXT	SEGMENT
_ii$1 = -8						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$ugreater@$$BY0BA@I@big@@YA_NAAY0BA@I0@Z PROC		; big::ugreater<unsigned int [16]>, COMDAT

; 353  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 354  : 		for ( s32 ii = BIGWORDCOUNT( T ) - 1; ii >= 0; --ii )

	mov	DWORD PTR _ii$1[ebp], 15		; 0000000fH
	jmp	SHORT $LN5@ugreater
$LN4@ugreater:
	mov	eax, DWORD PTR _ii$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _ii$1[ebp], eax
$LN5@ugreater:
	cmp	DWORD PTR _ii$1[ebp], 0
	jl	SHORT $LN3@ugreater

; 355  : 		{
; 356  : 			if ( a[ ii ] > b[ ii ] )

	mov	eax, DWORD PTR _ii$1[ebp]
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _ii$1[ebp]
	mov	esi, DWORD PTR _b$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	cmp	eax, DWORD PTR [esi+edx*4]
	jbe	SHORT $LN2@ugreater

; 357  : 				return true;

	mov	al, 1
	jmp	SHORT $LN6@ugreater
$LN2@ugreater:

; 358  : 				
; 359  : 			if ( a[ ii ] < b[ ii ] )

	mov	eax, DWORD PTR _ii$1[ebp]
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _ii$1[ebp]
	mov	esi, DWORD PTR _b$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	cmp	eax, DWORD PTR [esi+edx*4]
	jae	SHORT $LN1@ugreater

; 360  : 				return false;

	xor	al, al
	jmp	SHORT $LN6@ugreater
$LN1@ugreater:

; 361  : 		}

	jmp	SHORT $LN4@ugreater
$LN3@ugreater:

; 362  : 		
; 363  : 		return false;

	xor	al, al
$LN6@ugreater:

; 364  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$ugreater@$$BY0BA@I@big@@YA_NAAY0BA@I0@Z ENDP		; big::ugreater<unsigned int [16]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$zero@$$BY0BA@I@big@@YAXAAY0BA@I@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
??$zero@$$BY0BA@I@big@@YAXAAY0BA@I@Z PROC		; big::zero<unsigned int [16]>, COMDAT

; 288  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 289  : 		memset( n, 0, sizeof( T ) );

	push	64					; 00000040H
	push	0
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 290  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$zero@$$BY0BA@I@big@@YAXAAY0BA@I@Z ENDP		; big::zero<unsigned int [16]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$set@$$BY0BA@I@big@@YAXAAY0BA@I0@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$set@$$BY0BA@I@big@@YAXAAY0BA@I0@Z PROC		; big::set<unsigned int [16]>, COMDAT

; 308  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 309  : 		memcpy( a, b, sizeof( T ) );

	push	64					; 00000040H
	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 310  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$set@$$BY0BA@I@big@@YAXAAY0BA@I0@Z ENDP		; big::set<unsigned int [16]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rsacrypt.h
;	COMDAT ??$SubMulMod@$$BY07I@big@@YAXAAY07I0000@Z
_TEXT	SEGMENT
_y$ = -184						; size = 32
_dn$ = -144						; size = 64
_da$ = -72						; size = 64
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_c$ = 16						; size = 4
_n$ = 20						; size = 4
_x$ = 24						; size = 4
??$SubMulMod@$$BY07I@big@@YAXAAY07I0000@Z PROC		; big::SubMulMod<unsigned int [8]>, COMDAT

; 165  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 380				; 0000017cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-380]
	mov	ecx, 95					; 0000005fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 166  : 		BIGDOUBLESIZE( T, da );
; 167  : 		BIGDOUBLESIZE( T, dn );
; 168  : 		T y;
; 169  : 
; 170  : 		// y = a b (mod n)
; 171  : 		usetlow( da, a );

	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	lea	ecx, DWORD PTR _da$[ebp]
	push	ecx
	call	??$usetlow@$$BY07I$$BY0BA@I@big@@YAXAAY0BA@IAAY07I@Z ; big::usetlow<unsigned int [8],unsigned int [16]>
	add	esp, 8

; 172  : 		umultiply( da, b );

	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _da$[ebp]
	push	ecx
	call	??$umultiply@$$BY07I$$BY0BA@I@big@@YAXAAY0BA@IAAY07I@Z ; big::umultiply<unsigned int [8],unsigned int [16]>
	add	esp, 8

; 173  : 		usetlow( dn, n );

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dn$[ebp]
	push	ecx
	call	??$usetlow@$$BY07I$$BY0BA@I@big@@YAXAAY0BA@IAAY07I@Z ; big::usetlow<unsigned int [8],unsigned int [16]>
	add	esp, 8

; 174  : 		umodulo( da, dn, da );

	lea	eax, DWORD PTR _da$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dn$[ebp]
	push	ecx
	lea	edx, DWORD PTR _da$[ebp]
	push	edx
	call	??$umodulo@$$BY0BA@I@big@@YAXAAY0BA@I00@Z ; big::umodulo<unsigned int [16]>
	add	esp, 12					; 0000000cH

; 175  : 		takelow( y, da );

	lea	eax, DWORD PTR _da$[ebp]
	push	eax
	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	call	??$takelow@$$BY07I$$BY0BA@I@big@@YAXAAY07IAAY0BA@I@Z ; big::takelow<unsigned int [8],unsigned int [16]>
	add	esp, 8

; 176  : 
; 177  : 		// x = (c - y) (mod n) > 0
; 178  : 
; 179  : 		set ( x, c )
; 180  : 
; 181  : 			;

	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	??$set@$$BY07I@big@@YAXAAY07I0@Z	; big::set<unsigned int [8]>
	add	esp, 8

; 182  : 		if ( ugreater( c, y ) )

	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	call	??$ugreater@$$BY07I@big@@YA_NAAY07I0@Z	; big::ugreater<unsigned int [8]>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@SubMulMod

; 183  : 		{
; 184  : 			subtract( x, y );

	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	??$subtract@$$BY07I@big@@YAXAAY07I0@Z	; big::subtract<unsigned int [8]>
	add	esp, 8

; 185  : 		}
; 186  : 
; 187  : 		else

	jmp	SHORT $LN3@SubMulMod
$LN2@SubMulMod:

; 188  : 		{
; 189  : 			subtract( x, y );

	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	??$subtract@$$BY07I@big@@YAXAAY07I0@Z	; big::subtract<unsigned int [8]>
	add	esp, 8

; 190  : 
; 191  : 			add ( x, n )
; 192  : 
; 193  : 				;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	??$add@$$BY07I@big@@YAXAAY07I0@Z	; big::add<unsigned int [8]>
	add	esp, 8
$LN3@SubMulMod:

; 194  : 		}
; 195  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@SubMulMod
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 380				; 0000017cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN9@SubMulMod:
	DD	3
	DD	$LN8@SubMulMod
$LN8@SubMulMod:
	DD	-72					; ffffffb8H
	DD	64					; 00000040H
	DD	$LN5@SubMulMod
	DD	-144					; ffffff70H
	DD	64					; 00000040H
	DD	$LN6@SubMulMod
	DD	-184					; ffffff48H
	DD	32					; 00000020H
	DD	$LN7@SubMulMod
$LN7@SubMulMod:
	DB	121					; 00000079H
	DB	0
$LN6@SubMulMod:
	DB	100					; 00000064H
	DB	110					; 0000006eH
	DB	0
$LN5@SubMulMod:
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	0
??$SubMulMod@$$BY07I@big@@YAXAAY07I0000@Z ENDP		; big::SubMulMod<unsigned int [8]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$subtract@$$BY07I@big@@YAXAAY07I0@Z
_TEXT	SEGMENT
_qc1$ = -8						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$subtract@$$BY07I@big@@YAXAAY07I0@Z PROC		; big::subtract<unsigned int [8]>, COMDAT

; 780  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 781  : #if defined(NO_TEMPLATE_INLINE_ASSEMBLY) && defined(ASSEMBLY_INTEL_SYNTAX)
; 782  : 		const u32 qc1 = BIGWORDCOUNT( T ) / 4 - 1;
; 783  : 		
; 784  : 		BorlandSubtract( a, b, qc1 );
; 785  : 		
; 786  : #elif defined(ASSEMBLY_INTEL_SYNTAX)
; 787  : 		
; 788  : 		const u32 qc1 = BIGWORDCOUNT( T ) / 4 - 1;

	mov	DWORD PTR _qc1$[ebp], 1

; 789  : 		
; 790  : 		ASSEMBLY_BLOCK // VS.NET, x86, 32-bit words
; 791  : 		{
; 792  : 		        mov esi, b

	mov	esi, DWORD PTR _b$[ebp]

; 793  : 		        mov edi, a

	mov	edi, DWORD PTR _a$[ebp]

; 794  : 		        mov ecx, qc1

	mov	ecx, DWORD PTR _qc1$[ebp]

; 795  : 		
; 796  : 		        // unrolled loop since word count is a multiple of 4 >= 4
; 797  : 		        mov eax, [ esi ]

	mov	eax, DWORD PTR [esi]

; 798  : 		        xor edx, edx  // edx used later to index later words >= 4

	xor	edx, edx

; 799  : 		        sub [ edi ], eax  // first subtraction doesn't need to borrow

	sub	DWORD PTR [edi], eax

; 800  : 		        mov eax, [ esi + 4 ]

	mov	eax, DWORD PTR [esi+4]

; 801  : 		        sbb [ edi + 4 ], eax

	sbb	DWORD PTR [edi+4], eax

; 802  : 		        mov eax, [ esi + 8 ]

	mov	eax, DWORD PTR [esi+8]

; 803  : 		        sbb [ edi + 8 ], eax

	sbb	DWORD PTR [edi+8], eax

; 804  : 		        mov eax, [ esi + 12 ]

	mov	eax, DWORD PTR [esi+12]

; 805  : 		        sbb [ edi + 12 ], eax

	sbb	DWORD PTR [edi+12], eax

; 806  : 		
; 807  : 		        jecxz done_already

	jecxz	$done_already$3
$next_word$4:

; 808  : 		
; 809  : 	        next_word:
; 810  : 		        inc edx

	inc	edx

; 811  : 		        inc edx

	inc	edx

; 812  : 		
; 813  : 		        // unrolled loop since word count is a multiple of 4 >= 4
; 814  : 		        mov eax, [ esi + edx * 8 ]

	mov	eax, DWORD PTR [esi+edx*8]

; 815  : 		        sbb [ edi + edx * 8 ], eax

	sbb	DWORD PTR [edi+edx*8], eax

; 816  : 		        mov eax, [ esi + edx * 8 + 4 ]

	mov	eax, DWORD PTR [esi+edx*8+4]

; 817  : 		        sbb [ edi + edx * 8 + 4 ], eax

	sbb	DWORD PTR [edi+edx*8+4], eax

; 818  : 		        mov eax, [ esi + edx * 8 + 8 ]

	mov	eax, DWORD PTR [esi+edx*8+8]

; 819  : 		        sbb [ edi + edx * 8 + 8 ], eax

	sbb	DWORD PTR [edi+edx*8+8], eax

; 820  : 		        mov eax, [ esi + edx * 8 + 12 ]

	mov	eax, DWORD PTR [esi+edx*8+12]

; 821  : 		        sbb [ edi + edx * 8 + 12 ], eax

	sbb	DWORD PTR [edi+edx*8+12], eax

; 822  : 		
; 823  : 		        loop next_word

	loop	$next_word$4
$done_already$3:

; 824  : 		
; 825  : 	        done_already:
; 826  : 		}
; 827  : #else
; 828  : 		register word borrow = 0;
; 829  : 		
; 830  : 		for ( u32 ii = 0; ii < BIGWORDCOUNT( T ); ++ii )
; 831  : 		{
; 832  : 			word a_i = a[ ii ];
; 833  : 			word b_i = b[ ii ];
; 834  : 			a[ ii ] -= b_i + borrow;
; 835  : 		
; 836  : 			borrow = ( ( a_i & ( WORDALLBITS >> 1 ) ) - ( b_i & ( WORDALLBITS >> 1 ) ) - borrow ) >> ( WORDBITS - 1 );
; 837  : 			borrow += ( b_i >> ( WORDBITS - 1 ) ) - ( a_i >> ( WORDBITS - 1 ) );
; 838  : 			++borrow;
; 839  : 			borrow >>= 1;
; 840  : 		}
; 841  : 		
; 842  : #endif
; 843  : 		
; 844  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$subtract@$$BY07I@big@@YAXAAY07I0@Z ENDP		; big::subtract<unsigned int [8]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$isZero@$$BY07I@big@@YA_NAAY07I@Z
_TEXT	SEGMENT
_ii$1 = -8						; size = 4
_n$ = 8							; size = 4
??$isZero@$$BY07I@big@@YA_NAAY07I@Z PROC		; big::isZero<unsigned int [8]>, COMDAT

; 419  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 420  : 		for ( u32 ii = 0; ii < BIGWORDCOUNT( T ); ++ii )

	mov	DWORD PTR _ii$1[ebp], 0
	jmp	SHORT $LN4@isZero
$LN3@isZero:
	mov	eax, DWORD PTR _ii$1[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$1[ebp], eax
$LN4@isZero:
	cmp	DWORD PTR _ii$1[ebp], 8
	jae	SHORT $LN2@isZero

; 421  : 			if ( n[ ii ] )

	mov	eax, DWORD PTR _ii$1[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $LN1@isZero

; 422  : 				return false;

	xor	al, al
	jmp	SHORT $LN5@isZero
$LN1@isZero:

; 423  : 				
; 424  : 		return true;

	jmp	SHORT $LN3@isZero
$LN2@isZero:
	mov	al, 1
$LN5@isZero:

; 425  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$isZero@$$BY07I@big@@YA_NAAY07I@Z ENDP		; big::isZero<unsigned int [8]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$equal@$$BY03I@big@@YA_NAAY03I0@Z
_TEXT	SEGMENT
tv69 = -196						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$equal@$$BY03I@big@@YA_NAAY03I0@Z PROC		; big::equal<unsigned int [4]>, COMDAT

; 413  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 414  : 		return memcmp( a, b, sizeof( T ) ) == 0;

	push	16					; 00000010H
	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN3@equal
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@equal
$LN3@equal:
	mov	DWORD PTR tv69[ebp], 0
$LN4@equal:
	mov	al, BYTE PTR tv69[ebp]

; 415  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$equal@$$BY03I@big@@YA_NAAY03I0@Z ENDP		; big::equal<unsigned int [4]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$ushiftRight1@$$BY03I@big@@YAXAAY03I@Z
_TEXT	SEGMENT
_ii$1 = -32						; size = 4
_carry$ = -20						; size = 4
_w_i$ = -8						; size = 4
_n$ = 8							; size = 4
??$ushiftRight1@$$BY03I@big@@YAXAAY03I@Z PROC		; big::ushiftRight1<unsigned int [4]>, COMDAT

; 511  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 512  : 		register word w_i, carry = 0;

	mov	DWORD PTR _carry$[ebp], 0

; 513  : 		
; 514  : 		for ( s32 ii = BIGWORDCOUNT( T ) - 1; ii >= 0; --ii )

	mov	DWORD PTR _ii$1[ebp], 3
	jmp	SHORT $LN3@ushiftRigh
$LN2@ushiftRigh:
	mov	eax, DWORD PTR _ii$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _ii$1[ebp], eax
$LN3@ushiftRigh:
	cmp	DWORD PTR _ii$1[ebp], 0
	jl	SHORT $LN4@ushiftRigh

; 515  : 		{
; 516  : 			w_i = n[ ii ];

	mov	eax, DWORD PTR _ii$1[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _w_i$[ebp], edx

; 517  : 			
; 518  : 			n[ ii ] = carry | ( w_i >> 1 );

	mov	eax, DWORD PTR _w_i$[ebp]
	shr	eax, 1
	or	eax, DWORD PTR _carry$[ebp]
	mov	ecx, DWORD PTR _ii$1[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 519  : 			carry = w_i << ( WORDBITS - 1 );

	mov	eax, DWORD PTR _w_i$[ebp]
	shl	eax, 31					; 0000001fH
	mov	DWORD PTR _carry$[ebp], eax

; 520  : 		}

	jmp	SHORT $LN2@ushiftRigh
$LN4@ushiftRigh:

; 521  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$ushiftRight1@$$BY03I@big@@YAXAAY03I@Z ENDP		; big::ushiftRight1<unsigned int [4]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$umodulo@$$BY03I@big@@YAXAAY03I00@Z
_TEXT	SEGMENT
tv151 = -260						; size = 4
_jj$1 = -60						; size = 4
_ii$2 = -48						; size = 4
_shifts$ = -36						; size = 4
_b$ = -24						; size = 16
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_b0$ = 12						; size = 4
_r$ = 16						; size = 4
??$umodulo@$$BY03I@big@@YAXAAY03I00@Z PROC		; big::umodulo<unsigned int [4]>, COMDAT

; 1250 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 260				; 00000104H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-260]
	mov	ecx, 65					; 00000041H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1251 : 		T b;
; 1252 : 		u32 shifts = 1;

	mov	DWORD PTR _shifts$[ebp], 1

; 1253 : 		
; 1254 : 		set ( b, b0 )
; 1255 : 		
; 1256 : 		;

	mov	eax, DWORD PTR _b0$[ebp]
	push	eax
	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	call	??$set@$$BY03I@big@@YAXAAY03I0@Z	; big::set<unsigned int [4]>
	add	esp, 8

; 1257 : 		set ( r, a )
; 1258 : 		
; 1259 : 		;

	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	call	??$set@$$BY03I@big@@YAXAAY03I0@Z	; big::set<unsigned int [4]>
	add	esp, 8

; 1260 : 		
; 1261 : 		if ( !BIGHIGHBIT( b ) && ugreater( r, b ) )

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _b$[ebp+ecx]
	and	edx, -2147483648			; 80000000H
	jne	$LN19@umodulo
	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	call	??$ugreater@$$BY03I@big@@YA_NAAY03I0@Z	; big::ugreater<unsigned int [4]>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	$LN19@umodulo

; 1262 : 		{
; 1263 : 			s32 ii, jj;
; 1264 : 			
; 1265 : 			// shift by words if possible
; 1266 : 			
; 1267 : 			for ( ii = BIGWORDCOUNT( T ) - 1; ii >= 0; --ii )

	mov	DWORD PTR _ii$2[ebp], 3
	jmp	SHORT $LN18@umodulo
$LN17@umodulo:
	mov	eax, DWORD PTR _ii$2[ebp]
	sub	eax, 1
	mov	DWORD PTR _ii$2[ebp], eax
$LN18@umodulo:
	cmp	DWORD PTR _ii$2[ebp], 0
	jl	SHORT $LN16@umodulo

; 1268 : 				if ( r[ ii ] )

	mov	eax, DWORD PTR _ii$2[ebp]
	mov	ecx, DWORD PTR _r$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $LN15@umodulo

; 1269 : 					break;

	jmp	SHORT $LN16@umodulo
$LN15@umodulo:

; 1270 : 					
; 1271 : 			for ( jj = ii; jj >= 0; --jj )

	jmp	SHORT $LN17@umodulo
$LN16@umodulo:
	mov	eax, DWORD PTR _ii$2[ebp]
	mov	DWORD PTR _jj$1[ebp], eax
	jmp	SHORT $LN14@umodulo
$LN13@umodulo:
	mov	eax, DWORD PTR _jj$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _jj$1[ebp], eax
$LN14@umodulo:
	cmp	DWORD PTR _jj$1[ebp], 0
	jl	SHORT $LN12@umodulo

; 1272 : 				if ( b[ jj ] )

	mov	eax, DWORD PTR _jj$1[ebp]
	cmp	DWORD PTR _b$[ebp+eax*4], 0
	je	SHORT $LN11@umodulo

; 1273 : 					break;

	jmp	SHORT $LN12@umodulo
$LN11@umodulo:

; 1274 : 					
; 1275 : 			if ( ii != jj )

	jmp	SHORT $LN13@umodulo
$LN12@umodulo:
	mov	eax, DWORD PTR _ii$2[ebp]
	cmp	eax, DWORD PTR _jj$1[ebp]
	je	SHORT $LN9@umodulo

; 1276 : 			{
; 1277 : 				shifts = ( ii - jj ) * WORDBITS;

	mov	eax, DWORD PTR _ii$2[ebp]
	sub	eax, DWORD PTR _jj$1[ebp]
	shl	eax, 5
	mov	DWORD PTR _shifts$[ebp], eax

; 1278 : 				shiftLeft( b, shifts );

	mov	eax, DWORD PTR _shifts$[ebp]
	push	eax
	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	call	??$shiftLeft@$$BY03I@big@@YAXAAY03II@Z	; big::shiftLeft<unsigned int [4]>
	add	esp, 8

; 1279 : 				++shifts;

	mov	eax, DWORD PTR _shifts$[ebp]
	add	eax, 1
	mov	DWORD PTR _shifts$[ebp], eax
$LN9@umodulo:

; 1280 : 			}
; 1281 : 			
; 1282 : 			while ( !BIGHIGHBIT( b ) && ugreater( r, b ) )

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _b$[ebp+ecx]
	and	edx, -2147483648			; 80000000H
	jne	SHORT $LN7@umodulo
	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	call	??$ugreater@$$BY03I@big@@YA_NAAY03I0@Z	; big::ugreater<unsigned int [4]>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN7@umodulo

; 1283 : 			{
; 1284 : 				shiftLeft1( b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$shiftLeft1@$$BY03I@big@@YAXAAY03I@Z	; big::shiftLeft1<unsigned int [4]>
	add	esp, 4

; 1285 : 				
; 1286 : 				++shifts;

	mov	eax, DWORD PTR _shifts$[ebp]
	add	eax, 1
	mov	DWORD PTR _shifts$[ebp], eax

; 1287 : 			}

	jmp	SHORT $LN9@umodulo
$LN7@umodulo:

; 1288 : 			
; 1289 : 			while ( ugreater( b, r ) )

	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	call	??$ugreater@$$BY03I@big@@YA_NAAY03I0@Z	; big::ugreater<unsigned int [4]>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN6@umodulo

; 1290 : 			{
; 1291 : 				ushiftRight1( b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$ushiftRight1@$$BY03I@big@@YAXAAY03I@Z ; big::ushiftRight1<unsigned int [4]>
	add	esp, 4

; 1292 : 				
; 1293 : 				--shifts;

	mov	eax, DWORD PTR _shifts$[ebp]
	sub	eax, 1
	mov	DWORD PTR _shifts$[ebp], eax

; 1294 : 			}

	jmp	SHORT $LN7@umodulo
$LN6@umodulo:

; 1295 : 		}
; 1296 : 		
; 1297 : 		else

	jmp	SHORT $LN3@umodulo
$LN19@umodulo:

; 1298 : 			if ( ugreater( b, r ) )

	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	call	??$ugreater@$$BY03I@big@@YA_NAAY03I0@Z	; big::ugreater<unsigned int [4]>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@umodulo

; 1299 : 			{
; 1300 : 				ushiftRight1( b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$ushiftRight1@$$BY03I@big@@YAXAAY03I@Z ; big::ushiftRight1<unsigned int [4]>
	add	esp, 4

; 1301 : 				
; 1302 : 				--shifts;

	mov	eax, DWORD PTR _shifts$[ebp]
	sub	eax, 1
	mov	DWORD PTR _shifts$[ebp], eax
$LN3@umodulo:

; 1303 : 			}
; 1304 : 			
; 1305 : 		while ( shifts-- )

	mov	eax, DWORD PTR _shifts$[ebp]
	mov	DWORD PTR tv151[ebp], eax
	mov	ecx, DWORD PTR _shifts$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _shifts$[ebp], ecx
	cmp	DWORD PTR tv151[ebp], 0
	je	SHORT $LN20@umodulo

; 1306 : 		{
; 1307 : 			if ( !ugreater( b, r ) )

	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	call	??$ugreater@$$BY03I@big@@YA_NAAY03I0@Z	; big::ugreater<unsigned int [4]>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN1@umodulo

; 1308 : 				subtract( r, b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	call	??$subtract@$$BY03I@big@@YAXAAY03I0@Z	; big::subtract<unsigned int [4]>
	add	esp, 8
$LN1@umodulo:

; 1309 : 				
; 1310 : 			ushiftRight1( b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$ushiftRight1@$$BY03I@big@@YAXAAY03I@Z ; big::ushiftRight1<unsigned int [4]>
	add	esp, 4

; 1311 : 		}

	jmp	SHORT $LN3@umodulo
$LN20@umodulo:

; 1312 : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN24@umodulo
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 260				; 00000104H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN24@umodulo:
	DD	1
	DD	$LN23@umodulo
$LN23@umodulo:
	DD	-24					; ffffffe8H
	DD	16					; 00000010H
	DD	$LN22@umodulo
$LN22@umodulo:
	DB	98					; 00000062H
	DB	0
??$umodulo@$$BY03I@big@@YAXAAY03I00@Z ENDP		; big::umodulo<unsigned int [4]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$udivide@$$BY07I@big@@YAXAAY07I000@Z
_TEXT	SEGMENT
tv152 = -288						; size = 4
_qshifts$ = -88						; size = 4
_jj$1 = -76						; size = 4
_ii$2 = -64						; size = 4
_shifts$ = -52						; size = 4
_b$ = -40						; size = 32
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_b0$ = 12						; size = 4
_q$ = 16						; size = 4
_r$ = 20						; size = 4
??$udivide@$$BY07I@big@@YAXAAY07I000@Z PROC		; big::udivide<unsigned int [8]>, COMDAT

; 1168 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 288				; 00000120H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-288]
	mov	ecx, 72					; 00000048H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1169 : 		T b;
; 1170 : 		
; 1171 : 		set ( b, b0 )
; 1172 : 		
; 1173 : 		;

	mov	eax, DWORD PTR _b0$[ebp]
	push	eax
	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	call	??$set@$$BY07I@big@@YAXAAY07I0@Z	; big::set<unsigned int [8]>
	add	esp, 8

; 1174 : 		set ( r, a )
; 1175 : 		
; 1176 : 		;

	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	call	??$set@$$BY07I@big@@YAXAAY07I0@Z	; big::set<unsigned int [8]>
	add	esp, 8

; 1177 : 		zero( q );

	mov	eax, DWORD PTR _q$[ebp]
	push	eax
	call	??$zero@$$BY07I@big@@YAXAAY07I@Z	; big::zero<unsigned int [8]>
	add	esp, 4

; 1178 : 		
; 1179 : 		u32 shifts = 1;

	mov	DWORD PTR _shifts$[ebp], 1

; 1180 : 		
; 1181 : 		// sort of: shift b left until b > r, then shift back one
; 1182 : 		if ( !BIGHIGHBIT( b ) && ugreater( r, b ) )

	mov	eax, 4
	imul	ecx, eax, 7
	mov	edx, DWORD PTR _b$[ebp+ecx]
	and	edx, -2147483648			; 80000000H
	jne	$LN19@udivide
	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	call	??$ugreater@$$BY07I@big@@YA_NAAY07I0@Z	; big::ugreater<unsigned int [8]>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	$LN19@udivide

; 1183 : 		{
; 1184 : 			s32 ii, jj;
; 1185 : 			
; 1186 : 			// shift by words if possible
; 1187 : 			
; 1188 : 			for ( ii = BIGWORDCOUNT( T ) - 1; ii >= 0; --ii )

	mov	DWORD PTR _ii$2[ebp], 7
	jmp	SHORT $LN18@udivide
$LN17@udivide:
	mov	eax, DWORD PTR _ii$2[ebp]
	sub	eax, 1
	mov	DWORD PTR _ii$2[ebp], eax
$LN18@udivide:
	cmp	DWORD PTR _ii$2[ebp], 0
	jl	SHORT $LN16@udivide

; 1189 : 				if ( r[ ii ] )

	mov	eax, DWORD PTR _ii$2[ebp]
	mov	ecx, DWORD PTR _r$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $LN15@udivide

; 1190 : 					break;

	jmp	SHORT $LN16@udivide
$LN15@udivide:

; 1191 : 					
; 1192 : 			for ( jj = ii; jj >= 0; --jj )

	jmp	SHORT $LN17@udivide
$LN16@udivide:
	mov	eax, DWORD PTR _ii$2[ebp]
	mov	DWORD PTR _jj$1[ebp], eax
	jmp	SHORT $LN14@udivide
$LN13@udivide:
	mov	eax, DWORD PTR _jj$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _jj$1[ebp], eax
$LN14@udivide:
	cmp	DWORD PTR _jj$1[ebp], 0
	jl	SHORT $LN12@udivide

; 1193 : 				if ( b[ jj ] )

	mov	eax, DWORD PTR _jj$1[ebp]
	cmp	DWORD PTR _b$[ebp+eax*4], 0
	je	SHORT $LN11@udivide

; 1194 : 					break;

	jmp	SHORT $LN12@udivide
$LN11@udivide:

; 1195 : 					
; 1196 : 			if ( ii != jj )

	jmp	SHORT $LN13@udivide
$LN12@udivide:
	mov	eax, DWORD PTR _ii$2[ebp]
	cmp	eax, DWORD PTR _jj$1[ebp]
	je	SHORT $LN9@udivide

; 1197 : 			{
; 1198 : 				shifts = ( ii - jj ) * WORDBITS;

	mov	eax, DWORD PTR _ii$2[ebp]
	sub	eax, DWORD PTR _jj$1[ebp]
	shl	eax, 5
	mov	DWORD PTR _shifts$[ebp], eax

; 1199 : 				shiftLeft( b, shifts );

	mov	eax, DWORD PTR _shifts$[ebp]
	push	eax
	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	call	??$shiftLeft@$$BY07I@big@@YAXAAY07II@Z	; big::shiftLeft<unsigned int [8]>
	add	esp, 8

; 1200 : 				++shifts;

	mov	eax, DWORD PTR _shifts$[ebp]
	add	eax, 1
	mov	DWORD PTR _shifts$[ebp], eax
$LN9@udivide:

; 1201 : 			}
; 1202 : 			
; 1203 : 			while ( !BIGHIGHBIT( b ) && ugreater( r, b ) )

	mov	eax, 4
	imul	ecx, eax, 7
	mov	edx, DWORD PTR _b$[ebp+ecx]
	and	edx, -2147483648			; 80000000H
	jne	SHORT $LN7@udivide
	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	call	??$ugreater@$$BY07I@big@@YA_NAAY07I0@Z	; big::ugreater<unsigned int [8]>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN7@udivide

; 1204 : 			{
; 1205 : 				shiftLeft1( b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$shiftLeft1@$$BY07I@big@@YAXAAY07I@Z	; big::shiftLeft1<unsigned int [8]>
	add	esp, 4

; 1206 : 				
; 1207 : 				++shifts;

	mov	eax, DWORD PTR _shifts$[ebp]
	add	eax, 1
	mov	DWORD PTR _shifts$[ebp], eax

; 1208 : 			}

	jmp	SHORT $LN9@udivide
$LN7@udivide:

; 1209 : 			
; 1210 : 			while ( ugreater( b, r ) )

	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	call	??$ugreater@$$BY07I@big@@YA_NAAY07I0@Z	; big::ugreater<unsigned int [8]>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN6@udivide

; 1211 : 			{
; 1212 : 				ushiftRight1( b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$ushiftRight1@$$BY07I@big@@YAXAAY07I@Z ; big::ushiftRight1<unsigned int [8]>
	add	esp, 4

; 1213 : 				
; 1214 : 				--shifts;

	mov	eax, DWORD PTR _shifts$[ebp]
	sub	eax, 1
	mov	DWORD PTR _shifts$[ebp], eax

; 1215 : 			}

	jmp	SHORT $LN7@udivide
$LN6@udivide:

; 1216 : 		}
; 1217 : 		
; 1218 : 		else

	jmp	SHORT $LN5@udivide
$LN19@udivide:

; 1219 : 			if ( ugreater( b, r ) )

	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	call	??$ugreater@$$BY07I@big@@YA_NAAY07I0@Z	; big::ugreater<unsigned int [8]>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN5@udivide

; 1220 : 			{
; 1221 : 				ushiftRight1( b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$ushiftRight1@$$BY07I@big@@YAXAAY07I@Z ; big::ushiftRight1<unsigned int [8]>
	add	esp, 4

; 1222 : 				
; 1223 : 				--shifts;

	mov	eax, DWORD PTR _shifts$[ebp]
	sub	eax, 1
	mov	DWORD PTR _shifts$[ebp], eax
$LN5@udivide:

; 1224 : 			}
; 1225 : 			
; 1226 : 		u32 qshifts = 0;

	mov	DWORD PTR _qshifts$[ebp], 0
$LN3@udivide:

; 1227 : 		
; 1228 : 		while ( shifts-- )

	mov	eax, DWORD PTR _shifts$[ebp]
	mov	DWORD PTR tv152[ebp], eax
	mov	ecx, DWORD PTR _shifts$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _shifts$[ebp], ecx
	cmp	DWORD PTR tv152[ebp], 0
	je	SHORT $LN2@udivide

; 1229 : 		{
; 1230 : 			++qshifts;

	mov	eax, DWORD PTR _qshifts$[ebp]
	add	eax, 1
	mov	DWORD PTR _qshifts$[ebp], eax

; 1231 : 			
; 1232 : 			if ( !ugreater( b, r ) )

	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	call	??$ugreater@$$BY07I@big@@YA_NAAY07I0@Z	; big::ugreater<unsigned int [8]>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN1@udivide

; 1233 : 			{
; 1234 : 				subtract( r, b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	call	??$subtract@$$BY07I@big@@YAXAAY07I0@Z	; big::subtract<unsigned int [8]>
	add	esp, 8

; 1235 : 				
; 1236 : 				shiftLeft( q, qshifts );

	mov	eax, DWORD PTR _qshifts$[ebp]
	push	eax
	mov	ecx, DWORD PTR _q$[ebp]
	push	ecx
	call	??$shiftLeft@$$BY07I@big@@YAXAAY07II@Z	; big::shiftLeft<unsigned int [8]>
	add	esp, 8

; 1237 : 				qshifts = 0;

	mov	DWORD PTR _qshifts$[ebp], 0

; 1238 : 				
; 1239 : 				q[ 0 ] |= 1;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _q$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	or	eax, 1
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _q$[ebp]
	mov	DWORD PTR [ecx+edx], eax
$LN1@udivide:

; 1240 : 			}
; 1241 : 			
; 1242 : 			ushiftRight1( b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$ushiftRight1@$$BY07I@big@@YAXAAY07I@Z ; big::ushiftRight1<unsigned int [8]>
	add	esp, 4

; 1243 : 		}

	jmp	$LN3@udivide
$LN2@udivide:

; 1244 : 		
; 1245 : 		shiftLeft( q, qshifts );

	mov	eax, DWORD PTR _qshifts$[ebp]
	push	eax
	mov	ecx, DWORD PTR _q$[ebp]
	push	ecx
	call	??$shiftLeft@$$BY07I@big@@YAXAAY07II@Z	; big::shiftLeft<unsigned int [8]>
	add	esp, 8

; 1246 : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN24@udivide
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 288				; 00000120H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN24@udivide:
	DD	1
	DD	$LN23@udivide
$LN23@udivide:
	DD	-40					; ffffffd8H
	DD	32					; 00000020H
	DD	$LN22@udivide
$LN22@udivide:
	DB	98					; 00000062H
	DB	0
??$udivide@$$BY07I@big@@YAXAAY07I000@Z ENDP		; big::udivide<unsigned int [8]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$sethigh@$$BY03I$$BY07I@big@@YAXAAY07IAAY03I@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$sethigh@$$BY03I$$BY07I@big@@YAXAAY07IAAY03I@Z PROC	; big::sethigh<unsigned int [4],unsigned int [8]>, COMDAT

; 331  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 332  : 		memcpy( a + BIGWORDCOUNT( Bigger ) - BIGWORDCOUNT( T ), b, sizeof( T ) );

	push	16					; 00000010H
	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 333  : 		memset( a, 0, sizeof( Bigger ) - sizeof( T ) );

	push	16					; 00000010H
	push	0
	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 334  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$sethigh@$$BY03I$$BY07I@big@@YAXAAY07IAAY03I@Z ENDP	; big::sethigh<unsigned int [4],unsigned int [8]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rsacrypt.h
;	COMDAT ??$computeRinverse@$$BY03I@big@@YAXAAY03I0@Z
_TEXT	SEGMENT
_q$ = -144						; size = 16
_b$ = -120						; size = 16
_a$ = -96						; size = 16
_x2$ = -72						; size = 16
_x1$ = -48						; size = 16
_x0$ = -24						; size = 16
__$ArrayPad$ = -4					; size = 4
_n0$ = 8						; size = 4
_rp$ = 12						; size = 4
??$computeRinverse@$$BY03I@big@@YAXAAY03I0@Z PROC	; big::computeRinverse<unsigned int [4]>, COMDAT

; 209  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 340				; 00000154H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-340]
	mov	ecx, 85					; 00000055H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 210  : 		T x0, x1, x2, a, b, q;
; 211  : 
; 212  : 		//x[0] = 1
; 213  : 		usetw( x0, 1 );

	push	1
	lea	eax, DWORD PTR _x0$[ebp]
	push	eax
	call	??$usetw@$$BY03I@big@@YAXAAY03II@Z	; big::usetw<unsigned int [4]>
	add	esp, 8

; 214  : 
; 215  : 		// a = 2^k (mod b0)
; 216  : 		rModn( n0, a );

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n0$[ebp]
	push	ecx
	call	??$rModn@$$BY03I@big@@YAXAAY03I0@Z	; big::rModn<unsigned int [4]>
	add	esp, 8

; 217  : 
; 218  : 		// {q, b} = b0 / a
; 219  : 		udivide( n0, a, q, b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	mov	eax, DWORD PTR _n0$[ebp]
	push	eax
	call	??$udivide@$$BY03I@big@@YAXAAY03I000@Z	; big::udivide<unsigned int [4]>
	add	esp, 16					; 00000010H

; 220  : 
; 221  : 		// if b = 0, return x[0]
; 222  : 
; 223  : 		if ( isZero( b ) )

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$isZero@$$BY03I@big@@YA_NAAY03I@Z	; big::isZero<unsigned int [4]>
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN10@computeRin

; 224  : 		{
; 225  : 			set ( rp, x0 )
; 226  : 
; 227  : 				;

	lea	eax, DWORD PTR _x0$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rp$[ebp]
	push	ecx
	call	??$set@$$BY03I@big@@YAXAAY03I0@Z	; big::set<unsigned int [4]>
	add	esp, 8

; 228  : 			return ;

	jmp	$LN11@computeRin
$LN10@computeRin:

; 229  : 		}
; 230  : 
; 231  : 		// x[1] = -q (mod b0) = b0 - q, q <= b0
; 232  : 		set ( x1, n0 )
; 233  : 
; 234  : 			;

	mov	eax, DWORD PTR _n0$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x1$[ebp]
	push	ecx
	call	??$set@$$BY03I@big@@YAXAAY03I0@Z	; big::set<unsigned int [4]>
	add	esp, 8

; 235  : 		subtract( x1, q );

	lea	eax, DWORD PTR _q$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x1$[ebp]
	push	ecx
	call	??$subtract@$$BY03I@big@@YAXAAY03I0@Z	; big::subtract<unsigned int [4]>
	add	esp, 8

; 236  : 
; 237  : 		// {q, a} = a / b
; 238  : 		udivide( a, b, q, a );

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	lea	edx, DWORD PTR _b$[ebp]
	push	edx
	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	call	??$udivide@$$BY03I@big@@YAXAAY03I000@Z	; big::udivide<unsigned int [4]>
	add	esp, 16					; 00000010H

; 239  : 
; 240  : 		// if a = 0, return x[1]
; 241  : 		if ( isZero( a ) )

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	call	??$isZero@$$BY03I@big@@YA_NAAY03I@Z	; big::isZero<unsigned int [4]>
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN8@computeRin

; 242  : 		{
; 243  : 			set ( rp, x1 )
; 244  : 
; 245  : 				;

	lea	eax, DWORD PTR _x1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rp$[ebp]
	push	ecx
	call	??$set@$$BY03I@big@@YAXAAY03I0@Z	; big::set<unsigned int [4]>
	add	esp, 8

; 246  : 			return ;

	jmp	$LN11@computeRin
$LN8@computeRin:

; 247  : 		}
; 248  : #ifdef _MSC_VER
; 249  : #pragma warning( disable : 4127 ) // warning C4127: conditional expression is constant
; 250  : #endif
; 251  : 		while ( true )

	mov	eax, 1
	test	eax, eax
	je	$LN11@computeRin

; 252  : 		{
; 253  : 			// x[2] = x[0] - x[1] * q (mod b0)
; 254  : 			SubMulMod( q, x1, x0, n0, x2 );

	lea	eax, DWORD PTR _x2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n0$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x0$[ebp]
	push	edx
	lea	eax, DWORD PTR _x1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	call	??$SubMulMod@$$BY03I@big@@YAXAAY03I0000@Z ; big::SubMulMod<unsigned int [4]>
	add	esp, 20					; 00000014H

; 255  : 
; 256  : 			// {q, b} = b / a
; 257  : 			udivide( b, a, q, b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$udivide@$$BY03I@big@@YAXAAY03I000@Z	; big::udivide<unsigned int [4]>
	add	esp, 16					; 00000010H

; 258  : 
; 259  : 			// if b = 0, return x[2]
; 260  : 
; 261  : 			if ( isZero( b ) )

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$isZero@$$BY03I@big@@YA_NAAY03I@Z	; big::isZero<unsigned int [4]>
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@computeRin

; 262  : 			{
; 263  : 				set ( rp, x2 )
; 264  : 
; 265  : 					;

	lea	eax, DWORD PTR _x2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rp$[ebp]
	push	ecx
	call	??$set@$$BY03I@big@@YAXAAY03I0@Z	; big::set<unsigned int [4]>
	add	esp, 8

; 266  : 				return ;

	jmp	$LN11@computeRin
$LN6@computeRin:

; 267  : 			}
; 268  : 
; 269  : 			// x[0] = x[1] - x[2] * q (mod b0)
; 270  : 			SubMulMod( q, x2, x1, n0, x0 );

	lea	eax, DWORD PTR _x0$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n0$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x1$[ebp]
	push	edx
	lea	eax, DWORD PTR _x2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	call	??$SubMulMod@$$BY03I@big@@YAXAAY03I0000@Z ; big::SubMulMod<unsigned int [4]>
	add	esp, 20					; 00000014H

; 271  : 
; 272  : 			// {q, a} = a / b
; 273  : 			udivide( a, b, q, a );

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	lea	edx, DWORD PTR _b$[ebp]
	push	edx
	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	call	??$udivide@$$BY03I@big@@YAXAAY03I000@Z	; big::udivide<unsigned int [4]>
	add	esp, 16					; 00000010H

; 274  : 
; 275  : 			// if a = 0, return x[0]
; 276  : 			if ( isZero( a ) )

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	call	??$isZero@$$BY03I@big@@YA_NAAY03I@Z	; big::isZero<unsigned int [4]>
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@computeRin

; 277  : 			{
; 278  : 				set ( rp, x0 )
; 279  : 
; 280  : 					;

	lea	eax, DWORD PTR _x0$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rp$[ebp]
	push	ecx
	call	??$set@$$BY03I@big@@YAXAAY03I0@Z	; big::set<unsigned int [4]>
	add	esp, 8

; 281  : 				return ;

	jmp	$LN11@computeRin
$LN5@computeRin:

; 282  : 			}
; 283  : 
; 284  : 			// x[1] = x[2] - x[0] * q (mod b0)
; 285  : 			SubMulMod( q, x0, x2, n0, x1 );

	lea	eax, DWORD PTR _x1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n0$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x2$[ebp]
	push	edx
	lea	eax, DWORD PTR _x0$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	call	??$SubMulMod@$$BY03I@big@@YAXAAY03I0000@Z ; big::SubMulMod<unsigned int [4]>
	add	esp, 20					; 00000014H

; 286  : 
; 287  : 			// {q, b} = b / a
; 288  : 			udivide( b, a, q, b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$udivide@$$BY03I@big@@YAXAAY03I000@Z	; big::udivide<unsigned int [4]>
	add	esp, 16					; 00000010H

; 289  : 
; 290  : 			// if b = 0, return x[1]
; 291  : 			if ( isZero( b ) )

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$isZero@$$BY03I@big@@YA_NAAY03I@Z	; big::isZero<unsigned int [4]>
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@computeRin

; 292  : 			{
; 293  : 				set ( rp, x1 )
; 294  : 
; 295  : 					;

	lea	eax, DWORD PTR _x1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rp$[ebp]
	push	ecx
	call	??$set@$$BY03I@big@@YAXAAY03I0@Z	; big::set<unsigned int [4]>
	add	esp, 8

; 296  : 				return ;

	jmp	$LN11@computeRin
$LN4@computeRin:

; 297  : 			}
; 298  : 
; 299  : 			// x[2] = x[0] - x[1] * q (mod b0)
; 300  : 			SubMulMod( q, x1, x0, n0, x2 );

	lea	eax, DWORD PTR _x2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n0$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x0$[ebp]
	push	edx
	lea	eax, DWORD PTR _x1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	call	??$SubMulMod@$$BY03I@big@@YAXAAY03I0000@Z ; big::SubMulMod<unsigned int [4]>
	add	esp, 20					; 00000014H

; 301  : 
; 302  : 			// {q, a} = a / b
; 303  : 			udivide( a, b, q, a );

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	lea	edx, DWORD PTR _b$[ebp]
	push	edx
	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	call	??$udivide@$$BY03I@big@@YAXAAY03I000@Z	; big::udivide<unsigned int [4]>
	add	esp, 16					; 00000010H

; 304  : 
; 305  : 			// if a = 0, return x[2]
; 306  : 			if ( isZero( a ) )

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	call	??$isZero@$$BY03I@big@@YA_NAAY03I@Z	; big::isZero<unsigned int [4]>
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@computeRin

; 307  : 			{
; 308  : 				set ( rp, x2 )
; 309  : 
; 310  : 					;

	lea	eax, DWORD PTR _x2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rp$[ebp]
	push	ecx
	call	??$set@$$BY03I@big@@YAXAAY03I0@Z	; big::set<unsigned int [4]>
	add	esp, 8

; 311  : 				return ;

	jmp	$LN11@computeRin
$LN3@computeRin:

; 312  : 			}
; 313  : 
; 314  : 			// x[0] = x[1] - x[2] * q (mod b0)
; 315  : 			SubMulMod( q, x2, x1, n0, x0 );

	lea	eax, DWORD PTR _x0$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n0$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x1$[ebp]
	push	edx
	lea	eax, DWORD PTR _x2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	call	??$SubMulMod@$$BY03I@big@@YAXAAY03I0000@Z ; big::SubMulMod<unsigned int [4]>
	add	esp, 20					; 00000014H

; 316  : 
; 317  : 			// {q, b} = b / a
; 318  : 			udivide( b, a, q, b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$udivide@$$BY03I@big@@YAXAAY03I000@Z	; big::udivide<unsigned int [4]>
	add	esp, 16					; 00000010H

; 319  : 
; 320  : 			// if b = 0, return x[0]
; 321  : 			if ( isZero( b ) )

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$isZero@$$BY03I@big@@YA_NAAY03I@Z	; big::isZero<unsigned int [4]>
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@computeRin

; 322  : 			{
; 323  : 				set ( rp, x0 )
; 324  : 
; 325  : 					;

	lea	eax, DWORD PTR _x0$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rp$[ebp]
	push	ecx
	call	??$set@$$BY03I@big@@YAXAAY03I0@Z	; big::set<unsigned int [4]>
	add	esp, 8

; 326  : 				return ;

	jmp	SHORT $LN11@computeRin
$LN2@computeRin:

; 327  : 			}
; 328  : 
; 329  : 			// x[1] = x[2] - x[0] * q (mod b0)
; 330  : 			SubMulMod( q, x0, x2, n0, x1 );

	lea	eax, DWORD PTR _x1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n0$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x2$[ebp]
	push	edx
	lea	eax, DWORD PTR _x0$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	call	??$SubMulMod@$$BY03I@big@@YAXAAY03I0000@Z ; big::SubMulMod<unsigned int [4]>
	add	esp, 20					; 00000014H

; 331  : 
; 332  : 			// {q, a} = a / b
; 333  : 			udivide( a, b, q, a );

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	lea	edx, DWORD PTR _b$[ebp]
	push	edx
	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	call	??$udivide@$$BY03I@big@@YAXAAY03I000@Z	; big::udivide<unsigned int [4]>
	add	esp, 16					; 00000010H

; 334  : 
; 335  : 			// if a = 0, return x[1]
; 336  : 			if ( isZero( a ) )

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	call	??$isZero@$$BY03I@big@@YA_NAAY03I@Z	; big::isZero<unsigned int [4]>
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@computeRin

; 337  : 			{
; 338  : 				set ( rp, x1 )
; 339  : 
; 340  : 					;

	lea	eax, DWORD PTR _x1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rp$[ebp]
	push	ecx
	call	??$set@$$BY03I@big@@YAXAAY03I0@Z	; big::set<unsigned int [4]>
	add	esp, 8

; 341  : 				return ;

	jmp	SHORT $LN11@computeRin
$LN1@computeRin:

; 342  : 			}
; 343  : 		}

	jmp	$LN8@computeRin
$LN11@computeRin:

; 344  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN20@computeRin
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 340				; 00000154H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN20@computeRin:
	DD	6
	DD	$LN19@computeRin
$LN19@computeRin:
	DD	-24					; ffffffe8H
	DD	16					; 00000010H
	DD	$LN13@computeRin
	DD	-48					; ffffffd0H
	DD	16					; 00000010H
	DD	$LN14@computeRin
	DD	-72					; ffffffb8H
	DD	16					; 00000010H
	DD	$LN15@computeRin
	DD	-96					; ffffffa0H
	DD	16					; 00000010H
	DD	$LN16@computeRin
	DD	-120					; ffffff88H
	DD	16					; 00000010H
	DD	$LN17@computeRin
	DD	-144					; ffffff70H
	DD	16					; 00000010H
	DD	$LN18@computeRin
$LN18@computeRin:
	DB	113					; 00000071H
	DB	0
$LN17@computeRin:
	DB	98					; 00000062H
	DB	0
$LN16@computeRin:
	DB	97					; 00000061H
	DB	0
$LN15@computeRin:
	DB	120					; 00000078H
	DB	50					; 00000032H
	DB	0
$LN14@computeRin:
	DB	120					; 00000078H
	DB	49					; 00000031H
	DB	0
$LN13@computeRin:
	DB	120					; 00000078H
	DB	48					; 00000030H
	DB	0
??$computeRinverse@$$BY03I@big@@YAXAAY03I0@Z ENDP	; big::computeRinverse<unsigned int [4]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rsacrypt.h
;	COMDAT ??$SubMulMod@$$BY03I@big@@YAXAAY03I0000@Z
_TEXT	SEGMENT
_y$ = -104						; size = 16
_dn$ = -80						; size = 32
_da$ = -40						; size = 32
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_c$ = 16						; size = 4
_n$ = 20						; size = 4
_x$ = 24						; size = 4
??$SubMulMod@$$BY03I@big@@YAXAAY03I0000@Z PROC		; big::SubMulMod<unsigned int [4]>, COMDAT

; 165  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 300				; 0000012cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-300]
	mov	ecx, 75					; 0000004bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 166  : 		BIGDOUBLESIZE( T, da );
; 167  : 		BIGDOUBLESIZE( T, dn );
; 168  : 		T y;
; 169  : 
; 170  : 		// y = a b (mod n)
; 171  : 		usetlow( da, a );

	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	lea	ecx, DWORD PTR _da$[ebp]
	push	ecx
	call	??$usetlow@$$BY03I$$BY07I@big@@YAXAAY07IAAY03I@Z ; big::usetlow<unsigned int [4],unsigned int [8]>
	add	esp, 8

; 172  : 		umultiply( da, b );

	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _da$[ebp]
	push	ecx
	call	??$umultiply@$$BY03I$$BY07I@big@@YAXAAY07IAAY03I@Z ; big::umultiply<unsigned int [4],unsigned int [8]>
	add	esp, 8

; 173  : 		usetlow( dn, n );

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dn$[ebp]
	push	ecx
	call	??$usetlow@$$BY03I$$BY07I@big@@YAXAAY07IAAY03I@Z ; big::usetlow<unsigned int [4],unsigned int [8]>
	add	esp, 8

; 174  : 		umodulo( da, dn, da );

	lea	eax, DWORD PTR _da$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dn$[ebp]
	push	ecx
	lea	edx, DWORD PTR _da$[ebp]
	push	edx
	call	??$umodulo@$$BY07I@big@@YAXAAY07I00@Z	; big::umodulo<unsigned int [8]>
	add	esp, 12					; 0000000cH

; 175  : 		takelow( y, da );

	lea	eax, DWORD PTR _da$[ebp]
	push	eax
	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	call	??$takelow@$$BY03I$$BY07I@big@@YAXAAY03IAAY07I@Z ; big::takelow<unsigned int [4],unsigned int [8]>
	add	esp, 8

; 176  : 
; 177  : 		// x = (c - y) (mod n) > 0
; 178  : 
; 179  : 		set ( x, c )
; 180  : 
; 181  : 			;

	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	??$set@$$BY03I@big@@YAXAAY03I0@Z	; big::set<unsigned int [4]>
	add	esp, 8

; 182  : 		if ( ugreater( c, y ) )

	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	call	??$ugreater@$$BY03I@big@@YA_NAAY03I0@Z	; big::ugreater<unsigned int [4]>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@SubMulMod

; 183  : 		{
; 184  : 			subtract( x, y );

	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	??$subtract@$$BY03I@big@@YAXAAY03I0@Z	; big::subtract<unsigned int [4]>
	add	esp, 8

; 185  : 		}
; 186  : 
; 187  : 		else

	jmp	SHORT $LN3@SubMulMod
$LN2@SubMulMod:

; 188  : 		{
; 189  : 			subtract( x, y );

	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	??$subtract@$$BY03I@big@@YAXAAY03I0@Z	; big::subtract<unsigned int [4]>
	add	esp, 8

; 190  : 
; 191  : 			add ( x, n )
; 192  : 
; 193  : 				;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	??$add@$$BY03I@big@@YAXAAY03I0@Z	; big::add<unsigned int [4]>
	add	esp, 8
$LN3@SubMulMod:

; 194  : 		}
; 195  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@SubMulMod
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 300				; 0000012cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@SubMulMod:
	DD	3
	DD	$LN8@SubMulMod
$LN8@SubMulMod:
	DD	-40					; ffffffd8H
	DD	32					; 00000020H
	DD	$LN5@SubMulMod
	DD	-80					; ffffffb0H
	DD	32					; 00000020H
	DD	$LN6@SubMulMod
	DD	-104					; ffffff98H
	DD	16					; 00000010H
	DD	$LN7@SubMulMod
$LN7@SubMulMod:
	DB	121					; 00000079H
	DB	0
$LN6@SubMulMod:
	DB	100					; 00000064H
	DB	110					; 0000006eH
	DB	0
$LN5@SubMulMod:
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	0
??$SubMulMod@$$BY03I@big@@YAXAAY03I0000@Z ENDP		; big::SubMulMod<unsigned int [4]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$isZero@$$BY03I@big@@YA_NAAY03I@Z
_TEXT	SEGMENT
_ii$1 = -8						; size = 4
_n$ = 8							; size = 4
??$isZero@$$BY03I@big@@YA_NAAY03I@Z PROC		; big::isZero<unsigned int [4]>, COMDAT

; 419  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 420  : 		for ( u32 ii = 0; ii < BIGWORDCOUNT( T ); ++ii )

	mov	DWORD PTR _ii$1[ebp], 0
	jmp	SHORT $LN4@isZero
$LN3@isZero:
	mov	eax, DWORD PTR _ii$1[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$1[ebp], eax
$LN4@isZero:
	cmp	DWORD PTR _ii$1[ebp], 4
	jae	SHORT $LN2@isZero

; 421  : 			if ( n[ ii ] )

	mov	eax, DWORD PTR _ii$1[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $LN1@isZero

; 422  : 				return false;

	xor	al, al
	jmp	SHORT $LN5@isZero
$LN1@isZero:

; 423  : 				
; 424  : 		return true;

	jmp	SHORT $LN3@isZero
$LN2@isZero:
	mov	al, 1
$LN5@isZero:

; 425  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$isZero@$$BY03I@big@@YA_NAAY03I@Z ENDP		; big::isZero<unsigned int [4]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$udivide@$$BY03I@big@@YAXAAY03I000@Z
_TEXT	SEGMENT
tv152 = -272						; size = 4
_qshifts$ = -72						; size = 4
_jj$1 = -60						; size = 4
_ii$2 = -48						; size = 4
_shifts$ = -36						; size = 4
_b$ = -24						; size = 16
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_b0$ = 12						; size = 4
_q$ = 16						; size = 4
_r$ = 20						; size = 4
??$udivide@$$BY03I@big@@YAXAAY03I000@Z PROC		; big::udivide<unsigned int [4]>, COMDAT

; 1168 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 272				; 00000110H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-272]
	mov	ecx, 68					; 00000044H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1169 : 		T b;
; 1170 : 		
; 1171 : 		set ( b, b0 )
; 1172 : 		
; 1173 : 		;

	mov	eax, DWORD PTR _b0$[ebp]
	push	eax
	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	call	??$set@$$BY03I@big@@YAXAAY03I0@Z	; big::set<unsigned int [4]>
	add	esp, 8

; 1174 : 		set ( r, a )
; 1175 : 		
; 1176 : 		;

	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	call	??$set@$$BY03I@big@@YAXAAY03I0@Z	; big::set<unsigned int [4]>
	add	esp, 8

; 1177 : 		zero( q );

	mov	eax, DWORD PTR _q$[ebp]
	push	eax
	call	??$zero@$$BY03I@big@@YAXAAY03I@Z	; big::zero<unsigned int [4]>
	add	esp, 4

; 1178 : 		
; 1179 : 		u32 shifts = 1;

	mov	DWORD PTR _shifts$[ebp], 1

; 1180 : 		
; 1181 : 		// sort of: shift b left until b > r, then shift back one
; 1182 : 		if ( !BIGHIGHBIT( b ) && ugreater( r, b ) )

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _b$[ebp+ecx]
	and	edx, -2147483648			; 80000000H
	jne	$LN19@udivide
	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	call	??$ugreater@$$BY03I@big@@YA_NAAY03I0@Z	; big::ugreater<unsigned int [4]>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	$LN19@udivide

; 1183 : 		{
; 1184 : 			s32 ii, jj;
; 1185 : 			
; 1186 : 			// shift by words if possible
; 1187 : 			
; 1188 : 			for ( ii = BIGWORDCOUNT( T ) - 1; ii >= 0; --ii )

	mov	DWORD PTR _ii$2[ebp], 3
	jmp	SHORT $LN18@udivide
$LN17@udivide:
	mov	eax, DWORD PTR _ii$2[ebp]
	sub	eax, 1
	mov	DWORD PTR _ii$2[ebp], eax
$LN18@udivide:
	cmp	DWORD PTR _ii$2[ebp], 0
	jl	SHORT $LN16@udivide

; 1189 : 				if ( r[ ii ] )

	mov	eax, DWORD PTR _ii$2[ebp]
	mov	ecx, DWORD PTR _r$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $LN15@udivide

; 1190 : 					break;

	jmp	SHORT $LN16@udivide
$LN15@udivide:

; 1191 : 					
; 1192 : 			for ( jj = ii; jj >= 0; --jj )

	jmp	SHORT $LN17@udivide
$LN16@udivide:
	mov	eax, DWORD PTR _ii$2[ebp]
	mov	DWORD PTR _jj$1[ebp], eax
	jmp	SHORT $LN14@udivide
$LN13@udivide:
	mov	eax, DWORD PTR _jj$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _jj$1[ebp], eax
$LN14@udivide:
	cmp	DWORD PTR _jj$1[ebp], 0
	jl	SHORT $LN12@udivide

; 1193 : 				if ( b[ jj ] )

	mov	eax, DWORD PTR _jj$1[ebp]
	cmp	DWORD PTR _b$[ebp+eax*4], 0
	je	SHORT $LN11@udivide

; 1194 : 					break;

	jmp	SHORT $LN12@udivide
$LN11@udivide:

; 1195 : 					
; 1196 : 			if ( ii != jj )

	jmp	SHORT $LN13@udivide
$LN12@udivide:
	mov	eax, DWORD PTR _ii$2[ebp]
	cmp	eax, DWORD PTR _jj$1[ebp]
	je	SHORT $LN9@udivide

; 1197 : 			{
; 1198 : 				shifts = ( ii - jj ) * WORDBITS;

	mov	eax, DWORD PTR _ii$2[ebp]
	sub	eax, DWORD PTR _jj$1[ebp]
	shl	eax, 5
	mov	DWORD PTR _shifts$[ebp], eax

; 1199 : 				shiftLeft( b, shifts );

	mov	eax, DWORD PTR _shifts$[ebp]
	push	eax
	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	call	??$shiftLeft@$$BY03I@big@@YAXAAY03II@Z	; big::shiftLeft<unsigned int [4]>
	add	esp, 8

; 1200 : 				++shifts;

	mov	eax, DWORD PTR _shifts$[ebp]
	add	eax, 1
	mov	DWORD PTR _shifts$[ebp], eax
$LN9@udivide:

; 1201 : 			}
; 1202 : 			
; 1203 : 			while ( !BIGHIGHBIT( b ) && ugreater( r, b ) )

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _b$[ebp+ecx]
	and	edx, -2147483648			; 80000000H
	jne	SHORT $LN7@udivide
	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	call	??$ugreater@$$BY03I@big@@YA_NAAY03I0@Z	; big::ugreater<unsigned int [4]>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN7@udivide

; 1204 : 			{
; 1205 : 				shiftLeft1( b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$shiftLeft1@$$BY03I@big@@YAXAAY03I@Z	; big::shiftLeft1<unsigned int [4]>
	add	esp, 4

; 1206 : 				
; 1207 : 				++shifts;

	mov	eax, DWORD PTR _shifts$[ebp]
	add	eax, 1
	mov	DWORD PTR _shifts$[ebp], eax

; 1208 : 			}

	jmp	SHORT $LN9@udivide
$LN7@udivide:

; 1209 : 			
; 1210 : 			while ( ugreater( b, r ) )

	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	call	??$ugreater@$$BY03I@big@@YA_NAAY03I0@Z	; big::ugreater<unsigned int [4]>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN6@udivide

; 1211 : 			{
; 1212 : 				ushiftRight1( b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$ushiftRight1@$$BY03I@big@@YAXAAY03I@Z ; big::ushiftRight1<unsigned int [4]>
	add	esp, 4

; 1213 : 				
; 1214 : 				--shifts;

	mov	eax, DWORD PTR _shifts$[ebp]
	sub	eax, 1
	mov	DWORD PTR _shifts$[ebp], eax

; 1215 : 			}

	jmp	SHORT $LN7@udivide
$LN6@udivide:

; 1216 : 		}
; 1217 : 		
; 1218 : 		else

	jmp	SHORT $LN5@udivide
$LN19@udivide:

; 1219 : 			if ( ugreater( b, r ) )

	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	call	??$ugreater@$$BY03I@big@@YA_NAAY03I0@Z	; big::ugreater<unsigned int [4]>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN5@udivide

; 1220 : 			{
; 1221 : 				ushiftRight1( b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$ushiftRight1@$$BY03I@big@@YAXAAY03I@Z ; big::ushiftRight1<unsigned int [4]>
	add	esp, 4

; 1222 : 				
; 1223 : 				--shifts;

	mov	eax, DWORD PTR _shifts$[ebp]
	sub	eax, 1
	mov	DWORD PTR _shifts$[ebp], eax
$LN5@udivide:

; 1224 : 			}
; 1225 : 			
; 1226 : 		u32 qshifts = 0;

	mov	DWORD PTR _qshifts$[ebp], 0
$LN3@udivide:

; 1227 : 		
; 1228 : 		while ( shifts-- )

	mov	eax, DWORD PTR _shifts$[ebp]
	mov	DWORD PTR tv152[ebp], eax
	mov	ecx, DWORD PTR _shifts$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _shifts$[ebp], ecx
	cmp	DWORD PTR tv152[ebp], 0
	je	SHORT $LN2@udivide

; 1229 : 		{
; 1230 : 			++qshifts;

	mov	eax, DWORD PTR _qshifts$[ebp]
	add	eax, 1
	mov	DWORD PTR _qshifts$[ebp], eax

; 1231 : 			
; 1232 : 			if ( !ugreater( b, r ) )

	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	call	??$ugreater@$$BY03I@big@@YA_NAAY03I0@Z	; big::ugreater<unsigned int [4]>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN1@udivide

; 1233 : 			{
; 1234 : 				subtract( r, b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	call	??$subtract@$$BY03I@big@@YAXAAY03I0@Z	; big::subtract<unsigned int [4]>
	add	esp, 8

; 1235 : 				
; 1236 : 				shiftLeft( q, qshifts );

	mov	eax, DWORD PTR _qshifts$[ebp]
	push	eax
	mov	ecx, DWORD PTR _q$[ebp]
	push	ecx
	call	??$shiftLeft@$$BY03I@big@@YAXAAY03II@Z	; big::shiftLeft<unsigned int [4]>
	add	esp, 8

; 1237 : 				qshifts = 0;

	mov	DWORD PTR _qshifts$[ebp], 0

; 1238 : 				
; 1239 : 				q[ 0 ] |= 1;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _q$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	or	eax, 1
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _q$[ebp]
	mov	DWORD PTR [ecx+edx], eax
$LN1@udivide:

; 1240 : 			}
; 1241 : 			
; 1242 : 			ushiftRight1( b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$ushiftRight1@$$BY03I@big@@YAXAAY03I@Z ; big::ushiftRight1<unsigned int [4]>
	add	esp, 4

; 1243 : 		}

	jmp	$LN3@udivide
$LN2@udivide:

; 1244 : 		
; 1245 : 		shiftLeft( q, qshifts );

	mov	eax, DWORD PTR _qshifts$[ebp]
	push	eax
	mov	ecx, DWORD PTR _q$[ebp]
	push	ecx
	call	??$shiftLeft@$$BY03I@big@@YAXAAY03II@Z	; big::shiftLeft<unsigned int [4]>
	add	esp, 8

; 1246 : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN24@udivide
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 272				; 00000110H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN24@udivide:
	DD	1
	DD	$LN23@udivide
$LN23@udivide:
	DD	-24					; ffffffe8H
	DD	16					; 00000010H
	DD	$LN22@udivide
$LN22@udivide:
	DB	98					; 00000062H
	DB	0
??$udivide@$$BY03I@big@@YAXAAY03I000@Z ENDP		; big::udivide<unsigned int [4]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$usetw@$$BY03I@big@@YAXAAY03II@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$usetw@$$BY03I@big@@YAXAAY03II@Z PROC			; big::usetw<unsigned int [4]>, COMDAT

; 294  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 295  : 		a[ 0 ] = b;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR [edx+ecx], eax

; 296  : 		memset( a + 1, 0, sizeof( T ) - sizeof( word ) );

	push	12					; 0000000cH
	push	0
	mov	eax, DWORD PTR _a$[ebp]
	add	eax, 4
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 297  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$usetw@$$BY03I@big@@YAXAAY03II@Z ENDP			; big::usetw<unsigned int [4]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rsacrypt.h
;	COMDAT ??$computeModularInverse@$$BY07I@big@@YAXAAY07I00@Z
_TEXT	SEGMENT
_q$ = -240						; size = 32
_b$ = -200						; size = 32
_a$ = -160						; size = 32
_x2$ = -120						; size = 32
_x1$ = -80						; size = 32
_x0$ = -40						; size = 32
__$ArrayPad$ = -4					; size = 4
_a0$ = 8						; size = 4
_b0$ = 12						; size = 4
_ap$ = 16						; size = 4
??$computeModularInverse@$$BY07I@big@@YAXAAY07I00@Z PROC ; big::computeModularInverse<unsigned int [8]>, COMDAT

; 532  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 436				; 000001b4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-436]
	mov	ecx, 109				; 0000006dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 533  : 		T x0, x1, x2;
; 534  : 		T a, b, q;
; 535  : 
; 536  : 		// x[2] = 1
; 537  : 		usetw( x2, 1 );

	push	1
	lea	eax, DWORD PTR _x2$[ebp]
	push	eax
	call	??$usetw@$$BY07I@big@@YAXAAY07II@Z	; big::usetw<unsigned int [8]>
	add	esp, 8

; 538  : 
; 539  : 		// {q, b} = b0 / a0
; 540  : 		udivide( b0, a0, q, b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	mov	edx, DWORD PTR _a0$[ebp]
	push	edx
	mov	eax, DWORD PTR _b0$[ebp]
	push	eax
	call	??$udivide@$$BY07I@big@@YAXAAY07I000@Z	; big::udivide<unsigned int [8]>
	add	esp, 16					; 00000010H

; 541  : 
; 542  : 		// x[0] = -q (mod b0) = b0 - q, q <= b0
; 543  : 
; 544  : 		set ( x0, b0 )
; 545  : 
; 546  : 			;

	mov	eax, DWORD PTR _b0$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x0$[ebp]
	push	ecx
	call	??$set@$$BY07I@big@@YAXAAY07I0@Z	; big::set<unsigned int [8]>
	add	esp, 8

; 547  : 		subtract( x0, q );

	lea	eax, DWORD PTR _q$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x0$[ebp]
	push	ecx
	call	??$subtract@$$BY07I@big@@YAXAAY07I0@Z	; big::subtract<unsigned int [8]>
	add	esp, 8

; 548  : 
; 549  : 		set ( a, a0 )
; 550  : 
; 551  : 			;

	mov	eax, DWORD PTR _a0$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	??$set@$$BY07I@big@@YAXAAY07I0@Z	; big::set<unsigned int [8]>
	add	esp, 8
$LN8@computeMod:

; 552  : 
; 553  : #ifdef _MSC_VER
; 554  : #pragma warning( disable : 4127 ) // warning C4127: conditional expression is constant
; 555  : #endif
; 556  : 		while ( true )

	mov	eax, 1
	test	eax, eax
	je	$LN9@computeMod

; 557  : 		{
; 558  : 			// {q, a} = a / b
; 559  : 			udivide( a, b, q, a );

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	lea	edx, DWORD PTR _b$[ebp]
	push	edx
	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	call	??$udivide@$$BY07I@big@@YAXAAY07I000@Z	; big::udivide<unsigned int [8]>
	add	esp, 16					; 00000010H

; 560  : 
; 561  : 			// if a = 0, return x[0]
; 562  : 
; 563  : 			if ( isZero( a ) )

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	call	??$isZero@$$BY07I@big@@YA_NAAY07I@Z	; big::isZero<unsigned int [8]>
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@computeMod

; 564  : 			{
; 565  : 				set ( ap, x0 )
; 566  : 
; 567  : 					;

	lea	eax, DWORD PTR _x0$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ap$[ebp]
	push	ecx
	call	??$set@$$BY07I@big@@YAXAAY07I0@Z	; big::set<unsigned int [8]>
	add	esp, 8

; 568  : 				return ;

	jmp	$LN9@computeMod
$LN6@computeMod:

; 569  : 			}
; 570  : 
; 571  : 			// x[1] = x[2] - x[0] * q (mod b0)
; 572  : 			SubMulMod( x0, q, x2, b0, x1 );

	lea	eax, DWORD PTR _x1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _b0$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x2$[ebp]
	push	edx
	lea	eax, DWORD PTR _q$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x0$[ebp]
	push	ecx
	call	??$SubMulMod@$$BY07I@big@@YAXAAY07I0000@Z ; big::SubMulMod<unsigned int [8]>
	add	esp, 20					; 00000014H

; 573  : 
; 574  : 			// {q, b} = b / a
; 575  : 			udivide( b, a, q, b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$udivide@$$BY07I@big@@YAXAAY07I000@Z	; big::udivide<unsigned int [8]>
	add	esp, 16					; 00000010H

; 576  : 
; 577  : 			// if b = 0, return x[1]
; 578  : 			if ( isZero( b ) )

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$isZero@$$BY07I@big@@YA_NAAY07I@Z	; big::isZero<unsigned int [8]>
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@computeMod

; 579  : 			{
; 580  : 				set ( ap, x1 )
; 581  : 
; 582  : 					;

	lea	eax, DWORD PTR _x1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ap$[ebp]
	push	ecx
	call	??$set@$$BY07I@big@@YAXAAY07I0@Z	; big::set<unsigned int [8]>
	add	esp, 8

; 583  : 				return ;

	jmp	$LN9@computeMod
$LN5@computeMod:

; 584  : 			}
; 585  : 
; 586  : 			// x[2] = x[0] - x[1] * q (mod b0)
; 587  : 			SubMulMod( x1, q, x0, b0, x2 );

	lea	eax, DWORD PTR _x2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _b0$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x0$[ebp]
	push	edx
	lea	eax, DWORD PTR _q$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x1$[ebp]
	push	ecx
	call	??$SubMulMod@$$BY07I@big@@YAXAAY07I0000@Z ; big::SubMulMod<unsigned int [8]>
	add	esp, 20					; 00000014H

; 588  : 
; 589  : 			// {q, a} = a / b
; 590  : 			udivide( a, b, q, a );

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	lea	edx, DWORD PTR _b$[ebp]
	push	edx
	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	call	??$udivide@$$BY07I@big@@YAXAAY07I000@Z	; big::udivide<unsigned int [8]>
	add	esp, 16					; 00000010H

; 591  : 
; 592  : 			// if a = 0, return x[2]
; 593  : 			if ( isZero( a ) )

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	call	??$isZero@$$BY07I@big@@YA_NAAY07I@Z	; big::isZero<unsigned int [8]>
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@computeMod

; 594  : 			{
; 595  : 				set ( ap, x2 )
; 596  : 
; 597  : 					;

	lea	eax, DWORD PTR _x2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ap$[ebp]
	push	ecx
	call	??$set@$$BY07I@big@@YAXAAY07I0@Z	; big::set<unsigned int [8]>
	add	esp, 8

; 598  : 				return ;

	jmp	$LN9@computeMod
$LN4@computeMod:

; 599  : 			}
; 600  : 
; 601  : 			// x[0] = x[1] - x[2] * q (mod b0)
; 602  : 			SubMulMod( x2, q, x1, b0, x0 );

	lea	eax, DWORD PTR _x0$[ebp]
	push	eax
	mov	ecx, DWORD PTR _b0$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x1$[ebp]
	push	edx
	lea	eax, DWORD PTR _q$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x2$[ebp]
	push	ecx
	call	??$SubMulMod@$$BY07I@big@@YAXAAY07I0000@Z ; big::SubMulMod<unsigned int [8]>
	add	esp, 20					; 00000014H

; 603  : 
; 604  : 			// {q, b} = b / a
; 605  : 			udivide( b, a, q, b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$udivide@$$BY07I@big@@YAXAAY07I000@Z	; big::udivide<unsigned int [8]>
	add	esp, 16					; 00000010H

; 606  : 
; 607  : 			// if b = 0, return x[0]
; 608  : 			if ( isZero( b ) )

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$isZero@$$BY07I@big@@YA_NAAY07I@Z	; big::isZero<unsigned int [8]>
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@computeMod

; 609  : 			{
; 610  : 				set ( ap, x0 )
; 611  : 
; 612  : 					;

	lea	eax, DWORD PTR _x0$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ap$[ebp]
	push	ecx
	call	??$set@$$BY07I@big@@YAXAAY07I0@Z	; big::set<unsigned int [8]>
	add	esp, 8

; 613  : 				return ;

	jmp	$LN9@computeMod
$LN3@computeMod:

; 614  : 			}
; 615  : 
; 616  : 			// x[1] = x[2] - x[0] * q (mod b0)
; 617  : 			SubMulMod( x0, q, x2, b0, x1 );

	lea	eax, DWORD PTR _x1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _b0$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x2$[ebp]
	push	edx
	lea	eax, DWORD PTR _q$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x0$[ebp]
	push	ecx
	call	??$SubMulMod@$$BY07I@big@@YAXAAY07I0000@Z ; big::SubMulMod<unsigned int [8]>
	add	esp, 20					; 00000014H

; 618  : 
; 619  : 			// {q, a} = a / b
; 620  : 			udivide( a, b, q, a );

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	lea	edx, DWORD PTR _b$[ebp]
	push	edx
	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	call	??$udivide@$$BY07I@big@@YAXAAY07I000@Z	; big::udivide<unsigned int [8]>
	add	esp, 16					; 00000010H

; 621  : 
; 622  : 			// if a = 0, return x[1]
; 623  : 			if ( isZero( a ) )

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	call	??$isZero@$$BY07I@big@@YA_NAAY07I@Z	; big::isZero<unsigned int [8]>
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@computeMod

; 624  : 			{
; 625  : 				set ( ap, x1 )
; 626  : 
; 627  : 					;

	lea	eax, DWORD PTR _x1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ap$[ebp]
	push	ecx
	call	??$set@$$BY07I@big@@YAXAAY07I0@Z	; big::set<unsigned int [8]>
	add	esp, 8

; 628  : 				return ;

	jmp	$LN9@computeMod
$LN2@computeMod:

; 629  : 			}
; 630  : 
; 631  : 			// x[2] = x[0] - x[1] * q (mod b0)
; 632  : 			SubMulMod( x1, q, x0, b0, x2 );

	lea	eax, DWORD PTR _x2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _b0$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x0$[ebp]
	push	edx
	lea	eax, DWORD PTR _q$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x1$[ebp]
	push	ecx
	call	??$SubMulMod@$$BY07I@big@@YAXAAY07I0000@Z ; big::SubMulMod<unsigned int [8]>
	add	esp, 20					; 00000014H

; 633  : 
; 634  : 			// {q, b} = b / a
; 635  : 			udivide( b, a, q, b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$udivide@$$BY07I@big@@YAXAAY07I000@Z	; big::udivide<unsigned int [8]>
	add	esp, 16					; 00000010H

; 636  : 
; 637  : 			// if b = 0, return x[2]
; 638  : 			if ( isZero( b ) )

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$isZero@$$BY07I@big@@YA_NAAY07I@Z	; big::isZero<unsigned int [8]>
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@computeMod

; 639  : 			{
; 640  : 				set ( ap, x2 )
; 641  : 
; 642  : 					;

	lea	eax, DWORD PTR _x2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ap$[ebp]
	push	ecx
	call	??$set@$$BY07I@big@@YAXAAY07I0@Z	; big::set<unsigned int [8]>
	add	esp, 8

; 643  : 				return ;

	jmp	SHORT $LN9@computeMod
$LN1@computeMod:

; 644  : 			}
; 645  : 
; 646  : 			// x[0] = x[1] - x[2] * q (mod b0)
; 647  : 			SubMulMod( x2, q, x1, b0, x0 );

	lea	eax, DWORD PTR _x0$[ebp]
	push	eax
	mov	ecx, DWORD PTR _b0$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x1$[ebp]
	push	edx
	lea	eax, DWORD PTR _q$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x2$[ebp]
	push	ecx
	call	??$SubMulMod@$$BY07I@big@@YAXAAY07I0000@Z ; big::SubMulMod<unsigned int [8]>
	add	esp, 20					; 00000014H

; 648  : 		}

	jmp	$LN8@computeMod
$LN9@computeMod:

; 649  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN18@computeMod
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 436				; 000001b4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@computeMod:
	DD	6
	DD	$LN17@computeMod
$LN17@computeMod:
	DD	-40					; ffffffd8H
	DD	32					; 00000020H
	DD	$LN11@computeMod
	DD	-80					; ffffffb0H
	DD	32					; 00000020H
	DD	$LN12@computeMod
	DD	-120					; ffffff88H
	DD	32					; 00000020H
	DD	$LN13@computeMod
	DD	-160					; ffffff60H
	DD	32					; 00000020H
	DD	$LN14@computeMod
	DD	-200					; ffffff38H
	DD	32					; 00000020H
	DD	$LN15@computeMod
	DD	-240					; ffffff10H
	DD	32					; 00000020H
	DD	$LN16@computeMod
$LN16@computeMod:
	DB	113					; 00000071H
	DB	0
$LN15@computeMod:
	DB	98					; 00000062H
	DB	0
$LN14@computeMod:
	DB	97					; 00000061H
	DB	0
$LN13@computeMod:
	DB	120					; 00000078H
	DB	50					; 00000032H
	DB	0
$LN12@computeMod:
	DB	120					; 00000078H
	DB	49					; 00000031H
	DB	0
$LN11@computeMod:
	DB	120					; 00000078H
	DB	48					; 00000030H
	DB	0
??$computeModularInverse@$$BY07I@big@@YAXAAY07I00@Z ENDP ; big::computeModularInverse<unsigned int [8]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$equal@$$BY07I@big@@YA_NAAY07I0@Z
_TEXT	SEGMENT
tv69 = -196						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$equal@$$BY07I@big@@YA_NAAY07I0@Z PROC		; big::equal<unsigned int [8]>, COMDAT

; 413  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 414  : 		return memcmp( a, b, sizeof( T ) ) == 0;

	push	32					; 00000020H
	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN3@equal
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@equal
$LN3@equal:
	mov	DWORD PTR tv69[ebp], 0
$LN4@equal:
	mov	al, BYTE PTR tv69[ebp]

; 415  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$equal@$$BY07I@big@@YA_NAAY07I0@Z ENDP		; big::equal<unsigned int [8]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rsacrypt.h
;	COMDAT ??$GCD@$$BY07I@big@@YAXAAY07I00@Z
_TEXT	SEGMENT
_a$ = -40						; size = 32
__$ArrayPad$ = -4					; size = 4
_a0$ = 8						; size = 4
_b0$ = 12						; size = 4
_c$ = 16						; size = 4
??$GCD@$$BY07I@big@@YAXAAY07I00@Z PROC			; big::GCD<unsigned int [8]>, COMDAT

; 123  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 236				; 000000ecH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-236]
	mov	ecx, 59					; 0000003bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 124  : 		T a;
; 125  : 
; 126  : 		umodulo( a0, b0, c );

	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _b0$[ebp]
	push	ecx
	mov	edx, DWORD PTR _a0$[ebp]
	push	edx
	call	??$umodulo@$$BY07I@big@@YAXAAY07I00@Z	; big::umodulo<unsigned int [8]>
	add	esp, 12					; 0000000cH

; 127  : 
; 128  : 		if ( isZero( c ) )

	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	??$isZero@$$BY07I@big@@YA_NAAY07I@Z	; big::isZero<unsigned int [8]>
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@GCD

; 129  : 		{
; 130  : 			set ( c, b0 )
; 131  : 
; 132  : 				;

	mov	eax, DWORD PTR _b0$[ebp]
	push	eax
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	call	??$set@$$BY07I@big@@YAXAAY07I0@Z	; big::set<unsigned int [8]>
	add	esp, 8

; 133  : 			return ;

	jmp	$LN7@GCD
$LN6@GCD:

; 134  : 		}
; 135  : 
; 136  : 		umodulo( b0, c, a );

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	mov	edx, DWORD PTR _b0$[ebp]
	push	edx
	call	??$umodulo@$$BY07I@big@@YAXAAY07I00@Z	; big::umodulo<unsigned int [8]>
	add	esp, 12					; 0000000cH

; 137  : 
; 138  : 		if ( isZero( a ) )

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	call	??$isZero@$$BY07I@big@@YA_NAAY07I@Z	; big::isZero<unsigned int [8]>
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@GCD

; 139  : 			return ;

	jmp	SHORT $LN7@GCD
$LN4@GCD:

; 140  : 
; 141  : #ifdef _MSC_VER
; 142  : #pragma warning( disable : 4127 ) // warning C4127: conditional expression is constant
; 143  : #endif
; 144  : 		while ( true )

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN7@GCD

; 145  : 		{
; 146  : 			umodulo( c, a, c );

	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	call	??$umodulo@$$BY07I@big@@YAXAAY07I00@Z	; big::umodulo<unsigned int [8]>
	add	esp, 12					; 0000000cH

; 147  : 
; 148  : 			if ( isZero( c ) )

	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	??$isZero@$$BY07I@big@@YA_NAAY07I@Z	; big::isZero<unsigned int [8]>
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@GCD

; 149  : 			{
; 150  : 				set ( c, a )
; 151  : 
; 152  : 					;

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	call	??$set@$$BY07I@big@@YAXAAY07I0@Z	; big::set<unsigned int [8]>
	add	esp, 8

; 153  : 				return ;

	jmp	SHORT $LN7@GCD
$LN2@GCD:

; 154  : 			}
; 155  : 
; 156  : 			umodulo( a, c, a );

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	call	??$umodulo@$$BY07I@big@@YAXAAY07I00@Z	; big::umodulo<unsigned int [8]>
	add	esp, 12					; 0000000cH

; 157  : 
; 158  : 			if ( isZero( a ) )

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	call	??$isZero@$$BY07I@big@@YA_NAAY07I@Z	; big::isZero<unsigned int [8]>
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@GCD

; 159  : 				return ;

	jmp	SHORT $LN7@GCD
$LN1@GCD:

; 160  : 		}

	jmp	SHORT $LN4@GCD
$LN7@GCD:

; 161  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@GCD
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 236				; 000000ecH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN11@GCD:
	DD	1
	DD	$LN10@GCD
$LN10@GCD:
	DD	-40					; ffffffd8H
	DD	32					; 00000020H
	DD	$LN9@GCD
$LN9@GCD:
	DB	97					; 00000061H
	DB	0
??$GCD@$$BY07I@big@@YAXAAY07I00@Z ENDP			; big::GCD<unsigned int [8]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$ugreater@$$BY07I@big@@YA_NAAY07I0@Z
_TEXT	SEGMENT
_ii$1 = -8						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$ugreater@$$BY07I@big@@YA_NAAY07I0@Z PROC		; big::ugreater<unsigned int [8]>, COMDAT

; 353  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 354  : 		for ( s32 ii = BIGWORDCOUNT( T ) - 1; ii >= 0; --ii )

	mov	DWORD PTR _ii$1[ebp], 7
	jmp	SHORT $LN5@ugreater
$LN4@ugreater:
	mov	eax, DWORD PTR _ii$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _ii$1[ebp], eax
$LN5@ugreater:
	cmp	DWORD PTR _ii$1[ebp], 0
	jl	SHORT $LN3@ugreater

; 355  : 		{
; 356  : 			if ( a[ ii ] > b[ ii ] )

	mov	eax, DWORD PTR _ii$1[ebp]
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _ii$1[ebp]
	mov	esi, DWORD PTR _b$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	cmp	eax, DWORD PTR [esi+edx*4]
	jbe	SHORT $LN2@ugreater

; 357  : 				return true;

	mov	al, 1
	jmp	SHORT $LN6@ugreater
$LN2@ugreater:

; 358  : 				
; 359  : 			if ( a[ ii ] < b[ ii ] )

	mov	eax, DWORD PTR _ii$1[ebp]
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _ii$1[ebp]
	mov	esi, DWORD PTR _b$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	cmp	eax, DWORD PTR [esi+edx*4]
	jae	SHORT $LN1@ugreater

; 360  : 				return false;

	xor	al, al
	jmp	SHORT $LN6@ugreater
$LN1@ugreater:

; 361  : 		}

	jmp	SHORT $LN4@ugreater
$LN3@ugreater:

; 362  : 		
; 363  : 		return false;

	xor	al, al
$LN6@ugreater:

; 364  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$ugreater@$$BY07I@big@@YA_NAAY07I0@Z ENDP		; big::ugreater<unsigned int [8]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$shiftLeft@$$BY07I@big@@YAXAAY07II@Z
_TEXT	SEGMENT
_ii$1 = -68						; size = 4
_carry$2 = -56						; size = 4
_w_i$3 = -44						; size = 4
_bits$ = -32						; size = 4
_bases$ = -20						; size = 4
_ii$ = -8						; size = 4
_n$ = 8							; size = 4
_s$ = 12						; size = 4
??$shiftLeft@$$BY07I@big@@YAXAAY07II@Z PROC		; big::shiftLeft<unsigned int [8]>, COMDAT

; 477  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 478  : 		register s32 ii;
; 479  : 		register u32 bases = s / WORDBITS;

	mov	eax, DWORD PTR _s$[ebp]
	shr	eax, 5
	mov	DWORD PTR _bases$[ebp], eax

; 480  : 		u32 bits = s % WORDBITS;

	mov	eax, DWORD PTR _s$[ebp]
	xor	edx, edx
	mov	ecx, 32					; 00000020H
	div	ecx
	mov	DWORD PTR _bits$[ebp], edx

; 481  : 		
; 482  : 		// move whole bases first
; 483  : 		
; 484  : 		if ( bases )

	cmp	DWORD PTR _bases$[ebp], 0
	je	SHORT $LN8@shiftLeft

; 485  : 		{
; 486  : 			// shift bases
; 487  : 			
; 488  : 			for ( ii = BIGWORDCOUNT( T ) - 1 - bases; ii >= 0; --ii )

	mov	eax, 7
	sub	eax, DWORD PTR _bases$[ebp]
	mov	DWORD PTR _ii$[ebp], eax
	jmp	SHORT $LN7@shiftLeft
$LN6@shiftLeft:
	mov	eax, DWORD PTR _ii$[ebp]
	sub	eax, 1
	mov	DWORD PTR _ii$[ebp], eax
$LN7@shiftLeft:
	cmp	DWORD PTR _ii$[ebp], 0
	jl	SHORT $LN5@shiftLeft

; 489  : 				n[ ii + bases ] = n[ ii ];

	mov	eax, DWORD PTR _ii$[ebp]
	add	eax, DWORD PTR _bases$[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _ii$[ebp]
	mov	esi, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax*4], edx
	jmp	SHORT $LN6@shiftLeft
$LN5@shiftLeft:

; 490  : 				
; 491  : 			// clear the original locii of those bases
; 492  : 			memset( n, 0, bases * sizeof( word ) );

	mov	eax, DWORD PTR _bases$[ebp]
	shl	eax, 2
	push	eax
	push	0
	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
$LN8@shiftLeft:

; 493  : 		}
; 494  : 		
; 495  : 		if ( bits )

	cmp	DWORD PTR _bits$[ebp], 0
	je	SHORT $LN9@shiftLeft

; 496  : 		{
; 497  : 			register word w_i, carry = 0;

	mov	DWORD PTR _carry$2[ebp], 0

; 498  : 			
; 499  : 			for ( u32 ii = 0; ii < BIGWORDCOUNT( T ); ++ii )

	mov	DWORD PTR _ii$1[ebp], 0
	jmp	SHORT $LN3@shiftLeft
$LN2@shiftLeft:
	mov	eax, DWORD PTR _ii$1[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$1[ebp], eax
$LN3@shiftLeft:
	cmp	DWORD PTR _ii$1[ebp], 8
	jae	SHORT $LN9@shiftLeft

; 500  : 			{
; 501  : 				w_i = n[ ii ];

	mov	eax, DWORD PTR _ii$1[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _w_i$3[ebp], edx

; 502  : 				
; 503  : 				n[ ii ] = ( w_i << bits ) | carry;

	mov	eax, DWORD PTR _w_i$3[ebp]
	mov	ecx, DWORD PTR _bits$[ebp]
	shl	eax, cl
	or	eax, DWORD PTR _carry$2[ebp]
	mov	ecx, DWORD PTR _ii$1[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 504  : 				carry = w_i >> ( WORDBITS - bits );

	mov	ecx, 32					; 00000020H
	sub	ecx, DWORD PTR _bits$[ebp]
	mov	eax, DWORD PTR _w_i$3[ebp]
	shr	eax, cl
	mov	DWORD PTR _carry$2[ebp], eax

; 505  : 			}

	jmp	SHORT $LN2@shiftLeft
$LN9@shiftLeft:

; 506  : 		}
; 507  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$shiftLeft@$$BY07I@big@@YAXAAY07II@Z ENDP		; big::shiftLeft<unsigned int [8]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$umultiply@$$BY0BA@I$$BY0BA@I@big@@YAXAAY0BA@I00@Z
_TEXT	SEGMENT
_ctr$1 = -120						; size = 2
_w_i$2 = -108						; size = 4
_ii$3 = -96						; size = 4
_shifts$ = -84						; size = 4
_a$ = -72						; size = 64
__$ArrayPad$ = -4					; size = 4
_a0$ = 8						; size = 4
_b0$ = 12						; size = 4
_m$ = 16						; size = 4
??$umultiply@$$BY0BA@I$$BY0BA@I@big@@YAXAAY0BA@I00@Z PROC ; big::umultiply<unsigned int [16],unsigned int [16]>, COMDAT

; 916  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 316				; 0000013cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-316]
	mov	ecx, 79					; 0000004fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 917  : 		Bigger a;
; 918  : 		usetlow( a, a0 );

	mov	eax, DWORD PTR _a0$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	??$usetlow@$$BY0BA@I$$BY0BA@I@big@@YAXAAY0BA@I0@Z ; big::usetlow<unsigned int [16],unsigned int [16]>
	add	esp, 8

; 919  : 		
; 920  : 		zero( m );

	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	call	??$zero@$$BY0BA@I@big@@YAXAAY0BA@I@Z	; big::zero<unsigned int [16]>
	add	esp, 4

; 921  : 		
; 922  : 		u32 shifts = 0;

	mov	DWORD PTR _shifts$[ebp], 0

; 923  : 		
; 924  : 		for ( u32 ii = 0; ii < BIGWORDCOUNT( T ); ++ii )

	mov	DWORD PTR _ii$3[ebp], 0
	jmp	SHORT $LN7@umultiply
$LN6@umultiply:
	mov	eax, DWORD PTR _ii$3[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$3[ebp], eax
$LN7@umultiply:
	cmp	DWORD PTR _ii$3[ebp], 16		; 00000010H
	jae	SHORT $LN8@umultiply

; 925  : 		{
; 926  : 			word w_i = b0[ ii ];

	mov	eax, DWORD PTR _ii$3[ebp]
	mov	ecx, DWORD PTR _b0$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _w_i$2[ebp], edx

; 927  : 			
; 928  : 			u16 ctr = WORDBITS;

	mov	eax, 32					; 00000020H
	mov	WORD PTR _ctr$1[ebp], ax
$LN4@umultiply:

; 929  : 			
; 930  : 			while ( w_i )

	cmp	DWORD PTR _w_i$2[ebp], 0
	je	SHORT $LN3@umultiply

; 931  : 			{
; 932  : 				if ( w_i & 1 )

	mov	eax, DWORD PTR _w_i$2[ebp]
	and	eax, 1
	je	SHORT $LN2@umultiply

; 933  : 				{
; 934  : 					if ( shifts )

	cmp	DWORD PTR _shifts$[ebp], 0
	je	SHORT $LN1@umultiply

; 935  : 					{
; 936  : 						shiftLeft( a, shifts );

	mov	eax, DWORD PTR _shifts$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	??$shiftLeft@$$BY0BA@I@big@@YAXAAY0BA@II@Z ; big::shiftLeft<unsigned int [16]>
	add	esp, 8

; 937  : 						shifts = 0;

	mov	DWORD PTR _shifts$[ebp], 0
$LN1@umultiply:

; 938  : 					}
; 939  : 					
; 940  : 					add ( m, a )
; 941  : 					
; 942  : 					;

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	mov	ecx, DWORD PTR _m$[ebp]
	push	ecx
	call	??$add@$$BY0BA@I@big@@YAXAAY0BA@I0@Z	; big::add<unsigned int [16]>
	add	esp, 8
$LN2@umultiply:

; 943  : 				}
; 944  : 				
; 945  : 				w_i >>= 1;

	mov	eax, DWORD PTR _w_i$2[ebp]
	shr	eax, 1
	mov	DWORD PTR _w_i$2[ebp], eax

; 946  : 				++shifts;

	mov	eax, DWORD PTR _shifts$[ebp]
	add	eax, 1
	mov	DWORD PTR _shifts$[ebp], eax

; 947  : 				--ctr;

	mov	ax, WORD PTR _ctr$1[ebp]
	sub	ax, 1
	mov	WORD PTR _ctr$1[ebp], ax

; 948  : 			}

	jmp	SHORT $LN4@umultiply
$LN3@umultiply:

; 949  : 			
; 950  : 			shifts += ctr;

	movzx	eax, WORD PTR _ctr$1[ebp]
	add	eax, DWORD PTR _shifts$[ebp]
	mov	DWORD PTR _shifts$[ebp], eax

; 951  : 		}

	jmp	$LN6@umultiply
$LN8@umultiply:

; 952  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@umultiply
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@umultiply:
	DD	1
	DD	$LN11@umultiply
$LN11@umultiply:
	DD	-72					; ffffffb8H
	DD	64					; 00000040H
	DD	$LN10@umultiply
$LN10@umultiply:
	DB	97					; 00000061H
	DB	0
??$umultiply@$$BY0BA@I$$BY0BA@I@big@@YAXAAY0BA@I00@Z ENDP ; big::umultiply<unsigned int [16],unsigned int [16]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$usquare@$$BY0BA@I@big@@YAXAAY0BA@I@Z
_TEXT	SEGMENT
_ctr$1 = -192						; size = 2
_w_i$2 = -180						; size = 4
_ii$3 = -168						; size = 4
_shifts$ = -156						; size = 4
_a1$ = -144						; size = 64
_a0$ = -72						; size = 64
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
??$usquare@$$BY0BA@I@big@@YAXAAY0BA@I@Z PROC		; big::usquare<unsigned int [16]>, COMDAT

; 871  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 388				; 00000184H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-388]
	mov	ecx, 97					; 00000061H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 872  : 		T a0, a1;
; 873  : 		
; 874  : 		set ( a0, a )
; 875  : 		
; 876  : 		;

	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a0$[ebp]
	push	ecx
	call	??$set@$$BY0BA@I@big@@YAXAAY0BA@I0@Z	; big::set<unsigned int [16]>
	add	esp, 8

; 877  : 		set ( a1, a )
; 878  : 		
; 879  : 		;

	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a1$[ebp]
	push	ecx
	call	??$set@$$BY0BA@I@big@@YAXAAY0BA@I0@Z	; big::set<unsigned int [16]>
	add	esp, 8

; 880  : 		zero( a );

	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	??$zero@$$BY0BA@I@big@@YAXAAY0BA@I@Z	; big::zero<unsigned int [16]>
	add	esp, 4

; 881  : 		
; 882  : 		u32 shifts = 0;

	mov	DWORD PTR _shifts$[ebp], 0

; 883  : 		
; 884  : 		for ( u32 ii = 0; ii < BIGWORDCOUNT( T ); ++ii )

	mov	DWORD PTR _ii$3[ebp], 0
	jmp	SHORT $LN7@usquare
$LN6@usquare:
	mov	eax, DWORD PTR _ii$3[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$3[ebp], eax
$LN7@usquare:
	cmp	DWORD PTR _ii$3[ebp], 16		; 00000010H
	jae	$LN8@usquare

; 885  : 		{
; 886  : 			word w_i = a0[ ii ];

	mov	eax, DWORD PTR _ii$3[ebp]
	mov	ecx, DWORD PTR _a0$[ebp+eax*4]
	mov	DWORD PTR _w_i$2[ebp], ecx

; 887  : 			
; 888  : 			u16 ctr = WORDBITS;

	mov	eax, 32					; 00000020H
	mov	WORD PTR _ctr$1[ebp], ax
$LN4@usquare:

; 889  : 			
; 890  : 			while ( w_i )

	cmp	DWORD PTR _w_i$2[ebp], 0
	je	SHORT $LN3@usquare

; 891  : 			{
; 892  : 				if ( w_i & 1 )

	mov	eax, DWORD PTR _w_i$2[ebp]
	and	eax, 1
	je	SHORT $LN2@usquare

; 893  : 				{
; 894  : 					if ( shifts )

	cmp	DWORD PTR _shifts$[ebp], 0
	je	SHORT $LN1@usquare

; 895  : 					{
; 896  : 						shiftLeft( a1, shifts );

	mov	eax, DWORD PTR _shifts$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a1$[ebp]
	push	ecx
	call	??$shiftLeft@$$BY0BA@I@big@@YAXAAY0BA@II@Z ; big::shiftLeft<unsigned int [16]>
	add	esp, 8

; 897  : 						shifts = 0;

	mov	DWORD PTR _shifts$[ebp], 0
$LN1@usquare:

; 898  : 					}
; 899  : 					
; 900  : 					add ( a, a1 )
; 901  : 					
; 902  : 					;

	lea	eax, DWORD PTR _a1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	??$add@$$BY0BA@I@big@@YAXAAY0BA@I0@Z	; big::add<unsigned int [16]>
	add	esp, 8
$LN2@usquare:

; 903  : 				}
; 904  : 				
; 905  : 				w_i >>= 1;

	mov	eax, DWORD PTR _w_i$2[ebp]
	shr	eax, 1
	mov	DWORD PTR _w_i$2[ebp], eax

; 906  : 				++shifts;

	mov	eax, DWORD PTR _shifts$[ebp]
	add	eax, 1
	mov	DWORD PTR _shifts$[ebp], eax

; 907  : 				--ctr;

	mov	ax, WORD PTR _ctr$1[ebp]
	sub	ax, 1
	mov	WORD PTR _ctr$1[ebp], ax

; 908  : 			}

	jmp	$LN4@usquare
$LN3@usquare:

; 909  : 			
; 910  : 			shifts += ctr;

	movzx	eax, WORD PTR _ctr$1[ebp]
	add	eax, DWORD PTR _shifts$[ebp]
	mov	DWORD PTR _shifts$[ebp], eax

; 911  : 		}

	jmp	$LN6@usquare
$LN8@usquare:

; 912  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN13@usquare
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 388				; 00000184H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@usquare:
	DD	2
	DD	$LN12@usquare
$LN12@usquare:
	DD	-72					; ffffffb8H
	DD	64					; 00000040H
	DD	$LN10@usquare
	DD	-144					; ffffff70H
	DD	64					; 00000040H
	DD	$LN11@usquare
$LN11@usquare:
	DB	97					; 00000061H
	DB	49					; 00000031H
	DB	0
$LN10@usquare:
	DB	97					; 00000061H
	DB	48					; 00000030H
	DB	0
??$usquare@$$BY0BA@I@big@@YAXAAY0BA@I@Z ENDP		; big::usquare<unsigned int [16]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$usetw@$$BY0BA@I@big@@YAXAAY0BA@II@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$usetw@$$BY0BA@I@big@@YAXAAY0BA@II@Z PROC		; big::usetw<unsigned int [16]>, COMDAT

; 294  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 295  : 		a[ 0 ] = b;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR [edx+ecx], eax

; 296  : 		memset( a + 1, 0, sizeof( T ) - sizeof( word ) );

	push	60					; 0000003cH
	push	0
	mov	eax, DWORD PTR _a$[ebp]
	add	eax, 4
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 297  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$usetw@$$BY0BA@I@big@@YAXAAY0BA@II@Z ENDP		; big::usetw<unsigned int [16]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$add@$$BY07I@big@@YAXAAY07I0@Z
_TEXT	SEGMENT
_qc1$ = -8						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$add@$$BY07I@big@@YAXAAY07I0@Z PROC			; big::add<unsigned int [8]>, COMDAT

; 658  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 659  : #if defined(NO_TEMPLATE_INLINE_ASSEMBLY) && defined(ASSEMBLY_INTEL_SYNTAX)
; 660  : 		const u32 qc1 = BIGWORDCOUNT( T ) / 4 - 1;
; 661  : 		
; 662  : 		BorlandAdd( a, b, qc1 );
; 663  : 		
; 664  : #elif defined(ASSEMBLY_INTEL_SYNTAX)
; 665  : 		
; 666  : 		const u32 qc1 = BIGWORDCOUNT( T ) / 4 - 1;

	mov	DWORD PTR _qc1$[ebp], 1

; 667  : 		
; 668  : 		ASSEMBLY_BLOCK // VS.NET, x86, 32-bit words
; 669  : 		{
; 670  : 		        mov esi, b

	mov	esi, DWORD PTR _b$[ebp]

; 671  : 		        mov edi, a

	mov	edi, DWORD PTR _a$[ebp]

; 672  : 		        mov ecx, qc1

	mov	ecx, DWORD PTR _qc1$[ebp]

; 673  : 		
; 674  : 		        // unrolled loop since word count is a multiple of 4 >= 4
; 675  : 		        mov eax, [ esi ]

	mov	eax, DWORD PTR [esi]

; 676  : 		        xor edx, edx  // edx used later to index later words >= 4

	xor	edx, edx

; 677  : 		
; 678  : 		        add [ edi ], eax  // and now we can use ADD instead of ADC on the first addition

	add	DWORD PTR [edi], eax

; 679  : 		        mov eax, [ esi + 4 ]

	mov	eax, DWORD PTR [esi+4]

; 680  : 		        adc [ edi + 4 ], eax

	adc	DWORD PTR [edi+4], eax

; 681  : 		        mov eax, [ esi + 8 ]

	mov	eax, DWORD PTR [esi+8]

; 682  : 		        adc [ edi + 8 ], eax

	adc	DWORD PTR [edi+8], eax

; 683  : 		        mov eax, [ esi + 12 ]

	mov	eax, DWORD PTR [esi+12]

; 684  : 		        adc [ edi + 12 ], eax

	adc	DWORD PTR [edi+12], eax

; 685  : 		
; 686  : 		        jecxz done_already

	jecxz	$done_already$3
$next_word$4:

; 687  : 		
; 688  : 	        next_word:
; 689  : 		        inc edx

	inc	edx

; 690  : 		        inc edx

	inc	edx

; 691  : 		
; 692  : 		        // unrolled loop since word count is a multiple of 4 >= 4
; 693  : 		        mov eax, [ esi + edx * 8 ]

	mov	eax, DWORD PTR [esi+edx*8]

; 694  : 		        adc [ edi + edx * 8 ], eax

	adc	DWORD PTR [edi+edx*8], eax

; 695  : 		        mov eax, [ esi + edx * 8 + 4 ]

	mov	eax, DWORD PTR [esi+edx*8+4]

; 696  : 		        adc [ edi + edx * 8 + 4 ], eax

	adc	DWORD PTR [edi+edx*8+4], eax

; 697  : 		        mov eax, [ esi + edx * 8 + 8 ]

	mov	eax, DWORD PTR [esi+edx*8+8]

; 698  : 		        adc [ edi + edx * 8 + 8 ], eax

	adc	DWORD PTR [edi+edx*8+8], eax

; 699  : 		        mov eax, [ esi + edx * 8 + 12 ]

	mov	eax, DWORD PTR [esi+edx*8+12]

; 700  : 		        adc [ edi + edx * 8 + 12 ], eax

	adc	DWORD PTR [edi+edx*8+12], eax

; 701  : 		
; 702  : 		        loop next_word

	loop	$next_word$4
$done_already$3:

; 703  : 		
; 704  : 	        done_already:
; 705  : 		}
; 706  : #else
; 707  : 		register word carry = 0;
; 708  : 		
; 709  : 		for ( u32 ii = 0; ii < BIGWORDCOUNT( T ); ++ii )
; 710  : 		{
; 711  : 			word a_i = a[ ii ];
; 712  : 			word b_i = b[ ii ];
; 713  : 			a[ ii ] += b_i + carry;
; 714  : 		
; 715  : 			carry = ( ( a_i & ( WORDALLBITS >> 1 ) ) + ( b_i & ( WORDALLBITS >> 1 ) ) + carry ) >> ( WORDBITS - 1 );
; 716  : 			carry += ( a_i >> ( WORDBITS - 1 ) ) + ( b_i >> ( WORDBITS - 1 ) );
; 717  : 			carry >>= 1;
; 718  : 		}
; 719  : 		
; 720  : #endif
; 721  : 		
; 722  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$add@$$BY07I@big@@YAXAAY07I0@Z ENDP			; big::add<unsigned int [8]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$umultiply@$$BY07I$$BY07I@big@@YAXAAY07I0@Z
_TEXT	SEGMENT
_ctr$1 = -88						; size = 2
_w_i$2 = -76						; size = 4
_ii$3 = -64						; size = 4
_shifts$ = -52						; size = 4
_a$ = -40						; size = 32
__$ArrayPad$ = -4					; size = 4
_a0$ = 8						; size = 4
_b0$ = 12						; size = 4
??$umultiply@$$BY07I$$BY07I@big@@YAXAAY07I0@Z PROC	; big::umultiply<unsigned int [8],unsigned int [8]>, COMDAT

; 956  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 284				; 0000011cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-284]
	mov	ecx, 71					; 00000047H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 957  : 		Bigger a;
; 958  : 		
; 959  : 		set ( a, a0 )
; 960  : 		
; 961  : 		;

	mov	eax, DWORD PTR _a0$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	??$set@$$BY07I@big@@YAXAAY07I0@Z	; big::set<unsigned int [8]>
	add	esp, 8

; 962  : 		
; 963  : 		zero( a0 );

	mov	eax, DWORD PTR _a0$[ebp]
	push	eax
	call	??$zero@$$BY07I@big@@YAXAAY07I@Z	; big::zero<unsigned int [8]>
	add	esp, 4

; 964  : 		
; 965  : 		u32 shifts = 0;

	mov	DWORD PTR _shifts$[ebp], 0

; 966  : 		
; 967  : 		for ( u32 ii = 0; ii < BIGWORDCOUNT( T ); ++ii )

	mov	DWORD PTR _ii$3[ebp], 0
	jmp	SHORT $LN7@umultiply
$LN6@umultiply:
	mov	eax, DWORD PTR _ii$3[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$3[ebp], eax
$LN7@umultiply:
	cmp	DWORD PTR _ii$3[ebp], 8
	jae	SHORT $LN8@umultiply

; 968  : 		{
; 969  : 			word w_i = b0[ ii ];

	mov	eax, DWORD PTR _ii$3[ebp]
	mov	ecx, DWORD PTR _b0$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _w_i$2[ebp], edx

; 970  : 			
; 971  : 			u16 ctr = WORDBITS;

	mov	eax, 32					; 00000020H
	mov	WORD PTR _ctr$1[ebp], ax
$LN4@umultiply:

; 972  : 			
; 973  : 			while ( w_i )

	cmp	DWORD PTR _w_i$2[ebp], 0
	je	SHORT $LN3@umultiply

; 974  : 			{
; 975  : 				if ( w_i & 1 )

	mov	eax, DWORD PTR _w_i$2[ebp]
	and	eax, 1
	je	SHORT $LN2@umultiply

; 976  : 				{
; 977  : 					if ( shifts )

	cmp	DWORD PTR _shifts$[ebp], 0
	je	SHORT $LN1@umultiply

; 978  : 					{
; 979  : 						shiftLeft( a, shifts );

	mov	eax, DWORD PTR _shifts$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	??$shiftLeft@$$BY07I@big@@YAXAAY07II@Z	; big::shiftLeft<unsigned int [8]>
	add	esp, 8

; 980  : 						shifts = 0;

	mov	DWORD PTR _shifts$[ebp], 0
$LN1@umultiply:

; 981  : 					}
; 982  : 					
; 983  : 					add ( a0, a )
; 984  : 					
; 985  : 					;

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a0$[ebp]
	push	ecx
	call	??$add@$$BY07I@big@@YAXAAY07I0@Z	; big::add<unsigned int [8]>
	add	esp, 8
$LN2@umultiply:

; 986  : 				}
; 987  : 				
; 988  : 				w_i >>= 1;

	mov	eax, DWORD PTR _w_i$2[ebp]
	shr	eax, 1
	mov	DWORD PTR _w_i$2[ebp], eax

; 989  : 				++shifts;

	mov	eax, DWORD PTR _shifts$[ebp]
	add	eax, 1
	mov	DWORD PTR _shifts$[ebp], eax

; 990  : 				--ctr;

	mov	ax, WORD PTR _ctr$1[ebp]
	sub	ax, 1
	mov	WORD PTR _ctr$1[ebp], ax

; 991  : 			}

	jmp	SHORT $LN4@umultiply
$LN3@umultiply:

; 992  : 			
; 993  : 			shifts += ctr;

	movzx	eax, WORD PTR _ctr$1[ebp]
	add	eax, DWORD PTR _shifts$[ebp]
	mov	DWORD PTR _shifts$[ebp], eax

; 994  : 		}

	jmp	$LN6@umultiply
$LN8@umultiply:

; 995  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@umultiply
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 284				; 0000011cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@umultiply:
	DD	1
	DD	$LN11@umultiply
$LN11@umultiply:
	DD	-40					; ffffffd8H
	DD	32					; 00000020H
	DD	$LN10@umultiply
$LN10@umultiply:
	DB	97					; 00000061H
	DB	0
??$umultiply@$$BY07I$$BY07I@big@@YAXAAY07I0@Z ENDP	; big::umultiply<unsigned int [8],unsigned int [8]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$add@$$BY03I@big@@YAXAAY03I0@Z
_TEXT	SEGMENT
_qc1$ = -8						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$add@$$BY03I@big@@YAXAAY03I0@Z PROC			; big::add<unsigned int [4]>, COMDAT

; 658  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 659  : #if defined(NO_TEMPLATE_INLINE_ASSEMBLY) && defined(ASSEMBLY_INTEL_SYNTAX)
; 660  : 		const u32 qc1 = BIGWORDCOUNT( T ) / 4 - 1;
; 661  : 		
; 662  : 		BorlandAdd( a, b, qc1 );
; 663  : 		
; 664  : #elif defined(ASSEMBLY_INTEL_SYNTAX)
; 665  : 		
; 666  : 		const u32 qc1 = BIGWORDCOUNT( T ) / 4 - 1;

	mov	DWORD PTR _qc1$[ebp], 0

; 667  : 		
; 668  : 		ASSEMBLY_BLOCK // VS.NET, x86, 32-bit words
; 669  : 		{
; 670  : 		        mov esi, b

	mov	esi, DWORD PTR _b$[ebp]

; 671  : 		        mov edi, a

	mov	edi, DWORD PTR _a$[ebp]

; 672  : 		        mov ecx, qc1

	mov	ecx, DWORD PTR _qc1$[ebp]

; 673  : 		
; 674  : 		        // unrolled loop since word count is a multiple of 4 >= 4
; 675  : 		        mov eax, [ esi ]

	mov	eax, DWORD PTR [esi]

; 676  : 		        xor edx, edx  // edx used later to index later words >= 4

	xor	edx, edx

; 677  : 		
; 678  : 		        add [ edi ], eax  // and now we can use ADD instead of ADC on the first addition

	add	DWORD PTR [edi], eax

; 679  : 		        mov eax, [ esi + 4 ]

	mov	eax, DWORD PTR [esi+4]

; 680  : 		        adc [ edi + 4 ], eax

	adc	DWORD PTR [edi+4], eax

; 681  : 		        mov eax, [ esi + 8 ]

	mov	eax, DWORD PTR [esi+8]

; 682  : 		        adc [ edi + 8 ], eax

	adc	DWORD PTR [edi+8], eax

; 683  : 		        mov eax, [ esi + 12 ]

	mov	eax, DWORD PTR [esi+12]

; 684  : 		        adc [ edi + 12 ], eax

	adc	DWORD PTR [edi+12], eax

; 685  : 		
; 686  : 		        jecxz done_already

	jecxz	$done_already$3
$next_word$4:

; 687  : 		
; 688  : 	        next_word:
; 689  : 		        inc edx

	inc	edx

; 690  : 		        inc edx

	inc	edx

; 691  : 		
; 692  : 		        // unrolled loop since word count is a multiple of 4 >= 4
; 693  : 		        mov eax, [ esi + edx * 8 ]

	mov	eax, DWORD PTR [esi+edx*8]

; 694  : 		        adc [ edi + edx * 8 ], eax

	adc	DWORD PTR [edi+edx*8], eax

; 695  : 		        mov eax, [ esi + edx * 8 + 4 ]

	mov	eax, DWORD PTR [esi+edx*8+4]

; 696  : 		        adc [ edi + edx * 8 + 4 ], eax

	adc	DWORD PTR [edi+edx*8+4], eax

; 697  : 		        mov eax, [ esi + edx * 8 + 8 ]

	mov	eax, DWORD PTR [esi+edx*8+8]

; 698  : 		        adc [ edi + edx * 8 + 8 ], eax

	adc	DWORD PTR [edi+edx*8+8], eax

; 699  : 		        mov eax, [ esi + edx * 8 + 12 ]

	mov	eax, DWORD PTR [esi+edx*8+12]

; 700  : 		        adc [ edi + edx * 8 + 12 ], eax

	adc	DWORD PTR [edi+edx*8+12], eax

; 701  : 		
; 702  : 		        loop next_word

	loop	$next_word$4
$done_already$3:

; 703  : 		
; 704  : 	        done_already:
; 705  : 		}
; 706  : #else
; 707  : 		register word carry = 0;
; 708  : 		
; 709  : 		for ( u32 ii = 0; ii < BIGWORDCOUNT( T ); ++ii )
; 710  : 		{
; 711  : 			word a_i = a[ ii ];
; 712  : 			word b_i = b[ ii ];
; 713  : 			a[ ii ] += b_i + carry;
; 714  : 		
; 715  : 			carry = ( ( a_i & ( WORDALLBITS >> 1 ) ) + ( b_i & ( WORDALLBITS >> 1 ) ) + carry ) >> ( WORDBITS - 1 );
; 716  : 			carry += ( a_i >> ( WORDBITS - 1 ) ) + ( b_i >> ( WORDBITS - 1 ) );
; 717  : 			carry >>= 1;
; 718  : 		}
; 719  : 		
; 720  : #endif
; 721  : 		
; 722  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$add@$$BY03I@big@@YAXAAY03I0@Z ENDP			; big::add<unsigned int [4]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$subtract@$$BY03I@big@@YAXAAY03I0@Z
_TEXT	SEGMENT
_qc1$ = -8						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$subtract@$$BY03I@big@@YAXAAY03I0@Z PROC		; big::subtract<unsigned int [4]>, COMDAT

; 780  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 781  : #if defined(NO_TEMPLATE_INLINE_ASSEMBLY) && defined(ASSEMBLY_INTEL_SYNTAX)
; 782  : 		const u32 qc1 = BIGWORDCOUNT( T ) / 4 - 1;
; 783  : 		
; 784  : 		BorlandSubtract( a, b, qc1 );
; 785  : 		
; 786  : #elif defined(ASSEMBLY_INTEL_SYNTAX)
; 787  : 		
; 788  : 		const u32 qc1 = BIGWORDCOUNT( T ) / 4 - 1;

	mov	DWORD PTR _qc1$[ebp], 0

; 789  : 		
; 790  : 		ASSEMBLY_BLOCK // VS.NET, x86, 32-bit words
; 791  : 		{
; 792  : 		        mov esi, b

	mov	esi, DWORD PTR _b$[ebp]

; 793  : 		        mov edi, a

	mov	edi, DWORD PTR _a$[ebp]

; 794  : 		        mov ecx, qc1

	mov	ecx, DWORD PTR _qc1$[ebp]

; 795  : 		
; 796  : 		        // unrolled loop since word count is a multiple of 4 >= 4
; 797  : 		        mov eax, [ esi ]

	mov	eax, DWORD PTR [esi]

; 798  : 		        xor edx, edx  // edx used later to index later words >= 4

	xor	edx, edx

; 799  : 		        sub [ edi ], eax  // first subtraction doesn't need to borrow

	sub	DWORD PTR [edi], eax

; 800  : 		        mov eax, [ esi + 4 ]

	mov	eax, DWORD PTR [esi+4]

; 801  : 		        sbb [ edi + 4 ], eax

	sbb	DWORD PTR [edi+4], eax

; 802  : 		        mov eax, [ esi + 8 ]

	mov	eax, DWORD PTR [esi+8]

; 803  : 		        sbb [ edi + 8 ], eax

	sbb	DWORD PTR [edi+8], eax

; 804  : 		        mov eax, [ esi + 12 ]

	mov	eax, DWORD PTR [esi+12]

; 805  : 		        sbb [ edi + 12 ], eax

	sbb	DWORD PTR [edi+12], eax

; 806  : 		
; 807  : 		        jecxz done_already

	jecxz	$done_already$3
$next_word$4:

; 808  : 		
; 809  : 	        next_word:
; 810  : 		        inc edx

	inc	edx

; 811  : 		        inc edx

	inc	edx

; 812  : 		
; 813  : 		        // unrolled loop since word count is a multiple of 4 >= 4
; 814  : 		        mov eax, [ esi + edx * 8 ]

	mov	eax, DWORD PTR [esi+edx*8]

; 815  : 		        sbb [ edi + edx * 8 ], eax

	sbb	DWORD PTR [edi+edx*8], eax

; 816  : 		        mov eax, [ esi + edx * 8 + 4 ]

	mov	eax, DWORD PTR [esi+edx*8+4]

; 817  : 		        sbb [ edi + edx * 8 + 4 ], eax

	sbb	DWORD PTR [edi+edx*8+4], eax

; 818  : 		        mov eax, [ esi + edx * 8 + 8 ]

	mov	eax, DWORD PTR [esi+edx*8+8]

; 819  : 		        sbb [ edi + edx * 8 + 8 ], eax

	sbb	DWORD PTR [edi+edx*8+8], eax

; 820  : 		        mov eax, [ esi + edx * 8 + 12 ]

	mov	eax, DWORD PTR [esi+edx*8+12]

; 821  : 		        sbb [ edi + edx * 8 + 12 ], eax

	sbb	DWORD PTR [edi+edx*8+12], eax

; 822  : 		
; 823  : 		        loop next_word

	loop	$next_word$4
$done_already$3:

; 824  : 		
; 825  : 	        done_already:
; 826  : 		}
; 827  : #else
; 828  : 		register word borrow = 0;
; 829  : 		
; 830  : 		for ( u32 ii = 0; ii < BIGWORDCOUNT( T ); ++ii )
; 831  : 		{
; 832  : 			word a_i = a[ ii ];
; 833  : 			word b_i = b[ ii ];
; 834  : 			a[ ii ] -= b_i + borrow;
; 835  : 		
; 836  : 			borrow = ( ( a_i & ( WORDALLBITS >> 1 ) ) - ( b_i & ( WORDALLBITS >> 1 ) ) - borrow ) >> ( WORDBITS - 1 );
; 837  : 			borrow += ( b_i >> ( WORDBITS - 1 ) ) - ( a_i >> ( WORDBITS - 1 ) );
; 838  : 			++borrow;
; 839  : 			borrow >>= 1;
; 840  : 		}
; 841  : 		
; 842  : #endif
; 843  : 		
; 844  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$subtract@$$BY03I@big@@YAXAAY03I0@Z ENDP		; big::subtract<unsigned int [4]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rsacrypt.h
;	COMDAT ??$simpleModExp@$$BY03I@big@@YAXAAY03I000@Z
_TEXT	SEGMENT
_ctr$1 = -208						; size = 4
_y_i$2 = -196						; size = 4
_ii$3 = -184						; size = 4
_squares$ = -172					; size = 4
_r$ = -160						; size = 32
_n$ = -120						; size = 32
_y$ = -80						; size = 32
_x$ = -40						; size = 32
__$ArrayPad$ = -4					; size = 4
_x0$ = 8						; size = 4
_y0$ = 12						; size = 4
_n0$ = 16						; size = 4
_r0$ = 20						; size = 4
??$simpleModExp@$$BY03I@big@@YAXAAY03I000@Z PROC	; big::simpleModExp<unsigned int [4]>, COMDAT

; 53   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 404				; 00000194H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-404]
	mov	ecx, 101				; 00000065H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 54   : 		BIGDOUBLESIZE( T, x );
; 55   : 		BIGDOUBLESIZE( T, y );
; 56   : 		BIGDOUBLESIZE( T, n );
; 57   : 		BIGDOUBLESIZE( T, r );
; 58   : 
; 59   : 		usetlow( x, x0 );

	mov	eax, DWORD PTR _x0$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	??$usetlow@$$BY03I$$BY07I@big@@YAXAAY07IAAY03I@Z ; big::usetlow<unsigned int [4],unsigned int [8]>
	add	esp, 8

; 60   : 		usetlow( y, y0 );

	mov	eax, DWORD PTR _y0$[ebp]
	push	eax
	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	call	??$usetlow@$$BY03I$$BY07I@big@@YAXAAY07IAAY03I@Z ; big::usetlow<unsigned int [4],unsigned int [8]>
	add	esp, 8

; 61   : 		usetlow( n, n0 );

	mov	eax, DWORD PTR _n0$[ebp]
	push	eax
	lea	ecx, DWORD PTR _n$[ebp]
	push	ecx
	call	??$usetlow@$$BY03I$$BY07I@big@@YAXAAY07IAAY03I@Z ; big::usetlow<unsigned int [4],unsigned int [8]>
	add	esp, 8

; 62   : 		usetw( r, 1 );

	push	1
	lea	eax, DWORD PTR _r$[ebp]
	push	eax
	call	??$usetw@$$BY07I@big@@YAXAAY07II@Z	; big::usetw<unsigned int [8]>
	add	esp, 8

; 63   : 
; 64   : 		umodulo( x, n, x );

	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	lea	ecx, DWORD PTR _n$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	call	??$umodulo@$$BY07I@big@@YAXAAY07I00@Z	; big::umodulo<unsigned int [8]>
	add	esp, 12					; 0000000cH

; 65   : 
; 66   : 		u32 squares = 0;

	mov	DWORD PTR _squares$[ebp], 0

; 67   : 
; 68   : 		for ( u32 ii = 0; ii < BIGWORDCOUNT( T ); ++ii )

	mov	DWORD PTR _ii$3[ebp], 0
	jmp	SHORT $LN10@simpleModE
$LN9@simpleModE:
	mov	eax, DWORD PTR _ii$3[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$3[ebp], eax
$LN10@simpleModE:
	cmp	DWORD PTR _ii$3[ebp], 4
	jae	$LN8@simpleModE

; 69   : 		{
; 70   : 			word y_i = y[ ii ];

	mov	eax, DWORD PTR _ii$3[ebp]
	mov	ecx, DWORD PTR _y$[ebp+eax*4]
	mov	DWORD PTR _y_i$2[ebp], ecx

; 71   : 
; 72   : 			u32 ctr = WORDBITS;

	mov	DWORD PTR _ctr$1[ebp], 32		; 00000020H
$LN7@simpleModE:

; 73   : 
; 74   : 			while ( y_i )

	cmp	DWORD PTR _y_i$2[ebp], 0
	je	$LN6@simpleModE

; 75   : 			{
; 76   : 				if ( y_i & 1 )

	mov	eax, DWORD PTR _y_i$2[ebp]
	and	eax, 1
	je	SHORT $LN5@simpleModE

; 77   : 				{
; 78   : 					if ( squares )

	cmp	DWORD PTR _squares$[ebp], 0
	je	SHORT $LN4@simpleModE
$LN3@simpleModE:

; 79   : 						do
; 80   : 						{
; 81   : 							usquare( x );

	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	call	??$usquare@$$BY07I@big@@YAXAAY07I@Z	; big::usquare<unsigned int [8]>
	add	esp, 4

; 82   : 							umodulo( x, n, x );

	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	lea	ecx, DWORD PTR _n$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	call	??$umodulo@$$BY07I@big@@YAXAAY07I00@Z	; big::umodulo<unsigned int [8]>
	add	esp, 12					; 0000000cH

; 83   : 						}
; 84   : 
; 85   : 						while ( --squares );

	mov	eax, DWORD PTR _squares$[ebp]
	sub	eax, 1
	mov	DWORD PTR _squares$[ebp], eax
	jne	SHORT $LN3@simpleModE
$LN4@simpleModE:

; 86   : 
; 87   : 						umultiply( r, x, r );

	lea	eax, DWORD PTR _r$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	lea	edx, DWORD PTR _r$[ebp]
	push	edx
	call	??$umultiply@$$BY07I$$BY07I@big@@YAXAAY07I00@Z ; big::umultiply<unsigned int [8],unsigned int [8]>
	add	esp, 12					; 0000000cH

; 88   : 
; 89   : 						umodulo( r, n, r );

	lea	eax, DWORD PTR _r$[ebp]
	push	eax
	lea	ecx, DWORD PTR _n$[ebp]
	push	ecx
	lea	edx, DWORD PTR _r$[ebp]
	push	edx
	call	??$umodulo@$$BY07I@big@@YAXAAY07I00@Z	; big::umodulo<unsigned int [8]>
	add	esp, 12					; 0000000cH
$LN5@simpleModE:

; 90   : 				}
; 91   : 
; 92   : 				y_i >>= 1;

	mov	eax, DWORD PTR _y_i$2[ebp]
	shr	eax, 1
	mov	DWORD PTR _y_i$2[ebp], eax

; 93   : 				++squares;

	mov	eax, DWORD PTR _squares$[ebp]
	add	eax, 1
	mov	DWORD PTR _squares$[ebp], eax

; 94   : 				--ctr;

	mov	eax, DWORD PTR _ctr$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _ctr$1[ebp], eax

; 95   : 			}

	jmp	$LN7@simpleModE
$LN6@simpleModE:

; 96   : 
; 97   : 			squares += ctr;

	mov	eax, DWORD PTR _squares$[ebp]
	add	eax, DWORD PTR _ctr$1[ebp]
	mov	DWORD PTR _squares$[ebp], eax

; 98   : 		}

	jmp	$LN9@simpleModE
$LN8@simpleModE:

; 99   : 
; 100  : 		takelow( r0, r );

	lea	eax, DWORD PTR _r$[ebp]
	push	eax
	mov	ecx, DWORD PTR _r0$[ebp]
	push	ecx
	call	??$takelow@$$BY03I$$BY07I@big@@YAXAAY03IAAY07I@Z ; big::takelow<unsigned int [4],unsigned int [8]>
	add	esp, 8

; 101  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN18@simpleModE
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 404				; 00000194H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN18@simpleModE:
	DD	4
	DD	$LN17@simpleModE
$LN17@simpleModE:
	DD	-40					; ffffffd8H
	DD	32					; 00000020H
	DD	$LN13@simpleModE
	DD	-80					; ffffffb0H
	DD	32					; 00000020H
	DD	$LN14@simpleModE
	DD	-120					; ffffff88H
	DD	32					; 00000020H
	DD	$LN15@simpleModE
	DD	-160					; ffffff60H
	DD	32					; 00000020H
	DD	$LN16@simpleModE
$LN16@simpleModE:
	DB	114					; 00000072H
	DB	0
$LN15@simpleModE:
	DB	110					; 0000006eH
	DB	0
$LN14@simpleModE:
	DB	121					; 00000079H
	DB	0
$LN13@simpleModE:
	DB	120					; 00000078H
	DB	0
??$simpleModExp@$$BY03I@big@@YAXAAY03I000@Z ENDP	; big::simpleModExp<unsigned int [4]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$takelow@$$BY03I$$BY07I@big@@YAXAAY03IAAY07I@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$takelow@$$BY03I$$BY07I@big@@YAXAAY03IAAY07I@Z PROC	; big::takelow<unsigned int [4],unsigned int [8]>, COMDAT

; 338  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 339  : 		memcpy( a, b, sizeof( T ) );

	push	16					; 00000010H
	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 340  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$takelow@$$BY03I$$BY07I@big@@YAXAAY03IAAY07I@Z ENDP	; big::takelow<unsigned int [4],unsigned int [8]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$umodulo@$$BY07I@big@@YAXAAY07I00@Z
_TEXT	SEGMENT
tv151 = -276						; size = 4
_jj$1 = -76						; size = 4
_ii$2 = -64						; size = 4
_shifts$ = -52						; size = 4
_b$ = -40						; size = 32
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_b0$ = 12						; size = 4
_r$ = 16						; size = 4
??$umodulo@$$BY07I@big@@YAXAAY07I00@Z PROC		; big::umodulo<unsigned int [8]>, COMDAT

; 1250 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-276]
	mov	ecx, 69					; 00000045H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1251 : 		T b;
; 1252 : 		u32 shifts = 1;

	mov	DWORD PTR _shifts$[ebp], 1

; 1253 : 		
; 1254 : 		set ( b, b0 )
; 1255 : 		
; 1256 : 		;

	mov	eax, DWORD PTR _b0$[ebp]
	push	eax
	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	call	??$set@$$BY07I@big@@YAXAAY07I0@Z	; big::set<unsigned int [8]>
	add	esp, 8

; 1257 : 		set ( r, a )
; 1258 : 		
; 1259 : 		;

	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	call	??$set@$$BY07I@big@@YAXAAY07I0@Z	; big::set<unsigned int [8]>
	add	esp, 8

; 1260 : 		
; 1261 : 		if ( !BIGHIGHBIT( b ) && ugreater( r, b ) )

	mov	eax, 4
	imul	ecx, eax, 7
	mov	edx, DWORD PTR _b$[ebp+ecx]
	and	edx, -2147483648			; 80000000H
	jne	$LN19@umodulo
	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	call	??$ugreater@$$BY07I@big@@YA_NAAY07I0@Z	; big::ugreater<unsigned int [8]>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	$LN19@umodulo

; 1262 : 		{
; 1263 : 			s32 ii, jj;
; 1264 : 			
; 1265 : 			// shift by words if possible
; 1266 : 			
; 1267 : 			for ( ii = BIGWORDCOUNT( T ) - 1; ii >= 0; --ii )

	mov	DWORD PTR _ii$2[ebp], 7
	jmp	SHORT $LN18@umodulo
$LN17@umodulo:
	mov	eax, DWORD PTR _ii$2[ebp]
	sub	eax, 1
	mov	DWORD PTR _ii$2[ebp], eax
$LN18@umodulo:
	cmp	DWORD PTR _ii$2[ebp], 0
	jl	SHORT $LN16@umodulo

; 1268 : 				if ( r[ ii ] )

	mov	eax, DWORD PTR _ii$2[ebp]
	mov	ecx, DWORD PTR _r$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $LN15@umodulo

; 1269 : 					break;

	jmp	SHORT $LN16@umodulo
$LN15@umodulo:

; 1270 : 					
; 1271 : 			for ( jj = ii; jj >= 0; --jj )

	jmp	SHORT $LN17@umodulo
$LN16@umodulo:
	mov	eax, DWORD PTR _ii$2[ebp]
	mov	DWORD PTR _jj$1[ebp], eax
	jmp	SHORT $LN14@umodulo
$LN13@umodulo:
	mov	eax, DWORD PTR _jj$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _jj$1[ebp], eax
$LN14@umodulo:
	cmp	DWORD PTR _jj$1[ebp], 0
	jl	SHORT $LN12@umodulo

; 1272 : 				if ( b[ jj ] )

	mov	eax, DWORD PTR _jj$1[ebp]
	cmp	DWORD PTR _b$[ebp+eax*4], 0
	je	SHORT $LN11@umodulo

; 1273 : 					break;

	jmp	SHORT $LN12@umodulo
$LN11@umodulo:

; 1274 : 					
; 1275 : 			if ( ii != jj )

	jmp	SHORT $LN13@umodulo
$LN12@umodulo:
	mov	eax, DWORD PTR _ii$2[ebp]
	cmp	eax, DWORD PTR _jj$1[ebp]
	je	SHORT $LN9@umodulo

; 1276 : 			{
; 1277 : 				shifts = ( ii - jj ) * WORDBITS;

	mov	eax, DWORD PTR _ii$2[ebp]
	sub	eax, DWORD PTR _jj$1[ebp]
	shl	eax, 5
	mov	DWORD PTR _shifts$[ebp], eax

; 1278 : 				shiftLeft( b, shifts );

	mov	eax, DWORD PTR _shifts$[ebp]
	push	eax
	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	call	??$shiftLeft@$$BY07I@big@@YAXAAY07II@Z	; big::shiftLeft<unsigned int [8]>
	add	esp, 8

; 1279 : 				++shifts;

	mov	eax, DWORD PTR _shifts$[ebp]
	add	eax, 1
	mov	DWORD PTR _shifts$[ebp], eax
$LN9@umodulo:

; 1280 : 			}
; 1281 : 			
; 1282 : 			while ( !BIGHIGHBIT( b ) && ugreater( r, b ) )

	mov	eax, 4
	imul	ecx, eax, 7
	mov	edx, DWORD PTR _b$[ebp+ecx]
	and	edx, -2147483648			; 80000000H
	jne	SHORT $LN7@umodulo
	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	call	??$ugreater@$$BY07I@big@@YA_NAAY07I0@Z	; big::ugreater<unsigned int [8]>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN7@umodulo

; 1283 : 			{
; 1284 : 				shiftLeft1( b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$shiftLeft1@$$BY07I@big@@YAXAAY07I@Z	; big::shiftLeft1<unsigned int [8]>
	add	esp, 4

; 1285 : 				
; 1286 : 				++shifts;

	mov	eax, DWORD PTR _shifts$[ebp]
	add	eax, 1
	mov	DWORD PTR _shifts$[ebp], eax

; 1287 : 			}

	jmp	SHORT $LN9@umodulo
$LN7@umodulo:

; 1288 : 			
; 1289 : 			while ( ugreater( b, r ) )

	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	call	??$ugreater@$$BY07I@big@@YA_NAAY07I0@Z	; big::ugreater<unsigned int [8]>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN6@umodulo

; 1290 : 			{
; 1291 : 				ushiftRight1( b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$ushiftRight1@$$BY07I@big@@YAXAAY07I@Z ; big::ushiftRight1<unsigned int [8]>
	add	esp, 4

; 1292 : 				
; 1293 : 				--shifts;

	mov	eax, DWORD PTR _shifts$[ebp]
	sub	eax, 1
	mov	DWORD PTR _shifts$[ebp], eax

; 1294 : 			}

	jmp	SHORT $LN7@umodulo
$LN6@umodulo:

; 1295 : 		}
; 1296 : 		
; 1297 : 		else

	jmp	SHORT $LN3@umodulo
$LN19@umodulo:

; 1298 : 			if ( ugreater( b, r ) )

	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	call	??$ugreater@$$BY07I@big@@YA_NAAY07I0@Z	; big::ugreater<unsigned int [8]>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@umodulo

; 1299 : 			{
; 1300 : 				ushiftRight1( b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$ushiftRight1@$$BY07I@big@@YAXAAY07I@Z ; big::ushiftRight1<unsigned int [8]>
	add	esp, 4

; 1301 : 				
; 1302 : 				--shifts;

	mov	eax, DWORD PTR _shifts$[ebp]
	sub	eax, 1
	mov	DWORD PTR _shifts$[ebp], eax
$LN3@umodulo:

; 1303 : 			}
; 1304 : 			
; 1305 : 		while ( shifts-- )

	mov	eax, DWORD PTR _shifts$[ebp]
	mov	DWORD PTR tv151[ebp], eax
	mov	ecx, DWORD PTR _shifts$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _shifts$[ebp], ecx
	cmp	DWORD PTR tv151[ebp], 0
	je	SHORT $LN20@umodulo

; 1306 : 		{
; 1307 : 			if ( !ugreater( b, r ) )

	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	call	??$ugreater@$$BY07I@big@@YA_NAAY07I0@Z	; big::ugreater<unsigned int [8]>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN1@umodulo

; 1308 : 				subtract( r, b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	call	??$subtract@$$BY07I@big@@YAXAAY07I0@Z	; big::subtract<unsigned int [8]>
	add	esp, 8
$LN1@umodulo:

; 1309 : 				
; 1310 : 			ushiftRight1( b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$ushiftRight1@$$BY07I@big@@YAXAAY07I@Z ; big::ushiftRight1<unsigned int [8]>
	add	esp, 4

; 1311 : 		}

	jmp	SHORT $LN3@umodulo
$LN20@umodulo:

; 1312 : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN24@umodulo
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN24@umodulo:
	DD	1
	DD	$LN23@umodulo
$LN23@umodulo:
	DD	-40					; ffffffd8H
	DD	32					; 00000020H
	DD	$LN22@umodulo
$LN22@umodulo:
	DB	98					; 00000062H
	DB	0
??$umodulo@$$BY07I@big@@YAXAAY07I00@Z ENDP		; big::umodulo<unsigned int [8]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$decrement@$$BY07I@big@@YAXAAY07I@Z
_TEXT	SEGMENT
tv73 = -208						; size = 4
_ii$1 = -8						; size = 4
_n$ = 8							; size = 4
??$decrement@$$BY07I@big@@YAXAAY07I@Z PROC		; big::decrement<unsigned int [8]>, COMDAT

; 848  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 849  : 		for ( u32 ii = 0; ii < BIGWORDCOUNT( T ); ++ii )

	mov	DWORD PTR _ii$1[ebp], 0
	jmp	SHORT $LN4@decrement
$LN3@decrement:
	mov	eax, DWORD PTR _ii$1[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$1[ebp], eax
$LN4@decrement:
	cmp	DWORD PTR _ii$1[ebp], 8
	jae	SHORT $LN5@decrement

; 850  : 			if ( n[ ii ] -- )

	mov	eax, DWORD PTR _ii$1[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv73[ebp], edx
	mov	eax, DWORD PTR _ii$1[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	sub	edx, 1
	mov	eax, DWORD PTR _ii$1[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx
	cmp	DWORD PTR tv73[ebp], 0
	je	SHORT $LN1@decrement

; 851  : 				break;

	jmp	SHORT $LN5@decrement
$LN1@decrement:

; 852  : 	}

	jmp	SHORT $LN3@decrement
$LN5@decrement:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$decrement@$$BY07I@big@@YAXAAY07I@Z ENDP		; big::decrement<unsigned int [8]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$usetlow@$$BY03I$$BY07I@big@@YAXAAY07IAAY03I@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$usetlow@$$BY03I$$BY07I@big@@YAXAAY07IAAY03I@Z PROC	; big::usetlow<unsigned int [4],unsigned int [8]>, COMDAT

; 314  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 315  : 		memcpy( a, b, sizeof( T ) );

	push	16					; 00000010H
	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 316  : #ifdef _MSC_VER
; 317  : #pragma warning( disable : 4318 ) // warning C4318: passing constant zero as the length to memset
; 318  : #endif
; 319  : 		memset( a + BIGWORDCOUNT( T ), 0, sizeof( Bigger ) - sizeof( T ) );

	push	16					; 00000010H
	push	0
	mov	eax, DWORD PTR _a$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 320  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$usetlow@$$BY03I$$BY07I@big@@YAXAAY07IAAY03I@Z ENDP	; big::usetlow<unsigned int [4],unsigned int [8]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$umodulo@$$BY0BA@I@big@@YAXAAY0BA@I00@Z
_TEXT	SEGMENT
tv151 = -308						; size = 4
_jj$1 = -108						; size = 4
_ii$2 = -96						; size = 4
_shifts$ = -84						; size = 4
_b$ = -72						; size = 64
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_b0$ = 12						; size = 4
_r$ = 16						; size = 4
??$umodulo@$$BY0BA@I@big@@YAXAAY0BA@I00@Z PROC		; big::umodulo<unsigned int [16]>, COMDAT

; 1250 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 308				; 00000134H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-308]
	mov	ecx, 77					; 0000004dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1251 : 		T b;
; 1252 : 		u32 shifts = 1;

	mov	DWORD PTR _shifts$[ebp], 1

; 1253 : 		
; 1254 : 		set ( b, b0 )
; 1255 : 		
; 1256 : 		;

	mov	eax, DWORD PTR _b0$[ebp]
	push	eax
	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	call	??$set@$$BY0BA@I@big@@YAXAAY0BA@I0@Z	; big::set<unsigned int [16]>
	add	esp, 8

; 1257 : 		set ( r, a )
; 1258 : 		
; 1259 : 		;

	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	call	??$set@$$BY0BA@I@big@@YAXAAY0BA@I0@Z	; big::set<unsigned int [16]>
	add	esp, 8

; 1260 : 		
; 1261 : 		if ( !BIGHIGHBIT( b ) && ugreater( r, b ) )

	mov	eax, 4
	imul	ecx, eax, 15
	mov	edx, DWORD PTR _b$[ebp+ecx]
	and	edx, -2147483648			; 80000000H
	jne	$LN19@umodulo
	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	call	??$ugreater@$$BY0BA@I@big@@YA_NAAY0BA@I0@Z ; big::ugreater<unsigned int [16]>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	$LN19@umodulo

; 1262 : 		{
; 1263 : 			s32 ii, jj;
; 1264 : 			
; 1265 : 			// shift by words if possible
; 1266 : 			
; 1267 : 			for ( ii = BIGWORDCOUNT( T ) - 1; ii >= 0; --ii )

	mov	DWORD PTR _ii$2[ebp], 15		; 0000000fH
	jmp	SHORT $LN18@umodulo
$LN17@umodulo:
	mov	eax, DWORD PTR _ii$2[ebp]
	sub	eax, 1
	mov	DWORD PTR _ii$2[ebp], eax
$LN18@umodulo:
	cmp	DWORD PTR _ii$2[ebp], 0
	jl	SHORT $LN16@umodulo

; 1268 : 				if ( r[ ii ] )

	mov	eax, DWORD PTR _ii$2[ebp]
	mov	ecx, DWORD PTR _r$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $LN15@umodulo

; 1269 : 					break;

	jmp	SHORT $LN16@umodulo
$LN15@umodulo:

; 1270 : 					
; 1271 : 			for ( jj = ii; jj >= 0; --jj )

	jmp	SHORT $LN17@umodulo
$LN16@umodulo:
	mov	eax, DWORD PTR _ii$2[ebp]
	mov	DWORD PTR _jj$1[ebp], eax
	jmp	SHORT $LN14@umodulo
$LN13@umodulo:
	mov	eax, DWORD PTR _jj$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _jj$1[ebp], eax
$LN14@umodulo:
	cmp	DWORD PTR _jj$1[ebp], 0
	jl	SHORT $LN12@umodulo

; 1272 : 				if ( b[ jj ] )

	mov	eax, DWORD PTR _jj$1[ebp]
	cmp	DWORD PTR _b$[ebp+eax*4], 0
	je	SHORT $LN11@umodulo

; 1273 : 					break;

	jmp	SHORT $LN12@umodulo
$LN11@umodulo:

; 1274 : 					
; 1275 : 			if ( ii != jj )

	jmp	SHORT $LN13@umodulo
$LN12@umodulo:
	mov	eax, DWORD PTR _ii$2[ebp]
	cmp	eax, DWORD PTR _jj$1[ebp]
	je	SHORT $LN9@umodulo

; 1276 : 			{
; 1277 : 				shifts = ( ii - jj ) * WORDBITS;

	mov	eax, DWORD PTR _ii$2[ebp]
	sub	eax, DWORD PTR _jj$1[ebp]
	shl	eax, 5
	mov	DWORD PTR _shifts$[ebp], eax

; 1278 : 				shiftLeft( b, shifts );

	mov	eax, DWORD PTR _shifts$[ebp]
	push	eax
	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	call	??$shiftLeft@$$BY0BA@I@big@@YAXAAY0BA@II@Z ; big::shiftLeft<unsigned int [16]>
	add	esp, 8

; 1279 : 				++shifts;

	mov	eax, DWORD PTR _shifts$[ebp]
	add	eax, 1
	mov	DWORD PTR _shifts$[ebp], eax
$LN9@umodulo:

; 1280 : 			}
; 1281 : 			
; 1282 : 			while ( !BIGHIGHBIT( b ) && ugreater( r, b ) )

	mov	eax, 4
	imul	ecx, eax, 15
	mov	edx, DWORD PTR _b$[ebp+ecx]
	and	edx, -2147483648			; 80000000H
	jne	SHORT $LN7@umodulo
	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	call	??$ugreater@$$BY0BA@I@big@@YA_NAAY0BA@I0@Z ; big::ugreater<unsigned int [16]>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN7@umodulo

; 1283 : 			{
; 1284 : 				shiftLeft1( b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$shiftLeft1@$$BY0BA@I@big@@YAXAAY0BA@I@Z ; big::shiftLeft1<unsigned int [16]>
	add	esp, 4

; 1285 : 				
; 1286 : 				++shifts;

	mov	eax, DWORD PTR _shifts$[ebp]
	add	eax, 1
	mov	DWORD PTR _shifts$[ebp], eax

; 1287 : 			}

	jmp	SHORT $LN9@umodulo
$LN7@umodulo:

; 1288 : 			
; 1289 : 			while ( ugreater( b, r ) )

	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	call	??$ugreater@$$BY0BA@I@big@@YA_NAAY0BA@I0@Z ; big::ugreater<unsigned int [16]>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN6@umodulo

; 1290 : 			{
; 1291 : 				ushiftRight1( b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$ushiftRight1@$$BY0BA@I@big@@YAXAAY0BA@I@Z ; big::ushiftRight1<unsigned int [16]>
	add	esp, 4

; 1292 : 				
; 1293 : 				--shifts;

	mov	eax, DWORD PTR _shifts$[ebp]
	sub	eax, 1
	mov	DWORD PTR _shifts$[ebp], eax

; 1294 : 			}

	jmp	SHORT $LN7@umodulo
$LN6@umodulo:

; 1295 : 		}
; 1296 : 		
; 1297 : 		else

	jmp	SHORT $LN3@umodulo
$LN19@umodulo:

; 1298 : 			if ( ugreater( b, r ) )

	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	call	??$ugreater@$$BY0BA@I@big@@YA_NAAY0BA@I0@Z ; big::ugreater<unsigned int [16]>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@umodulo

; 1299 : 			{
; 1300 : 				ushiftRight1( b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$ushiftRight1@$$BY0BA@I@big@@YAXAAY0BA@I@Z ; big::ushiftRight1<unsigned int [16]>
	add	esp, 4

; 1301 : 				
; 1302 : 				--shifts;

	mov	eax, DWORD PTR _shifts$[ebp]
	sub	eax, 1
	mov	DWORD PTR _shifts$[ebp], eax
$LN3@umodulo:

; 1303 : 			}
; 1304 : 			
; 1305 : 		while ( shifts-- )

	mov	eax, DWORD PTR _shifts$[ebp]
	mov	DWORD PTR tv151[ebp], eax
	mov	ecx, DWORD PTR _shifts$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _shifts$[ebp], ecx
	cmp	DWORD PTR tv151[ebp], 0
	je	SHORT $LN20@umodulo

; 1306 : 		{
; 1307 : 			if ( !ugreater( b, r ) )

	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	call	??$ugreater@$$BY0BA@I@big@@YA_NAAY0BA@I0@Z ; big::ugreater<unsigned int [16]>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN1@umodulo

; 1308 : 				subtract( r, b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	call	??$subtract@$$BY0BA@I@big@@YAXAAY0BA@I0@Z ; big::subtract<unsigned int [16]>
	add	esp, 8
$LN1@umodulo:

; 1309 : 				
; 1310 : 			ushiftRight1( b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$ushiftRight1@$$BY0BA@I@big@@YAXAAY0BA@I@Z ; big::ushiftRight1<unsigned int [16]>
	add	esp, 4

; 1311 : 		}

	jmp	SHORT $LN3@umodulo
$LN20@umodulo:

; 1312 : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN24@umodulo
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 308				; 00000134H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN24@umodulo:
	DD	1
	DD	$LN23@umodulo
$LN23@umodulo:
	DD	-72					; ffffffb8H
	DD	64					; 00000040H
	DD	$LN22@umodulo
$LN22@umodulo:
	DB	98					; 00000062H
	DB	0
??$umodulo@$$BY0BA@I@big@@YAXAAY0BA@I00@Z ENDP		; big::umodulo<unsigned int [16]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$takelow@$$BY07I$$BY0BA@I@big@@YAXAAY07IAAY0BA@I@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$takelow@$$BY07I$$BY0BA@I@big@@YAXAAY07IAAY0BA@I@Z PROC ; big::takelow<unsigned int [8],unsigned int [16]>, COMDAT

; 338  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 339  : 		memcpy( a, b, sizeof( T ) );

	push	32					; 00000020H
	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 340  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$takelow@$$BY07I$$BY0BA@I@big@@YAXAAY07IAAY0BA@I@Z ENDP ; big::takelow<unsigned int [8],unsigned int [16]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$udivide@$$BY0BA@I@big@@YAXAAY0BA@I000@Z
_TEXT	SEGMENT
tv152 = -320						; size = 4
_qshifts$ = -120					; size = 4
_jj$1 = -108						; size = 4
_ii$2 = -96						; size = 4
_shifts$ = -84						; size = 4
_b$ = -72						; size = 64
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_b0$ = 12						; size = 4
_q$ = 16						; size = 4
_r$ = 20						; size = 4
??$udivide@$$BY0BA@I@big@@YAXAAY0BA@I000@Z PROC		; big::udivide<unsigned int [16]>, COMDAT

; 1168 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 320				; 00000140H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-320]
	mov	ecx, 80					; 00000050H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1169 : 		T b;
; 1170 : 		
; 1171 : 		set ( b, b0 )
; 1172 : 		
; 1173 : 		;

	mov	eax, DWORD PTR _b0$[ebp]
	push	eax
	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	call	??$set@$$BY0BA@I@big@@YAXAAY0BA@I0@Z	; big::set<unsigned int [16]>
	add	esp, 8

; 1174 : 		set ( r, a )
; 1175 : 		
; 1176 : 		;

	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	call	??$set@$$BY0BA@I@big@@YAXAAY0BA@I0@Z	; big::set<unsigned int [16]>
	add	esp, 8

; 1177 : 		zero( q );

	mov	eax, DWORD PTR _q$[ebp]
	push	eax
	call	??$zero@$$BY0BA@I@big@@YAXAAY0BA@I@Z	; big::zero<unsigned int [16]>
	add	esp, 4

; 1178 : 		
; 1179 : 		u32 shifts = 1;

	mov	DWORD PTR _shifts$[ebp], 1

; 1180 : 		
; 1181 : 		// sort of: shift b left until b > r, then shift back one
; 1182 : 		if ( !BIGHIGHBIT( b ) && ugreater( r, b ) )

	mov	eax, 4
	imul	ecx, eax, 15
	mov	edx, DWORD PTR _b$[ebp+ecx]
	and	edx, -2147483648			; 80000000H
	jne	$LN19@udivide
	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	call	??$ugreater@$$BY0BA@I@big@@YA_NAAY0BA@I0@Z ; big::ugreater<unsigned int [16]>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	$LN19@udivide

; 1183 : 		{
; 1184 : 			s32 ii, jj;
; 1185 : 			
; 1186 : 			// shift by words if possible
; 1187 : 			
; 1188 : 			for ( ii = BIGWORDCOUNT( T ) - 1; ii >= 0; --ii )

	mov	DWORD PTR _ii$2[ebp], 15		; 0000000fH
	jmp	SHORT $LN18@udivide
$LN17@udivide:
	mov	eax, DWORD PTR _ii$2[ebp]
	sub	eax, 1
	mov	DWORD PTR _ii$2[ebp], eax
$LN18@udivide:
	cmp	DWORD PTR _ii$2[ebp], 0
	jl	SHORT $LN16@udivide

; 1189 : 				if ( r[ ii ] )

	mov	eax, DWORD PTR _ii$2[ebp]
	mov	ecx, DWORD PTR _r$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $LN15@udivide

; 1190 : 					break;

	jmp	SHORT $LN16@udivide
$LN15@udivide:

; 1191 : 					
; 1192 : 			for ( jj = ii; jj >= 0; --jj )

	jmp	SHORT $LN17@udivide
$LN16@udivide:
	mov	eax, DWORD PTR _ii$2[ebp]
	mov	DWORD PTR _jj$1[ebp], eax
	jmp	SHORT $LN14@udivide
$LN13@udivide:
	mov	eax, DWORD PTR _jj$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _jj$1[ebp], eax
$LN14@udivide:
	cmp	DWORD PTR _jj$1[ebp], 0
	jl	SHORT $LN12@udivide

; 1193 : 				if ( b[ jj ] )

	mov	eax, DWORD PTR _jj$1[ebp]
	cmp	DWORD PTR _b$[ebp+eax*4], 0
	je	SHORT $LN11@udivide

; 1194 : 					break;

	jmp	SHORT $LN12@udivide
$LN11@udivide:

; 1195 : 					
; 1196 : 			if ( ii != jj )

	jmp	SHORT $LN13@udivide
$LN12@udivide:
	mov	eax, DWORD PTR _ii$2[ebp]
	cmp	eax, DWORD PTR _jj$1[ebp]
	je	SHORT $LN9@udivide

; 1197 : 			{
; 1198 : 				shifts = ( ii - jj ) * WORDBITS;

	mov	eax, DWORD PTR _ii$2[ebp]
	sub	eax, DWORD PTR _jj$1[ebp]
	shl	eax, 5
	mov	DWORD PTR _shifts$[ebp], eax

; 1199 : 				shiftLeft( b, shifts );

	mov	eax, DWORD PTR _shifts$[ebp]
	push	eax
	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	call	??$shiftLeft@$$BY0BA@I@big@@YAXAAY0BA@II@Z ; big::shiftLeft<unsigned int [16]>
	add	esp, 8

; 1200 : 				++shifts;

	mov	eax, DWORD PTR _shifts$[ebp]
	add	eax, 1
	mov	DWORD PTR _shifts$[ebp], eax
$LN9@udivide:

; 1201 : 			}
; 1202 : 			
; 1203 : 			while ( !BIGHIGHBIT( b ) && ugreater( r, b ) )

	mov	eax, 4
	imul	ecx, eax, 15
	mov	edx, DWORD PTR _b$[ebp+ecx]
	and	edx, -2147483648			; 80000000H
	jne	SHORT $LN7@udivide
	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	call	??$ugreater@$$BY0BA@I@big@@YA_NAAY0BA@I0@Z ; big::ugreater<unsigned int [16]>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN7@udivide

; 1204 : 			{
; 1205 : 				shiftLeft1( b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$shiftLeft1@$$BY0BA@I@big@@YAXAAY0BA@I@Z ; big::shiftLeft1<unsigned int [16]>
	add	esp, 4

; 1206 : 				
; 1207 : 				++shifts;

	mov	eax, DWORD PTR _shifts$[ebp]
	add	eax, 1
	mov	DWORD PTR _shifts$[ebp], eax

; 1208 : 			}

	jmp	SHORT $LN9@udivide
$LN7@udivide:

; 1209 : 			
; 1210 : 			while ( ugreater( b, r ) )

	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	call	??$ugreater@$$BY0BA@I@big@@YA_NAAY0BA@I0@Z ; big::ugreater<unsigned int [16]>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN6@udivide

; 1211 : 			{
; 1212 : 				ushiftRight1( b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$ushiftRight1@$$BY0BA@I@big@@YAXAAY0BA@I@Z ; big::ushiftRight1<unsigned int [16]>
	add	esp, 4

; 1213 : 				
; 1214 : 				--shifts;

	mov	eax, DWORD PTR _shifts$[ebp]
	sub	eax, 1
	mov	DWORD PTR _shifts$[ebp], eax

; 1215 : 			}

	jmp	SHORT $LN7@udivide
$LN6@udivide:

; 1216 : 		}
; 1217 : 		
; 1218 : 		else

	jmp	SHORT $LN5@udivide
$LN19@udivide:

; 1219 : 			if ( ugreater( b, r ) )

	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	call	??$ugreater@$$BY0BA@I@big@@YA_NAAY0BA@I0@Z ; big::ugreater<unsigned int [16]>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN5@udivide

; 1220 : 			{
; 1221 : 				ushiftRight1( b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$ushiftRight1@$$BY0BA@I@big@@YAXAAY0BA@I@Z ; big::ushiftRight1<unsigned int [16]>
	add	esp, 4

; 1222 : 				
; 1223 : 				--shifts;

	mov	eax, DWORD PTR _shifts$[ebp]
	sub	eax, 1
	mov	DWORD PTR _shifts$[ebp], eax
$LN5@udivide:

; 1224 : 			}
; 1225 : 			
; 1226 : 		u32 qshifts = 0;

	mov	DWORD PTR _qshifts$[ebp], 0
$LN3@udivide:

; 1227 : 		
; 1228 : 		while ( shifts-- )

	mov	eax, DWORD PTR _shifts$[ebp]
	mov	DWORD PTR tv152[ebp], eax
	mov	ecx, DWORD PTR _shifts$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _shifts$[ebp], ecx
	cmp	DWORD PTR tv152[ebp], 0
	je	SHORT $LN2@udivide

; 1229 : 		{
; 1230 : 			++qshifts;

	mov	eax, DWORD PTR _qshifts$[ebp]
	add	eax, 1
	mov	DWORD PTR _qshifts$[ebp], eax

; 1231 : 			
; 1232 : 			if ( !ugreater( b, r ) )

	mov	eax, DWORD PTR _r$[ebp]
	push	eax
	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	call	??$ugreater@$$BY0BA@I@big@@YA_NAAY0BA@I0@Z ; big::ugreater<unsigned int [16]>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN1@udivide

; 1233 : 			{
; 1234 : 				subtract( r, b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _r$[ebp]
	push	ecx
	call	??$subtract@$$BY0BA@I@big@@YAXAAY0BA@I0@Z ; big::subtract<unsigned int [16]>
	add	esp, 8

; 1235 : 				
; 1236 : 				shiftLeft( q, qshifts );

	mov	eax, DWORD PTR _qshifts$[ebp]
	push	eax
	mov	ecx, DWORD PTR _q$[ebp]
	push	ecx
	call	??$shiftLeft@$$BY0BA@I@big@@YAXAAY0BA@II@Z ; big::shiftLeft<unsigned int [16]>
	add	esp, 8

; 1237 : 				qshifts = 0;

	mov	DWORD PTR _qshifts$[ebp], 0

; 1238 : 				
; 1239 : 				q[ 0 ] |= 1;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _q$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	or	eax, 1
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _q$[ebp]
	mov	DWORD PTR [ecx+edx], eax
$LN1@udivide:

; 1240 : 			}
; 1241 : 			
; 1242 : 			ushiftRight1( b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$ushiftRight1@$$BY0BA@I@big@@YAXAAY0BA@I@Z ; big::ushiftRight1<unsigned int [16]>
	add	esp, 4

; 1243 : 		}

	jmp	$LN3@udivide
$LN2@udivide:

; 1244 : 		
; 1245 : 		shiftLeft( q, qshifts );

	mov	eax, DWORD PTR _qshifts$[ebp]
	push	eax
	mov	ecx, DWORD PTR _q$[ebp]
	push	ecx
	call	??$shiftLeft@$$BY0BA@I@big@@YAXAAY0BA@II@Z ; big::shiftLeft<unsigned int [16]>
	add	esp, 8

; 1246 : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN24@udivide
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 320				; 00000140H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN24@udivide:
	DD	1
	DD	$LN23@udivide
$LN23@udivide:
	DD	-72					; ffffffb8H
	DD	64					; 00000040H
	DD	$LN22@udivide
$LN22@udivide:
	DB	98					; 00000062H
	DB	0
??$udivide@$$BY0BA@I@big@@YAXAAY0BA@I000@Z ENDP		; big::udivide<unsigned int [16]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$usetlow@$$BY07I$$BY0BA@I@big@@YAXAAY0BA@IAAY07I@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$usetlow@$$BY07I$$BY0BA@I@big@@YAXAAY0BA@IAAY07I@Z PROC ; big::usetlow<unsigned int [8],unsigned int [16]>, COMDAT

; 314  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 315  : 		memcpy( a, b, sizeof( T ) );

	push	32					; 00000020H
	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 316  : #ifdef _MSC_VER
; 317  : #pragma warning( disable : 4318 ) // warning C4318: passing constant zero as the length to memset
; 318  : #endif
; 319  : 		memset( a + BIGWORDCOUNT( T ), 0, sizeof( Bigger ) - sizeof( T ) );

	push	32					; 00000020H
	push	0
	mov	eax, DWORD PTR _a$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 320  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$usetlow@$$BY07I$$BY0BA@I@big@@YAXAAY0BA@IAAY07I@Z ENDP ; big::usetlow<unsigned int [8],unsigned int [16]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$decrement@$$BY0BA@I@big@@YAXAAY0BA@I@Z
_TEXT	SEGMENT
tv73 = -208						; size = 4
_ii$1 = -8						; size = 4
_n$ = 8							; size = 4
??$decrement@$$BY0BA@I@big@@YAXAAY0BA@I@Z PROC		; big::decrement<unsigned int [16]>, COMDAT

; 848  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 849  : 		for ( u32 ii = 0; ii < BIGWORDCOUNT( T ); ++ii )

	mov	DWORD PTR _ii$1[ebp], 0
	jmp	SHORT $LN4@decrement
$LN3@decrement:
	mov	eax, DWORD PTR _ii$1[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$1[ebp], eax
$LN4@decrement:
	cmp	DWORD PTR _ii$1[ebp], 16		; 00000010H
	jae	SHORT $LN5@decrement

; 850  : 			if ( n[ ii ] -- )

	mov	eax, DWORD PTR _ii$1[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv73[ebp], edx
	mov	eax, DWORD PTR _ii$1[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	sub	edx, 1
	mov	eax, DWORD PTR _ii$1[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx
	cmp	DWORD PTR tv73[ebp], 0
	je	SHORT $LN1@decrement

; 851  : 				break;

	jmp	SHORT $LN5@decrement
$LN1@decrement:

; 852  : 	}

	jmp	SHORT $LN3@decrement
$LN5@decrement:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$decrement@$$BY0BA@I@big@@YAXAAY0BA@I@Z ENDP		; big::decrement<unsigned int [16]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$sethigh@$$BY07I$$BY0BA@I@big@@YAXAAY0BA@IAAY07I@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$sethigh@$$BY07I$$BY0BA@I@big@@YAXAAY0BA@IAAY07I@Z PROC ; big::sethigh<unsigned int [8],unsigned int [16]>, COMDAT

; 331  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 332  : 		memcpy( a + BIGWORDCOUNT( Bigger ) - BIGWORDCOUNT( T ), b, sizeof( T ) );

	push	32					; 00000020H
	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 333  : 		memset( a, 0, sizeof( Bigger ) - sizeof( T ) );

	push	32					; 00000020H
	push	0
	mov	eax, DWORD PTR _a$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 334  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$sethigh@$$BY07I$$BY0BA@I@big@@YAXAAY0BA@IAAY07I@Z ENDP ; big::sethigh<unsigned int [8],unsigned int [16]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rsacrypt.h
;	COMDAT ??$computeRinverse@$$BY07I@big@@YAXAAY07I0@Z
_TEXT	SEGMENT
_q$ = -240						; size = 32
_b$ = -200						; size = 32
_a$ = -160						; size = 32
_x2$ = -120						; size = 32
_x1$ = -80						; size = 32
_x0$ = -40						; size = 32
__$ArrayPad$ = -4					; size = 4
_n0$ = 8						; size = 4
_rp$ = 12						; size = 4
??$computeRinverse@$$BY07I@big@@YAXAAY07I0@Z PROC	; big::computeRinverse<unsigned int [8]>, COMDAT

; 209  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 436				; 000001b4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-436]
	mov	ecx, 109				; 0000006dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 210  : 		T x0, x1, x2, a, b, q;
; 211  : 
; 212  : 		//x[0] = 1
; 213  : 		usetw( x0, 1 );

	push	1
	lea	eax, DWORD PTR _x0$[ebp]
	push	eax
	call	??$usetw@$$BY07I@big@@YAXAAY07II@Z	; big::usetw<unsigned int [8]>
	add	esp, 8

; 214  : 
; 215  : 		// a = 2^k (mod b0)
; 216  : 		rModn( n0, a );

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n0$[ebp]
	push	ecx
	call	??$rModn@$$BY07I@big@@YAXAAY07I0@Z	; big::rModn<unsigned int [8]>
	add	esp, 8

; 217  : 
; 218  : 		// {q, b} = b0 / a
; 219  : 		udivide( n0, a, q, b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	mov	eax, DWORD PTR _n0$[ebp]
	push	eax
	call	??$udivide@$$BY07I@big@@YAXAAY07I000@Z	; big::udivide<unsigned int [8]>
	add	esp, 16					; 00000010H

; 220  : 
; 221  : 		// if b = 0, return x[0]
; 222  : 
; 223  : 		if ( isZero( b ) )

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$isZero@$$BY07I@big@@YA_NAAY07I@Z	; big::isZero<unsigned int [8]>
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN10@computeRin

; 224  : 		{
; 225  : 			set ( rp, x0 )
; 226  : 
; 227  : 				;

	lea	eax, DWORD PTR _x0$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rp$[ebp]
	push	ecx
	call	??$set@$$BY07I@big@@YAXAAY07I0@Z	; big::set<unsigned int [8]>
	add	esp, 8

; 228  : 			return ;

	jmp	$LN11@computeRin
$LN10@computeRin:

; 229  : 		}
; 230  : 
; 231  : 		// x[1] = -q (mod b0) = b0 - q, q <= b0
; 232  : 		set ( x1, n0 )
; 233  : 
; 234  : 			;

	mov	eax, DWORD PTR _n0$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x1$[ebp]
	push	ecx
	call	??$set@$$BY07I@big@@YAXAAY07I0@Z	; big::set<unsigned int [8]>
	add	esp, 8

; 235  : 		subtract( x1, q );

	lea	eax, DWORD PTR _q$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x1$[ebp]
	push	ecx
	call	??$subtract@$$BY07I@big@@YAXAAY07I0@Z	; big::subtract<unsigned int [8]>
	add	esp, 8

; 236  : 
; 237  : 		// {q, a} = a / b
; 238  : 		udivide( a, b, q, a );

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	lea	edx, DWORD PTR _b$[ebp]
	push	edx
	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	call	??$udivide@$$BY07I@big@@YAXAAY07I000@Z	; big::udivide<unsigned int [8]>
	add	esp, 16					; 00000010H

; 239  : 
; 240  : 		// if a = 0, return x[1]
; 241  : 		if ( isZero( a ) )

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	call	??$isZero@$$BY07I@big@@YA_NAAY07I@Z	; big::isZero<unsigned int [8]>
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN8@computeRin

; 242  : 		{
; 243  : 			set ( rp, x1 )
; 244  : 
; 245  : 				;

	lea	eax, DWORD PTR _x1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rp$[ebp]
	push	ecx
	call	??$set@$$BY07I@big@@YAXAAY07I0@Z	; big::set<unsigned int [8]>
	add	esp, 8

; 246  : 			return ;

	jmp	$LN11@computeRin
$LN8@computeRin:

; 247  : 		}
; 248  : #ifdef _MSC_VER
; 249  : #pragma warning( disable : 4127 ) // warning C4127: conditional expression is constant
; 250  : #endif
; 251  : 		while ( true )

	mov	eax, 1
	test	eax, eax
	je	$LN11@computeRin

; 252  : 		{
; 253  : 			// x[2] = x[0] - x[1] * q (mod b0)
; 254  : 			SubMulMod( q, x1, x0, n0, x2 );

	lea	eax, DWORD PTR _x2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n0$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x0$[ebp]
	push	edx
	lea	eax, DWORD PTR _x1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	call	??$SubMulMod@$$BY07I@big@@YAXAAY07I0000@Z ; big::SubMulMod<unsigned int [8]>
	add	esp, 20					; 00000014H

; 255  : 
; 256  : 			// {q, b} = b / a
; 257  : 			udivide( b, a, q, b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$udivide@$$BY07I@big@@YAXAAY07I000@Z	; big::udivide<unsigned int [8]>
	add	esp, 16					; 00000010H

; 258  : 
; 259  : 			// if b = 0, return x[2]
; 260  : 
; 261  : 			if ( isZero( b ) )

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$isZero@$$BY07I@big@@YA_NAAY07I@Z	; big::isZero<unsigned int [8]>
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@computeRin

; 262  : 			{
; 263  : 				set ( rp, x2 )
; 264  : 
; 265  : 					;

	lea	eax, DWORD PTR _x2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rp$[ebp]
	push	ecx
	call	??$set@$$BY07I@big@@YAXAAY07I0@Z	; big::set<unsigned int [8]>
	add	esp, 8

; 266  : 				return ;

	jmp	$LN11@computeRin
$LN6@computeRin:

; 267  : 			}
; 268  : 
; 269  : 			// x[0] = x[1] - x[2] * q (mod b0)
; 270  : 			SubMulMod( q, x2, x1, n0, x0 );

	lea	eax, DWORD PTR _x0$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n0$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x1$[ebp]
	push	edx
	lea	eax, DWORD PTR _x2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	call	??$SubMulMod@$$BY07I@big@@YAXAAY07I0000@Z ; big::SubMulMod<unsigned int [8]>
	add	esp, 20					; 00000014H

; 271  : 
; 272  : 			// {q, a} = a / b
; 273  : 			udivide( a, b, q, a );

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	lea	edx, DWORD PTR _b$[ebp]
	push	edx
	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	call	??$udivide@$$BY07I@big@@YAXAAY07I000@Z	; big::udivide<unsigned int [8]>
	add	esp, 16					; 00000010H

; 274  : 
; 275  : 			// if a = 0, return x[0]
; 276  : 			if ( isZero( a ) )

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	call	??$isZero@$$BY07I@big@@YA_NAAY07I@Z	; big::isZero<unsigned int [8]>
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@computeRin

; 277  : 			{
; 278  : 				set ( rp, x0 )
; 279  : 
; 280  : 					;

	lea	eax, DWORD PTR _x0$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rp$[ebp]
	push	ecx
	call	??$set@$$BY07I@big@@YAXAAY07I0@Z	; big::set<unsigned int [8]>
	add	esp, 8

; 281  : 				return ;

	jmp	$LN11@computeRin
$LN5@computeRin:

; 282  : 			}
; 283  : 
; 284  : 			// x[1] = x[2] - x[0] * q (mod b0)
; 285  : 			SubMulMod( q, x0, x2, n0, x1 );

	lea	eax, DWORD PTR _x1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n0$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x2$[ebp]
	push	edx
	lea	eax, DWORD PTR _x0$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	call	??$SubMulMod@$$BY07I@big@@YAXAAY07I0000@Z ; big::SubMulMod<unsigned int [8]>
	add	esp, 20					; 00000014H

; 286  : 
; 287  : 			// {q, b} = b / a
; 288  : 			udivide( b, a, q, b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$udivide@$$BY07I@big@@YAXAAY07I000@Z	; big::udivide<unsigned int [8]>
	add	esp, 16					; 00000010H

; 289  : 
; 290  : 			// if b = 0, return x[1]
; 291  : 			if ( isZero( b ) )

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$isZero@$$BY07I@big@@YA_NAAY07I@Z	; big::isZero<unsigned int [8]>
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@computeRin

; 292  : 			{
; 293  : 				set ( rp, x1 )
; 294  : 
; 295  : 					;

	lea	eax, DWORD PTR _x1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rp$[ebp]
	push	ecx
	call	??$set@$$BY07I@big@@YAXAAY07I0@Z	; big::set<unsigned int [8]>
	add	esp, 8

; 296  : 				return ;

	jmp	$LN11@computeRin
$LN4@computeRin:

; 297  : 			}
; 298  : 
; 299  : 			// x[2] = x[0] - x[1] * q (mod b0)
; 300  : 			SubMulMod( q, x1, x0, n0, x2 );

	lea	eax, DWORD PTR _x2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n0$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x0$[ebp]
	push	edx
	lea	eax, DWORD PTR _x1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	call	??$SubMulMod@$$BY07I@big@@YAXAAY07I0000@Z ; big::SubMulMod<unsigned int [8]>
	add	esp, 20					; 00000014H

; 301  : 
; 302  : 			// {q, a} = a / b
; 303  : 			udivide( a, b, q, a );

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	lea	edx, DWORD PTR _b$[ebp]
	push	edx
	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	call	??$udivide@$$BY07I@big@@YAXAAY07I000@Z	; big::udivide<unsigned int [8]>
	add	esp, 16					; 00000010H

; 304  : 
; 305  : 			// if a = 0, return x[2]
; 306  : 			if ( isZero( a ) )

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	call	??$isZero@$$BY07I@big@@YA_NAAY07I@Z	; big::isZero<unsigned int [8]>
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@computeRin

; 307  : 			{
; 308  : 				set ( rp, x2 )
; 309  : 
; 310  : 					;

	lea	eax, DWORD PTR _x2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rp$[ebp]
	push	ecx
	call	??$set@$$BY07I@big@@YAXAAY07I0@Z	; big::set<unsigned int [8]>
	add	esp, 8

; 311  : 				return ;

	jmp	$LN11@computeRin
$LN3@computeRin:

; 312  : 			}
; 313  : 
; 314  : 			// x[0] = x[1] - x[2] * q (mod b0)
; 315  : 			SubMulMod( q, x2, x1, n0, x0 );

	lea	eax, DWORD PTR _x0$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n0$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x1$[ebp]
	push	edx
	lea	eax, DWORD PTR _x2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	call	??$SubMulMod@$$BY07I@big@@YAXAAY07I0000@Z ; big::SubMulMod<unsigned int [8]>
	add	esp, 20					; 00000014H

; 316  : 
; 317  : 			// {q, b} = b / a
; 318  : 			udivide( b, a, q, b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$udivide@$$BY07I@big@@YAXAAY07I000@Z	; big::udivide<unsigned int [8]>
	add	esp, 16					; 00000010H

; 319  : 
; 320  : 			// if b = 0, return x[0]
; 321  : 			if ( isZero( b ) )

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$isZero@$$BY07I@big@@YA_NAAY07I@Z	; big::isZero<unsigned int [8]>
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@computeRin

; 322  : 			{
; 323  : 				set ( rp, x0 )
; 324  : 
; 325  : 					;

	lea	eax, DWORD PTR _x0$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rp$[ebp]
	push	ecx
	call	??$set@$$BY07I@big@@YAXAAY07I0@Z	; big::set<unsigned int [8]>
	add	esp, 8

; 326  : 				return ;

	jmp	SHORT $LN11@computeRin
$LN2@computeRin:

; 327  : 			}
; 328  : 
; 329  : 			// x[1] = x[2] - x[0] * q (mod b0)
; 330  : 			SubMulMod( q, x0, x2, n0, x1 );

	lea	eax, DWORD PTR _x1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n0$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x2$[ebp]
	push	edx
	lea	eax, DWORD PTR _x0$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	call	??$SubMulMod@$$BY07I@big@@YAXAAY07I0000@Z ; big::SubMulMod<unsigned int [8]>
	add	esp, 20					; 00000014H

; 331  : 
; 332  : 			// {q, a} = a / b
; 333  : 			udivide( a, b, q, a );

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	lea	edx, DWORD PTR _b$[ebp]
	push	edx
	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	call	??$udivide@$$BY07I@big@@YAXAAY07I000@Z	; big::udivide<unsigned int [8]>
	add	esp, 16					; 00000010H

; 334  : 
; 335  : 			// if a = 0, return x[1]
; 336  : 			if ( isZero( a ) )

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	call	??$isZero@$$BY07I@big@@YA_NAAY07I@Z	; big::isZero<unsigned int [8]>
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@computeRin

; 337  : 			{
; 338  : 				set ( rp, x1 )
; 339  : 
; 340  : 					;

	lea	eax, DWORD PTR _x1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rp$[ebp]
	push	ecx
	call	??$set@$$BY07I@big@@YAXAAY07I0@Z	; big::set<unsigned int [8]>
	add	esp, 8

; 341  : 				return ;

	jmp	SHORT $LN11@computeRin
$LN1@computeRin:

; 342  : 			}
; 343  : 		}

	jmp	$LN8@computeRin
$LN11@computeRin:

; 344  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN20@computeRin
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 436				; 000001b4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN20@computeRin:
	DD	6
	DD	$LN19@computeRin
$LN19@computeRin:
	DD	-40					; ffffffd8H
	DD	32					; 00000020H
	DD	$LN13@computeRin
	DD	-80					; ffffffb0H
	DD	32					; 00000020H
	DD	$LN14@computeRin
	DD	-120					; ffffff88H
	DD	32					; 00000020H
	DD	$LN15@computeRin
	DD	-160					; ffffff60H
	DD	32					; 00000020H
	DD	$LN16@computeRin
	DD	-200					; ffffff38H
	DD	32					; 00000020H
	DD	$LN17@computeRin
	DD	-240					; ffffff10H
	DD	32					; 00000020H
	DD	$LN18@computeRin
$LN18@computeRin:
	DB	113					; 00000071H
	DB	0
$LN17@computeRin:
	DB	98					; 00000062H
	DB	0
$LN16@computeRin:
	DB	97					; 00000061H
	DB	0
$LN15@computeRin:
	DB	120					; 00000078H
	DB	50					; 00000032H
	DB	0
$LN14@computeRin:
	DB	120					; 00000078H
	DB	49					; 00000031H
	DB	0
$LN13@computeRin:
	DB	120					; 00000078H
	DB	48					; 00000030H
	DB	0
??$computeRinverse@$$BY07I@big@@YAXAAY07I0@Z ENDP	; big::computeRinverse<unsigned int [8]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rsacrypt.h
;	COMDAT ??$RabinMillerPrimalityTest@$$BY03I@big@@YA_NAAY03II@Z
_TEXT	SEGMENT
tv155 = -476						; size = 4
tv154 = -472						; size = 4
tv128 = -472						; size = 4
tv70 = -472						; size = 4
_j$1 = -272						; size = 4
_y$2 = -260						; size = 16
_index$3 = -236						; size = 4
_a$4 = -224						; size = 16
_dn$ = -200						; size = 32
_dy$ = -160						; size = 32
_one$ = -120						; size = 16
_s$ = -96						; size = 4
_r$ = -84						; size = 16
_n1$ = -60						; size = 16
_ii$5 = -36						; size = 4
_temp$ = -24						; size = 16
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 4
_insurance$ = 12					; size = 4
??$RabinMillerPrimalityTest@$$BY03I@big@@YA_NAAY03II@Z PROC ; big::RabinMillerPrimalityTest<unsigned int [4]>, COMDAT

; 955  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 476				; 000001dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-476]
	mov	ecx, 119				; 00000077H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 956  : 		// check divisibility by small primes <= 1621 (speeds up computation)
; 957  : 		T temp;
; 958  : 
; 959  : 		for ( u32 ii = 0; ii < 256; ++ii )

	mov	DWORD PTR _ii$5[ebp], 0
	jmp	SHORT $LN16@RabinMille
$LN15@RabinMille:
	mov	eax, DWORD PTR _ii$5[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$5[ebp], eax
$LN16@RabinMille:
	cmp	DWORD PTR _ii$5[ebp], 256		; 00000100H
	jae	SHORT $LN14@RabinMille

; 960  : 		{
; 961  : 			usetw( temp, PRIME_TABLE[ ii++ ] );

	mov	eax, DWORD PTR _ii$5[ebp]
	movzx	ecx, WORD PTR _PRIME_TABLE[eax*2]
	mov	DWORD PTR tv70[ebp], ecx
	mov	edx, DWORD PTR _ii$5[ebp]
	add	edx, 1
	mov	DWORD PTR _ii$5[ebp], edx
	mov	eax, DWORD PTR tv70[ebp]
	push	eax
	lea	ecx, DWORD PTR _temp$[ebp]
	push	ecx
	call	??$usetw@$$BY03I@big@@YAXAAY03II@Z	; big::usetw<unsigned int [4]>
	add	esp, 8

; 962  : 
; 963  : 			umodulo( n, temp, temp );

	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _temp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _n$[ebp]
	push	edx
	call	??$umodulo@$$BY03I@big@@YAXAAY03I00@Z	; big::umodulo<unsigned int [4]>
	add	esp, 12					; 0000000cH

; 964  : 
; 965  : 			if ( isZero( temp ) )

	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	call	??$isZero@$$BY03I@big@@YA_NAAY03I@Z	; big::isZero<unsigned int [4]>
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN13@RabinMille

; 966  : 				return false;

	xor	al, al
	jmp	$LN17@RabinMille
$LN13@RabinMille:

; 967  : 		}

	jmp	SHORT $LN15@RabinMille
$LN14@RabinMille:

; 968  : 
; 969  : 		// n1 = n - 1
; 970  : 		T n1;
; 971  : 
; 972  : 		set ( n1, n )
; 973  : 
; 974  : 			;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR _n1$[ebp]
	push	ecx
	call	??$set@$$BY03I@big@@YAXAAY03I0@Z	; big::set<unsigned int [4]>
	add	esp, 8

; 975  : 		decrement( n1 );

	lea	eax, DWORD PTR _n1$[ebp]
	push	eax
	call	??$decrement@$$BY03I@big@@YAXAAY03I@Z	; big::decrement<unsigned int [4]>
	add	esp, 4

; 976  : 
; 977  : 		// write r 2^s = n - 1, r is odd
; 978  : 		T r;
; 979  : 
; 980  : 		u32 s = 0;

	mov	DWORD PTR _s$[ebp], 0

; 981  : 
; 982  : 		set ( r, n1 )
; 983  : 
; 984  : 			;

	lea	eax, DWORD PTR _n1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _r$[ebp]
	push	ecx
	call	??$set@$$BY03I@big@@YAXAAY03I0@Z	; big::set<unsigned int [4]>
	add	esp, 8
$LN12@RabinMille:

; 985  : 		while ( !( r[ 0 ] & 1 ) )

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _r$[ebp+ecx]
	and	edx, 1
	jne	SHORT $LN11@RabinMille

; 986  : 		{
; 987  : 			ushiftRight1( r );

	lea	eax, DWORD PTR _r$[ebp]
	push	eax
	call	??$ushiftRight1@$$BY03I@big@@YAXAAY03I@Z ; big::ushiftRight1<unsigned int [4]>
	add	esp, 4

; 988  : 			++s;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax

; 989  : 		}

	jmp	SHORT $LN12@RabinMille
$LN11@RabinMille:

; 990  : 
; 991  : 		// one = 1
; 992  : 		T one;
; 993  : 
; 994  : 		usetw( one, 1 );

	push	1
	lea	eax, DWORD PTR _one$[ebp]
	push	eax
	call	??$usetw@$$BY03I@big@@YAXAAY03II@Z	; big::usetw<unsigned int [4]>
	add	esp, 8

; 995  : 
; 996  : 		// cache n -> dn
; 997  : 		BIGDOUBLESIZE( T, dy );
; 998  : 
; 999  : 		BIGDOUBLESIZE( T, dn );
; 1000 : 
; 1001 : 		usetlow( dn, n );

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dn$[ebp]
	push	ecx
	call	??$usetlow@$$BY03I$$BY07I@big@@YAXAAY07IAAY03I@Z ; big::usetlow<unsigned int [4],unsigned int [8]>
	add	esp, 8
$LN10@RabinMille:

; 1002 : 
; 1003 : 		while ( insurance-- )

	mov	eax, DWORD PTR _insurance$[ebp]
	mov	DWORD PTR tv128[ebp], eax
	mov	ecx, DWORD PTR _insurance$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _insurance$[ebp], ecx
	cmp	DWORD PTR tv128[ebp], 0
	je	$LN9@RabinMille

; 1004 : 		{
; 1005 : 			// choose random integer a s.t. 1 < a < n - 1
; 1006 : 			T a;
; 1007 : 			int index;
; 1008 : 
; 1009 : 			for ( index = 0; index < (int) sizeof( a ) / (int) sizeof( a[ 0 ] ); index++ )

	mov	DWORD PTR _index$3[ebp], 0
	jmp	SHORT $LN8@RabinMille
$LN7@RabinMille:
	mov	eax, DWORD PTR _index$3[ebp]
	add	eax, 1
	mov	DWORD PTR _index$3[ebp], eax
$LN8@RabinMille:
	cmp	DWORD PTR _index$3[ebp], 4
	jge	SHORT $LN6@RabinMille

; 1010 : 				a[ index ] = randomMT();

	call	?randomMT@@YAIXZ			; randomMT
	mov	ecx, DWORD PTR _index$3[ebp]
	mov	DWORD PTR _a$4[ebp+ecx*4], eax
	jmp	SHORT $LN7@RabinMille
$LN6@RabinMille:

; 1011 : 
; 1012 : 			umodulo( a, n1, a );

	lea	eax, DWORD PTR _a$4[ebp]
	push	eax
	lea	ecx, DWORD PTR _n1$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$4[ebp]
	push	edx
	call	??$umodulo@$$BY03I@big@@YAXAAY03I00@Z	; big::umodulo<unsigned int [4]>
	add	esp, 12					; 0000000cH

; 1013 : 
; 1014 : 			// compute y = a ^ r (mod n)
; 1015 : 			T y;
; 1016 : 
; 1017 : 			simpleModExp( a, r, n, y );

	lea	eax, DWORD PTR _y$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	lea	edx, DWORD PTR _r$[ebp]
	push	edx
	lea	eax, DWORD PTR _a$4[ebp]
	push	eax
	call	??$simpleModExp@$$BY03I@big@@YAXAAY03I000@Z ; big::simpleModExp<unsigned int [4]>
	add	esp, 16					; 00000010H

; 1018 : 
; 1019 : 			if ( !equal( y, one ) && !equal( y, n1 ) )

	lea	eax, DWORD PTR _one$[ebp]
	push	eax
	lea	ecx, DWORD PTR _y$2[ebp]
	push	ecx
	call	??$equal@$$BY03I@big@@YA_NAAY03I0@Z	; big::equal<unsigned int [4]>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	$LN5@RabinMille
	lea	eax, DWORD PTR _n1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _y$2[ebp]
	push	ecx
	call	??$equal@$$BY03I@big@@YA_NAAY03I0@Z	; big::equal<unsigned int [4]>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	$LN5@RabinMille

; 1020 : 			{
; 1021 : 				u32 j = s;

	mov	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR _j$1[ebp], eax
$LN4@RabinMille:

; 1022 : 
; 1023 : 				while ( ( j-- > 1 ) && !equal( y, n1 ) )

	mov	eax, DWORD PTR _j$1[ebp]
	mov	DWORD PTR tv154[ebp], eax
	mov	ecx, DWORD PTR _j$1[ebp]
	sub	ecx, 1
	mov	DWORD PTR _j$1[ebp], ecx
	cmp	DWORD PTR tv154[ebp], 1
	jbe	SHORT $LN19@RabinMille
	mov	DWORD PTR tv155[ebp], 1
	jmp	SHORT $LN20@RabinMille
$LN19@RabinMille:
	mov	DWORD PTR tv155[ebp], 0
$LN20@RabinMille:
	cmp	DWORD PTR tv155[ebp], 0
	je	$LN3@RabinMille
	lea	eax, DWORD PTR _n1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _y$2[ebp]
	push	ecx
	call	??$equal@$$BY03I@big@@YA_NAAY03I0@Z	; big::equal<unsigned int [4]>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@RabinMille

; 1024 : 				{
; 1025 : 					umultiply( y, y, dy );

	lea	eax, DWORD PTR _dy$[ebp]
	push	eax
	lea	ecx, DWORD PTR _y$2[ebp]
	push	ecx
	lea	edx, DWORD PTR _y$2[ebp]
	push	edx
	call	??$umultiply@$$BY03I$$BY07I@big@@YAXAAY03I0AAY07I@Z ; big::umultiply<unsigned int [4],unsigned int [8]>
	add	esp, 12					; 0000000cH

; 1026 : 					umodulo( dy, dn, dy );

	lea	eax, DWORD PTR _dy$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dn$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dy$[ebp]
	push	edx
	call	??$umodulo@$$BY07I@big@@YAXAAY07I00@Z	; big::umodulo<unsigned int [8]>
	add	esp, 12					; 0000000cH

; 1027 : 					takelow( y, dy );

	lea	eax, DWORD PTR _dy$[ebp]
	push	eax
	lea	ecx, DWORD PTR _y$2[ebp]
	push	ecx
	call	??$takelow@$$BY03I$$BY07I@big@@YAXAAY03IAAY07I@Z ; big::takelow<unsigned int [4],unsigned int [8]>
	add	esp, 8

; 1028 : 
; 1029 : 					if ( equal( y, one ) )

	lea	eax, DWORD PTR _one$[ebp]
	push	eax
	lea	ecx, DWORD PTR _y$2[ebp]
	push	ecx
	call	??$equal@$$BY03I@big@@YA_NAAY03I0@Z	; big::equal<unsigned int [4]>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@RabinMille

; 1030 : 						return false;

	xor	al, al
	jmp	SHORT $LN17@RabinMille
$LN2@RabinMille:

; 1031 : 				}

	jmp	$LN4@RabinMille
$LN3@RabinMille:

; 1032 : 
; 1033 : 				if ( !equal( y, n1 ) )

	lea	eax, DWORD PTR _n1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _y$2[ebp]
	push	ecx
	call	??$equal@$$BY03I@big@@YA_NAAY03I0@Z	; big::equal<unsigned int [4]>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN5@RabinMille

; 1034 : 					return false;

	xor	al, al
	jmp	SHORT $LN17@RabinMille
$LN5@RabinMille:

; 1035 : 			}
; 1036 : 		}

	jmp	$LN10@RabinMille
$LN9@RabinMille:

; 1037 : 
; 1038 : 		return true;

	mov	al, 1
$LN17@RabinMille:

; 1039 : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN30@RabinMille
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 476				; 000001dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN30@RabinMille:
	DD	8
	DD	$LN29@RabinMille
$LN29@RabinMille:
	DD	-24					; ffffffe8H
	DD	16					; 00000010H
	DD	$LN21@RabinMille
	DD	-60					; ffffffc4H
	DD	16					; 00000010H
	DD	$LN22@RabinMille
	DD	-84					; ffffffacH
	DD	16					; 00000010H
	DD	$LN23@RabinMille
	DD	-120					; ffffff88H
	DD	16					; 00000010H
	DD	$LN24@RabinMille
	DD	-160					; ffffff60H
	DD	32					; 00000020H
	DD	$LN25@RabinMille
	DD	-200					; ffffff38H
	DD	32					; 00000020H
	DD	$LN26@RabinMille
	DD	-224					; ffffff20H
	DD	16					; 00000010H
	DD	$LN27@RabinMille
	DD	-260					; fffffefcH
	DD	16					; 00000010H
	DD	$LN28@RabinMille
$LN28@RabinMille:
	DB	121					; 00000079H
	DB	0
$LN27@RabinMille:
	DB	97					; 00000061H
	DB	0
$LN26@RabinMille:
	DB	100					; 00000064H
	DB	110					; 0000006eH
	DB	0
$LN25@RabinMille:
	DB	100					; 00000064H
	DB	121					; 00000079H
	DB	0
$LN24@RabinMille:
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	0
$LN23@RabinMille:
	DB	114					; 00000072H
	DB	0
$LN22@RabinMille:
	DB	110					; 0000006eH
	DB	49					; 00000031H
	DB	0
$LN21@RabinMille:
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
??$RabinMillerPrimalityTest@$$BY03I@big@@YA_NAAY03II@Z ENDP ; big::RabinMillerPrimalityTest<unsigned int [4]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rsacrypt.h
;	COMDAT ??$rModn@$$BY03I@big@@YAXAAY03I0@Z
_TEXT	SEGMENT
_one$ = -144						; size = 16
_dRn$ = -120						; size = 32
_dn$ = -80						; size = 32
_dR$ = -40						; size = 32
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 4
_Rn$ = 12						; size = 4
??$rModn@$$BY03I@big@@YAXAAY03I0@Z PROC			; big::rModn<unsigned int [4]>, COMDAT

; 105  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 340				; 00000154H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-340]
	mov	ecx, 85					; 00000055H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 106  : 		BIGDOUBLESIZE( T, dR );
; 107  : 		BIGDOUBLESIZE( T, dn );
; 108  : 		BIGDOUBLESIZE( T, dRn );
; 109  : 		T one;
; 110  : 
; 111  : 		// dR = 2^k
; 112  : 		usetw( one, 1 );

	push	1
	lea	eax, DWORD PTR _one$[ebp]
	push	eax
	call	??$usetw@$$BY03I@big@@YAXAAY03II@Z	; big::usetw<unsigned int [4]>
	add	esp, 8

; 113  : 		sethigh( dR, one );

	lea	eax, DWORD PTR _one$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dR$[ebp]
	push	ecx
	call	??$sethigh@$$BY03I$$BY07I@big@@YAXAAY07IAAY03I@Z ; big::sethigh<unsigned int [4],unsigned int [8]>
	add	esp, 8

; 114  : 
; 115  : 		// Rn = 2^k (mod n)
; 116  : 		usetlow( dn, n );

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dn$[ebp]
	push	ecx
	call	??$usetlow@$$BY03I$$BY07I@big@@YAXAAY07IAAY03I@Z ; big::usetlow<unsigned int [4],unsigned int [8]>
	add	esp, 8

; 117  : 		umodulo( dR, dn, dRn );

	lea	eax, DWORD PTR _dRn$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dn$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dR$[ebp]
	push	edx
	call	??$umodulo@$$BY07I@big@@YAXAAY07I00@Z	; big::umodulo<unsigned int [8]>
	add	esp, 12					; 0000000cH

; 118  : 		takelow( Rn, dRn );

	lea	eax, DWORD PTR _dRn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Rn$[ebp]
	push	ecx
	call	??$takelow@$$BY03I$$BY07I@big@@YAXAAY03IAAY07I@Z ; big::takelow<unsigned int [4],unsigned int [8]>
	add	esp, 8

; 119  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@rModn
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 340				; 00000154H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN8@rModn:
	DD	4
	DD	$LN7@rModn
$LN7@rModn:
	DD	-40					; ffffffd8H
	DD	32					; 00000020H
	DD	$LN3@rModn
	DD	-80					; ffffffb0H
	DD	32					; 00000020H
	DD	$LN4@rModn
	DD	-120					; ffffff88H
	DD	32					; 00000020H
	DD	$LN5@rModn
	DD	-144					; ffffff70H
	DD	16					; 00000010H
	DD	$LN6@rModn
$LN6@rModn:
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	0
$LN5@rModn:
	DB	100					; 00000064H
	DB	82					; 00000052H
	DB	110					; 0000006eH
	DB	0
$LN4@rModn:
	DB	100					; 00000064H
	DB	110					; 0000006eH
	DB	0
$LN3@rModn:
	DB	100					; 00000064H
	DB	82					; 00000052H
	DB	0
??$rModn@$$BY03I@big@@YAXAAY03I0@Z ENDP			; big::rModn<unsigned int [4]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rsacrypt.h
;	COMDAT ??$computeNRinverse@$$BY03I@big@@YAXAAY03I0@Z
_TEXT	SEGMENT
_n$ = -80						; size = 32
_r$ = -40						; size = 32
__$ArrayPad$ = -4					; size = 4
_n0$ = 8						; size = 4
_np$ = 12						; size = 4
??$computeNRinverse@$$BY03I@big@@YAXAAY03I0@Z PROC	; big::computeNRinverse<unsigned int [4]>, COMDAT

; 653  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-276]
	mov	ecx, 69					; 00000045H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 654  : 		BIGDOUBLESIZE( T, r );
; 655  : 		BIGDOUBLESIZE( T, n );
; 656  : 
; 657  : 		// r' = (1 + n' n) / r
; 658  : 		computeRinverse( n0, np );

	mov	eax, DWORD PTR _np$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n0$[ebp]
	push	ecx
	call	??$computeRinverse@$$BY03I@big@@YAXAAY03I0@Z ; big::computeRinverse<unsigned int [4]>
	add	esp, 8

; 659  : 
; 660  : 		// n' = (r' r - 1) / n
; 661  : 		sethigh( r, np ); // special case of r = 2^k

	mov	eax, DWORD PTR _np$[ebp]
	push	eax
	lea	ecx, DWORD PTR _r$[ebp]
	push	ecx
	call	??$sethigh@$$BY03I$$BY07I@big@@YAXAAY07IAAY03I@Z ; big::sethigh<unsigned int [4],unsigned int [8]>
	add	esp, 8

; 662  : 		decrement( r );

	lea	eax, DWORD PTR _r$[ebp]
	push	eax
	call	??$decrement@$$BY07I@big@@YAXAAY07I@Z	; big::decrement<unsigned int [8]>
	add	esp, 4

; 663  : 		usetlow( n, n0 );

	mov	eax, DWORD PTR _n0$[ebp]
	push	eax
	lea	ecx, DWORD PTR _n$[ebp]
	push	ecx
	call	??$usetlow@$$BY03I$$BY07I@big@@YAXAAY07IAAY03I@Z ; big::usetlow<unsigned int [4],unsigned int [8]>
	add	esp, 8

; 664  : 		udivide( r, n, n, r );

	lea	eax, DWORD PTR _r$[ebp]
	push	eax
	lea	ecx, DWORD PTR _n$[ebp]
	push	ecx
	lea	edx, DWORD PTR _n$[ebp]
	push	edx
	lea	eax, DWORD PTR _r$[ebp]
	push	eax
	call	??$udivide@$$BY07I@big@@YAXAAY07I000@Z	; big::udivide<unsigned int [8]>
	add	esp, 16					; 00000010H

; 665  : 		takelow( np, n );

	lea	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _np$[ebp]
	push	ecx
	call	??$takelow@$$BY03I$$BY07I@big@@YAXAAY03IAAY07I@Z ; big::takelow<unsigned int [4],unsigned int [8]>
	add	esp, 8

; 666  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@computeNRi
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@computeNRi:
	DD	2
	DD	$LN5@computeNRi
$LN5@computeNRi:
	DD	-40					; ffffffd8H
	DD	32					; 00000020H
	DD	$LN3@computeNRi
	DD	-80					; ffffffb0H
	DD	32					; 00000020H
	DD	$LN4@computeNRi
$LN4@computeNRi:
	DB	110					; 0000006eH
	DB	0
$LN3@computeNRi:
	DB	114					; 00000072H
	DB	0
??$computeNRinverse@$$BY03I@big@@YAXAAY03I0@Z ENDP	; big::computeNRinverse<unsigned int [4]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rsacrypt.h
;	COMDAT ??$computeModularInverse@$$BY03I@big@@YAXAAY03I00@Z
_TEXT	SEGMENT
_q$ = -144						; size = 16
_b$ = -120						; size = 16
_a$ = -96						; size = 16
_x2$ = -72						; size = 16
_x1$ = -48						; size = 16
_x0$ = -24						; size = 16
__$ArrayPad$ = -4					; size = 4
_a0$ = 8						; size = 4
_b0$ = 12						; size = 4
_ap$ = 16						; size = 4
??$computeModularInverse@$$BY03I@big@@YAXAAY03I00@Z PROC ; big::computeModularInverse<unsigned int [4]>, COMDAT

; 532  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 340				; 00000154H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-340]
	mov	ecx, 85					; 00000055H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 533  : 		T x0, x1, x2;
; 534  : 		T a, b, q;
; 535  : 
; 536  : 		// x[2] = 1
; 537  : 		usetw( x2, 1 );

	push	1
	lea	eax, DWORD PTR _x2$[ebp]
	push	eax
	call	??$usetw@$$BY03I@big@@YAXAAY03II@Z	; big::usetw<unsigned int [4]>
	add	esp, 8

; 538  : 
; 539  : 		// {q, b} = b0 / a0
; 540  : 		udivide( b0, a0, q, b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	mov	edx, DWORD PTR _a0$[ebp]
	push	edx
	mov	eax, DWORD PTR _b0$[ebp]
	push	eax
	call	??$udivide@$$BY03I@big@@YAXAAY03I000@Z	; big::udivide<unsigned int [4]>
	add	esp, 16					; 00000010H

; 541  : 
; 542  : 		// x[0] = -q (mod b0) = b0 - q, q <= b0
; 543  : 
; 544  : 		set ( x0, b0 )
; 545  : 
; 546  : 			;

	mov	eax, DWORD PTR _b0$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x0$[ebp]
	push	ecx
	call	??$set@$$BY03I@big@@YAXAAY03I0@Z	; big::set<unsigned int [4]>
	add	esp, 8

; 547  : 		subtract( x0, q );

	lea	eax, DWORD PTR _q$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x0$[ebp]
	push	ecx
	call	??$subtract@$$BY03I@big@@YAXAAY03I0@Z	; big::subtract<unsigned int [4]>
	add	esp, 8

; 548  : 
; 549  : 		set ( a, a0 )
; 550  : 
; 551  : 			;

	mov	eax, DWORD PTR _a0$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	??$set@$$BY03I@big@@YAXAAY03I0@Z	; big::set<unsigned int [4]>
	add	esp, 8
$LN8@computeMod:

; 552  : 
; 553  : #ifdef _MSC_VER
; 554  : #pragma warning( disable : 4127 ) // warning C4127: conditional expression is constant
; 555  : #endif
; 556  : 		while ( true )

	mov	eax, 1
	test	eax, eax
	je	$LN9@computeMod

; 557  : 		{
; 558  : 			// {q, a} = a / b
; 559  : 			udivide( a, b, q, a );

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	lea	edx, DWORD PTR _b$[ebp]
	push	edx
	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	call	??$udivide@$$BY03I@big@@YAXAAY03I000@Z	; big::udivide<unsigned int [4]>
	add	esp, 16					; 00000010H

; 560  : 
; 561  : 			// if a = 0, return x[0]
; 562  : 
; 563  : 			if ( isZero( a ) )

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	call	??$isZero@$$BY03I@big@@YA_NAAY03I@Z	; big::isZero<unsigned int [4]>
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@computeMod

; 564  : 			{
; 565  : 				set ( ap, x0 )
; 566  : 
; 567  : 					;

	lea	eax, DWORD PTR _x0$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ap$[ebp]
	push	ecx
	call	??$set@$$BY03I@big@@YAXAAY03I0@Z	; big::set<unsigned int [4]>
	add	esp, 8

; 568  : 				return ;

	jmp	$LN9@computeMod
$LN6@computeMod:

; 569  : 			}
; 570  : 
; 571  : 			// x[1] = x[2] - x[0] * q (mod b0)
; 572  : 			SubMulMod( x0, q, x2, b0, x1 );

	lea	eax, DWORD PTR _x1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _b0$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x2$[ebp]
	push	edx
	lea	eax, DWORD PTR _q$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x0$[ebp]
	push	ecx
	call	??$SubMulMod@$$BY03I@big@@YAXAAY03I0000@Z ; big::SubMulMod<unsigned int [4]>
	add	esp, 20					; 00000014H

; 573  : 
; 574  : 			// {q, b} = b / a
; 575  : 			udivide( b, a, q, b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$udivide@$$BY03I@big@@YAXAAY03I000@Z	; big::udivide<unsigned int [4]>
	add	esp, 16					; 00000010H

; 576  : 
; 577  : 			// if b = 0, return x[1]
; 578  : 			if ( isZero( b ) )

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$isZero@$$BY03I@big@@YA_NAAY03I@Z	; big::isZero<unsigned int [4]>
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@computeMod

; 579  : 			{
; 580  : 				set ( ap, x1 )
; 581  : 
; 582  : 					;

	lea	eax, DWORD PTR _x1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ap$[ebp]
	push	ecx
	call	??$set@$$BY03I@big@@YAXAAY03I0@Z	; big::set<unsigned int [4]>
	add	esp, 8

; 583  : 				return ;

	jmp	$LN9@computeMod
$LN5@computeMod:

; 584  : 			}
; 585  : 
; 586  : 			// x[2] = x[0] - x[1] * q (mod b0)
; 587  : 			SubMulMod( x1, q, x0, b0, x2 );

	lea	eax, DWORD PTR _x2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _b0$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x0$[ebp]
	push	edx
	lea	eax, DWORD PTR _q$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x1$[ebp]
	push	ecx
	call	??$SubMulMod@$$BY03I@big@@YAXAAY03I0000@Z ; big::SubMulMod<unsigned int [4]>
	add	esp, 20					; 00000014H

; 588  : 
; 589  : 			// {q, a} = a / b
; 590  : 			udivide( a, b, q, a );

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	lea	edx, DWORD PTR _b$[ebp]
	push	edx
	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	call	??$udivide@$$BY03I@big@@YAXAAY03I000@Z	; big::udivide<unsigned int [4]>
	add	esp, 16					; 00000010H

; 591  : 
; 592  : 			// if a = 0, return x[2]
; 593  : 			if ( isZero( a ) )

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	call	??$isZero@$$BY03I@big@@YA_NAAY03I@Z	; big::isZero<unsigned int [4]>
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@computeMod

; 594  : 			{
; 595  : 				set ( ap, x2 )
; 596  : 
; 597  : 					;

	lea	eax, DWORD PTR _x2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ap$[ebp]
	push	ecx
	call	??$set@$$BY03I@big@@YAXAAY03I0@Z	; big::set<unsigned int [4]>
	add	esp, 8

; 598  : 				return ;

	jmp	$LN9@computeMod
$LN4@computeMod:

; 599  : 			}
; 600  : 
; 601  : 			// x[0] = x[1] - x[2] * q (mod b0)
; 602  : 			SubMulMod( x2, q, x1, b0, x0 );

	lea	eax, DWORD PTR _x0$[ebp]
	push	eax
	mov	ecx, DWORD PTR _b0$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x1$[ebp]
	push	edx
	lea	eax, DWORD PTR _q$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x2$[ebp]
	push	ecx
	call	??$SubMulMod@$$BY03I@big@@YAXAAY03I0000@Z ; big::SubMulMod<unsigned int [4]>
	add	esp, 20					; 00000014H

; 603  : 
; 604  : 			// {q, b} = b / a
; 605  : 			udivide( b, a, q, b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$udivide@$$BY03I@big@@YAXAAY03I000@Z	; big::udivide<unsigned int [4]>
	add	esp, 16					; 00000010H

; 606  : 
; 607  : 			// if b = 0, return x[0]
; 608  : 			if ( isZero( b ) )

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$isZero@$$BY03I@big@@YA_NAAY03I@Z	; big::isZero<unsigned int [4]>
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@computeMod

; 609  : 			{
; 610  : 				set ( ap, x0 )
; 611  : 
; 612  : 					;

	lea	eax, DWORD PTR _x0$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ap$[ebp]
	push	ecx
	call	??$set@$$BY03I@big@@YAXAAY03I0@Z	; big::set<unsigned int [4]>
	add	esp, 8

; 613  : 				return ;

	jmp	$LN9@computeMod
$LN3@computeMod:

; 614  : 			}
; 615  : 
; 616  : 			// x[1] = x[2] - x[0] * q (mod b0)
; 617  : 			SubMulMod( x0, q, x2, b0, x1 );

	lea	eax, DWORD PTR _x1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _b0$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x2$[ebp]
	push	edx
	lea	eax, DWORD PTR _q$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x0$[ebp]
	push	ecx
	call	??$SubMulMod@$$BY03I@big@@YAXAAY03I0000@Z ; big::SubMulMod<unsigned int [4]>
	add	esp, 20					; 00000014H

; 618  : 
; 619  : 			// {q, a} = a / b
; 620  : 			udivide( a, b, q, a );

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	lea	edx, DWORD PTR _b$[ebp]
	push	edx
	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	call	??$udivide@$$BY03I@big@@YAXAAY03I000@Z	; big::udivide<unsigned int [4]>
	add	esp, 16					; 00000010H

; 621  : 
; 622  : 			// if a = 0, return x[1]
; 623  : 			if ( isZero( a ) )

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	call	??$isZero@$$BY03I@big@@YA_NAAY03I@Z	; big::isZero<unsigned int [4]>
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@computeMod

; 624  : 			{
; 625  : 				set ( ap, x1 )
; 626  : 
; 627  : 					;

	lea	eax, DWORD PTR _x1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ap$[ebp]
	push	ecx
	call	??$set@$$BY03I@big@@YAXAAY03I0@Z	; big::set<unsigned int [4]>
	add	esp, 8

; 628  : 				return ;

	jmp	$LN9@computeMod
$LN2@computeMod:

; 629  : 			}
; 630  : 
; 631  : 			// x[2] = x[0] - x[1] * q (mod b0)
; 632  : 			SubMulMod( x1, q, x0, b0, x2 );

	lea	eax, DWORD PTR _x2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _b0$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x0$[ebp]
	push	edx
	lea	eax, DWORD PTR _q$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x1$[ebp]
	push	ecx
	call	??$SubMulMod@$$BY03I@big@@YAXAAY03I0000@Z ; big::SubMulMod<unsigned int [4]>
	add	esp, 20					; 00000014H

; 633  : 
; 634  : 			// {q, b} = b / a
; 635  : 			udivide( b, a, q, b );

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$[ebp]
	push	ecx
	lea	edx, DWORD PTR _a$[ebp]
	push	edx
	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$udivide@$$BY03I@big@@YAXAAY03I000@Z	; big::udivide<unsigned int [4]>
	add	esp, 16					; 00000010H

; 636  : 
; 637  : 			// if b = 0, return x[2]
; 638  : 			if ( isZero( b ) )

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	??$isZero@$$BY03I@big@@YA_NAAY03I@Z	; big::isZero<unsigned int [4]>
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@computeMod

; 639  : 			{
; 640  : 				set ( ap, x2 )
; 641  : 
; 642  : 					;

	lea	eax, DWORD PTR _x2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ap$[ebp]
	push	ecx
	call	??$set@$$BY03I@big@@YAXAAY03I0@Z	; big::set<unsigned int [4]>
	add	esp, 8

; 643  : 				return ;

	jmp	SHORT $LN9@computeMod
$LN1@computeMod:

; 644  : 			}
; 645  : 
; 646  : 			// x[0] = x[1] - x[2] * q (mod b0)
; 647  : 			SubMulMod( x2, q, x1, b0, x0 );

	lea	eax, DWORD PTR _x0$[ebp]
	push	eax
	mov	ecx, DWORD PTR _b0$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x1$[ebp]
	push	edx
	lea	eax, DWORD PTR _q$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x2$[ebp]
	push	ecx
	call	??$SubMulMod@$$BY03I@big@@YAXAAY03I0000@Z ; big::SubMulMod<unsigned int [4]>
	add	esp, 20					; 00000014H

; 648  : 		}

	jmp	$LN8@computeMod
$LN9@computeMod:

; 649  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN18@computeMod
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 340				; 00000154H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN18@computeMod:
	DD	6
	DD	$LN17@computeMod
$LN17@computeMod:
	DD	-24					; ffffffe8H
	DD	16					; 00000010H
	DD	$LN11@computeMod
	DD	-48					; ffffffd0H
	DD	16					; 00000010H
	DD	$LN12@computeMod
	DD	-72					; ffffffb8H
	DD	16					; 00000010H
	DD	$LN13@computeMod
	DD	-96					; ffffffa0H
	DD	16					; 00000010H
	DD	$LN14@computeMod
	DD	-120					; ffffff88H
	DD	16					; 00000010H
	DD	$LN15@computeMod
	DD	-144					; ffffff70H
	DD	16					; 00000010H
	DD	$LN16@computeMod
$LN16@computeMod:
	DB	113					; 00000071H
	DB	0
$LN15@computeMod:
	DB	98					; 00000062H
	DB	0
$LN14@computeMod:
	DB	97					; 00000061H
	DB	0
$LN13@computeMod:
	DB	120					; 00000078H
	DB	50					; 00000032H
	DB	0
$LN12@computeMod:
	DB	120					; 00000078H
	DB	49					; 00000031H
	DB	0
$LN11@computeMod:
	DB	120					; 00000078H
	DB	48					; 00000030H
	DB	0
??$computeModularInverse@$$BY03I@big@@YAXAAY03I00@Z ENDP ; big::computeModularInverse<unsigned int [4]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rsacrypt.h
;	COMDAT ??$computePrivateExponent@$$BY07I@big@@YAXAAY07I00@Z
_TEXT	SEGMENT
_e$ = 8							; size = 4
_phi$ = 12						; size = 4
_d$ = 16						; size = 4
??$computePrivateExponent@$$BY07I@big@@YAXAAY07I00@Z PROC ; big::computePrivateExponent<unsigned int [8]>, COMDAT

; 900  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 901  : 		// d = e^-1 (mod phi), 1 < e << phi
; 902  : 		computeModularInverse( e, phi, d );

	mov	eax, DWORD PTR _d$[ebp]
	push	eax
	mov	ecx, DWORD PTR _phi$[ebp]
	push	ecx
	mov	edx, DWORD PTR _e$[ebp]
	push	edx
	call	??$computeModularInverse@$$BY07I@big@@YAXAAY07I00@Z ; big::computeModularInverse<unsigned int [8]>
	add	esp, 12					; 0000000cH

; 903  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$computePrivateExponent@$$BY07I@big@@YAXAAY07I00@Z ENDP ; big::computePrivateExponent<unsigned int [8]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rsacrypt.h
;	COMDAT ??$computePublicExponent@$$BY07I@big@@YAXAAY07I0@Z
_TEXT	SEGMENT
_two$ = -120						; size = 32
_one$ = -80						; size = 32
_r$ = -40						; size = 32
__$ArrayPad$ = -4					; size = 4
_phi$ = 8						; size = 4
_e$ = 12						; size = 4
??$computePublicExponent@$$BY07I@big@@YAXAAY07I0@Z PROC	; big::computePublicExponent<unsigned int [8]>, COMDAT

; 877  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 316				; 0000013cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-316]
	mov	ecx, 79					; 0000004fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 878  : 		T r, one, two;
; 879  : 		usetw( one, 1 );

	push	1
	lea	eax, DWORD PTR _one$[ebp]
	push	eax
	call	??$usetw@$$BY07I@big@@YAXAAY07II@Z	; big::usetw<unsigned int [8]>
	add	esp, 8

; 880  : 		usetw( two, 2 );

	push	2
	lea	eax, DWORD PTR _two$[ebp]
	push	eax
	call	??$usetw@$$BY07I@big@@YAXAAY07II@Z	; big::usetw<unsigned int [8]>
	add	esp, 8

; 881  : 		usetw( e, 65537 - 2 );

	push	65535					; 0000ffffH
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	??$usetw@$$BY07I@big@@YAXAAY07II@Z	; big::usetw<unsigned int [8]>
	add	esp, 8

; 882  : 
; 883  : 		if ( ugreater( e, phi ) )

	mov	eax, DWORD PTR _phi$[ebp]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	call	??$ugreater@$$BY07I@big@@YA_NAAY07I0@Z	; big::ugreater<unsigned int [8]>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@computePub

; 884  : 			usetw( e, 5 - 2 );

	push	3
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	??$usetw@$$BY07I@big@@YAXAAY07II@Z	; big::usetw<unsigned int [8]>
	add	esp, 8
$LN3@computePub:

; 885  : 
; 886  : 		do
; 887  : 		{
; 888  : 			add ( e, two )
; 889  : 
; 890  : 				;

	lea	eax, DWORD PTR _two$[ebp]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	call	??$add@$$BY07I@big@@YAXAAY07I0@Z	; big::add<unsigned int [8]>
	add	esp, 8

; 891  : 
; 892  : 			GCD( phi, e, r );

	lea	eax, DWORD PTR _r$[ebp]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	mov	edx, DWORD PTR _phi$[ebp]
	push	edx
	call	??$GCD@$$BY07I@big@@YAXAAY07I00@Z	; big::GCD<unsigned int [8]>
	add	esp, 12					; 0000000cH

; 893  : 		}
; 894  : 
; 895  : 		while ( !equal( r, one ) );

	lea	eax, DWORD PTR _one$[ebp]
	push	eax
	lea	ecx, DWORD PTR _r$[ebp]
	push	ecx
	call	??$equal@$$BY07I@big@@YA_NAAY07I0@Z	; big::equal<unsigned int [8]>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@computePub

; 896  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@computePub
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@computePub:
	DD	3
	DD	$LN10@computePub
$LN10@computePub:
	DD	-40					; ffffffd8H
	DD	32					; 00000020H
	DD	$LN7@computePub
	DD	-80					; ffffffb0H
	DD	32					; 00000020H
	DD	$LN8@computePub
	DD	-120					; ffffff88H
	DD	32					; 00000020H
	DD	$LN9@computePub
$LN9@computePub:
	DB	116					; 00000074H
	DB	119					; 00000077H
	DB	111					; 0000006fH
	DB	0
$LN8@computePub:
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	0
$LN7@computePub:
	DB	114					; 00000072H
	DB	0
??$computePublicExponent@$$BY07I@big@@YAXAAY07I0@Z ENDP	; big::computePublicExponent<unsigned int [8]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$umultiply@$$BY03I$$BY07I@big@@YAXAAY03I0AAY07I@Z
_TEXT	SEGMENT
_ctr$1 = -88						; size = 2
_w_i$2 = -76						; size = 4
_ii$3 = -64						; size = 4
_shifts$ = -52						; size = 4
_a$ = -40						; size = 32
__$ArrayPad$ = -4					; size = 4
_a0$ = 8						; size = 4
_b0$ = 12						; size = 4
_m$ = 16						; size = 4
??$umultiply@$$BY03I$$BY07I@big@@YAXAAY03I0AAY07I@Z PROC ; big::umultiply<unsigned int [4],unsigned int [8]>, COMDAT

; 916  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 284				; 0000011cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-284]
	mov	ecx, 71					; 00000047H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 917  : 		Bigger a;
; 918  : 		usetlow( a, a0 );

	mov	eax, DWORD PTR _a0$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	??$usetlow@$$BY03I$$BY07I@big@@YAXAAY07IAAY03I@Z ; big::usetlow<unsigned int [4],unsigned int [8]>
	add	esp, 8

; 919  : 		
; 920  : 		zero( m );

	mov	eax, DWORD PTR _m$[ebp]
	push	eax
	call	??$zero@$$BY07I@big@@YAXAAY07I@Z	; big::zero<unsigned int [8]>
	add	esp, 4

; 921  : 		
; 922  : 		u32 shifts = 0;

	mov	DWORD PTR _shifts$[ebp], 0

; 923  : 		
; 924  : 		for ( u32 ii = 0; ii < BIGWORDCOUNT( T ); ++ii )

	mov	DWORD PTR _ii$3[ebp], 0
	jmp	SHORT $LN7@umultiply
$LN6@umultiply:
	mov	eax, DWORD PTR _ii$3[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$3[ebp], eax
$LN7@umultiply:
	cmp	DWORD PTR _ii$3[ebp], 4
	jae	SHORT $LN8@umultiply

; 925  : 		{
; 926  : 			word w_i = b0[ ii ];

	mov	eax, DWORD PTR _ii$3[ebp]
	mov	ecx, DWORD PTR _b0$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _w_i$2[ebp], edx

; 927  : 			
; 928  : 			u16 ctr = WORDBITS;

	mov	eax, 32					; 00000020H
	mov	WORD PTR _ctr$1[ebp], ax
$LN4@umultiply:

; 929  : 			
; 930  : 			while ( w_i )

	cmp	DWORD PTR _w_i$2[ebp], 0
	je	SHORT $LN3@umultiply

; 931  : 			{
; 932  : 				if ( w_i & 1 )

	mov	eax, DWORD PTR _w_i$2[ebp]
	and	eax, 1
	je	SHORT $LN2@umultiply

; 933  : 				{
; 934  : 					if ( shifts )

	cmp	DWORD PTR _shifts$[ebp], 0
	je	SHORT $LN1@umultiply

; 935  : 					{
; 936  : 						shiftLeft( a, shifts );

	mov	eax, DWORD PTR _shifts$[ebp]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	??$shiftLeft@$$BY07I@big@@YAXAAY07II@Z	; big::shiftLeft<unsigned int [8]>
	add	esp, 8

; 937  : 						shifts = 0;

	mov	DWORD PTR _shifts$[ebp], 0
$LN1@umultiply:

; 938  : 					}
; 939  : 					
; 940  : 					add ( m, a )
; 941  : 					
; 942  : 					;

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	mov	ecx, DWORD PTR _m$[ebp]
	push	ecx
	call	??$add@$$BY07I@big@@YAXAAY07I0@Z	; big::add<unsigned int [8]>
	add	esp, 8
$LN2@umultiply:

; 943  : 				}
; 944  : 				
; 945  : 				w_i >>= 1;

	mov	eax, DWORD PTR _w_i$2[ebp]
	shr	eax, 1
	mov	DWORD PTR _w_i$2[ebp], eax

; 946  : 				++shifts;

	mov	eax, DWORD PTR _shifts$[ebp]
	add	eax, 1
	mov	DWORD PTR _shifts$[ebp], eax

; 947  : 				--ctr;

	mov	ax, WORD PTR _ctr$1[ebp]
	sub	ax, 1
	mov	WORD PTR _ctr$1[ebp], ax

; 948  : 			}

	jmp	SHORT $LN4@umultiply
$LN3@umultiply:

; 949  : 			
; 950  : 			shifts += ctr;

	movzx	eax, WORD PTR _ctr$1[ebp]
	add	eax, DWORD PTR _shifts$[ebp]
	mov	DWORD PTR _shifts$[ebp], eax

; 951  : 		}

	jmp	$LN6@umultiply
$LN8@umultiply:

; 952  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@umultiply
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 284				; 0000011cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@umultiply:
	DD	1
	DD	$LN11@umultiply
$LN11@umultiply:
	DD	-40					; ffffffd8H
	DD	32					; 00000020H
	DD	$LN10@umultiply
$LN10@umultiply:
	DB	97					; 00000061H
	DB	0
??$umultiply@$$BY03I$$BY07I@big@@YAXAAY03I0AAY07I@Z ENDP ; big::umultiply<unsigned int [4],unsigned int [8]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$decrement@$$BY03I@big@@YAXAAY03I@Z
_TEXT	SEGMENT
tv73 = -208						; size = 4
_ii$1 = -8						; size = 4
_n$ = 8							; size = 4
??$decrement@$$BY03I@big@@YAXAAY03I@Z PROC		; big::decrement<unsigned int [4]>, COMDAT

; 848  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 849  : 		for ( u32 ii = 0; ii < BIGWORDCOUNT( T ); ++ii )

	mov	DWORD PTR _ii$1[ebp], 0
	jmp	SHORT $LN4@decrement
$LN3@decrement:
	mov	eax, DWORD PTR _ii$1[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$1[ebp], eax
$LN4@decrement:
	cmp	DWORD PTR _ii$1[ebp], 4
	jae	SHORT $LN5@decrement

; 850  : 			if ( n[ ii ] -- )

	mov	eax, DWORD PTR _ii$1[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv73[ebp], edx
	mov	eax, DWORD PTR _ii$1[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	sub	edx, 1
	mov	eax, DWORD PTR _ii$1[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx
	cmp	DWORD PTR tv73[ebp], 0
	je	SHORT $LN1@decrement

; 851  : 				break;

	jmp	SHORT $LN5@decrement
$LN1@decrement:

; 852  : 	}

	jmp	SHORT $LN3@decrement
$LN5@decrement:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$decrement@$$BY03I@big@@YAXAAY03I@Z ENDP		; big::decrement<unsigned int [4]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$set@$$BY03I@big@@YAXAAY03I0@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$set@$$BY03I@big@@YAXAAY03I0@Z PROC			; big::set<unsigned int [4]>, COMDAT

; 308  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 309  : 		memcpy( a, b, sizeof( T ) );

	push	16					; 00000010H
	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 310  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$set@$$BY03I@big@@YAXAAY03I0@Z ENDP			; big::set<unsigned int [4]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$ugreater@$$BY03I@big@@YA_NAAY03I0@Z
_TEXT	SEGMENT
_ii$1 = -8						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$ugreater@$$BY03I@big@@YA_NAAY03I0@Z PROC		; big::ugreater<unsigned int [4]>, COMDAT

; 353  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 354  : 		for ( s32 ii = BIGWORDCOUNT( T ) - 1; ii >= 0; --ii )

	mov	DWORD PTR _ii$1[ebp], 3
	jmp	SHORT $LN5@ugreater
$LN4@ugreater:
	mov	eax, DWORD PTR _ii$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _ii$1[ebp], eax
$LN5@ugreater:
	cmp	DWORD PTR _ii$1[ebp], 0
	jl	SHORT $LN3@ugreater

; 355  : 		{
; 356  : 			if ( a[ ii ] > b[ ii ] )

	mov	eax, DWORD PTR _ii$1[ebp]
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _ii$1[ebp]
	mov	esi, DWORD PTR _b$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	cmp	eax, DWORD PTR [esi+edx*4]
	jbe	SHORT $LN2@ugreater

; 357  : 				return true;

	mov	al, 1
	jmp	SHORT $LN6@ugreater
$LN2@ugreater:

; 358  : 				
; 359  : 			if ( a[ ii ] < b[ ii ] )

	mov	eax, DWORD PTR _ii$1[ebp]
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _ii$1[ebp]
	mov	esi, DWORD PTR _b$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	cmp	eax, DWORD PTR [esi+edx*4]
	jae	SHORT $LN1@ugreater

; 360  : 				return false;

	xor	al, al
	jmp	SHORT $LN6@ugreater
$LN1@ugreater:

; 361  : 		}

	jmp	SHORT $LN4@ugreater
$LN3@ugreater:

; 362  : 		
; 363  : 		return false;

	xor	al, al
$LN6@ugreater:

; 364  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$ugreater@$$BY03I@big@@YA_NAAY03I0@Z ENDP		; big::ugreater<unsigned int [4]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$zero@$$BY03I@big@@YAXAAY03I@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
??$zero@$$BY03I@big@@YAXAAY03I@Z PROC			; big::zero<unsigned int [4]>, COMDAT

; 288  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 289  : 		memset( n, 0, sizeof( T ) );

	push	16					; 00000010H
	push	0
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 290  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$zero@$$BY03I@big@@YAXAAY03I@Z ENDP			; big::zero<unsigned int [4]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$zero@$$BY07I@big@@YAXAAY07I@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
??$zero@$$BY07I@big@@YAXAAY07I@Z PROC			; big::zero<unsigned int [8]>, COMDAT

; 288  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 289  : 		memset( n, 0, sizeof( T ) );

	push	32					; 00000020H
	push	0
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 290  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$zero@$$BY07I@big@@YAXAAY07I@Z ENDP			; big::zero<unsigned int [8]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rsacrypt.h
;	COMDAT ??$simpleModExp@$$BY07I@big@@YAXAAY07I000@Z
_TEXT	SEGMENT
_ctr$1 = -336						; size = 4
_y_i$2 = -324						; size = 4
_ii$3 = -312						; size = 4
_squares$ = -300					; size = 4
_r$ = -288						; size = 64
_n$ = -216						; size = 64
_y$ = -144						; size = 64
_x$ = -72						; size = 64
__$ArrayPad$ = -4					; size = 4
_x0$ = 8						; size = 4
_y0$ = 12						; size = 4
_n0$ = 16						; size = 4
_r0$ = 20						; size = 4
??$simpleModExp@$$BY07I@big@@YAXAAY07I000@Z PROC	; big::simpleModExp<unsigned int [8]>, COMDAT

; 53   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 532				; 00000214H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-532]
	mov	ecx, 133				; 00000085H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 54   : 		BIGDOUBLESIZE( T, x );
; 55   : 		BIGDOUBLESIZE( T, y );
; 56   : 		BIGDOUBLESIZE( T, n );
; 57   : 		BIGDOUBLESIZE( T, r );
; 58   : 
; 59   : 		usetlow( x, x0 );

	mov	eax, DWORD PTR _x0$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	??$usetlow@$$BY07I$$BY0BA@I@big@@YAXAAY0BA@IAAY07I@Z ; big::usetlow<unsigned int [8],unsigned int [16]>
	add	esp, 8

; 60   : 		usetlow( y, y0 );

	mov	eax, DWORD PTR _y0$[ebp]
	push	eax
	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	call	??$usetlow@$$BY07I$$BY0BA@I@big@@YAXAAY0BA@IAAY07I@Z ; big::usetlow<unsigned int [8],unsigned int [16]>
	add	esp, 8

; 61   : 		usetlow( n, n0 );

	mov	eax, DWORD PTR _n0$[ebp]
	push	eax
	lea	ecx, DWORD PTR _n$[ebp]
	push	ecx
	call	??$usetlow@$$BY07I$$BY0BA@I@big@@YAXAAY0BA@IAAY07I@Z ; big::usetlow<unsigned int [8],unsigned int [16]>
	add	esp, 8

; 62   : 		usetw( r, 1 );

	push	1
	lea	eax, DWORD PTR _r$[ebp]
	push	eax
	call	??$usetw@$$BY0BA@I@big@@YAXAAY0BA@II@Z	; big::usetw<unsigned int [16]>
	add	esp, 8

; 63   : 
; 64   : 		umodulo( x, n, x );

	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	lea	ecx, DWORD PTR _n$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	call	??$umodulo@$$BY0BA@I@big@@YAXAAY0BA@I00@Z ; big::umodulo<unsigned int [16]>
	add	esp, 12					; 0000000cH

; 65   : 
; 66   : 		u32 squares = 0;

	mov	DWORD PTR _squares$[ebp], 0

; 67   : 
; 68   : 		for ( u32 ii = 0; ii < BIGWORDCOUNT( T ); ++ii )

	mov	DWORD PTR _ii$3[ebp], 0
	jmp	SHORT $LN10@simpleModE
$LN9@simpleModE:
	mov	eax, DWORD PTR _ii$3[ebp]
	add	eax, 1
	mov	DWORD PTR _ii$3[ebp], eax
$LN10@simpleModE:
	cmp	DWORD PTR _ii$3[ebp], 8
	jae	$LN8@simpleModE

; 69   : 		{
; 70   : 			word y_i = y[ ii ];

	mov	eax, DWORD PTR _ii$3[ebp]
	mov	ecx, DWORD PTR _y$[ebp+eax*4]
	mov	DWORD PTR _y_i$2[ebp], ecx

; 71   : 
; 72   : 			u32 ctr = WORDBITS;

	mov	DWORD PTR _ctr$1[ebp], 32		; 00000020H
$LN7@simpleModE:

; 73   : 
; 74   : 			while ( y_i )

	cmp	DWORD PTR _y_i$2[ebp], 0
	je	$LN6@simpleModE

; 75   : 			{
; 76   : 				if ( y_i & 1 )

	mov	eax, DWORD PTR _y_i$2[ebp]
	and	eax, 1
	je	SHORT $LN5@simpleModE

; 77   : 				{
; 78   : 					if ( squares )

	cmp	DWORD PTR _squares$[ebp], 0
	je	SHORT $LN4@simpleModE
$LN3@simpleModE:

; 79   : 						do
; 80   : 						{
; 81   : 							usquare( x );

	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	call	??$usquare@$$BY0BA@I@big@@YAXAAY0BA@I@Z	; big::usquare<unsigned int [16]>
	add	esp, 4

; 82   : 							umodulo( x, n, x );

	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	lea	ecx, DWORD PTR _n$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	call	??$umodulo@$$BY0BA@I@big@@YAXAAY0BA@I00@Z ; big::umodulo<unsigned int [16]>
	add	esp, 12					; 0000000cH

; 83   : 						}
; 84   : 
; 85   : 						while ( --squares );

	mov	eax, DWORD PTR _squares$[ebp]
	sub	eax, 1
	mov	DWORD PTR _squares$[ebp], eax
	jne	SHORT $LN3@simpleModE
$LN4@simpleModE:

; 86   : 
; 87   : 						umultiply( r, x, r );

	lea	eax, DWORD PTR _r$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	lea	edx, DWORD PTR _r$[ebp]
	push	edx
	call	??$umultiply@$$BY0BA@I$$BY0BA@I@big@@YAXAAY0BA@I00@Z ; big::umultiply<unsigned int [16],unsigned int [16]>
	add	esp, 12					; 0000000cH

; 88   : 
; 89   : 						umodulo( r, n, r );

	lea	eax, DWORD PTR _r$[ebp]
	push	eax
	lea	ecx, DWORD PTR _n$[ebp]
	push	ecx
	lea	edx, DWORD PTR _r$[ebp]
	push	edx
	call	??$umodulo@$$BY0BA@I@big@@YAXAAY0BA@I00@Z ; big::umodulo<unsigned int [16]>
	add	esp, 12					; 0000000cH
$LN5@simpleModE:

; 90   : 				}
; 91   : 
; 92   : 				y_i >>= 1;

	mov	eax, DWORD PTR _y_i$2[ebp]
	shr	eax, 1
	mov	DWORD PTR _y_i$2[ebp], eax

; 93   : 				++squares;

	mov	eax, DWORD PTR _squares$[ebp]
	add	eax, 1
	mov	DWORD PTR _squares$[ebp], eax

; 94   : 				--ctr;

	mov	eax, DWORD PTR _ctr$1[ebp]
	sub	eax, 1
	mov	DWORD PTR _ctr$1[ebp], eax

; 95   : 			}

	jmp	$LN7@simpleModE
$LN6@simpleModE:

; 96   : 
; 97   : 			squares += ctr;

	mov	eax, DWORD PTR _squares$[ebp]
	add	eax, DWORD PTR _ctr$1[ebp]
	mov	DWORD PTR _squares$[ebp], eax

; 98   : 		}

	jmp	$LN9@simpleModE
$LN8@simpleModE:

; 99   : 
; 100  : 		takelow( r0, r );

	lea	eax, DWORD PTR _r$[ebp]
	push	eax
	mov	ecx, DWORD PTR _r0$[ebp]
	push	ecx
	call	??$takelow@$$BY07I$$BY0BA@I@big@@YAXAAY07IAAY0BA@I@Z ; big::takelow<unsigned int [8],unsigned int [16]>
	add	esp, 8

; 101  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN18@simpleModE
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 532				; 00000214H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN18@simpleModE:
	DD	4
	DD	$LN17@simpleModE
$LN17@simpleModE:
	DD	-72					; ffffffb8H
	DD	64					; 00000040H
	DD	$LN13@simpleModE
	DD	-144					; ffffff70H
	DD	64					; 00000040H
	DD	$LN14@simpleModE
	DD	-216					; ffffff28H
	DD	64					; 00000040H
	DD	$LN15@simpleModE
	DD	-288					; fffffee0H
	DD	64					; 00000040H
	DD	$LN16@simpleModE
$LN16@simpleModE:
	DB	114					; 00000072H
	DB	0
$LN15@simpleModE:
	DB	110					; 0000006eH
	DB	0
$LN14@simpleModE:
	DB	121					; 00000079H
	DB	0
$LN13@simpleModE:
	DB	120					; 00000078H
	DB	0
??$simpleModExp@$$BY07I@big@@YAXAAY07I000@Z ENDP	; big::simpleModExp<unsigned int [8]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rsacrypt.h
;	COMDAT ??$CRTModExp@$$BY03I$$BY07I@big@@YAXAAY07I00AAY03I111111@Z
_TEXT	SEGMENT
_dM1$ = -424						; size = 32
_C2$ = -384						; size = 16
_M2$ = -360						; size = 16
_dC2$ = -336						; size = 32
_dq$ = -296						; size = 32
_d2$ = -256						; size = 16
_dd2$ = -232						; size = 32
_C1$ = -192						; size = 16
_M1$ = -168						; size = 16
_dC1$ = -144						; size = 32
_dp$ = -104						; size = 32
_d1$ = -64						; size = 16
_dd1$ = -40						; size = 32
__$ArrayPad$ = -4					; size = 4
_x$ = 8							; size = 4
_C$ = 12						; size = 4
_d$ = 16						; size = 4
_p$ = 20						; size = 4
_q$ = 24						; size = 4
_pInverse$ = 28						; size = 4
_pnp$ = 32						; size = 4
_pxp$ = 36						; size = 4
_qnp$ = 40						; size = 4
_qxp$ = 44						; size = 4
??$CRTModExp@$$BY03I$$BY07I@big@@YAXAAY07I00AAY03I111111@Z PROC ; big::CRTModExp<unsigned int [4],unsigned int [8]>, COMDAT

; 799  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 620				; 0000026cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-620]
	mov	ecx, 155				; 0000009bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 800  : 		// d1 = d mod (p - 1)
; 801  : 		Bigger dd1;
; 802  : 		T d1;
; 803  : 		usetlow( dd1, p );

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dd1$[ebp]
	push	ecx
	call	??$usetlow@$$BY03I$$BY07I@big@@YAXAAY07IAAY03I@Z ; big::usetlow<unsigned int [4],unsigned int [8]>
	add	esp, 8

; 804  : 		decrement( dd1 );

	lea	eax, DWORD PTR _dd1$[ebp]
	push	eax
	call	??$decrement@$$BY07I@big@@YAXAAY07I@Z	; big::decrement<unsigned int [8]>
	add	esp, 4

; 805  : 		umodulo( d, dd1, dd1 );

	lea	eax, DWORD PTR _dd1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dd1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _d$[ebp]
	push	edx
	call	??$umodulo@$$BY07I@big@@YAXAAY07I00@Z	; big::umodulo<unsigned int [8]>
	add	esp, 12					; 0000000cH

; 806  : 		takelow( d1, dd1 );

	lea	eax, DWORD PTR _dd1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _d1$[ebp]
	push	ecx
	call	??$takelow@$$BY03I$$BY07I@big@@YAXAAY03IAAY07I@Z ; big::takelow<unsigned int [4],unsigned int [8]>
	add	esp, 8

; 807  : 
; 808  : 		// M1 = C1^d1 (mod p)
; 809  : 		Bigger dp, dC1;
; 810  : 		T M1, C1;
; 811  : 		usetlow( dp, p );

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dp$[ebp]
	push	ecx
	call	??$usetlow@$$BY03I$$BY07I@big@@YAXAAY07IAAY03I@Z ; big::usetlow<unsigned int [4],unsigned int [8]>
	add	esp, 8

; 812  : 		umodulo( C, dp, dC1 );

	lea	eax, DWORD PTR _dC1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _C$[ebp]
	push	edx
	call	??$umodulo@$$BY07I@big@@YAXAAY07I00@Z	; big::umodulo<unsigned int [8]>
	add	esp, 12					; 0000000cH

; 813  : 		takelow( C1, dC1 );

	lea	eax, DWORD PTR _dC1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _C1$[ebp]
	push	ecx
	call	??$takelow@$$BY03I$$BY07I@big@@YAXAAY03IAAY07I@Z ; big::takelow<unsigned int [4],unsigned int [8]>
	add	esp, 8

; 814  : 		simpleModExp( C1, d1, p, M1 );

	lea	eax, DWORD PTR _M1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	lea	edx, DWORD PTR _d1$[ebp]
	push	edx
	lea	eax, DWORD PTR _C1$[ebp]
	push	eax
	call	??$simpleModExp@$$BY03I@big@@YAXAAY03I000@Z ; big::simpleModExp<unsigned int [4]>
	add	esp, 16					; 00000010H

; 815  : 		//MonModExp(M1, C1, d1, p, pnp, pxp);
; 816  : 
; 817  : 		// d2 = d mod (q - 1)
; 818  : 		Bigger dd2;
; 819  : 		T d2;
; 820  : 		usetlow( dd2, q );

	mov	eax, DWORD PTR _q$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dd2$[ebp]
	push	ecx
	call	??$usetlow@$$BY03I$$BY07I@big@@YAXAAY07IAAY03I@Z ; big::usetlow<unsigned int [4],unsigned int [8]>
	add	esp, 8

; 821  : 		decrement( dd2 );

	lea	eax, DWORD PTR _dd2$[ebp]
	push	eax
	call	??$decrement@$$BY07I@big@@YAXAAY07I@Z	; big::decrement<unsigned int [8]>
	add	esp, 4

; 822  : 		umodulo( d, dd2, dd2 );

	lea	eax, DWORD PTR _dd2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dd2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _d$[ebp]
	push	edx
	call	??$umodulo@$$BY07I@big@@YAXAAY07I00@Z	; big::umodulo<unsigned int [8]>
	add	esp, 12					; 0000000cH

; 823  : 		takelow( d2, dd2 );

	lea	eax, DWORD PTR _dd2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _d2$[ebp]
	push	ecx
	call	??$takelow@$$BY03I$$BY07I@big@@YAXAAY03IAAY07I@Z ; big::takelow<unsigned int [4],unsigned int [8]>
	add	esp, 8

; 824  : 
; 825  : 		// M2 = C2^d2 (mod q)
; 826  : 		Bigger dq, dC2;
; 827  : 		T M2, C2;
; 828  : 		usetlow( dq, q );

	mov	eax, DWORD PTR _q$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dq$[ebp]
	push	ecx
	call	??$usetlow@$$BY03I$$BY07I@big@@YAXAAY07IAAY03I@Z ; big::usetlow<unsigned int [4],unsigned int [8]>
	add	esp, 8

; 829  : 		umodulo( C, dq, dC2 );

	lea	eax, DWORD PTR _dC2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dq$[ebp]
	push	ecx
	mov	edx, DWORD PTR _C$[ebp]
	push	edx
	call	??$umodulo@$$BY07I@big@@YAXAAY07I00@Z	; big::umodulo<unsigned int [8]>
	add	esp, 12					; 0000000cH

; 830  : 		takelow( C2, dC2 );

	lea	eax, DWORD PTR _dC2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _C2$[ebp]
	push	ecx
	call	??$takelow@$$BY03I$$BY07I@big@@YAXAAY03IAAY07I@Z ; big::takelow<unsigned int [4],unsigned int [8]>
	add	esp, 8

; 831  : 		simpleModExp( C2, d2, q, M2 );

	lea	eax, DWORD PTR _M2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _q$[ebp]
	push	ecx
	lea	edx, DWORD PTR _d2$[ebp]
	push	edx
	lea	eax, DWORD PTR _C2$[ebp]
	push	eax
	call	??$simpleModExp@$$BY03I@big@@YAXAAY03I000@Z ; big::simpleModExp<unsigned int [4]>
	add	esp, 16					; 00000010H

; 832  : 		//MonModExp(M2, C2, d2, q, qnp, qxp);
; 833  : 
; 834  : 		// x = M1 + p * ((M2 - M1)(p^-1 mod q) mod q)
; 835  : 
; 836  : 		if ( ugreater( M2, M1 ) )

	lea	eax, DWORD PTR _M1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _M2$[ebp]
	push	ecx
	call	??$ugreater@$$BY03I@big@@YA_NAAY03I0@Z	; big::ugreater<unsigned int [4]>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@CRTModExp

; 837  : 		{
; 838  : 			subtract( M2, M1 );

	lea	eax, DWORD PTR _M1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _M2$[ebp]
	push	ecx
	call	??$subtract@$$BY03I@big@@YAXAAY03I0@Z	; big::subtract<unsigned int [4]>
	add	esp, 8

; 839  : 		}
; 840  : 
; 841  : 		else

	jmp	SHORT $LN1@CRTModExp
$LN2@CRTModExp:

; 842  : 		{
; 843  : 			subtract( M2, M1 );

	lea	eax, DWORD PTR _M1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _M2$[ebp]
	push	ecx
	call	??$subtract@$$BY03I@big@@YAXAAY03I0@Z	; big::subtract<unsigned int [4]>
	add	esp, 8

; 844  : 
; 845  : 			add ( M2, q )
; 846  : 
; 847  : 				;

	mov	eax, DWORD PTR _q$[ebp]
	push	eax
	lea	ecx, DWORD PTR _M2$[ebp]
	push	ecx
	call	??$add@$$BY03I@big@@YAXAAY03I0@Z	; big::add<unsigned int [4]>
	add	esp, 8
$LN1@CRTModExp:

; 848  : 		}
; 849  : 
; 850  : 		// x = M1 + p * (( M2 )(p^-1 mod q) mod q)
; 851  : 
; 852  : 		umultiply( M2, pInverse, x );

	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pInverse$[ebp]
	push	ecx
	lea	edx, DWORD PTR _M2$[ebp]
	push	edx
	call	??$umultiply@$$BY03I$$BY07I@big@@YAXAAY03I0AAY07I@Z ; big::umultiply<unsigned int [4],unsigned int [8]>
	add	esp, 12					; 0000000cH

; 853  : 
; 854  : 		// x = M1 + p * (( x ) mod q)
; 855  : 
; 856  : 		umodulo( x, dq, x );

	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dq$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	call	??$umodulo@$$BY07I@big@@YAXAAY07I00@Z	; big::umodulo<unsigned int [8]>
	add	esp, 12					; 0000000cH

; 857  : 
; 858  : 		// x = M1 + p * ( x )
; 859  : 
; 860  : 		umultiply( x, dp );

	lea	eax, DWORD PTR _dp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	??$umultiply@$$BY07I$$BY07I@big@@YAXAAY07I0@Z ; big::umultiply<unsigned int [8],unsigned int [8]>
	add	esp, 8

; 861  : 
; 862  : 		// x = M1 + ( x )
; 863  : 
; 864  : 		Bigger dM1;
; 865  : 
; 866  : 		usetlow( dM1, M1 );

	lea	eax, DWORD PTR _M1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dM1$[ebp]
	push	ecx
	call	??$usetlow@$$BY03I$$BY07I@big@@YAXAAY07IAAY03I@Z ; big::usetlow<unsigned int [4],unsigned int [8]>
	add	esp, 8

; 867  : 
; 868  : 		// x = ( dM1 ) + ( x )
; 869  : 
; 870  : 		add ( x, dM1 )
; 871  : 
; 872  : 			;

	lea	eax, DWORD PTR _dM1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	call	??$add@$$BY07I@big@@YAXAAY07I0@Z	; big::add<unsigned int [8]>
	add	esp, 8

; 873  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN19@CRTModExp
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 620				; 0000026cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN19@CRTModExp:
	DD	13					; 0000000dH
	DD	$LN18@CRTModExp
$LN18@CRTModExp:
	DD	-40					; ffffffd8H
	DD	32					; 00000020H
	DD	$LN5@CRTModExp
	DD	-64					; ffffffc0H
	DD	16					; 00000010H
	DD	$LN6@CRTModExp
	DD	-104					; ffffff98H
	DD	32					; 00000020H
	DD	$LN7@CRTModExp
	DD	-144					; ffffff70H
	DD	32					; 00000020H
	DD	$LN8@CRTModExp
	DD	-168					; ffffff58H
	DD	16					; 00000010H
	DD	$LN9@CRTModExp
	DD	-192					; ffffff40H
	DD	16					; 00000010H
	DD	$LN10@CRTModExp
	DD	-232					; ffffff18H
	DD	32					; 00000020H
	DD	$LN11@CRTModExp
	DD	-256					; ffffff00H
	DD	16					; 00000010H
	DD	$LN12@CRTModExp
	DD	-296					; fffffed8H
	DD	32					; 00000020H
	DD	$LN13@CRTModExp
	DD	-336					; fffffeb0H
	DD	32					; 00000020H
	DD	$LN14@CRTModExp
	DD	-360					; fffffe98H
	DD	16					; 00000010H
	DD	$LN15@CRTModExp
	DD	-384					; fffffe80H
	DD	16					; 00000010H
	DD	$LN16@CRTModExp
	DD	-424					; fffffe58H
	DD	32					; 00000020H
	DD	$LN17@CRTModExp
$LN17@CRTModExp:
	DB	100					; 00000064H
	DB	77					; 0000004dH
	DB	49					; 00000031H
	DB	0
$LN16@CRTModExp:
	DB	67					; 00000043H
	DB	50					; 00000032H
	DB	0
$LN15@CRTModExp:
	DB	77					; 0000004dH
	DB	50					; 00000032H
	DB	0
$LN14@CRTModExp:
	DB	100					; 00000064H
	DB	67					; 00000043H
	DB	50					; 00000032H
	DB	0
$LN13@CRTModExp:
	DB	100					; 00000064H
	DB	113					; 00000071H
	DB	0
$LN12@CRTModExp:
	DB	100					; 00000064H
	DB	50					; 00000032H
	DB	0
$LN11@CRTModExp:
	DB	100					; 00000064H
	DB	100					; 00000064H
	DB	50					; 00000032H
	DB	0
$LN10@CRTModExp:
	DB	67					; 00000043H
	DB	49					; 00000031H
	DB	0
$LN9@CRTModExp:
	DB	77					; 0000004dH
	DB	49					; 00000031H
	DB	0
$LN8@CRTModExp:
	DB	100					; 00000064H
	DB	67					; 00000043H
	DB	49					; 00000031H
	DB	0
$LN7@CRTModExp:
	DB	100					; 00000064H
	DB	112					; 00000070H
	DB	0
$LN6@CRTModExp:
	DB	100					; 00000064H
	DB	49					; 00000031H
	DB	0
$LN5@CRTModExp:
	DB	100					; 00000064H
	DB	100					; 00000064H
	DB	49					; 00000031H
	DB	0
??$CRTModExp@$$BY03I$$BY07I@big@@YAXAAY07I00AAY03I111111@Z ENDP ; big::CRTModExp<unsigned int [4],unsigned int [8]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rsacrypt.h
;	COMDAT ??$rModn@$$BY07I@big@@YAXAAY07I0@Z
_TEXT	SEGMENT
_one$ = -256						; size = 32
_dRn$ = -216						; size = 64
_dn$ = -144						; size = 64
_dR$ = -72						; size = 64
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 4
_Rn$ = 12						; size = 4
??$rModn@$$BY07I@big@@YAXAAY07I0@Z PROC			; big::rModn<unsigned int [8]>, COMDAT

; 105  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 452				; 000001c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-452]
	mov	ecx, 113				; 00000071H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 106  : 		BIGDOUBLESIZE( T, dR );
; 107  : 		BIGDOUBLESIZE( T, dn );
; 108  : 		BIGDOUBLESIZE( T, dRn );
; 109  : 		T one;
; 110  : 
; 111  : 		// dR = 2^k
; 112  : 		usetw( one, 1 );

	push	1
	lea	eax, DWORD PTR _one$[ebp]
	push	eax
	call	??$usetw@$$BY07I@big@@YAXAAY07II@Z	; big::usetw<unsigned int [8]>
	add	esp, 8

; 113  : 		sethigh( dR, one );

	lea	eax, DWORD PTR _one$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dR$[ebp]
	push	ecx
	call	??$sethigh@$$BY07I$$BY0BA@I@big@@YAXAAY0BA@IAAY07I@Z ; big::sethigh<unsigned int [8],unsigned int [16]>
	add	esp, 8

; 114  : 
; 115  : 		// Rn = 2^k (mod n)
; 116  : 		usetlow( dn, n );

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dn$[ebp]
	push	ecx
	call	??$usetlow@$$BY07I$$BY0BA@I@big@@YAXAAY0BA@IAAY07I@Z ; big::usetlow<unsigned int [8],unsigned int [16]>
	add	esp, 8

; 117  : 		umodulo( dR, dn, dRn );

	lea	eax, DWORD PTR _dRn$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dn$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dR$[ebp]
	push	edx
	call	??$umodulo@$$BY0BA@I@big@@YAXAAY0BA@I00@Z ; big::umodulo<unsigned int [16]>
	add	esp, 12					; 0000000cH

; 118  : 		takelow( Rn, dRn );

	lea	eax, DWORD PTR _dRn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Rn$[ebp]
	push	ecx
	call	??$takelow@$$BY07I$$BY0BA@I@big@@YAXAAY07IAAY0BA@I@Z ; big::takelow<unsigned int [8],unsigned int [16]>
	add	esp, 8

; 119  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@rModn
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 452				; 000001c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN8@rModn:
	DD	4
	DD	$LN7@rModn
$LN7@rModn:
	DD	-72					; ffffffb8H
	DD	64					; 00000040H
	DD	$LN3@rModn
	DD	-144					; ffffff70H
	DD	64					; 00000040H
	DD	$LN4@rModn
	DD	-216					; ffffff28H
	DD	64					; 00000040H
	DD	$LN5@rModn
	DD	-256					; ffffff00H
	DD	32					; 00000020H
	DD	$LN6@rModn
$LN6@rModn:
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	0
$LN5@rModn:
	DB	100					; 00000064H
	DB	82					; 00000052H
	DB	110					; 0000006eH
	DB	0
$LN4@rModn:
	DB	100					; 00000064H
	DB	110					; 0000006eH
	DB	0
$LN3@rModn:
	DB	100					; 00000064H
	DB	82					; 00000052H
	DB	0
??$rModn@$$BY07I@big@@YAXAAY07I0@Z ENDP			; big::rModn<unsigned int [8]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rsacrypt.h
;	COMDAT ??$computeNRinverse@$$BY07I@big@@YAXAAY07I0@Z
_TEXT	SEGMENT
_n$ = -144						; size = 64
_r$ = -72						; size = 64
__$ArrayPad$ = -4					; size = 4
_n0$ = 8						; size = 4
_np$ = 12						; size = 4
??$computeNRinverse@$$BY07I@big@@YAXAAY07I0@Z PROC	; big::computeNRinverse<unsigned int [8]>, COMDAT

; 653  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 340				; 00000154H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-340]
	mov	ecx, 85					; 00000055H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 654  : 		BIGDOUBLESIZE( T, r );
; 655  : 		BIGDOUBLESIZE( T, n );
; 656  : 
; 657  : 		// r' = (1 + n' n) / r
; 658  : 		computeRinverse( n0, np );

	mov	eax, DWORD PTR _np$[ebp]
	push	eax
	mov	ecx, DWORD PTR _n0$[ebp]
	push	ecx
	call	??$computeRinverse@$$BY07I@big@@YAXAAY07I0@Z ; big::computeRinverse<unsigned int [8]>
	add	esp, 8

; 659  : 
; 660  : 		// n' = (r' r - 1) / n
; 661  : 		sethigh( r, np ); // special case of r = 2^k

	mov	eax, DWORD PTR _np$[ebp]
	push	eax
	lea	ecx, DWORD PTR _r$[ebp]
	push	ecx
	call	??$sethigh@$$BY07I$$BY0BA@I@big@@YAXAAY0BA@IAAY07I@Z ; big::sethigh<unsigned int [8],unsigned int [16]>
	add	esp, 8

; 662  : 		decrement( r );

	lea	eax, DWORD PTR _r$[ebp]
	push	eax
	call	??$decrement@$$BY0BA@I@big@@YAXAAY0BA@I@Z ; big::decrement<unsigned int [16]>
	add	esp, 4

; 663  : 		usetlow( n, n0 );

	mov	eax, DWORD PTR _n0$[ebp]
	push	eax
	lea	ecx, DWORD PTR _n$[ebp]
	push	ecx
	call	??$usetlow@$$BY07I$$BY0BA@I@big@@YAXAAY0BA@IAAY07I@Z ; big::usetlow<unsigned int [8],unsigned int [16]>
	add	esp, 8

; 664  : 		udivide( r, n, n, r );

	lea	eax, DWORD PTR _r$[ebp]
	push	eax
	lea	ecx, DWORD PTR _n$[ebp]
	push	ecx
	lea	edx, DWORD PTR _n$[ebp]
	push	edx
	lea	eax, DWORD PTR _r$[ebp]
	push	eax
	call	??$udivide@$$BY0BA@I@big@@YAXAAY0BA@I000@Z ; big::udivide<unsigned int [16]>
	add	esp, 16					; 00000010H

; 665  : 		takelow( np, n );

	lea	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _np$[ebp]
	push	ecx
	call	??$takelow@$$BY07I$$BY0BA@I@big@@YAXAAY07IAAY0BA@I@Z ; big::takelow<unsigned int [8],unsigned int [16]>
	add	esp, 8

; 666  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@computeNRi
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 340				; 00000154H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN6@computeNRi:
	DD	2
	DD	$LN5@computeNRi
$LN5@computeNRi:
	DD	-72					; ffffffb8H
	DD	64					; 00000040H
	DD	$LN3@computeNRi
	DD	-144					; ffffff70H
	DD	64					; 00000040H
	DD	$LN4@computeNRi
$LN4@computeNRi:
	DB	110					; 0000006eH
	DB	0
$LN3@computeNRi:
	DB	114					; 00000072H
	DB	0
??$computeNRinverse@$$BY07I@big@@YAXAAY07I0@Z ENDP	; big::computeNRinverse<unsigned int [8]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$set@$$BY07I@big@@YAXAAY07I0@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$set@$$BY07I@big@@YAXAAY07I0@Z PROC			; big::set<unsigned int [8]>, COMDAT

; 308  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 309  : 		memcpy( a, b, sizeof( T ) );

	push	32					; 00000020H
	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 310  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$set@$$BY07I@big@@YAXAAY07I0@Z ENDP			; big::set<unsigned int [8]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bigtypes.h
;	COMDAT ??$usetw@$$BY07I@big@@YAXAAY07II@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$usetw@$$BY07I@big@@YAXAAY07II@Z PROC			; big::usetw<unsigned int [8]>, COMDAT

; 294  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 295  : 		a[ 0 ] = b;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR [edx+ecx], eax

; 296  : 		memset( a + 1, 0, sizeof( T ) - sizeof( word ) );

	push	28					; 0000001cH
	push	0
	mov	eax, DWORD PTR _a$[ebp]
	add	eax, 4
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 297  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$usetw@$$BY07I@big@@YAXAAY07II@Z ENDP			; big::usetw<unsigned int [8]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rsacrypt.h
;	COMDAT ??$generateStrongPseudoPrime@$$BY03I@big@@YAXAAY03I@Z
_TEXT	SEGMENT
_index$1 = -8						; size = 4
_n$ = 8							; size = 4
??$generateStrongPseudoPrime@$$BY03I@big@@YAXAAY03I@Z PROC ; big::generateStrongPseudoPrime<unsigned int [4]>, COMDAT

; 1043 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
$LN6@generateSt:

; 1044 : 		do
; 1045 : 		{
; 1046 : 			int index;
; 1047 : 
; 1048 : 			for ( index = 0; index < (int) sizeof( n ) / (int) sizeof( n[ 0 ] ); index++ )

	mov	DWORD PTR _index$1[ebp], 0
	jmp	SHORT $LN3@generateSt
$LN2@generateSt:
	mov	eax, DWORD PTR _index$1[ebp]
	add	eax, 1
	mov	DWORD PTR _index$1[ebp], eax
$LN3@generateSt:
	cmp	DWORD PTR _index$1[ebp], 4
	jge	SHORT $LN1@generateSt

; 1049 : 				n[ index ] = randomMT();

	call	?randomMT@@YAIXZ			; randomMT
	mov	ecx, DWORD PTR _index$1[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
	jmp	SHORT $LN2@generateSt
$LN1@generateSt:

; 1050 : 
; 1051 : 			n[ BIGWORDCOUNT( T ) - 1 ] |= WORDHIGHBIT;

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	or	eax, -2147483648			; 80000000H
	mov	ecx, 4
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [ecx+edx], eax

; 1052 : 
; 1053 : 			//n[BIGWORDCOUNT(T) - 1] &= ~WORDHIGHBIT; n[BIGWORDCOUNT(T) - 1] |= WORDHIGHBIT >> 1;
; 1054 : 			n[ 0 ] |= 1;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	or	eax, 1
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [ecx+edx], eax

; 1055 : 		}
; 1056 : 
; 1057 : 		while ( !RabinMillerPrimalityTest( n, 5 ) );

	push	5
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	call	??$RabinMillerPrimalityTest@$$BY03I@big@@YA_NAAY03II@Z ; big::RabinMillerPrimalityTest<unsigned int [4]>
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@generateSt

; 1058 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$generateStrongPseudoPrime@$$BY03I@big@@YAXAAY03I@Z ENDP ; big::generateStrongPseudoPrime<unsigned int [4]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$ReadCompressed@I@BitStream@RakNet@@QAE_NAAI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 4
??$ReadCompressed@I@BitStream@RakNet@@QAE_NAAI@Z PROC	; RakNet::BitStream::ReadCompressed<unsigned int>, COMDAT
; _this$ = ecx

; 1080 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1081 : #ifdef _MSC_VER
; 1082 : #pragma warning(disable:4127)   // conditional expression is constant
; 1083 : #endif
; 1084 : 		if (sizeof(var)==1)

	xor	eax, eax
	je	SHORT $LN2@ReadCompre

; 1085 : 			return ReadCompressed( ( unsigned char* ) &var, sizeof(templateType) * 8, true );

	push	1
	push	32					; 00000020H
	mov	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadCompressed@BitStream@RakNet@@AAE_NPAEH_N@Z ; RakNet::BitStream::ReadCompressed
	jmp	SHORT $LN3@ReadCompre

; 1086 : 		else

	jmp	SHORT $LN3@ReadCompre
$LN2@ReadCompre:

; 1087 : 		{
; 1088 : #ifndef __BITSTREAM_NATIVE_END
; 1089 : 			if (DoEndianSwap())
; 1090 : 			{
; 1091 : 				unsigned char output[sizeof(templateType)];
; 1092 : 				if (ReadCompressed( ( unsigned char* ) output, sizeof(templateType) * 8, true ))
; 1093 : 				{
; 1094 : 					ReverseBytes(output, (unsigned char*)&var, sizeof(templateType));
; 1095 : 					return true;
; 1096 : 				}
; 1097 : 				return false;
; 1098 : 			}
; 1099 : 			else
; 1100 : #endif
; 1101 : 				return ReadCompressed( ( unsigned char* ) & var, sizeof(templateType) * 8, true );

	push	1
	push	32					; 00000020H
	mov	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadCompressed@BitStream@RakNet@@AAE_NPAEH_N@Z ; RakNet::BitStream::ReadCompressed
$LN3@ReadCompre:

; 1102 : 		}
; 1103 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$ReadCompressed@I@BitStream@RakNet@@QAE_NAAI@Z ENDP	; RakNet::BitStream::ReadCompressed<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$ReadCompressed@E@BitStream@RakNet@@QAE_NAAE@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 4
??$ReadCompressed@E@BitStream@RakNet@@QAE_NAAE@Z PROC	; RakNet::BitStream::ReadCompressed<unsigned char>, COMDAT
; _this$ = ecx

; 1080 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1081 : #ifdef _MSC_VER
; 1082 : #pragma warning(disable:4127)   // conditional expression is constant
; 1083 : #endif
; 1084 : 		if (sizeof(var)==1)

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN2@ReadCompre

; 1085 : 			return ReadCompressed( ( unsigned char* ) &var, sizeof(templateType) * 8, true );

	push	1
	push	8
	mov	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadCompressed@BitStream@RakNet@@AAE_NPAEH_N@Z ; RakNet::BitStream::ReadCompressed
	jmp	SHORT $LN3@ReadCompre

; 1086 : 		else

	jmp	SHORT $LN3@ReadCompre
$LN2@ReadCompre:

; 1087 : 		{
; 1088 : #ifndef __BITSTREAM_NATIVE_END
; 1089 : 			if (DoEndianSwap())
; 1090 : 			{
; 1091 : 				unsigned char output[sizeof(templateType)];
; 1092 : 				if (ReadCompressed( ( unsigned char* ) output, sizeof(templateType) * 8, true ))
; 1093 : 				{
; 1094 : 					ReverseBytes(output, (unsigned char*)&var, sizeof(templateType));
; 1095 : 					return true;
; 1096 : 				}
; 1097 : 				return false;
; 1098 : 			}
; 1099 : 			else
; 1100 : #endif
; 1101 : 				return ReadCompressed( ( unsigned char* ) & var, sizeof(templateType) * 8, true );

	push	1
	push	8
	mov	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadCompressed@BitStream@RakNet@@AAE_NPAEH_N@Z ; RakNet::BitStream::ReadCompressed
$LN3@ReadCompre:

; 1102 : 		}
; 1103 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$ReadCompressed@E@BitStream@RakNet@@QAE_NAAE@Z ENDP	; RakNet::BitStream::ReadCompressed<unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$WriteCompressed@I@BitStream@RakNet@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 4
??$WriteCompressed@I@BitStream@RakNet@@QAEXI@Z PROC	; RakNet::BitStream::WriteCompressed<unsigned int>, COMDAT
; _this$ = ecx

; 865  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 866  : #ifdef _MSC_VER
; 867  : #pragma warning(disable:4127)   // conditional expression is constant
; 868  : #endif
; 869  : 		if (sizeof(var)==1)

	xor	eax, eax
	je	SHORT $LN2@WriteCompr

; 870  : 			WriteCompressed( ( unsigned char* ) & var, sizeof( templateType ) * 8, true );

	push	1
	push	32					; 00000020H
	lea	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteCompressed@BitStream@RakNet@@AAEXPBEH_N@Z ; RakNet::BitStream::WriteCompressed

; 871  : 		else

	jmp	SHORT $LN3@WriteCompr
$LN2@WriteCompr:

; 872  : 		{
; 873  : #ifndef __BITSTREAM_NATIVE_END
; 874  : #ifdef _MSC_VER
; 875  : #pragma warning(disable:4244)   // '=' : conversion from 'unsigned long' to 'unsigned short', possible loss of data
; 876  : #endif
; 877  : 
; 878  : 			if (DoEndianSwap())
; 879  : 			{
; 880  : 				unsigned char output[sizeof(templateType)];
; 881  : 				ReverseBytes((unsigned char*)&var, output, sizeof(templateType));
; 882  : 				WriteCompressed( ( unsigned char* ) output, sizeof(templateType) * 8, true );
; 883  : 			}
; 884  : 			else
; 885  : #endif
; 886  : 				WriteCompressed( ( unsigned char* ) & var, sizeof(templateType) * 8, true );

	push	1
	push	32					; 00000020H
	lea	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteCompressed@BitStream@RakNet@@AAEXPBEH_N@Z ; RakNet::BitStream::WriteCompressed
$LN3@WriteCompr:

; 887  : 		}
; 888  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$WriteCompressed@I@BitStream@RakNet@@QAEXI@Z ENDP	; RakNet::BitStream::WriteCompressed<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$WriteCompressed@E@BitStream@RakNet@@QAEXE@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 1
??$WriteCompressed@E@BitStream@RakNet@@QAEXE@Z PROC	; RakNet::BitStream::WriteCompressed<unsigned char>, COMDAT
; _this$ = ecx

; 865  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 866  : #ifdef _MSC_VER
; 867  : #pragma warning(disable:4127)   // conditional expression is constant
; 868  : #endif
; 869  : 		if (sizeof(var)==1)

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN2@WriteCompr

; 870  : 			WriteCompressed( ( unsigned char* ) & var, sizeof( templateType ) * 8, true );

	push	1
	push	8
	lea	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteCompressed@BitStream@RakNet@@AAEXPBEH_N@Z ; RakNet::BitStream::WriteCompressed

; 871  : 		else

	jmp	SHORT $LN3@WriteCompr
$LN2@WriteCompr:

; 872  : 		{
; 873  : #ifndef __BITSTREAM_NATIVE_END
; 874  : #ifdef _MSC_VER
; 875  : #pragma warning(disable:4244)   // '=' : conversion from 'unsigned long' to 'unsigned short', possible loss of data
; 876  : #endif
; 877  : 
; 878  : 			if (DoEndianSwap())
; 879  : 			{
; 880  : 				unsigned char output[sizeof(templateType)];
; 881  : 				ReverseBytes((unsigned char*)&var, output, sizeof(templateType));
; 882  : 				WriteCompressed( ( unsigned char* ) output, sizeof(templateType) * 8, true );
; 883  : 			}
; 884  : 			else
; 885  : #endif
; 886  : 				WriteCompressed( ( unsigned char* ) & var, sizeof(templateType) * 8, true );

	push	1
	push	8
	lea	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteCompressed@BitStream@RakNet@@AAEXPBEH_N@Z ; RakNet::BitStream::WriteCompressed
$LN3@WriteCompr:

; 887  : 		}
; 888  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$WriteCompressed@E@BitStream@RakNet@@QAEXE@Z ENDP	; RakNet::BitStream::WriteCompressed<unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Write@E@BitStream@RakNet@@QAEXE@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 1
??$Write@E@BitStream@RakNet@@QAEXE@Z PROC		; RakNet::BitStream::Write<unsigned char>, COMDAT
; _this$ = ecx

; 729  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 730  : #ifdef _MSC_VER
; 731  : #pragma warning(disable:4127)   // conditional expression is constant
; 732  : #endif
; 733  : 		if (sizeof(var)==1)

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN2@Write

; 734  : 			WriteBits( ( unsigned char* ) & var, sizeof( templateType ) * 8, true );

	push	1
	push	8
	lea	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z ; RakNet::BitStream::WriteBits

; 735  : 		else

	jmp	SHORT $LN3@Write
$LN2@Write:

; 736  : 		{
; 737  : #ifndef __BITSTREAM_NATIVE_END
; 738  : 			if (DoEndianSwap())
; 739  : 			{
; 740  : 				unsigned char output[sizeof(templateType)];
; 741  : 				ReverseBytes((unsigned char*)&var, output, sizeof(templateType));
; 742  : 				WriteBits( ( unsigned char* ) output, sizeof(templateType) * 8, true );
; 743  : 			}
; 744  : 			else
; 745  : #endif
; 746  : 				WriteBits( ( unsigned char* ) & var, sizeof(templateType) * 8, true );

	push	1
	push	8
	lea	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z ; RakNet::BitStream::WriteBits
$LN3@Write:

; 747  : 		}
; 748  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$Write@E@BitStream@RakNet@@QAEXE@Z ENDP		; RakNet::BitStream::Write<unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rsacrypt.h
;	COMDAT ??$setPrivateKey@$$BY03I@?$RSACrypt@$$BY07I@big@@QAEXAAY03I0@Z
_TEXT	SEGMENT
_q1$ = -60						; size = 16
_p1$ = -36						; size = 16
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_c_p$ = 8						; size = 4
_c_q$ = 12						; size = 4
??$setPrivateKey@$$BY03I@?$RSACrypt@$$BY07I@big@@QAEXAAY03I0@Z PROC ; big::RSACrypt<unsigned int [8]>::setPrivateKey<unsigned int [4]>, COMDAT
; _this$ = ecx

; 1118 : 		BIGSMALLTYPE void setPrivateKey( Smaller &c_p, Smaller &c_q )

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		{
; 1120 : 			factorsAvailable = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+128], 1

; 1121 : 
; 1122 : 			// re-order factors s.t. q > p
; 1123 : 
; 1124 : 			if ( ugreater( c_p, c_q ) )

	mov	eax, DWORD PTR _c_q$[ebp]
	push	eax
	mov	ecx, DWORD PTR _c_p$[ebp]
	push	ecx
	call	??$ugreater@$$BY03I@big@@YA_NAAY03I0@Z	; big::ugreater<unsigned int [4]>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@setPrivate

; 1125 : 			{
; 1126 : 				set ( q, c_p )
; 1127 : 
; 1128 : 					;

	mov	eax, DWORD PTR _c_p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 241				; 000000f1H
	push	ecx
	call	??$set@$$BY03I@big@@YAXAAY03I0@Z	; big::set<unsigned int [4]>
	add	esp, 8

; 1129 : 				set ( p, c_q )
; 1130 : 
; 1131 : 					;

	mov	eax, DWORD PTR _c_q$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 193				; 000000c1H
	push	ecx
	call	??$set@$$BY03I@big@@YAXAAY03I0@Z	; big::set<unsigned int [4]>
	add	esp, 8

; 1132 : 			}
; 1133 : 
; 1134 : 			else

	jmp	SHORT $LN1@setPrivate
$LN2@setPrivate:

; 1135 : 			{
; 1136 : 				set ( p, c_p )
; 1137 : 
; 1138 : 					;

	mov	eax, DWORD PTR _c_p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 193				; 000000c1H
	push	ecx
	call	??$set@$$BY03I@big@@YAXAAY03I0@Z	; big::set<unsigned int [4]>
	add	esp, 8

; 1139 : 				set ( q, c_q )
; 1140 : 
; 1141 : 					;

	mov	eax, DWORD PTR _c_q$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 241				; 000000f1H
	push	ecx
	call	??$set@$$BY03I@big@@YAXAAY03I0@Z	; big::set<unsigned int [4]>
	add	esp, 8
$LN1@setPrivate:

; 1142 : 			}
; 1143 : 
; 1144 : 			// phi = (p - 1)(q - 1)
; 1145 : 			BIGHALFSIZE( T, p1 );
; 1146 : 
; 1147 : 			BIGHALFSIZE( T, q1 );
; 1148 : 
; 1149 : 			set ( p1, p )
; 1150 : 
; 1151 : 				;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 193				; 000000c1H
	push	eax
	lea	ecx, DWORD PTR _p1$[ebp]
	push	ecx
	call	??$set@$$BY03I@big@@YAXAAY03I0@Z	; big::set<unsigned int [4]>
	add	esp, 8

; 1152 : 			decrement( p1 );

	lea	eax, DWORD PTR _p1$[ebp]
	push	eax
	call	??$decrement@$$BY03I@big@@YAXAAY03I@Z	; big::decrement<unsigned int [4]>
	add	esp, 4

; 1153 : 
; 1154 : 			set ( q1, q )
; 1155 : 
; 1156 : 				;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 241				; 000000f1H
	push	eax
	lea	ecx, DWORD PTR _q1$[ebp]
	push	ecx
	call	??$set@$$BY03I@big@@YAXAAY03I0@Z	; big::set<unsigned int [4]>
	add	esp, 8

; 1157 : 			decrement( q1 );

	lea	eax, DWORD PTR _q1$[ebp]
	push	eax
	call	??$decrement@$$BY03I@big@@YAXAAY03I@Z	; big::decrement<unsigned int [4]>
	add	esp, 4

; 1158 : 
; 1159 : 			umultiply( p1, q1, phi );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 161				; 000000a1H
	push	eax
	lea	ecx, DWORD PTR _q1$[ebp]
	push	ecx
	lea	edx, DWORD PTR _p1$[ebp]
	push	edx
	call	??$umultiply@$$BY03I$$BY07I@big@@YAXAAY03I0AAY07I@Z ; big::umultiply<unsigned int [4],unsigned int [8]>
	add	esp, 12					; 0000000cH

; 1160 : 
; 1161 : 			// compute e
; 1162 : 			computePublicExponent( phi, e );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 161				; 000000a1H
	push	ecx
	call	??$computePublicExponent@$$BY07I@big@@YAXAAY07I0@Z ; big::computePublicExponent<unsigned int [8]>
	add	esp, 8

; 1163 : 
; 1164 : 			// compute d
; 1165 : 			computePrivateExponent( e, phi, d );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 129				; 00000081H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 161				; 000000a1H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$computePrivateExponent@$$BY07I@big@@YAXAAY07I00@Z ; big::computePrivateExponent<unsigned int [8]>
	add	esp, 12					; 0000000cH

; 1166 : 
; 1167 : 			// compute p^-1 mod q
; 1168 : 			computeModularInverse( p, q, pInverse );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 289				; 00000121H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 241				; 000000f1H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 193				; 000000c1H
	push	edx
	call	??$computeModularInverse@$$BY03I@big@@YAXAAY03I00@Z ; big::computeModularInverse<unsigned int [4]>
	add	esp, 12					; 0000000cH

; 1169 : 
; 1170 : 			// compute n = pq
; 1171 : 			umultiply( p, q, n );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 241				; 000000f1H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 193				; 000000c1H
	push	edx
	call	??$umultiply@$$BY03I$$BY07I@big@@YAXAAY03I0AAY07I@Z ; big::umultiply<unsigned int [4],unsigned int [8]>
	add	esp, 12					; 0000000cH

; 1172 : 
; 1173 : 			// find n'
; 1174 : 			computeNRinverse( n, np );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 64					; 00000040H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	call	??$computeNRinverse@$$BY07I@big@@YAXAAY07I0@Z ; big::computeNRinverse<unsigned int [8]>
	add	esp, 8

; 1175 : 
; 1176 : 			// x' = 1*r (mod n)
; 1177 : 			rModn( n, xp );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 96					; 00000060H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	call	??$rModn@$$BY07I@big@@YAXAAY07I0@Z	; big::rModn<unsigned int [8]>
	add	esp, 8

; 1178 : 
; 1179 : 			// find pn'
; 1180 : 			computeNRinverse( p, pnp );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 209				; 000000d1H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 193				; 000000c1H
	push	ecx
	call	??$computeNRinverse@$$BY03I@big@@YAXAAY03I0@Z ; big::computeNRinverse<unsigned int [4]>
	add	esp, 8

; 1181 : 
; 1182 : 			//   computeNRinverse2(p, pnp);
; 1183 : 
; 1184 : 			// px' = 1*r (mod p)
; 1185 : 			rModn( p, pxp );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 225				; 000000e1H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 193				; 000000c1H
	push	ecx
	call	??$rModn@$$BY03I@big@@YAXAAY03I0@Z	; big::rModn<unsigned int [4]>
	add	esp, 8

; 1186 : 
; 1187 : 			// find qn'
; 1188 : 			computeNRinverse( q, qnp );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 257				; 00000101H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 241				; 000000f1H
	push	ecx
	call	??$computeNRinverse@$$BY03I@big@@YAXAAY03I0@Z ; big::computeNRinverse<unsigned int [4]>
	add	esp, 8

; 1189 : 
; 1190 : 			// qx' = 1*r (mod q)
; 1191 : 			rModn( q, qxp );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 273				; 00000111H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 241				; 000000f1H
	push	ecx
	call	??$rModn@$$BY03I@big@@YAXAAY03I0@Z	; big::rModn<unsigned int [4]>
	add	esp, 8

; 1192 : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@setPrivate
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN8@setPrivate:
	DD	2
	DD	$LN7@setPrivate
$LN7@setPrivate:
	DD	-36					; ffffffdcH
	DD	16					; 00000010H
	DD	$LN5@setPrivate
	DD	-60					; ffffffc4H
	DD	16					; 00000010H
	DD	$LN6@setPrivate
$LN6@setPrivate:
	DB	113					; 00000071H
	DB	49					; 00000031H
	DB	0
$LN5@setPrivate:
	DB	112					; 00000070H
	DB	49					; 00000031H
	DB	0
??$setPrivateKey@$$BY03I@?$RSACrypt@$$BY07I@big@@QAEXAAY03I0@Z ENDP ; big::RSACrypt<unsigned int [8]>::setPrivateKey<unsigned int [4]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?AllocPacket@@YAPAUPacket@@IPAE@Z
_TEXT	SEGMENT
_p$ = -8						; size = 4
_dataSize$ = 8						; size = 4
_data$ = 12						; size = 4
?AllocPacket@@YAPAUPacket@@IPAE@Z PROC			; AllocPacket, COMDAT

; 150  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 151  : 	Packet *p = (Packet *)malloc(sizeof(Packet));

	push	21					; 00000015H
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _p$[ebp], eax

; 152  : 	p->data=data;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _data$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 153  : 	p->length=dataSize;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _dataSize$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 154  : 	p->deleteData=true;

	mov	eax, DWORD PTR _p$[ebp]
	mov	BYTE PTR [eax+20], 1

; 155  : 	return p;

	mov	eax, DWORD PTR _p$[ebp]

; 156  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?AllocPacket@@YAPAUPacket@@IPAE@Z ENDP			; AllocPacket
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?AllocPacket@@YAPAUPacket@@I@Z
_TEXT	SEGMENT
_p$ = -8						; size = 4
_dataSize$ = 8						; size = 4
?AllocPacket@@YAPAUPacket@@I@Z PROC			; AllocPacket, COMDAT

; 141  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 142  : 	Packet *p = (Packet *)malloc(sizeof(Packet)+dataSize);

	mov	eax, DWORD PTR _dataSize$[ebp]
	add	eax, 21					; 00000015H
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _p$[ebp], eax

; 143  : 	p->data=(unsigned char*)p+sizeof(Packet);

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 21					; 00000015H
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 144  : 	p->length=dataSize;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _dataSize$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 145  : 	p->deleteData=false;

	mov	eax, DWORD PTR _p$[ebp]
	mov	BYTE PTR [eax+20], 0

; 146  : 	return p;

	mov	eax, DWORD PTR _p$[ebp]

; 147  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?AllocPacket@@YAPAUPacket@@I@Z ENDP			; AllocPacket
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GHuffmanEncodingTree@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GHuffmanEncodingTree@@QAEPAXI@Z PROC			; HuffmanEncodingTree::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1HuffmanEncodingTree@@QAE@XZ		; HuffmanEncodingTree::~HuffmanEncodingTree
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GHuffmanEncodingTree@@QAEPAXI@Z ENDP			; HuffmanEncodingTree::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GRakPeer@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GRakPeer@@UAEPAXI@Z PROC				; RakPeer::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1RakPeer@@UAE@XZ			; RakPeer::~RakPeer
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GRakPeer@@UAEPAXI@Z ENDP				; RakPeer::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ?Clear@?$Queue@PAUPacket@@@DataStructures@@QAEXXZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
?Clear@?$Queue@PAUPacket@@@DataStructures@@QAEXXZ PROC	; DataStructures::Queue<Packet *>::Clear, COMDAT
; _this$ = ecx

; 285  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 286  : 		if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN2@Clear

; 287  : 			return ;

	jmp	SHORT $LN3@Clear
$LN2@Clear:

; 288  : 
; 289  : 		if (allocation_size > 32)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 32			; 00000020H
	jbe	SHORT $LN1@Clear

; 290  : 		{
; 291  : 			delete[] array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 292  : 			allocation_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
$LN1@Clear:

; 293  : 		}
; 294  : 
; 295  : 		head = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 296  : 		tail = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
$LN3@Clear:

; 297  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$Queue@PAUPacket@@@DataStructures@@QAEXXZ ENDP	; DataStructures::Queue<Packet *>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ?Size@?$Queue@PAUPacket@@@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$Queue@PAUPacket@@@DataStructures@@QBEIXZ PROC	; DataStructures::Queue<Packet *>::Size, COMDAT
; _this$ = ecx

; 62   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 63   : 		if ( head <= tail )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	ja	SHORT $LN2@Size

; 64   : 			return tail -head;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	jmp	SHORT $LN3@Size

; 65   : 		else

	jmp	SHORT $LN3@Size
$LN2@Size:

; 66   : 			return allocation_size -head + tail;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx+8]
$LN3@Size:

; 67   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$Queue@PAUPacket@@@DataStructures@@QBEIXZ ENDP	; DataStructures::Queue<Packet *>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ?Pop@?$Queue@PAUPacket@@@DataStructures@@QAEPAUPacket@@XZ
_TEXT	SEGMENT
tv78 = -208						; size = 4
_this$ = -8						; size = 4
?Pop@?$Queue@PAUPacket@@@DataStructures@@QAEPAUPacket@@XZ PROC ; DataStructures::Queue<Packet *>::Pop, COMDAT
; _this$ = ecx

; 99   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 100  : #ifdef _DEBUG
; 101  : 		assert( allocation_size > 0 && Size() >= 0 && head != tail);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jbe	SHORT $LN5@Pop
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$Queue@PAUPacket@@@DataStructures@@QBEIXZ ; DataStructures::Queue<Packet *>::Size
	test	eax, eax
	jb	SHORT $LN5@Pop
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN6@Pop
$LN5@Pop:
	push	101					; 00000065H
	push	OFFSET ??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@
	push	OFFSET ??_C@_1GG@JDEIIJCO@?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN6@Pop:

; 102  : #endif
; 103  : 		//head=(head+1) % allocation_size;
; 104  : 
; 105  : 		if ( ++head == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	DWORD PTR tv78[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv78[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv78[ebp]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN2@Pop

; 106  : 			head = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
$LN2@Pop:

; 107  : 
; 108  : 		if ( head == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN1@Pop

; 109  : 			return ( queue_type ) array[ allocation_size -1 ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+ecx*4-4]
	jmp	SHORT $LN3@Pop
$LN1@Pop:

; 110  : 
; 111  : 		return ( queue_type ) array[ head -1 ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+ecx*4-4]
$LN3@Pop:

; 112  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Pop@?$Queue@PAUPacket@@@DataStructures@@QAEPAUPacket@@XZ ENDP ; DataStructures::Queue<Packet *>::Pop
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ??A?$Queue@PAUPacket@@@DataStructures@@QBEAAPAUPacket@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
??A?$Queue@PAUPacket@@@DataStructures@@QBEAAPAUPacket@@I@Z PROC ; DataStructures::Queue<Packet *>::operator[], COMDAT
; _this$ = ecx

; 356  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 357  : #ifdef _DEBUG
; 358  : 		assert( position < Size() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$Queue@PAUPacket@@@DataStructures@@QBEIXZ ; DataStructures::Queue<Packet *>::Size
	cmp	DWORD PTR _position$[ebp], eax
	jb	SHORT $LN5@operator
	push	358					; 00000166H
	push	OFFSET ??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@
	push	OFFSET ??_C@_1CE@CLDOPLDF@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN5@operator:

; 359  : #endif
; 360  : 		//return array[(head + position) % allocation_size];
; 361  : 
; 362  : 		if ( head + position >= allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _position$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [edx+12]
	jb	SHORT $LN2@operator

; 363  : 			return array[ head + position - allocation_size ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _position$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	sub	ecx, DWORD PTR [edx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	lea	eax, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN3@operator

; 364  : 		else

	jmp	SHORT $LN3@operator
$LN2@operator:

; 365  : 			return array[ head + position ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _position$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	eax, DWORD PTR [eax+ecx*4]
$LN3@operator:

; 366  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$Queue@PAUPacket@@@DataStructures@@QBEAAPAUPacket@@I@Z ENDP ; DataStructures::Queue<Packet *>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ?PushAtHead@?$Queue@PAUPacket@@@DataStructures@@QAEXABQAUPacket@@I@Z
_TEXT	SEGMENT
$T1 = -272						; size = 4
$T2 = -260						; size = 4
$T3 = -248						; size = 4
_counter$4 = -44					; size = 4
_new_array$5 = -32					; size = 4
_count$ = -20						; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
_index$ = 12						; size = 4
?PushAtHead@?$Queue@PAUPacket@@@DataStructures@@QAEXABQAUPacket@@I@Z PROC ; DataStructures::Queue<Packet *>::PushAtHead, COMDAT
; _this$ = ecx

; 116  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-276]
	mov	ecx, 69					; 00000045H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 117  : 		if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN9@PushAtHead

; 118  : 		{
; 119  : 			array = new queue_type[ 16 ];

	push	64					; 00000040H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax], ecx

; 120  : 			head = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 121  : 			tail = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 1

; 122  : 			array[ 0 ] = input;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+eax], edx

; 123  : 			allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 16			; 00000010H

; 124  : 			return ;

	jmp	$LN10@PushAtHead
$LN9@PushAtHead:

; 125  : 		}
; 126  : 
; 127  : 		if ( head == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN8@PushAtHead

; 128  : 			head = allocation_size - 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 129  : 		else

	jmp	SHORT $LN7@PushAtHead
$LN8@PushAtHead:

; 130  : 			--head;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
$LN7@PushAtHead:

; 131  : 
; 132  : 		unsigned count=0;

	mov	DWORD PTR _count$[ebp], 0
$LN6@PushAtHead:

; 133  : 		while (count < index)

	mov	eax, DWORD PTR _count$[ebp]
	cmp	eax, DWORD PTR _index$[ebp]
	jae	SHORT $LN5@PushAtHead

; 134  : 		{
; 135  : 			array[head+count]=array[head+count+1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _count$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+4]
	add	edx, DWORD PTR _count$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+ecx*4+4]
	mov	DWORD PTR [esi+edx*4], eax

; 136  : 			count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 137  : 		}

	jmp	SHORT $LN6@PushAtHead
$LN5@PushAtHead:

; 138  : 		array[ head+count ] = input;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _count$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [eax+ecx*4], edx

; 139  : 
; 140  : 		if ( tail == head )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+4]
	jne	$LN10@PushAtHead

; 141  : 		{
; 142  : 			//  unsigned int index=tail;
; 143  : 
; 144  : 			// Need to allocate more memory.
; 145  : 			queue_type * new_array;
; 146  : 			new_array = new queue_type[ allocation_size * 2 ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	shl	eax, 1
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _new_array$5[ebp], eax

; 147  : #ifdef _DEBUG
; 148  : 
; 149  : 			assert( new_array );

	cmp	DWORD PTR _new_array$5[ebp], 0
	jne	SHORT $LN12@PushAtHead
	push	149					; 00000095H
	push	OFFSET ??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@
	push	OFFSET ??_C@_1BE@OMEGJCHO@?$AAn?$AAe?$AAw?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN12@PushAtHead:

; 150  : #endif
; 151  : 
; 152  : 			for ( unsigned int counter = 0; counter < allocation_size; ++counter )

	mov	DWORD PTR _counter$4[ebp], 0
	jmp	SHORT $LN3@PushAtHead
$LN2@PushAtHead:
	mov	eax, DWORD PTR _counter$4[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$4[ebp], eax
$LN3@PushAtHead:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _counter$4[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN1@PushAtHead

; 153  : 				new_array[ counter ] = array[ ( head + counter ) % ( allocation_size ) ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, DWORD PTR _counter$4[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _counter$4[ebp]
	mov	esi, DWORD PTR _new_array$5[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [esi+eax*4], ecx
	jmp	SHORT $LN2@PushAtHead
$LN1@PushAtHead:

; 154  : 
; 155  : 			head = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 156  : 
; 157  : 			tail = allocation_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+8], edx

; 158  : 
; 159  : 			allocation_size *= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 160  : 
; 161  : 			// Delete the old array and move the pointer to the new array
; 162  : 			delete [] array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T3[ebp], ecx
	mov	edx, DWORD PTR $T3[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 163  : 
; 164  : 			array = new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$5[ebp]
	mov	DWORD PTR [eax], ecx
$LN10@PushAtHead:

; 165  : 		}
; 166  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?PushAtHead@?$Queue@PAUPacket@@@DataStructures@@QAEXABQAUPacket@@I@Z ENDP ; DataStructures::Queue<Packet *>::PushAtHead
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ?Push@?$Queue@PAUPacket@@@DataStructures@@QAEXABQAUPacket@@@Z
_TEXT	SEGMENT
$T1 = -260						; size = 4
$T2 = -248						; size = 4
$T3 = -236						; size = 4
_counter$4 = -32					; size = 4
_new_array$5 = -20					; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
?Push@?$Queue@PAUPacket@@@DataStructures@@QAEXABQAUPacket@@@Z PROC ; DataStructures::Queue<Packet *>::Push, COMDAT
; _this$ = ecx

; 182  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 183  : 		if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN6@Push

; 184  : 		{
; 185  : 			array = new queue_type[ 16 ];

	push	64					; 00000040H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax], ecx

; 186  : 			head = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 187  : 			tail = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 1

; 188  : 			array[ 0 ] = input;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+eax], edx

; 189  : 			allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 16			; 00000010H

; 190  : 			return ;

	jmp	$LN7@Push
$LN6@Push:

; 191  : 		}
; 192  : 
; 193  : 		array[ tail++ ] = input;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [eax+ecx*4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 194  : 
; 195  : 		if ( tail == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN5@Push

; 196  : 			tail = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
$LN5@Push:

; 197  : 
; 198  : 		if ( tail == head )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+4]
	jne	$LN7@Push

; 199  : 		{
; 200  : 			//  unsigned int index=tail;
; 201  : 
; 202  : 			// Need to allocate more memory.
; 203  : 			queue_type * new_array;
; 204  : 			new_array = new queue_type[ allocation_size * 2 ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	shl	eax, 1
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _new_array$5[ebp], eax

; 205  : #ifdef _DEBUG
; 206  : 
; 207  : 			assert( new_array );

	cmp	DWORD PTR _new_array$5[ebp], 0
	jne	SHORT $LN9@Push
	push	207					; 000000cfH
	push	OFFSET ??_C@_1EG@DIEEECKO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAq?$AAu?$AAe?$AAu?$AAe@
	push	OFFSET ??_C@_1BE@OMEGJCHO@?$AAn?$AAe?$AAw?$AA_?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN9@Push:

; 208  : #endif
; 209  : 
; 210  : 			for ( unsigned int counter = 0; counter < allocation_size; ++counter )

	mov	DWORD PTR _counter$4[ebp], 0
	jmp	SHORT $LN3@Push
$LN2@Push:
	mov	eax, DWORD PTR _counter$4[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$4[ebp], eax
$LN3@Push:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _counter$4[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN1@Push

; 211  : 				new_array[ counter ] = array[ ( head + counter ) % ( allocation_size ) ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, DWORD PTR _counter$4[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	div	DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _counter$4[ebp]
	mov	esi, DWORD PTR _new_array$5[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [esi+eax*4], ecx
	jmp	SHORT $LN2@Push
$LN1@Push:

; 212  : 
; 213  : 			head = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 214  : 
; 215  : 			tail = allocation_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+8], edx

; 216  : 
; 217  : 			allocation_size *= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 218  : 
; 219  : 			// Delete the old array and move the pointer to the new array
; 220  : 			delete [] array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T3[ebp], ecx
	mov	edx, DWORD PTR $T3[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 221  : 
; 222  : 			array = new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$5[ebp]
	mov	DWORD PTR [eax], ecx
$LN7@Push:

; 223  : 		}
; 224  : 
; 225  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Push@?$Queue@PAUPacket@@@DataStructures@@QAEXABQAUPacket@@@Z ENDP ; DataStructures::Queue<Packet *>::Push
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ??1?$Queue@PAUPacket@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
??1?$Queue@PAUPacket@@@DataStructures@@QAE@XZ PROC	; DataStructures::Queue<Packet *>::~Queue<Packet *>, COMDAT
; _this$ = ecx

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		if (allocation_size>0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jbe	SHORT $LN2@Queue

; 94   : 			delete [] array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@Queue:

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$Queue@PAUPacket@@@DataStructures@@QAE@XZ ENDP	; DataStructures::Queue<Packet *>::~Queue<Packet *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_queue.h
;	COMDAT ??0?$Queue@PAUPacket@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
??0?$Queue@PAUPacket@@@DataStructures@@QAE@XZ PROC	; DataStructures::Queue<Packet *>::Queue<Packet *>, COMDAT
; _this$ = ecx

; 83   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 84   : 		allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 16			; 00000010H

; 85   : 		array = new queue_type[ allocation_size ];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax], ecx

; 86   : 		head = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 87   : 		tail = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 88   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$Queue@PAUPacket@@@DataStructures@@QAE@XZ ENDP	; DataStructures::Queue<Packet *>::Queue<Packet *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\singleproducerconsumer.h
;	COMDAT ?Clear@?$SingleProducerConsumer@PAUPacket@@@DataStructures@@QAEXXZ
_TEXT	SEGMENT
tv79 = -248						; size = 4
tv78 = -244						; size = 4
$T1 = -236						; size = 4
_listSize$ = -32					; size = 4
_next$ = -20						; size = 4
_this$ = -8						; size = 4
?Clear@?$SingleProducerConsumer@PAUPacket@@@DataStructures@@QAEXXZ PROC ; DataStructures::SingleProducerConsumer<Packet *>::Clear, COMDAT
; _this$ = ecx

; 216  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 248				; 000000f8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-248]
	mov	ecx, 62					; 0000003eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 217  : 		// Shrink the list down to MINIMUM_LIST_SIZE elements
; 218  : 		volatile DataPlusPtr *next;
; 219  : 		writePointer=readPointer->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+5]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 220  : 
; 221  : 		int listSize=1;

	mov	DWORD PTR _listSize$[ebp], 1

; 222  : 		next=readPointer->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+5]
	mov	DWORD PTR _next$[ebp], edx
$LN4@Clear:

; 223  : 		while (next!=readPointer)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _next$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	je	SHORT $LN2@Clear

; 224  : 		{
; 225  : 			listSize++;

	mov	eax, DWORD PTR _listSize$[ebp]
	add	eax, 1
	mov	DWORD PTR _listSize$[ebp], eax

; 226  : 			next=next->next;

	mov	eax, DWORD PTR _next$[ebp]
	mov	ecx, DWORD PTR [eax+5]
	mov	DWORD PTR _next$[ebp], ecx

; 227  : 		}

	jmp	SHORT $LN4@Clear
$LN2@Clear:

; 228  : 
; 229  : 		while (listSize-- > MINIMUM_LIST_SIZE)

	mov	eax, DWORD PTR _listSize$[ebp]
	mov	DWORD PTR tv78[ebp], eax
	mov	ecx, DWORD PTR _listSize$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _listSize$[ebp], ecx
	cmp	DWORD PTR tv78[ebp], 8
	jle	SHORT $LN7@Clear
	mov	DWORD PTR tv79[ebp], 1
	jmp	SHORT $LN8@Clear
$LN7@Clear:
	mov	DWORD PTR tv79[ebp], 0
$LN8@Clear:
	cmp	DWORD PTR tv79[ebp], 0
	je	SHORT $LN1@Clear

; 230  : 		{
; 231  : 			next=writePointer->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+5]
	mov	DWORD PTR _next$[ebp], edx

; 232  : #ifdef _DEBUG
; 233  : 			assert(writePointer!=readPointer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN9@Clear
	push	233					; 000000e9H
	push	OFFSET ??_C@_1GC@EGJKEKIF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAs?$AAi?$AAn?$AAg?$AAl?$AAe?$AAp?$AAr@
	push	OFFSET ??_C@_1DE@FCOMCLAG@?$AAw?$AAr?$AAi?$AAt?$AAe?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$CB?$AA?$DN?$AAr?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN9@Clear:

; 234  : #endif
; 235  : 			delete (char*) writePointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 236  : 			writePointer=next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _next$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 237  : 		}

	jmp	$LN2@Clear
$LN1@Clear:

; 238  : 
; 239  : 		readPointer->next=writePointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+5], eax

; 240  : 		writePointer=readPointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+12], edx

; 241  : 		readAheadPointer=readPointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], edx

; 242  : 		writeAheadPointer=writePointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+4], edx

; 243  : 		readCount=writeCount=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 244  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 248				; 000000f8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$SingleProducerConsumer@PAUPacket@@@DataStructures@@QAEXXZ ENDP ; DataStructures::SingleProducerConsumer<Packet *>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\singleproducerconsumer.h
;	COMDAT ?ReadUnlock@?$SingleProducerConsumer@PAUPacket@@@DataStructures@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?ReadUnlock@?$SingleProducerConsumer@PAUPacket@@@DataStructures@@QAEXXZ PROC ; DataStructures::SingleProducerConsumer<Packet *>::ReadUnlock, COMDAT
; _this$ = ecx

; 202  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 203  : #ifdef _DEBUG
; 204  : 		assert(readAheadPointer!=readPointer); // If hits, then called ReadUnlock before ReadLock

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN3@ReadUnlock
	push	204					; 000000ccH
	push	OFFSET ??_C@_1GC@EGJKEKIF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAs?$AAi?$AAn?$AAg?$AAl?$AAe?$AAp?$AAr@
	push	OFFSET ??_C@_1DM@HLMOCDPL@?$AAr?$AAe?$AAa?$AAd?$AAA?$AAh?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$CB?$AA?$DN?$AAr?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@ReadUnlock:

; 205  : 		assert(readPointer!=writePointer); // If hits, then called ReadUnlock when Read returns 0

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN4@ReadUnlock
	push	205					; 000000cdH
	push	OFFSET ??_C@_1GC@EGJKEKIF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAs?$AAi?$AAn?$AAg?$AAl?$AAe?$AAp?$AAr@
	push	OFFSET ??_C@_1DE@PPJJMKJI@?$AAr?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$CB?$AA?$DN?$AAw?$AAr?$AAi?$AAt?$AAe?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@ReadUnlock:

; 206  : #endif
; 207  : 		readCount++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 208  : 
; 209  : 		// Allow writes to this memory block
; 210  : 		readPointer->readyToRead=false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	BYTE PTR [ecx+4], 0

; 211  : 		readPointer=readPointer->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+5]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 212  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadUnlock@?$SingleProducerConsumer@PAUPacket@@@DataStructures@@QAEXXZ ENDP ; DataStructures::SingleProducerConsumer<Packet *>::ReadUnlock
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\singleproducerconsumer.h
;	COMDAT ?ReadLock@?$SingleProducerConsumer@PAUPacket@@@DataStructures@@QAEPAPAUPacket@@XZ
_TEXT	SEGMENT
_last$ = -20						; size = 4
_this$ = -8						; size = 4
?ReadLock@?$SingleProducerConsumer@PAUPacket@@@DataStructures@@QAEPAPAUPacket@@XZ PROC ; DataStructures::SingleProducerConsumer<Packet *>::ReadLock, COMDAT
; _this$ = ecx

; 178  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 179  : 			if (readAheadPointer==writePointer ||
; 180  : 				readAheadPointer->readyToRead==false)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+12]
	je	SHORT $LN1@ReadLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN2@ReadLock
$LN1@ReadLock:

; 181  : 			{
; 182  : 				return 0;

	xor	eax, eax
	jmp	SHORT $LN3@ReadLock
$LN2@ReadLock:

; 183  : 			}
; 184  : 
; 185  : 			volatile DataPlusPtr *last;
; 186  : 			last=readAheadPointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _last$[ebp], ecx

; 187  : 			readAheadPointer=readAheadPointer->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+5]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], edx

; 188  : 			return (SingleProducerConsumerType*)last;

	mov	eax, DWORD PTR _last$[ebp]
$LN3@ReadLock:

; 189  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadLock@?$SingleProducerConsumer@PAUPacket@@@DataStructures@@QAEPAPAUPacket@@XZ ENDP ; DataStructures::SingleProducerConsumer<Packet *>::ReadLock
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\singleproducerconsumer.h
;	COMDAT ?WriteUnlock@?$SingleProducerConsumer@PAUPacket@@@DataStructures@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?WriteUnlock@?$SingleProducerConsumer@PAUPacket@@@DataStructures@@QAEXXZ PROC ; DataStructures::SingleProducerConsumer<Packet *>::WriteUnlock, COMDAT
; _this$ = ecx

; 162  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 163  : 		//	DataPlusPtr *dataContainer = (DataPlusPtr *)structure;
; 164  : 
; 165  : #ifdef _DEBUG
; 166  : 		assert(writePointer->next!=readPointer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+5]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $LN3@WriteUnloc
	push	166					; 000000a6H
	push	OFFSET ??_C@_1GC@EGJKEKIF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAs?$AAi?$AAn?$AAg?$AAl?$AAe?$AAp?$AAr@
	push	OFFSET ??_C@_1EA@OAIJHOON@?$AAw?$AAr?$AAi?$AAt?$AAe?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AA?$CB?$AA?$DN?$AAr?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@WriteUnloc:

; 167  : 		assert(writePointer!=writeAheadPointer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@WriteUnloc
	push	167					; 000000a7H
	push	OFFSET ??_C@_1GC@EGJKEKIF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAs?$AAi?$AAn?$AAg?$AAl?$AAe?$AAp?$AAr@
	push	OFFSET ??_C@_1EA@LEKNHFBP@?$AAw?$AAr?$AAi?$AAt?$AAe?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$CB?$AA?$DN?$AAw?$AAr?$AAi?$AAt?$AAe?$AAA?$AAh?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@WriteUnloc:

; 168  : #endif
; 169  : 
; 170  : 		writeCount++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 171  : 		// User is done with the data, allow send by updating the write pointer
; 172  : 		writePointer->readyToRead=true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	BYTE PTR [ecx+4], 1

; 173  : 		writePointer=writePointer->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+5]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 174  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?WriteUnlock@?$SingleProducerConsumer@PAUPacket@@@DataStructures@@QAEXXZ ENDP ; DataStructures::SingleProducerConsumer<Packet *>::WriteUnlock
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\singleproducerconsumer.h
;	COMDAT ?WriteLock@?$SingleProducerConsumer@PAUPacket@@@DataStructures@@QAEPAPAUPacket@@XZ
_TEXT	SEGMENT
$T1 = -236						; size = 4
_last$ = -32						; size = 4
_originalNext$2 = -20					; size = 4
_this$ = -8						; size = 4
?WriteLock@?$SingleProducerConsumer@PAUPacket@@@DataStructures@@QAEPAPAUPacket@@XZ PROC ; DataStructures::SingleProducerConsumer<Packet *>::WriteLock, COMDAT
; _this$ = ecx

; 137  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 138  : 		if (writeAheadPointer->next==readPointer ||
; 139  : 			writeAheadPointer->next->readyToRead==true)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+5]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR [eax+8]
	je	SHORT $LN1@WriteLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+5]
	movzx	eax, BYTE PTR [edx+4]
	cmp	eax, 1
	jne	SHORT $LN2@WriteLock
$LN1@WriteLock:

; 140  : 		{
; 141  : 			volatile DataPlusPtr *originalNext=writeAheadPointer->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+5]
	mov	DWORD PTR _originalNext$2[ebp], edx

; 142  : 			writeAheadPointer->next=new DataPlusPtr;

	push	9
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [ecx+5], edx

; 143  : 			assert(writeAheadPointer->next);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+5], 0
	jne	SHORT $LN5@WriteLock
	push	143					; 0000008fH
	push	OFFSET ??_C@_1GC@EGJKEKIF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAs?$AAi?$AAn?$AAg?$AAl?$AAe?$AAp?$AAr@
	push	OFFSET ??_C@_1DA@FABPCGM@?$AAw?$AAr?$AAi?$AAt?$AAe?$AAA?$AAh?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN5@WriteLock:

; 144  : 			writeAheadPointer->next->next=originalNext;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+5]
	mov	eax, DWORD PTR _originalNext$2[ebp]
	mov	DWORD PTR [edx+5], eax
$LN2@WriteLock:

; 145  : 		}
; 146  : 
; 147  : 		volatile DataPlusPtr *last;
; 148  : 		last=writeAheadPointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _last$[ebp], ecx

; 149  : 		writeAheadPointer=writeAheadPointer->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+5]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 150  : 
; 151  : 		return (SingleProducerConsumerType*) last;

	mov	eax, DWORD PTR _last$[ebp]

; 152  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?WriteLock@?$SingleProducerConsumer@PAUPacket@@@DataStructures@@QAEPAPAUPacket@@XZ ENDP ; DataStructures::SingleProducerConsumer<Packet *>::WriteLock
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\singleproducerconsumer.h
;	COMDAT ??1?$SingleProducerConsumer@PAUPacket@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T1 = -236						; size = 4
$T2 = -224						; size = 4
_next$ = -20						; size = 4
_this$ = -8						; size = 4
??1?$SingleProducerConsumer@PAUPacket@@@DataStructures@@QAE@XZ PROC ; DataStructures::SingleProducerConsumer<Packet *>::~SingleProducerConsumer<Packet *>, COMDAT
; _this$ = ecx

; 123  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		volatile DataPlusPtr *next;
; 125  : 		readPointer=writeAheadPointer->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+5]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx
$LN2@SingleProd:

; 126  : 		while (readPointer!=writeAheadPointer)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+4]
	je	SHORT $LN1@SingleProd

; 127  : 		{
; 128  : 			next=readPointer->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+5]
	mov	DWORD PTR _next$[ebp], edx

; 129  : 			delete (char*) readPointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 130  : 			readPointer=next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _next$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 131  : 		}

	jmp	SHORT $LN2@SingleProd
$LN1@SingleProd:

; 132  : 		delete (char*) readPointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 133  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$SingleProducerConsumer@PAUPacket@@@DataStructures@@QAE@XZ ENDP ; DataStructures::SingleProducerConsumer<Packet *>::~SingleProducerConsumer<Packet *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\singleproducerconsumer.h
;	COMDAT ??0?$SingleProducerConsumer@PAUPacket@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T1 = -248						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_listSize$ = -20					; size = 4
_this$ = -8						; size = 4
??0?$SingleProducerConsumer@PAUPacket@@@DataStructures@@QAE@XZ PROC ; DataStructures::SingleProducerConsumer<Packet *>::SingleProducerConsumer<Packet *>, COMDAT
; _this$ = ecx

; 100  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 101  : 		// Preallocate
; 102  : 		readPointer = new DataPlusPtr;

	push	9
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax+8], ecx

; 103  : 		writePointer=readPointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+12], edx

; 104  : 		readPointer->next = new DataPlusPtr;

	push	9
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [ecx+5], edx

; 105  : 		int listSize;
; 106  : #ifdef _DEBUG
; 107  : 		assert(MINIMUM_LIST_SIZE>=3);
; 108  : #endif
; 109  : 		for (listSize=2; listSize < MINIMUM_LIST_SIZE; listSize++)

	mov	DWORD PTR _listSize$[ebp], 2
	jmp	SHORT $LN3@SingleProd
$LN2@SingleProd:
	mov	eax, DWORD PTR _listSize$[ebp]
	add	eax, 1
	mov	DWORD PTR _listSize$[ebp], eax
$LN3@SingleProd:
	cmp	DWORD PTR _listSize$[ebp], 8
	jge	SHORT $LN1@SingleProd

; 110  : 		{
; 111  : 			readPointer=readPointer->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+5]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 112  : 			readPointer->next = new DataPlusPtr;

	push	9
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR [ecx+5], edx

; 113  : 		}

	jmp	SHORT $LN2@SingleProd
$LN1@SingleProd:

; 114  : 		readPointer->next->next=writePointer; // last to next = start

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+5]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+5], ecx

; 115  : 		readPointer=writePointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+8], edx

; 116  : 		readAheadPointer=readPointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], edx

; 117  : 		writeAheadPointer=writePointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+4], edx

; 118  : 		readCount=writeCount=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 119  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$SingleProducerConsumer@PAUPacket@@@DataStructures@@QAE@XZ ENDP ; DataStructures::SingleProducerConsumer<Packet *>::SingleProducerConsumer<Packet *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rsacrypt.h
;	COMDAT ?decrypt@?$RSACrypt@$$BY07I@big@@QAEXAAY07I0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_C$ = 8							; size = 4
_x$ = 12						; size = 4
?decrypt@?$RSACrypt@$$BY07I@big@@QAEXAAY07I0@Z PROC	; big::RSACrypt<unsigned int [8]>::decrypt, COMDAT
; _this$ = ecx

; 1241 : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1242 : 			if ( factorsAvailable )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+128]
	test	ecx, ecx
	je	SHORT $LN2@decrypt

; 1243 : 				CRTModExp( x, C, d, p, q, pInverse, pnp, pxp, qnp, qxp );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 273				; 00000111H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 257				; 00000101H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 225				; 000000e1H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 209				; 000000d1H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 289				; 00000121H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 241				; 000000f1H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 193				; 000000c1H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 129				; 00000081H
	push	ecx
	mov	edx, DWORD PTR _C$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	??$CRTModExp@$$BY03I$$BY07I@big@@YAXAAY07I00AAY03I111111@Z ; big::CRTModExp<unsigned int [4],unsigned int [8]>
	add	esp, 40					; 00000028H
$LN2@decrypt:

; 1244 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?decrypt@?$RSACrypt@$$BY07I@big@@QAEXAAY07I0@Z ENDP	; big::RSACrypt<unsigned int [8]>::decrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rsacrypt.h
;	COMDAT ?encrypt@?$RSACrypt@$$BY07I@big@@QAEXAAY07I0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_M$ = 8							; size = 4
_x$ = 12						; size = 4
?encrypt@?$RSACrypt@$$BY07I@big@@QAEXAAY07I0@Z PROC	; big::RSACrypt<unsigned int [8]>::encrypt, COMDAT
; _this$ = ecx

; 1233 : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1234 : 			if ( factorsAvailable )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+128]
	test	ecx, ecx
	je	SHORT $LN2@encrypt

; 1235 : 				CRTModExp( x, M, e, p, q, pInverse, pnp, pxp, qnp, qxp );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 273				; 00000111H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 257				; 00000101H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 225				; 000000e1H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 209				; 000000d1H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 289				; 00000121H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 241				; 000000f1H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 193				; 000000c1H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _M$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	??$CRTModExp@$$BY03I$$BY07I@big@@YAXAAY07I00AAY03I111111@Z ; big::CRTModExp<unsigned int [4],unsigned int [8]>
	add	esp, 40					; 00000028H

; 1236 : 			else

	jmp	SHORT $LN3@encrypt
$LN2@encrypt:

; 1237 : 				simpleModExp( M, e, n, x );

	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _M$[ebp]
	push	eax
	call	??$simpleModExp@$$BY07I@big@@YAXAAY07I000@Z ; big::simpleModExp<unsigned int [8]>
	add	esp, 16					; 00000010H
$LN3@encrypt:

; 1238 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?encrypt@?$RSACrypt@$$BY07I@big@@QAEXAAY07I0@Z ENDP	; big::RSACrypt<unsigned int [8]>::encrypt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rsacrypt.h
;	COMDAT ?getPublicKey@?$RSACrypt@$$BY07I@big@@QAEXAAIAAY07I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_c_e$ = 8						; size = 4
_c_n$ = 12						; size = 4
?getPublicKey@?$RSACrypt@$$BY07I@big@@QAEXAAIAAY07I@Z PROC ; big::RSACrypt<unsigned int [8]>::getPublicKey, COMDAT
; _this$ = ecx

; 1213 : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1214 : 			c_e = e[ 0 ];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _c_e$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+ecx]
	mov	DWORD PTR [edx], ecx

; 1215 : 
; 1216 : 			set ( c_n, n )
; 1217 : 
; 1218 : 				;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	mov	ecx, DWORD PTR _c_n$[ebp]
	push	ecx
	call	??$set@$$BY07I@big@@YAXAAY07I0@Z	; big::set<unsigned int [8]>
	add	esp, 8

; 1219 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?getPublicKey@?$RSACrypt@$$BY07I@big@@QAEXAAIAAY07I@Z ENDP ; big::RSACrypt<unsigned int [8]>::getPublicKey
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rsacrypt.h
;	COMDAT ?setPublicKey@?$RSACrypt@$$BY07I@big@@QAEXIAAY07I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_c_e$ = 8						; size = 4
_c_n$ = 12						; size = 4
?setPublicKey@?$RSACrypt@$$BY07I@big@@QAEXIAAY07I@Z PROC ; big::RSACrypt<unsigned int [8]>::setPublicKey, COMDAT
; _this$ = ecx

; 1195 : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1196 : 			reset(); // in case we knew a private key

	mov	ecx, DWORD PTR _this$[ebp]
	call	?reset@?$RSACrypt@$$BY07I@big@@QAEXXZ	; big::RSACrypt<unsigned int [8]>::reset

; 1197 : 
; 1198 : 			usetw( e, c_e );

	mov	eax, DWORD PTR _c_e$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$usetw@$$BY07I@big@@YAXAAY07II@Z	; big::usetw<unsigned int [8]>
	add	esp, 8

; 1199 : 
; 1200 : 			set ( n, c_n )
; 1201 : 
; 1202 : 				;

	mov	eax, DWORD PTR _c_n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	call	??$set@$$BY07I@big@@YAXAAY07I0@Z	; big::set<unsigned int [8]>
	add	esp, 8

; 1203 : 
; 1204 : 			// find n'
; 1205 : 			computeNRinverse( n, np );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 64					; 00000040H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	call	??$computeNRinverse@$$BY07I@big@@YAXAAY07I0@Z ; big::computeNRinverse<unsigned int [8]>
	add	esp, 8

; 1206 : 
; 1207 : 			// x' = 1*r (mod n)
; 1208 : 			rModn( n, xp );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 96					; 00000060H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	call	??$rModn@$$BY07I@big@@YAXAAY07I0@Z	; big::rModn<unsigned int [8]>
	add	esp, 8

; 1209 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?setPublicKey@?$RSACrypt@$$BY07I@big@@QAEXIAAY07I@Z ENDP ; big::RSACrypt<unsigned int [8]>::setPublicKey
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rsacrypt.h
;	COMDAT ?generateKeys@?$RSACrypt@$$BY07I@big@@QAEXXZ
_TEXT	SEGMENT
_q0$ = -60						; size = 16
_p0$ = -36						; size = 16
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?generateKeys@?$RSACrypt@$$BY07I@big@@QAEXXZ PROC	; big::RSACrypt<unsigned int [8]>::generateKeys, COMDAT
; _this$ = ecx

; 1106 : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1107 : 			BIGHALFSIZE( T, p0 );
; 1108 : 			BIGHALFSIZE( T, q0 );
; 1109 : 
; 1110 : 			generateStrongPseudoPrime( p0 );

	lea	eax, DWORD PTR _p0$[ebp]
	push	eax
	call	??$generateStrongPseudoPrime@$$BY03I@big@@YAXAAY03I@Z ; big::generateStrongPseudoPrime<unsigned int [4]>
	add	esp, 4

; 1111 : 			generateStrongPseudoPrime( q0 );

	lea	eax, DWORD PTR _q0$[ebp]
	push	eax
	call	??$generateStrongPseudoPrime@$$BY03I@big@@YAXAAY03I@Z ; big::generateStrongPseudoPrime<unsigned int [4]>
	add	esp, 4

; 1112 : 
; 1113 : 			setPrivateKey( p0, q0 );

	lea	eax, DWORD PTR _q0$[ebp]
	push	eax
	lea	ecx, DWORD PTR _p0$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$setPrivateKey@$$BY03I@?$RSACrypt@$$BY07I@big@@QAEXAAY03I0@Z ; big::RSACrypt<unsigned int [8]>::setPrivateKey<unsigned int [4]>

; 1114 : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@generateKe
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@generateKe:
	DD	2
	DD	$LN5@generateKe
$LN5@generateKe:
	DD	-36					; ffffffdcH
	DD	16					; 00000010H
	DD	$LN3@generateKe
	DD	-60					; ffffffc4H
	DD	16					; 00000010H
	DD	$LN4@generateKe
$LN4@generateKe:
	DB	113					; 00000071H
	DB	48					; 00000030H
	DB	0
$LN3@generateKe:
	DB	112					; 00000070H
	DB	48					; 00000030H
	DB	0
?generateKeys@?$RSACrypt@$$BY07I@big@@QAEXXZ ENDP	; big::RSACrypt<unsigned int [8]>::generateKeys
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rsacrypt.h
;	COMDAT ?reset@?$RSACrypt@$$BY07I@big@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?reset@?$RSACrypt@$$BY07I@big@@QAEXXZ PROC		; big::RSACrypt<unsigned int [8]>::reset, COMDAT
; _this$ = ecx

; 1095 : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1096 : 			zero( d );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 129				; 00000081H
	push	eax
	call	??$zero@$$BY07I@big@@YAXAAY07I@Z	; big::zero<unsigned int [8]>
	add	esp, 4

; 1097 : 			zero( p );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 193				; 000000c1H
	push	eax
	call	??$zero@$$BY03I@big@@YAXAAY03I@Z	; big::zero<unsigned int [4]>
	add	esp, 4

; 1098 : 			zero( q );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 241				; 000000f1H
	push	eax
	call	??$zero@$$BY03I@big@@YAXAAY03I@Z	; big::zero<unsigned int [4]>
	add	esp, 4

; 1099 : 			zero( pInverse );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 289				; 00000121H
	push	eax
	call	??$zero@$$BY03I@big@@YAXAAY03I@Z	; big::zero<unsigned int [4]>
	add	esp, 4

; 1100 : 			factorsAvailable = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+128], 0

; 1101 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?reset@?$RSACrypt@$$BY07I@big@@QAEXXZ ENDP		; big::RSACrypt<unsigned int [8]>::reset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rsacrypt.h
;	COMDAT ??1?$RSACrypt@$$BY07I@big@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$RSACrypt@$$BY07I@big@@QAE@XZ PROC			; big::RSACrypt<unsigned int [8]>::~RSACrypt<unsigned int [8]>, COMDAT
; _this$ = ecx

; 1089 : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1090 : 			reset();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?reset@?$RSACrypt@$$BY07I@big@@QAEXXZ	; big::RSACrypt<unsigned int [8]>::reset

; 1091 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$RSACrypt@$$BY07I@big@@QAE@XZ ENDP			; big::RSACrypt<unsigned int [8]>::~RSACrypt<unsigned int [8]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rsacrypt.h
;	COMDAT ??0?$RSACrypt@$$BY07I@big@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$RSACrypt@$$BY07I@big@@QAE@XZ PROC			; big::RSACrypt<unsigned int [8]>::RSACrypt<unsigned int [8]>, COMDAT
; _this$ = ecx

; 1083 : 		RSACrypt()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1084 : 		{
; 1085 : 			reset();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?reset@?$RSACrypt@$$BY07I@big@@QAEXXZ	; big::RSACrypt<unsigned int [8]>::reset

; 1086 : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$RSACrypt@$$BY07I@big@@QAE@XZ ENDP			; big::RSACrypt<unsigned int [8]>::RSACrypt<unsigned int [8]>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?AddPacketToProducer@RakPeer@@IAEXPAUPacket@@@Z
_TEXT	SEGMENT
_packetPtr$ = -20					; size = 4
_this$ = -8						; size = 4
_p$ = 8							; size = 4
?AddPacketToProducer@RakPeer@@IAEXPAUPacket@@@Z PROC	; RakPeer::AddPacketToProducer, COMDAT
; _this$ = ecx

; 3783 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3784 : 	Packet **packetPtr=packetSingleProducerConsumer.WriteLock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2498				; 000009c2H
	call	?WriteLock@?$SingleProducerConsumer@PAUPacket@@@DataStructures@@QAEPAPAUPacket@@XZ ; DataStructures::SingleProducerConsumer<Packet *>::WriteLock
	mov	DWORD PTR _packetPtr$[ebp], eax

; 3785 : 	*packetPtr=p;

	mov	eax, DWORD PTR _packetPtr$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], ecx

; 3786 : 	packetSingleProducerConsumer.WriteUnlock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2498				; 000009c2H
	call	?WriteUnlock@?$SingleProducerConsumer@PAUPacket@@@DataStructures@@QAEXXZ ; DataStructures::SingleProducerConsumer<Packet *>::WriteUnlock

; 3787 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?AddPacketToProducer@RakPeer@@IAEXPAUPacket@@@Z ENDP	; RakPeer::AddPacketToProducer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?ClearRequestedConnectionList@RakPeer@@IAEXXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_bcs$ = -20						; size = 4
_this$ = -8						; size = 4
?ClearRequestedConnectionList@RakPeer@@IAEXXZ PROC	; RakPeer::ClearRequestedConnectionList, COMDAT
; _this$ = ecx

; 3765 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
$LN3@ClearReque:

; 3766 : 	RequestedConnectionStruct *bcs;
; 3767 : #ifdef _RAKNET_THREADSAFE
; 3768 : 	rakPeerMutexes[requestedConnectionList_Mutex].Lock();
; 3769 : #endif
; 3770 : 	while ((bcs=requestedConnectionList.ReadLock())!=0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 953				; 000003b9H
	call	?ReadLock@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEPAURequestedConnectionStruct@RakPeer@@XZ ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::ReadLock
	mov	DWORD PTR _bcs$[ebp], eax
	cmp	DWORD PTR _bcs$[ebp], 0
	je	SHORT $LN2@ClearReque

; 3771 : 	{
; 3772 : 		if (bcs->data)

	mov	eax, DWORD PTR _bcs$[ebp]
	cmp	DWORD PTR [eax+11], 0
	je	SHORT $LN1@ClearReque

; 3773 : 			delete [] bcs->data;

	mov	eax, DWORD PTR _bcs$[ebp]
	mov	ecx, DWORD PTR [eax+11]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@ClearReque:

; 3774 : 
; 3775 : 		requestedConnectionList.ReadUnlock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 953				; 000003b9H
	call	?ReadUnlock@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEXXZ ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::ReadUnlock

; 3776 : 	}

	jmp	SHORT $LN3@ClearReque
$LN2@ClearReque:

; 3777 : 	requestedConnectionList.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 953				; 000003b9H
	call	?Clear@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEXXZ ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::Clear

; 3778 : #ifdef _RAKNET_THREADSAFE
; 3779 : 	rakPeerMutexes[requestedConnectionList_Mutex].Unlock();
; 3780 : #endif
; 3781 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?ClearRequestedConnectionList@RakPeer@@IAEXXZ ENDP	; RakPeer::ClearRequestedConnectionList
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?ClearBufferedCommands@RakPeer@@IAEXXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
_bcs$ = -20						; size = 4
_this$ = -8						; size = 4
?ClearBufferedCommands@RakPeer@@IAEXXZ PROC		; RakPeer::ClearBufferedCommands, COMDAT
; _this$ = ecx

; 3745 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
$LN3@ClearBuffe:

; 3746 : 	BufferedCommandStruct *bcs;
; 3747 : 
; 3748 : #ifdef _RAKNET_THREADSAFE
; 3749 : 	rakPeerMutexes[bufferedCommands_Mutex].Lock();
; 3750 : #endif
; 3751 : 	while ((bcs=bufferedCommands.ReadLock())!=0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2025				; 000007e9H
	call	?ReadLock@?$SingleProducerConsumer@UBufferedCommandStruct@RakPeer@@@DataStructures@@QAEPAUBufferedCommandStruct@RakPeer@@XZ ; DataStructures::SingleProducerConsumer<RakPeer::BufferedCommandStruct>::ReadLock
	mov	DWORD PTR _bcs$[ebp], eax
	cmp	DWORD PTR _bcs$[ebp], 0
	je	SHORT $LN2@ClearBuffe

; 3752 : 	{
; 3753 : 		if (bcs->data)

	mov	eax, DWORD PTR _bcs$[ebp]
	cmp	DWORD PTR [eax+33], 0
	je	SHORT $LN1@ClearBuffe

; 3754 : 			delete [] bcs->data;

	mov	eax, DWORD PTR _bcs$[ebp]
	mov	ecx, DWORD PTR [eax+33]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@ClearBuffe:

; 3755 : 
; 3756 :         bufferedCommands.ReadUnlock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2025				; 000007e9H
	call	?ReadUnlock@?$SingleProducerConsumer@UBufferedCommandStruct@RakPeer@@@DataStructures@@QAEXXZ ; DataStructures::SingleProducerConsumer<RakPeer::BufferedCommandStruct>::ReadUnlock

; 3757 : 	}

	jmp	SHORT $LN3@ClearBuffe
$LN2@ClearBuffe:

; 3758 : 	bufferedCommands.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2025				; 000007e9H
	call	?Clear@?$SingleProducerConsumer@UBufferedCommandStruct@RakPeer@@@DataStructures@@QAEXXZ ; DataStructures::SingleProducerConsumer<RakPeer::BufferedCommandStruct>::Clear

; 3759 : #ifdef _RAKNET_THREADSAFE
; 3760 : 	rakPeerMutexes[bufferedCommands_Mutex].Unlock();
; 3761 : #endif
; 3762 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?ClearBufferedCommands@RakPeer@@IAEXXZ ENDP		; RakPeer::ClearBufferedCommands
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?SendImmediate@RakPeer@@IAE_NPADHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N4_J@Z
_TEXT	SEGMENT
tv130 = -620						; size = 4
tv70 = -620						; size = 4
tv273 = -616						; size = 4
tv234 = -616						; size = 4
tv195 = -616						; size = 4
tv249 = -613						; size = 1
__$AllocaPad$$ = -416					; size = 4
_useData$2 = -401					; size = 1
_bitStreamCopy$3 = -392					; size = 273
_i$4 = -108						; size = 4
_numberOfBytesUsed$ = -96				; size = 4
_sendListIndex$ = -84					; size = 4
_remoteSystemIndex$ = -72				; size = 4
_callerDataAllocationUsed$ = -57			; size = 1
_sendListSize$ = -48					; size = 4
_sendList$ = -36					; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_data$ = 8						; size = 4
_numberOfBitsToSend$ = 12				; size = 4
_priority$ = 16						; size = 4
_reliability$ = 20					; size = 4
_orderingChannel$ = 24					; size = 1
_playerId$ = 28						; size = 6
_broadcast$ = 36					; size = 1
_useCallerDataAllocation$ = 40				; size = 1
_currentTime$ = 44					; size = 8
?SendImmediate@RakPeer@@IAE_NPADHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N4_J@Z PROC ; RakPeer::SendImmediate, COMDAT
; _this$ = ecx

; 3528 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SendImmediate@RakPeer@@IAE_NPADHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N4_J@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 608				; 00000260H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-620]
	mov	ecx, 152				; 00000098H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$AllocaPad$$[ebp], 0

; 3529 : 	unsigned *sendList;
; 3530 : 	unsigned sendListSize;
; 3531 : 	bool callerDataAllocationUsed;
; 3532 : 	unsigned remoteSystemIndex, sendListIndex; // Iterates into the list of remote systems
; 3533 : 	unsigned numberOfBytesUsed = BITS_TO_BYTES(numberOfBitsToSend);

	mov	eax, DWORD PTR _numberOfBitsToSend$[ebp]
	add	eax, 7
	sar	eax, 3
	mov	DWORD PTR _numberOfBytesUsed$[ebp], eax

; 3534 : 	callerDataAllocationUsed=false;

	mov	BYTE PTR _callerDataAllocationUsed$[ebp], 0

; 3535 : 
; 3536 : 	sendListSize=0;

	mov	DWORD PTR _sendListSize$[ebp], 0

; 3537 : 
; 3538 : 	// 03/06/06 - If broadcast is false, use the optimized version of GetIndexFromPlayerID
; 3539 : 	if (broadcast==false)

	movzx	eax, BYTE PTR _broadcast$[ebp]
	test	eax, eax
	jne	$LN20@SendImmedi
	mov	eax, 4
	add	eax, 36					; 00000024H
	mov	DWORD PTR tv195[ebp], eax

; 3540 : 	{
; 3541 : #if !defined(_COMPATIBILITY_1)
; 3542 : 		sendList=(unsigned *)alloca(sizeof(unsigned));

	mov	eax, DWORD PTR tv195[ebp]
	call	__alloca_probe_16
	mov	DWORD PTR tv70[ebp], esp
	lea	ecx, DWORD PTR __$AllocaPad$$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv195[ebp]
	mov	ecx, DWORD PTR tv70[ebp]
	call	@_RTC_AllocaHelper@12
	add	DWORD PTR tv70[ebp], 32			; 00000020H
	mov	edx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _sendList$[ebp], edx

; 3543 : #else
; 3544 : 		sendList = new unsigned[1];
; 3545 : #endif
; 3546 : 		remoteSystemIndex=GetIndexFromPlayerID( playerId, true );

	push	1
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexFromPlayerID@RakPeer@@IAEHUPlayerID@@_N@Z ; RakPeer::GetIndexFromPlayerID
	mov	DWORD PTR _remoteSystemIndex$[ebp], eax

; 3547 : 		if (remoteSystemIndex!=(unsigned)-1 &&
; 3548 : 			remoteSystemList[remoteSystemIndex].connectMode!=RemoteSystemStruct::DISCONNECT_ASAP && 
; 3549 : 			remoteSystemList[remoteSystemIndex].connectMode!=RemoteSystemStruct::DISCONNECT_ASAP_SILENTLY && 
; 3550 : 			remoteSystemList[remoteSystemIndex].connectMode!=RemoteSystemStruct::DISCONNECT_ON_NO_ACK)

	cmp	DWORD PTR _remoteSystemIndex$[ebp], -1
	je	SHORT $LN19@SendImmedi
	imul	eax, DWORD PTR _remoteSystemIndex$[ebp], 2058
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	cmp	DWORD PTR [edx+eax+2054], 1
	je	SHORT $LN19@SendImmedi
	imul	eax, DWORD PTR _remoteSystemIndex$[ebp], 2058
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	cmp	DWORD PTR [edx+eax+2054], 2
	je	SHORT $LN19@SendImmedi
	imul	eax, DWORD PTR _remoteSystemIndex$[ebp], 2058
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	cmp	DWORD PTR [edx+eax+2054], 3
	je	SHORT $LN19@SendImmedi

; 3551 : 		{
; 3552 : 			sendList[0]=remoteSystemIndex;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _sendList$[ebp]
	mov	eax, DWORD PTR _remoteSystemIndex$[ebp]
	mov	DWORD PTR [edx+ecx], eax

; 3553 : 			sendListSize=1;

	mov	DWORD PTR _sendListSize$[ebp], 1
$LN19@SendImmedi:

; 3554 : 		}
; 3555 : 	}
; 3556 : 	else

	jmp	$LN18@SendImmedi
$LN20@SendImmedi:

; 3557 : 	{
; 3558 : #if !defined(_COMPATIBILITY_1)
; 3559 : 	//sendList=(unsigned *)alloca(sizeof(unsigned)*remoteSystemListSize);
; 3560 : 		sendList=(unsigned *)alloca(sizeof(unsigned)*maximumNumberOfPeers);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+7]
	shl	ecx, 2
	add	ecx, 36					; 00000024H
	mov	DWORD PTR tv273[ebp], ecx
	mov	eax, DWORD PTR tv273[ebp]
	call	__alloca_probe_16
	mov	DWORD PTR tv130[ebp], esp
	lea	edx, DWORD PTR __$AllocaPad$$[ebp]
	push	edx
	mov	edx, DWORD PTR tv273[ebp]
	mov	ecx, DWORD PTR tv130[ebp]
	call	@_RTC_AllocaHelper@12
	add	DWORD PTR tv130[ebp], 32		; 00000020H
	mov	eax, DWORD PTR tv130[ebp]
	mov	DWORD PTR _sendList$[ebp], eax

; 3561 : #else
; 3562 : 	//sendList = new unsigned[remoteSystemListSize];
; 3563 : 		sendList = new unsigned[maximumNumberOfPeers];
; 3564 : #endif
; 3565 : 
; 3566 : 		// remoteSystemList in network thread
; 3567 : 		for ( remoteSystemIndex = 0; remoteSystemIndex < maximumNumberOfPeers; remoteSystemIndex++ )

	mov	DWORD PTR _remoteSystemIndex$[ebp], 0
	jmp	SHORT $LN17@SendImmedi
$LN16@SendImmedi:
	mov	eax, DWORD PTR _remoteSystemIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _remoteSystemIndex$[ebp], eax
$LN17@SendImmedi:
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+7]
	cmp	DWORD PTR _remoteSystemIndex$[ebp], ecx
	jae	SHORT $LN18@SendImmedi

; 3568 : 		//for ( remoteSystemIndex = 0; remoteSystemIndex < remoteSystemListSize; remoteSystemIndex++ )
; 3569 : 		{
; 3570 : 			if ( remoteSystemList[ remoteSystemIndex ].isActive && remoteSystemList[ remoteSystemIndex ].playerId != playerId && remoteSystemList[ remoteSystemIndex ].playerId != UNASSIGNED_PLAYER_ID )

	imul	eax, DWORD PTR _remoteSystemIndex$[ebp], 2058
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	movzx	eax, BYTE PTR [edx+eax]
	test	eax, eax
	je	SHORT $LN14@SendImmedi
	lea	eax, DWORD PTR _playerId$[ebp]
	push	eax
	imul	ecx, DWORD PTR _remoteSystemIndex$[ebp], 2058
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+820]
	lea	ecx, DWORD PTR [eax+ecx+1]
	call	??9PlayerID@@QBE_NABU0@@Z		; PlayerID::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN14@SendImmedi
	push	OFFSET _UNASSIGNED_PLAYER_ID
	imul	eax, DWORD PTR _remoteSystemIndex$[ebp], 2058
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	lea	ecx, DWORD PTR [edx+eax+1]
	call	??9PlayerID@@QBE_NABU0@@Z		; PlayerID::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN14@SendImmedi

; 3571 : 				sendList[sendListSize++]=remoteSystemIndex;

	mov	eax, DWORD PTR _sendListSize$[ebp]
	mov	ecx, DWORD PTR _sendList$[ebp]
	mov	edx, DWORD PTR _remoteSystemIndex$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx
	mov	eax, DWORD PTR _sendListSize$[ebp]
	add	eax, 1
	mov	DWORD PTR _sendListSize$[ebp], eax
$LN14@SendImmedi:

; 3572 : 		}

	jmp	$LN16@SendImmedi
$LN18@SendImmedi:

; 3573 : 	}
; 3574 : 
; 3575 : 	if (sendListSize==0)

	cmp	DWORD PTR _sendListSize$[ebp], 0
	jne	SHORT $LN13@SendImmedi

; 3576 : 	{
; 3577 : #if defined(_COMPATIBILITY_1)
; 3578 : 		delete [] sendList;
; 3579 : #endif
; 3580 : 		return false;

	xor	al, al
	jmp	$LN21@SendImmedi
$LN13@SendImmedi:

; 3581 : 	}
; 3582 : 
; 3583 : 	for (sendListIndex=0; sendListIndex < sendListSize; sendListIndex++)

	mov	DWORD PTR _sendListIndex$[ebp], 0
	jmp	SHORT $LN12@SendImmedi
$LN11@SendImmedi:
	mov	eax, DWORD PTR _sendListIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _sendListIndex$[ebp], eax
$LN12@SendImmedi:
	mov	eax, DWORD PTR _sendListIndex$[ebp]
	cmp	eax, DWORD PTR _sendListSize$[ebp]
	jae	$LN10@SendImmedi

; 3584 : 	{
; 3585 : 		if ( trackFrequencyTable )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+2065]
	test	ecx, ecx
	je	SHORT $LN9@SendImmedi

; 3586 : 		{
; 3587 : 			unsigned i;
; 3588 : 			// Store output frequency
; 3589 : 			for (i=0 ; i < numberOfBytesUsed; i++ )

	mov	DWORD PTR _i$4[ebp], 0
	jmp	SHORT $LN8@SendImmedi
$LN7@SendImmedi:
	mov	eax, DWORD PTR _i$4[ebp]
	add	eax, 1
	mov	DWORD PTR _i$4[ebp], eax
$LN8@SendImmedi:
	mov	eax, DWORD PTR _i$4[ebp]
	cmp	eax, DWORD PTR _numberOfBytesUsed$[ebp]
	jae	SHORT $LN6@SendImmedi

; 3590 : 				frequencyTable[ (unsigned char)(data[i]) ]++;

	mov	eax, DWORD PTR _data$[ebp]
	add	eax, DWORD PTR _i$4[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+977]
	add	eax, 1
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, DWORD PTR _i$4[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx*4+977], eax
	jmp	SHORT $LN7@SendImmedi
$LN6@SendImmedi:

; 3591 : 			rawBytesSent += numberOfBytesUsed;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2009]
	add	ecx, DWORD PTR _numberOfBytesUsed$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2009], ecx
$LN9@SendImmedi:

; 3592 : 		}
; 3593 : 
; 3594 : 		if ( outputTree )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2005], 0
	je	$LN5@SendImmedi

; 3595 : 		{
; 3596 : 			RakNet::BitStream bitStreamCopy( numberOfBytesUsed );

	mov	eax, DWORD PTR _numberOfBytesUsed$[ebp]
	push	eax
	lea	ecx, DWORD PTR _bitStreamCopy$3[ebp]
	call	??0BitStream@RakNet@@QAE@H@Z		; RakNet::BitStream::BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3597 : 			outputTree->EncodeArray( (unsigned char*) data, numberOfBytesUsed, &bitStreamCopy );

	lea	eax, DWORD PTR _bitStreamCopy$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _numberOfBytesUsed$[ebp]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2005]
	call	?EncodeArray@HuffmanEncodingTree@@QAEXPAEIPAVBitStream@RakNet@@@Z ; HuffmanEncodingTree::EncodeArray

; 3598 : 			compressedBytesSent += bitStreamCopy.GetNumberOfBytesUsed();

	lea	ecx, DWORD PTR _bitStreamCopy$3[ebp]
	call	?GetNumberOfBytesUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBytesUsed
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+2017]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2017], eax

; 3599 : 			remoteSystemList[sendList[sendListIndex]].reliabilityLayer.Send( (char*) bitStreamCopy.GetData(), bitStreamCopy.GetNumberOfBitsUsed(), priority, reliability, orderingChannel, true, MTUSize, currentTime );

	mov	eax, DWORD PTR _currentTime$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _currentTime$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2061]
	push	eax
	push	1
	movzx	ecx, BYTE PTR _orderingChannel$[ebp]
	push	ecx
	mov	edx, DWORD PTR _reliability$[ebp]
	push	edx
	mov	eax, DWORD PTR _priority$[ebp]
	push	eax
	lea	ecx, DWORD PTR _bitStreamCopy$3[ebp]
	call	?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBitsUsed
	push	eax
	lea	ecx, DWORD PTR _bitStreamCopy$3[ebp]
	call	?GetData@BitStream@RakNet@@QBEPAEXZ	; RakNet::BitStream::GetData
	push	eax
	mov	ecx, DWORD PTR _sendListIndex$[ebp]
	mov	edx, DWORD PTR _sendList$[ebp]
	imul	eax, DWORD PTR [edx+ecx*4], 2058
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	lea	ecx, DWORD PTR [edx+eax+13]
	call	?Send@ReliabilityLayer@@QAE_NPADHW4PacketPriority@@W4PacketReliability@@E_NH_J@Z ; ReliabilityLayer::Send

; 3600 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _bitStreamCopy$3[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream

; 3601 : 		else

	jmp	$LN4@SendImmedi
$LN5@SendImmedi:

; 3602 : 		{
; 3603 : 			// Send may split the packet and thus deallocate data.  Don't assume data is valid if we use the callerAllocationData
; 3604 : 			bool useData = useCallerDataAllocation && callerDataAllocationUsed==false && sendListIndex+1==sendListSize;

	movzx	eax, BYTE PTR _useCallerDataAllocation$[ebp]
	test	eax, eax
	je	SHORT $LN23@SendImmedi
	movzx	ecx, BYTE PTR _callerDataAllocationUsed$[ebp]
	test	ecx, ecx
	jne	SHORT $LN23@SendImmedi
	mov	edx, DWORD PTR _sendListIndex$[ebp]
	add	edx, 1
	cmp	edx, DWORD PTR _sendListSize$[ebp]
	jne	SHORT $LN23@SendImmedi
	mov	DWORD PTR tv234[ebp], 1
	jmp	SHORT $LN24@SendImmedi
$LN23@SendImmedi:
	mov	DWORD PTR tv234[ebp], 0
$LN24@SendImmedi:
	mov	al, BYTE PTR tv234[ebp]
	mov	BYTE PTR _useData$2[ebp], al

; 3605 : 			remoteSystemList[sendList[sendListIndex]].reliabilityLayer.Send( data, numberOfBitsToSend, priority, reliability, orderingChannel, useData==false, MTUSize, currentTime );

	movzx	eax, BYTE PTR _useData$2[ebp]
	test	eax, eax
	jne	SHORT $LN25@SendImmedi
	mov	BYTE PTR tv249[ebp], 1
	jmp	SHORT $LN26@SendImmedi
$LN25@SendImmedi:
	mov	BYTE PTR tv249[ebp], 0
$LN26@SendImmedi:
	mov	ecx, DWORD PTR _currentTime$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _currentTime$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2061]
	push	ecx
	movzx	edx, BYTE PTR tv249[ebp]
	push	edx
	movzx	eax, BYTE PTR _orderingChannel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _reliability$[ebp]
	push	ecx
	mov	edx, DWORD PTR _priority$[ebp]
	push	edx
	mov	eax, DWORD PTR _numberOfBitsToSend$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sendListIndex$[ebp]
	mov	eax, DWORD PTR _sendList$[ebp]
	imul	ecx, DWORD PTR [eax+edx*4], 2058
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+820]
	lea	ecx, DWORD PTR [eax+ecx+13]
	call	?Send@ReliabilityLayer@@QAE_NPADHW4PacketPriority@@W4PacketReliability@@E_NH_J@Z ; ReliabilityLayer::Send

; 3606 : 			if (useData)

	movzx	eax, BYTE PTR _useData$2[ebp]
	test	eax, eax
	je	SHORT $LN4@SendImmedi

; 3607 : 				callerDataAllocationUsed=true;

	mov	BYTE PTR _callerDataAllocationUsed$[ebp], 1
$LN4@SendImmedi:

; 3608 : 		}
; 3609 : 
; 3610 : 		if (reliability==RELIABLE || reliability==RELIABLE_ORDERED || reliability==RELIABLE_SEQUENCED)

	cmp	DWORD PTR _reliability$[ebp], 2
	je	SHORT $LN1@SendImmedi
	cmp	DWORD PTR _reliability$[ebp], 3
	je	SHORT $LN1@SendImmedi
	cmp	DWORD PTR _reliability$[ebp], 4
	jne	SHORT $LN2@SendImmedi
$LN1@SendImmedi:

; 3611 : 			remoteSystemList[sendList[sendListIndex]].lastReliableSend=(RakNetTime)(currentTime/(RakNetTimeNS)1000);

	push	0
	push	1000					; 000003e8H
	mov	eax, DWORD PTR _currentTime$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _currentTime$[ebp]
	push	ecx
	call	__alldiv
	mov	edx, DWORD PTR _sendListIndex$[ebp]
	mov	ecx, DWORD PTR _sendList$[ebp]
	imul	edx, DWORD PTR [ecx+edx*4], 2058
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+820]
	mov	DWORD PTR [ecx+edx+1744], eax
$LN2@SendImmedi:

; 3612 : 	}

	jmp	$LN11@SendImmedi
$LN10@SendImmedi:

; 3613 : 
; 3614 : #if defined(_COMPATIBILITY_1)
; 3615 : 	delete [] sendList;
; 3616 : #endif
; 3617 : 
; 3618 : 	// Return value only meaningful if true was passed for useCallerDataAllocation.  Means the reliability layer used that data copy, so the caller should not deallocate it
; 3619 : 	return callerDataAllocationUsed;

	mov	al, BYTE PTR _callerDataAllocationUsed$[ebp]
$LN21@SendImmedi:

; 3620 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN32@SendImmedi
	push	DWORD PTR __$AllocaPad$$[ebp]
	call	@_RTC_CheckStackVars2@12
	pop	eax
	pop	edx
	lea	esp, DWORD PTR [ebp-636]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	44					; 0000002cH
	npad	1
$LN32@SendImmedi:
	DD	2
	DD	$LN31@SendImmedi
$LN31@SendImmedi:
	DD	-392					; fffffe78H
	DD	273					; 00000111H
	DD	$LN28@SendImmedi
	DD	-416					; fffffe60H
	DD	4
	DD	$LN29@SendImmedi
$LN29@SendImmedi:
	DB	95					; 0000005fH
	DB	36					; 00000024H
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	36					; 00000024H
	DB	0
$LN28@SendImmedi:
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	112					; 00000070H
	DB	121					; 00000079H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SendImmediate@RakPeer@@IAE_NPADHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N4_J@Z$0:
	lea	ecx, DWORD PTR _bitStreamCopy$3[ebp]
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__ehhandler$?SendImmediate@RakPeer@@IAE_NPADHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N4_J@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-624]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SendImmediate@RakPeer@@IAE_NPADHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N4_J@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SendImmediate@RakPeer@@IAE_NPADHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N4_J@Z ENDP ; RakPeer::SendImmediate
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?SendBuffered@RakPeer@@IAEXPBDHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_NW4ConnectMode@RemoteSystemStruct@1@@Z
_TEXT	SEGMENT
$T1 = -224						; size = 4
_bcs$ = -20						; size = 4
_this$ = -8						; size = 4
_data$ = 8						; size = 4
_numberOfBitsToSend$ = 12				; size = 4
_priority$ = 16						; size = 4
_reliability$ = 20					; size = 4
_orderingChannel$ = 24					; size = 1
_playerId$ = 28						; size = 6
_broadcast$ = 36					; size = 1
_connectionMode$ = 40					; size = 4
?SendBuffered@RakPeer@@IAEXPBDHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_NW4ConnectMode@RemoteSystemStruct@1@@Z PROC ; RakPeer::SendBuffered, COMDAT
; _this$ = ecx

; 3495 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3496 : #ifdef _DEBUG
; 3497 : 	assert(orderingChannel >=0 && orderingChannel < 32);

	movsx	eax, BYTE PTR _orderingChannel$[ebp]
	test	eax, eax
	jl	SHORT $LN3@SendBuffer
	movsx	ecx, BYTE PTR _orderingChannel$[ebp]
	cmp	ecx, 32					; 00000020H
	jl	SHORT $LN4@SendBuffer
$LN3@SendBuffer:
	mov	edx, DWORD PTR ?__LINE__Var@?1??SendBuffered@RakPeer@@IAEXPBDHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_NW4ConnectMode@RemoteSystemStruct@2@@Z@4JA
	add	edx, 2
	push	edx
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_1FI@DAMMCKDJ@?$AAo?$AAr?$AAd?$AAe?$AAr?$AAi?$AAn?$AAg?$AAC?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AA?5?$AA?$DO?$AA?$DN?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAo?$AAr?$AAd?$AAe?$AAr?$AAi?$AAn?$AAg?$AAC@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@SendBuffer:

; 3498 : #endif
; 3499 : 
; 3500 : 
; 3501 : 	BufferedCommandStruct *bcs;
; 3502 : 
; 3503 : #ifdef _RAKNET_THREADSAFE
; 3504 : 	rakPeerMutexes[bufferedCommands_Mutex].Lock();
; 3505 : #endif
; 3506 : 	bcs=bufferedCommands.WriteLock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2025				; 000007e9H
	call	?WriteLock@?$SingleProducerConsumer@UBufferedCommandStruct@RakPeer@@@DataStructures@@QAEPAUBufferedCommandStruct@RakPeer@@XZ ; DataStructures::SingleProducerConsumer<RakPeer::BufferedCommandStruct>::WriteLock
	mov	DWORD PTR _bcs$[ebp], eax

; 3507 : 	bcs->data = new char[BITS_TO_BYTES(numberOfBitsToSend)]; // Making a copy doesn't lose efficiency because I tell the reliability layer to use this allocation for its own copy

	mov	eax, DWORD PTR _numberOfBitsToSend$[ebp]
	add	eax, 7
	sar	eax, 3
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR _bcs$[ebp]
	mov	edx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [ecx+33], edx

; 3508 : #ifdef _DEBUG
; 3509 : 	assert(bcs->data);

	mov	eax, DWORD PTR _bcs$[ebp]
	cmp	DWORD PTR [eax+33], 0
	jne	SHORT $LN5@SendBuffer
	mov	ecx, DWORD PTR ?__LINE__Var@?1??SendBuffered@RakPeer@@IAEXPBDHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_NW4ConnectMode@RemoteSystemStruct@2@@Z@4JA
	add	ecx, 14					; 0000000eH
	push	ecx
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_1BE@LOOBMGDN@?$AAb?$AAc?$AAs?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN5@SendBuffer:

; 3510 : #endif
; 3511 : 	memcpy(bcs->data, data, BITS_TO_BYTES(numberOfBitsToSend));

	mov	eax, DWORD PTR _numberOfBitsToSend$[ebp]
	add	eax, 7
	sar	eax, 3
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bcs$[ebp]
	mov	eax, DWORD PTR [edx+33]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 3512 :     bcs->numberOfBitsToSend=numberOfBitsToSend;

	mov	eax, DWORD PTR _bcs$[ebp]
	mov	ecx, DWORD PTR _numberOfBitsToSend$[ebp]
	mov	DWORD PTR [eax], ecx

; 3513 : 	bcs->priority=priority;

	mov	eax, DWORD PTR _bcs$[ebp]
	mov	ecx, DWORD PTR _priority$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 3514 : 	bcs->reliability=reliability;

	mov	eax, DWORD PTR _bcs$[ebp]
	mov	ecx, DWORD PTR _reliability$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 3515 : 	bcs->orderingChannel=orderingChannel;

	mov	eax, DWORD PTR _bcs$[ebp]
	mov	cl, BYTE PTR _orderingChannel$[ebp]
	mov	BYTE PTR [eax+12], cl

; 3516 : 	bcs->playerId=playerId;

	lea	eax, DWORD PTR _playerId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bcs$[ebp]
	add	ecx, 13					; 0000000dH
	call	??4PlayerID@@QAEAAU0@ABU0@@Z		; PlayerID::operator=

; 3517 : 	bcs->broadcast=broadcast;

	mov	eax, DWORD PTR _bcs$[ebp]
	mov	cl, BYTE PTR _broadcast$[ebp]
	mov	BYTE PTR [eax+19], cl

; 3518 : 	bcs->connectionMode=connectionMode;

	mov	eax, DWORD PTR _bcs$[ebp]
	mov	ecx, DWORD PTR _connectionMode$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 3519 : 	bcs->command=BufferedCommandStruct::BCS_SEND;

	mov	eax, DWORD PTR _bcs$[ebp]
	mov	DWORD PTR [eax+37], 0

; 3520 : 	bufferedCommands.WriteUnlock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2025				; 000007e9H
	call	?WriteUnlock@?$SingleProducerConsumer@UBufferedCommandStruct@RakPeer@@@DataStructures@@QAEXXZ ; DataStructures::SingleProducerConsumer<RakPeer::BufferedCommandStruct>::WriteUnlock

; 3521 : 
; 3522 : #ifdef _RAKNET_THREADSAFE
; 3523 : 	rakPeerMutexes[bufferedCommands_Mutex].Unlock();
; 3524 : #endif
; 3525 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
?SendBuffered@RakPeer@@IAEXPBDHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_NW4ConnectMode@RemoteSystemStruct@1@@Z ENDP ; RakPeer::SendBuffered
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?CloseConnectionInternal@RakPeer@@IAEXUPlayerID@@_N1E@Z
_TEXT	SEGMENT
tv158 = -244						; size = 4
_bcs$1 = -44						; size = 4
_j$ = -32						; size = 4
_i$ = -20						; size = 4
_this$ = -8						; size = 4
_target$ = 8						; size = 6
_sendDisconnectionNotification$ = 16			; size = 1
_performImmediate$ = 20					; size = 1
_orderingChannel$ = 24					; size = 1
?CloseConnectionInternal@RakPeer@@IAEXUPlayerID@@_N1E@Z PROC ; RakPeer::CloseConnectionInternal, COMDAT
; _this$ = ecx

; 3407 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3408 : 	unsigned i,j;
; 3409 : 
; 3410 : #ifdef _DEBUG
; 3411 : 	assert(orderingChannel >=0 && orderingChannel < 32);

	movzx	eax, BYTE PTR _orderingChannel$[ebp]
	test	eax, eax
	jl	SHORT $LN17@CloseConne
	movzx	ecx, BYTE PTR _orderingChannel$[ebp]
	cmp	ecx, 32					; 00000020H
	jl	SHORT $LN18@CloseConne
$LN17@CloseConne:
	mov	edx, DWORD PTR ?__LINE__Var@?1??CloseConnectionInternal@RakPeer@@IAEXUPlayerID@@_N1E@Z@4JA
	add	edx, 4
	push	edx
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_1FI@DAMMCKDJ@?$AAo?$AAr?$AAd?$AAe?$AAr?$AAi?$AAn?$AAg?$AAC?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AA?5?$AA?$DO?$AA?$DN?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAo?$AAr?$AAd?$AAe?$AAr?$AAi?$AAn?$AAg?$AAC@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN18@CloseConne:

; 3412 : #endif
; 3413 : 
; 3414 : 	if (target==UNASSIGNED_PLAYER_ID)

	push	OFFSET _UNASSIGNED_PLAYER_ID
	lea	ecx, DWORD PTR _target$[ebp]
	call	??8PlayerID@@QBE_NABU0@@Z		; PlayerID::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN14@CloseConne

; 3415 : 		return;

	jmp	$LN15@CloseConne
$LN14@CloseConne:

; 3416 : 
; 3417 : 	if ( remoteSystemList == 0 || endThreads == true )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+820], 0
	je	SHORT $LN12@CloseConne
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	cmp	ecx, 1
	jne	SHORT $LN13@CloseConne
$LN12@CloseConne:

; 3418 : 		return;

	jmp	$LN15@CloseConne
$LN13@CloseConne:

; 3419 : 
; 3420 : 	if (sendDisconnectionNotification)

	movzx	eax, BYTE PTR _sendDisconnectionNotification$[ebp]
	test	eax, eax
	je	SHORT $LN11@CloseConne

; 3421 : 	{
; 3422 : 		NotifyAndFlagForDisconnect(target, performImmediate, orderingChannel);

	movzx	eax, BYTE PTR _orderingChannel$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _performImmediate$[ebp]
	push	ecx
	sub	esp, 8
	mov	edx, esp
	mov	eax, DWORD PTR _target$[ebp]
	mov	DWORD PTR [edx], eax
	mov	cx, WORD PTR _target$[ebp+4]
	mov	WORD PTR [edx+4], cx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NotifyAndFlagForDisconnect@RakPeer@@IAEXUPlayerID@@_NE@Z ; RakPeer::NotifyAndFlagForDisconnect

; 3423 : 	}
; 3424 : 	else

	jmp	$LN15@CloseConne
$LN11@CloseConne:

; 3425 : 	{
; 3426 : 		if (performImmediate)

	movzx	eax, BYTE PTR _performImmediate$[ebp]
	test	eax, eax
	je	$LN9@CloseConne

; 3427 : 		{
; 3428 : 			i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 3429 : 			// remoteSystemList in user thread
; 3430 : 			for ( ; i < maximumNumberOfPeers; i++ )

	jmp	SHORT $LN8@CloseConne
$LN7@CloseConne:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN8@CloseConne:
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+7]
	cmp	DWORD PTR _i$[ebp], ecx
	jae	$LN6@CloseConne

; 3431 : 				//for ( ; i < remoteSystemListSize; i++ )
; 3432 : 			{
; 3433 : 				if ( remoteSystemList[ i ].isActive && remoteSystemList[ i ].playerId == target )

	imul	eax, DWORD PTR _i$[ebp], 2058
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	movzx	eax, BYTE PTR [edx+eax]
	test	eax, eax
	je	$LN5@CloseConne
	lea	eax, DWORD PTR _target$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 2058
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+820]
	lea	ecx, DWORD PTR [eax+ecx+1]
	call	??8PlayerID@@QBE_NABU0@@Z		; PlayerID::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	$LN5@CloseConne

; 3434 : 				{
; 3435 : 					// Found the index to stop
; 3436 : 					remoteSystemList[ i ].isActive=false;

	imul	eax, DWORD PTR _i$[ebp], 2058
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	mov	BYTE PTR [edx+eax], 0

; 3437 : 
; 3438 : 					// Reserve this reliability layer for ourselves
; 3439 : 					//remoteSystemList[ i ].playerId = UNASSIGNED_PLAYER_ID;
; 3440 : 					
; 3441 : 					for (j=0; j < messageHandlerList.Size(); j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN4@CloseConne
$LN3@CloseConne:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN4@CloseConne:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 941				; 000003adH
	call	?Size@?$List@PAVPluginInterface@@@DataStructures@@QBEIXZ ; DataStructures::List<PluginInterface *>::Size
	cmp	DWORD PTR _j$[ebp], eax
	jae	SHORT $LN2@CloseConne

; 3442 : 					{
; 3443 : 						messageHandlerList[j]->OnCloseConnection(this, target);

	mov	eax, DWORD PTR _j$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 941				; 000003adH
	call	??A?$List@PAVPluginInterface@@@DataStructures@@QBEAAPAVPluginInterface@@I@Z ; DataStructures::List<PluginInterface *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv158[ebp], ecx
	mov	esi, esp
	sub	esp, 8
	mov	edx, esp
	mov	eax, DWORD PTR _target$[ebp]
	mov	DWORD PTR [edx], eax
	mov	cx, WORD PTR _target$[ebp+4]
	mov	WORD PTR [edx+4], cx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR tv158[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv158[ebp]
	mov	eax, DWORD PTR [edx+24]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3444 : 					}

	jmp	SHORT $LN3@CloseConne
$LN2@CloseConne:

; 3445 : 
; 3446 : 					// Clear any remaining messages
; 3447 : 					remoteSystemList[ i ].reliabilityLayer.Reset(false);

	push	0
	imul	eax, DWORD PTR _i$[ebp], 2058
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	lea	ecx, DWORD PTR [edx+eax+13]
	call	?Reset@ReliabilityLayer@@QAEX_N@Z	; ReliabilityLayer::Reset

; 3448 : 
; 3449 : 					// Remove from the lookup list
; 3450 : 					remoteSystemLookup.Remove(target);

	lea	eax, DWORD PTR _target$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 824				; 00000338H
	call	?Remove@?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QAEIABUPlayerID@@@Z ; DataStructures::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>::Remove

; 3451 : 
; 3452 : 					break;

	jmp	SHORT $LN6@CloseConne
$LN5@CloseConne:

; 3453 : 				}
; 3454 : 			}

	jmp	$LN7@CloseConne
$LN6@CloseConne:

; 3455 : 		}
; 3456 : 		else

	jmp	SHORT $LN15@CloseConne
$LN9@CloseConne:

; 3457 : 		{
; 3458 : 			BufferedCommandStruct *bcs;
; 3459 : #ifdef _RAKNET_THREADSAFE
; 3460 : 			rakPeerMutexes[bufferedCommands_Mutex].Lock();
; 3461 : #endif
; 3462 : 			bcs=bufferedCommands.WriteLock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2025				; 000007e9H
	call	?WriteLock@?$SingleProducerConsumer@UBufferedCommandStruct@RakPeer@@@DataStructures@@QAEPAUBufferedCommandStruct@RakPeer@@XZ ; DataStructures::SingleProducerConsumer<RakPeer::BufferedCommandStruct>::WriteLock
	mov	DWORD PTR _bcs$1[ebp], eax

; 3463 : 			bcs->command=BufferedCommandStruct::BCS_CLOSE_CONNECTION;

	mov	eax, DWORD PTR _bcs$1[ebp]
	mov	DWORD PTR [eax+37], 1

; 3464 : 			bcs->playerId=target;

	lea	eax, DWORD PTR _target$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bcs$1[ebp]
	add	ecx, 13					; 0000000dH
	call	??4PlayerID@@QAEAAU0@ABU0@@Z		; PlayerID::operator=

; 3465 : 			bcs->data=0;

	mov	eax, DWORD PTR _bcs$1[ebp]
	mov	DWORD PTR [eax+33], 0

; 3466 : 			bcs->orderingChannel=orderingChannel;

	mov	eax, DWORD PTR _bcs$1[ebp]
	mov	cl, BYTE PTR _orderingChannel$[ebp]
	mov	BYTE PTR [eax+12], cl

; 3467 : 			bufferedCommands.WriteUnlock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2025				; 000007e9H
	call	?WriteUnlock@?$SingleProducerConsumer@UBufferedCommandStruct@RakPeer@@@DataStructures@@QAEXXZ ; DataStructures::SingleProducerConsumer<RakPeer::BufferedCommandStruct>::WriteUnlock
$LN15@CloseConne:

; 3468 : #ifdef _RAKNET_THREADSAFE
; 3469 : 			rakPeerMutexes[bufferedCommands_Mutex].Unlock();
; 3470 : #endif
; 3471 : 		}
; 3472 : 	}
; 3473 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?CloseConnectionInternal@RakPeer@@IAEXUPlayerID@@_N1E@Z ENDP ; RakPeer::CloseConnectionInternal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?ValidSendTarget@RakPeer@@IAE_NUPlayerID@@_N@Z
_TEXT	SEGMENT
_remoteSystemIndex$ = -20				; size = 4
_this$ = -8						; size = 4
_playerId$ = 8						; size = 6
_broadcast$ = 16					; size = 1
?ValidSendTarget@RakPeer@@IAE_NUPlayerID@@_N@Z PROC	; RakPeer::ValidSendTarget, COMDAT
; _this$ = ecx

; 3476 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3477 : 	unsigned remoteSystemIndex;
; 3478 : 
; 3479 : 	// remoteSystemList in user thread.  This is slow so only do it in debug
; 3480 : 	for ( remoteSystemIndex = 0; remoteSystemIndex < maximumNumberOfPeers; remoteSystemIndex++ )

	mov	DWORD PTR _remoteSystemIndex$[ebp], 0
	jmp	SHORT $LN6@ValidSendT
$LN5@ValidSendT:
	mov	eax, DWORD PTR _remoteSystemIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _remoteSystemIndex$[ebp], eax
$LN6@ValidSendT:
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+7]
	cmp	DWORD PTR _remoteSystemIndex$[ebp], ecx
	jae	$LN4@ValidSendT

; 3481 : 	//for ( remoteSystemIndex = 0; remoteSystemIndex < remoteSystemListSize; remoteSystemIndex++ )
; 3482 : 	{
; 3483 : 		if ( remoteSystemList[ remoteSystemIndex ].isActive &&
; 3484 : 			remoteSystemList[ remoteSystemIndex ].connectMode==RakPeer::RemoteSystemStruct::CONNECTED && // Not fully connected players are not valid user-send targets because the reliability layer wasn't reset yet
; 3485 : 			( ( broadcast == false && remoteSystemList[ remoteSystemIndex ].playerId == playerId ) ||
; 3486 : 			( broadcast == true && remoteSystemList[ remoteSystemIndex ].playerId != playerId ) )
; 3487 : 			)

	imul	eax, DWORD PTR _remoteSystemIndex$[ebp], 2058
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	movzx	eax, BYTE PTR [edx+eax]
	test	eax, eax
	je	SHORT $LN3@ValidSendT
	imul	eax, DWORD PTR _remoteSystemIndex$[ebp], 2058
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	cmp	DWORD PTR [edx+eax+2054], 8
	jne	SHORT $LN3@ValidSendT
	movzx	eax, BYTE PTR _broadcast$[ebp]
	test	eax, eax
	jne	SHORT $LN1@ValidSendT
	lea	eax, DWORD PTR _playerId$[ebp]
	push	eax
	imul	ecx, DWORD PTR _remoteSystemIndex$[ebp], 2058
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+820]
	lea	ecx, DWORD PTR [eax+ecx+1]
	call	??8PlayerID@@QBE_NABU0@@Z		; PlayerID::operator==
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@ValidSendT
$LN1@ValidSendT:
	movzx	eax, BYTE PTR _broadcast$[ebp]
	cmp	eax, 1
	jne	SHORT $LN3@ValidSendT
	lea	eax, DWORD PTR _playerId$[ebp]
	push	eax
	imul	ecx, DWORD PTR _remoteSystemIndex$[ebp], 2058
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+820]
	lea	ecx, DWORD PTR [eax+ecx+1]
	call	??9PlayerID@@QBE_NABU0@@Z		; PlayerID::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@ValidSendT
$LN2@ValidSendT:

; 3488 : 			return true;

	mov	al, 1
	jmp	SHORT $LN7@ValidSendT
$LN3@ValidSendT:

; 3489 : 	}

	jmp	$LN5@ValidSendT
$LN4@ValidSendT:

; 3490 : 
; 3491 : 	return false;

	xor	al, al
$LN7@ValidSendT:

; 3492 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?ValidSendTarget@RakPeer@@IAE_NUPlayerID@@_N@Z ENDP	; RakPeer::ValidSendTarget
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?PingInternal@RakPeer@@IAEXUPlayerID@@_N@Z
_TEXT	SEGMENT
_currentTime$ = -336					; size = 4
_currentTimeNS$ = -324					; size = 8
_bitStream$ = -308					; size = 273
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_target$ = 8						; size = 6
_performImmediate$ = 16					; size = 1
?PingInternal@RakPeer@@IAEXUPlayerID@@_N@Z PROC		; RakPeer::PingInternal, COMDAT
; _this$ = ecx

; 3391 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PingInternal@RakPeer@@IAEXUPlayerID@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 520				; 00000208H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-532]
	mov	ecx, 130				; 00000082H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3392 : 	if ( IsActive() == false )

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@PingIntern

; 3393 : 		return ;

	jmp	$LN4@PingIntern
$LN3@PingIntern:

; 3394 : 
; 3395 : 	RakNet::BitStream bitStream(sizeof(unsigned char)+sizeof(RakNetTime));

	push	5
	lea	ecx, DWORD PTR _bitStream$[ebp]
	call	??0BitStream@RakNet@@QAE@H@Z		; RakNet::BitStream::BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3396 : 	bitStream.Write((unsigned char)ID_INTERNAL_PING);

	push	2
	lea	ecx, DWORD PTR _bitStream$[ebp]
	call	??$Write@E@BitStream@RakNet@@QAEXE@Z	; RakNet::BitStream::Write<unsigned char>

; 3397 : 	RakNetTimeNS currentTimeNS = RakNet::GetTimeNS();

	call	?GetTimeNS@RakNet@@YA_JXZ		; RakNet::GetTimeNS
	mov	DWORD PTR _currentTimeNS$[ebp], eax
	mov	DWORD PTR _currentTimeNS$[ebp+4], edx

; 3398 : 	RakNetTime currentTime = RakNet::GetTime();

	call	?GetTime@RakNet@@YAIXZ			; RakNet::GetTime
	mov	DWORD PTR _currentTime$[ebp], eax

; 3399 : 	bitStream.Write(currentTime);

	mov	eax, DWORD PTR _currentTime$[ebp]
	push	eax
	lea	ecx, DWORD PTR _bitStream$[ebp]
	call	??$Write@I@BitStream@RakNet@@QAEXI@Z	; RakNet::BitStream::Write<unsigned int>

; 3400 : 	if (performImmediate)

	movzx	eax, BYTE PTR _performImmediate$[ebp]
	test	eax, eax
	je	SHORT $LN2@PingIntern

; 3401 : 		SendImmediate( (char*)bitStream.GetData(), bitStream.GetNumberOfBitsUsed(), SYSTEM_PRIORITY, UNRELIABLE, 0, target, false, false, currentTimeNS );

	mov	eax, DWORD PTR _currentTimeNS$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _currentTimeNS$[ebp]
	push	ecx
	push	0
	push	0
	sub	esp, 8
	mov	edx, esp
	mov	eax, DWORD PTR _target$[ebp]
	mov	DWORD PTR [edx], eax
	mov	cx, WORD PTR _target$[ebp+4]
	mov	WORD PTR [edx+4], cx
	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR _bitStream$[ebp]
	call	?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBitsUsed
	push	eax
	lea	ecx, DWORD PTR _bitStream$[ebp]
	call	?GetData@BitStream@RakNet@@QBEPAEXZ	; RakNet::BitStream::GetData
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendImmediate@RakPeer@@IAE_NPADHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N4_J@Z ; RakPeer::SendImmediate

; 3402 : 	else

	jmp	SHORT $LN1@PingIntern
$LN2@PingIntern:

; 3403 : 		Send( &bitStream, SYSTEM_PRIORITY, UNRELIABLE, 0, target, false );

	mov	esi, esp
	push	0
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _target$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _target$[ebp+4]
	mov	WORD PTR [eax+4], dx
	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _bitStream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@PingIntern:

; 3404 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _bitStream$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
$LN4@PingIntern:
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@PingIntern
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 532				; 00000214H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	1
$LN10@PingIntern:
	DD	1
	DD	$LN9@PingIntern
$LN9@PingIntern:
	DD	-308					; fffffeccH
	DD	273					; 00000111H
	DD	$LN7@PingIntern
$LN7@PingIntern:
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PingInternal@RakPeer@@IAEXUPlayerID@@_N@Z$0:
	lea	ecx, DWORD PTR _bitStream$[ebp]
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__ehhandler$?PingInternal@RakPeer@@IAEXUPlayerID@@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-536]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?PingInternal@RakPeer@@IAEXUPlayerID@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?PingInternal@RakPeer@@IAEXUPlayerID@@_N@Z ENDP		; RakPeer::PingInternal
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?SendStaticDataInternal@RakPeer@@IAEXUPlayerID@@_N@Z
_TEXT	SEGMENT
_reply$ = -308						; size = 273
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_target$ = 8						; size = 6
_performImmediate$ = 16					; size = 1
?SendStaticDataInternal@RakPeer@@IAEXUPlayerID@@_N@Z PROC ; RakPeer::SendStaticDataInternal, COMDAT
; _this$ = ecx

; 3369 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SendStaticDataInternal@RakPeer@@IAEXUPlayerID@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 492				; 000001ecH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-504]
	mov	ecx, 123				; 0000007bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3370 : 	RakNet::BitStream reply( sizeof(unsigned char) + localStaticData.GetNumberOfBytesUsed() );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 11					; 0000000bH
	call	?GetNumberOfBytesUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBytesUsed
	add	eax, 1
	push	eax
	lea	ecx, DWORD PTR _reply$[ebp]
	call	??0BitStream@RakNet@@QAE@H@Z		; RakNet::BitStream::BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3371 : 	reply.Write( (unsigned char) ID_RECEIVED_STATIC_DATA );

	push	38					; 00000026H
	lea	ecx, DWORD PTR _reply$[ebp]
	call	??$Write@E@BitStream@RakNet@@QAEXE@Z	; RakNet::BitStream::Write<unsigned char>

; 3372 : 	reply.Write( (char*)localStaticData.GetData(), localStaticData.GetNumberOfBytesUsed() );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 11					; 0000000bH
	call	?GetNumberOfBytesUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBytesUsed
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 11					; 0000000bH
	call	?GetData@BitStream@RakNet@@QBEPAEXZ	; RakNet::BitStream::GetData
	push	eax
	lea	ecx, DWORD PTR _reply$[ebp]
	call	?Write@BitStream@RakNet@@QAEXPBDH@Z	; RakNet::BitStream::Write

; 3373 : 
; 3374 : 	if (performImmediate)

	movzx	eax, BYTE PTR _performImmediate$[ebp]
	test	eax, eax
	je	$LN6@SendStatic

; 3375 : 	{
; 3376 : 		if ( target == UNASSIGNED_PLAYER_ID )

	push	OFFSET _UNASSIGNED_PLAYER_ID
	lea	ecx, DWORD PTR _target$[ebp]
	call	??8PlayerID@@QBE_NABU0@@Z		; PlayerID::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@SendStatic

; 3377 : 			SendImmediate( (char*)reply.GetData(), reply.GetNumberOfBitsUsed(), SYSTEM_PRIORITY, RELIABLE, 0, target, true, false, RakNet::GetTime() );

	call	?GetTime@RakNet@@YAIXZ			; RakNet::GetTime
	xor	ecx, ecx
	push	ecx
	push	eax
	push	0
	push	1
	sub	esp, 8
	mov	edx, esp
	mov	eax, DWORD PTR _target$[ebp]
	mov	DWORD PTR [edx], eax
	mov	cx, WORD PTR _target$[ebp+4]
	mov	WORD PTR [edx+4], cx
	push	0
	push	2
	push	0
	lea	ecx, DWORD PTR _reply$[ebp]
	call	?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBitsUsed
	push	eax
	lea	ecx, DWORD PTR _reply$[ebp]
	call	?GetData@BitStream@RakNet@@QBEPAEXZ	; RakNet::BitStream::GetData
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendImmediate@RakPeer@@IAE_NPADHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N4_J@Z ; RakPeer::SendImmediate

; 3378 : 		else

	jmp	SHORT $LN4@SendStatic
$LN5@SendStatic:

; 3379 : 			SendImmediate( (char*)reply.GetData(), reply.GetNumberOfBitsUsed(), SYSTEM_PRIORITY, RELIABLE, 0, target, false, false, RakNet::GetTime() );

	call	?GetTime@RakNet@@YAIXZ			; RakNet::GetTime
	xor	ecx, ecx
	push	ecx
	push	eax
	push	0
	push	0
	sub	esp, 8
	mov	edx, esp
	mov	eax, DWORD PTR _target$[ebp]
	mov	DWORD PTR [edx], eax
	mov	cx, WORD PTR _target$[ebp+4]
	mov	WORD PTR [edx+4], cx
	push	0
	push	2
	push	0
	lea	ecx, DWORD PTR _reply$[ebp]
	call	?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBitsUsed
	push	eax
	lea	ecx, DWORD PTR _reply$[ebp]
	call	?GetData@BitStream@RakNet@@QBEPAEXZ	; RakNet::BitStream::GetData
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendImmediate@RakPeer@@IAE_NPADHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N4_J@Z ; RakPeer::SendImmediate
$LN4@SendStatic:

; 3380 : 	}
; 3381 : 	else

	jmp	$LN3@SendStatic
$LN6@SendStatic:

; 3382 : 	{
; 3383 : 		if ( target == UNASSIGNED_PLAYER_ID )

	push	OFFSET _UNASSIGNED_PLAYER_ID
	lea	ecx, DWORD PTR _target$[ebp]
	call	??8PlayerID@@QBE_NABU0@@Z		; PlayerID::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@SendStatic

; 3384 : 			Send( &reply, SYSTEM_PRIORITY, RELIABLE, 0, target, true );

	mov	esi, esp
	push	1
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _target$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _target$[ebp+4]
	mov	WORD PTR [eax+4], dx
	push	0
	push	2
	push	0
	lea	eax, DWORD PTR _reply$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3385 : 		else

	jmp	SHORT $LN3@SendStatic
$LN2@SendStatic:

; 3386 : 			Send( &reply, SYSTEM_PRIORITY, RELIABLE, 0, target, false );

	mov	esi, esp
	push	0
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _target$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _target$[ebp+4]
	mov	WORD PTR [eax+4], dx
	push	0
	push	2
	push	0
	lea	eax, DWORD PTR _reply$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@SendStatic:

; 3387 : 	}
; 3388 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _reply$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN13@SendStatic
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 504				; 000001f8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	3
$LN13@SendStatic:
	DD	1
	DD	$LN12@SendStatic
$LN12@SendStatic:
	DD	-308					; fffffeccH
	DD	273					; 00000111H
	DD	$LN10@SendStatic
$LN10@SendStatic:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	121					; 00000079H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SendStaticDataInternal@RakPeer@@IAEXUPlayerID@@_N@Z$0:
	lea	ecx, DWORD PTR _reply$[ebp]
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__ehhandler$?SendStaticDataInternal@RakPeer@@IAEXUPlayerID@@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-508]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SendStaticDataInternal@RakPeer@@IAEXUPlayerID@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SendStaticDataInternal@RakPeer@@IAEXUPlayerID@@_N@Z ENDP ; RakPeer::SendStaticDataInternal
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?AllowIncomingConnections@RakPeer@@IBE_NXZ
_TEXT	SEGMENT
tv77 = -208						; size = 4
_this$ = -8						; size = 4
?AllowIncomingConnections@RakPeer@@IBE_NXZ PROC		; RakPeer::AllowIncomingConnections, COMDAT
; _this$ = ecx

; 3364 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3365 : 	return GetNumberOfRemoteInitiatedConnections() < GetMaximumIncomingConnections();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumberOfRemoteInitiatedConnections@RakPeer@@IBEGXZ ; RakPeer::GetNumberOfRemoteInitiatedConnections
	movzx	esi, ax
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	edi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	call	eax
	cmp	edi, esp
	call	__RTC_CheckEsp
	movzx	ecx, ax
	cmp	esi, ecx
	jge	SHORT $LN3@AllowIncom
	mov	DWORD PTR tv77[ebp], 1
	jmp	SHORT $LN4@AllowIncom
$LN3@AllowIncom:
	mov	DWORD PTR tv77[ebp], 0
$LN4@AllowIncom:
	mov	al, BYTE PTR tv77[ebp]

; 3366 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?AllowIncomingConnections@RakPeer@@IBE_NXZ ENDP		; RakPeer::AllowIncomingConnections
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\singleproducerconsumer.h
;	COMDAT ?Clear@?$SingleProducerConsumer@UBufferedCommandStruct@RakPeer@@@DataStructures@@QAEXXZ
_TEXT	SEGMENT
tv79 = -248						; size = 4
tv78 = -244						; size = 4
$T1 = -236						; size = 4
_listSize$ = -32					; size = 4
_next$ = -20						; size = 4
_this$ = -8						; size = 4
?Clear@?$SingleProducerConsumer@UBufferedCommandStruct@RakPeer@@@DataStructures@@QAEXXZ PROC ; DataStructures::SingleProducerConsumer<RakPeer::BufferedCommandStruct>::Clear, COMDAT
; _this$ = ecx

; 216  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 248				; 000000f8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-248]
	mov	ecx, 62					; 0000003eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 217  : 		// Shrink the list down to MINIMUM_LIST_SIZE elements
; 218  : 		volatile DataPlusPtr *next;
; 219  : 		writePointer=readPointer->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+42]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 220  : 
; 221  : 		int listSize=1;

	mov	DWORD PTR _listSize$[ebp], 1

; 222  : 		next=readPointer->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+42]
	mov	DWORD PTR _next$[ebp], edx
$LN4@Clear:

; 223  : 		while (next!=readPointer)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _next$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	je	SHORT $LN2@Clear

; 224  : 		{
; 225  : 			listSize++;

	mov	eax, DWORD PTR _listSize$[ebp]
	add	eax, 1
	mov	DWORD PTR _listSize$[ebp], eax

; 226  : 			next=next->next;

	mov	eax, DWORD PTR _next$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	mov	DWORD PTR _next$[ebp], ecx

; 227  : 		}

	jmp	SHORT $LN4@Clear
$LN2@Clear:

; 228  : 
; 229  : 		while (listSize-- > MINIMUM_LIST_SIZE)

	mov	eax, DWORD PTR _listSize$[ebp]
	mov	DWORD PTR tv78[ebp], eax
	mov	ecx, DWORD PTR _listSize$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _listSize$[ebp], ecx
	cmp	DWORD PTR tv78[ebp], 8
	jle	SHORT $LN7@Clear
	mov	DWORD PTR tv79[ebp], 1
	jmp	SHORT $LN8@Clear
$LN7@Clear:
	mov	DWORD PTR tv79[ebp], 0
$LN8@Clear:
	cmp	DWORD PTR tv79[ebp], 0
	je	SHORT $LN1@Clear

; 230  : 		{
; 231  : 			next=writePointer->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+42]
	mov	DWORD PTR _next$[ebp], edx

; 232  : #ifdef _DEBUG
; 233  : 			assert(writePointer!=readPointer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN9@Clear
	push	233					; 000000e9H
	push	OFFSET ??_C@_1GC@EGJKEKIF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAs?$AAi?$AAn?$AAg?$AAl?$AAe?$AAp?$AAr@
	push	OFFSET ??_C@_1DE@FCOMCLAG@?$AAw?$AAr?$AAi?$AAt?$AAe?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$CB?$AA?$DN?$AAr?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN9@Clear:

; 234  : #endif
; 235  : 			delete (char*) writePointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 236  : 			writePointer=next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _next$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 237  : 		}

	jmp	$LN2@Clear
$LN1@Clear:

; 238  : 
; 239  : 		readPointer->next=writePointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+42], eax

; 240  : 		writePointer=readPointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+12], edx

; 241  : 		readAheadPointer=readPointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], edx

; 242  : 		writeAheadPointer=writePointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+4], edx

; 243  : 		readCount=writeCount=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 244  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 248				; 000000f8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$SingleProducerConsumer@UBufferedCommandStruct@RakPeer@@@DataStructures@@QAEXXZ ENDP ; DataStructures::SingleProducerConsumer<RakPeer::BufferedCommandStruct>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\singleproducerconsumer.h
;	COMDAT ?ReadUnlock@?$SingleProducerConsumer@UBufferedCommandStruct@RakPeer@@@DataStructures@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?ReadUnlock@?$SingleProducerConsumer@UBufferedCommandStruct@RakPeer@@@DataStructures@@QAEXXZ PROC ; DataStructures::SingleProducerConsumer<RakPeer::BufferedCommandStruct>::ReadUnlock, COMDAT
; _this$ = ecx

; 202  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 203  : #ifdef _DEBUG
; 204  : 		assert(readAheadPointer!=readPointer); // If hits, then called ReadUnlock before ReadLock

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN3@ReadUnlock
	push	204					; 000000ccH
	push	OFFSET ??_C@_1GC@EGJKEKIF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAs?$AAi?$AAn?$AAg?$AAl?$AAe?$AAp?$AAr@
	push	OFFSET ??_C@_1DM@HLMOCDPL@?$AAr?$AAe?$AAa?$AAd?$AAA?$AAh?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$CB?$AA?$DN?$AAr?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@ReadUnlock:

; 205  : 		assert(readPointer!=writePointer); // If hits, then called ReadUnlock when Read returns 0

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN4@ReadUnlock
	push	205					; 000000cdH
	push	OFFSET ??_C@_1GC@EGJKEKIF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAs?$AAi?$AAn?$AAg?$AAl?$AAe?$AAp?$AAr@
	push	OFFSET ??_C@_1DE@PPJJMKJI@?$AAr?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$CB?$AA?$DN?$AAw?$AAr?$AAi?$AAt?$AAe?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@ReadUnlock:

; 206  : #endif
; 207  : 		readCount++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 208  : 
; 209  : 		// Allow writes to this memory block
; 210  : 		readPointer->readyToRead=false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	BYTE PTR [ecx+41], 0

; 211  : 		readPointer=readPointer->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+42]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 212  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadUnlock@?$SingleProducerConsumer@UBufferedCommandStruct@RakPeer@@@DataStructures@@QAEXXZ ENDP ; DataStructures::SingleProducerConsumer<RakPeer::BufferedCommandStruct>::ReadUnlock
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\singleproducerconsumer.h
;	COMDAT ?ReadLock@?$SingleProducerConsumer@UBufferedCommandStruct@RakPeer@@@DataStructures@@QAEPAUBufferedCommandStruct@RakPeer@@XZ
_TEXT	SEGMENT
_last$ = -20						; size = 4
_this$ = -8						; size = 4
?ReadLock@?$SingleProducerConsumer@UBufferedCommandStruct@RakPeer@@@DataStructures@@QAEPAUBufferedCommandStruct@RakPeer@@XZ PROC ; DataStructures::SingleProducerConsumer<RakPeer::BufferedCommandStruct>::ReadLock, COMDAT
; _this$ = ecx

; 178  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 179  : 			if (readAheadPointer==writePointer ||
; 180  : 				readAheadPointer->readyToRead==false)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+12]
	je	SHORT $LN1@ReadLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx+41]
	test	edx, edx
	jne	SHORT $LN2@ReadLock
$LN1@ReadLock:

; 181  : 			{
; 182  : 				return 0;

	xor	eax, eax
	jmp	SHORT $LN3@ReadLock
$LN2@ReadLock:

; 183  : 			}
; 184  : 
; 185  : 			volatile DataPlusPtr *last;
; 186  : 			last=readAheadPointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _last$[ebp], ecx

; 187  : 			readAheadPointer=readAheadPointer->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+42]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], edx

; 188  : 			return (SingleProducerConsumerType*)last;

	mov	eax, DWORD PTR _last$[ebp]
$LN3@ReadLock:

; 189  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadLock@?$SingleProducerConsumer@UBufferedCommandStruct@RakPeer@@@DataStructures@@QAEPAUBufferedCommandStruct@RakPeer@@XZ ENDP ; DataStructures::SingleProducerConsumer<RakPeer::BufferedCommandStruct>::ReadLock
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\singleproducerconsumer.h
;	COMDAT ?WriteUnlock@?$SingleProducerConsumer@UBufferedCommandStruct@RakPeer@@@DataStructures@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?WriteUnlock@?$SingleProducerConsumer@UBufferedCommandStruct@RakPeer@@@DataStructures@@QAEXXZ PROC ; DataStructures::SingleProducerConsumer<RakPeer::BufferedCommandStruct>::WriteUnlock, COMDAT
; _this$ = ecx

; 162  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 163  : 		//	DataPlusPtr *dataContainer = (DataPlusPtr *)structure;
; 164  : 
; 165  : #ifdef _DEBUG
; 166  : 		assert(writePointer->next!=readPointer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+42]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $LN3@WriteUnloc
	push	166					; 000000a6H
	push	OFFSET ??_C@_1GC@EGJKEKIF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAs?$AAi?$AAn?$AAg?$AAl?$AAe?$AAp?$AAr@
	push	OFFSET ??_C@_1EA@OAIJHOON@?$AAw?$AAr?$AAi?$AAt?$AAe?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AA?$CB?$AA?$DN?$AAr?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@WriteUnloc:

; 167  : 		assert(writePointer!=writeAheadPointer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@WriteUnloc
	push	167					; 000000a7H
	push	OFFSET ??_C@_1GC@EGJKEKIF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAs?$AAi?$AAn?$AAg?$AAl?$AAe?$AAp?$AAr@
	push	OFFSET ??_C@_1EA@LEKNHFBP@?$AAw?$AAr?$AAi?$AAt?$AAe?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$CB?$AA?$DN?$AAw?$AAr?$AAi?$AAt?$AAe?$AAA?$AAh?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@WriteUnloc:

; 168  : #endif
; 169  : 
; 170  : 		writeCount++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 171  : 		// User is done with the data, allow send by updating the write pointer
; 172  : 		writePointer->readyToRead=true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	BYTE PTR [ecx+41], 1

; 173  : 		writePointer=writePointer->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+42]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 174  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?WriteUnlock@?$SingleProducerConsumer@UBufferedCommandStruct@RakPeer@@@DataStructures@@QAEXXZ ENDP ; DataStructures::SingleProducerConsumer<RakPeer::BufferedCommandStruct>::WriteUnlock
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\singleproducerconsumer.h
;	COMDAT ?WriteLock@?$SingleProducerConsumer@UBufferedCommandStruct@RakPeer@@@DataStructures@@QAEPAUBufferedCommandStruct@RakPeer@@XZ
_TEXT	SEGMENT
$T1 = -236						; size = 4
_last$ = -32						; size = 4
_originalNext$2 = -20					; size = 4
_this$ = -8						; size = 4
?WriteLock@?$SingleProducerConsumer@UBufferedCommandStruct@RakPeer@@@DataStructures@@QAEPAUBufferedCommandStruct@RakPeer@@XZ PROC ; DataStructures::SingleProducerConsumer<RakPeer::BufferedCommandStruct>::WriteLock, COMDAT
; _this$ = ecx

; 137  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 138  : 		if (writeAheadPointer->next==readPointer ||
; 139  : 			writeAheadPointer->next->readyToRead==true)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+42]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR [eax+8]
	je	SHORT $LN1@WriteLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+42]
	movzx	eax, BYTE PTR [edx+41]
	cmp	eax, 1
	jne	SHORT $LN2@WriteLock
$LN1@WriteLock:

; 140  : 		{
; 141  : 			volatile DataPlusPtr *originalNext=writeAheadPointer->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+42]
	mov	DWORD PTR _originalNext$2[ebp], edx

; 142  : 			writeAheadPointer->next=new DataPlusPtr;

	push	46					; 0000002eH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [ecx+42], edx

; 143  : 			assert(writeAheadPointer->next);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+42], 0
	jne	SHORT $LN5@WriteLock
	push	143					; 0000008fH
	push	OFFSET ??_C@_1GC@EGJKEKIF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAs?$AAi?$AAn?$AAg?$AAl?$AAe?$AAp?$AAr@
	push	OFFSET ??_C@_1DA@FABPCGM@?$AAw?$AAr?$AAi?$AAt?$AAe?$AAA?$AAh?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN5@WriteLock:

; 144  : 			writeAheadPointer->next->next=originalNext;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+42]
	mov	eax, DWORD PTR _originalNext$2[ebp]
	mov	DWORD PTR [edx+42], eax
$LN2@WriteLock:

; 145  : 		}
; 146  : 
; 147  : 		volatile DataPlusPtr *last;
; 148  : 		last=writeAheadPointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _last$[ebp], ecx

; 149  : 		writeAheadPointer=writeAheadPointer->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+42]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 150  : 
; 151  : 		return (SingleProducerConsumerType*) last;

	mov	eax, DWORD PTR _last$[ebp]

; 152  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?WriteLock@?$SingleProducerConsumer@UBufferedCommandStruct@RakPeer@@@DataStructures@@QAEPAUBufferedCommandStruct@RakPeer@@XZ ENDP ; DataStructures::SingleProducerConsumer<RakPeer::BufferedCommandStruct>::WriteLock
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\singleproducerconsumer.h
;	COMDAT ??1?$SingleProducerConsumer@UBufferedCommandStruct@RakPeer@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T1 = -236						; size = 4
$T2 = -224						; size = 4
_next$ = -20						; size = 4
_this$ = -8						; size = 4
??1?$SingleProducerConsumer@UBufferedCommandStruct@RakPeer@@@DataStructures@@QAE@XZ PROC ; DataStructures::SingleProducerConsumer<RakPeer::BufferedCommandStruct>::~SingleProducerConsumer<RakPeer::BufferedCommandStruct>, COMDAT
; _this$ = ecx

; 123  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		volatile DataPlusPtr *next;
; 125  : 		readPointer=writeAheadPointer->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+42]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx
$LN2@SingleProd:

; 126  : 		while (readPointer!=writeAheadPointer)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+4]
	je	SHORT $LN1@SingleProd

; 127  : 		{
; 128  : 			next=readPointer->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+42]
	mov	DWORD PTR _next$[ebp], edx

; 129  : 			delete (char*) readPointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 130  : 			readPointer=next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _next$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 131  : 		}

	jmp	SHORT $LN2@SingleProd
$LN1@SingleProd:

; 132  : 		delete (char*) readPointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 133  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$SingleProducerConsumer@UBufferedCommandStruct@RakPeer@@@DataStructures@@QAE@XZ ENDP ; DataStructures::SingleProducerConsumer<RakPeer::BufferedCommandStruct>::~SingleProducerConsumer<RakPeer::BufferedCommandStruct>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\singleproducerconsumer.h
;	COMDAT ??0?$SingleProducerConsumer@UBufferedCommandStruct@RakPeer@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T1 = -248						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_listSize$ = -20					; size = 4
_this$ = -8						; size = 4
??0?$SingleProducerConsumer@UBufferedCommandStruct@RakPeer@@@DataStructures@@QAE@XZ PROC ; DataStructures::SingleProducerConsumer<RakPeer::BufferedCommandStruct>::SingleProducerConsumer<RakPeer::BufferedCommandStruct>, COMDAT
; _this$ = ecx

; 100  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 101  : 		// Preallocate
; 102  : 		readPointer = new DataPlusPtr;

	push	46					; 0000002eH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax+8], ecx

; 103  : 		writePointer=readPointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+12], edx

; 104  : 		readPointer->next = new DataPlusPtr;

	push	46					; 0000002eH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [ecx+42], edx

; 105  : 		int listSize;
; 106  : #ifdef _DEBUG
; 107  : 		assert(MINIMUM_LIST_SIZE>=3);
; 108  : #endif
; 109  : 		for (listSize=2; listSize < MINIMUM_LIST_SIZE; listSize++)

	mov	DWORD PTR _listSize$[ebp], 2
	jmp	SHORT $LN3@SingleProd
$LN2@SingleProd:
	mov	eax, DWORD PTR _listSize$[ebp]
	add	eax, 1
	mov	DWORD PTR _listSize$[ebp], eax
$LN3@SingleProd:
	cmp	DWORD PTR _listSize$[ebp], 8
	jge	SHORT $LN1@SingleProd

; 110  : 		{
; 111  : 			readPointer=readPointer->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+42]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 112  : 			readPointer->next = new DataPlusPtr;

	push	46					; 0000002eH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR [ecx+42], edx

; 113  : 		}

	jmp	SHORT $LN2@SingleProd
$LN1@SingleProd:

; 114  : 		readPointer->next->next=writePointer; // last to next = start

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+42]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+42], ecx

; 115  : 		readPointer=writePointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+8], edx

; 116  : 		readAheadPointer=readPointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], edx

; 117  : 		writeAheadPointer=writePointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+4], edx

; 118  : 		readCount=writeCount=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 119  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$SingleProducerConsumer@UBufferedCommandStruct@RakPeer@@@DataStructures@@QAE@XZ ENDP ; DataStructures::SingleProducerConsumer<RakPeer::BufferedCommandStruct>::SingleProducerConsumer<RakPeer::BufferedCommandStruct>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?RunUpdateCycle@RakPeer@@IAE_NXZ
_TEXT	SEGMENT
tv742 = -3752						; size = 4
tv272 = -3752						; size = 4
tv202 = -3752						; size = 4
tv210 = -3749						; size = 1
$T2 = -3744						; size = 4
$T3 = -3732						; size = 4
$T4 = -3720						; size = 4
$T5 = -3708						; size = 4
$T6 = -3696						; size = 4
$T7 = -3684						; size = 4
$T8 = -3672						; size = 4
$T9 = -3660						; size = 4
$T10 = -3648						; size = 4
$T11 = -3636						; size = 4
$T12 = -3624						; size = 4
$T13 = -3612						; size = 4
$T14 = -3600						; size = 4
$T15 = -3588						; size = 4
$T16 = -3576						; size = 4
$T17 = -3564						; size = 4
$T18 = -3552						; size = 4
$T19 = -3540						; size = 4
$T20 = -3528						; size = 4
$T21 = -3516						; size = 4
_outBitStream$22 = -3312				; size = 273
_inBitStream$23 = -3028					; size = 273
_playerIndex$24 = -2744					; size = 2
_externalID$25 = -2732					; size = 6
_alreadyConnected$26 = -2713				; size = 1
_allowConnection$27 = -2701				; size = 1
_encryptedMessage$28 = -2692				; size = 32
_message$29 = -2652					; size = 32
_AESKey$30 = -2612					; size = 16
_i$31 = -2588						; size = 4
_newRandNumber$32 = -2573				; size = 1
_confirmedHash$33 = -2561				; size = 1
_sha1$34 = -2552					; size = 180
_output$35 = -2364					; size = 256
_index$36 = -2097					; size = 1
_inBitStream$37 = -2088					; size = 273
_outBitStream$38 = -1804				; size = 273
_sendPingTime$39 = -1520				; size = 4
_inBitStream$40 = -1508					; size = 273
_inBitStream$41 = -1224					; size = 273
_sendPongTime$42 = -940					; size = 4
_sendPingTime$43 = -928					; size = 4
_bsPlayerId$44 = -916					; size = 6
_inBitStream$45 = -900					; size = 273
_dataCopy$46 = -616					; size = 4
_dataBitStream$47 = -604				; size = 273
_keepAlive$48 = -317					; size = 1
_i$49 = -308						; size = 4
_c$50 = -296						; size = 2
_condition2$ = -281					; size = 1
_condition1$ = -269					; size = 1
_rcs$ = -260						; size = 4
_rcsFirst$ = -248					; size = 4
_rnss$ = -236						; size = 4
_callerDataAllocationUsed$ = -221			; size = 1
_bcs$ = -212						; size = 4
_playerId$ = -200					; size = 6
_timeMS$ = -184						; size = 4
_timeNS$ = -172						; size = 8
_gotData$ = -156					; size = 4
_errorCode$ = -144					; size = 4
_data$ = -132						; size = 4
_byteSize$ = -120					; size = 4
_bitSize$ = -108					; size = 4
_numberOfBitsUsed$ = -96				; size = 4
_lastPing$ = -84					; size = 4
_ping$ = -72						; size = 4
_packet$ = -60						; size = 4
_remoteSystemIndex$ = -48				; size = 4
_remoteSystem$ = -36					; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?RunUpdateCycle@RakPeer@@IAE_NXZ PROC			; RakPeer::RunUpdateCycle, COMDAT
; _this$ = ecx

; 4221 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?RunUpdateCycle@RakPeer@@IAE_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 3740				; 00000e9cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-3752]
	mov	ecx, 935				; 000003a7H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
$LN118@RunUpdateC:

; 4222 : 	RakPeer::RemoteSystemStruct * remoteSystem;
; 4223 : 	unsigned remoteSystemIndex;
; 4224 : 	Packet *packet;
; 4225 : 	RakNetTime ping, lastPing;
; 4226 : 	// int currentSentBytes,currentReceivedBytes;
; 4227 : //	unsigned numberOfBytesUsed;
; 4228 : 	unsigned numberOfBitsUsed;
; 4229 : 	//PlayerID authoritativeClientPlayerId;
; 4230 : 	int bitSize, byteSize;
; 4231 : 	unsigned char *data;
; 4232 : 	int errorCode;
; 4233 : 	int gotData;
; 4234 : 	RakNetTimeNS timeNS;
; 4235 : 	RakNetTime timeMS;
; 4236 : 	PlayerID playerId;
; 4237 : 	BufferedCommandStruct *bcs;
; 4238 : 	bool callerDataAllocationUsed;
; 4239 : 	RakNetStatisticsStruct *rnss;
; 4240 : 
; 4241 : 	do
; 4242 : 	{
; 4243 : 		// Read a packet
; 4244 : 		gotData = SocketLayer::Instance()->RecvFrom( connectionSocket, this, &errorCode );

	lea	eax, DWORD PTR _errorCode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2070]
	push	eax
	call	?Instance@SocketLayer@@SAPAV1@XZ	; SocketLayer::Instance
	mov	ecx, eax
	call	?RecvFrom@SocketLayer@@QAEHIPAVRakPeer@@PAH@Z ; SocketLayer::RecvFrom
	mov	DWORD PTR _gotData$[ebp], eax

; 4245 : 
; 4246 : 		if ( gotData == SOCKET_ERROR )

	cmp	DWORD PTR _gotData$[ebp], -1
	jne	SHORT $LN115@RunUpdateC

; 4247 : 		{
; 4248 : #ifdef _WIN32
; 4249 : 			if ( errorCode == WSAECONNRESET )

	cmp	DWORD PTR _errorCode$[ebp], 10054	; 00002746H
	jne	SHORT $LN114@RunUpdateC

; 4250 : 			{
; 4251 : 				gotData=false;

	mov	DWORD PTR _gotData$[ebp], 0

; 4252 : 				// 11/14/05 - RecvFrom now calls HandlePortUnreachable rather than PushPortRefused
; 4253 : 				//PushPortRefused( UNASSIGNED_PLAYER_ID );
; 4254 : 				//closesocket(peer->connectionSocket);
; 4255 : 
; 4256 : 				//peer->connectionSocket = SocketLayer::Instance()->CreateBoundSocket(peer->myPlayerId.port, true);
; 4257 : 			}
; 4258 : 			else

	jmp	SHORT $LN115@RunUpdateC
$LN114@RunUpdateC:

; 4259 : 				if ( errorCode != 0 && endThreads == false )

	cmp	DWORD PTR _errorCode$[ebp], 0
	je	SHORT $LN115@RunUpdateC
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN115@RunUpdateC

; 4260 : 				{
; 4261 : #ifdef _DO_PRINTF
; 4262 : 					printf( "Server RecvFrom critical failure!\n" );
; 4263 : #endif
; 4264 : 					// Some kind of critical error
; 4265 : 					// peer->isRecvfromThreadActive=false;
; 4266 : 					endThreads = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+4], 1

; 4267 : 					Disconnect( 0, 0 );

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4268 : 					return false;

	xor	al, al
	jmp	$LN120@RunUpdateC
$LN115@RunUpdateC:

; 4269 : 				}
; 4270 : 
; 4271 : #else
; 4272 : 			if ( errorCode == -1 )
; 4273 : 			{
; 4274 : 				// isRecvfromThreadActive=false;
; 4275 : 				endThreads = true;
; 4276 : 				Disconnect( 0 );
; 4277 : 				return false;
; 4278 : 			}
; 4279 : #endif
; 4280 : 		}
; 4281 : 
; 4282 : 		if ( endThreads )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN117@RunUpdateC

; 4283 : 			return false;

	xor	al, al
	jmp	$LN120@RunUpdateC
$LN117@RunUpdateC:

; 4284 : 	}
; 4285 : 	while ( gotData>0 ); // Read until there is nothing left

	cmp	DWORD PTR _gotData$[ebp], 0
	jg	$LN118@RunUpdateC

; 4286 : 
; 4287 : 	timeNS=0;

	xorpd	xmm0, xmm0
	movlpd	QWORD PTR _timeNS$[ebp], xmm0

; 4288 : 	timeMS=0;

	mov	DWORD PTR _timeMS$[ebp], 0
$LN110@RunUpdateC:

; 4289 : 
; 4290 : 	// Process all the deferred user thread Send and connect calls
; 4291 : 	while ((bcs=bufferedCommands.ReadLock())!=0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2025				; 000007e9H
	call	?ReadLock@?$SingleProducerConsumer@UBufferedCommandStruct@RakPeer@@@DataStructures@@QAEPAUBufferedCommandStruct@RakPeer@@XZ ; DataStructures::SingleProducerConsumer<RakPeer::BufferedCommandStruct>::ReadLock
	mov	DWORD PTR _bcs$[ebp], eax
	cmp	DWORD PTR _bcs$[ebp], 0
	je	$LN109@RunUpdateC

; 4292 : 	{
; 4293 : 		if (bcs->command==BufferedCommandStruct::BCS_SEND)

	mov	eax, DWORD PTR _bcs$[ebp]
	cmp	DWORD PTR [eax+37], 0
	jne	$LN108@RunUpdateC

; 4294 : 		{
; 4295 : 			// GetTime is a very slow call so do it once and as late as possible
; 4296 : 			if (timeNS==0)

	mov	eax, DWORD PTR _timeNS$[ebp]
	or	eax, DWORD PTR _timeNS$[ebp+4]
	jne	SHORT $LN107@RunUpdateC

; 4297 : 				timeNS = RakNet::GetTimeNS();

	call	?GetTimeNS@RakNet@@YA_JXZ		; RakNet::GetTimeNS
	mov	DWORD PTR _timeNS$[ebp], eax
	mov	DWORD PTR _timeNS$[ebp+4], edx
$LN107@RunUpdateC:

; 4298 : 
; 4299 : 			callerDataAllocationUsed=SendImmediate((char*)bcs->data, bcs->numberOfBitsToSend, bcs->priority, bcs->reliability, bcs->orderingChannel, bcs->playerId, bcs->broadcast, true, timeNS);

	mov	eax, DWORD PTR _timeNS$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _timeNS$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _bcs$[ebp]
	movzx	eax, BYTE PTR [edx+19]
	push	eax
	mov	ecx, DWORD PTR _bcs$[ebp]
	add	ecx, 13					; 0000000dH
	sub	esp, 8
	mov	edx, esp
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	cx, WORD PTR [ecx+4]
	mov	WORD PTR [edx+4], cx
	mov	edx, DWORD PTR _bcs$[ebp]
	movzx	eax, BYTE PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _bcs$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _bcs$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _bcs$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _bcs$[ebp]
	mov	edx, DWORD PTR [ecx+33]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendImmediate@RakPeer@@IAE_NPADHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N4_J@Z ; RakPeer::SendImmediate
	mov	BYTE PTR _callerDataAllocationUsed$[ebp], al

; 4300 : 			if ( callerDataAllocationUsed==false )

	movzx	eax, BYTE PTR _callerDataAllocationUsed$[ebp]
	test	eax, eax
	jne	SHORT $LN106@RunUpdateC

; 4301 : 				delete bcs->data;

	mov	eax, DWORD PTR _bcs$[ebp]
	mov	ecx, DWORD PTR [eax+33]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN106@RunUpdateC:

; 4302 : 
; 4303 : 			// Set the new connection state AFTER we call sendImmediate in case we are setting it to a disconnection state, which does not allow further sends
; 4304 : 			if (bcs->connectionMode!=RemoteSystemStruct::NO_ACTION && bcs->playerId!=UNASSIGNED_PLAYER_ID)

	mov	eax, DWORD PTR _bcs$[ebp]
	cmp	DWORD PTR [eax+20], 0
	je	SHORT $LN105@RunUpdateC
	push	OFFSET _UNASSIGNED_PLAYER_ID
	mov	ecx, DWORD PTR _bcs$[ebp]
	add	ecx, 13					; 0000000dH
	call	??9PlayerID@@QBE_NABU0@@Z		; PlayerID::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN105@RunUpdateC

; 4305 : 			{
; 4306 : 				remoteSystem=GetRemoteSystemFromPlayerID( bcs->playerId, true, true );

	push	1
	push	1
	mov	eax, DWORD PTR _bcs$[ebp]
	add	eax, 13					; 0000000dH
	sub	esp, 8
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	ax, WORD PTR [eax+4]
	mov	WORD PTR [ecx+4], ax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRemoteSystemFromPlayerID@RakPeer@@IBEPAURemoteSystemStruct@1@UPlayerID@@_N1@Z ; RakPeer::GetRemoteSystemFromPlayerID
	mov	DWORD PTR _remoteSystem$[ebp], eax

; 4307 : 			//	if (remoteSystem==0)
; 4308 : 			//		remoteSystem=AssignSystemAddressToRemoteSystemList(bcs->systemAddress, bcs->connectionMode);
; 4309 : 				if (remoteSystem)

	cmp	DWORD PTR _remoteSystem$[ebp], 0
	je	SHORT $LN105@RunUpdateC

; 4310 : 					remoteSystem->connectMode=bcs->connectionMode;

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	mov	ecx, DWORD PTR _bcs$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+2054], edx
$LN105@RunUpdateC:

; 4311 : 			}
; 4312 : 		}
; 4313 : 		else

	jmp	SHORT $LN103@RunUpdateC
$LN108@RunUpdateC:

; 4314 : 		{
; 4315 : #ifdef _DEBUG
; 4316 : 			assert(bcs->command==BufferedCommandStruct::BCS_CLOSE_CONNECTION);

	mov	eax, DWORD PTR _bcs$[ebp]
	cmp	DWORD PTR [eax+37], 1
	je	SHORT $LN121@RunUpdateC
	mov	ecx, DWORD PTR ?__LINE__Var@?1??RunUpdateCycle@RakPeer@@IAE_NXZ@4JA
	add	ecx, 95					; 0000005fH
	push	ecx
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_1HE@GIGKOHOC@?$AAb?$AAc?$AAs?$AA?9?$AA?$DO?$AAc?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AA?$DN?$AA?$DN?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AAe?$AAd?$AAC?$AAo?$AAm?$AAm?$AAa?$AAn?$AAd?$AAS?$AAt?$AAr@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN121@RunUpdateC:

; 4317 : #endif
; 4318 : 			CloseConnectionInternal(bcs->playerId, false, true, bcs->orderingChannel);

	mov	eax, DWORD PTR _bcs$[ebp]
	movzx	ecx, BYTE PTR [eax+12]
	push	ecx
	push	1
	push	0
	mov	edx, DWORD PTR _bcs$[ebp]
	add	edx, 13					; 0000000dH
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR [edx+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CloseConnectionInternal@RakPeer@@IAEXUPlayerID@@_N1E@Z ; RakPeer::CloseConnectionInternal
$LN103@RunUpdateC:

; 4319 : 		}
; 4320 : 
; 4321 : #ifdef _DEBUG
; 4322 : 		bcs->data=0;

	mov	eax, DWORD PTR _bcs$[ebp]
	mov	DWORD PTR [eax+33], 0

; 4323 : #endif
; 4324 : 
; 4325 : 		bufferedCommands.ReadUnlock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2025				; 000007e9H
	call	?ReadUnlock@?$SingleProducerConsumer@UBufferedCommandStruct@RakPeer@@@DataStructures@@QAEXXZ ; DataStructures::SingleProducerConsumer<RakPeer::BufferedCommandStruct>::ReadUnlock

; 4326 : 	}

	jmp	$LN110@RunUpdateC
$LN109@RunUpdateC:

; 4327 : 
; 4328 : 	// Process connection attempts
; 4329 : 	RequestedConnectionStruct *rcsFirst, *rcs;
; 4330 : 	bool condition1, condition2;
; 4331 :     rcsFirst = requestedConnectionList.ReadLock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 953				; 000003b9H
	call	?ReadLock@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEPAURequestedConnectionStruct@RakPeer@@XZ ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::ReadLock
	mov	DWORD PTR _rcsFirst$[ebp], eax

; 4332 : 	rcs=rcsFirst;

	mov	eax, DWORD PTR _rcsFirst$[ebp]
	mov	DWORD PTR _rcs$[ebp], eax
$LN102@RunUpdateC:

; 4333 : 	while (rcs)

	cmp	DWORD PTR _rcs$[ebp], 0
	je	$LN101@RunUpdateC

; 4334 : 	{
; 4335 : 		if (timeNS==0)

	mov	eax, DWORD PTR _timeNS$[ebp]
	or	eax, DWORD PTR _timeNS$[ebp+4]
	jne	SHORT $LN100@RunUpdateC

; 4336 : 		{
; 4337 : 			timeNS = RakNet::GetTimeNS();

	call	?GetTimeNS@RakNet@@YA_JXZ		; RakNet::GetTimeNS
	mov	DWORD PTR _timeNS$[ebp], eax
	mov	DWORD PTR _timeNS$[ebp+4], edx

; 4338 : 			timeMS = (RakNetTime)(timeNS/(RakNetTimeNS)1000);

	push	0
	push	1000					; 000003e8H
	mov	eax, DWORD PTR _timeNS$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _timeNS$[ebp]
	push	ecx
	call	__alldiv
	mov	DWORD PTR _timeMS$[ebp], eax
$LN100@RunUpdateC:

; 4339 : 		}
; 4340 : 
; 4341 : 		if (rcs->nextRequestTime < timeMS)

	mov	eax, DWORD PTR _rcs$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	cmp	ecx, DWORD PTR _timeMS$[ebp]
	jae	$LN99@RunUpdateC

; 4342 : 		{
; 4343 : 			condition1=rcs->requestsMade==6;

	mov	eax, DWORD PTR _rcs$[ebp]
	movzx	ecx, BYTE PTR [eax+10]
	cmp	ecx, 6
	jne	SHORT $LN122@RunUpdateC
	mov	DWORD PTR tv202[ebp], 1
	jmp	SHORT $LN123@RunUpdateC
$LN122@RunUpdateC:
	mov	DWORD PTR tv202[ebp], 0
$LN123@RunUpdateC:
	mov	dl, BYTE PTR tv202[ebp]
	mov	BYTE PTR _condition1$[ebp], dl

; 4344 : 			condition2=(bool)((rcs->playerId==UNASSIGNED_PLAYER_ID)==1);

	push	OFFSET _UNASSIGNED_PLAYER_ID
	mov	ecx, DWORD PTR _rcs$[ebp]
	call	??8PlayerID@@QBE_NABU0@@Z		; PlayerID::operator==
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN124@RunUpdateC
	mov	BYTE PTR tv210[ebp], 1
	jmp	SHORT $LN125@RunUpdateC
$LN124@RunUpdateC:
	mov	BYTE PTR tv210[ebp], 0
$LN125@RunUpdateC:
	mov	cl, BYTE PTR tv210[ebp]
	mov	BYTE PTR _condition2$[ebp], cl

; 4345 : 			// If too many requests made or a hole then remove this if possible, otherwise invalidate it
; 4346 : 			if (condition1 || condition2)

	movzx	eax, BYTE PTR _condition1$[ebp]
	test	eax, eax
	jne	SHORT $LN97@RunUpdateC
	movzx	eax, BYTE PTR _condition2$[ebp]
	test	eax, eax
	je	$LN98@RunUpdateC
$LN97@RunUpdateC:

; 4347 : 			{
; 4348 : 				if (rcs->data)

	mov	eax, DWORD PTR _rcs$[ebp]
	cmp	DWORD PTR [eax+11], 0
	je	SHORT $LN96@RunUpdateC

; 4349 : 				{
; 4350 : 					delete [] rcs->data;

	mov	eax, DWORD PTR _rcs$[ebp]
	mov	ecx, DWORD PTR [eax+11]
	mov	DWORD PTR $T3[ebp], ecx
	mov	edx, DWORD PTR $T3[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 4351 : 					rcs->data=0;

	mov	eax, DWORD PTR _rcs$[ebp]
	mov	DWORD PTR [eax+11], 0
$LN96@RunUpdateC:

; 4352 : 				}
; 4353 : 
; 4354 : 				if (condition1 && !condition2 && rcs->actionToTake==RequestedConnectionStruct::CONNECT)

	movzx	eax, BYTE PTR _condition1$[ebp]
	test	eax, eax
	je	SHORT $LN95@RunUpdateC
	movzx	eax, BYTE PTR _condition2$[ebp]
	test	eax, eax
	jne	SHORT $LN95@RunUpdateC
	mov	eax, DWORD PTR _rcs$[ebp]
	cmp	DWORD PTR [eax+274], 1
	jne	SHORT $LN95@RunUpdateC

; 4355 : 				{
; 4356 : 					// Tell user of connection attempt failed
; 4357 : 					packet=AllocPacket(sizeof( char ));

	push	1
	call	?AllocPacket@@YAPAUPacket@@I@Z		; AllocPacket
	add	esp, 4
	mov	DWORD PTR _packet$[ebp], eax

; 4358 : 					packet->data[ 0 ] = ID_CONNECTION_ATTEMPT_FAILED; // Attempted a connection and couldn't

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _packet$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	BYTE PTR [ecx+eax], 24			; 00000018H

; 4359 : 					packet->bitSize = ( sizeof( char ) * 8);

	mov	eax, DWORD PTR _packet$[ebp]
	mov	DWORD PTR [eax+12], 8

; 4360 : 					packet->playerId = rcs->playerId;

	mov	eax, DWORD PTR _rcs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _packet$[ebp]
	add	ecx, 2
	call	??4PlayerID@@QAEAAU0@ABU0@@Z		; PlayerID::operator=

; 4361 : 					packet->playerIndex = 65535;

	mov	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _packet$[ebp]
	mov	WORD PTR [ecx], ax

; 4362 : 					AddPacketToProducer(packet);

	mov	eax, DWORD PTR _packet$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddPacketToProducer@RakPeer@@IAEXPAUPacket@@@Z ; RakPeer::AddPacketToProducer
$LN95@RunUpdateC:

; 4363 : 				}
; 4364 : 
; 4365 : 				// Remove this if possible
; 4366 : 				if (rcs==rcsFirst)

	mov	eax, DWORD PTR _rcs$[ebp]
	cmp	eax, DWORD PTR _rcsFirst$[ebp]
	jne	SHORT $LN94@RunUpdateC

; 4367 : 				{
; 4368 : 					requestedConnectionList.ReadUnlock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 953				; 000003b9H
	call	?ReadUnlock@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEXXZ ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::ReadUnlock

; 4369 : 					rcsFirst = requestedConnectionList.ReadLock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 953				; 000003b9H
	call	?ReadLock@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEPAURequestedConnectionStruct@RakPeer@@XZ ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::ReadLock
	mov	DWORD PTR _rcsFirst$[ebp], eax

; 4370 : 					rcs=rcsFirst;

	mov	eax, DWORD PTR _rcsFirst$[ebp]
	mov	DWORD PTR _rcs$[ebp], eax

; 4371 : 				}
; 4372 : 				else

	jmp	SHORT $LN93@RunUpdateC
$LN94@RunUpdateC:

; 4373 : 				{
; 4374 : 					// Hole in the middle
; 4375 : 					rcs->playerId=UNASSIGNED_PLAYER_ID;

	push	OFFSET _UNASSIGNED_PLAYER_ID
	mov	ecx, DWORD PTR _rcs$[ebp]
	call	??4PlayerID@@QAEAAU0@ABU0@@Z		; PlayerID::operator=

; 4376 : 					rcs=requestedConnectionList.ReadLock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 953				; 000003b9H
	call	?ReadLock@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEPAURequestedConnectionStruct@RakPeer@@XZ ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::ReadLock
	mov	DWORD PTR _rcs$[ebp], eax
$LN93@RunUpdateC:

; 4377 : 				}
; 4378 : 
; 4379 : 				continue;

	jmp	$LN102@RunUpdateC
$LN98@RunUpdateC:

; 4380 : 			}
; 4381 : 
; 4382 : 			rcs->requestsMade++;

	mov	eax, DWORD PTR _rcs$[ebp]
	mov	cl, BYTE PTR [eax+10]
	add	cl, 1
	mov	edx, DWORD PTR _rcs$[ebp]
	mov	BYTE PTR [edx+10], cl

; 4383 : 			rcs->nextRequestTime=timeMS+1000;

	mov	eax, DWORD PTR _timeMS$[ebp]
	add	eax, 1000				; 000003e8H
	mov	ecx, DWORD PTR _rcs$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 4384 : 			char c[2];
; 4385 : 			c[0] = ID_OPEN_CONNECTION_REQUEST;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	BYTE PTR _c$50[ebp+ecx], 16		; 00000010H

; 4386 : 			c[1] = 0; // Pad - apparently some routers block 1 byte packets

	mov	DWORD PTR $T4[ebp], 1
	cmp	DWORD PTR $T4[ebp], 2
	jae	SHORT $LN126@RunUpdateC
	jmp	SHORT $LN127@RunUpdateC
$LN126@RunUpdateC:
	call	___report_rangecheckfailure
$LN127@RunUpdateC:
	mov	eax, DWORD PTR $T4[ebp]
	mov	BYTE PTR _c$50[ebp+eax], 0

; 4387 : 
; 4388 : 			unsigned i;
; 4389 : 			for (i=0; i < messageHandlerList.Size(); i++)

	mov	DWORD PTR _i$49[ebp], 0
	jmp	SHORT $LN92@RunUpdateC
$LN91@RunUpdateC:
	mov	eax, DWORD PTR _i$49[ebp]
	add	eax, 1
	mov	DWORD PTR _i$49[ebp], eax
$LN92@RunUpdateC:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 941				; 000003adH
	call	?Size@?$List@PAVPluginInterface@@@DataStructures@@QBEIXZ ; DataStructures::List<PluginInterface *>::Size
	cmp	DWORD PTR _i$49[ebp], eax
	jae	SHORT $LN90@RunUpdateC

; 4390 : 				messageHandlerList[i]->OnDirectSocketSend((char*)&c, 16, rcs->playerId);

	mov	eax, DWORD PTR _i$49[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 941				; 000003adH
	call	??A?$List@PAVPluginInterface@@@DataStructures@@QBEAAPAVPluginInterface@@I@Z ; DataStructures::List<PluginInterface *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv272[ebp], ecx
	mov	edx, DWORD PTR _rcs$[ebp]
	mov	esi, esp
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR [edx+4]
	mov	WORD PTR [eax+4], dx
	push	16					; 00000010H
	lea	eax, DWORD PTR _c$50[ebp]
	push	eax
	mov	ecx, DWORD PTR tv272[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv272[ebp]
	mov	eax, DWORD PTR [edx+28]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN91@RunUpdateC
$LN90@RunUpdateC:

; 4391 : 			SocketLayer::Instance()->SendTo( connectionSocket, (char*)&c, 2, rcs->playerId.binaryAddress, rcs->playerId.port );

	mov	eax, DWORD PTR _rcs$[ebp]
	movzx	ecx, WORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _rcs$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	2
	lea	ecx, DWORD PTR _c$50[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2070]
	push	eax
	call	?Instance@SocketLayer@@SAPAV1@XZ	; SocketLayer::Instance
	mov	ecx, eax
	call	?SendTo@SocketLayer@@QAEHIPBDHIG@Z	; SocketLayer::SendTo
$LN99@RunUpdateC:

; 4392 : 		}
; 4393 : 
; 4394 : 		rcs=requestedConnectionList.ReadLock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 953				; 000003b9H
	call	?ReadLock@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEPAURequestedConnectionStruct@RakPeer@@XZ ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::ReadLock
	mov	DWORD PTR _rcs$[ebp], eax

; 4395 : 	}

	jmp	$LN102@RunUpdateC
$LN101@RunUpdateC:

; 4396 : 
; 4397 : 	if (rcsFirst)

	cmp	DWORD PTR _rcsFirst$[ebp], 0
	je	SHORT $LN89@RunUpdateC

; 4398 : 		requestedConnectionList.CancelReadLock(rcsFirst);

	mov	eax, DWORD PTR _rcsFirst$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 953				; 000003b9H
	call	?CancelReadLock@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEXPAURequestedConnectionStruct@RakPeer@@@Z ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::CancelReadLock
$LN89@RunUpdateC:

; 4399 : 
; 4400 : 	 
; 4401 : 	// remoteSystemList in network thread
; 4402 : 	for ( remoteSystemIndex = 0; remoteSystemIndex < maximumNumberOfPeers; ++remoteSystemIndex )

	mov	DWORD PTR _remoteSystemIndex$[ebp], 0
	jmp	SHORT $LN88@RunUpdateC
$LN87@RunUpdateC:
	mov	eax, DWORD PTR _remoteSystemIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _remoteSystemIndex$[ebp], eax
$LN88@RunUpdateC:
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+7]
	cmp	DWORD PTR _remoteSystemIndex$[ebp], ecx
	jae	$LN86@RunUpdateC

; 4403 : 	//for ( remoteSystemIndex = 0; remoteSystemIndex < remoteSystemListSize; ++remoteSystemIndex )
; 4404 : 	{
; 4405 : 		// I'm using playerId from remoteSystemList but am not locking it because this loop is called very frequently and it doesn't
; 4406 : 		// matter if we miss or do an extra update.  The reliability layers themselves never care which player they are associated with
; 4407 : 		//playerId = remoteSystemList[ remoteSystemIndex ].playerId;
; 4408 : 		// Allow the playerID for this remote system list to change.  We don't care if it changes now.
; 4409 : 	//	remoteSystemList[ remoteSystemIndex ].allowPlayerIdAssigment=true;
; 4410 : 		if ( remoteSystemList[ remoteSystemIndex ].isActive )

	imul	eax, DWORD PTR _remoteSystemIndex$[ebp], 2058
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	movzx	eax, BYTE PTR [edx+eax]
	test	eax, eax
	je	$LN85@RunUpdateC

; 4411 : 		{
; 4412 : 			playerId = remoteSystemList[ remoteSystemIndex ].playerId;

	imul	eax, DWORD PTR _remoteSystemIndex$[ebp], 2058
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	lea	eax, DWORD PTR [edx+eax+1]
	push	eax
	lea	ecx, DWORD PTR _playerId$[ebp]
	call	??4PlayerID@@QAEAAU0@ABU0@@Z		; PlayerID::operator=

; 4413 : 			RakAssert(playerId!=UNASSIGNED_PLAYER_ID);

	push	OFFSET _UNASSIGNED_PLAYER_ID
	lea	ecx, DWORD PTR _playerId$[ebp]
	call	??9PlayerID@@QBE_NABU0@@Z		; PlayerID::operator!=
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN128@RunUpdateC
	mov	ecx, DWORD PTR ?__LINE__Var@?1??RunUpdateCycle@RakPeer@@IAE_NXZ@4JA
	add	ecx, 192				; 000000c0H
	push	ecx
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_1DO@FONFJDEJ@?$AAp?$AAl?$AAa?$AAy?$AAe?$AAr?$AAI?$AAd?$AA?$CB?$AA?$DN?$AAU?$AAN?$AAA?$AAS?$AAS?$AAI?$AAG?$AAN?$AAE?$AAD?$AA_?$AAP?$AAL?$AAA?$AAY?$AAE?$AAR?$AA_?$AAI?$AAD?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN128@RunUpdateC:

; 4414 : 
; 4415 : 			// Found an active remote system
; 4416 : 			remoteSystem = remoteSystemList + remoteSystemIndex;

	imul	eax, DWORD PTR _remoteSystemIndex$[ebp], 2058
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+820]
	mov	DWORD PTR _remoteSystem$[ebp], eax

; 4417 : 			// Update is only safe to call from the same thread that calls HandleSocketReceiveFromConnectedPlayer,
; 4418 : 			// which is this thread
; 4419 : 
; 4420 : 			if (timeNS==0)

	mov	eax, DWORD PTR _timeNS$[ebp]
	or	eax, DWORD PTR _timeNS$[ebp+4]
	jne	SHORT $LN84@RunUpdateC

; 4421 : 			{
; 4422 : 				timeNS = RakNet::GetTimeNS();

	call	?GetTimeNS@RakNet@@YA_JXZ		; RakNet::GetTimeNS
	mov	DWORD PTR _timeNS$[ebp], eax
	mov	DWORD PTR _timeNS$[ebp+4], edx

; 4423 : 				timeMS = (RakNetTime)(timeNS/(RakNetTimeNS)1000);

	push	0
	push	1000					; 000003e8H
	mov	eax, DWORD PTR _timeNS$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _timeNS$[ebp]
	push	ecx
	call	__alldiv
	mov	DWORD PTR _timeMS$[ebp], eax
$LN84@RunUpdateC:

; 4424 : 				//printf("timeNS = %I64i timeMS=%i\n", timeNS, timeMS);
; 4425 : 			}
; 4426 : 
; 4427 : 
; 4428 : 			if (timeMS > remoteSystem->lastReliableSend && timeMS-remoteSystem->lastReliableSend > 5000 && remoteSystem->connectMode==RemoteSystemStruct::CONNECTED)

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	mov	ecx, DWORD PTR _timeMS$[ebp]
	cmp	ecx, DWORD PTR [eax+1744]
	jbe	$LN83@RunUpdateC
	mov	eax, DWORD PTR _remoteSystem$[ebp]
	mov	ecx, DWORD PTR _timeMS$[ebp]
	sub	ecx, DWORD PTR [eax+1744]
	cmp	ecx, 5000				; 00001388H
	jbe	$LN83@RunUpdateC
	mov	eax, DWORD PTR _remoteSystem$[ebp]
	cmp	DWORD PTR [eax+2054], 8
	jne	SHORT $LN83@RunUpdateC

; 4429 : 			{
; 4430 : 				// If no reliable packets are waiting for an ack, do a one byte reliable send so that disconnections are noticed
; 4431 : 				rnss=remoteSystem->reliabilityLayer.GetStatistics();

	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	add	ecx, 13					; 0000000dH
	call	?GetStatistics@ReliabilityLayer@@QAEQAURakNetStatisticsStruct@@XZ ; ReliabilityLayer::GetStatistics
	mov	DWORD PTR _rnss$[ebp], eax

; 4432 : 				if (rnss->messagesOnResendQueue==0)

	mov	eax, DWORD PTR _rnss$[ebp]
	cmp	DWORD PTR [eax+96], 0
	jne	SHORT $LN83@RunUpdateC

; 4433 : 				{
; 4434 : 					unsigned char keepAlive=ID_DETECT_LOST_CONNECTIONS;

	mov	BYTE PTR _keepAlive$48[ebp], 15		; 0000000fH

; 4435 : 					SendImmediate((char*)&keepAlive,8,LOW_PRIORITY, RELIABLE, 0, remoteSystem->playerId, false, false, timeNS);

	mov	eax, DWORD PTR _timeNS$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _timeNS$[ebp]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _remoteSystem$[ebp]
	add	edx, 1
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR [edx+4]
	mov	WORD PTR [eax+4], dx
	push	0
	push	2
	push	3
	push	8
	lea	eax, DWORD PTR _keepAlive$48[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendImmediate@RakPeer@@IAE_NPADHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N4_J@Z ; RakPeer::SendImmediate

; 4436 : 					remoteSystem->lastReliableSend=timeMS+remoteSystem->reliabilityLayer.GetTimeoutTime();

	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	add	ecx, 13					; 0000000dH
	call	?GetTimeoutTime@ReliabilityLayer@@QAEIXZ ; ReliabilityLayer::GetTimeoutTime
	add	eax, DWORD PTR _timeMS$[ebp]
	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	mov	DWORD PTR [ecx+1744], eax
$LN83@RunUpdateC:

; 4437 : 				}
; 4438 : 			}
; 4439 : 
; 4440 : 			remoteSystem->reliabilityLayer.Update( connectionSocket, playerId, MTUSize, timeNS, messageHandlerList ); // playerId only used for the internet simulator test

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 941				; 000003adH
	push	eax
	mov	ecx, DWORD PTR _timeNS$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _timeNS$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2061]
	push	ecx
	sub	esp, 8
	mov	edx, esp
	mov	eax, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [edx], eax
	mov	cx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [edx+4], cx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2070]
	push	eax
	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	add	ecx, 13					; 0000000dH
	call	?Update@ReliabilityLayer@@QAEXIUPlayerID@@H_JAAV?$List@PAVPluginInterface@@@DataStructures@@@Z ; ReliabilityLayer::Update

; 4441 : 
; 4442 : 			// Check for failure conditions
; 4443 : 			if ( remoteSystem->reliabilityLayer.IsDeadConnection() ||
; 4444 : 				((remoteSystem->connectMode==RemoteSystemStruct::DISCONNECT_ASAP || remoteSystem->connectMode==RemoteSystemStruct::DISCONNECT_ASAP_SILENTLY) && remoteSystem->reliabilityLayer.IsDataWaiting()==false) ||
; 4445 : 				(remoteSystem->connectMode==RemoteSystemStruct::DISCONNECT_ON_NO_ACK && remoteSystem->reliabilityLayer.AreAcksWaiting()==false) ||
; 4446 : 				((
; 4447 : 				(remoteSystem->connectMode==RemoteSystemStruct::REQUESTED_CONNECTION ||
; 4448 : 				remoteSystem->connectMode==RemoteSystemStruct::HANDLING_CONNECTION_REQUEST ||
; 4449 : 				remoteSystem->connectMode==RemoteSystemStruct::UNVERIFIED_SENDER ||
; 4450 : 				remoteSystem->connectMode==RemoteSystemStruct::SET_ENCRYPTION_ON_MULTIPLE_16_BYTE_PACKET)
; 4451 : 				&& timeMS > remoteSystem->connectionTime && timeMS - remoteSystem->connectionTime > 10000))
; 4452 : 				)

	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	add	ecx, 13					; 0000000dH
	call	?IsDeadConnection@ReliabilityLayer@@QBE_NXZ ; ReliabilityLayer::IsDeadConnection
	movzx	eax, al
	test	eax, eax
	jne	$LN80@RunUpdateC
	mov	eax, DWORD PTR _remoteSystem$[ebp]
	cmp	DWORD PTR [eax+2054], 1
	je	SHORT $LN78@RunUpdateC
	mov	eax, DWORD PTR _remoteSystem$[ebp]
	cmp	DWORD PTR [eax+2054], 2
	jne	SHORT $LN79@RunUpdateC
$LN78@RunUpdateC:
	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	add	ecx, 13					; 0000000dH
	call	?IsDataWaiting@ReliabilityLayer@@QAE_NXZ ; ReliabilityLayer::IsDataWaiting
	movzx	eax, al
	test	eax, eax
	je	$LN80@RunUpdateC
$LN79@RunUpdateC:
	mov	eax, DWORD PTR _remoteSystem$[ebp]
	cmp	DWORD PTR [eax+2054], 3
	jne	SHORT $LN77@RunUpdateC
	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	add	ecx, 13					; 0000000dH
	call	?AreAcksWaiting@ReliabilityLayer@@QAE_NXZ ; ReliabilityLayer::AreAcksWaiting
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN80@RunUpdateC
$LN77@RunUpdateC:
	mov	eax, DWORD PTR _remoteSystem$[ebp]
	cmp	DWORD PTR [eax+2054], 4
	je	SHORT $LN76@RunUpdateC
	mov	eax, DWORD PTR _remoteSystem$[ebp]
	cmp	DWORD PTR [eax+2054], 5
	je	SHORT $LN76@RunUpdateC
	mov	eax, DWORD PTR _remoteSystem$[ebp]
	cmp	DWORD PTR [eax+2054], 6
	je	SHORT $LN76@RunUpdateC
	mov	eax, DWORD PTR _remoteSystem$[ebp]
	cmp	DWORD PTR [eax+2054], 7
	jne	$LN81@RunUpdateC
$LN76@RunUpdateC:
	mov	eax, DWORD PTR _remoteSystem$[ebp]
	mov	ecx, DWORD PTR _timeMS$[ebp]
	cmp	ecx, DWORD PTR [eax+2021]
	jbe	$LN81@RunUpdateC
	mov	eax, DWORD PTR _remoteSystem$[ebp]
	mov	ecx, DWORD PTR _timeMS$[ebp]
	sub	ecx, DWORD PTR [eax+2021]
	cmp	ecx, 10000				; 00002710H
	jbe	$LN81@RunUpdateC
$LN80@RunUpdateC:

; 4453 : 			{
; 4454 : 			//	printf("timeMS=%i remoteSystem->connectionTime=%i\n", timeMS, remoteSystem->connectionTime );
; 4455 : 
; 4456 : 				// Failed.  Inform the user?
; 4457 : 				if (remoteSystem->connectMode==RemoteSystemStruct::CONNECTED || remoteSystem->connectMode==RemoteSystemStruct::REQUESTED_CONNECTION
; 4458 : 					|| remoteSystem->connectMode==RemoteSystemStruct::DISCONNECT_ASAP || remoteSystem->connectMode==RemoteSystemStruct::DISCONNECT_ON_NO_ACK)

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	cmp	DWORD PTR [eax+2054], 8
	je	SHORT $LN74@RunUpdateC
	mov	eax, DWORD PTR _remoteSystem$[ebp]
	cmp	DWORD PTR [eax+2054], 4
	je	SHORT $LN74@RunUpdateC
	mov	eax, DWORD PTR _remoteSystem$[ebp]
	cmp	DWORD PTR [eax+2054], 1
	je	SHORT $LN74@RunUpdateC
	mov	eax, DWORD PTR _remoteSystem$[ebp]
	cmp	DWORD PTR [eax+2054], 3
	jne	$LN75@RunUpdateC
$LN74@RunUpdateC:

; 4459 : 				{
; 4460 : 					// Inform the user of the connection failure.
; 4461 : 				//	unsigned staticDataBytes;
; 4462 : 
; 4463 : 				//	staticDataBytes=remoteSystem->staticData.GetNumberOfBytesUsed();
; 4464 : 				//	packet=AllocPacket(sizeof( char ) + staticDataBytes);
; 4465 : 					packet=AllocPacket(sizeof( char ) );

	push	1
	call	?AllocPacket@@YAPAUPacket@@I@Z		; AllocPacket
	add	esp, 4
	mov	DWORD PTR _packet$[ebp], eax

; 4466 : 					if (remoteSystem->connectMode==RemoteSystemStruct::REQUESTED_CONNECTION)

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	cmp	DWORD PTR [eax+2054], 4
	jne	SHORT $LN73@RunUpdateC

; 4467 : 						packet->data[ 0 ] = ID_CONNECTION_ATTEMPT_FAILED; // Attempted a connection and couldn't

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _packet$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	BYTE PTR [ecx+eax], 24			; 00000018H
	jmp	SHORT $LN72@RunUpdateC
$LN73@RunUpdateC:

; 4468 : 					else if (remoteSystem->connectMode==RemoteSystemStruct::CONNECTED)

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	cmp	DWORD PTR [eax+2054], 8
	jne	SHORT $LN71@RunUpdateC

; 4469 : 						packet->data[ 0 ] = ID_CONNECTION_LOST; // DeadConnection

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _packet$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	BYTE PTR [ecx+eax], 30			; 0000001eH

; 4470 : 					else

	jmp	SHORT $LN72@RunUpdateC
$LN71@RunUpdateC:

; 4471 : 						packet->data[ 0 ] = ID_DISCONNECTION_NOTIFICATION; // DeadConnection

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _packet$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	BYTE PTR [ecx+eax], 28			; 0000001cH
$LN72@RunUpdateC:

; 4472 : 
; 4473 : 					//if (staticDataBytes)
; 4474 : 					//	memcpy( packet->data + sizeof( char ), remoteSystem->staticData.GetData(), staticDataBytes );
; 4475 : 					packet->bitSize = ( sizeof( char ) ) * 8;

	mov	eax, DWORD PTR _packet$[ebp]
	mov	DWORD PTR [eax+12], 8

; 4476 : 					//packet->bitSize = ( sizeof( char ) + staticDataBytes ) * 8;
; 4477 : 					packet->playerId = playerId;

	lea	eax, DWORD PTR _playerId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _packet$[ebp]
	add	ecx, 2
	call	??4PlayerID@@QAEAAU0@ABU0@@Z		; PlayerID::operator=

; 4478 : 					packet->playerIndex = ( PlayerIndex ) remoteSystemIndex;

	mov	eax, DWORD PTR _packet$[ebp]
	mov	cx, WORD PTR _remoteSystemIndex$[ebp]
	mov	WORD PTR [eax], cx

; 4479 : 
; 4480 : 					AddPacketToProducer(packet);

	mov	eax, DWORD PTR _packet$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddPacketToProducer@RakPeer@@IAEXPAUPacket@@@Z ; RakPeer::AddPacketToProducer
$LN75@RunUpdateC:

; 4481 : 				}
; 4482 : 				// else connection shutting down, don't bother telling the user
; 4483 : 
; 4484 : #ifdef _DO_PRINTF
; 4485 : 				printf("Connection dropped for player %i:%i\n", playerId.binaryAddress, playerId.port);
; 4486 : #endif
; 4487 : 				CloseConnectionInternal( playerId, false, true, 0 );

	push	0
	push	1
	push	0
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CloseConnectionInternal@RakPeer@@IAEXUPlayerID@@_N1E@Z ; RakPeer::CloseConnectionInternal

; 4488 : 				continue;

	jmp	$LN87@RunUpdateC
$LN81@RunUpdateC:

; 4489 : 			}
; 4490 : 
; 4491 : 			// Did the reliability layer detect a modified packet?
; 4492 : 			if ( remoteSystem->reliabilityLayer.IsCheater() )

	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	add	ecx, 13					; 0000000dH
	call	?IsCheater@ReliabilityLayer@@QBE_NXZ	; ReliabilityLayer::IsCheater
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN69@RunUpdateC

; 4493 : 			{
; 4494 : 				packet=AllocPacket(sizeof(char));

	push	1
	call	?AllocPacket@@YAPAUPacket@@I@Z		; AllocPacket
	add	esp, 4
	mov	DWORD PTR _packet$[ebp], eax

; 4495 : 				packet->bitSize=8;

	mov	eax, DWORD PTR _packet$[ebp]
	mov	DWORD PTR [eax+12], 8

; 4496 : 				packet->data[ 0 ] = (unsigned char) ID_MODIFIED_PACKET;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _packet$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	BYTE PTR [ecx+eax], 35			; 00000023H

; 4497 : 				packet->playerId = playerId;

	lea	eax, DWORD PTR _playerId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _packet$[ebp]
	add	ecx, 2
	call	??4PlayerID@@QAEAAU0@ABU0@@Z		; PlayerID::operator=

; 4498 : 				packet->playerIndex = ( PlayerIndex ) remoteSystemIndex;

	mov	eax, DWORD PTR _packet$[ebp]
	mov	cx, WORD PTR _remoteSystemIndex$[ebp]
	mov	WORD PTR [eax], cx

; 4499 : 				AddPacketToProducer(packet);

	mov	eax, DWORD PTR _packet$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddPacketToProducer@RakPeer@@IAEXPAUPacket@@@Z ; RakPeer::AddPacketToProducer

; 4500 : 				continue;

	jmp	$LN87@RunUpdateC
$LN69@RunUpdateC:

; 4501 : 			}
; 4502 : 
; 4503 : 			// Ping this guy if it is time to do so
; 4504 : 			if ( remoteSystem->connectMode==RemoteSystemStruct::CONNECTED && timeMS > remoteSystem->nextPingTime && ( occasionalPing || remoteSystem->lowestPing == (unsigned short)-1 ) )

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	cmp	DWORD PTR [eax+2054], 8
	jne	SHORT $LN68@RunUpdateC
	mov	eax, DWORD PTR _remoteSystem$[ebp]
	mov	ecx, DWORD PTR _timeMS$[ebp]
	cmp	ecx, DWORD PTR [eax+1740]
	jbe	SHORT $LN68@RunUpdateC
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+6]
	test	ecx, ecx
	jne	SHORT $LN67@RunUpdateC
	mov	eax, DWORD PTR _remoteSystem$[ebp]
	movzx	ecx, WORD PTR [eax+1738]
	cmp	ecx, 65535				; 0000ffffH
	jne	SHORT $LN68@RunUpdateC
$LN67@RunUpdateC:

; 4505 : 			{
; 4506 : 				remoteSystem->nextPingTime = timeMS + 5000;

	mov	eax, DWORD PTR _timeMS$[ebp]
	add	eax, 5000				; 00001388H
	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	mov	DWORD PTR [ecx+1740], eax

; 4507 : 				PingInternal( playerId, true );

	push	1
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PingInternal@RakPeer@@IAEXUPlayerID@@_N@Z ; RakPeer::PingInternal
$LN68@RunUpdateC:

; 4508 : 			}
; 4509 : 
; 4510 : 			// Find whoever has the lowest player ID
; 4511 : 			//if (playerId < authoritativeClientPlayerId)
; 4512 : 			// authoritativeClientPlayerId=playerId;
; 4513 : 
; 4514 : 			// Does the reliability layer have any packets waiting for us?
; 4515 : 			// To be thread safe, this has to be called in the same thread as HandleSocketReceiveFromConnectedPlayer
; 4516 : 			bitSize = remoteSystem->reliabilityLayer.Receive( &data );

	lea	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	add	ecx, 13					; 0000000dH
	call	?Receive@ReliabilityLayer@@QAEHPAPAE@Z	; ReliabilityLayer::Receive
	mov	DWORD PTR _bitSize$[ebp], eax
$LN66@RunUpdateC:

; 4517 : 
; 4518 : 			while ( bitSize > 0 )

	cmp	DWORD PTR _bitSize$[ebp], 0
	jle	$LN85@RunUpdateC

; 4519 : 			{
; 4520 : 				// These types are for internal use and should never arrive from a network packet
; 4521 : 				if (data[0]==ID_CONNECTION_ATTEMPT_FAILED && data[0]==ID_MODIFIED_PACKET)

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 24					; 00000018H
	jne	SHORT $LN64@RunUpdateC
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 35					; 00000023H
	jne	SHORT $LN64@RunUpdateC

; 4522 : 				{
; 4523 : 					RakAssert(0);

	xor	eax, eax
	jne	SHORT $LN129@RunUpdateC
	mov	ecx, DWORD PTR ?__LINE__Var@?1??RunUpdateCycle@RakPeer@@IAE_NXZ@4JA
	add	ecx, 302				; 0000012eH
	push	ecx
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_13COJANIEC@?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN129@RunUpdateC:

; 4524 : 					continue;

	jmp	SHORT $LN66@RunUpdateC
$LN64@RunUpdateC:

; 4525 : 				}
; 4526 : 
; 4527 : 				// Put the input through compression if necessary
; 4528 : 				if ( inputTree )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2001], 0
	je	$LN63@RunUpdateC

; 4529 : 				{
; 4530 : 					RakNet::BitStream dataBitStream( MAXIMUM_MTU_SIZE );

	push	576					; 00000240H
	lea	ecx, DWORD PTR _dataBitStream$47[ebp]
	call	??0BitStream@RakNet@@QAE@H@Z		; RakNet::BitStream::BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4531 : 					// Since we are decompressing input, we need to copy to a bitstream, decompress, then copy back to a probably
; 4532 : 					// larger data block.  It's slow, but the user should have known that anyway
; 4533 : 					dataBitStream.Reset();

	lea	ecx, DWORD PTR _dataBitStream$47[ebp]
	call	?Reset@BitStream@RakNet@@QAEXXZ		; RakNet::BitStream::Reset

; 4534 : 					dataBitStream.WriteAlignedBytes( ( unsigned char* ) data, BITS_TO_BYTES( bitSize ) );

	mov	eax, DWORD PTR _bitSize$[ebp]
	add	eax, 7
	sar	eax, 3
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _dataBitStream$47[ebp]
	call	?WriteAlignedBytes@BitStream@RakNet@@QAEXPBEH@Z ; RakNet::BitStream::WriteAlignedBytes

; 4535 : 					rawBytesReceived += dataBitStream.GetNumberOfBytesUsed();

	lea	ecx, DWORD PTR _dataBitStream$47[ebp]
	call	?GetNumberOfBytesUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBytesUsed
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+2013]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2013], eax

; 4536 : 
; 4537 : //					numberOfBytesUsed = dataBitStream.GetNumberOfBytesUsed();
; 4538 : 					numberOfBitsUsed = dataBitStream.GetNumberOfBitsUsed();

	lea	ecx, DWORD PTR _dataBitStream$47[ebp]
	call	?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBitsUsed
	mov	DWORD PTR _numberOfBitsUsed$[ebp], eax

; 4539 : 					//rawBytesReceived += numberOfBytesUsed;
; 4540 : 					// Decompress the input data.
; 4541 : 
; 4542 : 					if (numberOfBitsUsed>0)

	cmp	DWORD PTR _numberOfBitsUsed$[ebp], 0
	jbe	$LN62@RunUpdateC

; 4543 : 					{
; 4544 : 						unsigned char *dataCopy = new unsigned char[ dataBitStream.GetNumberOfBytesUsed() ];

	lea	ecx, DWORD PTR _dataBitStream$47[ebp]
	call	?GetNumberOfBytesUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBytesUsed
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR _dataCopy$46[ebp], eax

; 4545 : 						memcpy( dataCopy, dataBitStream.GetData(), dataBitStream.GetNumberOfBytesUsed() );

	lea	ecx, DWORD PTR _dataBitStream$47[ebp]
	call	?GetNumberOfBytesUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBytesUsed
	push	eax
	lea	ecx, DWORD PTR _dataBitStream$47[ebp]
	call	?GetData@BitStream@RakNet@@QBEPAEXZ	; RakNet::BitStream::GetData
	push	eax
	mov	eax, DWORD PTR _dataCopy$46[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 4546 : 						dataBitStream.Reset();

	lea	ecx, DWORD PTR _dataBitStream$47[ebp]
	call	?Reset@BitStream@RakNet@@QAEXXZ		; RakNet::BitStream::Reset

; 4547 : 						inputTree->DecodeArray( dataCopy, numberOfBitsUsed, &dataBitStream );

	lea	eax, DWORD PTR _dataBitStream$47[ebp]
	push	eax
	mov	ecx, DWORD PTR _numberOfBitsUsed$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dataCopy$46[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2001]
	call	?DecodeArray@HuffmanEncodingTree@@QAEXPAEIPAVBitStream@RakNet@@@Z ; HuffmanEncodingTree::DecodeArray

; 4548 : 						compressedBytesReceived += dataBitStream.GetNumberOfBytesUsed();

	lea	ecx, DWORD PTR _dataBitStream$47[ebp]
	call	?GetNumberOfBytesUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBytesUsed
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+2021]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2021], eax

; 4549 : 						delete [] dataCopy;

	mov	eax, DWORD PTR _dataCopy$46[ebp]
	mov	DWORD PTR $T6[ebp], eax
	mov	ecx, DWORD PTR $T6[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 4550 : 
; 4551 : 						byteSize = dataBitStream.GetNumberOfBytesUsed();

	lea	ecx, DWORD PTR _dataBitStream$47[ebp]
	call	?GetNumberOfBytesUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBytesUsed
	mov	DWORD PTR _byteSize$[ebp], eax

; 4552 : 
; 4553 : 						if ( byteSize > BITS_TO_BYTES( bitSize ) )   // Probably the case - otherwise why decompress?

	mov	eax, DWORD PTR _bitSize$[ebp]
	add	eax, 7
	sar	eax, 3
	cmp	DWORD PTR _byteSize$[ebp], eax
	jle	SHORT $LN61@RunUpdateC

; 4554 : 						{
; 4555 : 							delete [] data;

	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR $T7[ebp], eax
	mov	ecx, DWORD PTR $T7[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 4556 : 							data = new unsigned char [ byteSize ];

	mov	eax, DWORD PTR _byteSize$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T8[ebp], eax
	mov	ecx, DWORD PTR $T8[ebp]
	mov	DWORD PTR _data$[ebp], ecx
$LN61@RunUpdateC:

; 4557 : 						}
; 4558 : 						memcpy( data, dataBitStream.GetData(), byteSize );

	mov	eax, DWORD PTR _byteSize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dataBitStream$47[ebp]
	call	?GetData@BitStream@RakNet@@QBEPAEXZ	; RakNet::BitStream::GetData
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 4559 : 					}
; 4560 : 					else

	jmp	SHORT $LN60@RunUpdateC
$LN62@RunUpdateC:

; 4561 : 						byteSize=0;

	mov	DWORD PTR _byteSize$[ebp], 0
$LN60@RunUpdateC:

; 4562 : 				}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _dataBitStream$47[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream

; 4563 : 				else

	jmp	SHORT $LN59@RunUpdateC
$LN63@RunUpdateC:

; 4564 : 					// Fast and easy - just use the data that was returned
; 4565 : 					byteSize = BITS_TO_BYTES( bitSize );

	mov	eax, DWORD PTR _bitSize$[ebp]
	add	eax, 7
	sar	eax, 3
	mov	DWORD PTR _byteSize$[ebp], eax
$LN59@RunUpdateC:

; 4566 : 
; 4567 : 				// For unknown senders we only accept a few specific packets
; 4568 : 				if (remoteSystem->connectMode==RemoteSystemStruct::UNVERIFIED_SENDER)

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	cmp	DWORD PTR [eax+2054], 6
	jne	$LN58@RunUpdateC

; 4569 : 				{
; 4570 : 					if ( (unsigned char)(data)[0] == ID_CONNECTION_REQUEST )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 8
	jne	SHORT $LN57@RunUpdateC

; 4571 : 					{
; 4572 : 						ParseConnectionRequestPacket(remoteSystem, playerId, (const char*)data, byteSize);

	mov	eax, DWORD PTR _byteSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	sub	esp, 8
	mov	edx, esp
	mov	eax, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [edx], eax
	mov	cx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [edx+4], cx
	mov	edx, DWORD PTR _remoteSystem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ParseConnectionRequestPacket@RakPeer@@IAEXPAURemoteSystemStruct@1@UPlayerID@@PBDH@Z ; RakPeer::ParseConnectionRequestPacket

; 4573 : 						delete [] data;

	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR $T9[ebp], eax
	mov	ecx, DWORD PTR $T9[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 4574 : 					}
; 4575 : 					else

	jmp	$LN56@RunUpdateC
$LN57@RunUpdateC:

; 4576 : 					{
; 4577 : 						CloseConnectionInternal( playerId, false, true, 0 );

	push	0
	push	1
	push	0
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CloseConnectionInternal@RakPeer@@IAEXUPlayerID@@_N1E@Z ; RakPeer::CloseConnectionInternal

; 4578 : #ifdef _DO_PRINTF
; 4579 : 						printf("Temporarily banning %i:%i for sending nonsense data\n", playerId.binaryAddress, playerId.port);
; 4580 : #endif
; 4581 : 
; 4582 : #if !defined(_COMPATIBILITY_1)
; 4583 : 						AddToBanList(PlayerIDToDottedIP(playerId), remoteSystem->reliabilityLayer.GetTimeoutTime());

	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	add	ecx, 13					; 0000000dH
	call	?GetTimeoutTime@ReliabilityLayer@@QAEIXZ ; ReliabilityLayer::GetTimeoutTime
	mov	esi, esp
	push	eax
	mov	edi, esp
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+184]
	call	eax
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4584 : #endif
; 4585 : 						delete [] data;

	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR $T10[ebp], eax
	mov	ecx, DWORD PTR $T10[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN56@RunUpdateC:

; 4586 : 					}
; 4587 : 				}
; 4588 : 				else

	jmp	$LN55@RunUpdateC
$LN58@RunUpdateC:

; 4589 : 				{
; 4590 : 					// However, if we are connected we still take a connection request in case both systems are trying to connect to each other
; 4591 : 					// at the same time
; 4592 : 					if ( (unsigned char)(data)[0] == ID_CONNECTION_REQUEST )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 8
	jne	SHORT $LN54@RunUpdateC

; 4593 : 					{
; 4594 : 						// 04/27/06 This is wrong.  With cross connections, we can both have initiated the connection are in state REQUESTED_CONNECTION
; 4595 : 						// 04/28/06 Downgrading connections from connected will close the connection due to security at ((remoteSystem->connectMode!=RemoteSystemStruct::CONNECTED && time > remoteSystem->connectionTime && time - remoteSystem->connectionTime > 10000))
; 4596 : 						if (remoteSystem->connectMode!=RemoteSystemStruct::CONNECTED)

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	cmp	DWORD PTR [eax+2054], 8
	je	SHORT $LN53@RunUpdateC

; 4597 : 							ParseConnectionRequestPacket(remoteSystem, playerId, (const char*)data, byteSize);

	mov	eax, DWORD PTR _byteSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	sub	esp, 8
	mov	edx, esp
	mov	eax, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [edx], eax
	mov	cx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [edx+4], cx
	mov	edx, DWORD PTR _remoteSystem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ParseConnectionRequestPacket@RakPeer@@IAEXPAURemoteSystemStruct@1@UPlayerID@@PBDH@Z ; RakPeer::ParseConnectionRequestPacket
$LN53@RunUpdateC:

; 4598 : 						delete [] data;

	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR $T11[ebp], eax
	mov	ecx, DWORD PTR $T11[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	jmp	$LN55@RunUpdateC
$LN54@RunUpdateC:

; 4599 : 					}
; 4600 : 					else if ( (unsigned char) data[ 0 ] == ID_NEW_INCOMING_CONNECTION && byteSize == sizeof(unsigned char)+sizeof(unsigned int)+sizeof(unsigned short) )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 26					; 0000001aH
	jne	$LN51@RunUpdateC
	cmp	DWORD PTR _byteSize$[ebp], 7
	jne	$LN51@RunUpdateC

; 4601 : 					{
; 4602 : #ifdef _DEBUG
; 4603 : 						// This assert can be ignored since it could hit from duplicate packets.
; 4604 : 						// It's just here for internal testing since it should only happen rarely and will mostly be from bugs
; 4605 : //						assert(remoteSystem->connectMode==RemoteSystemStruct::HANDLING_CONNECTION_REQUEST);
; 4606 : #endif
; 4607 : 						if (remoteSystem->connectMode==RemoteSystemStruct::HANDLING_CONNECTION_REQUEST ||
; 4608 : 							remoteSystem->connectMode==RemoteSystemStruct::SET_ENCRYPTION_ON_MULTIPLE_16_BYTE_PACKET ||
; 4609 : 							playerId==myPlayerId) // local system connect

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	cmp	DWORD PTR [eax+2054], 5
	je	SHORT $LN49@RunUpdateC
	mov	eax, DWORD PTR _remoteSystem$[ebp]
	cmp	DWORD PTR [eax+2054], 7
	je	SHORT $LN49@RunUpdateC
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 557				; 0000022dH
	push	eax
	lea	ecx, DWORD PTR _playerId$[ebp]
	call	??8PlayerID@@QBE_NABU0@@Z		; PlayerID::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	$LN50@RunUpdateC
$LN49@RunUpdateC:

; 4610 : 						{
; 4611 : 							remoteSystem->connectMode=RemoteSystemStruct::CONNECTED;

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	mov	DWORD PTR [eax+2054], 8

; 4612 : 							PingInternal( playerId, true );

	push	1
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PingInternal@RakPeer@@IAEXUPlayerID@@_N@Z ; RakPeer::PingInternal

; 4613 : 							SendStaticDataInternal( playerId, true );

	push	1
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendStaticDataInternal@RakPeer@@IAEXUPlayerID@@_N@Z ; RakPeer::SendStaticDataInternal

; 4614 : 
; 4615 : 							RakNet::BitStream inBitStream((unsigned char *) data, byteSize, false);

	push	0
	mov	eax, DWORD PTR _byteSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _inBitStream$45[ebp]
	call	??0BitStream@RakNet@@QAE@PAEI_N@Z	; RakNet::BitStream::BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 4616 : 							PlayerID bsPlayerId;
; 4617 : 
; 4618 : 							inBitStream.IgnoreBits(8);

	push	8
	lea	ecx, DWORD PTR _inBitStream$45[ebp]
	call	?IgnoreBits@BitStream@RakNet@@QAEXH@Z	; RakNet::BitStream::IgnoreBits

; 4619 : 							inBitStream.Read(bsPlayerId.binaryAddress);

	lea	eax, DWORD PTR _bsPlayerId$44[ebp]
	push	eax
	lea	ecx, DWORD PTR _inBitStream$45[ebp]
	call	??$Read@I@BitStream@RakNet@@QAE_NAAI@Z	; RakNet::BitStream::Read<unsigned int>

; 4620 : 							inBitStream.Read(bsPlayerId.port);

	lea	eax, DWORD PTR _bsPlayerId$44[ebp+4]
	push	eax
	lea	ecx, DWORD PTR _inBitStream$45[ebp]
	call	??$Read@G@BitStream@RakNet@@QAE_NAAG@Z	; RakNet::BitStream::Read<unsigned short>

; 4621 : 
; 4622 : 							// Overwrite the data in the packet
; 4623 : 							//					NewIncomingConnectionStruct newIncomingConnectionStruct;
; 4624 : 							//					RakNet::BitStream nICS_BS( data, NewIncomingConnectionStruct_Size, false );
; 4625 : 							//					newIncomingConnectionStruct.Deserialize( nICS_BS );
; 4626 : 							remoteSystem->myExternalPlayerId = bsPlayerId;

	lea	eax, DWORD PTR _bsPlayerId$44[ebp]
	push	eax
	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	add	ecx, 7
	call	??4PlayerID@@QAEAAU0@ABU0@@Z		; PlayerID::operator=

; 4627 : 
; 4628 : 							// Send this info down to the game
; 4629 : 
; 4630 : 							packet=AllocPacket(byteSize, data);

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _byteSize$[ebp]
	push	ecx
	call	?AllocPacket@@YAPAUPacket@@IPAE@Z	; AllocPacket
	add	esp, 8
	mov	DWORD PTR _packet$[ebp], eax

; 4631 : 							packet->bitSize = bitSize;

	mov	eax, DWORD PTR _packet$[ebp]
	mov	ecx, DWORD PTR _bitSize$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 4632 : 							packet->playerId = playerId;

	lea	eax, DWORD PTR _playerId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _packet$[ebp]
	add	ecx, 2
	call	??4PlayerID@@QAEAAU0@ABU0@@Z		; PlayerID::operator=

; 4633 : 							packet->playerIndex = ( PlayerIndex ) remoteSystemIndex;

	mov	eax, DWORD PTR _packet$[ebp]
	mov	cx, WORD PTR _remoteSystemIndex$[ebp]
	mov	WORD PTR [eax], cx

; 4634 : 							AddPacketToProducer(packet);

	mov	eax, DWORD PTR _packet$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddPacketToProducer@RakPeer@@IAEXPAUPacket@@@Z ; RakPeer::AddPacketToProducer

; 4635 : 						}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _inBitStream$45[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream

; 4636 : 						else

	jmp	SHORT $LN48@RunUpdateC
$LN50@RunUpdateC:

; 4637 : 							delete [] data;

	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR $T12[ebp], eax
	mov	ecx, DWORD PTR $T12[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN48@RunUpdateC:
	jmp	$LN55@RunUpdateC
$LN51@RunUpdateC:

; 4638 : 					}
; 4639 : 					else if ( (unsigned char) data[ 0 ] == ID_CONNECTED_PONG && byteSize == sizeof(unsigned char)+sizeof(RakNetTime)*2 )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 5
	jne	$LN46@RunUpdateC
	cmp	DWORD PTR _byteSize$[ebp], 9
	jne	$LN46@RunUpdateC

; 4640 : 					{
; 4641 : 						RakNetTime sendPingTime, sendPongTime;
; 4642 : 
; 4643 : 						// Copy into the ping times array the current time - the value returned
; 4644 : 						// First extract the sent ping
; 4645 : 						RakNet::BitStream inBitStream( (unsigned char *) data, byteSize, false );

	push	0
	mov	eax, DWORD PTR _byteSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _inBitStream$41[ebp]
	call	??0BitStream@RakNet@@QAE@PAEI_N@Z	; RakNet::BitStream::BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 4646 : 						//PingStruct ps;
; 4647 : 						//ps.Deserialize(psBS);
; 4648 : 						inBitStream.IgnoreBits(8);

	push	8
	lea	ecx, DWORD PTR _inBitStream$41[ebp]
	call	?IgnoreBits@BitStream@RakNet@@QAEXH@Z	; RakNet::BitStream::IgnoreBits

; 4649 : 						inBitStream.Read(sendPingTime);

	lea	eax, DWORD PTR _sendPingTime$43[ebp]
	push	eax
	lea	ecx, DWORD PTR _inBitStream$41[ebp]
	call	??$Read@I@BitStream@RakNet@@QAE_NAAI@Z	; RakNet::BitStream::Read<unsigned int>

; 4650 : 						inBitStream.Read(sendPongTime);

	lea	eax, DWORD PTR _sendPongTime$42[ebp]
	push	eax
	lea	ecx, DWORD PTR _inBitStream$41[ebp]
	call	??$Read@I@BitStream@RakNet@@QAE_NAAI@Z	; RakNet::BitStream::Read<unsigned int>

; 4651 : 
; 4652 : 						timeNS = RakNet::GetTimeNS(); // Update the time value to be accurate

	call	?GetTimeNS@RakNet@@YA_JXZ		; RakNet::GetTimeNS
	mov	DWORD PTR _timeNS$[ebp], eax
	mov	DWORD PTR _timeNS$[ebp+4], edx

; 4653 : 						timeMS = (RakNetTime)(timeNS/(RakNetTimeNS)1000);

	push	0
	push	1000					; 000003e8H
	mov	eax, DWORD PTR _timeNS$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _timeNS$[ebp]
	push	ecx
	call	__alldiv
	mov	DWORD PTR _timeMS$[ebp], eax

; 4654 : 						if (timeMS > sendPingTime)

	mov	eax, DWORD PTR _timeMS$[ebp]
	cmp	eax, DWORD PTR _sendPingTime$43[ebp]
	jbe	SHORT $LN45@RunUpdateC

; 4655 : 							ping = timeMS - sendPingTime;

	mov	eax, DWORD PTR _timeMS$[ebp]
	sub	eax, DWORD PTR _sendPingTime$43[ebp]
	mov	DWORD PTR _ping$[ebp], eax

; 4656 : 						else

	jmp	SHORT $LN44@RunUpdateC
$LN45@RunUpdateC:

; 4657 : 							ping=0;

	mov	DWORD PTR _ping$[ebp], 0
$LN44@RunUpdateC:

; 4658 : 						lastPing = remoteSystem->pingAndClockDifferential[ remoteSystem->pingAndClockDifferentialWriteIndex ].pingTime;

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	imul	ecx, DWORD PTR [eax+1734], 6
	mov	edx, DWORD PTR _remoteSystem$[ebp]
	movzx	eax, WORD PTR [edx+ecx+1704]
	mov	DWORD PTR _lastPing$[ebp], eax

; 4659 : 
; 4660 : 						// Ignore super high spikes in the average
; 4661 : 						if ( lastPing <= 0 || ( ( ping < ( lastPing * 3 ) ) && ping < 1200 ) )

	cmp	DWORD PTR _lastPing$[ebp], 0
	jbe	SHORT $LN42@RunUpdateC
	imul	eax, DWORD PTR _lastPing$[ebp], 3
	cmp	DWORD PTR _ping$[ebp], eax
	jae	$LN43@RunUpdateC
	cmp	DWORD PTR _ping$[ebp], 1200		; 000004b0H
	jae	$LN43@RunUpdateC
$LN42@RunUpdateC:

; 4662 : 						{
; 4663 : 							remoteSystem->pingAndClockDifferential[ remoteSystem->pingAndClockDifferentialWriteIndex ].pingTime = ( unsigned short ) ping;

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	imul	ecx, DWORD PTR [eax+1734], 6
	mov	edx, DWORD PTR _remoteSystem$[ebp]
	mov	ax, WORD PTR _ping$[ebp]
	mov	WORD PTR [edx+ecx+1704], ax

; 4664 : 							// Thanks to Chris Taylor (cat02e@fsu.edu) for the improved timestamping algorithm
; 4665 : 							remoteSystem->pingAndClockDifferential[ remoteSystem->pingAndClockDifferentialWriteIndex ].clockDifferential = sendPongTime - ( timeMS + sendPingTime ) / 2;

	mov	eax, DWORD PTR _timeMS$[ebp]
	add	eax, DWORD PTR _sendPingTime$43[ebp]
	shr	eax, 1
	mov	ecx, DWORD PTR _sendPongTime$42[ebp]
	sub	ecx, eax
	mov	edx, DWORD PTR _remoteSystem$[ebp]
	imul	eax, DWORD PTR [edx+1734], 6
	mov	edx, DWORD PTR _remoteSystem$[ebp]
	mov	DWORD PTR [edx+eax+1706], ecx

; 4666 : 
; 4667 : 							if ( remoteSystem->lowestPing == (unsigned short)-1 || remoteSystem->lowestPing > (int) ping )

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	movzx	ecx, WORD PTR [eax+1738]
	cmp	ecx, 65535				; 0000ffffH
	je	SHORT $LN40@RunUpdateC
	mov	eax, DWORD PTR _remoteSystem$[ebp]
	movzx	ecx, WORD PTR [eax+1738]
	cmp	ecx, DWORD PTR _ping$[ebp]
	jle	SHORT $LN41@RunUpdateC
$LN40@RunUpdateC:

; 4668 : 								remoteSystem->lowestPing = (unsigned short) ping;

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	mov	cx, WORD PTR _ping$[ebp]
	mov	WORD PTR [eax+1738], cx
$LN41@RunUpdateC:

; 4669 : 
; 4670 : 							// Most packets should arrive by the ping time.
; 4671 : 							assert(ping < 10000); // Sanity check - could hit due to negative pings causing the var to overflow

	cmp	DWORD PTR _ping$[ebp], 10000		; 00002710H
	jb	SHORT $LN130@RunUpdateC
	mov	eax, DWORD PTR ?__LINE__Var@?1??RunUpdateCycle@RakPeer@@IAE_NXZ@4JA
	add	eax, 450				; 000001c2H
	push	eax
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_1BK@CNLEAJJK@?$AAp?$AAi?$AAn?$AAg?$AA?5?$AA?$DM?$AA?5?$AA1?$AA0?$AA0?$AA0?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN130@RunUpdateC:

; 4672 : 							remoteSystem->reliabilityLayer.SetPing( (unsigned short) ping );

	movzx	eax, WORD PTR _ping$[ebp]
	push	eax
	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	add	ecx, 13					; 0000000dH
	call	?SetPing@ReliabilityLayer@@QAEXI@Z	; ReliabilityLayer::SetPing

; 4673 : 
; 4674 : 							if ( ++( remoteSystem->pingAndClockDifferentialWriteIndex ) == PING_TIMES_ARRAY_SIZE )

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	mov	ecx, DWORD PTR [eax+1734]
	add	ecx, 1
	mov	DWORD PTR tv742[ebp], ecx
	mov	edx, DWORD PTR _remoteSystem$[ebp]
	mov	eax, DWORD PTR tv742[ebp]
	mov	DWORD PTR [edx+1734], eax
	cmp	DWORD PTR tv742[ebp], 5
	jne	SHORT $LN43@RunUpdateC

; 4675 : 								remoteSystem->pingAndClockDifferentialWriteIndex = 0;

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	mov	DWORD PTR [eax+1734], 0
$LN43@RunUpdateC:

; 4676 : 						}
; 4677 : 
; 4678 : 						delete [] data;

	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR $T13[ebp], eax
	mov	ecx, DWORD PTR $T13[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 4679 : 					}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _inBitStream$41[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	jmp	$LN55@RunUpdateC
$LN46@RunUpdateC:

; 4680 : 					else if ( (unsigned char)data[0] == ID_INTERNAL_PING && byteSize == sizeof(unsigned char)+sizeof(RakNetTime) )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 2
	jne	$LN37@RunUpdateC
	cmp	DWORD PTR _byteSize$[ebp], 5
	jne	$LN37@RunUpdateC

; 4681 : 					{
; 4682 : 						RakNet::BitStream inBitStream( (unsigned char *) data, byteSize, false );

	push	0
	mov	eax, DWORD PTR _byteSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _inBitStream$40[ebp]
	call	??0BitStream@RakNet@@QAE@PAEI_N@Z	; RakNet::BitStream::BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], 3

; 4683 :  						inBitStream.IgnoreBits(8);

	push	8
	lea	ecx, DWORD PTR _inBitStream$40[ebp]
	call	?IgnoreBits@BitStream@RakNet@@QAEXH@Z	; RakNet::BitStream::IgnoreBits

; 4684 : 						RakNetTime sendPingTime;
; 4685 : 						inBitStream.Read(sendPingTime);

	lea	eax, DWORD PTR _sendPingTime$39[ebp]
	push	eax
	lea	ecx, DWORD PTR _inBitStream$40[ebp]
	call	??$Read@I@BitStream@RakNet@@QAE_NAAI@Z	; RakNet::BitStream::Read<unsigned int>

; 4686 : 
; 4687 : 						RakNet::BitStream outBitStream;

	lea	ecx, DWORD PTR _outBitStream$38[ebp]
	call	??0BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::BitStream
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 4688 : 						outBitStream.Write((unsigned char)ID_CONNECTED_PONG);

	push	5
	lea	ecx, DWORD PTR _outBitStream$38[ebp]
	call	??$Write@E@BitStream@RakNet@@QAEXE@Z	; RakNet::BitStream::Write<unsigned char>

; 4689 : 						outBitStream.Write(sendPingTime);

	mov	eax, DWORD PTR _sendPingTime$39[ebp]
	push	eax
	lea	ecx, DWORD PTR _outBitStream$38[ebp]
	call	??$Write@I@BitStream@RakNet@@QAEXI@Z	; RakNet::BitStream::Write<unsigned int>

; 4690 : 						timeMS = RakNet::GetTime();

	call	?GetTime@RakNet@@YAIXZ			; RakNet::GetTime
	mov	DWORD PTR _timeMS$[ebp], eax

; 4691 : 						timeNS = RakNet::GetTimeNS();

	call	?GetTimeNS@RakNet@@YA_JXZ		; RakNet::GetTimeNS
	mov	DWORD PTR _timeNS$[ebp], eax
	mov	DWORD PTR _timeNS$[ebp+4], edx

; 4692 : 						outBitStream.Write(timeMS);

	mov	eax, DWORD PTR _timeMS$[ebp]
	push	eax
	lea	ecx, DWORD PTR _outBitStream$38[ebp]
	call	??$Write@I@BitStream@RakNet@@QAEXI@Z	; RakNet::BitStream::Write<unsigned int>

; 4693 : 						SendImmediate( (char*)outBitStream.GetData(), outBitStream.GetNumberOfBitsUsed(), SYSTEM_PRIORITY, UNRELIABLE, 0, playerId, false, false, timeMS );

	mov	eax, DWORD PTR _timeMS$[ebp]
	xor	ecx, ecx
	push	ecx
	push	eax
	push	0
	push	0
	sub	esp, 8
	mov	edx, esp
	mov	eax, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [edx], eax
	mov	cx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [edx+4], cx
	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR _outBitStream$38[ebp]
	call	?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBitsUsed
	push	eax
	lea	ecx, DWORD PTR _outBitStream$38[ebp]
	call	?GetData@BitStream@RakNet@@QBEPAEXZ	; RakNet::BitStream::GetData
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendImmediate@RakPeer@@IAE_NPADHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N4_J@Z ; RakPeer::SendImmediate

; 4694 : 
; 4695 : 						delete [] data;

	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR $T14[ebp], eax
	mov	ecx, DWORD PTR $T14[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 4696 : 					}

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _outBitStream$38[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _inBitStream$40[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	jmp	$LN55@RunUpdateC
$LN37@RunUpdateC:

; 4697 : 					else if ( (unsigned char) data[ 0 ] == ID_DISCONNECTION_NOTIFICATION )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 28					; 0000001cH
	jne	SHORT $LN35@RunUpdateC

; 4698 : 					{
; 4699 : 						/*
; 4700 : 						unsigned staticDataBytes=remoteSystem->staticData.GetNumberOfBytesUsed();
; 4701 : 
; 4702 : 						if ( staticDataBytes > 0 )
; 4703 : 						{
; 4704 : 							packet=AllocPacket(sizeof( char ) + staticDataBytes);
; 4705 : 							packet->data[ 0 ] = ID_DISCONNECTION_NOTIFICATION;
; 4706 : 							memcpy( packet->data + sizeof( char ), remoteSystem->staticData.GetData(), staticDataBytes );
; 4707 : 							packet->bitSize = sizeof( char ) * 8 + remoteSystem->staticData.GetNumberOfBitsUsed();
; 4708 : 							delete [] data;
; 4709 : 						}
; 4710 : 						else
; 4711 : 						{
; 4712 : 							packet=AllocPacket(1, data);
; 4713 : 							packet->bitSize = 8;
; 4714 : 						}
; 4715 : 						*/
; 4716 : 
; 4717 : 						
; 4718 : //						packet->playerId = playerId;
; 4719 : //						packet->playerIndex = ( PlayerIndex ) remoteSystemIndex;
; 4720 : 
; 4721 : 						// We shouldn't close the connection immediately because we need to ack the ID_DISCONNECTION_NOTIFICATION
; 4722 : 						remoteSystem->connectMode=RemoteSystemStruct::DISCONNECT_ON_NO_ACK;

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	mov	DWORD PTR [eax+2054], 3

; 4723 : 						delete [] data;

	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR $T15[ebp], eax
	mov	ecx, DWORD PTR $T15[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	jmp	$LN55@RunUpdateC
$LN35@RunUpdateC:

; 4724 : 
; 4725 : 					//	AddPacketToProducer(packet);
; 4726 : 					}
; 4727 : 					else if ( (unsigned char) data[ 0 ] == ID_RPC_MAPPING )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 13					; 0000000dH
	jne	$LN33@RunUpdateC

; 4728 : 					{
; 4729 : 						RakNet::BitStream inBitStream( (unsigned char *) data, byteSize, false );

	push	0
	mov	eax, DWORD PTR _byteSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _inBitStream$37[ebp]
	call	??0BitStream@RakNet@@QAE@PAEI_N@Z	; RakNet::BitStream::BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], 5

; 4730 : 						RPCIndex index;
; 4731 : 						char output[256];
; 4732 : 						inBitStream.IgnoreBits(8);

	push	8
	lea	ecx, DWORD PTR _inBitStream$37[ebp]
	call	?IgnoreBits@BitStream@RakNet@@QAEXH@Z	; RakNet::BitStream::IgnoreBits

; 4733 : 						stringCompressor->DecodeString(output, 255, &inBitStream);

	push	0
	lea	eax, DWORD PTR _inBitStream$37[ebp]
	push	eax
	push	255					; 000000ffH
	lea	ecx, DWORD PTR _output$35[ebp]
	push	ecx
	call	?Instance@StringCompressor@@SAPAV1@XZ	; StringCompressor::Instance
	mov	ecx, eax
	call	?DecodeString@StringCompressor@@QAE_NPADHPAVBitStream@RakNet@@H@Z ; StringCompressor::DecodeString

; 4734 : 						inBitStream.ReadCompressed(index);

	lea	eax, DWORD PTR _index$36[ebp]
	push	eax
	lea	ecx, DWORD PTR _inBitStream$37[ebp]
	call	??$ReadCompressed@E@BitStream@RakNet@@QAE_NAAE@Z ; RakNet::BitStream::ReadCompressed<unsigned char>

; 4735 :                         remoteSystem->rpcMap.AddIdentifierAtIndex((char*)output,index);

	movzx	eax, BYTE PTR _index$36[ebp]
	push	eax
	lea	ecx, DWORD PTR _output$35[ebp]
	push	ecx
	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	add	ecx, 2042				; 000007faH
	call	?AddIdentifierAtIndex@RPCMap@@QAEXPADE@Z ; RPCMap::AddIdentifierAtIndex

; 4736 : 						delete [] data;

	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR $T16[ebp], eax
	mov	ecx, DWORD PTR $T16[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 4737 : 					}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _inBitStream$37[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	jmp	$LN55@RunUpdateC
$LN33@RunUpdateC:

; 4738 : 					else if ( (unsigned char) data[ 0 ] == ID_REQUEST_STATIC_DATA )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 7
	jne	SHORT $LN31@RunUpdateC

; 4739 : 					{
; 4740 : 						SendStaticDataInternal( playerId, true );

	push	1
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendStaticDataInternal@RakPeer@@IAEXUPlayerID@@_N@Z ; RakPeer::SendStaticDataInternal

; 4741 : 						delete [] data;

	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR $T17[ebp], eax
	mov	ecx, DWORD PTR $T17[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	jmp	$LN55@RunUpdateC
$LN31@RunUpdateC:

; 4742 : 					}
; 4743 : 					else if ( (unsigned char) data[ 0 ] == ID_RECEIVED_STATIC_DATA )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 38					; 00000026H
	jne	SHORT $LN29@RunUpdateC

; 4744 : 					{
; 4745 : 						remoteSystem->staticData.Reset();

	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	add	ecx, 1748				; 000006d4H
	call	?Reset@BitStream@RakNet@@QAEXXZ		; RakNet::BitStream::Reset

; 4746 : 						remoteSystem->staticData.Write( ( char* ) data + sizeof(unsigned char), byteSize - 1 );

	mov	eax, DWORD PTR _byteSize$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	add	ecx, 1748				; 000006d4H
	call	?Write@BitStream@RakNet@@QAEXPBDH@Z	; RakNet::BitStream::Write

; 4747 : 
; 4748 : 						// Inform game server code that we got static data
; 4749 : 						packet=AllocPacket(byteSize, data);

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _byteSize$[ebp]
	push	ecx
	call	?AllocPacket@@YAPAUPacket@@IPAE@Z	; AllocPacket
	add	esp, 8
	mov	DWORD PTR _packet$[ebp], eax

; 4750 : 						packet->bitSize = bitSize;

	mov	eax, DWORD PTR _packet$[ebp]
	mov	ecx, DWORD PTR _bitSize$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 4751 : 						packet->playerId = playerId;

	lea	eax, DWORD PTR _playerId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _packet$[ebp]
	add	ecx, 2
	call	??4PlayerID@@QAEAAU0@ABU0@@Z		; PlayerID::operator=

; 4752 : 						packet->playerIndex = ( PlayerIndex ) remoteSystemIndex;

	mov	eax, DWORD PTR _packet$[ebp]
	mov	cx, WORD PTR _remoteSystemIndex$[ebp]
	mov	WORD PTR [eax], cx

; 4753 : 						AddPacketToProducer(packet);

	mov	eax, DWORD PTR _packet$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddPacketToProducer@RakPeer@@IAEXPAUPacket@@@Z ; RakPeer::AddPacketToProducer

; 4754 : 					}
; 4755 : #if !defined(_COMPATIBILITY_1)
; 4756 : 					else if ( (unsigned char)(data)[0] == ID_SECURED_CONNECTION_RESPONSE &&

	jmp	$LN55@RunUpdateC
$LN29@RunUpdateC:

; 4757 : 						byteSize == 1 + sizeof( big::u32 ) + sizeof( RSA_BIT_SIZE ) + 20 )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 11					; 0000000bH
	jne	SHORT $LN27@RunUpdateC
	cmp	DWORD PTR _byteSize$[ebp], 57		; 00000039H
	jne	SHORT $LN27@RunUpdateC

; 4758 : 					{
; 4759 : 						SecuredConnectionConfirmation( remoteSystem, (char*)data );

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SecuredConnectionConfirmation@RakPeer@@IAEXPAURemoteSystemStruct@1@PAD@Z ; RakPeer::SecuredConnectionConfirmation

; 4760 : 						delete [] data;

	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR $T18[ebp], eax
	mov	ecx, DWORD PTR $T18[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 4761 : 					}
; 4762 : 					else if ( (unsigned char)(data)[0] == ID_SECURED_CONNECTION_CONFIRMATION &&

	jmp	$LN55@RunUpdateC
$LN27@RunUpdateC:

; 4763 : 						byteSize == 1 + 20 + sizeof( RSA_BIT_SIZE ) )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 12					; 0000000cH
	jne	$LN25@RunUpdateC
	cmp	DWORD PTR _byteSize$[ebp], 53		; 00000035H
	jne	$LN25@RunUpdateC

; 4764 : 					{
; 4765 : 						CSHA1 sha1;

	lea	ecx, DWORD PTR _sha1$34[ebp]
	call	??0CSHA1@@QAE@XZ			; CSHA1::CSHA1
	mov	DWORD PTR __$EHRec$[ebp+8], 6

; 4766 : 						bool confirmedHash, newRandNumber;
; 4767 : 
; 4768 : 						confirmedHash = false;

	mov	BYTE PTR _confirmedHash$33[ebp], 0

; 4769 : 
; 4770 : 						// Hash the SYN-Cookie
; 4771 : 						// s2c syn-cookie = SHA1_HASH(source ip address + source port + random number)
; 4772 : 						sha1.Reset();

	lea	ecx, DWORD PTR _sha1$34[ebp]
	call	?Reset@CSHA1@@QAEXXZ			; CSHA1::Reset

; 4773 : 						sha1.Update( ( unsigned char* ) & playerId.binaryAddress, sizeof( playerId.binaryAddress ) );

	push	4
	lea	eax, DWORD PTR _playerId$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sha1$34[ebp]
	call	?Update@CSHA1@@QAEXPAEI@Z		; CSHA1::Update

; 4774 : 						sha1.Update( ( unsigned char* ) & playerId.port, sizeof( playerId.port ) );

	push	2
	lea	eax, DWORD PTR _playerId$[ebp+4]
	push	eax
	lea	ecx, DWORD PTR _sha1$34[ebp]
	call	?Update@CSHA1@@QAEXPAEI@Z		; CSHA1::Update

; 4775 : 						sha1.Update( ( unsigned char* ) & ( newRandomNumber ), 20 );

	push	20					; 00000014H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2449				; 00000991H
	push	eax
	lea	ecx, DWORD PTR _sha1$34[ebp]
	call	?Update@CSHA1@@QAEXPAEI@Z		; CSHA1::Update

; 4776 : 						sha1.Final();

	lea	ecx, DWORD PTR _sha1$34[ebp]
	call	?Final@CSHA1@@QAEXXZ			; CSHA1::Final

; 4777 : 
; 4778 : 						newRandNumber = false;

	mov	BYTE PTR _newRandNumber$32[ebp], 0

; 4779 : 
; 4780 : 						// Confirm if
; 4781 : 						//syn-cookie ?= HASH(source ip address + source port + last random number)
; 4782 : 						//syn-cookie ?= HASH(source ip address + source port + current random number)
; 4783 : 						if ( memcmp( sha1.GetHash(), data + 1, 20 ) == 0 )

	push	20					; 00000014H
	mov	eax, DWORD PTR _data$[ebp]
	add	eax, 1
	push	eax
	lea	ecx, DWORD PTR _sha1$34[ebp]
	call	?GetHash@CSHA1@@QBEPAEXZ		; CSHA1::GetHash
	push	eax
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN24@RunUpdateC

; 4784 : 						{
; 4785 : 							confirmedHash = true;

	mov	BYTE PTR _confirmedHash$33[ebp], 1

; 4786 : 						}
; 4787 : 						else

	jmp	SHORT $LN23@RunUpdateC
$LN24@RunUpdateC:

; 4788 : 						{
; 4789 : 							sha1.Reset();

	lea	ecx, DWORD PTR _sha1$34[ebp]
	call	?Reset@CSHA1@@QAEXXZ			; CSHA1::Reset

; 4790 : 							sha1.Update( ( unsigned char* ) & playerId.binaryAddress, sizeof( playerId.binaryAddress ) );

	push	4
	lea	eax, DWORD PTR _playerId$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sha1$34[ebp]
	call	?Update@CSHA1@@QAEXPAEI@Z		; CSHA1::Update

; 4791 : 							sha1.Update( ( unsigned char* ) & playerId.port, sizeof( playerId.port ) );

	push	2
	lea	eax, DWORD PTR _playerId$[ebp+4]
	push	eax
	lea	ecx, DWORD PTR _sha1$34[ebp]
	call	?Update@CSHA1@@QAEXPAEI@Z		; CSHA1::Update

; 4792 : 							sha1.Update( ( unsigned char* ) & ( oldRandomNumber ), 20 );

	push	20					; 00000014H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2469				; 000009a5H
	push	eax
	lea	ecx, DWORD PTR _sha1$34[ebp]
	call	?Update@CSHA1@@QAEXPAEI@Z		; CSHA1::Update

; 4793 : 							sha1.Final();

	lea	ecx, DWORD PTR _sha1$34[ebp]
	call	?Final@CSHA1@@QAEXXZ			; CSHA1::Final

; 4794 : 
; 4795 : 							if ( memcmp( sha1.GetHash(), data + 1, 20 ) == 0 )

	push	20					; 00000014H
	mov	eax, DWORD PTR _data$[ebp]
	add	eax, 1
	push	eax
	lea	ecx, DWORD PTR _sha1$34[ebp]
	call	?GetHash@CSHA1@@QBEPAEXZ		; CSHA1::GetHash
	push	eax
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN23@RunUpdateC

; 4796 : 								confirmedHash = true;

	mov	BYTE PTR _confirmedHash$33[ebp], 1
$LN23@RunUpdateC:

; 4797 : 						}
; 4798 : 						if ( confirmedHash )

	movzx	eax, BYTE PTR _confirmedHash$33[ebp]
	test	eax, eax
	je	$LN21@RunUpdateC

; 4799 : 						{
; 4800 : 							int i;
; 4801 : 							unsigned char AESKey[ 16 ];
; 4802 : 							RSA_BIT_SIZE message, encryptedMessage;
; 4803 : 
; 4804 : 							// On connection accept, AES key is c2s RSA_Decrypt(random number) XOR s2c syn-cookie
; 4805 : 							// Get the random number first
; 4806 : 							#ifdef HOST_ENDIAN_IS_BIG
; 4807 : 								BSWAPCPY( (unsigned char *) encryptedMessage, (unsigned char *)(data + 1 + 20), sizeof( RSA_BIT_SIZE ) );
; 4808 : 							#else
; 4809 : 								memcpy( encryptedMessage, data + 1 + 20, sizeof( RSA_BIT_SIZE ) );

	push	32					; 00000020H
	mov	eax, DWORD PTR _data$[ebp]
	add	eax, 21					; 00000015H
	push	eax
	lea	ecx, DWORD PTR _encryptedMessage$28[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 4810 : 							#endif
; 4811 : 							rsacrypt.decrypt( encryptedMessage, message );

	lea	eax, DWORD PTR _message$29[ebp]
	push	eax
	lea	ecx, DWORD PTR _encryptedMessage$28[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2102				; 00000836H
	call	?decrypt@?$RSACrypt@$$BY07I@big@@QAEXAAY07I0@Z ; big::RSACrypt<unsigned int [8]>::decrypt

; 4812 : 							#ifdef HOST_ENDIAN_IS_BIG
; 4813 : 								BSWAPSELF( (unsigned char *) message, sizeof( RSA_BIT_SIZE ) );
; 4814 : 							#endif
; 4815 : 
; 4816 : 							// Save the AES key
; 4817 : 							for ( i = 0; i < 16; i++ )

	mov	DWORD PTR _i$31[ebp], 0
	jmp	SHORT $LN20@RunUpdateC
$LN19@RunUpdateC:
	mov	eax, DWORD PTR _i$31[ebp]
	add	eax, 1
	mov	DWORD PTR _i$31[ebp], eax
$LN20@RunUpdateC:
	cmp	DWORD PTR _i$31[ebp], 16		; 00000010H
	jge	SHORT $LN18@RunUpdateC

; 4818 : 								AESKey[ i ] = data[ 1 + i ] ^ ( ( unsigned char* ) ( message ) ) [ i ];

	mov	eax, DWORD PTR _data$[ebp]
	add	eax, DWORD PTR _i$31[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	mov	edx, DWORD PTR _i$31[ebp]
	movzx	eax, BYTE PTR _message$29[ebp+edx]
	xor	ecx, eax
	mov	edx, DWORD PTR _i$31[ebp]
	mov	BYTE PTR _AESKey$30[ebp+edx], cl
	jmp	SHORT $LN19@RunUpdateC
$LN18@RunUpdateC:

; 4819 : 
; 4820 : 							// Connect this player assuming we have open slots
; 4821 : 							OnConnectionRequest( remoteSystem, AESKey, true );

	push	1
	lea	eax, DWORD PTR _AESKey$30[ebp]
	push	eax
	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OnConnectionRequest@RakPeer@@IAEXPAURemoteSystemStruct@1@PAE_N@Z ; RakPeer::OnConnectionRequest
$LN21@RunUpdateC:

; 4822 : 						}
; 4823 : 						delete [] data;

	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR $T19[ebp], eax
	mov	ecx, DWORD PTR $T19[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 4824 : 					}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sha1$34[ebp]
	call	??1CSHA1@@UAE@XZ			; CSHA1::~CSHA1
	jmp	$LN55@RunUpdateC
$LN25@RunUpdateC:

; 4825 : #endif // #if !defined(_COMPATIBILITY_1)
; 4826 : 					else if ( (unsigned char)(data)[0] == ID_DETECT_LOST_CONNECTIONS && byteSize == sizeof(unsigned char) )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 15					; 0000000fH
	jne	SHORT $LN16@RunUpdateC
	cmp	DWORD PTR _byteSize$[ebp], 1
	jne	SHORT $LN16@RunUpdateC

; 4827 : 					{
; 4828 : 						// Do nothing
; 4829 : 						delete [] data;

	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR $T20[ebp], eax
	mov	ecx, DWORD PTR $T20[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	jmp	$LN55@RunUpdateC
$LN16@RunUpdateC:

; 4830 : 					}
; 4831 : 					else if ( (unsigned char)(data)[0] == ID_CONNECTION_REQUEST_ACCEPTED && byteSize == sizeof(unsigned char)+sizeof(unsigned int)+sizeof(unsigned short)+sizeof(PlayerIndex)+sizeof(unsigned int) )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 23					; 00000017H
	jne	$LN14@RunUpdateC
	cmp	DWORD PTR _byteSize$[ebp], 13		; 0000000dH
	jne	$LN14@RunUpdateC

; 4832 : 					{
; 4833 : 						// Make sure this connection accept is from someone we wanted to connect to
; 4834 : 						bool allowConnection, alreadyConnected;
; 4835 : 
; 4836 : 						if (remoteSystem->connectMode==RemoteSystemStruct::HANDLING_CONNECTION_REQUEST || remoteSystem->connectMode==RemoteSystemStruct::REQUESTED_CONNECTION || allowConnectionResponseIPMigration)

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	cmp	DWORD PTR [eax+2054], 5
	je	SHORT $LN12@RunUpdateC
	mov	eax, DWORD PTR _remoteSystem$[ebp]
	cmp	DWORD PTR [eax+2054], 4
	je	SHORT $LN12@RunUpdateC
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+2489]
	test	ecx, ecx
	je	SHORT $LN13@RunUpdateC
$LN12@RunUpdateC:

; 4837 : 							allowConnection=true;

	mov	BYTE PTR _allowConnection$27[ebp], 1

; 4838 : 						else

	jmp	SHORT $LN11@RunUpdateC
$LN13@RunUpdateC:

; 4839 : 							allowConnection=false;

	mov	BYTE PTR _allowConnection$27[ebp], 0
$LN11@RunUpdateC:

; 4840 : 						if (remoteSystem->connectMode==RemoteSystemStruct::HANDLING_CONNECTION_REQUEST)

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	cmp	DWORD PTR [eax+2054], 5
	jne	SHORT $LN10@RunUpdateC

; 4841 : 							alreadyConnected=true;

	mov	BYTE PTR _alreadyConnected$26[ebp], 1

; 4842 : 						else

	jmp	SHORT $LN9@RunUpdateC
$LN10@RunUpdateC:

; 4843 : 							alreadyConnected=false;

	mov	BYTE PTR _alreadyConnected$26[ebp], 0
$LN9@RunUpdateC:

; 4844 : 
; 4845 : 						if ( allowConnection )

	movzx	eax, BYTE PTR _allowConnection$27[ebp]
	test	eax, eax
	je	$LN8@RunUpdateC

; 4846 : 						{
; 4847 : 							PlayerID externalID;
; 4848 : 							PlayerIndex playerIndex;
; 4849 : 
; 4850 : 							RakNet::BitStream inBitStream((unsigned char *) data, byteSize, false);

	push	0
	mov	eax, DWORD PTR _byteSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _inBitStream$23[ebp]
	call	??0BitStream@RakNet@@QAE@PAEI_N@Z	; RakNet::BitStream::BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], 7

; 4851 : 							inBitStream.IgnoreBits(8); // ID_CONNECTION_REQUEST_ACCEPTED

	push	8
	lea	ecx, DWORD PTR _inBitStream$23[ebp]
	call	?IgnoreBits@BitStream@RakNet@@QAEXH@Z	; RakNet::BitStream::IgnoreBits

; 4852 : 						//	inBitStream.Read(remotePort);
; 4853 : 							inBitStream.Read(externalID.binaryAddress);

	lea	eax, DWORD PTR _externalID$25[ebp]
	push	eax
	lea	ecx, DWORD PTR _inBitStream$23[ebp]
	call	??$Read@I@BitStream@RakNet@@QAE_NAAI@Z	; RakNet::BitStream::Read<unsigned int>

; 4854 : 							inBitStream.Read(externalID.port);

	lea	eax, DWORD PTR _externalID$25[ebp+4]
	push	eax
	lea	ecx, DWORD PTR _inBitStream$23[ebp]
	call	??$Read@G@BitStream@RakNet@@QAE_NAAG@Z	; RakNet::BitStream::Read<unsigned short>

; 4855 : 							inBitStream.Read(playerIndex);

	lea	eax, DWORD PTR _playerIndex$24[ebp]
	push	eax
	lea	ecx, DWORD PTR _inBitStream$23[ebp]
	call	??$Read@G@BitStream@RakNet@@QAE_NAAG@Z	; RakNet::BitStream::Read<unsigned short>

; 4856 : 
; 4857 : 							// Find a free remote system struct to use
; 4858 : 							//						RakNet::BitStream casBitS(data, byteSize, false);
; 4859 : 							//						ConnectionAcceptStruct cas;
; 4860 : 							//						cas.Deserialize(casBitS);
; 4861 : 						//	playerId.port = remotePort;
; 4862 : 
; 4863 : 							// The remote system told us our external IP, so save it
; 4864 : 							remoteSystem->myExternalPlayerId = externalID;

	lea	eax, DWORD PTR _externalID$25[ebp]
	push	eax
	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	add	ecx, 7
	call	??4PlayerID@@QAEAAU0@ABU0@@Z		; PlayerID::operator=

; 4865 : 							remoteSystem->connectMode=RemoteSystemStruct::CONNECTED;

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	mov	DWORD PTR [eax+2054], 8

; 4866 : 
; 4867 : 
; 4868 : 							if (alreadyConnected==false)

	movzx	eax, BYTE PTR _alreadyConnected$26[ebp]
	test	eax, eax
	jne	SHORT $LN7@RunUpdateC

; 4869 : 							{
; 4870 : #ifdef __USE_IO_COMPLETION_PORTS
; 4871 : 								bool b;
; 4872 : 								// Create a new nonblocking socket
; 4873 : 								remoteSystem->reliabilityLayer.SetSocket( SocketLayer::Instance()->CreateBoundSocket( myPlayerId.port, false ) );
; 4874 : 
; 4875 : 								SocketLayer::Instance()->Connect( remoteSystem->reliabilityLayer.GetSocket(), playerId.binaryAddress, playerId.port );
; 4876 : 								// Associate our new socket with a completion port and do the first read
; 4877 : 								b = SocketLayer::Instance()->AssociateSocketWithCompletionPortAndRead( remoteSystem->reliabilityLayer.GetSocket(), playerId.binaryAddress, playerId.port, rakPeer );
; 4878 : 								//client->//reliabilityLayerMutex.Unlock();
; 4879 : 
; 4880 : 								if ( b == false )   // Some damn completion port error... windows is so unreliable
; 4881 : 								{
; 4882 : #ifdef _DO_PRINTF
; 4883 : 									printf( "RakClient - AssociateSocketWithCompletionPortAndRead failed" );
; 4884 : #endif
; 4885 : 									return ;
; 4886 : 								}
; 4887 : #endif
; 4888 : 
; 4889 : 								// Use the stored encryption key
; 4890 : 								if (remoteSystem->setAESKey)

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	movzx	ecx, BYTE PTR [eax+2041]
	test	ecx, ecx
	je	SHORT $LN6@RunUpdateC

; 4891 : 									remoteSystem->reliabilityLayer.SetEncryptionKey( remoteSystem->AESKey );

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	add	eax, 2025				; 000007e9H
	push	eax
	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	add	ecx, 13					; 0000000dH
	call	?SetEncryptionKey@ReliabilityLayer@@QAEXPBE@Z ; ReliabilityLayer::SetEncryptionKey

; 4892 : 								else

	jmp	SHORT $LN7@RunUpdateC
$LN6@RunUpdateC:

; 4893 : 									remoteSystem->reliabilityLayer.SetEncryptionKey( 0 );

	push	0
	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	add	ecx, 13					; 0000000dH
	call	?SetEncryptionKey@ReliabilityLayer@@QAEXPBE@Z ; ReliabilityLayer::SetEncryptionKey
$LN7@RunUpdateC:

; 4894 : 							}
; 4895 : 
; 4896 : 							// Send the connection request complete to the game
; 4897 : 							packet=AllocPacket(byteSize, data);

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _byteSize$[ebp]
	push	ecx
	call	?AllocPacket@@YAPAUPacket@@IPAE@Z	; AllocPacket
	add	esp, 8
	mov	DWORD PTR _packet$[ebp], eax

; 4898 : 							packet->bitSize = byteSize * 8;

	mov	eax, DWORD PTR _byteSize$[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR _packet$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 4899 : 							packet->playerId = playerId;

	lea	eax, DWORD PTR _playerId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _packet$[ebp]
	add	ecx, 2
	call	??4PlayerID@@QAEAAU0@ABU0@@Z		; PlayerID::operator=

; 4900 : 							packet->playerIndex = ( PlayerIndex ) GetIndexFromPlayerID( playerId, true );

	push	1
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexFromPlayerID@RakPeer@@IAEHUPlayerID@@_N@Z ; RakPeer::GetIndexFromPlayerID
	mov	ecx, DWORD PTR _packet$[ebp]
	mov	WORD PTR [ecx], ax

; 4901 : 							AddPacketToProducer(packet);

	mov	eax, DWORD PTR _packet$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddPacketToProducer@RakPeer@@IAEXPAUPacket@@@Z ; RakPeer::AddPacketToProducer

; 4902 : 
; 4903 : 							RakNet::BitStream outBitStream(sizeof(unsigned char)+sizeof(unsigned int)+sizeof(unsigned short));

	push	7
	lea	ecx, DWORD PTR _outBitStream$22[ebp]
	call	??0BitStream@RakNet@@QAE@H@Z		; RakNet::BitStream::BitStream
	mov	BYTE PTR __$EHRec$[ebp+8], 8

; 4904 : 							outBitStream.Write((unsigned char)ID_NEW_INCOMING_CONNECTION);

	push	26					; 0000001aH
	lea	ecx, DWORD PTR _outBitStream$22[ebp]
	call	??$Write@E@BitStream@RakNet@@QAEXE@Z	; RakNet::BitStream::Write<unsigned char>

; 4905 : 							outBitStream.Write(playerId.binaryAddress);

	mov	eax, DWORD PTR _playerId$[ebp]
	push	eax
	lea	ecx, DWORD PTR _outBitStream$22[ebp]
	call	??$Write@I@BitStream@RakNet@@QAEXI@Z	; RakNet::BitStream::Write<unsigned int>

; 4906 : 							outBitStream.Write(playerId.port);

	movzx	eax, WORD PTR _playerId$[ebp+4]
	push	eax
	lea	ecx, DWORD PTR _outBitStream$22[ebp]
	call	??$Write@G@BitStream@RakNet@@QAEXG@Z	; RakNet::BitStream::Write<unsigned short>

; 4907 : 							// We turned on encryption with SetEncryptionKey.  This pads packets to up to 16 bytes.
; 4908 : 							// As soon as a 16 byte packet arrives on the remote system, we will turn on AES.  This works because all encrypted packets are multiples of 16 and the
; 4909 : 							// packets I happen to be sending before this are less than 16 bytes.  Otherwise there is no way to know if a packet that arrived is
; 4910 : 							// encrypted or not so the other side won't know to turn on encryption or not.
; 4911 : 							SendImmediate( (char*)outBitStream.GetData(), outBitStream.GetNumberOfBitsUsed(), SYSTEM_PRIORITY, RELIABLE, 0, playerId, false, false, RakNet::GetTime() );

	call	?GetTime@RakNet@@YAIXZ			; RakNet::GetTime
	xor	ecx, ecx
	push	ecx
	push	eax
	push	0
	push	0
	sub	esp, 8
	mov	edx, esp
	mov	eax, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [edx], eax
	mov	cx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [edx+4], cx
	push	0
	push	2
	push	0
	lea	ecx, DWORD PTR _outBitStream$22[ebp]
	call	?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBitsUsed
	push	eax
	lea	ecx, DWORD PTR _outBitStream$22[ebp]
	call	?GetData@BitStream@RakNet@@QBEPAEXZ	; RakNet::BitStream::GetData
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendImmediate@RakPeer@@IAE_NPADHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N4_J@Z ; RakPeer::SendImmediate

; 4912 : 
; 4913 : 							if (alreadyConnected==false)

	movzx	eax, BYTE PTR _alreadyConnected$26[ebp]
	test	eax, eax
	jne	SHORT $LN4@RunUpdateC

; 4914 : 							{
; 4915 : 								PingInternal( playerId, true );

	push	1
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PingInternal@RakPeer@@IAEXUPlayerID@@_N@Z ; RakPeer::PingInternal

; 4916 : 								SendStaticDataInternal( playerId, true );

	push	1
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendStaticDataInternal@RakPeer@@IAEXUPlayerID@@_N@Z ; RakPeer::SendStaticDataInternal
$LN4@RunUpdateC:

; 4917 : 							}
; 4918 : 						}

	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	ecx, DWORD PTR _outBitStream$22[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _inBitStream$23[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream

; 4919 : 						else

	jmp	SHORT $LN3@RunUpdateC
$LN8@RunUpdateC:

; 4920 : 						{
; 4921 : 							// Tell the remote system the connection failed
; 4922 : 							NotifyAndFlagForDisconnect(playerId, true, 0);

	push	0
	push	1
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NotifyAndFlagForDisconnect@RakPeer@@IAEXUPlayerID@@_NE@Z ; RakPeer::NotifyAndFlagForDisconnect

; 4923 : #ifdef _DO_PRINTF
; 4924 : 							printf( "Error: Got a connection accept when we didn't request the connection.\n" );
; 4925 : #endif
; 4926 : 							delete [] data;

	mov	eax, DWORD PTR _data$[ebp]
	mov	DWORD PTR $T21[ebp], eax
	mov	ecx, DWORD PTR $T21[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN3@RunUpdateC:

; 4927 : 						}
; 4928 : 					}
; 4929 : 					else

	jmp	SHORT $LN55@RunUpdateC
$LN14@RunUpdateC:

; 4930 : 					{
; 4931 : 						if (data[0]>=(unsigned char)ID_RPC)

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 19					; 00000013H
	jl	SHORT $LN55@RunUpdateC

; 4932 : 						{
; 4933 : 							packet=AllocPacket(byteSize, data);

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _byteSize$[ebp]
	push	ecx
	call	?AllocPacket@@YAPAUPacket@@IPAE@Z	; AllocPacket
	add	esp, 8
	mov	DWORD PTR _packet$[ebp], eax

; 4934 : 							packet->bitSize = bitSize;

	mov	eax, DWORD PTR _packet$[ebp]
	mov	ecx, DWORD PTR _bitSize$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 4935 : 							packet->playerId = playerId;

	lea	eax, DWORD PTR _playerId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _packet$[ebp]
	add	ecx, 2
	call	??4PlayerID@@QAEAAU0@ABU0@@Z		; PlayerID::operator=

; 4936 : 							packet->playerIndex = ( PlayerIndex ) remoteSystemIndex;

	mov	eax, DWORD PTR _packet$[ebp]
	mov	cx, WORD PTR _remoteSystemIndex$[ebp]
	mov	WORD PTR [eax], cx

; 4937 : 							AddPacketToProducer(packet);					

	mov	eax, DWORD PTR _packet$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddPacketToProducer@RakPeer@@IAEXPAUPacket@@@Z ; RakPeer::AddPacketToProducer
$LN55@RunUpdateC:

; 4938 : 						}
; 4939 : 						//else
; 4940 : 							// Some internal type got returned to the user?
; 4941 : 							//RakAssert(0);
; 4942 : 					}
; 4943 : 				}
; 4944 : 
; 4945 : 				// Does the reliability layer have any more packets waiting for us?
; 4946 : 				// To be thread safe, this has to be called in the same thread as HandleSocketReceiveFromConnectedPlayer
; 4947 : 				bitSize = remoteSystem->reliabilityLayer.Receive( &data );

	lea	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	add	ecx, 13					; 0000000dH
	call	?Receive@ReliabilityLayer@@QAEHPAPAE@Z	; ReliabilityLayer::Receive
	mov	DWORD PTR _bitSize$[ebp], eax

; 4948 : 			}

	jmp	$LN66@RunUpdateC
$LN85@RunUpdateC:

; 4949 : 		}
; 4950 : 	}

	jmp	$LN87@RunUpdateC
$LN86@RunUpdateC:

; 4951 : 
; 4952 : 	return true;

	mov	al, 1
$LN120@RunUpdateC:

; 4953 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN169@RunUpdateC
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 3752				; 00000ea8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN169@RunUpdateC:
	DD	25					; 00000019H
	DD	$LN168@RunUpdateC
$LN168@RunUpdateC:
	DD	-132					; ffffff7cH
	DD	4
	DD	$LN142@RunUpdateC
	DD	-144					; ffffff70H
	DD	4
	DD	$LN143@RunUpdateC
	DD	-200					; ffffff38H
	DD	6
	DD	$LN144@RunUpdateC
	DD	-296					; fffffed8H
	DD	2
	DD	$LN145@RunUpdateC
	DD	-317					; fffffec3H
	DD	1
	DD	$LN146@RunUpdateC
	DD	-604					; fffffda4H
	DD	273					; 00000111H
	DD	$LN147@RunUpdateC
	DD	-900					; fffffc7cH
	DD	273					; 00000111H
	DD	$LN148@RunUpdateC
	DD	-916					; fffffc6cH
	DD	6
	DD	$LN149@RunUpdateC
	DD	-928					; fffffc60H
	DD	4
	DD	$LN150@RunUpdateC
	DD	-940					; fffffc54H
	DD	4
	DD	$LN151@RunUpdateC
	DD	-1224					; fffffb38H
	DD	273					; 00000111H
	DD	$LN152@RunUpdateC
	DD	-1508					; fffffa1cH
	DD	273					; 00000111H
	DD	$LN153@RunUpdateC
	DD	-1520					; fffffa10H
	DD	4
	DD	$LN154@RunUpdateC
	DD	-1804					; fffff8f4H
	DD	273					; 00000111H
	DD	$LN155@RunUpdateC
	DD	-2088					; fffff7d8H
	DD	273					; 00000111H
	DD	$LN156@RunUpdateC
	DD	-2097					; fffff7cfH
	DD	1
	DD	$LN157@RunUpdateC
	DD	-2364					; fffff6c4H
	DD	256					; 00000100H
	DD	$LN158@RunUpdateC
	DD	-2552					; fffff608H
	DD	180					; 000000b4H
	DD	$LN159@RunUpdateC
	DD	-2612					; fffff5ccH
	DD	16					; 00000010H
	DD	$LN160@RunUpdateC
	DD	-2652					; fffff5a4H
	DD	32					; 00000020H
	DD	$LN161@RunUpdateC
	DD	-2692					; fffff57cH
	DD	32					; 00000020H
	DD	$LN162@RunUpdateC
	DD	-2732					; fffff554H
	DD	6
	DD	$LN163@RunUpdateC
	DD	-2744					; fffff548H
	DD	2
	DD	$LN164@RunUpdateC
	DD	-3028					; fffff42cH
	DD	273					; 00000111H
	DD	$LN165@RunUpdateC
	DD	-3312					; fffff310H
	DD	273					; 00000111H
	DD	$LN166@RunUpdateC
$LN166@RunUpdateC:
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	66					; 00000042H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	0
$LN165@RunUpdateC:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	66					; 00000042H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	0
$LN164@RunUpdateC:
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	0
$LN163@RunUpdateC:
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	73					; 00000049H
	DB	68					; 00000044H
	DB	0
$LN162@RunUpdateC:
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	114					; 00000072H
	DB	121					; 00000079H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	77					; 0000004dH
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	115					; 00000073H
	DB	97					; 00000061H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	0
$LN161@RunUpdateC:
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	115					; 00000073H
	DB	97					; 00000061H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	0
$LN160@RunUpdateC:
	DB	65					; 00000041H
	DB	69					; 00000045H
	DB	83					; 00000053H
	DB	75					; 0000004bH
	DB	101					; 00000065H
	DB	121					; 00000079H
	DB	0
$LN159@RunUpdateC:
	DB	115					; 00000073H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	49					; 00000031H
	DB	0
$LN158@RunUpdateC:
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	112					; 00000070H
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	0
$LN157@RunUpdateC:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	0
$LN156@RunUpdateC:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	66					; 00000042H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	0
$LN155@RunUpdateC:
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	66					; 00000042H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	0
$LN154@RunUpdateC:
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	80					; 00000050H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$LN153@RunUpdateC:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	66					; 00000042H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	0
$LN152@RunUpdateC:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	66					; 00000042H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	0
$LN151@RunUpdateC:
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	80					; 00000050H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$LN150@RunUpdateC:
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	80					; 00000050H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$LN149@RunUpdateC:
	DB	98					; 00000062H
	DB	115					; 00000073H
	DB	80					; 00000050H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	73					; 00000049H
	DB	100					; 00000064H
	DB	0
$LN148@RunUpdateC:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	66					; 00000042H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	0
$LN147@RunUpdateC:
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	66					; 00000042H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	0
$LN146@RunUpdateC:
	DB	107					; 0000006bH
	DB	101					; 00000065H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	0
$LN145@RunUpdateC:
	DB	99					; 00000063H
	DB	0
$LN144@RunUpdateC:
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	73					; 00000049H
	DB	100					; 00000064H
	DB	0
$LN143@RunUpdateC:
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
$LN142@RunUpdateC:
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RunUpdateCycle@RakPeer@@IAE_NXZ$0:
	lea	ecx, DWORD PTR _dataBitStream$47[ebp]
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__unwindfunclet$?RunUpdateCycle@RakPeer@@IAE_NXZ$1:
	lea	ecx, DWORD PTR _inBitStream$45[ebp]
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__unwindfunclet$?RunUpdateCycle@RakPeer@@IAE_NXZ$2:
	lea	ecx, DWORD PTR _inBitStream$41[ebp]
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__unwindfunclet$?RunUpdateCycle@RakPeer@@IAE_NXZ$3:
	lea	ecx, DWORD PTR _inBitStream$40[ebp]
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__unwindfunclet$?RunUpdateCycle@RakPeer@@IAE_NXZ$4:
	lea	ecx, DWORD PTR _outBitStream$38[ebp]
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__unwindfunclet$?RunUpdateCycle@RakPeer@@IAE_NXZ$5:
	lea	ecx, DWORD PTR _inBitStream$37[ebp]
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__unwindfunclet$?RunUpdateCycle@RakPeer@@IAE_NXZ$6:
	lea	ecx, DWORD PTR _sha1$34[ebp]
	jmp	??1CSHA1@@UAE@XZ			; CSHA1::~CSHA1
__unwindfunclet$?RunUpdateCycle@RakPeer@@IAE_NXZ$7:
	lea	ecx, DWORD PTR _inBitStream$23[ebp]
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__unwindfunclet$?RunUpdateCycle@RakPeer@@IAE_NXZ$8:
	lea	ecx, DWORD PTR _outBitStream$22[ebp]
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__ehhandler$?RunUpdateCycle@RakPeer@@IAE_NXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-3756]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?RunUpdateCycle@RakPeer@@IAE_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?RunUpdateCycle@RakPeer@@IAE_NXZ ENDP			; RakPeer::RunUpdateCycle
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?SecuredConnectionConfirmation@RakPeer@@IAEXPAURemoteSystemStruct@1@PAD@Z
_TEXT	SEGMENT
_reply$ = -612						; size = 53
_privKeyPncrypt$ = -548					; size = 305
_encryptedMessage$ = -232				; size = 32
_message$ = -192					; size = 32
_n$ = -152						; size = 32
_e$ = -112						; size = 4
_packet$ = -100						; size = 4
_number$ = -88						; size = 4
_randomNumber$ = -76					; size = 20
_j$ = -48						; size = 4
_i$ = -36						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_remoteSystem$ = 8					; size = 4
_data$ = 12						; size = 4
?SecuredConnectionConfirmation@RakPeer@@IAEXPAURemoteSystemStruct@1@PAD@Z PROC ; RakPeer::SecuredConnectionConfirmation, COMDAT
; _this$ = ecx

; 3257 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SecuredConnectionConfirmation@RakPeer@@IAEXPAURemoteSystemStruct@1@PAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 796				; 0000031cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-808]
	mov	ecx, 199				; 000000c7H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3258 : #if !defined(_COMPATIBILITY_1)
; 3259 : 	int i, j;
; 3260 : 	unsigned char randomNumber[ 20 ];
; 3261 : 	unsigned int number;
; 3262 : 	//bool doSend;
; 3263 : 	Packet *packet;
; 3264 : 	big::u32 e;
; 3265 : 	RSA_BIT_SIZE n, message, encryptedMessage;
; 3266 : 	big::RSACrypt<RSA_BIT_SIZE> privKeyPncrypt;

	lea	ecx, DWORD PTR _privKeyPncrypt$[ebp]
	call	??0?$RSACrypt@$$BY07I@big@@QAE@XZ	; big::RSACrypt<unsigned int [8]>::RSACrypt<unsigned int [8]>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3267 : 
; 3268 : 	// Make sure that we still want to connect
; 3269 : 	if (remoteSystem->connectMode!=RemoteSystemStruct::REQUESTED_CONNECTION)

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	cmp	DWORD PTR [eax+2054], 4
	je	SHORT $LN10@SecuredCon

; 3270 : 		return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _privKeyPncrypt$[ebp]
	call	??1?$RSACrypt@$$BY07I@big@@QAE@XZ	; big::RSACrypt<unsigned int [8]>::~RSACrypt<unsigned int [8]>
	jmp	$LN11@SecuredCon
$LN10@SecuredCon:

; 3271 : 
; 3272 : 	// Copy out e and n
; 3273 : #ifdef HOST_ENDIAN_IS_BIG
; 3274 : 	BSWAPCPY( (unsigned char *)&e, (unsigned char *)(data + 1 + 20), sizeof( big::u32 ) );
; 3275 : 	BSWAPCPY( (unsigned char *)n, (unsigned char *)(data + 1 + 20 + sizeof( big::u32 )), sizeof( RSA_BIT_SIZE ) );
; 3276 : #else
; 3277 : 	memcpy( ( char* ) & e, data + 1 + 20, sizeof( big::u32 ) );

	push	4
	mov	eax, DWORD PTR _data$[ebp]
	add	eax, 21					; 00000015H
	push	eax
	lea	ecx, DWORD PTR _e$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 3278 : 	memcpy( n, data + 1 + 20 + sizeof( big::u32 ), sizeof( RSA_BIT_SIZE ) );

	push	32					; 00000020H
	mov	eax, DWORD PTR _data$[ebp]
	add	eax, 25					; 00000019H
	push	eax
	lea	ecx, DWORD PTR _n$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 3279 : #endif
; 3280 : 
; 3281 : 	// If we preset a size and it doesn't match, or the keys do not match, then tell the user
; 3282 : 	if ( usingSecurity == true && keysLocallyGenerated == false )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+2444]
	cmp	ecx, 1
	jne	$LN9@SecuredCon
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+2443]
	test	ecx, ecx
	jne	$LN9@SecuredCon

; 3283 : 	{
; 3284 : 		if ( memcmp( ( char* ) & e, ( char* ) & publicKeyE, sizeof( big::u32 ) ) != 0 ||
; 3285 : 			memcmp( n, publicKeyN, sizeof( RSA_BIT_SIZE ) ) != 0 )

	push	4
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2407				; 00000967H
	push	eax
	lea	ecx, DWORD PTR _e$[ebp]
	push	ecx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN7@SecuredCon
	push	32					; 00000020H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2411				; 0000096bH
	push	eax
	lea	ecx, DWORD PTR _n$[ebp]
	push	ecx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN9@SecuredCon
$LN7@SecuredCon:

; 3286 : 		{
; 3287 : 			packet=AllocPacket(1);

	push	1
	call	?AllocPacket@@YAPAUPacket@@I@Z		; AllocPacket
	add	esp, 4
	mov	DWORD PTR _packet$[ebp], eax

; 3288 : 			packet->data[ 0 ] = ID_RSA_PUBLIC_KEY_MISMATCH;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _packet$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	BYTE PTR [ecx+eax], 31			; 0000001fH

; 3289 : 			packet->bitSize = sizeof( char ) * 8;

	mov	eax, DWORD PTR _packet$[ebp]
	mov	DWORD PTR [eax+12], 8

; 3290 : 			packet->playerId = remoteSystem->playerId;

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _packet$[ebp]
	add	ecx, 2
	call	??4PlayerID@@QAEAAU0@ABU0@@Z		; PlayerID::operator=

; 3291 : 			packet->playerIndex = ( PlayerIndex ) GetIndexFromPlayerID( packet->playerId, true );

	push	1
	mov	eax, DWORD PTR _packet$[ebp]
	add	eax, 2
	sub	esp, 8
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	ax, WORD PTR [eax+4]
	mov	WORD PTR [ecx+4], ax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexFromPlayerID@RakPeer@@IAEHUPlayerID@@_N@Z ; RakPeer::GetIndexFromPlayerID
	mov	ecx, DWORD PTR _packet$[ebp]
	mov	WORD PTR [ecx], ax

; 3292 : 			AddPacketToProducer(packet);

	mov	eax, DWORD PTR _packet$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddPacketToProducer@RakPeer@@IAEXPAUPacket@@@Z ; RakPeer::AddPacketToProducer

; 3293 : 			remoteSystem->connectMode=RemoteSystemStruct::DISCONNECT_ASAP_SILENTLY;

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	mov	DWORD PTR [eax+2054], 2

; 3294 : 			return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _privKeyPncrypt$[ebp]
	call	??1?$RSACrypt@$$BY07I@big@@QAE@XZ	; big::RSACrypt<unsigned int [8]>::~RSACrypt<unsigned int [8]>
	jmp	$LN11@SecuredCon
$LN9@SecuredCon:

; 3295 : 		}
; 3296 : 	}
; 3297 : 
; 3298 : 	// Create a random number
; 3299 : 	for ( i = 0; i < (int) sizeof( randomNumber ); i += (int) sizeof( number ) )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@SecuredCon
$LN5@SecuredCon:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 4
	mov	DWORD PTR _i$[ebp], eax
$LN6@SecuredCon:
	cmp	DWORD PTR _i$[ebp], 20			; 00000014H
	jge	SHORT $LN4@SecuredCon

; 3300 : 	{
; 3301 : 		number = randomMT();

	call	?randomMT@@YAIXZ			; randomMT
	mov	DWORD PTR _number$[ebp], eax

; 3302 : 		memcpy( randomNumber + i, ( char* ) & number, sizeof( number ) );

	push	4
	lea	eax, DWORD PTR _number$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	lea	edx, DWORD PTR _randomNumber$[ebp+ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 3303 : 	}

	jmp	SHORT $LN5@SecuredCon
$LN4@SecuredCon:

; 3304 : 
; 3305 : 	memset( message, 0, sizeof( message ) );

	push	32					; 00000020H
	push	0
	lea	eax, DWORD PTR _message$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 3306 : 	assert( sizeof( message ) >= sizeof( randomNumber ) );
; 3307 : 
; 3308 : #ifdef HOST_ENDIAN_IS_BIG
; 3309 : 	// Scramble the plaintext message
; 3310 : 	BSWAPCPY( (unsigned char *)message, randomNumber, sizeof(randomNumber) );
; 3311 : #else
; 3312 : 	memcpy( message, randomNumber, sizeof( randomNumber ) );

	push	20					; 00000014H
	lea	eax, DWORD PTR _randomNumber$[ebp]
	push	eax
	lea	ecx, DWORD PTR _message$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 3313 : #endif
; 3314 : 	privKeyPncrypt.setPublicKey( e, n );

	lea	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _privKeyPncrypt$[ebp]
	call	?setPublicKey@?$RSACrypt@$$BY07I@big@@QAEXIAAY07I@Z ; big::RSACrypt<unsigned int [8]>::setPublicKey

; 3315 : 	privKeyPncrypt.encrypt( message, encryptedMessage );

	lea	eax, DWORD PTR _encryptedMessage$[ebp]
	push	eax
	lea	ecx, DWORD PTR _message$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _privKeyPncrypt$[ebp]
	call	?encrypt@?$RSACrypt@$$BY07I@big@@QAEXAAY07I0@Z ; big::RSACrypt<unsigned int [8]>::encrypt

; 3316 : #ifdef HOST_ENDIAN_IS_BIG
; 3317 : 	// A big-endian machine needs to scramble the byte order of an outgoing (encrypted) message
; 3318 : 	BSWAPSELF( (unsigned char *)encryptedMessage, sizeof( RSA_BIT_SIZE ) );
; 3319 : #endif
; 3320 : 
; 3321 : 	/*
; 3322 : 	rakPeerMutexes[ RakPeer::requestedConnections_MUTEX ].Lock();
; 3323 : 	for ( i = 0; i < ( int ) requestedConnectionsList.Size(); i++ )
; 3324 : 	{
; 3325 : 		if ( requestedConnectionsList[ i ]->playerId == playerId )
; 3326 : 		{
; 3327 : 			doSend = true;
; 3328 : 			// Generate the AES key
; 3329 : 
; 3330 : 			for ( j = 0; j < 16; j++ )
; 3331 : 				requestedConnectionsList[ i ]->AESKey[ j ] = data[ 1 + j ] ^ randomNumber[ j ];
; 3332 : 
; 3333 : 			requestedConnectionsList[ i ]->setAESKey = true;
; 3334 : 
; 3335 : 			break;
; 3336 : 		}
; 3337 : 	}
; 3338 : 	rakPeerMutexes[ RakPeer::requestedConnections_MUTEX ].Unlock();
; 3339 : 	*/
; 3340 : 
; 3341 : 	// Take the remote system's AESKey and XOR with our random number.
; 3342 : 		for ( j = 0; j < 16; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN3@SecuredCon
$LN2@SecuredCon:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN3@SecuredCon:
	cmp	DWORD PTR _j$[ebp], 16			; 00000010H
	jge	SHORT $LN1@SecuredCon

; 3343 : 			remoteSystem->AESKey[ j ] = data[ 1 + j ] ^ randomNumber[ j ];

	mov	eax, DWORD PTR _data$[ebp]
	add	eax, DWORD PTR _j$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	mov	edx, DWORD PTR _j$[ebp]
	movzx	eax, BYTE PTR _randomNumber$[ebp+edx]
	xor	ecx, eax
	mov	edx, DWORD PTR _remoteSystem$[ebp]
	add	edx, DWORD PTR _j$[ebp]
	mov	BYTE PTR [edx+2025], cl
	jmp	SHORT $LN2@SecuredCon
$LN1@SecuredCon:

; 3344 : 	remoteSystem->setAESKey = true;

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	mov	BYTE PTR [eax+2041], 1

; 3345 : 
; 3346 : //	if ( doSend )
; 3347 : //	{
; 3348 : 		char reply[ 1 + 20 + sizeof( RSA_BIT_SIZE ) ];
; 3349 : 		// c2s RSA(random number), same syn-cookie
; 3350 : 		reply[ 0 ] = ID_SECURED_CONNECTION_CONFIRMATION;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	BYTE PTR _reply$[ebp+ecx], 12		; 0000000cH

; 3351 : 		memcpy( reply + 1, data + 1, 20 );  // Copy the syn-cookie

	push	20					; 00000014H
	mov	eax, DWORD PTR _data$[ebp]
	add	eax, 1
	push	eax
	lea	ecx, DWORD PTR _reply$[ebp+1]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 3352 : 		memcpy( reply + 1 + 20, encryptedMessage, sizeof( RSA_BIT_SIZE ) ); // Copy the encoded random number

	push	32					; 00000020H
	lea	eax, DWORD PTR _encryptedMessage$[ebp]
	push	eax
	lea	ecx, DWORD PTR _reply$[ebp+21]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 3353 : 
; 3354 : 		//SocketLayer::Instance()->SendTo( connectionSocket, reply, 1 + 20 + sizeof( RSA_BIT_SIZE ), playerId.binaryAddress, playerId.port );
; 3355 : 		// All secure connection requests are unreliable because the entire process needs to be restarted if any part fails.
; 3356 : 		// Connection requests are resent periodically
; 3357 : 		SendImmediate((char*)reply, (1 + 20 + sizeof( RSA_BIT_SIZE )) * 8, SYSTEM_PRIORITY, UNRELIABLE, 0, remoteSystem->playerId, false, false, RakNet::GetTime());

	call	?GetTime@RakNet@@YAIXZ			; RakNet::GetTime
	xor	ecx, ecx
	push	ecx
	push	eax
	push	0
	push	0
	mov	edx, DWORD PTR _remoteSystem$[ebp]
	add	edx, 1
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR [edx+4]
	mov	WORD PTR [eax+4], dx
	push	0
	push	0
	push	0
	push	424					; 000001a8H
	lea	eax, DWORD PTR _reply$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendImmediate@RakPeer@@IAE_NPADHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N4_J@Z ; RakPeer::SendImmediate

; 3358 : //	}
; 3359 : 
; 3360 : #endif
; 3361 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _privKeyPncrypt$[ebp]
	call	??1?$RSACrypt@$$BY07I@big@@QAE@XZ	; big::RSACrypt<unsigned int [8]>::~RSACrypt<unsigned int [8]>
$LN11@SecuredCon:
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN24@SecuredCon
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 808				; 00000328H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN24@SecuredCon:
	DD	8
	DD	$LN23@SecuredCon
$LN23@SecuredCon:
	DD	-76					; ffffffb4H
	DD	20					; 00000014H
	DD	$LN14@SecuredCon
	DD	-88					; ffffffa8H
	DD	4
	DD	$LN15@SecuredCon
	DD	-112					; ffffff90H
	DD	4
	DD	$LN16@SecuredCon
	DD	-152					; ffffff68H
	DD	32					; 00000020H
	DD	$LN17@SecuredCon
	DD	-192					; ffffff40H
	DD	32					; 00000020H
	DD	$LN18@SecuredCon
	DD	-232					; ffffff18H
	DD	32					; 00000020H
	DD	$LN19@SecuredCon
	DD	-548					; fffffddcH
	DD	305					; 00000131H
	DD	$LN20@SecuredCon
	DD	-612					; fffffd9cH
	DD	53					; 00000035H
	DD	$LN21@SecuredCon
$LN21@SecuredCon:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	121					; 00000079H
	DB	0
$LN20@SecuredCon:
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	118					; 00000076H
	DB	75					; 0000004bH
	DB	101					; 00000065H
	DB	121					; 00000079H
	DB	80					; 00000050H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	114					; 00000072H
	DB	121					; 00000079H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	0
$LN19@SecuredCon:
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	114					; 00000072H
	DB	121					; 00000079H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	77					; 0000004dH
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	115					; 00000073H
	DB	97					; 00000061H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	0
$LN18@SecuredCon:
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	115					; 00000073H
	DB	97					; 00000061H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	0
$LN17@SecuredCon:
	DB	110					; 0000006eH
	DB	0
$LN16@SecuredCon:
	DB	101					; 00000065H
	DB	0
$LN15@SecuredCon:
	DB	110					; 0000006eH
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	98					; 00000062H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$LN14@SecuredCon:
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	111					; 0000006fH
	DB	109					; 0000006dH
	DB	78					; 0000004eH
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	98					; 00000062H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SecuredConnectionConfirmation@RakPeer@@IAEXPAURemoteSystemStruct@1@PAD@Z$0:
	lea	ecx, DWORD PTR _privKeyPncrypt$[ebp]
	jmp	??1?$RSACrypt@$$BY07I@big@@QAE@XZ	; big::RSACrypt<unsigned int [8]>::~RSACrypt<unsigned int [8]>
__ehhandler$?SecuredConnectionConfirmation@RakPeer@@IAEXPAURemoteSystemStruct@1@PAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-812]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SecuredConnectionConfirmation@RakPeer@@IAEXPAURemoteSystemStruct@1@PAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SecuredConnectionConfirmation@RakPeer@@IAEXPAURemoteSystemStruct@1@PAD@Z ENDP ; RakPeer::SecuredConnectionConfirmation
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?SecuredConnectionResponse@RakPeer@@IAEXUPlayerID@@@Z
_TEXT	SEGMENT
_connectionRequestResponse$ = -332			; size = 57
_e$ = -264						; size = 4
_n$ = -252						; size = 32
_sha1$ = -212						; size = 180
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_playerId$ = 8						; size = 6
?SecuredConnectionResponse@RakPeer@@IAEXUPlayerID@@@Z PROC ; RakPeer::SecuredConnectionResponse, COMDAT
; _this$ = ecx

; 3213 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SecuredConnectionResponse@RakPeer@@IAEXUPlayerID@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 516				; 00000204H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-528]
	mov	ecx, 129				; 00000081H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3214 : #if !defined(_COMPATIBILITY_1)
; 3215 : 	CSHA1 sha1;

	lea	ecx, DWORD PTR _sha1$[ebp]
	call	??0CSHA1@@QAE@XZ			; CSHA1::CSHA1
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3216 : 	RSA_BIT_SIZE n;
; 3217 : 	big::u32 e;
; 3218 : 	unsigned char connectionRequestResponse[ 1 + sizeof( big::u32 ) + sizeof( RSA_BIT_SIZE ) + 20 ];
; 3219 : 	connectionRequestResponse[ 0 ] = ID_SECURED_CONNECTION_RESPONSE;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	BYTE PTR _connectionRequestResponse$[ebp+ecx], 11 ; 0000000bH

; 3220 : 
; 3221 : 	if ( randomNumberExpirationTime < RakNet::GetTime() )

	call	?GetTime@RakNet@@YAIXZ			; RakNet::GetTime
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2445], eax
	jae	SHORT $LN1@SecuredCon

; 3222 : 		GenerateSYNCookieRandomNumber();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GenerateSYNCookieRandomNumber@RakPeer@@IAEXXZ ; RakPeer::GenerateSYNCookieRandomNumber
$LN1@SecuredCon:

; 3223 : 
; 3224 : 	// Hash the SYN-Cookie
; 3225 : 	// s2c syn-cookie = SHA1_HASH(source ip address + source port + random number)
; 3226 : 	sha1.Reset();

	lea	ecx, DWORD PTR _sha1$[ebp]
	call	?Reset@CSHA1@@QAEXXZ			; CSHA1::Reset

; 3227 : 	sha1.Update( ( unsigned char* ) & playerId.binaryAddress, sizeof( playerId.binaryAddress ) );

	push	4
	lea	eax, DWORD PTR _playerId$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sha1$[ebp]
	call	?Update@CSHA1@@QAEXPAEI@Z		; CSHA1::Update

; 3228 : 	sha1.Update( ( unsigned char* ) & playerId.port, sizeof( playerId.port ) );

	push	2
	lea	eax, DWORD PTR _playerId$[ebp+4]
	push	eax
	lea	ecx, DWORD PTR _sha1$[ebp]
	call	?Update@CSHA1@@QAEXPAEI@Z		; CSHA1::Update

; 3229 : 	sha1.Update( ( unsigned char* ) & ( newRandomNumber ), 20 );

	push	20					; 00000014H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2449				; 00000991H
	push	eax
	lea	ecx, DWORD PTR _sha1$[ebp]
	call	?Update@CSHA1@@QAEXPAEI@Z		; CSHA1::Update

; 3230 : 	sha1.Final();

	lea	ecx, DWORD PTR _sha1$[ebp]
	call	?Final@CSHA1@@QAEXXZ			; CSHA1::Final

; 3231 : 
; 3232 : 	// Write the cookie
; 3233 : 	memcpy( connectionRequestResponse + 1, sha1.GetHash(), 20 );

	push	20					; 00000014H
	lea	ecx, DWORD PTR _sha1$[ebp]
	call	?GetHash@CSHA1@@QBEPAEXZ		; CSHA1::GetHash
	push	eax
	lea	eax, DWORD PTR _connectionRequestResponse$[ebp+1]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 3234 : 
; 3235 : 	// Write the public keys
; 3236 : 	rsacrypt.getPublicKey( e, n );

	lea	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR _e$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2102				; 00000836H
	call	?getPublicKey@?$RSACrypt@$$BY07I@big@@QAEXAAIAAY07I@Z ; big::RSACrypt<unsigned int [8]>::getPublicKey

; 3237 : #ifdef HOST_ENDIAN_IS_BIG
; 3238 : 	// Mangle the keys on a Big-endian machine before sending
; 3239 : 	BSWAPCPY( (unsigned char *)(connectionRequestResponse + 1 + 20),
; 3240 : 		(unsigned char *)&e, sizeof( big::u32 ) );
; 3241 : 	BSWAPCPY( (unsigned char *)(connectionRequestResponse + 1 + 20 + sizeof( big::u32 ) ),
; 3242 : 		(unsigned char *)n, sizeof( RSA_BIT_SIZE ) );
; 3243 : #else
; 3244 : 	memcpy( connectionRequestResponse + 1 + 20, ( char* ) & e, sizeof( big::u32 ) );

	push	4
	lea	eax, DWORD PTR _e$[ebp]
	push	eax
	lea	ecx, DWORD PTR _connectionRequestResponse$[ebp+21]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 3245 : 	memcpy( connectionRequestResponse + 1 + 20 + sizeof( big::u32 ), n, sizeof( RSA_BIT_SIZE ) );

	push	32					; 00000020H
	lea	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR _connectionRequestResponse$[ebp+25]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 3246 : #endif
; 3247 : 
; 3248 : 	// s2c public key, syn-cookie
; 3249 : 	//SocketLayer::Instance()->SendTo( connectionSocket, ( char* ) connectionRequestResponse, 1 + sizeof( big::u32 ) + sizeof( RSA_BIT_SIZE ) + 20, playerId.binaryAddress, playerId.port );
; 3250 : 	// All secure connection requests are unreliable because the entire process needs to be restarted if any part fails.
; 3251 : 	// Connection requests are resent periodically
; 3252 : 	SendImmediate(( char* ) connectionRequestResponse, (1 + sizeof( big::u32 ) + sizeof( RSA_BIT_SIZE ) + 20) *8, SYSTEM_PRIORITY, UNRELIABLE, 0, playerId, false, false, RakNet::GetTime());

	call	?GetTime@RakNet@@YAIXZ			; RakNet::GetTime
	xor	ecx, ecx
	push	ecx
	push	eax
	push	0
	push	0
	sub	esp, 8
	mov	edx, esp
	mov	eax, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [edx], eax
	mov	cx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [edx+4], cx
	push	0
	push	0
	push	0
	push	456					; 000001c8H
	lea	edx, DWORD PTR _connectionRequestResponse$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendImmediate@RakPeer@@IAE_NPADHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N4_J@Z ; RakPeer::SendImmediate

; 3253 : #endif
; 3254 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sha1$[ebp]
	call	??1CSHA1@@UAE@XZ			; CSHA1::~CSHA1
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@SecuredCon
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 528				; 00000210H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN11@SecuredCon:
	DD	4
	DD	$LN10@SecuredCon
$LN10@SecuredCon:
	DD	-212					; ffffff2cH
	DD	180					; 000000b4H
	DD	$LN5@SecuredCon
	DD	-252					; ffffff04H
	DD	32					; 00000020H
	DD	$LN6@SecuredCon
	DD	-264					; fffffef8H
	DD	4
	DD	$LN7@SecuredCon
	DD	-332					; fffffeb4H
	DD	57					; 00000039H
	DD	$LN8@SecuredCon
$LN8@SecuredCon:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	82					; 00000052H
	DB	101					; 00000065H
	DB	113					; 00000071H
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	82					; 00000052H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	112					; 00000070H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	0
$LN7@SecuredCon:
	DB	101					; 00000065H
	DB	0
$LN6@SecuredCon:
	DB	110					; 0000006eH
	DB	0
$LN5@SecuredCon:
	DB	115					; 00000073H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	49					; 00000031H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SecuredConnectionResponse@RakPeer@@IAEXUPlayerID@@@Z$0:
	lea	ecx, DWORD PTR _sha1$[ebp]
	jmp	??1CSHA1@@UAE@XZ			; CSHA1::~CSHA1
__ehhandler$?SecuredConnectionResponse@RakPeer@@IAEXUPlayerID@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-532]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SecuredConnectionResponse@RakPeer@@IAEXUPlayerID@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SecuredConnectionResponse@RakPeer@@IAEXUPlayerID@@@Z ENDP ; RakPeer::SecuredConnectionResponse
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?GenerateSYNCookieRandomNumber@RakPeer@@IAEXXZ
_TEXT	SEGMENT
_i$ = -32						; size = 4
_number$ = -20						; size = 4
_this$ = -8						; size = 4
?GenerateSYNCookieRandomNumber@RakPeer@@IAEXXZ PROC	; RakPeer::GenerateSYNCookieRandomNumber, COMDAT
; _this$ = ecx

; 3195 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3196 : #if !defined(_COMPATIBILITY_1)
; 3197 : 	unsigned int number;
; 3198 : 	int i;
; 3199 : 	memcpy( oldRandomNumber, newRandomNumber, sizeof( newRandomNumber ) );

	push	20					; 00000014H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2449				; 00000991H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2469				; 000009a5H
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 3200 : 
; 3201 : 	for ( i = 0; i < (int) sizeof( newRandomNumber ); i += (int) sizeof( number ) )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@GenerateSY
$LN2@GenerateSY:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 4
	mov	DWORD PTR _i$[ebp], eax
$LN3@GenerateSY:
	cmp	DWORD PTR _i$[ebp], 20			; 00000014H
	jge	SHORT $LN1@GenerateSY

; 3202 : 	{
; 3203 : 		number = randomMT();

	call	?randomMT@@YAIXZ			; randomMT
	mov	DWORD PTR _number$[ebp], eax

; 3204 : 		memcpy( newRandomNumber + i, ( char* ) & number, sizeof( number ) );

	push	4
	lea	eax, DWORD PTR _number$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+2449]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 3205 : 	}

	jmp	SHORT $LN2@GenerateSY
$LN1@GenerateSY:

; 3206 : 
; 3207 : 	randomNumberExpirationTime = RakNet::GetTime() + SYN_COOKIE_OLD_RANDOM_NUMBER_DURATION;

	call	?GetTime@RakNet@@YAIXZ			; RakNet::GetTime
	add	eax, 5000				; 00001388H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2445], eax

; 3208 : #endif
; 3209 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@GenerateSY
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN8@GenerateSY:
	DD	1
	DD	$LN7@GenerateSY
$LN7@GenerateSY:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN6@GenerateSY
$LN6@GenerateSY:
	DB	110					; 0000006eH
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	98					; 00000062H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
?GenerateSYNCookieRandomNumber@RakPeer@@IAEXXZ ENDP	; RakPeer::GenerateSYNCookieRandomNumber
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\singleproducerconsumer.h
;	COMDAT ?Clear@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEXXZ
_TEXT	SEGMENT
tv79 = -248						; size = 4
tv78 = -244						; size = 4
$T1 = -236						; size = 4
_listSize$ = -32					; size = 4
_next$ = -20						; size = 4
_this$ = -8						; size = 4
?Clear@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEXXZ PROC ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::Clear, COMDAT
; _this$ = ecx

; 216  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 248				; 000000f8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-248]
	mov	ecx, 62					; 0000003eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 217  : 		// Shrink the list down to MINIMUM_LIST_SIZE elements
; 218  : 		volatile DataPlusPtr *next;
; 219  : 		writePointer=readPointer->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+279]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 220  : 
; 221  : 		int listSize=1;

	mov	DWORD PTR _listSize$[ebp], 1

; 222  : 		next=readPointer->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+279]
	mov	DWORD PTR _next$[ebp], edx
$LN4@Clear:

; 223  : 		while (next!=readPointer)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _next$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	je	SHORT $LN2@Clear

; 224  : 		{
; 225  : 			listSize++;

	mov	eax, DWORD PTR _listSize$[ebp]
	add	eax, 1
	mov	DWORD PTR _listSize$[ebp], eax

; 226  : 			next=next->next;

	mov	eax, DWORD PTR _next$[ebp]
	mov	ecx, DWORD PTR [eax+279]
	mov	DWORD PTR _next$[ebp], ecx

; 227  : 		}

	jmp	SHORT $LN4@Clear
$LN2@Clear:

; 228  : 
; 229  : 		while (listSize-- > MINIMUM_LIST_SIZE)

	mov	eax, DWORD PTR _listSize$[ebp]
	mov	DWORD PTR tv78[ebp], eax
	mov	ecx, DWORD PTR _listSize$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _listSize$[ebp], ecx
	cmp	DWORD PTR tv78[ebp], 8
	jle	SHORT $LN7@Clear
	mov	DWORD PTR tv79[ebp], 1
	jmp	SHORT $LN8@Clear
$LN7@Clear:
	mov	DWORD PTR tv79[ebp], 0
$LN8@Clear:
	cmp	DWORD PTR tv79[ebp], 0
	je	SHORT $LN1@Clear

; 230  : 		{
; 231  : 			next=writePointer->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+279]
	mov	DWORD PTR _next$[ebp], edx

; 232  : #ifdef _DEBUG
; 233  : 			assert(writePointer!=readPointer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN9@Clear
	push	233					; 000000e9H
	push	OFFSET ??_C@_1GC@EGJKEKIF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAs?$AAi?$AAn?$AAg?$AAl?$AAe?$AAp?$AAr@
	push	OFFSET ??_C@_1DE@FCOMCLAG@?$AAw?$AAr?$AAi?$AAt?$AAe?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$CB?$AA?$DN?$AAr?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN9@Clear:

; 234  : #endif
; 235  : 			delete (char*) writePointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 236  : 			writePointer=next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _next$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 237  : 		}

	jmp	$LN2@Clear
$LN1@Clear:

; 238  : 
; 239  : 		readPointer->next=writePointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+279], eax

; 240  : 		writePointer=readPointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+12], edx

; 241  : 		readAheadPointer=readPointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], edx

; 242  : 		writeAheadPointer=writePointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+4], edx

; 243  : 		readCount=writeCount=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 244  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 248				; 000000f8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEXXZ ENDP ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\singleproducerconsumer.h
;	COMDAT ?ReadUnlock@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?ReadUnlock@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEXXZ PROC ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::ReadUnlock, COMDAT
; _this$ = ecx

; 202  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 203  : #ifdef _DEBUG
; 204  : 		assert(readAheadPointer!=readPointer); // If hits, then called ReadUnlock before ReadLock

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN3@ReadUnlock
	push	204					; 000000ccH
	push	OFFSET ??_C@_1GC@EGJKEKIF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAs?$AAi?$AAn?$AAg?$AAl?$AAe?$AAp?$AAr@
	push	OFFSET ??_C@_1DM@HLMOCDPL@?$AAr?$AAe?$AAa?$AAd?$AAA?$AAh?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$CB?$AA?$DN?$AAr?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@ReadUnlock:

; 205  : 		assert(readPointer!=writePointer); // If hits, then called ReadUnlock when Read returns 0

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN4@ReadUnlock
	push	205					; 000000cdH
	push	OFFSET ??_C@_1GC@EGJKEKIF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAs?$AAi?$AAn?$AAg?$AAl?$AAe?$AAp?$AAr@
	push	OFFSET ??_C@_1DE@PPJJMKJI@?$AAr?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$CB?$AA?$DN?$AAw?$AAr?$AAi?$AAt?$AAe?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@ReadUnlock:

; 206  : #endif
; 207  : 		readCount++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 208  : 
; 209  : 		// Allow writes to this memory block
; 210  : 		readPointer->readyToRead=false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	BYTE PTR [ecx+278], 0

; 211  : 		readPointer=readPointer->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+279]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 212  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadUnlock@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEXXZ ENDP ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::ReadUnlock
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\singleproducerconsumer.h
;	COMDAT ?CancelReadLock@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEXPAURequestedConnectionStruct@RakPeer@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_cancelToLocation$ = 8					; size = 4
?CancelReadLock@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEXPAURequestedConnectionStruct@RakPeer@@@Z PROC ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::CancelReadLock, COMDAT
; _this$ = ecx

; 193  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 194  : #ifdef _DEBUG
; 195  : 		assert(readPointer!=writePointer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN3@CancelRead
	push	195					; 000000c3H
	push	OFFSET ??_C@_1GC@EGJKEKIF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAs?$AAi?$AAn?$AAg?$AAl?$AAe?$AAp?$AAr@
	push	OFFSET ??_C@_1DE@PPJJMKJI@?$AAr?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$CB?$AA?$DN?$AAw?$AAr?$AAi?$AAt?$AAe?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@CancelRead:

; 196  : #endif
; 197  : 		readAheadPointer=(DataPlusPtr *)cancelToLocation;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _cancelToLocation$[ebp]
	mov	DWORD PTR [eax], ecx

; 198  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?CancelReadLock@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEXPAURequestedConnectionStruct@RakPeer@@@Z ENDP ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::CancelReadLock
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\singleproducerconsumer.h
;	COMDAT ?ReadLock@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEPAURequestedConnectionStruct@RakPeer@@XZ
_TEXT	SEGMENT
_last$ = -20						; size = 4
_this$ = -8						; size = 4
?ReadLock@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEPAURequestedConnectionStruct@RakPeer@@XZ PROC ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::ReadLock, COMDAT
; _this$ = ecx

; 178  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 179  : 			if (readAheadPointer==writePointer ||
; 180  : 				readAheadPointer->readyToRead==false)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+12]
	je	SHORT $LN1@ReadLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx+278]
	test	edx, edx
	jne	SHORT $LN2@ReadLock
$LN1@ReadLock:

; 181  : 			{
; 182  : 				return 0;

	xor	eax, eax
	jmp	SHORT $LN3@ReadLock
$LN2@ReadLock:

; 183  : 			}
; 184  : 
; 185  : 			volatile DataPlusPtr *last;
; 186  : 			last=readAheadPointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _last$[ebp], ecx

; 187  : 			readAheadPointer=readAheadPointer->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+279]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], edx

; 188  : 			return (SingleProducerConsumerType*)last;

	mov	eax, DWORD PTR _last$[ebp]
$LN3@ReadLock:

; 189  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadLock@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEPAURequestedConnectionStruct@RakPeer@@XZ ENDP ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::ReadLock
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\singleproducerconsumer.h
;	COMDAT ?WriteUnlock@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?WriteUnlock@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEXXZ PROC ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::WriteUnlock, COMDAT
; _this$ = ecx

; 162  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 163  : 		//	DataPlusPtr *dataContainer = (DataPlusPtr *)structure;
; 164  : 
; 165  : #ifdef _DEBUG
; 166  : 		assert(writePointer->next!=readPointer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+279]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $LN3@WriteUnloc
	push	166					; 000000a6H
	push	OFFSET ??_C@_1GC@EGJKEKIF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAs?$AAi?$AAn?$AAg?$AAl?$AAe?$AAp?$AAr@
	push	OFFSET ??_C@_1EA@OAIJHOON@?$AAw?$AAr?$AAi?$AAt?$AAe?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AA?$CB?$AA?$DN?$AAr?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@WriteUnloc:

; 167  : 		assert(writePointer!=writeAheadPointer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@WriteUnloc
	push	167					; 000000a7H
	push	OFFSET ??_C@_1GC@EGJKEKIF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAs?$AAi?$AAn?$AAg?$AAl?$AAe?$AAp?$AAr@
	push	OFFSET ??_C@_1EA@LEKNHFBP@?$AAw?$AAr?$AAi?$AAt?$AAe?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$CB?$AA?$DN?$AAw?$AAr?$AAi?$AAt?$AAe?$AAA?$AAh?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@WriteUnloc:

; 168  : #endif
; 169  : 
; 170  : 		writeCount++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 171  : 		// User is done with the data, allow send by updating the write pointer
; 172  : 		writePointer->readyToRead=true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	BYTE PTR [ecx+278], 1

; 173  : 		writePointer=writePointer->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+279]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 174  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?WriteUnlock@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEXXZ ENDP ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::WriteUnlock
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\singleproducerconsumer.h
;	COMDAT ?WriteLock@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEPAURequestedConnectionStruct@RakPeer@@XZ
_TEXT	SEGMENT
$T1 = -236						; size = 4
_last$ = -32						; size = 4
_originalNext$2 = -20					; size = 4
_this$ = -8						; size = 4
?WriteLock@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEPAURequestedConnectionStruct@RakPeer@@XZ PROC ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::WriteLock, COMDAT
; _this$ = ecx

; 137  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 138  : 		if (writeAheadPointer->next==readPointer ||
; 139  : 			writeAheadPointer->next->readyToRead==true)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+279]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR [eax+8]
	je	SHORT $LN1@WriteLock
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+279]
	movzx	eax, BYTE PTR [edx+278]
	cmp	eax, 1
	jne	SHORT $LN2@WriteLock
$LN1@WriteLock:

; 140  : 		{
; 141  : 			volatile DataPlusPtr *originalNext=writeAheadPointer->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+279]
	mov	DWORD PTR _originalNext$2[ebp], edx

; 142  : 			writeAheadPointer->next=new DataPlusPtr;

	push	283					; 0000011bH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [ecx+279], edx

; 143  : 			assert(writeAheadPointer->next);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+279], 0
	jne	SHORT $LN5@WriteLock
	push	143					; 0000008fH
	push	OFFSET ??_C@_1GC@EGJKEKIF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAs?$AAi?$AAn?$AAg?$AAl?$AAe?$AAp?$AAr@
	push	OFFSET ??_C@_1DA@FABPCGM@?$AAw?$AAr?$AAi?$AAt?$AAe?$AAA?$AAh?$AAe?$AAa?$AAd?$AAP?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN5@WriteLock:

; 144  : 			writeAheadPointer->next->next=originalNext;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+279]
	mov	eax, DWORD PTR _originalNext$2[ebp]
	mov	DWORD PTR [edx+279], eax
$LN2@WriteLock:

; 145  : 		}
; 146  : 
; 147  : 		volatile DataPlusPtr *last;
; 148  : 		last=writeAheadPointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _last$[ebp], ecx

; 149  : 		writeAheadPointer=writeAheadPointer->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+279]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 150  : 
; 151  : 		return (SingleProducerConsumerType*) last;

	mov	eax, DWORD PTR _last$[ebp]

; 152  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?WriteLock@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEPAURequestedConnectionStruct@RakPeer@@XZ ENDP ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::WriteLock
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\singleproducerconsumer.h
;	COMDAT ??1?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T1 = -236						; size = 4
$T2 = -224						; size = 4
_next$ = -20						; size = 4
_this$ = -8						; size = 4
??1?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAE@XZ PROC ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::~SingleProducerConsumer<RakPeer::RequestedConnectionStruct>, COMDAT
; _this$ = ecx

; 123  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		volatile DataPlusPtr *next;
; 125  : 		readPointer=writeAheadPointer->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+279]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx
$LN2@SingleProd:

; 126  : 		while (readPointer!=writeAheadPointer)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+4]
	je	SHORT $LN1@SingleProd

; 127  : 		{
; 128  : 			next=readPointer->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+279]
	mov	DWORD PTR _next$[ebp], edx

; 129  : 			delete (char*) readPointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 130  : 			readPointer=next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _next$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 131  : 		}

	jmp	SHORT $LN2@SingleProd
$LN1@SingleProd:

; 132  : 		delete (char*) readPointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 133  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAE@XZ ENDP ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::~SingleProducerConsumer<RakPeer::RequestedConnectionStruct>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\singleproducerconsumer.h
;	COMDAT ??0?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T1 = -248						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_listSize$ = -20					; size = 4
_this$ = -8						; size = 4
??0?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAE@XZ PROC ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>, COMDAT
; _this$ = ecx

; 100  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 101  : 		// Preallocate
; 102  : 		readPointer = new DataPlusPtr;

	push	283					; 0000011bH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax+8], ecx

; 103  : 		writePointer=readPointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+12], edx

; 104  : 		readPointer->next = new DataPlusPtr;

	push	283					; 0000011bH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [ecx+279], edx

; 105  : 		int listSize;
; 106  : #ifdef _DEBUG
; 107  : 		assert(MINIMUM_LIST_SIZE>=3);
; 108  : #endif
; 109  : 		for (listSize=2; listSize < MINIMUM_LIST_SIZE; listSize++)

	mov	DWORD PTR _listSize$[ebp], 2
	jmp	SHORT $LN3@SingleProd
$LN2@SingleProd:
	mov	eax, DWORD PTR _listSize$[ebp]
	add	eax, 1
	mov	DWORD PTR _listSize$[ebp], eax
$LN3@SingleProd:
	cmp	DWORD PTR _listSize$[ebp], 8
	jge	SHORT $LN1@SingleProd

; 110  : 		{
; 111  : 			readPointer=readPointer->next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+279]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 112  : 			readPointer->next = new DataPlusPtr;

	push	283					; 0000011bH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR [ecx+279], edx

; 113  : 		}

	jmp	SHORT $LN2@SingleProd
$LN1@SingleProd:

; 114  : 		readPointer->next->next=writePointer; // last to next = start

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+279]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+279], ecx

; 115  : 		readPointer=writePointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+8], edx

; 116  : 		readAheadPointer=readPointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], edx

; 117  : 		writeAheadPointer=writePointer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+4], edx

; 118  : 		readCount=writeCount=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 119  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAE@XZ ENDP ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Size@?$List@PAVPluginInterface@@@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$List@PAVPluginInterface@@@DataStructures@@QBEIXZ PROC ; DataStructures::List<PluginInterface *>::Size, COMDAT
; _this$ = ecx

; 373  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 374  : 		return list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 375  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$List@PAVPluginInterface@@@DataStructures@@QBEIXZ ENDP ; DataStructures::List<PluginInterface *>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?GetIndexOf@?$List@PAVPluginInterface@@@DataStructures@@QAEIQAVPluginInterface@@@Z
_TEXT	SEGMENT
_i$1 = -20						; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
?GetIndexOf@?$List@PAVPluginInterface@@@DataStructures@@QAEIQAVPluginInterface@@@Z PROC ; DataStructures::List<PluginInterface *>::GetIndexOf, COMDAT
; _this$ = ecx

; 363  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 364  : 		for ( unsigned int i = 0; i < list_size; ++i )

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@GetIndexOf
$LN3@GetIndexOf:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@GetIndexOf:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN2@GetIndexOf

; 365  : 			if ( listArray[ i ] == input )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _input$[ebp]
	jne	SHORT $LN1@GetIndexOf

; 366  : 				return i;

	mov	eax, DWORD PTR _i$1[ebp]
	jmp	SHORT $LN5@GetIndexOf
$LN1@GetIndexOf:

; 367  : 
; 368  : 		return MAX_UNSIGNED_LONG;

	jmp	SHORT $LN3@GetIndexOf
$LN2@GetIndexOf:
	or	eax, -1
$LN5@GetIndexOf:

; 369  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetIndexOf@?$List@PAVPluginInterface@@@DataStructures@@QAEIQAVPluginInterface@@@Z ENDP ; DataStructures::List<PluginInterface *>::GetIndexOf
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Del@?$List@PAVPluginInterface@@@DataStructures@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_num$ = 8						; size = 4
?Del@?$List@PAVPluginInterface@@@DataStructures@@QAEXI@Z PROC ; DataStructures::List<PluginInterface *>::Del, COMDAT
; _this$ = ecx

; 353  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 354  : 		// Delete the last elements on the list.  No compression needed
; 355  : #ifdef _DEBUG
; 356  : 		assert(list_size>=num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _num$[ebp]
	jae	SHORT $LN3@Del
	push	356					; 00000164H
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1BO@JBFMBKMD@?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$DO?$AA?$DN?$AAn?$AAu?$AAm?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@Del:

; 357  : #endif
; 358  : 		list_size-=num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _num$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 359  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Del@?$List@PAVPluginInterface@@@DataStructures@@QAEXI@Z ENDP ; DataStructures::List<PluginInterface *>::Del
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Insert@?$List@PAVPluginInterface@@@DataStructures@@QAEXQAVPluginInterface@@@Z
_TEXT	SEGMENT
$T1 = -236						; size = 4
$T2 = -224						; size = 4
_new_array$3 = -20					; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
?Insert@?$List@PAVPluginInterface@@@DataStructures@@QAEXQAVPluginInterface@@@Z PROC ; DataStructures::List<PluginInterface *>::Insert, COMDAT
; _this$ = ecx

; 242  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 243  : 		// Reallocate list if necessary
; 244  : 
; 245  : 		if ( list_size == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	$LN3@Insert

; 246  : 		{
; 247  : 			// allocate twice the currently allocated memory
; 248  : 			list_type * new_array;
; 249  : 
; 250  : 			if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Insert

; 251  : 				allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 16			; 00000010H

; 252  : 			else

	jmp	SHORT $LN1@Insert
$LN2@Insert:

; 253  : 				allocation_size *= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN1@Insert:

; 254  : 
; 255  : 			new_array = new list_type [ allocation_size ];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _new_array$3[ebp], eax

; 256  : 
; 257  : 			// copy old array over
; 258  : 			//	for ( unsigned int counter = 0; counter < list_size; ++counter )
; 259  : 			//		new_array[ counter ] = listArray[ counter ];
; 260  : 
; 261  : 			// Don't call constructors, assignment operators, etc.
; 262  : 			memcpy(new_array, listArray, list_size*sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _new_array$3[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 263  : 
; 264  : 			// set old array to point to the newly allocated and twice as large array
; 265  : 			delete[] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 266  : 
; 267  : 			listArray = new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$3[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Insert:

; 268  : 		}
; 269  : 
; 270  : 		// Insert the new item at the correct spot
; 271  : 		listArray[ list_size ] = input;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _input$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 272  : 
; 273  : 		++list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 274  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Insert@?$List@PAVPluginInterface@@@DataStructures@@QAEXQAVPluginInterface@@@Z ENDP ; DataStructures::List<PluginInterface *>::Insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??A?$List@PAVPluginInterface@@@DataStructures@@QBEAAPAVPluginInterface@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
??A?$List@PAVPluginInterface@@@DataStructures@@QBEAAPAVPluginInterface@@I@Z PROC ; DataStructures::List<PluginInterface *>::operator[], COMDAT
; _this$ = ecx

; 185  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 186  : #ifdef _DEBUG
; 187  : 		assert ( position < list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN3@operator
	push	187					; 000000bbH
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@operator:

; 188  : #endif
; 189  : 		return listArray[ position ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _position$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 190  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@PAVPluginInterface@@@DataStructures@@QBEAAPAVPluginInterface@@I@Z ENDP ; DataStructures::List<PluginInterface *>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??1?$List@PAVPluginInterface@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
??1?$List@PAVPluginInterface@@@DataStructures@@QAE@XZ PROC ; DataStructures::List<PluginInterface *>::~List<PluginInterface *>, COMDAT
; _this$ = ecx

; 121  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 122  : 		if (allocation_size>0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jbe	SHORT $LN2@List

; 123  : 			delete [] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@List:

; 124  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@PAVPluginInterface@@@DataStructures@@QAE@XZ ENDP ; DataStructures::List<PluginInterface *>::~List<PluginInterface *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??0?$List@PAVPluginInterface@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$List@PAVPluginInterface@@@DataStructures@@QAE@XZ PROC ; DataStructures::List<PluginInterface *>::List<PluginInterface *>, COMDAT
; _this$ = ecx

; 113  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 114  : 		allocation_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 115  : 		listArray = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 116  : 		list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 117  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@PAVPluginInterface@@@DataStructures@@QAE@XZ ENDP ; DataStructures::List<PluginInterface *>::List<PluginInterface *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Clear@?$List@PAUBanStruct@RakPeer@@@DataStructures@@QAEX_N@Z
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
_doNotDeallocate$ = 8					; size = 1
?Clear@?$List@PAUBanStruct@RakPeer@@@DataStructures@@QAEX_N@Z PROC ; DataStructures::List<RakPeer::BanStruct *>::Clear, COMDAT
; _this$ = ecx

; 379  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  : 		if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Clear

; 381  : 			return;

	jmp	SHORT $LN3@Clear
$LN2@Clear:

; 382  : 
; 383  : 		if (allocation_size>512 && doNotDeallocate==false)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 512			; 00000200H
	jbe	SHORT $LN1@Clear
	movzx	eax, BYTE PTR _doNotDeallocate$[ebp]
	test	eax, eax
	jne	SHORT $LN1@Clear

; 384  : 		{
; 385  : 			delete [] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 386  : 			allocation_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 387  : 			listArray = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN1@Clear:

; 388  : 		}
; 389  : 		list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
$LN3@Clear:

; 390  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Clear@?$List@PAUBanStruct@RakPeer@@@DataStructures@@QAEX_N@Z ENDP ; DataStructures::List<RakPeer::BanStruct *>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Size@?$List@PAUBanStruct@RakPeer@@@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$List@PAUBanStruct@RakPeer@@@DataStructures@@QBEIXZ PROC ; DataStructures::List<RakPeer::BanStruct *>::Size, COMDAT
; _this$ = ecx

; 373  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 374  : 		return list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 375  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$List@PAUBanStruct@RakPeer@@@DataStructures@@QBEIXZ ENDP ; DataStructures::List<RakPeer::BanStruct *>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Del@?$List@PAUBanStruct@RakPeer@@@DataStructures@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_num$ = 8						; size = 4
?Del@?$List@PAUBanStruct@RakPeer@@@DataStructures@@QAEXI@Z PROC ; DataStructures::List<RakPeer::BanStruct *>::Del, COMDAT
; _this$ = ecx

; 353  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 354  : 		// Delete the last elements on the list.  No compression needed
; 355  : #ifdef _DEBUG
; 356  : 		assert(list_size>=num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _num$[ebp]
	jae	SHORT $LN3@Del
	push	356					; 00000164H
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1BO@JBFMBKMD@?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$DO?$AA?$DN?$AAn?$AAu?$AAm?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@Del:

; 357  : #endif
; 358  : 		list_size-=num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _num$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 359  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Del@?$List@PAUBanStruct@RakPeer@@@DataStructures@@QAEXI@Z ENDP ; DataStructures::List<RakPeer::BanStruct *>::Del
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?RemoveAtIndex@?$List@PAUBanStruct@RakPeer@@@DataStructures@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
?RemoveAtIndex@?$List@PAUBanStruct@RakPeer@@@DataStructures@@QAEXI@Z PROC ; DataStructures::List<RakPeer::BanStruct *>::RemoveAtIndex, COMDAT
; _this$ = ecx

; 333  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 334  : #ifdef _DEBUG
; 335  : 		assert( position < list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN4@RemoveAtIn
	push	335					; 0000014fH
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@RemoveAtIn:

; 336  : #endif
; 337  : 
; 338  : 		if ( position < list_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN2@RemoveAtIn

; 339  : 		{
; 340  : 			// Compress the array
; 341  : 			/*
; 342  : 			for ( unsigned int counter = position; counter < list_size - 1 ; ++counter )
; 343  : 			listArray[ counter ] = listArray[ counter + 1 ];
; 344  : 			*/
; 345  : 			memmove(listArray+position, listArray+position+1, (list_size-1-position) * sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	sub	ecx, DWORD PTR _position$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _position$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _position$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 346  : 
; 347  : 			Del();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Del@?$List@PAUBanStruct@RakPeer@@@DataStructures@@QAEXI@Z ; DataStructures::List<RakPeer::BanStruct *>::Del
$LN2@RemoveAtIn:

; 348  : 		}
; 349  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveAtIndex@?$List@PAUBanStruct@RakPeer@@@DataStructures@@QAEXI@Z ENDP ; DataStructures::List<RakPeer::BanStruct *>::RemoveAtIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Insert@?$List@PAUBanStruct@RakPeer@@@DataStructures@@QAEXQAUBanStruct@RakPeer@@@Z
_TEXT	SEGMENT
$T1 = -236						; size = 4
$T2 = -224						; size = 4
_new_array$3 = -20					; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 4
?Insert@?$List@PAUBanStruct@RakPeer@@@DataStructures@@QAEXQAUBanStruct@RakPeer@@@Z PROC ; DataStructures::List<RakPeer::BanStruct *>::Insert, COMDAT
; _this$ = ecx

; 242  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 243  : 		// Reallocate list if necessary
; 244  : 
; 245  : 		if ( list_size == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	$LN3@Insert

; 246  : 		{
; 247  : 			// allocate twice the currently allocated memory
; 248  : 			list_type * new_array;
; 249  : 
; 250  : 			if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Insert

; 251  : 				allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 16			; 00000010H

; 252  : 			else

	jmp	SHORT $LN1@Insert
$LN2@Insert:

; 253  : 				allocation_size *= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN1@Insert:

; 254  : 
; 255  : 			new_array = new list_type [ allocation_size ];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _new_array$3[ebp], eax

; 256  : 
; 257  : 			// copy old array over
; 258  : 			//	for ( unsigned int counter = 0; counter < list_size; ++counter )
; 259  : 			//		new_array[ counter ] = listArray[ counter ];
; 260  : 
; 261  : 			// Don't call constructors, assignment operators, etc.
; 262  : 			memcpy(new_array, listArray, list_size*sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _new_array$3[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 263  : 
; 264  : 			// set old array to point to the newly allocated and twice as large array
; 265  : 			delete[] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 266  : 
; 267  : 			listArray = new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$3[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Insert:

; 268  : 		}
; 269  : 
; 270  : 		// Insert the new item at the correct spot
; 271  : 		listArray[ list_size ] = input;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _input$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 272  : 
; 273  : 		++list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 274  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Insert@?$List@PAUBanStruct@RakPeer@@@DataStructures@@QAEXQAUBanStruct@RakPeer@@@Z ENDP ; DataStructures::List<RakPeer::BanStruct *>::Insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??A?$List@PAUBanStruct@RakPeer@@@DataStructures@@QBEAAPAUBanStruct@RakPeer@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
??A?$List@PAUBanStruct@RakPeer@@@DataStructures@@QBEAAPAUBanStruct@RakPeer@@I@Z PROC ; DataStructures::List<RakPeer::BanStruct *>::operator[], COMDAT
; _this$ = ecx

; 185  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 186  : #ifdef _DEBUG
; 187  : 		assert ( position < list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN3@operator
	push	187					; 000000bbH
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@operator:

; 188  : #endif
; 189  : 		return listArray[ position ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _position$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 190  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@PAUBanStruct@RakPeer@@@DataStructures@@QBEAAPAUBanStruct@RakPeer@@I@Z ENDP ; DataStructures::List<RakPeer::BanStruct *>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??1?$List@PAUBanStruct@RakPeer@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
??1?$List@PAUBanStruct@RakPeer@@@DataStructures@@QAE@XZ PROC ; DataStructures::List<RakPeer::BanStruct *>::~List<RakPeer::BanStruct *>, COMDAT
; _this$ = ecx

; 121  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 122  : 		if (allocation_size>0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jbe	SHORT $LN2@List

; 123  : 			delete [] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@List:

; 124  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@PAUBanStruct@RakPeer@@@DataStructures@@QAE@XZ ENDP ; DataStructures::List<RakPeer::BanStruct *>::~List<RakPeer::BanStruct *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??0?$List@PAUBanStruct@RakPeer@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$List@PAUBanStruct@RakPeer@@@DataStructures@@QAE@XZ PROC ; DataStructures::List<RakPeer::BanStruct *>::List<RakPeer::BanStruct *>, COMDAT
; _this$ = ecx

; 113  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 114  : 		allocation_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 115  : 		listArray = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 116  : 		list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 117  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@PAUBanStruct@RakPeer@@@DataStructures@@QAE@XZ ENDP ; DataStructures::List<RakPeer::BanStruct *>::List<RakPeer::BanStruct *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Clear@?$List@UPlayerIDAndIndex@@@DataStructures@@QAEX_N@Z
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
_doNotDeallocate$ = 8					; size = 1
?Clear@?$List@UPlayerIDAndIndex@@@DataStructures@@QAEX_N@Z PROC ; DataStructures::List<PlayerIDAndIndex>::Clear, COMDAT
; _this$ = ecx

; 379  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  : 		if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Clear

; 381  : 			return;

	jmp	SHORT $LN3@Clear
$LN2@Clear:

; 382  : 
; 383  : 		if (allocation_size>512 && doNotDeallocate==false)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 512			; 00000200H
	jbe	SHORT $LN1@Clear
	movzx	eax, BYTE PTR _doNotDeallocate$[ebp]
	test	eax, eax
	jne	SHORT $LN1@Clear

; 384  : 		{
; 385  : 			delete [] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 386  : 			allocation_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 387  : 			listArray = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN1@Clear:

; 388  : 		}
; 389  : 		list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
$LN3@Clear:

; 390  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Clear@?$List@UPlayerIDAndIndex@@@DataStructures@@QAEX_N@Z ENDP ; DataStructures::List<PlayerIDAndIndex>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Size@?$List@UPlayerIDAndIndex@@@DataStructures@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Size@?$List@UPlayerIDAndIndex@@@DataStructures@@QBEIXZ PROC ; DataStructures::List<PlayerIDAndIndex>::Size, COMDAT
; _this$ = ecx

; 373  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 374  : 		return list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 375  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Size@?$List@UPlayerIDAndIndex@@@DataStructures@@QBEIXZ ENDP ; DataStructures::List<PlayerIDAndIndex>::Size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Del@?$List@UPlayerIDAndIndex@@@DataStructures@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_num$ = 8						; size = 4
?Del@?$List@UPlayerIDAndIndex@@@DataStructures@@QAEXI@Z PROC ; DataStructures::List<PlayerIDAndIndex>::Del, COMDAT
; _this$ = ecx

; 353  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 354  : 		// Delete the last elements on the list.  No compression needed
; 355  : #ifdef _DEBUG
; 356  : 		assert(list_size>=num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _num$[ebp]
	jae	SHORT $LN3@Del
	push	356					; 00000164H
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1BO@JBFMBKMD@?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$DO?$AA?$DN?$AAn?$AAu?$AAm?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@Del:

; 357  : #endif
; 358  : 		list_size-=num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _num$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 359  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Del@?$List@UPlayerIDAndIndex@@@DataStructures@@QAEXI@Z ENDP ; DataStructures::List<PlayerIDAndIndex>::Del
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?RemoveAtIndex@?$List@UPlayerIDAndIndex@@@DataStructures@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
?RemoveAtIndex@?$List@UPlayerIDAndIndex@@@DataStructures@@QAEXI@Z PROC ; DataStructures::List<PlayerIDAndIndex>::RemoveAtIndex, COMDAT
; _this$ = ecx

; 333  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 334  : #ifdef _DEBUG
; 335  : 		assert( position < list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN4@RemoveAtIn
	push	335					; 0000014fH
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@RemoveAtIn:

; 336  : #endif
; 337  : 
; 338  : 		if ( position < list_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN2@RemoveAtIn

; 339  : 		{
; 340  : 			// Compress the array
; 341  : 			/*
; 342  : 			for ( unsigned int counter = position; counter < list_size - 1 ; ++counter )
; 343  : 			listArray[ counter ] = listArray[ counter + 1 ];
; 344  : 			*/
; 345  : 			memmove(listArray+position, listArray+position+1, (list_size-1-position) * sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	sub	ecx, DWORD PTR _position$[ebp]
	imul	edx, ecx, 10
	push	edx
	imul	eax, DWORD PTR _position$[ebp], 10
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax+10]
	push	eax
	imul	ecx, DWORD PTR _position$[ebp], 10
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	call	_memmove
	add	esp, 12					; 0000000cH

; 346  : 
; 347  : 			Del();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Del@?$List@UPlayerIDAndIndex@@@DataStructures@@QAEXI@Z ; DataStructures::List<PlayerIDAndIndex>::Del
$LN2@RemoveAtIn:

; 348  : 		}
; 349  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveAtIndex@?$List@UPlayerIDAndIndex@@@DataStructures@@QAEXI@Z ENDP ; DataStructures::List<PlayerIDAndIndex>::RemoveAtIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Insert@?$List@UPlayerIDAndIndex@@@DataStructures@@QAEXUPlayerIDAndIndex@@@Z
_TEXT	SEGMENT
$T1 = -236						; size = 4
$T2 = -224						; size = 4
_new_array$3 = -20					; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 10
?Insert@?$List@UPlayerIDAndIndex@@@DataStructures@@QAEXUPlayerIDAndIndex@@@Z PROC ; DataStructures::List<PlayerIDAndIndex>::Insert, COMDAT
; _this$ = ecx

; 242  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 243  : 		// Reallocate list if necessary
; 244  : 
; 245  : 		if ( list_size == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	$LN3@Insert

; 246  : 		{
; 247  : 			// allocate twice the currently allocated memory
; 248  : 			list_type * new_array;
; 249  : 
; 250  : 			if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Insert

; 251  : 				allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 16			; 00000010H

; 252  : 			else

	jmp	SHORT $LN1@Insert
$LN2@Insert:

; 253  : 				allocation_size *= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN1@Insert:

; 254  : 
; 255  : 			new_array = new list_type [ allocation_size ];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, 10					; 0000000aH
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _new_array$3[ebp], eax

; 256  : 
; 257  : 			// copy old array over
; 258  : 			//	for ( unsigned int counter = 0; counter < list_size; ++counter )
; 259  : 			//		new_array[ counter ] = listArray[ counter ];
; 260  : 
; 261  : 			// Don't call constructors, assignment operators, etc.
; 262  : 			memcpy(new_array, listArray, list_size*sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [eax+4], 10
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _new_array$3[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 263  : 
; 264  : 			// set old array to point to the newly allocated and twice as large array
; 265  : 			delete[] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 266  : 
; 267  : 			listArray = new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$3[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Insert:

; 268  : 		}
; 269  : 
; 270  : 		// Insert the new item at the correct spot
; 271  : 		listArray[ list_size ] = input;

	lea	eax, DWORD PTR _input$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [ecx+4], 10
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	call	??4PlayerIDAndIndex@@QAEAAU0@ABU0@@Z

; 272  : 
; 273  : 		++list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 274  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Insert@?$List@UPlayerIDAndIndex@@@DataStructures@@QAEXUPlayerIDAndIndex@@@Z ENDP ; DataStructures::List<PlayerIDAndIndex>::Insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ?Insert@?$List@UPlayerIDAndIndex@@@DataStructures@@QAEXUPlayerIDAndIndex@@I@Z
_TEXT	SEGMENT
$T1 = -236						; size = 4
$T2 = -224						; size = 4
_new_array$3 = -20					; size = 4
_this$ = -8						; size = 4
_input$ = 8						; size = 10
_position$ = 20						; size = 4
?Insert@?$List@UPlayerIDAndIndex@@@DataStructures@@QAEXUPlayerIDAndIndex@@I@Z PROC ; DataStructures::List<PlayerIDAndIndex>::Insert, COMDAT
; _this$ = ecx

; 194  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 195  : #ifdef _DEBUG
; 196  : 		assert( position <= list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jbe	SHORT $LN6@Insert
	push	196					; 000000c4H
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CM@FMCFHBCK@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN6@Insert:

; 197  : #endif
; 198  : 
; 199  : 		// Reallocate list if necessary
; 200  : 		if ( list_size == allocation_size )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	$LN3@Insert

; 201  : 		{
; 202  : 			// allocate twice the currently allocated memory
; 203  : 			list_type * new_array;
; 204  : 
; 205  : 			if ( allocation_size == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@Insert

; 206  : 				allocation_size = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 16			; 00000010H

; 207  : 			else

	jmp	SHORT $LN1@Insert
$LN2@Insert:

; 208  : 				allocation_size *= 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN1@Insert:

; 209  : 
; 210  : 			new_array = new list_type [ allocation_size ];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, 10					; 0000000aH
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _new_array$3[ebp], eax

; 211  : 
; 212  : 			// copy old array over
; 213  : 			//for ( unsigned int counter = 0; counter < list_size; ++counter )
; 214  : 			//	new_array[ counter ] = listArray[ counter ];
; 215  : 
; 216  : 			// Don't call constructors, assignment operators, etc.
; 217  : 			memcpy(new_array, listArray, list_size*sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [eax+4], 10
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _new_array$3[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 218  : 
; 219  : 			// set old array to point to the newly allocated and twice as large array
; 220  : 			delete[] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 221  : 
; 222  : 			listArray = new_array;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _new_array$3[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Insert:

; 223  : 		}
; 224  : 
; 225  : 		// Move the elements in the list to make room
; 226  : 		//for ( unsigned int counter = list_size; counter != position; counter-- )
; 227  : 		//	listArray[ counter ] = listArray[ counter - 1 ];
; 228  : 
; 229  : 		// Don't call constructors, assignment operators, etc.
; 230  : 		memmove(listArray+position+1, listArray+position, (list_size-position)*sizeof(list_type));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _position$[ebp]
	imul	edx, ecx, 10
	push	edx
	imul	eax, DWORD PTR _position$[ebp], 10
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	push	eax
	imul	edx, DWORD PTR _position$[ebp], 10
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+edx+10]
	push	edx
	call	_memmove
	add	esp, 12					; 0000000cH

; 231  : 
; 232  : 		// Insert the new item at the correct spot
; 233  : 		listArray[ position ] = input;

	lea	eax, DWORD PTR _input$[ebp]
	push	eax
	imul	ecx, DWORD PTR _position$[ebp], 10
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	call	??4PlayerIDAndIndex@@QAEAAU0@ABU0@@Z

; 234  : 
; 235  : 		++list_size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 236  : 
; 237  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Insert@?$List@UPlayerIDAndIndex@@@DataStructures@@QAEXUPlayerIDAndIndex@@I@Z ENDP ; DataStructures::List<PlayerIDAndIndex>::Insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??A?$List@UPlayerIDAndIndex@@@DataStructures@@QBEAAUPlayerIDAndIndex@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
??A?$List@UPlayerIDAndIndex@@@DataStructures@@QBEAAUPlayerIDAndIndex@@I@Z PROC ; DataStructures::List<PlayerIDAndIndex>::operator[], COMDAT
; _this$ = ecx

; 185  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 186  : #ifdef _DEBUG
; 187  : 		assert ( position < list_size );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _position$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN3@operator
	push	187					; 000000bbH
	push	OFFSET ??_C@_1EE@MBOIAKFO@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?4@
	push	OFFSET ??_C@_1CK@HINNGFPG@?$AAp?$AAo?$AAs?$AAi?$AAt?$AAi?$AAo?$AAn?$AA?5?$AA?$DM?$AA?5?$AAl?$AAi?$AAs?$AAt?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@operator:

; 188  : #endif
; 189  : 		return listArray[ position ];

	imul	eax, DWORD PTR _position$[ebp], 10
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]

; 190  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@UPlayerIDAndIndex@@@DataStructures@@QBEAAUPlayerIDAndIndex@@I@Z ENDP ; DataStructures::List<PlayerIDAndIndex>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??1?$List@UPlayerIDAndIndex@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
??1?$List@UPlayerIDAndIndex@@@DataStructures@@QAE@XZ PROC ; DataStructures::List<PlayerIDAndIndex>::~List<PlayerIDAndIndex>, COMDAT
; _this$ = ecx

; 121  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 122  : 		if (allocation_size>0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jbe	SHORT $LN2@List

; 123  : 			delete [] listArray;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@List:

; 124  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@UPlayerIDAndIndex@@@DataStructures@@QAE@XZ ENDP ; DataStructures::List<PlayerIDAndIndex>::~List<PlayerIDAndIndex>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_list.h
;	COMDAT ??0?$List@UPlayerIDAndIndex@@@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$List@UPlayerIDAndIndex@@@DataStructures@@QAE@XZ PROC ; DataStructures::List<PlayerIDAndIndex>::List<PlayerIDAndIndex>, COMDAT
; _this$ = ecx

; 113  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 114  : 		allocation_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 115  : 		listArray = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 116  : 		list_size = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 117  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@UPlayerIDAndIndex@@@DataStructures@@QAE@XZ ENDP ; DataStructures::List<PlayerIDAndIndex>::List<PlayerIDAndIndex>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?Clear@?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Clear@?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QAEXXZ PROC ; DataStructures::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>::Clear, COMDAT
; _this$ = ecx

; 219  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 220  : 		orderedList.Clear();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UPlayerIDAndIndex@@@DataStructures@@QAEX_N@Z ; DataStructures::List<PlayerIDAndIndex>::Clear

; 221  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QAEXXZ ENDP ; DataStructures::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ??A?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QBEAAUPlayerIDAndIndex@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_position$ = 8						; size = 4
??A?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QBEAAUPlayerIDAndIndex@@I@Z PROC ; DataStructures::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>::operator[], COMDAT
; _this$ = ecx

; 225  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 226  : 		return orderedList[position];

	mov	eax, DWORD PTR _position$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UPlayerIDAndIndex@@@DataStructures@@QBEAAUPlayerIDAndIndex@@I@Z ; DataStructures::List<PlayerIDAndIndex>::operator[]

; 227  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QBEAAUPlayerIDAndIndex@@I@Z ENDP ; DataStructures::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?Remove@?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QAEIABUPlayerID@@@Z
_TEXT	SEGMENT
_index$ = -32						; size = 4
_objectExists$ = -17					; size = 1
_this$ = -8						; size = 4
_key$ = 8						; size = 4
?Remove@?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QAEIABUPlayerID@@@Z PROC ; DataStructures::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>::Remove, COMDAT
; _this$ = ecx

; 179  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 180  : 		bool objectExists;
; 181  : 		unsigned index;
; 182  : 		index = GetIndexFromKey(key, &objectExists);

	lea	eax, DWORD PTR _objectExists$[ebp]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexFromKey@?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QBEIABUPlayerID@@PA_N@Z ; DataStructures::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>::GetIndexFromKey
	mov	DWORD PTR _index$[ebp], eax

; 183  : 
; 184  : 		// Can't find the element to remove if this assert hits
; 185  : 		assert(objectExists==true);

	movzx	eax, BYTE PTR _objectExists$[ebp]
	cmp	eax, 1
	je	SHORT $LN4@Remove
	push	185					; 000000b9H
	push	OFFSET ??_C@_1FC@PKHPOOLI@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAd?$AAs?$AA_?$AAo?$AAr?$AAd?$AAe?$AAr@
	push	OFFSET ??_C@_1CG@FNLJFNDG@?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAE?$AAx?$AAi?$AAs?$AAt?$AAs?$AA?$DN?$AA?$DN?$AAt?$AAr?$AAu?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@Remove:

; 186  : 		if (objectExists==false)

	movzx	eax, BYTE PTR _objectExists$[ebp]
	test	eax, eax
	jne	SHORT $LN1@Remove

; 187  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN2@Remove
$LN1@Remove:

; 188  : 
; 189  : 		orderedList.RemoveAtIndex(index);

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAtIndex@?$List@UPlayerIDAndIndex@@@DataStructures@@QAEXI@Z ; DataStructures::List<PlayerIDAndIndex>::RemoveAtIndex

; 190  : 		return index;

	mov	eax, DWORD PTR _index$[ebp]
$LN2@Remove:

; 191  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@Remove
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$LN7@Remove:
	DD	1
	DD	$LN6@Remove
$LN6@Remove:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN5@Remove
$LN5@Remove:
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
?Remove@?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QAEIABUPlayerID@@@Z ENDP ; DataStructures::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>::Remove
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?Insert@?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QAEIABUPlayerID@@ABUPlayerIDAndIndex@@@Z
_TEXT	SEGMENT
_index$ = -32						; size = 4
_objectExists$ = -17					; size = 1
_this$ = -8						; size = 4
_key$ = 8						; size = 4
_data$ = 12						; size = 4
?Insert@?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QAEIABUPlayerID@@ABUPlayerIDAndIndex@@@Z PROC ; DataStructures::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>::Insert, COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		bool objectExists;
; 158  : 		unsigned index;
; 159  : 		index = GetIndexFromKey(key, &objectExists);

	lea	eax, DWORD PTR _objectExists$[ebp]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexFromKey@?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QBEIABUPlayerID@@PA_N@Z ; DataStructures::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>::GetIndexFromKey
	mov	DWORD PTR _index$[ebp], eax

; 160  : 
; 161  : 		// Don't allow duplicate insertion.
; 162  : 		if (objectExists)

	movzx	eax, BYTE PTR _objectExists$[ebp]
	test	eax, eax
	je	SHORT $LN3@Insert

; 163  : 			return (unsigned)-1;

	or	eax, -1
	jmp	SHORT $LN4@Insert
$LN3@Insert:

; 164  : 
; 165  : 		if (index>=orderedList.Size())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@UPlayerIDAndIndex@@@DataStructures@@QBEIXZ ; DataStructures::List<PlayerIDAndIndex>::Size
	cmp	DWORD PTR _index$[ebp], eax
	jb	SHORT $LN2@Insert

; 166  : 		{
; 167  : 			orderedList.Insert(data);

	mov	eax, DWORD PTR _data$[ebp]
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	ax, WORD PTR [eax+8]
	mov	WORD PTR [ecx+8], ax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Insert@?$List@UPlayerIDAndIndex@@@DataStructures@@QAEXUPlayerIDAndIndex@@@Z ; DataStructures::List<PlayerIDAndIndex>::Insert

; 168  : 			return orderedList.Size()-1;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@UPlayerIDAndIndex@@@DataStructures@@QBEIXZ ; DataStructures::List<PlayerIDAndIndex>::Size
	sub	eax, 1
	jmp	SHORT $LN4@Insert

; 169  : 		}
; 170  : 		else

	jmp	SHORT $LN4@Insert
$LN2@Insert:

; 171  : 		{
; 172  : 			orderedList.Insert(data,index);

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	cx, WORD PTR [ecx+8]
	mov	WORD PTR [edx+8], cx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Insert@?$List@UPlayerIDAndIndex@@@DataStructures@@QAEXUPlayerIDAndIndex@@I@Z ; DataStructures::List<PlayerIDAndIndex>::Insert

; 173  : 			return index;

	mov	eax, DWORD PTR _index$[ebp]
$LN4@Insert:

; 174  : 		}		
; 175  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@Insert
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN8@Insert:
	DD	1
	DD	$LN7@Insert
$LN7@Insert:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN6@Insert
$LN6@Insert:
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
?Insert@?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QAEIABUPlayerID@@ABUPlayerIDAndIndex@@@Z ENDP ; DataStructures::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>::Insert
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ?GetIndexFromKey@?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QBEIABUPlayerID@@PA_N@Z
_TEXT	SEGMENT
_res$ = -56						; size = 4
_lowerBound$ = -44					; size = 4
_upperBound$ = -32					; size = 4
_index$ = -20						; size = 4
_this$ = -8						; size = 4
_key$ = 8						; size = 4
_objectExists$ = 12					; size = 4
?GetIndexFromKey@?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QBEIABUPlayerID@@PA_N@Z PROC ; DataStructures::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>::GetIndexFromKey, COMDAT
; _this$ = ecx

; 110  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 111  : 		int index, upperBound, lowerBound;
; 112  : 		int res;
; 113  : 
; 114  : 		if (orderedList.Size()==0)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@UPlayerIDAndIndex@@@DataStructures@@QBEIXZ ; DataStructures::List<PlayerIDAndIndex>::Size
	test	eax, eax
	jne	SHORT $LN8@GetIndexFr

; 115  : 		{
; 116  : 			*objectExists=false;

	mov	eax, DWORD PTR _objectExists$[ebp]
	mov	BYTE PTR [eax], 0

; 117  : 			return 0;

	xor	eax, eax
	jmp	$LN9@GetIndexFr
$LN8@GetIndexFr:

; 118  : 		}
; 119  : 
; 120  : 		upperBound=(int)orderedList.Size()-1;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@UPlayerIDAndIndex@@@DataStructures@@QBEIXZ ; DataStructures::List<PlayerIDAndIndex>::Size
	sub	eax, 1
	mov	DWORD PTR _upperBound$[ebp], eax

; 121  : 		lowerBound=0;

	mov	DWORD PTR _lowerBound$[ebp], 0

; 122  : 		index = (int)orderedList.Size()/2;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Size@?$List@UPlayerIDAndIndex@@@DataStructures@@QBEIXZ ; DataStructures::List<PlayerIDAndIndex>::Size
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _index$[ebp], eax
$LN7@GetIndexFr:

; 123  : 
; 124  : #ifdef _MSC_VER
; 125  : 	#pragma warning( disable : 4127 ) // warning C4127: conditional expression is constant
; 126  : #endif
; 127  : 		while (1)

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN9@GetIndexFr

; 128  : 		{
; 129  : 			res = comparison_function(key,orderedList[index]);

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UPlayerIDAndIndex@@@DataStructures@@QBEAAUPlayerIDAndIndex@@I@Z ; DataStructures::List<PlayerIDAndIndex>::operator[]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	call	?PlayerIDAndIndexComp@@YAHABUPlayerID@@ABUPlayerIDAndIndex@@@Z ; PlayerIDAndIndexComp
	add	esp, 8
	mov	DWORD PTR _res$[ebp], eax

; 130  : 			if (res==0)

	cmp	DWORD PTR _res$[ebp], 0
	jne	SHORT $LN5@GetIndexFr

; 131  : 			{
; 132  : 				*objectExists=true;

	mov	eax, DWORD PTR _objectExists$[ebp]
	mov	BYTE PTR [eax], 1

; 133  : 				return index;

	mov	eax, DWORD PTR _index$[ebp]
	jmp	SHORT $LN9@GetIndexFr
	jmp	SHORT $LN4@GetIndexFr
$LN5@GetIndexFr:

; 134  : 			}
; 135  : 			else if (res<0)

	cmp	DWORD PTR _res$[ebp], 0
	jge	SHORT $LN3@GetIndexFr

; 136  : 			{
; 137  : 				upperBound=index-1;

	mov	eax, DWORD PTR _index$[ebp]
	sub	eax, 1
	mov	DWORD PTR _upperBound$[ebp], eax

; 138  : 			}
; 139  : 			else// if (res>0)

	jmp	SHORT $LN4@GetIndexFr
$LN3@GetIndexFr:

; 140  : 			{
; 141  : 				lowerBound=index+1;

	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 1
	mov	DWORD PTR _lowerBound$[ebp], eax
$LN4@GetIndexFr:

; 142  : 			}
; 143  : 
; 144  : 			index=lowerBound+(upperBound-lowerBound)/2;

	mov	eax, DWORD PTR _upperBound$[ebp]
	sub	eax, DWORD PTR _lowerBound$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR _lowerBound$[ebp]
	mov	DWORD PTR _index$[ebp], eax

; 145  : 
; 146  : 			if (lowerBound>upperBound)

	mov	eax, DWORD PTR _lowerBound$[ebp]
	cmp	eax, DWORD PTR _upperBound$[ebp]
	jle	SHORT $LN1@GetIndexFr

; 147  : 			{
; 148  : 				*objectExists=false;

	mov	eax, DWORD PTR _objectExists$[ebp]
	mov	BYTE PTR [eax], 0

; 149  : 				return lowerBound; // No match

	mov	eax, DWORD PTR _lowerBound$[ebp]
	jmp	SHORT $LN9@GetIndexFr
$LN1@GetIndexFr:

; 150  : 			}
; 151  : 		}

	jmp	SHORT $LN7@GetIndexFr
$LN9@GetIndexFr:

; 152  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?GetIndexFromKey@?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QBEIABUPlayerID@@PA_N@Z ENDP ; DataStructures::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>::GetIndexFromKey
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ??1?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QAE@XZ PROC ; DataStructures::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>::~OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>, COMDAT
; _this$ = ecx

; 72   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 73   : 		Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QAEXXZ ; DataStructures::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>::Clear

; 74   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$List@UPlayerIDAndIndex@@@DataStructures@@QAE@XZ ; DataStructures::List<PlayerIDAndIndex>::~List<PlayerIDAndIndex>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$List@UPlayerIDAndIndex@@@DataStructures@@QAE@XZ ; DataStructures::List<PlayerIDAndIndex>::~List<PlayerIDAndIndex>
__ehhandler$??1?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QAE@XZ ENDP ; DataStructures::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>::~OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\ds_orderedlist.h
;	COMDAT ??0?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QAE@XZ PROC ; DataStructures::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>, COMDAT
; _this$ = ecx

; 67   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$List@UPlayerIDAndIndex@@@DataStructures@@QAE@XZ ; DataStructures::List<PlayerIDAndIndex>::List<PlayerIDAndIndex>

; 68   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QAE@XZ ENDP ; DataStructures::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?HandleRPCReplyPacket@RakPeer@@IAEXPBDHUPlayerID@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_data$ = 8						; size = 4
_length$ = 12						; size = 4
_playerId$ = 16						; size = 6
?HandleRPCReplyPacket@RakPeer@@IAEXPBDHUPlayerID@@@Z PROC ; RakPeer::HandleRPCReplyPacket, COMDAT
; _this$ = ecx

; 3160 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3161 : 	if (blockOnRPCReply)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+2085]
	test	ecx, ecx
	je	SHORT $LN5@HandleRPCR

; 3162 : 	{
; 3163 : 		if ((playerId==replyFromTargetPlayer && replyFromTargetBroadcast==false) ||
; 3164 : 			(playerId!=replyFromTargetPlayer && replyFromTargetBroadcast==true))

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2078				; 0000081eH
	push	eax
	lea	ecx, DWORD PTR _playerId$[ebp]
	call	??8PlayerID@@QBE_NABU0@@Z		; PlayerID::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@HandleRPCR
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+2084]
	test	ecx, ecx
	je	SHORT $LN2@HandleRPCR
$LN1@HandleRPCR:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2078				; 0000081eH
	push	eax
	lea	ecx, DWORD PTR _playerId$[ebp]
	call	??9PlayerID@@QBE_NABU0@@Z		; PlayerID::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@HandleRPCR
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+2084]
	cmp	ecx, 1
	jne	SHORT $LN5@HandleRPCR
$LN2@HandleRPCR:

; 3165 : 		{
; 3166 : 			replyFromTargetBS->Write(data+1, length-1);

	mov	eax, DWORD PTR _length$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+2074]
	call	?Write@BitStream@RakNet@@QAEXPBDH@Z	; RakNet::BitStream::Write

; 3167 : 			blockOnRPCReply=false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+2085], 0
$LN5@HandleRPCR:

; 3168 : 		}
; 3169 : 	}
; 3170 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?HandleRPCReplyPacket@RakPeer@@IAEXPBDHUPlayerID@@@Z ENDP ; RakPeer::HandleRPCReplyPacket
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?HandleRPCPacket@RakPeer@@IAE_NPBDHUPlayerID@@@Z
_TEXT	SEGMENT
tv347 = -1988						; size = 4
tv383 = -1984						; size = 4
$T2 = -1973						; size = 1
$T3 = -1961						; size = 1
$T4 = -1949						; size = 1
$T5 = -1937						; size = 1
$T6 = -1925						; size = 1
$T7 = -1913						; size = 1
$T8 = -1901						; size = 1
$T9 = -1889						; size = 1
$T10 = -1877						; size = 1
$T11 = -1865						; size = 1
$T12 = -1853						; size = 1
$T13 = -1841						; size = 1
$T14 = -1832						; size = 4
$T15 = -1817						; size = 1
$T16 = -1808						; size = 4
$T17 = -1793						; size = 1
__$AllocaPad$$ = -1592					; size = 4
_reply$18 = -1580					; size = 273
_object$19 = -1296					; size = 4
_usedAlloca$20 = -1281					; size = 1
_object$21 = -1272					; size = 4
_rpcMapBitStream$22 = -1260				; size = 273
_replyToSender$ = -976					; size = 273
_blockingCommand$ = -689				; size = 1
_networkID$ = -680					; size = 8
_rpcParms$ = -664					; size = 22
_node$ = -632						; size = 4
_rpcIndex$ = -617					; size = 1
_networkIDIsEncoded$ = -605				; size = 1
_nameIsEncoded$ = -593					; size = 1
_userData$ = -584					; size = 4
_uniqueIdentifier$ = -572				; size = 256
_incomingBitStream$ = -308				; size = 273
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_data$ = 8						; size = 4
_length$ = 12						; size = 4
_playerId$ = 16						; size = 6
?HandleRPCPacket@RakPeer@@IAE_NPBDHUPlayerID@@@Z PROC	; RakPeer::HandleRPCPacket, COMDAT
; _this$ = ecx

; 2914 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?HandleRPCPacket@RakPeer@@IAE_NPBDHUPlayerID@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1976				; 000007b8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-1988]
	mov	ecx, 494				; 000001eeH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$AllocaPad$$[ebp], 0

; 2915 : 	// RPC BitStream format is
; 2916 : 	// ID_RPC - unsigned char
; 2917 : 	// Unique identifier string length - unsigned char
; 2918 : 	// The unique ID  - string with each letter in upper case, subtracted by 'A' and written in 5 bits.
; 2919 : 	// Number of bits of the data (int)
; 2920 : 	// The data
; 2921 : 
; 2922 : 	RakNet::BitStream incomingBitStream( (unsigned char *) data, length, false );

	push	0
	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _incomingBitStream$[ebp]
	call	??0BitStream@RakNet@@QAE@PAEI_N@Z	; RakNet::BitStream::BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2923 : 	char uniqueIdentifier[ 256 ];
; 2924 : //	unsigned int bitLength;
; 2925 : 	unsigned char *userData;
; 2926 : 	//bool hasTimestamp;
; 2927 : 	bool nameIsEncoded, networkIDIsEncoded;
; 2928 : 	RPCIndex rpcIndex;
; 2929 : 	RPCNode *node;
; 2930 : 	RPCParameters rpcParms;
; 2931 : 	NetworkID networkID;
; 2932 : 	bool blockingCommand;
; 2933 : 	RakNet::BitStream replyToSender;

	lea	ecx, DWORD PTR _replyToSender$[ebp]
	call	??0BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::BitStream
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 2934 : 	rpcParms.replyToSender=&replyToSender;

	lea	eax, DWORD PTR _replyToSender$[ebp]
	mov	DWORD PTR _rpcParms$[ebp+18], eax

; 2935 : 
; 2936 : 	rpcParms.recipient=this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR _rpcParms$[ebp+14], eax

; 2937 : 	rpcParms.sender=playerId;

	lea	eax, DWORD PTR _playerId$[ebp]
	push	eax
	lea	ecx, DWORD PTR _rpcParms$[ebp+8]
	call	??4PlayerID@@QAEAAU0@ABU0@@Z		; PlayerID::operator=

; 2938 : 
; 2939 : 	// Note to self - if I change this format then I have to change the PacketLogger class too
; 2940 : 	incomingBitStream.IgnoreBits(8);

	push	8
	lea	ecx, DWORD PTR _incomingBitStream$[ebp]
	call	?IgnoreBits@BitStream@RakNet@@QAEXH@Z	; RakNet::BitStream::IgnoreBits

; 2941 : 	if (data[0]==ID_TIMESTAMP)

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _data$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 36					; 00000024H
	jne	SHORT $LN30@HandleRPCP

; 2942 : 		incomingBitStream.IgnoreBits(8*(sizeof(RakNetTime)+sizeof(unsigned char)));

	push	40					; 00000028H
	lea	ecx, DWORD PTR _incomingBitStream$[ebp]
	call	?IgnoreBits@BitStream@RakNet@@QAEXH@Z	; RakNet::BitStream::IgnoreBits
$LN30@HandleRPCP:

; 2943 : 	if ( incomingBitStream.Read( nameIsEncoded ) == false )

	lea	eax, DWORD PTR _nameIsEncoded$[ebp]
	push	eax
	lea	ecx, DWORD PTR _incomingBitStream$[ebp]
	call	??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z ; RakNet::BitStream::Read<bool>
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN29@HandleRPCP

; 2944 : 	{
; 2945 : #ifdef _DEBUG
; 2946 : 		assert( 0 ); // bitstream was not long enough.  Some kind of internal error

	xor	eax, eax
	jne	SHORT $LN33@HandleRPCP
	mov	ecx, DWORD PTR ?__LINE__Var@?1??HandleRPCPacket@RakPeer@@IAE_NPBDHUPlayerID@@@Z@4JA
	add	ecx, 32					; 00000020H
	push	ecx
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_13COJANIEC@?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN33@HandleRPCP:

; 2947 : #endif
; 2948 : 		return false;

	mov	BYTE PTR $T2[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _replyToSender$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _incomingBitStream$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	al, BYTE PTR $T2[ebp]
	jmp	$LN31@HandleRPCP
$LN29@HandleRPCP:

; 2949 : 	}
; 2950 : 
; 2951 : 	if (nameIsEncoded)

	movzx	eax, BYTE PTR _nameIsEncoded$[ebp]
	test	eax, eax
	je	$LN28@HandleRPCP

; 2952 : 	{
; 2953 : 		if ( stringCompressor->DecodeString(uniqueIdentifier, 256, &incomingBitStream) == false )

	push	0
	lea	eax, DWORD PTR _incomingBitStream$[ebp]
	push	eax
	push	256					; 00000100H
	lea	ecx, DWORD PTR _uniqueIdentifier$[ebp]
	push	ecx
	call	?Instance@StringCompressor@@SAPAV1@XZ	; StringCompressor::Instance
	mov	ecx, eax
	call	?DecodeString@StringCompressor@@QAE_NPADHPAVBitStream@RakNet@@H@Z ; StringCompressor::DecodeString
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN27@HandleRPCP

; 2954 : 		{
; 2955 : #ifdef _DEBUG
; 2956 : 			assert( 0 ); // bitstream was not long enough.  Some kind of internal error

	xor	eax, eax
	jne	SHORT $LN34@HandleRPCP
	mov	ecx, DWORD PTR ?__LINE__Var@?1??HandleRPCPacket@RakPeer@@IAE_NPBDHUPlayerID@@@Z@4JA
	add	ecx, 42					; 0000002aH
	push	ecx
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_13COJANIEC@?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN34@HandleRPCP:

; 2957 : #endif
; 2958 : 			return false;

	mov	BYTE PTR $T3[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _replyToSender$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _incomingBitStream$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	al, BYTE PTR $T3[ebp]
	jmp	$LN31@HandleRPCP
$LN27@HandleRPCP:

; 2959 : 		}
; 2960 : 
; 2961 : 		rpcIndex = rpcMap.GetIndexFromFunctionName(uniqueIdentifier);

	lea	eax, DWORD PTR _uniqueIdentifier$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2049				; 00000801H
	call	?GetIndexFromFunctionName@RPCMap@@QAEEPAD@Z ; RPCMap::GetIndexFromFunctionName
	mov	BYTE PTR _rpcIndex$[ebp], al

; 2962 : 	}
; 2963 : 	else

	jmp	SHORT $LN26@HandleRPCP
$LN28@HandleRPCP:

; 2964 : 	{
; 2965 : 		if ( incomingBitStream.ReadCompressed( rpcIndex ) == false )

	lea	eax, DWORD PTR _rpcIndex$[ebp]
	push	eax
	lea	ecx, DWORD PTR _incomingBitStream$[ebp]
	call	??$ReadCompressed@E@BitStream@RakNet@@QAE_NAAE@Z ; RakNet::BitStream::ReadCompressed<unsigned char>
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN26@HandleRPCP

; 2966 : 		{
; 2967 : #ifdef _DEBUG
; 2968 : 			assert( 0 ); // bitstream was not long enough.  Some kind of internal error

	xor	eax, eax
	jne	SHORT $LN35@HandleRPCP
	mov	ecx, DWORD PTR ?__LINE__Var@?1??HandleRPCPacket@RakPeer@@IAE_NPBDHUPlayerID@@@Z@4JA
	add	ecx, 54					; 00000036H
	push	ecx
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_13COJANIEC@?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN35@HandleRPCP:

; 2969 : #endif
; 2970 : 			return false;

	mov	BYTE PTR $T4[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _replyToSender$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _incomingBitStream$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	al, BYTE PTR $T4[ebp]
	jmp	$LN31@HandleRPCP
$LN26@HandleRPCP:

; 2971 : 		}
; 2972 : 	}
; 2973 : 	if ( incomingBitStream.Read( blockingCommand ) == false )

	lea	eax, DWORD PTR _blockingCommand$[ebp]
	push	eax
	lea	ecx, DWORD PTR _incomingBitStream$[ebp]
	call	??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z ; RakNet::BitStream::Read<bool>
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN24@HandleRPCP

; 2974 : 	{
; 2975 : #ifdef _DEBUG
; 2976 : 		assert( 0 ); // bitstream was not long enough.  Some kind of internal error

	xor	eax, eax
	jne	SHORT $LN36@HandleRPCP
	mov	ecx, DWORD PTR ?__LINE__Var@?1??HandleRPCPacket@RakPeer@@IAE_NPBDHUPlayerID@@@Z@4JA
	add	ecx, 62					; 0000003eH
	push	ecx
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_13COJANIEC@?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN36@HandleRPCP:

; 2977 : #endif
; 2978 : 		return false;

	mov	BYTE PTR $T5[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _replyToSender$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _incomingBitStream$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	al, BYTE PTR $T5[ebp]
	jmp	$LN31@HandleRPCP
$LN24@HandleRPCP:

; 2979 : 	}
; 2980 : 
; 2981 : 	/*
; 2982 : 	if ( incomingBitStream.Read( rpcParms.hasTimestamp ) == false )
; 2983 : 	{
; 2984 : #ifdef _DEBUG
; 2985 : 		assert( 0 ); // bitstream was not long enough.  Some kind of internal error
; 2986 : #endif
; 2987 : 		return false;
; 2988 : 	}
; 2989 : 	*/
; 2990 : 
; 2991 : 	if ( incomingBitStream.ReadCompressed( rpcParms.numberOfBitsOfData ) == false )

	lea	eax, DWORD PTR _rpcParms$[ebp+4]
	push	eax
	lea	ecx, DWORD PTR _incomingBitStream$[ebp]
	call	??$ReadCompressed@I@BitStream@RakNet@@QAE_NAAI@Z ; RakNet::BitStream::ReadCompressed<unsigned int>
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN23@HandleRPCP

; 2992 : 	{
; 2993 : #ifdef _DEBUG
; 2994 : 		assert( 0 ); // bitstream was not long enough.  Some kind of internal error

	xor	eax, eax
	jne	SHORT $LN37@HandleRPCP
	mov	ecx, DWORD PTR ?__LINE__Var@?1??HandleRPCPacket@RakPeer@@IAE_NPBDHUPlayerID@@@Z@4JA
	add	ecx, 80					; 00000050H
	push	ecx
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_13COJANIEC@?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN37@HandleRPCP:

; 2995 : #endif
; 2996 : 		return false;

	mov	BYTE PTR $T6[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _replyToSender$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _incomingBitStream$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	al, BYTE PTR $T6[ebp]
	jmp	$LN31@HandleRPCP
$LN23@HandleRPCP:

; 2997 : 	}
; 2998 : 
; 2999 : 	if ( incomingBitStream.Read( networkIDIsEncoded ) == false )

	lea	eax, DWORD PTR _networkIDIsEncoded$[ebp]
	push	eax
	lea	ecx, DWORD PTR _incomingBitStream$[ebp]
	call	??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z ; RakNet::BitStream::Read<bool>
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN22@HandleRPCP

; 3000 : 	{
; 3001 : #ifdef _DEBUG
; 3002 : 		assert( 0 ); // bitstream was not long enough.  Some kind of internal error

	xor	eax, eax
	jne	SHORT $LN38@HandleRPCP
	mov	ecx, DWORD PTR ?__LINE__Var@?1??HandleRPCPacket@RakPeer@@IAE_NPBDHUPlayerID@@@Z@4JA
	add	ecx, 88					; 00000058H
	push	ecx
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_13COJANIEC@?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN38@HandleRPCP:

; 3003 : #endif
; 3004 : 		return false;

	mov	BYTE PTR $T7[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _replyToSender$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _incomingBitStream$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	al, BYTE PTR $T7[ebp]
	jmp	$LN31@HandleRPCP
$LN22@HandleRPCP:

; 3005 : 	}
; 3006 : 
; 3007 : 	if (networkIDIsEncoded)

	movzx	eax, BYTE PTR _networkIDIsEncoded$[ebp]
	test	eax, eax
	je	SHORT $LN21@HandleRPCP

; 3008 : 	{
; 3009 : 		if ( incomingBitStream.Read( networkID ) == false )

	lea	eax, DWORD PTR _networkID$[ebp]
	push	eax
	lea	ecx, DWORD PTR _incomingBitStream$[ebp]
	call	??$Read@UNetworkID@@@BitStream@RakNet@@QAE_NAAUNetworkID@@@Z ; RakNet::BitStream::Read<NetworkID>
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN21@HandleRPCP

; 3010 : 		{
; 3011 : #ifdef _DEBUG
; 3012 : 			assert( 0 ); // bitstream was not long enough.  Some kind of internal error

	xor	eax, eax
	jne	SHORT $LN39@HandleRPCP
	mov	ecx, DWORD PTR ?__LINE__Var@?1??HandleRPCPacket@RakPeer@@IAE_NPBDHUPlayerID@@@Z@4JA
	add	ecx, 98					; 00000062H
	push	ecx
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_13COJANIEC@?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN39@HandleRPCP:

; 3013 : #endif
; 3014 : 			return false;

	mov	BYTE PTR $T8[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _replyToSender$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _incomingBitStream$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	al, BYTE PTR $T8[ebp]
	jmp	$LN31@HandleRPCP
$LN21@HandleRPCP:

; 3015 : 		}
; 3016 : 	}
; 3017 : 
; 3018 : 	if (rpcIndex==UNDEFINED_RPC_INDEX)

	movzx	eax, BYTE PTR _rpcIndex$[ebp]
	cmp	eax, 255				; 000000ffH
	jne	SHORT $LN19@HandleRPCP

; 3019 : 	{
; 3020 : 		// Unregistered function
; 3021 : 		RakAssert(0);

	xor	eax, eax
	jne	SHORT $LN40@HandleRPCP
	mov	ecx, DWORD PTR ?__LINE__Var@?1??HandleRPCPacket@RakPeer@@IAE_NPBDHUPlayerID@@@Z@4JA
	add	ecx, 107				; 0000006bH
	push	ecx
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_13COJANIEC@?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN40@HandleRPCP:

; 3022 : 		return false;

	mov	BYTE PTR $T9[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _replyToSender$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _incomingBitStream$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	al, BYTE PTR $T9[ebp]
	jmp	$LN31@HandleRPCP
$LN19@HandleRPCP:

; 3023 : 	}
; 3024 : 
; 3025 : 	node = rpcMap.GetNodeFromIndex(rpcIndex);

	movzx	eax, BYTE PTR _rpcIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2049				; 00000801H
	call	?GetNodeFromIndex@RPCMap@@QAEPAURPCNode@@E@Z ; RPCMap::GetNodeFromIndex
	mov	DWORD PTR _node$[ebp], eax

; 3026 : 	if (node==0)

	cmp	DWORD PTR _node$[ebp], 0
	jne	SHORT $LN18@HandleRPCP

; 3027 : 	{
; 3028 : #ifdef _DEBUG
; 3029 : 		assert( 0 ); // Should never happen except perhaps from threading errors?  No harm in checking anyway

	xor	eax, eax
	jne	SHORT $LN41@HandleRPCP
	mov	ecx, DWORD PTR ?__LINE__Var@?1??HandleRPCPacket@RakPeer@@IAE_NPBDHUPlayerID@@@Z@4JA
	add	ecx, 115				; 00000073H
	push	ecx
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_13COJANIEC@?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN41@HandleRPCP:

; 3030 : #endif
; 3031 : 		return false;

	mov	BYTE PTR $T10[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _replyToSender$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _incomingBitStream$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	al, BYTE PTR $T10[ebp]
	jmp	$LN31@HandleRPCP
$LN18@HandleRPCP:

; 3032 : 	}
; 3033 : 
; 3034 : 	// Make sure the call type matches - if this is a pointer to a class member then networkID must be defined.  Otherwise it must not be defined
; 3035 : 	if (node->isPointerToMember==true && networkIDIsEncoded==false)

	mov	eax, DWORD PTR _node$[ebp]
	movzx	ecx, BYTE PTR [eax+8]
	cmp	ecx, 1
	jne	SHORT $LN17@HandleRPCP
	movzx	eax, BYTE PTR _networkIDIsEncoded$[ebp]
	test	eax, eax
	jne	SHORT $LN17@HandleRPCP

; 3036 : 	{
; 3037 : 		// If this hits then this pointer was registered as a class member function but the packet does not have an NetworkID.
; 3038 : 		// Most likely this means this system registered a function with REGISTER_CLASS_MEMBER_RPC and the remote system called it
; 3039 : 		// using the unique ID for a function registered with REGISTER_STATIC_RPC.
; 3040 : 		assert(0);

	xor	eax, eax
	jne	SHORT $LN42@HandleRPCP
	mov	ecx, DWORD PTR ?__LINE__Var@?1??HandleRPCPacket@RakPeer@@IAE_NPBDHUPlayerID@@@Z@4JA
	add	ecx, 126				; 0000007eH
	push	ecx
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_13COJANIEC@?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN42@HandleRPCP:

; 3041 : 		return false;

	mov	BYTE PTR $T11[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _replyToSender$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _incomingBitStream$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	al, BYTE PTR $T11[ebp]
	jmp	$LN31@HandleRPCP
$LN17@HandleRPCP:

; 3042 : 	}
; 3043 : 
; 3044 : 	if (node->isPointerToMember==false && networkIDIsEncoded==true)

	mov	eax, DWORD PTR _node$[ebp]
	movzx	ecx, BYTE PTR [eax+8]
	test	ecx, ecx
	jne	SHORT $LN16@HandleRPCP
	movzx	eax, BYTE PTR _networkIDIsEncoded$[ebp]
	cmp	eax, 1
	jne	SHORT $LN16@HandleRPCP

; 3045 : 	{
; 3046 : 		// If this hits then this pointer was not registered as a class member function but the packet does have an NetworkID.
; 3047 : 		// Most likely this means this system registered a function with REGISTER_STATIC_RPC and the remote system called it
; 3048 : 		// using the unique ID for a function registered with REGISTER_CLASS_MEMBER_RPC.
; 3049 : 		assert(0);

	xor	eax, eax
	jne	SHORT $LN43@HandleRPCP
	mov	ecx, DWORD PTR ?__LINE__Var@?1??HandleRPCPacket@RakPeer@@IAE_NPBDHUPlayerID@@@Z@4JA
	add	ecx, 135				; 00000087H
	push	ecx
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_13COJANIEC@?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN43@HandleRPCP:

; 3050 : 		return false;

	mov	BYTE PTR $T12[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _replyToSender$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _incomingBitStream$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	al, BYTE PTR $T12[ebp]
	jmp	$LN31@HandleRPCP
$LN16@HandleRPCP:

; 3051 : 	}
; 3052 : 
; 3053 : 	if (nameIsEncoded && GetRemoteSystemFromPlayerID(playerId, false, true))

	movzx	eax, BYTE PTR _nameIsEncoded$[ebp]
	test	eax, eax
	je	$LN15@HandleRPCP
	push	1
	push	0
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRemoteSystemFromPlayerID@RakPeer@@IBEPAURemoteSystemStruct@1@UPlayerID@@_N1@Z ; RakPeer::GetRemoteSystemFromPlayerID
	test	eax, eax
	je	$LN15@HandleRPCP

; 3054 : 	{
; 3055 : 		// Send ID_RPC_MAPPING to the sender so they know what index to use next time
; 3056 : 		RakNet::BitStream rpcMapBitStream;

	lea	ecx, DWORD PTR _rpcMapBitStream$22[ebp]
	call	??0BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::BitStream
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 3057 : 		rpcMapBitStream.Write((unsigned char)ID_RPC_MAPPING);

	push	13					; 0000000dH
	lea	ecx, DWORD PTR _rpcMapBitStream$22[ebp]
	call	??$Write@E@BitStream@RakNet@@QAEXE@Z	; RakNet::BitStream::Write<unsigned char>

; 3058 : 		stringCompressor->EncodeString(node->uniqueIdentifier, 256, &rpcMapBitStream);

	push	0
	lea	eax, DWORD PTR _rpcMapBitStream$22[ebp]
	push	eax
	push	256					; 00000100H
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?Instance@StringCompressor@@SAPAV1@XZ	; StringCompressor::Instance
	mov	ecx, eax
	call	?EncodeString@StringCompressor@@QAEXPBDHPAVBitStream@RakNet@@H@Z ; StringCompressor::EncodeString

; 3059 :         rpcMapBitStream.WriteCompressed(rpcIndex);

	movzx	eax, BYTE PTR _rpcIndex$[ebp]
	push	eax
	lea	ecx, DWORD PTR _rpcMapBitStream$22[ebp]
	call	??$WriteCompressed@E@BitStream@RakNet@@QAEXE@Z ; RakNet::BitStream::WriteCompressed<unsigned char>

; 3060 : 		SendBuffered( (const char*)rpcMapBitStream.GetData(), rpcMapBitStream.GetNumberOfBitsUsed(), HIGH_PRIORITY, UNRELIABLE, 0, playerId, false, RemoteSystemStruct::NO_ACTION );

	push	0
	push	0
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	push	0
	push	0
	push	1
	lea	ecx, DWORD PTR _rpcMapBitStream$22[ebp]
	call	?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBitsUsed
	push	eax
	lea	ecx, DWORD PTR _rpcMapBitStream$22[ebp]
	call	?GetData@BitStream@RakNet@@QBEPAEXZ	; RakNet::BitStream::GetData
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendBuffered@RakPeer@@IAEXPBDHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_NW4ConnectMode@RemoteSystemStruct@1@@Z ; RakPeer::SendBuffered

; 3061 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _rpcMapBitStream$22[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
$LN15@HandleRPCP:

; 3062 : 
; 3063 : 	// Call the function
; 3064 : 	if ( rpcParms.numberOfBitsOfData == 0 )

	cmp	DWORD PTR _rpcParms$[ebp+4], 0
	jne	$LN14@HandleRPCP

; 3065 : 	{
; 3066 : 		rpcParms.input=0;

	mov	DWORD PTR _rpcParms$[ebp], 0

; 3067 : 		if (networkIDIsEncoded)

	movzx	eax, BYTE PTR _networkIDIsEncoded$[ebp]
	test	eax, eax
	je	SHORT $LN13@HandleRPCP

; 3068 : 		{
; 3069 : 			void *object = NetworkIDGenerator::GET_OBJECT_FROM_ID(networkID);

	mov	eax, DWORD PTR _networkID$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _networkID$[ebp]
	push	ecx
	call	?GET_OBJECT_FROM_ID@NetworkIDGenerator@@SAPAXUNetworkID@@@Z ; NetworkIDGenerator::GET_OBJECT_FROM_ID
	add	esp, 8
	mov	DWORD PTR _object$21[ebp], eax

; 3070 : 			if (object)

	cmp	DWORD PTR _object$21[ebp], 0
	je	SHORT $LN12@HandleRPCP

; 3071 : 				(node->memberFunctionPointer(object, &rpcParms));

	mov	esi, esp
	lea	eax, DWORD PTR _rpcParms$[ebp]
	push	eax
	mov	ecx, DWORD PTR _object$21[ebp]
	push	ecx
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN12@HandleRPCP:

; 3072 : 		}
; 3073 : 		else

	jmp	SHORT $LN11@HandleRPCP
$LN13@HandleRPCP:

; 3074 : 		{
; 3075 : 			node->staticFunctionPointer( &rpcParms );

	mov	esi, esp
	lea	eax, DWORD PTR _rpcParms$[ebp]
	push	eax
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	call	edx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN11@HandleRPCP:

; 3076 : 		}
; 3077 : 	}
; 3078 : 	else

	jmp	$LN10@HandleRPCP
$LN14@HandleRPCP:

; 3079 : 	{
; 3080 : 		if ( incomingBitStream.GetNumberOfUnreadBits() == 0 )

	lea	ecx, DWORD PTR _incomingBitStream$[ebp]
	call	?GetNumberOfUnreadBits@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfUnreadBits
	test	eax, eax
	jne	SHORT $LN9@HandleRPCP

; 3081 : 		{
; 3082 : #ifdef _DEBUG
; 3083 : 			assert( 0 );

	xor	eax, eax
	jne	SHORT $LN44@HandleRPCP
	mov	ecx, DWORD PTR ?__LINE__Var@?1??HandleRPCPacket@RakPeer@@IAE_NPBDHUPlayerID@@@Z@4JA
	add	ecx, 169				; 000000a9H
	push	ecx
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_13COJANIEC@?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN44@HandleRPCP:

; 3084 : #endif
; 3085 : 			return false; // No data was appended!

	mov	BYTE PTR $T13[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _replyToSender$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _incomingBitStream$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	al, BYTE PTR $T13[ebp]
	jmp	$LN31@HandleRPCP
$LN9@HandleRPCP:

; 3086 : 		}
; 3087 : 
; 3088 : 		// We have to copy into a new data chunk because the user data might not be byte aligned.
; 3089 : 		bool usedAlloca=false;

	mov	BYTE PTR _usedAlloca$20[ebp], 0

; 3090 : #if !defined(_COMPATIBILITY_1)
; 3091 : 		if (BITS_TO_BYTES( incomingBitStream.GetNumberOfUnreadBits() ) < MAX_ALLOCA_STACK_ALLOCATION)

	lea	ecx, DWORD PTR _incomingBitStream$[ebp]
	call	?GetNumberOfUnreadBits@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfUnreadBits
	add	eax, 7
	sar	eax, 3
	cmp	eax, 1048576				; 00100000H
	jge	SHORT $LN8@HandleRPCP

; 3092 : 		{
; 3093 : 			userData = ( unsigned char* ) alloca( BITS_TO_BYTES( incomingBitStream.GetNumberOfUnreadBits() ) );

	lea	ecx, DWORD PTR _incomingBitStream$[ebp]
	call	?GetNumberOfUnreadBits@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfUnreadBits
	add	eax, 7
	sar	eax, 3
	add	eax, 36					; 00000024H
	mov	DWORD PTR tv383[ebp], eax
	mov	eax, DWORD PTR tv383[ebp]
	call	__alloca_probe_16
	mov	DWORD PTR tv347[ebp], esp
	lea	eax, DWORD PTR __$AllocaPad$$[ebp]
	push	eax
	mov	edx, DWORD PTR tv383[ebp]
	mov	ecx, DWORD PTR tv347[ebp]
	call	@_RTC_AllocaHelper@12
	add	DWORD PTR tv347[ebp], 32		; 00000020H
	mov	ecx, DWORD PTR tv347[ebp]
	mov	DWORD PTR _userData$[ebp], ecx

; 3094 : 			usedAlloca=true;

	mov	BYTE PTR _usedAlloca$20[ebp], 1

; 3095 : 		}
; 3096 : 		else

	jmp	SHORT $LN7@HandleRPCP
$LN8@HandleRPCP:

; 3097 : #endif
; 3098 : 			userData = new unsigned char[BITS_TO_BYTES(incomingBitStream.GetNumberOfUnreadBits())];

	lea	ecx, DWORD PTR _incomingBitStream$[ebp]
	call	?GetNumberOfUnreadBits@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfUnreadBits
	add	eax, 7
	sar	eax, 3
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T14[ebp], eax
	mov	eax, DWORD PTR $T14[ebp]
	mov	DWORD PTR _userData$[ebp], eax
$LN7@HandleRPCP:

; 3099 : 
; 3100 : 
; 3101 : 		// The false means read out the internal representation of the bitstream data rather than
; 3102 : 		// aligning it as we normally would with user data.  This is so the end user can cast the data received
; 3103 : 		// into a bitstream for reading
; 3104 : 		if ( incomingBitStream.ReadBits( ( unsigned char* ) userData, rpcParms.numberOfBitsOfData, false ) == false )

	push	0
	mov	eax, DWORD PTR _rpcParms$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _userData$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _incomingBitStream$[ebp]
	call	?ReadBits@BitStream@RakNet@@QAE_NPAEH_N@Z ; RakNet::BitStream::ReadBits
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN6@HandleRPCP

; 3105 : 		{
; 3106 : #ifdef _DEBUG
; 3107 : 			assert( 0 );

	xor	eax, eax
	jne	SHORT $LN45@HandleRPCP
	mov	ecx, DWORD PTR ?__LINE__Var@?1??HandleRPCPacket@RakPeer@@IAE_NPBDHUPlayerID@@@Z@4JA
	add	ecx, 193				; 000000c1H
	push	ecx
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_13COJANIEC@?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN45@HandleRPCP:

; 3108 : #endif
; 3109 : 			#if defined(_COMPATIBILITY_1)
; 3110 : 			delete [] userData;
; 3111 : 			#endif
; 3112 : 
; 3113 : 			return false; // Not enough data to read

	mov	BYTE PTR $T15[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _replyToSender$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _incomingBitStream$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	al, BYTE PTR $T15[ebp]
	jmp	$LN31@HandleRPCP
$LN6@HandleRPCP:

; 3114 : 		}
; 3115 : 
; 3116 : //		if ( rpcParms.hasTimestamp )
; 3117 : //			ShiftIncomingTimestamp( userData, playerId );
; 3118 : 
; 3119 : 		// Call the function callback
; 3120 : 		rpcParms.input=userData;

	mov	eax, DWORD PTR _userData$[ebp]
	mov	DWORD PTR _rpcParms$[ebp], eax

; 3121 : 		if (networkIDIsEncoded)

	movzx	eax, BYTE PTR _networkIDIsEncoded$[ebp]
	test	eax, eax
	je	SHORT $LN5@HandleRPCP

; 3122 : 		{
; 3123 : 			void *object = NetworkIDGenerator::GET_OBJECT_FROM_ID(networkID);

	mov	eax, DWORD PTR _networkID$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _networkID$[ebp]
	push	ecx
	call	?GET_OBJECT_FROM_ID@NetworkIDGenerator@@SAPAXUNetworkID@@@Z ; NetworkIDGenerator::GET_OBJECT_FROM_ID
	add	esp, 8
	mov	DWORD PTR _object$19[ebp], eax

; 3124 : 			if (object)

	cmp	DWORD PTR _object$19[ebp], 0
	je	SHORT $LN4@HandleRPCP

; 3125 : 				(node->memberFunctionPointer(object, &rpcParms));

	mov	esi, esp
	lea	eax, DWORD PTR _rpcParms$[ebp]
	push	eax
	mov	ecx, DWORD PTR _object$19[ebp]
	push	ecx
	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@HandleRPCP:

; 3126 : 		}
; 3127 : 		else

	jmp	SHORT $LN3@HandleRPCP
$LN5@HandleRPCP:

; 3128 : 		{
; 3129 : 			node->staticFunctionPointer( &rpcParms );

	mov	esi, esp
	lea	eax, DWORD PTR _rpcParms$[ebp]
	push	eax
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	call	edx
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@HandleRPCP:

; 3130 : 		}
; 3131 : 
; 3132 : 
; 3133 : 		if (usedAlloca==false)

	movzx	eax, BYTE PTR _usedAlloca$20[ebp]
	test	eax, eax
	jne	SHORT $LN10@HandleRPCP

; 3134 : 			delete [] userData;

	mov	eax, DWORD PTR _userData$[ebp]
	mov	DWORD PTR $T16[ebp], eax
	mov	ecx, DWORD PTR $T16[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@HandleRPCP:

; 3135 : 	}
; 3136 : 
; 3137 : 	if (blockingCommand)

	movzx	eax, BYTE PTR _blockingCommand$[ebp]
	test	eax, eax
	je	$LN1@HandleRPCP

; 3138 : 	{
; 3139 : 		RakNet::BitStream reply;

	lea	ecx, DWORD PTR _reply$18[ebp]
	call	??0BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::BitStream
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 3140 : 		reply.Write((unsigned char) ID_RPC_REPLY);

	push	20					; 00000014H
	lea	ecx, DWORD PTR _reply$18[ebp]
	call	??$Write@E@BitStream@RakNet@@QAEXE@Z	; RakNet::BitStream::Write<unsigned char>

; 3141 : 		reply.Write((char*)replyToSender.GetData(), replyToSender.GetNumberOfBytesUsed());

	lea	ecx, DWORD PTR _replyToSender$[ebp]
	call	?GetNumberOfBytesUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBytesUsed
	push	eax
	lea	ecx, DWORD PTR _replyToSender$[ebp]
	call	?GetData@BitStream@RakNet@@QBEPAEXZ	; RakNet::BitStream::GetData
	push	eax
	lea	ecx, DWORD PTR _reply$18[ebp]
	call	?Write@BitStream@RakNet@@QAEXPBDH@Z	; RakNet::BitStream::Write

; 3142 : 		Send(&reply, HIGH_PRIORITY, RELIABLE, 0, playerId, false);

	mov	esi, esp
	push	0
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	push	0
	push	2
	push	1
	lea	eax, DWORD PTR _reply$18[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3143 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _reply$18[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
$LN1@HandleRPCP:

; 3144 : 
; 3145 : 	return true;

	mov	BYTE PTR $T17[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _replyToSender$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _incomingBitStream$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	al, BYTE PTR $T17[ebp]
$LN31@HandleRPCP:

; 3146 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN64@HandleRPCP
	push	DWORD PTR __$AllocaPad$$[ebp]
	call	@_RTC_CheckStackVars2@12
	pop	eax
	pop	edx
	lea	esp, DWORD PTR [ebp-2004]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	npad	2
$LN64@HandleRPCP:
	DD	12					; 0000000cH
	DD	$LN63@HandleRPCP
$LN63@HandleRPCP:
	DD	-308					; fffffeccH
	DD	273					; 00000111H
	DD	$LN50@HandleRPCP
	DD	-572					; fffffdc4H
	DD	256					; 00000100H
	DD	$LN51@HandleRPCP
	DD	-593					; fffffdafH
	DD	1
	DD	$LN52@HandleRPCP
	DD	-605					; fffffda3H
	DD	1
	DD	$LN53@HandleRPCP
	DD	-617					; fffffd97H
	DD	1
	DD	$LN54@HandleRPCP
	DD	-664					; fffffd68H
	DD	22					; 00000016H
	DD	$LN55@HandleRPCP
	DD	-680					; fffffd58H
	DD	8
	DD	$LN56@HandleRPCP
	DD	-689					; fffffd4fH
	DD	1
	DD	$LN57@HandleRPCP
	DD	-976					; fffffc30H
	DD	273					; 00000111H
	DD	$LN58@HandleRPCP
	DD	-1260					; fffffb14H
	DD	273					; 00000111H
	DD	$LN59@HandleRPCP
	DD	-1580					; fffff9d4H
	DD	273					; 00000111H
	DD	$LN60@HandleRPCP
	DD	-1592					; fffff9c8H
	DD	4
	DD	$LN61@HandleRPCP
$LN61@HandleRPCP:
	DB	95					; 0000005fH
	DB	36					; 00000024H
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	36					; 00000024H
	DB	0
$LN60@HandleRPCP:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	121					; 00000079H
	DB	0
$LN59@HandleRPCP:
	DB	114					; 00000072H
	DB	112					; 00000070H
	DB	99					; 00000063H
	DB	77					; 0000004dH
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	66					; 00000042H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	0
$LN58@HandleRPCP:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	121					; 00000079H
	DB	84					; 00000054H
	DB	111					; 0000006fH
	DB	83					; 00000053H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$LN57@HandleRPCP:
	DB	98					; 00000062H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	0
$LN56@HandleRPCP:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	119					; 00000077H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	107					; 0000006bH
	DB	73					; 00000049H
	DB	68					; 00000044H
	DB	0
$LN55@HandleRPCP:
	DB	114					; 00000072H
	DB	112					; 00000070H
	DB	99					; 00000063H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	109					; 0000006dH
	DB	115					; 00000073H
	DB	0
$LN54@HandleRPCP:
	DB	114					; 00000072H
	DB	112					; 00000070H
	DB	99					; 00000063H
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	0
$LN53@HandleRPCP:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	119					; 00000077H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	107					; 0000006bH
	DB	73					; 00000049H
	DB	68					; 00000044H
	DB	73					; 00000049H
	DB	115					; 00000073H
	DB	69					; 00000045H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	0
$LN52@HandleRPCP:
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	73					; 00000049H
	DB	115					; 00000073H
	DB	69					; 00000045H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	0
$LN51@HandleRPCP:
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	105					; 00000069H
	DB	113					; 00000071H
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	73					; 00000049H
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$LN50@HandleRPCP:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	109					; 0000006dH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	66					; 00000042H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?HandleRPCPacket@RakPeer@@IAE_NPBDHUPlayerID@@@Z$0:
	lea	ecx, DWORD PTR _incomingBitStream$[ebp]
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__unwindfunclet$?HandleRPCPacket@RakPeer@@IAE_NPBDHUPlayerID@@@Z$1:
	lea	ecx, DWORD PTR _replyToSender$[ebp]
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__unwindfunclet$?HandleRPCPacket@RakPeer@@IAE_NPBDHUPlayerID@@@Z$2:
	lea	ecx, DWORD PTR _rpcMapBitStream$22[ebp]
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__unwindfunclet$?HandleRPCPacket@RakPeer@@IAE_NPBDHUPlayerID@@@Z$3:
	lea	ecx, DWORD PTR _reply$18[ebp]
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__ehhandler$?HandleRPCPacket@RakPeer@@IAE_NPBDHUPlayerID@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1992]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?HandleRPCPacket@RakPeer@@IAE_NPBDHUPlayerID@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?HandleRPCPacket@RakPeer@@IAE_NPBDHUPlayerID@@@Z ENDP	; RakPeer::HandleRPCPacket
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?GetBestClockDifferential@RakPeer@@IBEIUPlayerID@@@Z
_TEXT	SEGMENT
_remoteSystem$ = -56					; size = 4
_clockDifferential$ = -44				; size = 4
_lowestPingSoFar$ = -32					; size = 4
_counter$ = -20						; size = 4
_this$ = -8						; size = 4
_playerId$ = 8						; size = 6
?GetBestClockDifferential@RakPeer@@IBEIUPlayerID@@@Z PROC ; RakPeer::GetBestClockDifferential, COMDAT
; _this$ = ecx

; 2872 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2873 : 	int counter, lowestPingSoFar;
; 2874 : 	RakNetTime clockDifferential;
; 2875 : 	RemoteSystemStruct *remoteSystem = GetRemoteSystemFromPlayerID( playerId, true, true );

	push	1
	push	1
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRemoteSystemFromPlayerID@RakPeer@@IBEPAURemoteSystemStruct@1@UPlayerID@@_N1@Z ; RakPeer::GetRemoteSystemFromPlayerID
	mov	DWORD PTR _remoteSystem$[ebp], eax

; 2876 : 
; 2877 : 	if ( remoteSystem == 0 )

	cmp	DWORD PTR _remoteSystem$[ebp], 0
	jne	SHORT $LN6@GetBestClo

; 2878 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN7@GetBestClo
$LN6@GetBestClo:

; 2879 : 
; 2880 : 	lowestPingSoFar = 65535;

	mov	DWORD PTR _lowestPingSoFar$[ebp], 65535	; 0000ffffH

; 2881 : 
; 2882 : 	clockDifferential = 0;

	mov	DWORD PTR _clockDifferential$[ebp], 0

; 2883 : 
; 2884 : 	for ( counter = 0; counter < PING_TIMES_ARRAY_SIZE; counter++ )

	mov	DWORD PTR _counter$[ebp], 0
	jmp	SHORT $LN5@GetBestClo
$LN4@GetBestClo:
	mov	eax, DWORD PTR _counter$[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$[ebp], eax
$LN5@GetBestClo:
	cmp	DWORD PTR _counter$[ebp], 5
	jge	SHORT $LN3@GetBestClo

; 2885 : 	{
; 2886 : 		if ( remoteSystem->pingAndClockDifferential[ counter ].pingTime == 65535 )

	imul	eax, DWORD PTR _counter$[ebp], 6
	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	movzx	edx, WORD PTR [ecx+eax+1704]
	cmp	edx, 65535				; 0000ffffH
	jne	SHORT $LN2@GetBestClo

; 2887 : 			break;

	jmp	SHORT $LN3@GetBestClo
$LN2@GetBestClo:

; 2888 : 
; 2889 : 		if ( remoteSystem->pingAndClockDifferential[ counter ].pingTime < lowestPingSoFar )

	imul	eax, DWORD PTR _counter$[ebp], 6
	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	movzx	edx, WORD PTR [ecx+eax+1704]
	cmp	edx, DWORD PTR _lowestPingSoFar$[ebp]
	jge	SHORT $LN1@GetBestClo

; 2890 : 		{
; 2891 : 			clockDifferential = remoteSystem->pingAndClockDifferential[ counter ].clockDifferential;

	imul	eax, DWORD PTR _counter$[ebp], 6
	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	mov	edx, DWORD PTR [ecx+eax+1706]
	mov	DWORD PTR _clockDifferential$[ebp], edx

; 2892 : 			lowestPingSoFar = remoteSystem->pingAndClockDifferential[ counter ].pingTime;

	imul	eax, DWORD PTR _counter$[ebp], 6
	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	movzx	edx, WORD PTR [ecx+eax+1704]
	mov	DWORD PTR _lowestPingSoFar$[ebp], edx
$LN1@GetBestClo:

; 2893 : 		}
; 2894 : 	}

	jmp	SHORT $LN4@GetBestClo
$LN3@GetBestClo:

; 2895 : 
; 2896 : 	return clockDifferential;

	mov	eax, DWORD PTR _clockDifferential$[ebp]
$LN7@GetBestClo:

; 2897 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?GetBestClockDifferential@RakPeer@@IBEIUPlayerID@@@Z ENDP ; RakPeer::GetBestClockDifferential
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?ShiftIncomingTimestamp@RakPeer@@IBEXPAEUPlayerID@@@Z
_TEXT	SEGMENT
_encodedTimestamp$ = -320				; size = 4
_timeBS$ = -308						; size = 273
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_data$ = 8						; size = 4
_playerId$ = 12						; size = 6
?ShiftIncomingTimestamp@RakPeer@@IBEXPAEUPlayerID@@@Z PROC ; RakPeer::ShiftIncomingTimestamp, COMDAT
; _this$ = ecx

; 2854 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ShiftIncomingTimestamp@RakPeer@@IBEXPAEUPlayerID@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 504				; 000001f8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-516]
	mov	ecx, 126				; 0000007eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2855 : #ifdef _DEBUG
; 2856 : 	assert( IsActive() );

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@ShiftIncom
	mov	edx, DWORD PTR ?__LINE__Var@?1??ShiftIncomingTimestamp@RakPeer@@IBEXPAEUPlayerID@@@Z@4JA
	add	edx, 2
	push	edx
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_1BG@FGPJADG@?$AAI?$AAs?$AAA?$AAc?$AAt?$AAi?$AAv?$AAe?$AA?$CI?$AA?$CJ?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN3@ShiftIncom:

; 2857 : 	assert( data );

	cmp	DWORD PTR _data$[ebp], 0
	jne	SHORT $LN4@ShiftIncom
	mov	eax, DWORD PTR ?__LINE__Var@?1??ShiftIncomingTimestamp@RakPeer@@IBEXPAEUPlayerID@@@Z@4JA
	add	eax, 3
	push	eax
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_19MLBBEMBH@?$AAd?$AAa?$AAt?$AAa?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@ShiftIncom:

; 2858 : #endif
; 2859 : 
; 2860 : 	RakNet::BitStream timeBS( data, sizeof(RakNetTime), false);

	push	0
	push	4
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	lea	ecx, DWORD PTR _timeBS$[ebp]
	call	??0BitStream@RakNet@@QAE@PAEI_N@Z	; RakNet::BitStream::BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2861 : 	RakNetTime encodedTimestamp;
; 2862 : 	timeBS.Read(encodedTimestamp);

	lea	eax, DWORD PTR _encodedTimestamp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _timeBS$[ebp]
	call	??$Read@I@BitStream@RakNet@@QAE_NAAI@Z	; RakNet::BitStream::Read<unsigned int>

; 2863 : 
; 2864 : 	encodedTimestamp = encodedTimestamp - GetBestClockDifferential( playerId );

	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBestClockDifferential@RakPeer@@IBEIUPlayerID@@@Z ; RakPeer::GetBestClockDifferential
	mov	ecx, DWORD PTR _encodedTimestamp$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _encodedTimestamp$[ebp], ecx

; 2865 : 	timeBS.SetWriteOffset(0);

	push	0
	lea	ecx, DWORD PTR _timeBS$[ebp]
	call	?SetWriteOffset@BitStream@RakNet@@QAEXH@Z ; RakNet::BitStream::SetWriteOffset

; 2866 : 	timeBS.Write(encodedTimestamp);

	mov	eax, DWORD PTR _encodedTimestamp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _timeBS$[ebp]
	call	??$Write@I@BitStream@RakNet@@QAEXI@Z	; RakNet::BitStream::Write<unsigned int>

; 2867 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _timeBS$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@ShiftIncom
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 516				; 00000204H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN10@ShiftIncom:
	DD	2
	DD	$LN9@ShiftIncom
$LN9@ShiftIncom:
	DD	-308					; fffffeccH
	DD	273					; 00000111H
	DD	$LN6@ShiftIncom
	DD	-320					; fffffec0H
	DD	4
	DD	$LN7@ShiftIncom
$LN7@ShiftIncom:
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
$LN6@ShiftIncom:
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	66					; 00000042H
	DB	83					; 00000053H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ShiftIncomingTimestamp@RakPeer@@IBEXPAEUPlayerID@@@Z$0:
	lea	ecx, DWORD PTR _timeBS$[ebp]
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__ehhandler$?ShiftIncomingTimestamp@RakPeer@@IBEXPAEUPlayerID@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-520]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ShiftIncomingTimestamp@RakPeer@@IBEXPAEUPlayerID@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ShiftIncomingTimestamp@RakPeer@@IBEXPAEUPlayerID@@@Z ENDP ; RakPeer::ShiftIncomingTimestamp
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?AssignPlayerIDToRemoteSystemList@RakPeer@@IAEPAURemoteSystemStruct@1@UPlayerID@@W4ConnectMode@21@@Z
_TEXT	SEGMENT
_playerIDAndIndex$1 = -76				; size = 10
_time$ = -56						; size = 4
_j$ = -44						; size = 4
_i$ = -32						; size = 4
_remoteSystem$ = -20					; size = 4
_this$ = -8						; size = 4
_playerId$ = 8						; size = 6
_connectionMode$ = 16					; size = 4
?AssignPlayerIDToRemoteSystemList@RakPeer@@IAEPAURemoteSystemStruct@1@UPlayerID@@W4ConnectMode@21@@Z PROC ; RakPeer::AssignPlayerIDToRemoteSystemList, COMDAT
; _this$ = ecx

; 2795 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 272				; 00000110H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-272]
	mov	ecx, 68					; 00000044H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2796 : 	RemoteSystemStruct * remoteSystem;
; 2797 : 	unsigned i,j;
; 2798 : 	RakNetTime time = RakNet::GetTime();

	call	?GetTime@RakNet@@YAIXZ			; RakNet::GetTime
	mov	DWORD PTR _time$[ebp], eax

; 2799 : #ifdef _DEBUG
; 2800 : 	assert(playerId!=UNASSIGNED_PLAYER_ID);

	push	OFFSET _UNASSIGNED_PLAYER_ID
	lea	ecx, DWORD PTR _playerId$[ebp]
	call	??9PlayerID@@QBE_NABU0@@Z		; PlayerID::operator!=
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN10@AssignPlay
	mov	ecx, DWORD PTR ?__LINE__Var@?1??AssignPlayerIDToRemoteSystemList@RakPeer@@IAEPAURemoteSystemStruct@2@UPlayerID@@W4ConnectMode@32@@Z@4JA
	add	ecx, 5
	push	ecx
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_1DO@FONFJDEJ@?$AAp?$AAl?$AAa?$AAy?$AAe?$AAr?$AAI?$AAd?$AA?$CB?$AA?$DN?$AAU?$AAN?$AAA?$AAS?$AAS?$AAI?$AAG?$AAN?$AAE?$AAD?$AA_?$AAP?$AAL?$AAA?$AAY?$AAE?$AAR?$AA_?$AAI?$AAD?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN10@AssignPlay:

; 2801 : #endif
; 2802 : 
; 2803 : 	// remoteSystemList in user thread
; 2804 : 	for ( i = 0; i < maximumNumberOfPeers; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@AssignPlay
$LN6@AssignPlay:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@AssignPlay:
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+7]
	cmp	DWORD PTR _i$[ebp], ecx
	jae	$LN5@AssignPlay

; 2805 : 	//for ( i = 0; i < remoteSystemListSize; i++ )
; 2806 : 	{
; 2807 : 		if ( remoteSystemList[ i ].isActive==false )

	imul	eax, DWORD PTR _i$[ebp], 2058
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	movzx	eax, BYTE PTR [edx+eax]
	test	eax, eax
	jne	$LN4@AssignPlay

; 2808 : 		{
; 2809 : 			remoteSystem=remoteSystemList+i;

	imul	eax, DWORD PTR _i$[ebp], 2058
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+820]
	mov	DWORD PTR _remoteSystem$[ebp], eax

; 2810 : 			remoteSystem->rpcMap.Clear();

	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	add	ecx, 2042				; 000007faH
	call	?Clear@RPCMap@@QAEXXZ			; RPCMap::Clear

; 2811 : 			remoteSystem->playerId = playerId;

	lea	eax, DWORD PTR _playerId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	add	ecx, 1
	call	??4PlayerID@@QAEAAU0@ABU0@@Z		; PlayerID::operator=

; 2812 : 			remoteSystem->isActive=true; // This one line causes future incoming packets to go through the reliability layer

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	mov	BYTE PTR [eax], 1

; 2813 : 			remoteSystem->reliabilityLayer.SetSplitMessageProgressInterval(splitMessageProgressInterval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2490]
	push	ecx
	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	add	ecx, 13					; 0000000dH
	call	?SetSplitMessageProgressInterval@ReliabilityLayer@@QAEXH@Z ; ReliabilityLayer::SetSplitMessageProgressInterval

; 2814 : 			remoteSystem->reliabilityLayer.SetUnreliableTimeout(unreliableTimeout);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2494]
	push	ecx
	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	add	ecx, 13					; 0000000dH
	call	?SetUnreliableTimeout@ReliabilityLayer@@QAEXI@Z ; ReliabilityLayer::SetUnreliableTimeout

; 2815 : 			remoteSystem->reliabilityLayer.SetEncryptionKey( 0 );

	push	0
	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	add	ecx, 13					; 0000000dH
	call	?SetEncryptionKey@ReliabilityLayer@@QAEXPBE@Z ; ReliabilityLayer::SetEncryptionKey

; 2816 : 
; 2817 : 			for ( j = 0; j < (unsigned) PING_TIMES_ARRAY_SIZE; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN3@AssignPlay
$LN2@AssignPlay:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN3@AssignPlay:
	cmp	DWORD PTR _j$[ebp], 5
	jae	SHORT $LN1@AssignPlay

; 2818 : 			{
; 2819 : 				remoteSystem->pingAndClockDifferential[ j ].pingTime = 65535;

	imul	eax, DWORD PTR _j$[ebp], 6
	mov	ecx, 65535				; 0000ffffH
	mov	edx, DWORD PTR _remoteSystem$[ebp]
	mov	WORD PTR [edx+eax+1704], cx

; 2820 : 				remoteSystem->pingAndClockDifferential[ j ].clockDifferential = 0;

	imul	eax, DWORD PTR _j$[ebp], 6
	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	mov	DWORD PTR [ecx+eax+1706], 0

; 2821 : 			}

	jmp	SHORT $LN2@AssignPlay
$LN1@AssignPlay:

; 2822 : 
; 2823 : 			remoteSystem->connectMode=connectionMode;

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	mov	ecx, DWORD PTR _connectionMode$[ebp]
	mov	DWORD PTR [eax+2054], ecx

; 2824 : 			remoteSystem->pingAndClockDifferentialWriteIndex = 0;

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	mov	DWORD PTR [eax+1734], 0

; 2825 : 			remoteSystem->lowestPing = 65535;

	mov	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	mov	WORD PTR [ecx+1738], ax

; 2826 : 			remoteSystem->nextPingTime = 0; // Ping immediately

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	mov	DWORD PTR [eax+1740], 0

; 2827 : 			remoteSystem->weInitiatedTheConnection = false;

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	mov	BYTE PTR [eax+1703], 0

; 2828 : 			remoteSystem->staticData.Reset();

	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	add	ecx, 1748				; 000006d4H
	call	?Reset@BitStream@RakNet@@QAEXXZ		; RakNet::BitStream::Reset

; 2829 : 			remoteSystem->connectionTime = time;

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	mov	ecx, DWORD PTR _time$[ebp]
	mov	DWORD PTR [eax+2021], ecx

; 2830 : 			remoteSystem->myExternalPlayerId = UNASSIGNED_PLAYER_ID;

	push	OFFSET _UNASSIGNED_PLAYER_ID
	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	add	ecx, 7
	call	??4PlayerID@@QAEAAU0@ABU0@@Z		; PlayerID::operator=

; 2831 : 			remoteSystem->setAESKey=false;

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	mov	BYTE PTR [eax+2041], 0

; 2832 : 			remoteSystem->lastReliableSend=time;

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	mov	ecx, DWORD PTR _time$[ebp]
	mov	DWORD PTR [eax+1744], ecx

; 2833 : 
; 2834 : 			// Reserve this reliability layer for ourselves.
; 2835 : 			remoteSystem->reliabilityLayer.Reset(true);

	push	1
	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	add	ecx, 13					; 0000000dH
	call	?Reset@ReliabilityLayer@@QAEX_N@Z	; ReliabilityLayer::Reset

; 2836 : 
; 2837 : 			/// Add this player to the lookup tree
; 2838 : 			PlayerIDAndIndex playerIDAndIndex;
; 2839 : 			playerIDAndIndex.playerId=playerId;

	lea	eax, DWORD PTR _playerId$[ebp]
	push	eax
	lea	ecx, DWORD PTR _playerIDAndIndex$1[ebp]
	call	??4PlayerID@@QAEAAU0@ABU0@@Z		; PlayerID::operator=

; 2840 : 			playerIDAndIndex.index=i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _playerIDAndIndex$1[ebp+6], eax

; 2841 : 			remoteSystemLookup.Insert(playerId,playerIDAndIndex);

	lea	eax, DWORD PTR _playerIDAndIndex$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _playerId$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 824				; 00000338H
	call	?Insert@?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QAEIABUPlayerID@@ABUPlayerIDAndIndex@@@Z ; DataStructures::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>::Insert

; 2842 : 
; 2843 : 			return remoteSystem;

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	jmp	SHORT $LN8@AssignPlay
$LN4@AssignPlay:

; 2844 : 		}
; 2845 : 	}

	jmp	$LN6@AssignPlay
$LN5@AssignPlay:

; 2846 : 
; 2847 : 	return 0;

	xor	eax, eax
$LN8@AssignPlay:

; 2848 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN13@AssignPlay
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 272				; 00000110H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	3
$LN13@AssignPlay:
	DD	1
	DD	$LN12@AssignPlay
$LN12@AssignPlay:
	DD	-76					; ffffffb4H
	DD	10					; 0000000aH
	DD	$LN11@AssignPlay
$LN11@AssignPlay:
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	73					; 00000049H
	DB	68					; 00000044H
	DB	65					; 00000041H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	0
?AssignPlayerIDToRemoteSystemList@RakPeer@@IAEPAURemoteSystemStruct@1@UPlayerID@@W4ConnectMode@21@@Z ENDP ; RakPeer::AssignPlayerIDToRemoteSystemList
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?GetNumberOfRemoteInitiatedConnections@RakPeer@@IBEGXZ
_TEXT	SEGMENT
_numberOfIncomingConnections$ = -32			; size = 2
_i$ = -20						; size = 2
_this$ = -8						; size = 4
?GetNumberOfRemoteInitiatedConnections@RakPeer@@IBEGXZ PROC ; RakPeer::GetNumberOfRemoteInitiatedConnections, COMDAT
; _this$ = ecx

; 2774 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2775 : 	unsigned short i, numberOfIncomingConnections;
; 2776 : 
; 2777 : 	if ( remoteSystemList == 0 || endThreads == true )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+820], 0
	je	SHORT $LN5@GetNumberO
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	cmp	ecx, 1
	jne	SHORT $LN6@GetNumberO
$LN5@GetNumberO:

; 2778 : 		return 0;

	xor	eax, eax
	jmp	$LN7@GetNumberO
$LN6@GetNumberO:

; 2779 : 
; 2780 : 	numberOfIncomingConnections = 0;

	xor	eax, eax
	mov	WORD PTR _numberOfIncomingConnections$[ebp], ax

; 2781 : 
; 2782 : 	// remoteSystemList in network thread
; 2783 : 	for ( i = 0; i < maximumNumberOfPeers; i++ )

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN4@GetNumberO
$LN3@GetNumberO:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN4@GetNumberO:
	movzx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+7]
	cmp	eax, edx
	jge	SHORT $LN2@GetNumberO

; 2784 : 	//for ( i = 0; i < remoteSystemListSize; i++ )
; 2785 : 	{
; 2786 : 		if ( remoteSystemList[ i ].isActive && remoteSystemList[ i ].weInitiatedTheConnection == false && remoteSystemList[i].connectMode==RemoteSystemStruct::CONNECTED)

	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 2058
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+820]
	movzx	ecx, BYTE PTR [eax+ecx]
	test	ecx, ecx
	je	SHORT $LN1@GetNumberO
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 2058
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+820]
	movzx	ecx, BYTE PTR [eax+ecx+1703]
	test	ecx, ecx
	jne	SHORT $LN1@GetNumberO
	movzx	eax, WORD PTR _i$[ebp]
	imul	ecx, eax, 2058
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+820]
	cmp	DWORD PTR [eax+ecx+2054], 8
	jne	SHORT $LN1@GetNumberO

; 2787 : 			numberOfIncomingConnections++;

	mov	ax, WORD PTR _numberOfIncomingConnections$[ebp]
	add	ax, 1
	mov	WORD PTR _numberOfIncomingConnections$[ebp], ax
$LN1@GetNumberO:

; 2788 : 	}

	jmp	SHORT $LN3@GetNumberO
$LN2@GetNumberO:

; 2789 : 
; 2790 : 	return numberOfIncomingConnections;

	mov	ax, WORD PTR _numberOfIncomingConnections$[ebp]
$LN7@GetNumberO:

; 2791 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumberOfRemoteInitiatedConnections@RakPeer@@IBEGXZ ENDP ; RakPeer::GetNumberOfRemoteInitiatedConnections
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?NotifyAndFlagForDisconnect@RakPeer@@IAEXUPlayerID@@_NE@Z
_TEXT	SEGMENT
_rss$2 = -320						; size = 4
_temp$ = -308						; size = 273
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_playerId$ = 8						; size = 6
_performImmediate$ = 16					; size = 1
_orderingChannel$ = 20					; size = 1
?NotifyAndFlagForDisconnect@RakPeer@@IAEXUPlayerID@@_NE@Z PROC ; RakPeer::NotifyAndFlagForDisconnect, COMDAT
; _this$ = ecx

; 2758 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?NotifyAndFlagForDisconnect@RakPeer@@IAEXUPlayerID@@_NE@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 504				; 000001f8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-516]
	mov	ecx, 126				; 0000007eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2759 : 	RakNet::BitStream temp( sizeof(unsigned char) );

	push	1
	lea	ecx, DWORD PTR _temp$[ebp]
	call	??0BitStream@RakNet@@QAE@H@Z		; RakNet::BitStream::BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2760 : 	temp.Write( (unsigned char) ID_DISCONNECTION_NOTIFICATION );

	push	28					; 0000001cH
	lea	ecx, DWORD PTR _temp$[ebp]
	call	??$Write@E@BitStream@RakNet@@QAEXE@Z	; RakNet::BitStream::Write<unsigned char>

; 2761 : 	if (performImmediate)

	movzx	eax, BYTE PTR _performImmediate$[ebp]
	test	eax, eax
	je	SHORT $LN2@NotifyAndF

; 2762 : 	{
; 2763 : 		SendImmediate((char*)temp.GetData(), temp.GetNumberOfBitsUsed(), LOW_PRIORITY, RELIABLE_ORDERED, orderingChannel, playerId, false, false, RakNet::GetTime());

	call	?GetTime@RakNet@@YAIXZ			; RakNet::GetTime
	xor	ecx, ecx
	push	ecx
	push	eax
	push	0
	push	0
	sub	esp, 8
	mov	edx, esp
	mov	eax, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [edx], eax
	mov	cx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [edx+4], cx
	movzx	edx, BYTE PTR _orderingChannel$[ebp]
	push	edx
	push	3
	push	3
	lea	ecx, DWORD PTR _temp$[ebp]
	call	?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBitsUsed
	push	eax
	lea	ecx, DWORD PTR _temp$[ebp]
	call	?GetData@BitStream@RakNet@@QBEPAEXZ	; RakNet::BitStream::GetData
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendImmediate@RakPeer@@IAE_NPADHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N4_J@Z ; RakPeer::SendImmediate

; 2764 : 		RemoteSystemStruct *rss=GetRemoteSystemFromPlayerID(playerId, true, true);

	push	1
	push	1
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRemoteSystemFromPlayerID@RakPeer@@IBEPAURemoteSystemStruct@1@UPlayerID@@_N1@Z ; RakPeer::GetRemoteSystemFromPlayerID
	mov	DWORD PTR _rss$2[ebp], eax

; 2765 : 		rss->connectMode=RemoteSystemStruct::DISCONNECT_ASAP;

	mov	eax, DWORD PTR _rss$2[ebp]
	mov	DWORD PTR [eax+2054], 1

; 2766 : 	}
; 2767 : 	else

	jmp	SHORT $LN1@NotifyAndF
$LN2@NotifyAndF:

; 2768 : 	{
; 2769 : 		SendBuffered((const char*)temp.GetData(), temp.GetNumberOfBitsUsed(), LOW_PRIORITY, RELIABLE_ORDERED, orderingChannel, playerId, false, RemoteSystemStruct::DISCONNECT_ASAP);

	push	1
	push	0
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	movzx	eax, BYTE PTR _orderingChannel$[ebp]
	push	eax
	push	3
	push	3
	lea	ecx, DWORD PTR _temp$[ebp]
	call	?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBitsUsed
	push	eax
	lea	ecx, DWORD PTR _temp$[ebp]
	call	?GetData@BitStream@RakNet@@QBEPAEXZ	; RakNet::BitStream::GetData
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendBuffered@RakPeer@@IAEXPBDHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_NW4ConnectMode@RemoteSystemStruct@1@@Z ; RakPeer::SendBuffered
$LN1@NotifyAndF:

; 2770 : 	}
; 2771 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _temp$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN9@NotifyAndF
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 516				; 00000204H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	npad	3
$LN9@NotifyAndF:
	DD	1
	DD	$LN8@NotifyAndF
$LN8@NotifyAndF:
	DD	-308					; fffffeccH
	DD	273					; 00000111H
	DD	$LN6@NotifyAndF
$LN6@NotifyAndF:
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?NotifyAndFlagForDisconnect@RakPeer@@IAEXUPlayerID@@_NE@Z$0:
	lea	ecx, DWORD PTR _temp$[ebp]
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__ehhandler$?NotifyAndFlagForDisconnect@RakPeer@@IAEXUPlayerID@@_NE@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-520]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?NotifyAndFlagForDisconnect@RakPeer@@IAEXUPlayerID@@_NE@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?NotifyAndFlagForDisconnect@RakPeer@@IAEXUPlayerID@@_NE@Z ENDP ; RakPeer::NotifyAndFlagForDisconnect
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?OnConnectionRequest@RakPeer@@IAEXPAURemoteSystemStruct@1@PAE_N@Z
_TEXT	SEGMENT
_bitStream$2 = -308					; size = 273
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_remoteSystem$ = 8					; size = 4
_AESKey$ = 12						; size = 4
_setAESKey$ = 16					; size = 1
?OnConnectionRequest@RakPeer@@IAEXPAURemoteSystemStruct@1@PAE_N@Z PROC ; RakPeer::OnConnectionRequest, COMDAT
; _this$ = ecx

; 2696 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?OnConnectionRequest@RakPeer@@IAEXPAURemoteSystemStruct@1@PAE_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 492				; 000001ecH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-504]
	mov	ecx, 123				; 0000007bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2697 : 	// Already handled by caller
; 2698 : 	//if ( AllowIncomingConnections() )
; 2699 : 	{
; 2700 : #ifdef __USE_IO_COMPLETION_PORTS
; 2701 : 		unsigned index;
; 2702 : 
; 2703 : 		// remoteSystemList in network thread
; 2704 : 		for ( index = 0; index < maximumNumberOfPeers; index++ )
; 2705 : 		//for ( index = 0; index < remoteSystemListSize; index++ )
; 2706 : 			if ( remoteSystemList + index == remoteSystem )
; 2707 : 				break;
; 2708 : 
; 2709 : 		if ( SetupIOCompletionPortSocket( index ) == false )
; 2710 : 		{
; 2711 : 			// Socket error
; 2712 : 			assert( 0 );
; 2713 : 			return ;
; 2714 : 		}
; 2715 : #endif
; 2716 : 
; 2717 : 		RakNet::BitStream bitStream(sizeof(unsigned char)+sizeof(unsigned short)+sizeof(unsigned int)+sizeof(unsigned short)+sizeof(PlayerIndex)+sizeof(unsigned int));

	push	15					; 0000000fH
	lea	ecx, DWORD PTR _bitStream$2[ebp]
	call	??0BitStream@RakNet@@QAE@H@Z		; RakNet::BitStream::BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2718 : 		bitStream.Write((unsigned char)ID_CONNECTION_REQUEST_ACCEPTED);

	push	23					; 00000017H
	lea	ecx, DWORD PTR _bitStream$2[ebp]
	call	??$Write@E@BitStream@RakNet@@QAEXE@Z	; RakNet::BitStream::Write<unsigned char>

; 2719 : //#ifdef __USE_IO_COMPLETION_PORTS
; 2720 : //		bitStream.Write((unsigned short)myPlayerId.port + ( unsigned short ) index + ( unsigned short ) 1);
; 2721 : //#else
; 2722 : //		bitStream.Write((unsigned short)myPlayerId.port);
; 2723 : //#endif
; 2724 : 		bitStream.Write(remoteSystem->playerId.binaryAddress);

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	push	ecx
	lea	ecx, DWORD PTR _bitStream$2[ebp]
	call	??$Write@I@BitStream@RakNet@@QAEXI@Z	; RakNet::BitStream::Write<unsigned int>

; 2725 : 		bitStream.Write(remoteSystem->playerId.port);

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	movzx	ecx, WORD PTR [eax+5]
	push	ecx
	lea	ecx, DWORD PTR _bitStream$2[ebp]
	call	??$Write@G@BitStream@RakNet@@QAEXG@Z	; RakNet::BitStream::Write<unsigned short>

; 2726 : 		bitStream.Write(( PlayerIndex ) GetIndexFromPlayerID( remoteSystem->playerId, true ));

	push	1
	mov	eax, DWORD PTR _remoteSystem$[ebp]
	add	eax, 1
	sub	esp, 8
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	ax, WORD PTR [eax+4]
	mov	WORD PTR [ecx+4], ax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexFromPlayerID@RakPeer@@IAEHUPlayerID@@_N@Z ; RakPeer::GetIndexFromPlayerID
	push	eax
	lea	ecx, DWORD PTR _bitStream$2[ebp]
	call	??$Write@G@BitStream@RakNet@@QAEXG@Z	; RakNet::BitStream::Write<unsigned short>

; 2727 : #ifdef SAMPSRV
; 2728 : 		bitStream.Write((unsigned int)_uiRndSrvChallenge);
; 2729 : #else
; 2730 : 		bitStream.Write((unsigned int)0);

	push	0
	lea	ecx, DWORD PTR _bitStream$2[ebp]
	call	??$Write@I@BitStream@RakNet@@QAEXI@Z	; RakNet::BitStream::Write<unsigned int>

; 2731 : #endif
; 2732 : 		SendImmediate((char*)bitStream.GetData(), bitStream.GetNumberOfBitsUsed(), SYSTEM_PRIORITY, RELIABLE, 0, remoteSystem->playerId, false, false, RakNet::GetTime());

	call	?GetTime@RakNet@@YAIXZ			; RakNet::GetTime
	xor	ecx, ecx
	push	ecx
	push	eax
	push	0
	push	0
	mov	edx, DWORD PTR _remoteSystem$[ebp]
	add	edx, 1
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR [edx+4]
	mov	WORD PTR [eax+4], dx
	push	0
	push	2
	push	0
	lea	ecx, DWORD PTR _bitStream$2[ebp]
	call	?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBitsUsed
	push	eax
	lea	ecx, DWORD PTR _bitStream$2[ebp]
	call	?GetData@BitStream@RakNet@@QBEPAEXZ	; RakNet::BitStream::GetData
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendImmediate@RakPeer@@IAE_NPADHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N4_J@Z ; RakPeer::SendImmediate

; 2733 : 
; 2734 : 		// Don't set secure connections immediately because we need the ack from the remote system to know ID_CONNECTION_REQUEST_ACCEPTED
; 2735 : 		// As soon as a 16 byte packet arrives, we will turn on AES.  This works because all encrypted packets are multiples of 16 and the
; 2736 : 		// packets I happen to be sending are less than 16 bytes
; 2737 : 		remoteSystem->setAESKey=setAESKey;

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	mov	cl, BYTE PTR _setAESKey$[ebp]
	mov	BYTE PTR [eax+2041], cl

; 2738 : 		if ( setAESKey )

	movzx	eax, BYTE PTR _setAESKey$[ebp]
	test	eax, eax
	je	SHORT $LN1@OnConnecti

; 2739 : 		{
; 2740 : 			memcpy(remoteSystem->AESKey, AESKey, 16);

	push	16					; 00000010H
	mov	eax, DWORD PTR _AESKey$[ebp]
	push	eax
	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	add	ecx, 2025				; 000007e9H
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2741 : 			remoteSystem->connectMode=RemoteSystemStruct::SET_ENCRYPTION_ON_MULTIPLE_16_BYTE_PACKET;

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	mov	DWORD PTR [eax+2054], 7
$LN1@OnConnecti:

; 2742 : 		}
; 2743 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _bitStream$2[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream

; 2744 : 	/*
; 2745 : 	else
; 2746 : 	{
; 2747 : 		unsigned char c = ID_NO_FREE_INCOMING_CONNECTIONS;
; 2748 : 		//SocketLayer::Instance()->SendTo( connectionSocket, ( char* ) & c, sizeof( char ), playerId.binaryAddress, playerId.port );
; 2749 : 
; 2750 : 		SendImmediate((char*)&c, sizeof(c)*8, SYSTEM_PRIORITY, RELIABLE, 0, remoteSystem->systemAddress, false, false, RakNet::GetTime());
; 2751 : 		remoteSystem->connectMode=RemoteSystemStruct::DISCONNECT_ASAP_SILENTLY;
; 2752 : 	}
; 2753 : 	*/
; 2754 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@OnConnecti
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 504				; 000001f8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	2
$LN8@OnConnecti:
	DD	1
	DD	$LN7@OnConnecti
$LN7@OnConnecti:
	DD	-308					; fffffeccH
	DD	273					; 00000111H
	DD	$LN5@OnConnecti
$LN5@OnConnecti:
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?OnConnectionRequest@RakPeer@@IAEXPAURemoteSystemStruct@1@PAE_N@Z$0:
	lea	ecx, DWORD PTR _bitStream$2[ebp]
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__ehhandler$?OnConnectionRequest@RakPeer@@IAEXPAURemoteSystemStruct@1@PAE_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-508]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?OnConnectionRequest@RakPeer@@IAEXPAURemoteSystemStruct@1@PAE_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?OnConnectionRequest@RakPeer@@IAEXPAURemoteSystemStruct@1@PAE_N@Z ENDP ; RakPeer::OnConnectionRequest
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?ParseConnectionRequestPacket@RakPeer@@IAEXPAURemoteSystemStruct@1@UPlayerID@@PBDH@Z
_TEXT	SEGMENT
_c$1 = -53						; size = 1
_passwordLength$2 = -44					; size = 4
_password$3 = -32					; size = 4
_c$4 = -17						; size = 1
_this$ = -8						; size = 4
_remoteSystem$ = 8					; size = 4
_playerId$ = 12						; size = 6
_data$ = 20						; size = 4
_byteSize$ = 24						; size = 4
?ParseConnectionRequestPacket@RakPeer@@IAEXPAURemoteSystemStruct@1@UPlayerID@@PBDH@Z PROC ; RakPeer::ParseConnectionRequestPacket, COMDAT
; _this$ = ecx

; 2642 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2643 : 	// If we are full tell the sender.
; 2644 : 	if ( !AllowIncomingConnections() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AllowIncomingConnections@RakPeer@@IBE_NXZ ; RakPeer::AllowIncomingConnections
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@ParseConne

; 2645 : 	{
; 2646 : 		unsigned char c = ID_NO_FREE_INCOMING_CONNECTIONS;

	mov	BYTE PTR _c$4[ebp], 27			; 0000001bH

; 2647 : 		// SocketLayer::Instance()->SendTo( rakPeer->connectionSocket, ( char* ) & c, sizeof( char ), systemAddress.binaryAddress, systemAddress.port );
; 2648 : 		SendImmediate(( char* ) & c, sizeof( char )*8, SYSTEM_PRIORITY, RELIABLE, 0, playerId, false, false, RakNet::GetTime());

	call	?GetTime@RakNet@@YAIXZ			; RakNet::GetTime
	xor	ecx, ecx
	push	ecx
	push	eax
	push	0
	push	0
	sub	esp, 8
	mov	edx, esp
	mov	eax, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [edx], eax
	mov	cx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [edx+4], cx
	push	0
	push	2
	push	0
	push	8
	lea	edx, DWORD PTR _c$4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendImmediate@RakPeer@@IAE_NPADHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N4_J@Z ; RakPeer::SendImmediate

; 2649 : 		remoteSystem->connectMode=RemoteSystemStruct::DISCONNECT_ASAP_SILENTLY;

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	mov	DWORD PTR [eax+2054], 2

; 2650 : 	}
; 2651 : 	else

	jmp	$LN7@ParseConne
$LN6@ParseConne:

; 2652 : 	{
; 2653 : 		const char *password = data + sizeof(unsigned char);

	mov	eax, DWORD PTR _data$[ebp]
	add	eax, 1
	mov	DWORD PTR _password$3[ebp], eax

; 2654 : 		int passwordLength = byteSize - sizeof(unsigned char);

	mov	eax, DWORD PTR _byteSize$[ebp]
	sub	eax, 1
	mov	DWORD PTR _passwordLength$2[ebp], eax

; 2655 : 
; 2656 : 		if ( incomingPasswordLength == passwordLength &&
; 2657 : 			memcmp( password, incomingPassword, incomingPasswordLength ) == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+819]
	cmp	ecx, DWORD PTR _passwordLength$2[ebp]
	jne	SHORT $LN4@ParseConne
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+819]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 563				; 00000233H
	push	edx
	mov	eax, DWORD PTR _password$3[ebp]
	push	eax
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN4@ParseConne

; 2658 : 		{
; 2659 : 			remoteSystem->connectMode=RemoteSystemStruct::HANDLING_CONNECTION_REQUEST;

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	mov	DWORD PTR [eax+2054], 5

; 2660 : 
; 2661 : #if !defined(_COMPATIBILITY_1)
; 2662 : 			if ( usingSecurity == false )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+2444]
	test	ecx, ecx
	jne	SHORT $LN3@ParseConne

; 2663 : #endif
; 2664 : 			{
; 2665 : #ifdef _TEST_AES
; 2666 : 				unsigned char AESKey[ 16 ];
; 2667 : 				// Save the AES key
; 2668 : 				for ( i = 0; i < 16; i++ )
; 2669 : 					AESKey[ i ] = i;
; 2670 : 
; 2671 : 				OnConnectionRequest( remoteSystem, AESKey, true );
; 2672 : #else
; 2673 : 				// Connect this player assuming we have open slots
; 2674 : 				OnConnectionRequest( remoteSystem, 0, false );

	push	0
	push	0
	mov	eax, DWORD PTR _remoteSystem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?OnConnectionRequest@RakPeer@@IAEXPAURemoteSystemStruct@1@PAE_N@Z ; RakPeer::OnConnectionRequest

; 2675 : #endif
; 2676 : 			}
; 2677 : #if !defined(_COMPATIBILITY_1)
; 2678 : 			else

	jmp	SHORT $LN2@ParseConne
$LN3@ParseConne:

; 2679 : 				SecuredConnectionResponse( playerId );

	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SecuredConnectionResponse@RakPeer@@IAEXUPlayerID@@@Z ; RakPeer::SecuredConnectionResponse
$LN2@ParseConne:

; 2680 : #endif
; 2681 : 		}
; 2682 : 		else

	jmp	SHORT $LN7@ParseConne
$LN4@ParseConne:

; 2683 : 		{
; 2684 : 			// This one we only send once since we don't care if it arrives.
; 2685 : 			unsigned char c = ID_INVALID_PASSWORD;

	mov	BYTE PTR _c$1[ebp], 34			; 00000022H

; 2686 : 			// SocketLayer::Instance()->SendTo( rakPeer->connectionSocket, ( char* ) & c, sizeof( char ), systemAddress.binaryAddress, systemAddress.port );
; 2687 : 			SendImmediate(( char* ) & c, sizeof( char )*8, SYSTEM_PRIORITY, RELIABLE, 0, playerId, false, false, RakNet::GetTime());

	call	?GetTime@RakNet@@YAIXZ			; RakNet::GetTime
	xor	ecx, ecx
	push	ecx
	push	eax
	push	0
	push	0
	sub	esp, 8
	mov	edx, esp
	mov	eax, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [edx], eax
	mov	cx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [edx+4], cx
	push	0
	push	2
	push	0
	push	8
	lea	edx, DWORD PTR _c$1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendImmediate@RakPeer@@IAE_NPADHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N4_J@Z ; RakPeer::SendImmediate

; 2688 : 			remoteSystem->connectMode=RemoteSystemStruct::DISCONNECT_ASAP_SILENTLY;

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	mov	DWORD PTR [eax+2054], 2
$LN7@ParseConne:

; 2689 : 		}
; 2690 : 	}
; 2691 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@ParseConne
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
	npad	3
$LN12@ParseConne:
	DD	2
	DD	$LN11@ParseConne
$LN11@ParseConne:
	DD	-17					; ffffffefH
	DD	1
	DD	$LN9@ParseConne
	DD	-53					; ffffffcbH
	DD	1
	DD	$LN10@ParseConne
$LN10@ParseConne:
	DB	99					; 00000063H
	DB	0
$LN9@ParseConne:
	DB	99					; 00000063H
	DB	0
?ParseConnectionRequestPacket@RakPeer@@IAEXPAURemoteSystemStruct@1@UPlayerID@@PBDH@Z ENDP ; RakPeer::ParseConnectionRequestPacket
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?GetRemoteSystemFromPlayerID@RakPeer@@IBEPAURemoteSystemStruct@1@UPlayerID@@_N1@Z
_TEXT	SEGMENT
_deadConnectionIndex$1 = -56				; size = 4
_index$2 = -44						; size = 4
_objectExists$3 = -29					; size = 1
_i$ = -20						; size = 4
_this$ = -8						; size = 4
_playerID$ = 8						; size = 6
_calledFromNetworkThread$ = 16				; size = 1
_onlyActive$ = 20					; size = 1
?GetRemoteSystemFromPlayerID@RakPeer@@IBEPAURemoteSystemStruct@1@UPlayerID@@_N1@Z PROC ; RakPeer::GetRemoteSystemFromPlayerID, COMDAT
; _this$ = ecx

; 2599 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2600 : 	unsigned i;
; 2601 : 
; 2602 : 	if ( playerID == UNASSIGNED_PLAYER_ID )

	push	OFFSET _UNASSIGNED_PLAYER_ID
	lea	ecx, DWORD PTR _playerID$[ebp]
	call	??8PlayerID@@QBE_NABU0@@Z		; PlayerID::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN12@GetRemoteS

; 2603 : 		return 0;

	xor	eax, eax
	jmp	$LN13@GetRemoteS
$LN12@GetRemoteS:

; 2604 : 
; 2605 : 	if (calledFromNetworkThread)

	movzx	eax, BYTE PTR _calledFromNetworkThread$[ebp]
	test	eax, eax
	je	$LN11@GetRemoteS

; 2606 : 	{
; 2607 : 		bool objectExists;
; 2608 : 		unsigned index;
; 2609 : 		index = remoteSystemLookup.GetIndexFromKey(playerID, &objectExists);

	lea	eax, DWORD PTR _objectExists$3[ebp]
	push	eax
	lea	ecx, DWORD PTR _playerID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 824				; 00000338H
	call	?GetIndexFromKey@?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QBEIABUPlayerID@@PA_N@Z ; DataStructures::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>::GetIndexFromKey
	mov	DWORD PTR _index$2[ebp], eax

; 2610 : 		if (objectExists)

	movzx	eax, BYTE PTR _objectExists$3[ebp]
	test	eax, eax
	je	SHORT $LN10@GetRemoteS

; 2611 : 		{
; 2612 : #ifdef _DEBUG
; 2613 : 			assert(remoteSystemList[ remoteSystemLookup[index].index ].playerId==playerID);

	lea	eax, DWORD PTR _playerID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _index$2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 824				; 00000338H
	call	??A?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QBEAAUPlayerIDAndIndex@@I@Z ; DataStructures::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>::operator[]
	imul	edx, DWORD PTR [eax+6], 2058
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	lea	ecx, DWORD PTR [ecx+edx+1]
	call	??8PlayerID@@QBE_NABU0@@Z		; PlayerID::operator==
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN15@GetRemoteS
	mov	eax, DWORD PTR ?__LINE__Var@?1??GetRemoteSystemFromPlayerID@RakPeer@@IBEPAURemoteSystemStruct@2@UPlayerID@@_N1@Z@4JA
	add	eax, 14					; 0000000eH
	push	eax
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_1IO@IHOLNDOE@?$AAr?$AAe?$AAm?$AAo?$AAt?$AAe?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AAL?$AAi?$AAs?$AAt?$AA?$FL?$AA?5?$AAr?$AAe?$AAm?$AAo?$AAt?$AAe?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AAL?$AAo@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN15@GetRemoteS:

; 2614 : #endif
; 2615 : 			return remoteSystemList + remoteSystemLookup[index].index;

	mov	eax, DWORD PTR _index$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 824				; 00000338H
	call	??A?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QBEAAUPlayerIDAndIndex@@I@Z ; DataStructures::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>::operator[]
	imul	eax, DWORD PTR [eax+6], 2058
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+820]
	jmp	$LN13@GetRemoteS
$LN10@GetRemoteS:

; 2616 : 		}
; 2617 : 	}
; 2618 : 	else

	jmp	$LN9@GetRemoteS
$LN11@GetRemoteS:

; 2619 : 	{
; 2620 : 		int deadConnectionIndex=-1;

	mov	DWORD PTR _deadConnectionIndex$1[ebp], -1

; 2621 : 
; 2622 : 		// Active connections take priority.  But if there are no active connections, return the first systemAddress match found
; 2623 : 		for ( i = 0; i < maximumNumberOfPeers; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN8@GetRemoteS
$LN7@GetRemoteS:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN8@GetRemoteS:
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+7]
	cmp	DWORD PTR _i$[ebp], ecx
	jae	SHORT $LN6@GetRemoteS

; 2624 : 		{
; 2625 : 			if (remoteSystemList[ i ].playerId == playerID )

	lea	eax, DWORD PTR _playerID$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 2058
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+820]
	lea	ecx, DWORD PTR [eax+ecx+1]
	call	??8PlayerID@@QBE_NABU0@@Z		; PlayerID::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@GetRemoteS

; 2626 : 			{
; 2627 : 				if ( remoteSystemList[ i ].isActive )

	imul	eax, DWORD PTR _i$[ebp], 2058
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	movzx	eax, BYTE PTR [edx+eax]
	test	eax, eax
	je	SHORT $LN4@GetRemoteS

; 2628 : 					return remoteSystemList + i;

	imul	eax, DWORD PTR _i$[ebp], 2058
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+820]
	jmp	SHORT $LN13@GetRemoteS
	jmp	SHORT $LN5@GetRemoteS
$LN4@GetRemoteS:

; 2629 : 				else if (deadConnectionIndex==-1)

	cmp	DWORD PTR _deadConnectionIndex$1[ebp], -1
	jne	SHORT $LN5@GetRemoteS

; 2630 : 					deadConnectionIndex=i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _deadConnectionIndex$1[ebp], eax
$LN5@GetRemoteS:

; 2631 : 			}
; 2632 : 		}

	jmp	SHORT $LN7@GetRemoteS
$LN6@GetRemoteS:

; 2633 : 
; 2634 : 		if (deadConnectionIndex!=-1 && onlyActive==false)

	cmp	DWORD PTR _deadConnectionIndex$1[ebp], -1
	je	SHORT $LN9@GetRemoteS
	movzx	eax, BYTE PTR _onlyActive$[ebp]
	test	eax, eax
	jne	SHORT $LN9@GetRemoteS

; 2635 : 			return remoteSystemList + deadConnectionIndex;

	imul	eax, DWORD PTR _deadConnectionIndex$1[ebp], 2058
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+820]
	jmp	SHORT $LN13@GetRemoteS
$LN9@GetRemoteS:

; 2636 : 	}
; 2637 : 
; 2638 : 	return 0;

	xor	eax, eax
$LN13@GetRemoteS:

; 2639 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN18@GetRemoteS
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN18@GetRemoteS:
	DD	1
	DD	$LN17@GetRemoteS
$LN17@GetRemoteS:
	DD	-29					; ffffffe3H
	DD	1
	DD	$LN16@GetRemoteS
$LN16@GetRemoteS:
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
?GetRemoteSystemFromPlayerID@RakPeer@@IBEPAURemoteSystemStruct@1@UPlayerID@@_N1@Z ENDP ; RakPeer::GetRemoteSystemFromPlayerID
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?SendConnectionRequest@RakPeer@@IAE_NPBDGPADH@Z
_TEXT	SEGMENT
_rcs$ = -36						; size = 4
_playerId$ = -24					; size = 6
_this$ = -8						; size = 4
_host$ = 8						; size = 4
_remotePort$ = 12					; size = 2
_passwordData$ = 16					; size = 4
_passwordDataLength$ = 20				; size = 4
?SendConnectionRequest@RakPeer@@IAE_NPBDGPADH@Z PROC	; RakPeer::SendConnectionRequest, COMDAT
; _this$ = ecx

; 2556 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2557 : 	PlayerID playerId;
; 2558 : 	IPToPlayerID( host, remotePort, &playerId );

	mov	esi, esp
	lea	eax, DWORD PTR _playerId$[ebp]
	push	eax
	movzx	ecx, WORD PTR _remotePort$[ebp]
	push	ecx
	mov	edx, DWORD PTR _host$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+188]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2559 : 
; 2560 : 	// Already connected?
; 2561 : 	if (GetRemoteSystemFromPlayerID(playerId, false, true))

	push	1
	push	0
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRemoteSystemFromPlayerID@RakPeer@@IBEPAURemoteSystemStruct@1@UPlayerID@@_N1@Z ; RakPeer::GetRemoteSystemFromPlayerID
	test	eax, eax
	je	SHORT $LN1@SendConnec

; 2562 : 		return false;

	xor	al, al
	jmp	$LN2@SendConnec
$LN1@SendConnec:

; 2563 : 
; 2564 : 	assert(passwordDataLength <= 256);

	cmp	DWORD PTR _passwordDataLength$[ebp], 256 ; 00000100H
	jle	SHORT $LN4@SendConnec
	mov	eax, DWORD PTR ?__LINE__Var@?1??SendConnectionRequest@RakPeer@@IAE_NPBDGPADH@Z@4JA
	add	eax, 8
	push	eax
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_1DE@MHEPBEIO@?$AAp?$AAa?$AAs?$AAs?$AAw?$AAo?$AAr?$AAd?$AAD?$AAa?$AAt?$AAa?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA2?$AA5?$AA6?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@SendConnec:

; 2565 : 
; 2566 : #ifdef _RAKNET_THREADSAFE
; 2567 : 	rakPeerMutexes[requestedConnectionList_Mutex].Lock();
; 2568 : #endif
; 2569 : 	RequestedConnectionStruct *rcs = requestedConnectionList.WriteLock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 953				; 000003b9H
	call	?WriteLock@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEPAURequestedConnectionStruct@RakPeer@@XZ ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::WriteLock
	mov	DWORD PTR _rcs$[ebp], eax

; 2570 : 	rcs->playerId=playerId;

	lea	eax, DWORD PTR _playerId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rcs$[ebp]
	call	??4PlayerID@@QAEAAU0@ABU0@@Z		; PlayerID::operator=

; 2571 : 	rcs->nextRequestTime=RakNet::GetTime();

	call	?GetTime@RakNet@@YAIXZ			; RakNet::GetTime
	mov	ecx, DWORD PTR _rcs$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 2572 : 	rcs->requestsMade=0;

	mov	eax, DWORD PTR _rcs$[ebp]
	mov	BYTE PTR [eax+10], 0

; 2573 : 	rcs->data=0;

	mov	eax, DWORD PTR _rcs$[ebp]
	mov	DWORD PTR [eax+11], 0

; 2574 : 	rcs->actionToTake=RequestedConnectionStruct::CONNECT;

	mov	eax, DWORD PTR _rcs$[ebp]
	mov	DWORD PTR [eax+274], 1

; 2575 : 	memcpy(rcs->outgoingPassword, passwordData, passwordDataLength);

	mov	eax, DWORD PTR _passwordDataLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _passwordData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rcs$[ebp]
	add	edx, 17					; 00000011H
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2576 : 	rcs->outgoingPasswordLength=(unsigned char) passwordDataLength;

	mov	eax, DWORD PTR _rcs$[ebp]
	mov	cl, BYTE PTR _passwordDataLength$[ebp]
	mov	BYTE PTR [eax+273], cl

; 2577 : 	requestedConnectionList.WriteUnlock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 953				; 000003b9H
	call	?WriteUnlock@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEXXZ ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::WriteUnlock

; 2578 : 
; 2579 : #ifdef _RAKNET_THREADSAFE
; 2580 : 	rakPeerMutexes[requestedConnectionList_Mutex].Unlock();
; 2581 : #endif
; 2582 : 
; 2583 : 	return true;

	mov	al, 1
$LN2@SendConnec:

; 2584 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@SendConnec
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	npad	2
$LN7@SendConnec:
	DD	1
	DD	$LN6@SendConnec
$LN6@SendConnec:
	DD	-24					; ffffffe8H
	DD	6
	DD	$LN5@SendConnec
$LN5@SendConnec:
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	73					; 00000049H
	DB	100					; 00000064H
	DB	0
?SendConnectionRequest@RakPeer@@IAE_NPBDGPADH@Z ENDP	; RakPeer::SendConnectionRequest
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?GetIndexFromPlayerID@RakPeer@@IAEHUPlayerID@@_N@Z
_TEXT	SEGMENT
_index$1 = -44						; size = 4
_objectExists$2 = -29					; size = 1
_i$ = -20						; size = 4
_this$ = -8						; size = 4
_playerId$ = 8						; size = 6
_calledFromNetworkThread$ = 16				; size = 1
?GetIndexFromPlayerID@RakPeer@@IAEHUPlayerID@@_N@Z PROC	; RakPeer::GetIndexFromPlayerID, COMDAT
; _this$ = ecx

; 2525 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2526 : 	unsigned i;
; 2527 : 
; 2528 : 	if ( playerId == UNASSIGNED_PLAYER_ID )

	push	OFFSET _UNASSIGNED_PLAYER_ID
	lea	ecx, DWORD PTR _playerId$[ebp]
	call	??8PlayerID@@QBE_NABU0@@Z		; PlayerID::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@GetIndexFr

; 2529 : 		return -1;

	or	eax, -1
	jmp	$LN10@GetIndexFr
$LN9@GetIndexFr:

; 2530 : 
; 2531 : 	if (calledFromNetworkThread)

	movzx	eax, BYTE PTR _calledFromNetworkThread$[ebp]
	test	eax, eax
	je	$LN8@GetIndexFr

; 2532 : 	{
; 2533 : 		bool objectExists;
; 2534 : 		unsigned index;
; 2535 : 		index = remoteSystemLookup.GetIndexFromKey(playerId, &objectExists);

	lea	eax, DWORD PTR _objectExists$2[ebp]
	push	eax
	lea	ecx, DWORD PTR _playerId$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 824				; 00000338H
	call	?GetIndexFromKey@?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QBEIABUPlayerID@@PA_N@Z ; DataStructures::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>::GetIndexFromKey
	mov	DWORD PTR _index$1[ebp], eax

; 2536 : 		if (objectExists)

	movzx	eax, BYTE PTR _objectExists$2[ebp]
	test	eax, eax
	je	SHORT $LN7@GetIndexFr

; 2537 : 		{
; 2538 : 			assert(remoteSystemList[remoteSystemLookup[index].index].playerId==playerId);

	lea	eax, DWORD PTR _playerId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _index$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 824				; 00000338H
	call	??A?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QBEAAUPlayerIDAndIndex@@I@Z ; DataStructures::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>::operator[]
	imul	edx, DWORD PTR [eax+6], 2058
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	lea	ecx, DWORD PTR [ecx+edx+1]
	call	??8PlayerID@@QBE_NABU0@@Z		; PlayerID::operator==
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN12@GetIndexFr
	mov	eax, DWORD PTR ?__LINE__Var@?1??GetIndexFromPlayerID@RakPeer@@IAEHUPlayerID@@_N@Z@4JA
	add	eax, 13					; 0000000dH
	push	eax
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_1IK@PCGACABH@?$AAr?$AAe?$AAm?$AAo?$AAt?$AAe?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AAL?$AAi?$AAs?$AAt?$AA?$FL?$AAr?$AAe?$AAm?$AAo?$AAt?$AAe?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AAL?$AAo?$AAo@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN12@GetIndexFr:

; 2539 : 			return remoteSystemLookup[index].index;

	mov	eax, DWORD PTR _index$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 824				; 00000338H
	call	??A?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QBEAAUPlayerIDAndIndex@@I@Z ; DataStructures::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>::operator[]
	mov	eax, DWORD PTR [eax+6]
	jmp	SHORT $LN10@GetIndexFr

; 2540 : 		}
; 2541 : 		else

	jmp	SHORT $LN6@GetIndexFr
$LN7@GetIndexFr:

; 2542 : 			return -1;

	or	eax, -1
	jmp	SHORT $LN10@GetIndexFr
$LN6@GetIndexFr:

; 2543 : 	}
; 2544 : 	else

	jmp	SHORT $LN5@GetIndexFr
$LN8@GetIndexFr:

; 2545 : 	{
; 2546 : 		// remoteSystemList in user and network thread
; 2547 : 		for ( i = 0; i < maximumNumberOfPeers; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@GetIndexFr
$LN3@GetIndexFr:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@GetIndexFr:
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+7]
	cmp	DWORD PTR _i$[ebp], ecx
	jae	SHORT $LN5@GetIndexFr

; 2548 : 			if ( remoteSystemList[ i ].isActive && remoteSystemList[ i ].playerId == playerId )

	imul	eax, DWORD PTR _i$[ebp], 2058
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	movzx	eax, BYTE PTR [edx+eax]
	test	eax, eax
	je	SHORT $LN1@GetIndexFr
	lea	eax, DWORD PTR _playerId$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 2058
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+820]
	lea	ecx, DWORD PTR [eax+ecx+1]
	call	??8PlayerID@@QBE_NABU0@@Z		; PlayerID::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@GetIndexFr

; 2549 : 				return i;

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $LN10@GetIndexFr
$LN1@GetIndexFr:

; 2550 : 	}

	jmp	SHORT $LN3@GetIndexFr
$LN5@GetIndexFr:

; 2551 : 
; 2552 : 	return -1;

	or	eax, -1
$LN10@GetIndexFr:

; 2553 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN15@GetIndexFr
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN15@GetIndexFr:
	DD	1
	DD	$LN14@GetIndexFr
$LN14@GetIndexFr:
	DD	-29					; ffffffe3H
	DD	1
	DD	$LN13@GetIndexFr
$LN13@GetIndexFr:
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
?GetIndexFromPlayerID@RakPeer@@IAEHUPlayerID@@_N@Z ENDP	; RakPeer::GetIndexFromPlayerID
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?ReceiveIgnoreRPC@RakPeer@@IAEPAUPacket@@XZ
_TEXT	SEGMENT
tv188 = -268						; size = 4
tv85 = -268						; size = 4
_i$ = -68						; size = 4
_offset$ = -56						; size = 4
_pluginResult$ = -44					; size = 4
_threadPacket$ = -32					; size = 4
_packet$ = -20						; size = 4
_this$ = -8						; size = 4
?ReceiveIgnoreRPC@RakPeer@@IAEPAUPacket@@XZ PROC	; RakPeer::ReceiveIgnoreRPC, COMDAT
; _this$ = ecx

; 927  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-268]
	mov	ecx, 67					; 00000043H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 928  : 	if ( !( IsActive() ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN19@ReceiveIgn

; 929  : 		return 0;

	xor	eax, eax
	jmp	$LN20@ReceiveIgn
$LN19@ReceiveIgn:

; 930  : 
; 931  : 	Packet *packet;
; 932  : 	Packet **threadPacket;
; 933  : 	PluginReceiveResult pluginResult;
; 934  : 
; 935  : 	int offset;
; 936  : 	unsigned int i;
; 937  : 
; 938  : 	for (i=0; i < messageHandlerList.Size(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN18@ReceiveIgn
$LN17@ReceiveIgn:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN18@ReceiveIgn:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 941				; 000003adH
	call	?Size@?$List@PAVPluginInterface@@@DataStructures@@QBEIXZ ; DataStructures::List<PluginInterface *>::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN15@ReceiveIgn

; 939  : 	{
; 940  : 		messageHandlerList[i]->Update(this);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 941				; 000003adH
	call	??A?$List@PAVPluginInterface@@@DataStructures@@QBEAAPAVPluginInterface@@I@Z ; DataStructures::List<PluginInterface *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv85[ebp], ecx
	mov	esi, esp
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR tv85[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv85[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 941  : 	}

	jmp	SHORT $LN17@ReceiveIgn
$LN15@ReceiveIgn:

; 942  : 
; 943  : 	do 
; 944  : 	{
; 945  : #ifdef _RAKNET_THREADSAFE
; 946  : 		rakPeerMutexes[transferToPacketQueue_Mutex].Lock();
; 947  : #endif
; 948  : 		// Take all the messages off the queue so if the user pushes them back they are really pushed back, and not just at the end of the immediate write
; 949  : 		threadPacket=packetSingleProducerConsumer.ReadLock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2498				; 000009c2H
	call	?ReadLock@?$SingleProducerConsumer@PAUPacket@@@DataStructures@@QAEPAPAUPacket@@XZ ; DataStructures::SingleProducerConsumer<Packet *>::ReadLock
	mov	DWORD PTR _threadPacket$[ebp], eax
$LN12@ReceiveIgn:

; 950  : 		while (threadPacket)

	cmp	DWORD PTR _threadPacket$[ebp], 0
	je	SHORT $LN11@ReceiveIgn

; 951  : 		{
; 952  : 			packet=*threadPacket;

	mov	eax, DWORD PTR _threadPacket$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _packet$[ebp], ecx

; 953  : 			packetSingleProducerConsumer.ReadUnlock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2498				; 000009c2H
	call	?ReadUnlock@?$SingleProducerConsumer@PAUPacket@@@DataStructures@@QAEXXZ ; DataStructures::SingleProducerConsumer<Packet *>::ReadUnlock

; 954  : 			threadPacket=packetSingleProducerConsumer.ReadLock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2498				; 000009c2H
	call	?ReadLock@?$SingleProducerConsumer@PAUPacket@@@DataStructures@@QAEPAPAUPacket@@XZ ; DataStructures::SingleProducerConsumer<Packet *>::ReadLock
	mov	DWORD PTR _threadPacket$[ebp], eax

; 955  : 			packetPool.Push(packet);

	lea	eax, DWORD PTR _packet$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2522				; 000009daH
	call	?Push@?$Queue@PAUPacket@@@DataStructures@@QAEXABQAUPacket@@@Z ; DataStructures::Queue<Packet *>::Push

; 956  : 		}

	jmp	SHORT $LN12@ReceiveIgn
$LN11@ReceiveIgn:

; 957  : #ifdef _RAKNET_THREADSAFE
; 958  : 		rakPeerMutexes[transferToPacketQueue_Mutex].Unlock();
; 959  : #endif
; 960  : 
; 961  : #ifdef _MSC_VER
; 962  : #pragma warning( disable : 4127 ) // warning C4127: conditional expression is constant
; 963  : #endif
; 964  : 
; 965  : #ifdef _RAKNET_THREADSAFE
; 966  : 		rakPeerMutexes[packetPool_Mutex].Lock();
; 967  : #endif
; 968  : 		if (packetPool.Size()==0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2522				; 000009daH
	call	?Size@?$Queue@PAUPacket@@@DataStructures@@QBEIXZ ; DataStructures::Queue<Packet *>::Size
	test	eax, eax
	jne	SHORT $LN10@ReceiveIgn

; 969  : 		{
; 970  : #ifdef _RAKNET_THREADSAFE
; 971  : 			rakPeerMutexes[packetPool_Mutex].Unlock();
; 972  : #endif
; 973  : 			return 0;

	xor	eax, eax
	jmp	$LN20@ReceiveIgn
$LN10@ReceiveIgn:

; 974  : 		}
; 975  : 
; 976  : 		packet = packetPool.Pop();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2522				; 000009daH
	call	?Pop@?$Queue@PAUPacket@@@DataStructures@@QAEPAUPacket@@XZ ; DataStructures::Queue<Packet *>::Pop
	mov	DWORD PTR _packet$[ebp], eax

; 977  : #ifdef _RAKNET_THREADSAFE
; 978  : 		rakPeerMutexes[packetPool_Mutex].Unlock();
; 979  : #endif
; 980  : 		if ( ( packet->length >= sizeof(unsigned char) + sizeof( RakNetTime ) ) &&
; 981  : 			( (unsigned char) packet->data[ 0 ] == ID_TIMESTAMP ) )

	mov	eax, DWORD PTR _packet$[ebp]
	cmp	DWORD PTR [eax+8], 5
	jb	SHORT $LN9@ReceiveIgn
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _packet$[ebp]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax+ecx]
	cmp	ecx, 36					; 00000024H
	jne	SHORT $LN9@ReceiveIgn

; 982  : 		{
; 983  : 			offset = sizeof(unsigned char);

	mov	DWORD PTR _offset$[ebp], 1

; 984  : 			ShiftIncomingTimestamp( packet->data + offset, packet->playerId );

	mov	eax, DWORD PTR _packet$[ebp]
	add	eax, 2
	sub	esp, 8
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	ax, WORD PTR [eax+4]
	mov	WORD PTR [ecx+4], ax
	mov	ecx, DWORD PTR _packet$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, DWORD PTR _offset$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShiftIncomingTimestamp@RakPeer@@IBEXPAEUPlayerID@@@Z ; RakPeer::ShiftIncomingTimestamp
$LN9@ReceiveIgn:

; 985  : 		}
; 986  : 		if ( (unsigned char) packet->data[ 0 ] == ID_RPC_REPLY )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _packet$[ebp]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax+ecx]
	cmp	ecx, 20					; 00000014H
	jne	SHORT $LN8@ReceiveIgn

; 987  : 		{
; 988  : 			HandleRPCReplyPacket( ( char* ) packet->data, packet->length, packet->playerId );

	mov	eax, DWORD PTR _packet$[ebp]
	add	eax, 2
	sub	esp, 8
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	ax, WORD PTR [eax+4]
	mov	WORD PTR [ecx+4], ax
	mov	ecx, DWORD PTR _packet$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _packet$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HandleRPCReplyPacket@RakPeer@@IAEXPBDHUPlayerID@@@Z ; RakPeer::HandleRPCReplyPacket

; 989  : 			DeallocatePacket( packet );

	mov	esi, esp
	mov	eax, DWORD PTR _packet$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 990  : 			packet=0; // Will do the loop again and get another packet

	mov	DWORD PTR _packet$[ebp], 0

; 991  : 		}
; 992  : 		else

	jmp	$LN14@ReceiveIgn
$LN8@ReceiveIgn:

; 993  : 		{
; 994  : 			for (i=0; i < messageHandlerList.Size(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@ReceiveIgn
$LN5@ReceiveIgn:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@ReceiveIgn:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 941				; 000003adH
	call	?Size@?$List@PAVPluginInterface@@@DataStructures@@QBEIXZ ; DataStructures::List<PluginInterface *>::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	$LN14@ReceiveIgn

; 995  : 			{
; 996  : 				pluginResult=messageHandlerList[i]->OnReceive(this, packet);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 941				; 000003adH
	call	??A?$List@PAVPluginInterface@@@DataStructures@@QBEAAPAVPluginInterface@@I@Z ; DataStructures::List<PluginInterface *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv188[ebp], ecx
	mov	esi, esp
	mov	edx, DWORD PTR _packet$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv188[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv188[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pluginResult$[ebp], eax

; 997  : 				if (pluginResult==RR_STOP_PROCESSING_AND_DEALLOCATE)

	cmp	DWORD PTR _pluginResult$[ebp], 0
	jne	SHORT $LN3@ReceiveIgn

; 998  : 				{
; 999  : 					DeallocatePacket( packet );

	mov	esi, esp
	mov	eax, DWORD PTR _packet$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1000 : 					packet=0; // Will do the loop again and get another packet

	mov	DWORD PTR _packet$[ebp], 0

; 1001 : 					break; // break out of the enclosing for

	jmp	SHORT $LN14@ReceiveIgn
	jmp	SHORT $LN2@ReceiveIgn
$LN3@ReceiveIgn:

; 1002 : 				}
; 1003 : 				else if (pluginResult==RR_STOP_PROCESSING)

	cmp	DWORD PTR _pluginResult$[ebp], 2
	jne	SHORT $LN2@ReceiveIgn

; 1004 : 				{
; 1005 : 					packet=0;

	mov	DWORD PTR _packet$[ebp], 0

; 1006 : 					break;

	jmp	SHORT $LN14@ReceiveIgn
$LN2@ReceiveIgn:

; 1007 : 				}
; 1008 : 			}

	jmp	$LN5@ReceiveIgn
$LN14@ReceiveIgn:

; 1009 : 		}
; 1010 : 
; 1011 : 	} while(packet==0);

	cmp	DWORD PTR _packet$[ebp], 0
	je	$LN15@ReceiveIgn

; 1012 : 
; 1013 : #ifdef _DEBUG
; 1014 : 	assert( packet->data );

	mov	eax, DWORD PTR _packet$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN22@ReceiveIgn
	mov	ecx, DWORD PTR ?__LINE__Var@?1??ReceiveIgnoreRPC@RakPeer@@IAEPAUPacket@@XZ@4JA
	add	ecx, 87					; 00000057H
	push	ecx
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_1BK@NGDKLLMA@?$AAp?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN22@ReceiveIgn:

; 1015 : #endif
; 1016 : 
; 1017 : 	return packet;

	mov	eax, DWORD PTR _packet$[ebp]
$LN20@ReceiveIgn:

; 1018 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN25@ReceiveIgn
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 268				; 0000010cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN25@ReceiveIgn:
	DD	1
	DD	$LN24@ReceiveIgn
$LN24@ReceiveIgn:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN23@ReceiveIgn
$LN23@ReceiveIgn:
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	0
?ReceiveIgnoreRPC@RakPeer@@IAEPAUPacket@@XZ ENDP	; RakPeer::ReceiveIgnoreRPC
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?UpdateNetworkLoop@@YGIPAX@Z
_TEXT	SEGMENT
_success$ = -48						; size = 4
_dueTime$ = -36						; size = 8
_timerHandle$ = -20					; size = 4
_rakPeer$ = -8						; size = 4
_arguments$ = 8						; size = 4
?UpdateNetworkLoop@@YGIPAX@Z PROC			; UpdateNetworkLoop, COMDAT

; 4961 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4962 : 	RakPeer * rakPeer = ( RakPeer * ) arguments;

	mov	eax, DWORD PTR _arguments$[ebp]
	mov	DWORD PTR _rakPeer$[ebp], eax

; 4963 : 	// RakNetTime time;
; 4964 : 
; 4965 : #ifdef __USE_IO_COMPLETION_PORTS
; 4966 : 
; 4967 : 	AsynchronousFileIO::Instance()->IncreaseUserCount();
; 4968 : #endif
; 4969 : 
; 4970 : 	// 11/15/05 - this is slower than Sleep()
; 4971 : #ifdef _WIN32
; 4972 : #if (_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)
; 4973 : 	// Lets see if these timers give better performance than Sleep
; 4974 : 	HANDLE timerHandle;
; 4975 : 	LARGE_INTEGER dueTime;
; 4976 : 
; 4977 : 	if ( rakPeer->threadSleepTimer <= 0 )

	mov	eax, DWORD PTR _rakPeer$[ebp]
	cmp	DWORD PTR [eax+2066], 0
	jg	SHORT $LN4@UpdateNetw

; 4978 : 		rakPeer->threadSleepTimer = 1;

	mov	eax, DWORD PTR _rakPeer$[ebp]
	mov	DWORD PTR [eax+2066], 1
$LN4@UpdateNetw:

; 4979 : 
; 4980 : 	// 2nd parameter of false means synchronization timer instead of manual-reset timer
; 4981 : 	timerHandle = CreateWaitableTimer( NULL, FALSE, 0 );

	mov	esi, esp
	push	0
	push	0
	push	0
	call	DWORD PTR __imp__CreateWaitableTimerA@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _timerHandle$[ebp], eax

; 4982 : 
; 4983 : 	assert( timerHandle );

	cmp	DWORD PTR _timerHandle$[ebp], 0
	jne	SHORT $LN7@UpdateNetw
	mov	eax, DWORD PTR ?__LINE__Var@?1??UpdateNetworkLoop@@YGIPAX@Z@4JA
	add	eax, 22					; 00000016H
	push	eax
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_1BI@JFBHHBPJ@?$AAt?$AAi?$AAm?$AAe?$AAr?$AAH?$AAa?$AAn?$AAd?$AAl?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN7@UpdateNetw:

; 4984 : 
; 4985 : 	dueTime.QuadPart = -10000 * rakPeer->threadSleepTimer; // 10000 is 1 ms?

	mov	eax, DWORD PTR _rakPeer$[ebp]
	imul	eax, DWORD PTR [eax+2066], -10000
	cdq
	mov	DWORD PTR _dueTime$[ebp], eax
	mov	DWORD PTR _dueTime$[ebp+4], edx

; 4986 : 
; 4987 : 	BOOL success = SetWaitableTimer( timerHandle, &dueTime, rakPeer->threadSleepTimer, NULL, NULL, FALSE );

	mov	esi, esp
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _rakPeer$[ebp]
	mov	ecx, DWORD PTR [eax+2066]
	push	ecx
	lea	edx, DWORD PTR _dueTime$[ebp]
	push	edx
	mov	eax, DWORD PTR _timerHandle$[ebp]
	push	eax
	call	DWORD PTR __imp__SetWaitableTimer@24
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _success$[ebp], eax

; 4988 : 
; 4989 : 	assert( success );

	cmp	DWORD PTR _success$[ebp], 0
	jne	SHORT $LN8@UpdateNetw
	mov	eax, DWORD PTR ?__LINE__Var@?1??UpdateNetworkLoop@@YGIPAX@Z@4JA
	add	eax, 28					; 0000001cH
	push	eax
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_1BA@ICANLBCA@?$AAs?$AAu?$AAc?$AAc?$AAe?$AAs?$AAs?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN8@UpdateNetw:

; 4990 : 
; 4991 : #endif
; 4992 : #endif
; 4993 : 
; 4994 : #ifdef _RAKNET_THREADSAFE
; 4995 : 	#pragma message("-- RakNet: _RAKNET_THREADSAFE defined.  Safe to use multiple threads on the same instance of RakPeer (Slow!). --")
; 4996 : #else
; 4997 : 	#pragma message("-- RakNet: _RAKNET_THREADSAFE not defined.  Do NOT use multiple threads on the same instance of RakPeer (Fast!). --")
; 4998 : #endif
; 4999 : 
; 5000 : 	rakPeer->isMainLoopThreadActive = true;

	mov	eax, DWORD PTR _rakPeer$[ebp]
	mov	BYTE PTR [eax+5], 1
$LN3@UpdateNetw:

; 5001 : 
; 5002 : 	while ( rakPeer->endThreads == false )

	mov	eax, DWORD PTR _rakPeer$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN2@UpdateNetw

; 5003 : 	{
; 5004 : 		rakPeer->RunUpdateCycle();

	mov	ecx, DWORD PTR _rakPeer$[ebp]
	call	?RunUpdateCycle@RakPeer@@IAE_NXZ	; RakPeer::RunUpdateCycle

; 5005 : 		/*
; 5006 : #ifdef _WIN32
; 5007 : #if (_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)
; 5008 : 		#pragma message("-- RakNet: Using WaitForSingleObject. Comment out USE_WAIT_FOR_MULTIPLE_EVENTS in RakNetDefines.h if you want to use Sleep instead. --")
; 5009 : 
; 5010 : 		if ( WaitForSingleObject( timerHandle, INFINITE ) != WAIT_OBJECT_0 )
; 5011 : 		{
; 5012 : #ifdef _DEBUG
; 5013 : 
; 5014 : 			assert( 0 );
; 5015 : 	#ifdef _DO_PRINTF
; 5016 : 			printf( "WaitForSingleObject failed (%d)\n", GetLastError() );
; 5017 : 	#endif
; 5018 : #endif
; 5019 : 		}
; 5020 : 
; 5021 : #else
; 5022 : 		#pragma message("-- RakNet: Using Sleep(). Uncomment USE_WAIT_FOR_MULTIPLE_EVENTS in RakNetDefines.h if you want to use WaitForSingleObject instead. --")
; 5023 : */
; 5024 : 		if (rakPeer->threadSleepTimer>=0)

	mov	eax, DWORD PTR _rakPeer$[ebp]
	cmp	DWORD PTR [eax+2066], 0
	jl	SHORT $LN1@UpdateNetw

; 5025 : 		{
; 5026 : #if defined(USE_WAIT_FOR_MULTIPLE_EVENTS)
; 5027 : 			if (rakPeer->threadSleepTimer>0)
; 5028 : 				WSAWaitForMultipleEvents(1,&rakPeer->recvEvent,TRUE,rakPeer->threadSleepTimer,FALSE);
; 5029 : 			else
; 5030 : 				RakSleep(0);
; 5031 : #else // _WIN32
; 5032 : 				RakSleep( rakPeer->threadSleepTimer );

	mov	eax, DWORD PTR _rakPeer$[ebp]
	mov	ecx, DWORD PTR [eax+2066]
	push	ecx
	call	?RakSleep@@YAXI@Z			; RakSleep
	add	esp, 4
$LN1@UpdateNetw:

; 5033 : #endif
; 5034 : 		}
; 5035 : 	}

	jmp	SHORT $LN3@UpdateNetw
$LN2@UpdateNetw:

; 5036 : 
; 5037 : 
; 5038 : #ifdef __USE_IO_COMPLETION_PORTS
; 5039 : 	AsynchronousFileIO::Instance()->DecreaseUserCount();
; 5040 : #endif
; 5041 : 
; 5042 : 
; 5043 : 	/*
; 5044 : #ifdef _WIN32
; 5045 : #if (_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)
; 5046 : 	CloseHandle( timerHandle );
; 5047 : #endif
; 5048 : #endif
; 5049 : */
; 5050 : 
; 5051 : 	rakPeer->isMainLoopThreadActive = false;

	mov	eax, DWORD PTR _rakPeer$[ebp]
	mov	BYTE PTR [eax+5], 0

; 5052 : 
; 5053 : 	return 0;

	xor	eax, eax

; 5054 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@UpdateNetw
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN11@UpdateNetw:
	DD	1
	DD	$LN10@UpdateNetw
$LN10@UpdateNetw:
	DD	-36					; ffffffdcH
	DD	8
	DD	$LN9@UpdateNetw
$LN9@UpdateNetw:
	DB	100					; 00000064H
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
?UpdateNetworkLoop@@YGIPAX@Z ENDP			; UpdateNetworkLoop
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?ProcessNetworkPacket@@YGXIGPBDHPAVRakPeer@@@Z
_TEXT	SEGMENT
tv634 = -1376						; size = 4
tv514 = -1376						; size = 4
tv412 = -1376						; size = 4
tv376 = -1376						; size = 4
tv337 = -1376						; size = 4
tv179 = -1376						; size = 4
tv149 = -1376						; size = 4
tv95 = -1376						; size = 4
$T2 = -1368						; size = 4
$T3 = -1356						; size = 4
$T4 = -1344						; size = 4
_i$5 = -1140						; size = 4
_outBitStream$6 = -1128					; size = 273
_sendPingTime$7 = -844					; size = 4
_inBitStream$8 = -832					; size = 273
_i$9 = -508						; size = 4
_c$10 = -496						; size = 2
_i$11 = -484						; size = 4
_c$12 = -472						; size = 2
_rss$13 = -460						; size = 4
_connectionAttemptCancelled$14 = -445			; size = 1
_rcs$15 = -436						; size = 4
_rcsFirst$16 = -424					; size = 4
_temp$17 = -412						; size = 273
_time$18 = -128						; size = 8
_rcs$19 = -112						; size = 4
_rcsFirst$20 = -100					; size = 4
_i$21 = -88						; size = 4
_c$22 = -76						; size = 2
_remoteSystem$ = -64					; size = 4
_i$ = -52						; size = 4
_playerId$ = -40					; size = 6
_packet$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_binaryAddress$ = 8					; size = 4
_port$ = 12						; size = 2
_data$ = 16						; size = 4
_length$ = 20						; size = 4
_rakPeer$ = 24						; size = 4
?ProcessNetworkPacket@@YGXIGPBDHPAVRakPeer@@@Z PROC	; ProcessNetworkPacket, COMDAT

; 3871 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ProcessNetworkPacket@@YGXIGPBDHPAVRakPeer@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1364				; 00000554H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-1376]
	mov	ecx, 341				; 00000155H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 3872 : 	Packet *packet;
; 3873 : 	PlayerID playerId;
; 3874 : 	unsigned i;
; 3875 : 	RakPeer::RemoteSystemStruct *remoteSystem;
; 3876 : 	playerId.binaryAddress = binaryAddress;

	mov	eax, DWORD PTR _binaryAddress$[ebp]
	mov	DWORD PTR _playerId$[ebp], eax

; 3877 : 	playerId.port = port;

	mov	ax, WORD PTR _port$[ebp]
	mov	WORD PTR _playerId$[ebp+4], ax

; 3878 : 
; 3879 : #if !defined(_COMPATIBILITY_1)
; 3880 : 	if (rakPeer->IsBanned( rakPeer->PlayerIDToDottedIP( playerId ) ))

	mov	esi, esp
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	eax, DWORD PTR _rakPeer$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	mov	eax, DWORD PTR [edx+184]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	movzx	ecx, al
	test	ecx, ecx
	je	$LN76@ProcessNet

; 3881 : 	{
; 3882 : 		for (i=0; i < rakPeer->messageHandlerList.Size(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN75@ProcessNet
$LN74@ProcessNet:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN75@ProcessNet:
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	add	ecx, 941				; 000003adH
	call	?Size@?$List@PAVPluginInterface@@@DataStructures@@QBEIXZ ; DataStructures::List<PluginInterface *>::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN73@ProcessNet

; 3883 : 			rakPeer->messageHandlerList[i]->OnDirectSocketReceive(data, length*8, playerId);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	add	ecx, 941				; 000003adH
	call	??A?$List@PAVPluginInterface@@@DataStructures@@QBEAAPAVPluginInterface@@I@Z ; DataStructures::List<PluginInterface *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv95[ebp], ecx
	mov	esi, esp
	sub	esp, 8
	mov	edx, esp
	mov	eax, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [edx], eax
	mov	cx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [edx+4], cx
	mov	edx, DWORD PTR _length$[ebp]
	shl	edx, 3
	push	edx
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv95[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv95[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN74@ProcessNet
$LN73@ProcessNet:

; 3884 : 
; 3885 : 		char c[2];
; 3886 : 		c[0] = ID_CONNECTION_BANNED;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	BYTE PTR _c$22[ebp+ecx], 32		; 00000020H

; 3887 : 		c[1] = 0; // Pad, some routers apparently block 1 byte packets

	mov	DWORD PTR $T3[ebp], 1
	cmp	DWORD PTR $T3[ebp], 2
	jae	SHORT $LN79@ProcessNet
	jmp	SHORT $LN80@ProcessNet
$LN79@ProcessNet:
	call	___report_rangecheckfailure
$LN80@ProcessNet:
	mov	eax, DWORD PTR $T3[ebp]
	mov	BYTE PTR _c$22[ebp+eax], 0

; 3888 : 
; 3889 : 		unsigned i;
; 3890 : 		for (i=0; i < rakPeer->messageHandlerList.Size(); i++)

	mov	DWORD PTR _i$21[ebp], 0
	jmp	SHORT $LN72@ProcessNet
$LN71@ProcessNet:
	mov	eax, DWORD PTR _i$21[ebp]
	add	eax, 1
	mov	DWORD PTR _i$21[ebp], eax
$LN72@ProcessNet:
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	add	ecx, 941				; 000003adH
	call	?Size@?$List@PAVPluginInterface@@@DataStructures@@QBEIXZ ; DataStructures::List<PluginInterface *>::Size
	cmp	DWORD PTR _i$21[ebp], eax
	jae	SHORT $LN70@ProcessNet

; 3891 : 			rakPeer->messageHandlerList[i]->OnDirectSocketSend((char*)&c, 16, playerId);

	mov	eax, DWORD PTR _i$21[ebp]
	push	eax
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	add	ecx, 941				; 000003adH
	call	??A?$List@PAVPluginInterface@@@DataStructures@@QBEAAPAVPluginInterface@@I@Z ; DataStructures::List<PluginInterface *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv149[ebp], ecx
	mov	esi, esp
	sub	esp, 8
	mov	edx, esp
	mov	eax, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [edx], eax
	mov	cx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [edx+4], cx
	push	16					; 00000010H
	lea	edx, DWORD PTR _c$22[ebp]
	push	edx
	mov	eax, DWORD PTR tv149[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv149[ebp]
	mov	eax, DWORD PTR [edx+28]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN71@ProcessNet
$LN70@ProcessNet:

; 3892 : 		SocketLayer::Instance()->SendTo( rakPeer->connectionSocket, (char*)&c, 2, playerId.binaryAddress, playerId.port );

	movzx	eax, WORD PTR _playerId$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _playerId$[ebp]
	push	ecx
	push	2
	lea	edx, DWORD PTR _c$22[ebp]
	push	edx
	mov	eax, DWORD PTR _rakPeer$[ebp]
	mov	ecx, DWORD PTR [eax+2070]
	push	ecx
	call	?Instance@SocketLayer@@SAPAV1@XZ	; SocketLayer::Instance
	mov	ecx, eax
	call	?SendTo@SocketLayer@@QAEHIPBDHIG@Z	; SocketLayer::SendTo

; 3893 : 
; 3894 : 		return;

	jmp	$LN78@ProcessNet
$LN76@ProcessNet:

; 3895 : 	}
; 3896 : #endif
; 3897 : 
; 3898 : 	//printf("ProcessNetPacket(0x%X,%u)\n",rakPeer->myPlayerId.binaryAddress,rakPeer->myPlayerId.port);
; 3899 :     
; 3900 : 	// We didn't check this datagram to see if it came from a connected system or not yet.
; 3901 : 	// Therefore, this datagram must be under 17 bits - otherwise it may be normal network traffic as the min size for a raknet send is 17 bits
; 3902 : 	if ((unsigned char)(data)[0] == (unsigned char) ID_OPEN_CONNECTION_REPLY && length <= sizeof(unsigned char)*2)

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 17					; 00000011H
	jne	$LN69@ProcessNet
	cmp	DWORD PTR _length$[ebp], 2
	ja	$LN69@ProcessNet

; 3903 : 	{
; 3904 : 		for (i=0; i < rakPeer->messageHandlerList.Size(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN68@ProcessNet
$LN67@ProcessNet:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN68@ProcessNet:
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	add	ecx, 941				; 000003adH
	call	?Size@?$List@PAVPluginInterface@@@DataStructures@@QBEIXZ ; DataStructures::List<PluginInterface *>::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN66@ProcessNet

; 3905 : 			rakPeer->messageHandlerList[i]->OnDirectSocketReceive(data, length*8, playerId);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	add	ecx, 941				; 000003adH
	call	??A?$List@PAVPluginInterface@@@DataStructures@@QBEAAPAVPluginInterface@@I@Z ; DataStructures::List<PluginInterface *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv179[ebp], ecx
	mov	esi, esp
	sub	esp, 8
	mov	edx, esp
	mov	eax, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [edx], eax
	mov	cx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [edx+4], cx
	mov	edx, DWORD PTR _length$[ebp]
	shl	edx, 3
	push	edx
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv179[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv179[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN67@ProcessNet
$LN66@ProcessNet:

; 3906 : 
; 3907 : 		// Verify that we were waiting for this
; 3908 : 	//	bool acceptOpenConnection;
; 3909 : //		int actionToTake=0;
; 3910 : //		char data[MAX_OFFLINE_DATA_LENGTH];
; 3911 : 		RakPeer::RequestedConnectionStruct *rcsFirst, *rcs;
; 3912 : 		rcsFirst = rakPeer->requestedConnectionList.ReadLock();

	mov	ecx, DWORD PTR _rakPeer$[ebp]
	add	ecx, 953				; 000003b9H
	call	?ReadLock@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEPAURequestedConnectionStruct@RakPeer@@XZ ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::ReadLock
	mov	DWORD PTR _rcsFirst$20[ebp], eax

; 3913 : 		rcs=rcsFirst;

	mov	eax, DWORD PTR _rcsFirst$20[ebp]
	mov	DWORD PTR _rcs$19[ebp], eax
$LN65@ProcessNet:

; 3914 : 	//	acceptOpenConnection=false;
; 3915 : 		while (rcs)

	cmp	DWORD PTR _rcs$19[ebp], 0
	je	$LN64@ProcessNet

; 3916 : 		{
; 3917 : 			// Scan through the requested connection queue and process any elements whose playerId matches the player we just got this packet from.
; 3918 : 			// If it is the first element in the queue, remove it from the queue.  Otherwise, set the playerId to UNASSIGNED_PLAYER_ID to cancel it out of order.
; 3919 : 			if (rcs->playerId==playerId)

	lea	eax, DWORD PTR _playerId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rcs$19[ebp]
	call	??8PlayerID@@QBE_NABU0@@Z		; PlayerID::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	$LN63@ProcessNet

; 3920 : 			{
; 3921 : 				// Go ahead and process this request
; 3922 : 			//	acceptOpenConnection=true;
; 3923 : 
; 3924 : 				// Store the action (may be multiple actions to take at once)
; 3925 : 		//		actionToTake|=(int)rcs->actionToTake;
; 3926 : 				assert(rcs->actionToTake==RakPeer::RequestedConnectionStruct::CONNECT);

	mov	eax, DWORD PTR _rcs$19[ebp]
	cmp	DWORD PTR [eax+274], 1
	je	SHORT $LN81@ProcessNet
	mov	ecx, DWORD PTR ?__LINE__Var@?1??ProcessNetworkPacket@@YGXIGPBDHPAVRakPeer@@@Z@4JA
	add	ecx, 55					; 00000037H
	push	ecx
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_1HO@KBDHKDHK@?$AAr?$AAc?$AAs?$AA?9?$AA?$DO?$AAa?$AAc?$AAt?$AAi?$AAo?$AAn?$AAT?$AAo?$AAT?$AAa?$AAk?$AAe?$AA?$DN?$AA?$DN?$AAR?$AAa?$AAk?$AAP?$AAe?$AAe?$AAr?$AA?3?$AA?3?$AAR?$AAe?$AAq?$AAu@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN81@ProcessNet:

; 3927 : 
; 3928 : 				// You might get this when already connected because of cross-connections
; 3929 : 				remoteSystem=rakPeer->GetRemoteSystemFromPlayerID( playerId, true, true );

	push	1
	push	1
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	call	?GetRemoteSystemFromPlayerID@RakPeer@@IBEPAURemoteSystemStruct@1@UPlayerID@@_N1@Z ; RakPeer::GetRemoteSystemFromPlayerID
	mov	DWORD PTR _remoteSystem$[ebp], eax

; 3930 : 				if (remoteSystem==0)

	cmp	DWORD PTR _remoteSystem$[ebp], 0
	jne	SHORT $LN62@ProcessNet

; 3931 : 					remoteSystem=rakPeer->AssignPlayerIDToRemoteSystemList(playerId, RakPeer::RemoteSystemStruct::UNVERIFIED_SENDER);

	push	6
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	call	?AssignPlayerIDToRemoteSystemList@RakPeer@@IAEPAURemoteSystemStruct@1@UPlayerID@@W4ConnectMode@21@@Z ; RakPeer::AssignPlayerIDToRemoteSystemList
	mov	DWORD PTR _remoteSystem$[ebp], eax
$LN62@ProcessNet:

; 3932 : 
; 3933 : 				if (remoteSystem)

	cmp	DWORD PTR _remoteSystem$[ebp], 0
	je	$LN61@ProcessNet

; 3934 : 				{
; 3935 : 					RakNetTimeNS time = RakNet::GetTimeNS();

	call	?GetTimeNS@RakNet@@YA_JXZ		; RakNet::GetTimeNS
	mov	DWORD PTR _time$18[ebp], eax
	mov	DWORD PTR _time$18[ebp+4], edx

; 3936 : 					remoteSystem->connectMode=RakPeer::RemoteSystemStruct::REQUESTED_CONNECTION;

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	mov	DWORD PTR [eax+2054], 4

; 3937 : 					remoteSystem->weInitiatedTheConnection=true;

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	mov	BYTE PTR [eax+1703], 1

; 3938 : 
; 3939 : 					RakNet::BitStream temp;

	lea	ecx, DWORD PTR _temp$17[ebp]
	call	??0BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3940 : 
; 3941 : 					temp.Write( (unsigned char) ID_CONNECTION_REQUEST );

	push	8
	lea	ecx, DWORD PTR _temp$17[ebp]
	call	??$Write@E@BitStream@RakNet@@QAEXE@Z	; RakNet::BitStream::Write<unsigned char>

; 3942 : 					if ( rcs->outgoingPasswordLength > 0 )

	mov	eax, DWORD PTR _rcs$19[ebp]
	movzx	ecx, BYTE PTR [eax+273]
	test	ecx, ecx
	jle	SHORT $LN60@ProcessNet

; 3943 : 						temp.Write( ( char* ) rcs->outgoingPassword,  rcs->outgoingPasswordLength );

	mov	eax, DWORD PTR _rcs$19[ebp]
	movzx	ecx, BYTE PTR [eax+273]
	push	ecx
	mov	edx, DWORD PTR _rcs$19[ebp]
	add	edx, 17					; 00000011H
	push	edx
	lea	ecx, DWORD PTR _temp$17[ebp]
	call	?Write@BitStream@RakNet@@QAEXPBDH@Z	; RakNet::BitStream::Write
$LN60@ProcessNet:

; 3944 : 					rakPeer->SendImmediate((char*)temp.GetData(), temp.GetNumberOfBitsUsed(), SYSTEM_PRIORITY, RELIABLE, 0, playerId, false, false, time );

	mov	eax, DWORD PTR _time$18[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _time$18[ebp]
	push	ecx
	push	0
	push	0
	sub	esp, 8
	mov	edx, esp
	mov	eax, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [edx], eax
	mov	cx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [edx+4], cx
	push	0
	push	2
	push	0
	lea	ecx, DWORD PTR _temp$17[ebp]
	call	?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBitsUsed
	push	eax
	lea	ecx, DWORD PTR _temp$17[ebp]
	call	?GetData@BitStream@RakNet@@QBEPAEXZ	; RakNet::BitStream::GetData
	push	eax
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	call	?SendImmediate@RakPeer@@IAE_NPADHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N4_J@Z ; RakPeer::SendImmediate

; 3945 : 				}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _temp$17[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
$LN61@ProcessNet:

; 3946 : 
; 3947 : 				if (rcs==rcsFirst)

	mov	eax, DWORD PTR _rcs$19[ebp]
	cmp	eax, DWORD PTR _rcsFirst$20[ebp]
	jne	SHORT $LN59@ProcessNet

; 3948 : 				{
; 3949 : 					// Delete the head of the queue
; 3950 : 					rakPeer->requestedConnectionList.ReadUnlock();

	mov	ecx, DWORD PTR _rakPeer$[ebp]
	add	ecx, 953				; 000003b9H
	call	?ReadUnlock@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEXXZ ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::ReadUnlock

; 3951 : 					rcsFirst=rakPeer->requestedConnectionList.ReadLock();

	mov	ecx, DWORD PTR _rakPeer$[ebp]
	add	ecx, 953				; 000003b9H
	call	?ReadLock@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEPAURequestedConnectionStruct@RakPeer@@XZ ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::ReadLock
	mov	DWORD PTR _rcsFirst$20[ebp], eax

; 3952 : 					rcs=rcsFirst;

	mov	eax, DWORD PTR _rcsFirst$20[ebp]
	mov	DWORD PTR _rcs$19[ebp], eax

; 3953 : 					continue;

	jmp	$LN65@ProcessNet

; 3954 : 				}
; 3955 : 				else

	jmp	SHORT $LN63@ProcessNet
$LN59@ProcessNet:

; 3956 : 				{
; 3957 : 					// Cancel this out of order element of the queue - we are handling it now.
; 3958 : 					rcs->playerId=UNASSIGNED_PLAYER_ID;

	push	OFFSET _UNASSIGNED_PLAYER_ID
	mov	ecx, DWORD PTR _rcs$19[ebp]
	call	??4PlayerID@@QAEAAU0@ABU0@@Z		; PlayerID::operator=
$LN63@ProcessNet:

; 3959 : 				}
; 3960 : 			}
; 3961 : 
; 3962 : 			rcs=rakPeer->requestedConnectionList.ReadLock();

	mov	ecx, DWORD PTR _rakPeer$[ebp]
	add	ecx, 953				; 000003b9H
	call	?ReadLock@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEPAURequestedConnectionStruct@RakPeer@@XZ ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::ReadLock
	mov	DWORD PTR _rcs$19[ebp], eax

; 3963 : 		}

	jmp	$LN65@ProcessNet
$LN64@ProcessNet:

; 3964 : 
; 3965 : 		// Go back to the current head of the queue
; 3966 : 		if (rcsFirst)

	cmp	DWORD PTR _rcsFirst$20[ebp], 0
	je	SHORT $LN57@ProcessNet

; 3967 : 			rakPeer->requestedConnectionList.CancelReadLock(rcsFirst);

	mov	eax, DWORD PTR _rcsFirst$20[ebp]
	push	eax
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	add	ecx, 953				; 000003b9H
	call	?CancelReadLock@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEXPAURequestedConnectionStruct@RakPeer@@@Z ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::CancelReadLock
$LN57@ProcessNet:

; 3968 : 
; 3969 : 		/*
; 3970 : 		if (acceptOpenConnection)
; 3971 : 		{
; 3972 : 			// You might get this when already connected because of cross-connections
; 3973 : 			remoteSystem=rakPeer->GetRemoteSystemFromPlayerID( playerId, true );
; 3974 : 			if (remoteSystem==0)
; 3975 : 			{
; 3976 : 				remoteSystem=rakPeer->AssignPlayerIDToRemoteSystemList(playerId, RakPeer::RemoteSystemStruct::UNVERIFIED_SENDER);
; 3977 : 			}
; 3978 : 			if (remoteSystem)
; 3979 : 			{
; 3980 : 				RakNetTime time = RakNet::GetTime();
; 3981 : 				if (actionToTake & RakPeer::RequestedConnectionStruct::CONNECT)
; 3982 : 				{
; 3983 : 					remoteSystem->connectMode=RakPeer::RemoteSystemStruct::REQUESTED_CONNECTION;
; 3984 : 					remoteSystem->weInitiatedTheConnection=true;
; 3985 : 
; 3986 : 					RakNet::BitStream temp;
; 3987 : 
; 3988 : 					temp.Write( (unsigned char) ID_CONNECTION_REQUEST );
; 3989 : 					if ( rakPeer->outgoingPasswordLength > 0 )
; 3990 : 						temp.Write( ( char* ) rakPeer->outgoingPassword,  rakPeer->outgoingPasswordLength );
; 3991 : 					rakPeer->SendImmediate((char*)temp.GetData(), temp.GetNumberOfBitsUsed(), SYSTEM_PRIORITY, RELIABLE, 0, playerId, false, false, time );
; 3992 : 				}
; 3993 : 			}
; 3994 : 		}
; 3995 : 		*/
; 3996 : 
; 3997 : 		return;

	jmp	$LN78@ProcessNet

; 3998 : 	}
; 3999 : 	else if (((unsigned char)(data)[0] == (MessageID)ID_CONNECTION_ATTEMPT_FAILED ||

	jmp	$LN56@ProcessNet
$LN69@ProcessNet:

; 4000 : 			  (unsigned char)(data)[0] == (MessageID)ID_NO_FREE_INCOMING_CONNECTIONS ||
; 4001 : 			  (unsigned char)(data)[0] == (MessageID)ID_CONNECTION_BANNED)
; 4002 : 				&& length <= sizeof(unsigned char)*2)

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 24					; 00000018H
	je	SHORT $LN54@ProcessNet
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 27					; 0000001bH
	je	SHORT $LN54@ProcessNet
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 32					; 00000020H
	jne	$LN55@ProcessNet
$LN54@ProcessNet:
	cmp	DWORD PTR _length$[ebp], 2
	ja	$LN55@ProcessNet

; 4003 : 	{
; 4004 : 		// Remove the connection attempt from the buffered commands
; 4005 : 		RakPeer::RequestedConnectionStruct *rcsFirst, *rcs;
; 4006 : 		rcsFirst = rakPeer->requestedConnectionList.ReadLock();

	mov	ecx, DWORD PTR _rakPeer$[ebp]
	add	ecx, 953				; 000003b9H
	call	?ReadLock@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEPAURequestedConnectionStruct@RakPeer@@XZ ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::ReadLock
	mov	DWORD PTR _rcsFirst$16[ebp], eax

; 4007 : 		rcs=rcsFirst;

	mov	eax, DWORD PTR _rcsFirst$16[ebp]
	mov	DWORD PTR _rcs$15[ebp], eax

; 4008 : 		bool connectionAttemptCancelled=false;

	mov	BYTE PTR _connectionAttemptCancelled$14[ebp], 0
$LN53@ProcessNet:

; 4009 : 		while (rcs)

	cmp	DWORD PTR _rcs$15[ebp], 0
	je	$LN52@ProcessNet

; 4010 : 		{
; 4011 : 			if (rcs->actionToTake==RakPeer::RequestedConnectionStruct::CONNECT && rcs->playerId==playerId)

	mov	eax, DWORD PTR _rcs$15[ebp]
	cmp	DWORD PTR [eax+274], 1
	jne	$LN51@ProcessNet
	lea	eax, DWORD PTR _playerId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rcs$15[ebp]
	call	??8PlayerID@@QBE_NABU0@@Z		; PlayerID::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN51@ProcessNet

; 4012 : 			{
; 4013 : 				connectionAttemptCancelled=true;

	mov	BYTE PTR _connectionAttemptCancelled$14[ebp], 1

; 4014 : 				if (rcs==rcsFirst)

	mov	eax, DWORD PTR _rcs$15[ebp]
	cmp	eax, DWORD PTR _rcsFirst$16[ebp]
	jne	SHORT $LN50@ProcessNet

; 4015 : 				{
; 4016 : 					rakPeer->requestedConnectionList.ReadUnlock();

	mov	ecx, DWORD PTR _rakPeer$[ebp]
	add	ecx, 953				; 000003b9H
	call	?ReadUnlock@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEXXZ ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::ReadUnlock

; 4017 : 					rcsFirst=rakPeer->requestedConnectionList.ReadLock();

	mov	ecx, DWORD PTR _rakPeer$[ebp]
	add	ecx, 953				; 000003b9H
	call	?ReadLock@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEPAURequestedConnectionStruct@RakPeer@@XZ ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::ReadLock
	mov	DWORD PTR _rcsFirst$16[ebp], eax

; 4018 : 					rcs=rcsFirst;

	mov	eax, DWORD PTR _rcsFirst$16[ebp]
	mov	DWORD PTR _rcs$15[ebp], eax

; 4019 : 				}
; 4020 : 				else

	jmp	SHORT $LN49@ProcessNet
$LN50@ProcessNet:

; 4021 : 				{
; 4022 : 					// Hole in the middle
; 4023 : 					rcs->playerId=UNASSIGNED_PLAYER_ID;

	push	OFFSET _UNASSIGNED_PLAYER_ID
	mov	ecx, DWORD PTR _rcs$15[ebp]
	call	??4PlayerID@@QAEAAU0@ABU0@@Z		; PlayerID::operator=

; 4024 : 					rcs=rakPeer->requestedConnectionList.ReadLock();

	mov	ecx, DWORD PTR _rakPeer$[ebp]
	add	ecx, 953				; 000003b9H
	call	?ReadLock@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEPAURequestedConnectionStruct@RakPeer@@XZ ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::ReadLock
	mov	DWORD PTR _rcs$15[ebp], eax
$LN49@ProcessNet:

; 4025 : 				}
; 4026 : 
; 4027 : 				continue;

	jmp	$LN53@ProcessNet
$LN51@ProcessNet:

; 4028 : 			}
; 4029 : 
; 4030 : 			rcs=rakPeer->requestedConnectionList.ReadLock();

	mov	ecx, DWORD PTR _rakPeer$[ebp]
	add	ecx, 953				; 000003b9H
	call	?ReadLock@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEPAURequestedConnectionStruct@RakPeer@@XZ ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::ReadLock
	mov	DWORD PTR _rcs$15[ebp], eax

; 4031 : 		}

	jmp	$LN53@ProcessNet
$LN52@ProcessNet:

; 4032 : 
; 4033 : 		if (rcsFirst)

	cmp	DWORD PTR _rcsFirst$16[ebp], 0
	je	SHORT $LN48@ProcessNet

; 4034 : 			rakPeer->requestedConnectionList.CancelReadLock(rcsFirst);

	mov	eax, DWORD PTR _rcsFirst$16[ebp]
	push	eax
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	add	ecx, 953				; 000003b9H
	call	?CancelReadLock@?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAEXPAURequestedConnectionStruct@RakPeer@@@Z ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::CancelReadLock
$LN48@ProcessNet:

; 4035 : 
; 4036 : 		if (connectionAttemptCancelled)

	movzx	eax, BYTE PTR _connectionAttemptCancelled$14[ebp]
	test	eax, eax
	je	SHORT $LN47@ProcessNet

; 4037 : 		{
; 4038 : 			// Tell user of connection attempt failed
; 4039 : 			packet=AllocPacket(sizeof( char ));

	push	1
	call	?AllocPacket@@YAPAUPacket@@I@Z		; AllocPacket
	add	esp, 4
	mov	DWORD PTR _packet$[ebp], eax

; 4040 : 			packet->data[ 0 ] = data[0]; // Attempted a connection and couldn't

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _packet$[ebp]
	mov	edx, DWORD PTR [edx+16]
	mov	esi, DWORD PTR _data$[ebp]
	mov	cl, BYTE PTR [esi+ecx]
	mov	BYTE PTR [eax+edx], cl

; 4041 : 			packet->bitSize = ( sizeof( char ) * 8);

	mov	eax, DWORD PTR _packet$[ebp]
	mov	DWORD PTR [eax+12], 8

; 4042 : 			packet->playerId = playerId;

	lea	eax, DWORD PTR _playerId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _packet$[ebp]
	add	ecx, 2
	call	??4PlayerID@@QAEAAU0@ABU0@@Z		; PlayerID::operator=

; 4043 : 			packet->playerIndex = 65535;

	mov	eax, 65535				; 0000ffffH
	mov	ecx, DWORD PTR _packet$[ebp]
	mov	WORD PTR [ecx], ax

; 4044 : 			rakPeer->AddPacketToProducer(packet);

	mov	eax, DWORD PTR _packet$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	call	?AddPacketToProducer@RakPeer@@IAEXPAUPacket@@@Z ; RakPeer::AddPacketToProducer
$LN47@ProcessNet:

; 4045 : 		}
; 4046 : 	}

	jmp	$LN56@ProcessNet
$LN55@ProcessNet:

; 4047 : 	// We didn't check this datagram to see if it came from a connected system or not yet.
; 4048 : 	// Therefore, this datagram must be under 17 bits - otherwise it may be normal network traffic as the min size for a raknet send is 17 bits
; 4049 : 	else if ((unsigned char)(data)[0] == ID_OPEN_CONNECTION_REQUEST && length == sizeof(unsigned char)*2)

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 16					; 00000010H
	jne	$LN56@ProcessNet
	cmp	DWORD PTR _length$[ebp], 2
	jne	$LN56@ProcessNet

; 4050 : 	{
; 4051 : 		for (i=0; i < rakPeer->messageHandlerList.Size(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN44@ProcessNet
$LN43@ProcessNet:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN44@ProcessNet:
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	add	ecx, 941				; 000003adH
	call	?Size@?$List@PAVPluginInterface@@@DataStructures@@QBEIXZ ; DataStructures::List<PluginInterface *>::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN42@ProcessNet

; 4052 : 			rakPeer->messageHandlerList[i]->OnDirectSocketReceive(data, length*8, playerId);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	add	ecx, 941				; 000003adH
	call	??A?$List@PAVPluginInterface@@@DataStructures@@QBEAAPAVPluginInterface@@I@Z ; DataStructures::List<PluginInterface *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv337[ebp], ecx
	mov	esi, esp
	sub	esp, 8
	mov	edx, esp
	mov	eax, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [edx], eax
	mov	cx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [edx+4], cx
	mov	edx, DWORD PTR _length$[ebp]
	shl	edx, 3
	push	edx
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv337[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv337[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN43@ProcessNet
$LN42@ProcessNet:

; 4053 : 
; 4054 : 		// If this guy is already connected and they initiated the connection, ignore the connection request
; 4055 : 		RakPeer::RemoteSystemStruct *rss = rakPeer->GetRemoteSystemFromPlayerID( playerId, true, true );

	push	1
	push	1
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	call	?GetRemoteSystemFromPlayerID@RakPeer@@IBEPAURemoteSystemStruct@1@UPlayerID@@_N1@Z ; RakPeer::GetRemoteSystemFromPlayerID
	mov	DWORD PTR _rss$13[ebp], eax

; 4056 : 		if (rss==0 || rss->weInitiatedTheConnection==true)

	cmp	DWORD PTR _rss$13[ebp], 0
	je	SHORT $LN40@ProcessNet
	mov	eax, DWORD PTR _rss$13[ebp]
	movzx	ecx, BYTE PTR [eax+1703]
	cmp	ecx, 1
	jne	$LN41@ProcessNet
$LN40@ProcessNet:

; 4057 : 		{
; 4058 : 			// Assign new remote system
; 4059 : 			if (rss==0)

	cmp	DWORD PTR _rss$13[ebp], 0
	jne	SHORT $LN39@ProcessNet

; 4060 : 				rss=rakPeer->AssignPlayerIDToRemoteSystemList(playerId, RakPeer::RemoteSystemStruct::UNVERIFIED_SENDER);

	push	6
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	call	?AssignPlayerIDToRemoteSystemList@RakPeer@@IAEPAURemoteSystemStruct@1@UPlayerID@@W4ConnectMode@21@@Z ; RakPeer::AssignPlayerIDToRemoteSystemList
	mov	DWORD PTR _rss$13[ebp], eax
$LN39@ProcessNet:

; 4061 : 
; 4062 : 			unsigned char c[2];
; 4063 : 			if (rss) // If this guy is already connected remote system will be 0

	cmp	DWORD PTR _rss$13[ebp], 0
	je	SHORT $LN38@ProcessNet

; 4064 : 				c[0] = ID_OPEN_CONNECTION_REPLY;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	BYTE PTR _c$12[ebp+ecx], 17		; 00000011H

; 4065 : 			else

	jmp	SHORT $LN37@ProcessNet
$LN38@ProcessNet:

; 4066 : 				c[0] = ID_NO_FREE_INCOMING_CONNECTIONS;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	BYTE PTR _c$12[ebp+ecx], 27		; 0000001bH
$LN37@ProcessNet:

; 4067 : 			c[1] = 0; // Pad, some routers apparently block 1 byte packets

	mov	DWORD PTR $T4[ebp], 1
	cmp	DWORD PTR $T4[ebp], 2
	jae	SHORT $LN82@ProcessNet
	jmp	SHORT $LN83@ProcessNet
$LN82@ProcessNet:
	call	___report_rangecheckfailure
$LN83@ProcessNet:
	mov	eax, DWORD PTR $T4[ebp]
	mov	BYTE PTR _c$12[ebp+eax], 0

; 4068 : 
; 4069 : 			unsigned i;
; 4070 : 			for (i=0; i < rakPeer->messageHandlerList.Size(); i++)

	mov	DWORD PTR _i$11[ebp], 0
	jmp	SHORT $LN36@ProcessNet
$LN35@ProcessNet:
	mov	eax, DWORD PTR _i$11[ebp]
	add	eax, 1
	mov	DWORD PTR _i$11[ebp], eax
$LN36@ProcessNet:
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	add	ecx, 941				; 000003adH
	call	?Size@?$List@PAVPluginInterface@@@DataStructures@@QBEIXZ ; DataStructures::List<PluginInterface *>::Size
	cmp	DWORD PTR _i$11[ebp], eax
	jae	SHORT $LN34@ProcessNet

; 4071 : 				rakPeer->messageHandlerList[i]->OnDirectSocketSend((char*)&c, 16, playerId);

	mov	eax, DWORD PTR _i$11[ebp]
	push	eax
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	add	ecx, 941				; 000003adH
	call	??A?$List@PAVPluginInterface@@@DataStructures@@QBEAAPAVPluginInterface@@I@Z ; DataStructures::List<PluginInterface *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv376[ebp], ecx
	mov	esi, esp
	sub	esp, 8
	mov	edx, esp
	mov	eax, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [edx], eax
	mov	cx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [edx+4], cx
	push	16					; 00000010H
	lea	edx, DWORD PTR _c$12[ebp]
	push	edx
	mov	eax, DWORD PTR tv376[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv376[ebp]
	mov	eax, DWORD PTR [edx+28]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN35@ProcessNet
$LN34@ProcessNet:

; 4072 : 			SocketLayer::Instance()->SendTo( rakPeer->connectionSocket, (char*)&c, 2, playerId.binaryAddress, playerId.port );

	movzx	eax, WORD PTR _playerId$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _playerId$[ebp]
	push	ecx
	push	2
	lea	edx, DWORD PTR _c$12[ebp]
	push	edx
	mov	eax, DWORD PTR _rakPeer$[ebp]
	mov	ecx, DWORD PTR [eax+2070]
	push	ecx
	call	?Instance@SocketLayer@@SAPAV1@XZ	; SocketLayer::Instance
	mov	ecx, eax
	call	?SendTo@SocketLayer@@QAEHIPBDHIG@Z	; SocketLayer::SendTo

; 4073 : 
; 4074 : 			return;

	jmp	$LN78@ProcessNet
	jmp	$LN56@ProcessNet
$LN41@ProcessNet:

; 4075 : 		}
; 4076 : 		else if (rss!=0)

	cmp	DWORD PTR _rss$13[ebp], 0
	je	$LN56@ProcessNet

; 4077 : 		{
; 4078 : 			// If this is an existing connection, and they are already fully connected (not in progress), reply with connection attempt failed
; 4079 : 			if (rss->connectMode==RakPeer::RemoteSystemStruct::CONNECTED ||
; 4080 : 				rss->connectMode==RakPeer::RemoteSystemStruct::DISCONNECT_ASAP ||
; 4081 : 				rss->connectMode==RakPeer::RemoteSystemStruct::DISCONNECT_ASAP_SILENTLY)

	mov	eax, DWORD PTR _rss$13[ebp]
	cmp	DWORD PTR [eax+2054], 8
	je	SHORT $LN30@ProcessNet
	mov	eax, DWORD PTR _rss$13[ebp]
	cmp	DWORD PTR [eax+2054], 1
	je	SHORT $LN30@ProcessNet
	mov	eax, DWORD PTR _rss$13[ebp]
	cmp	DWORD PTR [eax+2054], 2
	jne	$LN56@ProcessNet
$LN30@ProcessNet:

; 4082 : 			{
; 4083 : 				char c[2];
; 4084 : 				c[0] = ID_CONNECTION_ATTEMPT_FAILED;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	BYTE PTR _c$10[ebp+ecx], 24		; 00000018H

; 4085 : 				c[1] = 0; // Pad, some routers apparently block 1 byte packets

	mov	DWORD PTR $T2[ebp], 1
	cmp	DWORD PTR $T2[ebp], 2
	jae	SHORT $LN84@ProcessNet
	jmp	SHORT $LN85@ProcessNet
$LN84@ProcessNet:
	call	___report_rangecheckfailure
$LN85@ProcessNet:
	mov	eax, DWORD PTR $T2[ebp]
	mov	BYTE PTR _c$10[ebp+eax], 0

; 4086 : 
; 4087 : 				unsigned i;
; 4088 : 				for (i=0; i < rakPeer->messageHandlerList.Size(); i++)

	mov	DWORD PTR _i$9[ebp], 0
	jmp	SHORT $LN29@ProcessNet
$LN28@ProcessNet:
	mov	eax, DWORD PTR _i$9[ebp]
	add	eax, 1
	mov	DWORD PTR _i$9[ebp], eax
$LN29@ProcessNet:
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	add	ecx, 941				; 000003adH
	call	?Size@?$List@PAVPluginInterface@@@DataStructures@@QBEIXZ ; DataStructures::List<PluginInterface *>::Size
	cmp	DWORD PTR _i$9[ebp], eax
	jae	SHORT $LN27@ProcessNet

; 4089 : 					rakPeer->messageHandlerList[i]->OnDirectSocketSend((char*)&c, 16, playerId);

	mov	eax, DWORD PTR _i$9[ebp]
	push	eax
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	add	ecx, 941				; 000003adH
	call	??A?$List@PAVPluginInterface@@@DataStructures@@QBEAAPAVPluginInterface@@I@Z ; DataStructures::List<PluginInterface *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv412[ebp], ecx
	mov	esi, esp
	sub	esp, 8
	mov	edx, esp
	mov	eax, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [edx], eax
	mov	cx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [edx+4], cx
	push	16					; 00000010H
	lea	edx, DWORD PTR _c$10[ebp]
	push	edx
	mov	eax, DWORD PTR tv412[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv412[ebp]
	mov	eax, DWORD PTR [edx+28]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN28@ProcessNet
$LN27@ProcessNet:

; 4090 : 				SocketLayer::Instance()->SendTo( rakPeer->connectionSocket, (char*)&c, 2, playerId.binaryAddress, playerId.port );

	movzx	eax, WORD PTR _playerId$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _playerId$[ebp]
	push	ecx
	push	2
	lea	edx, DWORD PTR _c$10[ebp]
	push	edx
	mov	eax, DWORD PTR _rakPeer$[ebp]
	mov	ecx, DWORD PTR [eax+2070]
	push	ecx
	call	?Instance@SocketLayer@@SAPAV1@XZ	; SocketLayer::Instance
	mov	ecx, eax
	call	?SendTo@SocketLayer@@QAEHIPBDHIG@Z	; SocketLayer::SendTo
$LN56@ProcessNet:

; 4091 : 			}
; 4092 : 		}
; 4093 : 
; 4094 : 	}
; 4095 : 
; 4096 : 	// See if this datagram came from a connected system
; 4097 : 	remoteSystem = rakPeer->GetRemoteSystemFromPlayerID( playerId, true, true );

	push	1
	push	1
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	call	?GetRemoteSystemFromPlayerID@RakPeer@@IBEPAURemoteSystemStruct@1@UPlayerID@@_N1@Z ; RakPeer::GetRemoteSystemFromPlayerID
	mov	DWORD PTR _remoteSystem$[ebp], eax

; 4098 : 	if ( remoteSystem )

	cmp	DWORD PTR _remoteSystem$[ebp], 0
	je	$LN26@ProcessNet

; 4099 : 	{
; 4100 : #ifdef TEA_ENCRYPTOR
; 4101 : 		char szBuffer[32];
; 4102 : /*
; 4103 : #ifdef SAMPSRV
; 4104 : 		sprintf(szBuffer, "SvLength: %d\n", length);
; 4105 : #else
; 4106 : 		sprintf(szBuffer, "ClLength: %d\n", length);
; 4107 : #endif
; 4108 : 		OutputDebugString(szBuffer);
; 4109 : 		if (remoteSystem->connectMode==RakPeer::RemoteSystemStruct::SET_ENCRYPTION_ON_MULTIPLE_16_BYTE_PACKET)
; 4110 : 			OutputDebugString("Boo\n");
; 4111 : */
; 4112 : 		if (remoteSystem->connectMode==RakPeer::RemoteSystemStruct::SET_ENCRYPTION_ON_MULTIPLE_16_BYTE_PACKET && length >= 8 && (length%8)==0)

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	cmp	DWORD PTR [eax+2054], 7
	jne	SHORT $LN25@ProcessNet
	cmp	DWORD PTR _length$[ebp], 8
	jl	SHORT $LN25@ProcessNet
	mov	eax, DWORD PTR _length$[ebp]
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN103@ProcessNet
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN103@ProcessNet:
	test	eax, eax
	jne	SHORT $LN25@ProcessNet

; 4113 : 		{
; 4114 : 			remoteSystem->reliabilityLayer.SetEncryptionKey( remoteSystem->AESKey );

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	add	eax, 2025				; 000007e9H
	push	eax
	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	add	ecx, 13					; 0000000dH
	call	?SetEncryptionKey@ReliabilityLayer@@QAEXPBE@Z ; ReliabilityLayer::SetEncryptionKey
$LN25@ProcessNet:

; 4115 : /*
; 4116 : #ifdef SAMPSRV
; 4117 : 			OutputDebugString("SvSet\n");
; 4118 : #else
; 4119 : 			OutputDebugString("ClSet\n");
; 4120 : #endif
; 4121 : */
; 4122 : 		}
; 4123 : #else
; 4124 : 		if (remoteSystem->connectMode==RakPeer::RemoteSystemStruct::SET_ENCRYPTION_ON_MULTIPLE_16_BYTE_PACKET && (length%16)==0)
; 4125 : 			remoteSystem->reliabilityLayer.SetEncryptionKey( remoteSystem->AESKey );
; 4126 : #endif
; 4127 : 
; 4128 : 		// Handle regular incoming data
; 4129 : 		// HandleSocketReceiveFromConnectedPlayer is only safe to be called from the same thread as Update, which is this thread
; 4130 : 		if ( remoteSystem->reliabilityLayer.HandleSocketReceiveFromConnectedPlayer( data, length, playerId, rakPeer->messageHandlerList, rakPeer->MTUSize ) == false )

	mov	eax, DWORD PTR _rakPeer$[ebp]
	mov	ecx, DWORD PTR [eax+2061]
	push	ecx
	mov	edx, DWORD PTR _rakPeer$[ebp]
	add	edx, 941				; 000003adH
	push	edx
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	add	ecx, 13					; 0000000dH
	call	?HandleSocketReceiveFromConnectedPlayer@ReliabilityLayer@@QAE_NPBDHUPlayerID@@AAV?$List@PAVPluginInterface@@@DataStructures@@H@Z ; ReliabilityLayer::HandleSocketReceiveFromConnectedPlayer
	movzx	edx, al
	test	edx, edx
	jne	$LN24@ProcessNet

; 4131 : 		{
; 4132 : 			// These kinds of packets may have been duplicated and incorrectly determined to be
; 4133 : 			// cheat packets.  Anything else really is a cheat packet
; 4134 : 			if ( !(
; 4135 : 			( (unsigned char)data[0] == ID_OPEN_CONNECTION_REQUEST && length <= 2 ) ||
; 4136 : 			( (unsigned char)data[0] == ID_OPEN_CONNECTION_REPLY && length <= 2 ) ||
; 4137 : 			( (unsigned char)data[0] == ID_CONNECTION_ATTEMPT_FAILED && length <= 2 ) ||
; 4138 : 			( ((unsigned char)data[0] == ID_PING_OPEN_CONNECTIONS || (unsigned char)data[0] == ID_PING || (unsigned char)data[0] == ID_PONG) && length >= sizeof(unsigned char)+sizeof(RakNetTime) ) ||
; 4139 : 			( (unsigned char)data[0] == ID_ADVERTISE_SYSTEM && length<MAX_OFFLINE_DATA_LENGTH )
; 4140 : 			) )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 16					; 00000010H
	jne	SHORT $LN22@ProcessNet
	cmp	DWORD PTR _length$[ebp], 2
	jle	$LN24@ProcessNet
$LN22@ProcessNet:
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 17					; 00000011H
	jne	SHORT $LN21@ProcessNet
	cmp	DWORD PTR _length$[ebp], 2
	jle	$LN24@ProcessNet
$LN21@ProcessNet:
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 24					; 00000018H
	jne	SHORT $LN20@ProcessNet
	cmp	DWORD PTR _length$[ebp], 2
	jle	$LN24@ProcessNet
$LN20@ProcessNet:
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 4
	je	SHORT $LN18@ProcessNet
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 3
	je	SHORT $LN18@ProcessNet
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN19@ProcessNet
$LN18@ProcessNet:
	cmp	DWORD PTR _length$[ebp], 5
	jae	$LN24@ProcessNet
$LN19@ProcessNet:
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 54					; 00000036H
	jne	SHORT $LN17@ProcessNet
	cmp	DWORD PTR _length$[ebp], 400		; 00000190H
	jl	SHORT $LN24@ProcessNet
$LN17@ProcessNet:

; 4141 : 			{
; 4142 : 				// Unknown message.  Could be caused by old out of order stuff from unconnected or no longer connected systems, etc.
; 4143 : 				packet=AllocPacket(1);

	push	1
	call	?AllocPacket@@YAPAUPacket@@I@Z		; AllocPacket
	add	esp, 4
	mov	DWORD PTR _packet$[ebp], eax

; 4144 : 				packet->data[ 0 ] = ID_MODIFIED_PACKET;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _packet$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	BYTE PTR [ecx+eax], 35			; 00000023H

; 4145 : 				packet->bitSize = sizeof( char ) * 8;

	mov	eax, DWORD PTR _packet$[ebp]
	mov	DWORD PTR [eax+12], 8

; 4146 : 				packet->playerId = playerId;

	lea	eax, DWORD PTR _playerId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _packet$[ebp]
	add	ecx, 2
	call	??4PlayerID@@QAEAAU0@ABU0@@Z		; PlayerID::operator=

; 4147 : 				packet->playerIndex = ( PlayerIndex ) rakPeer->GetIndexFromPlayerID( playerId, true );

	push	1
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	call	?GetIndexFromPlayerID@RakPeer@@IAEHUPlayerID@@_N@Z ; RakPeer::GetIndexFromPlayerID
	mov	ecx, DWORD PTR _packet$[ebp]
	mov	WORD PTR [ecx], ax

; 4148 : 				rakPeer->AddPacketToProducer(packet);

	mov	eax, DWORD PTR _packet$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	call	?AddPacketToProducer@RakPeer@@IAEXPAUPacket@@@Z ; RakPeer::AddPacketToProducer
$LN24@ProcessNet:

; 4149 : 			}
; 4150 : 		}
; 4151 : 	}
; 4152 : 	else

	jmp	$LN78@ProcessNet
$LN26@ProcessNet:

; 4153 : 	{
; 4154 : 		for (i=0; i < rakPeer->messageHandlerList.Size(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN15@ProcessNet
$LN14@ProcessNet:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN15@ProcessNet:
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	add	ecx, 941				; 000003adH
	call	?Size@?$List@PAVPluginInterface@@@DataStructures@@QBEIXZ ; DataStructures::List<PluginInterface *>::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN13@ProcessNet

; 4155 : 			rakPeer->messageHandlerList[i]->OnDirectSocketReceive(data, length*8, playerId);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	add	ecx, 941				; 000003adH
	call	??A?$List@PAVPluginInterface@@@DataStructures@@QBEAAPAVPluginInterface@@I@Z ; DataStructures::List<PluginInterface *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv514[ebp], ecx
	mov	esi, esp
	sub	esp, 8
	mov	edx, esp
	mov	eax, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [edx], eax
	mov	cx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [edx+4], cx
	mov	edx, DWORD PTR _length$[ebp]
	shl	edx, 3
	push	edx
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv514[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv514[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN14@ProcessNet
$LN13@ProcessNet:

; 4156 : 
; 4157 : 		if (length > 512)

	cmp	DWORD PTR _length$[ebp], 512		; 00000200H
	jle	SHORT $LN12@ProcessNet

; 4158 : 		{
; 4159 : #if !defined(_COMPATIBILITY_1)
; 4160 : 			// Flood attack?  Unknown systems should never send more than a small amount of data. Do a short ban
; 4161 : 			rakPeer->AddToBanList(rakPeer->PlayerIDToDottedIP(playerId), 10000);

	mov	esi, esp
	push	10000					; 00002710H
	mov	edi, esp
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	eax, DWORD PTR _rakPeer$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	mov	eax, DWORD PTR [edx+184]
	call	eax
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4162 : #endif
; 4163 : 			return;

	jmp	$LN78@ProcessNet
$LN12@ProcessNet:

; 4164 : 		}
; 4165 : 
; 4166 : 		// These are all messages from unconnected systems.  Messages here can be any size, but are never processed from connected systems.
; 4167 : 		if ( ( (unsigned char) data[ 0 ] == ID_PING_OPEN_CONNECTIONS
; 4168 : 			|| (unsigned char)(data)[0] == ID_PING)	&& length == sizeof(unsigned char)+sizeof(RakNetTime) )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 4
	je	SHORT $LN10@ProcessNet
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 3
	jne	$LN11@ProcessNet
$LN10@ProcessNet:
	cmp	DWORD PTR _length$[ebp], 5
	jne	$LN11@ProcessNet

; 4169 : 		{
; 4170 : 			if ( (unsigned char)(data)[0] == ID_PING ||
; 4171 : 				rakPeer->AllowIncomingConnections() ) // Open connections with players

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 3
	je	SHORT $LN8@ProcessNet
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	call	?AllowIncomingConnections@RakPeer@@IBE_NXZ ; RakPeer::AllowIncomingConnections
	movzx	eax, al
	test	eax, eax
	je	$LN9@ProcessNet
$LN8@ProcessNet:

; 4172 : 			{
; 4173 : #if !defined(_COMPATIBILITY_1)
; 4174 : 				RakNet::BitStream inBitStream( (unsigned char *) data, length, false );

	push	0
	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _inBitStream$8[ebp]
	call	??0BitStream@RakNet@@QAE@PAEI_N@Z	; RakNet::BitStream::BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 4175 : 				inBitStream.IgnoreBits(8);

	push	8
	lea	ecx, DWORD PTR _inBitStream$8[ebp]
	call	?IgnoreBits@BitStream@RakNet@@QAEXH@Z	; RakNet::BitStream::IgnoreBits

; 4176 : 				RakNetTime sendPingTime;
; 4177 : 				inBitStream.Read(sendPingTime);

	lea	eax, DWORD PTR _sendPingTime$7[ebp]
	push	eax
	lea	ecx, DWORD PTR _inBitStream$8[ebp]
	call	??$Read@I@BitStream@RakNet@@QAE_NAAI@Z	; RakNet::BitStream::Read<unsigned int>

; 4178 : 
; 4179 : 				RakNet::BitStream outBitStream;

	lea	ecx, DWORD PTR _outBitStream$6[ebp]
	call	??0BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::BitStream
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 4180 : 				outBitStream.Write((unsigned char)ID_PONG); // Should be named ID_UNCONNECTED_PONG eventually

	push	37					; 00000025H
	lea	ecx, DWORD PTR _outBitStream$6[ebp]
	call	??$Write@E@BitStream@RakNet@@QAEXE@Z	; RakNet::BitStream::Write<unsigned char>

; 4181 : 				outBitStream.Write(sendPingTime);

	mov	eax, DWORD PTR _sendPingTime$7[ebp]
	push	eax
	lea	ecx, DWORD PTR _outBitStream$6[ebp]
	call	??$Write@I@BitStream@RakNet@@QAEXI@Z	; RakNet::BitStream::Write<unsigned int>

; 4182 : 				//tempBitStream.Write( data, UnconnectedPingStruct_Size );
; 4183 : 				rakPeer->rakPeerMutexes[ RakPeer::offlinePingResponse_Mutex ].Lock();

	mov	eax, 24					; 00000018H
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _rakPeer$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+836]
	call	?Lock@SimpleMutex@@QAEXXZ		; SimpleMutex::Lock

; 4184 : 				// They are connected, so append offline ping data
; 4185 : 				outBitStream.Write( (char*)rakPeer->offlinePingResponse.GetData(), rakPeer->offlinePingResponse.GetNumberOfBytesUsed() );

	mov	ecx, DWORD PTR _rakPeer$[ebp]
	add	ecx, 284				; 0000011cH
	call	?GetNumberOfBytesUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBytesUsed
	push	eax
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	add	ecx, 284				; 0000011cH
	call	?GetData@BitStream@RakNet@@QBEPAEXZ	; RakNet::BitStream::GetData
	push	eax
	lea	ecx, DWORD PTR _outBitStream$6[ebp]
	call	?Write@BitStream@RakNet@@QAEXPBDH@Z	; RakNet::BitStream::Write

; 4186 : 				rakPeer->rakPeerMutexes[ RakPeer::offlinePingResponse_Mutex ].Unlock();

	mov	eax, 24					; 00000018H
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _rakPeer$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+836]
	call	?Unlock@SimpleMutex@@QAEXXZ		; SimpleMutex::Unlock

; 4187 : 				//SocketLayer::Instance()->SendTo( connectionSocket, ( char* ) outBitStream.GetData(), outBitStream.GetNumberOfBytesUsed(), playerId.binaryAddress, playerId.port );
; 4188 : 
; 4189 : 				unsigned i;
; 4190 : 				for (i=0; i < rakPeer->messageHandlerList.Size(); i++)

	mov	DWORD PTR _i$5[ebp], 0
	jmp	SHORT $LN7@ProcessNet
$LN6@ProcessNet:
	mov	eax, DWORD PTR _i$5[ebp]
	add	eax, 1
	mov	DWORD PTR _i$5[ebp], eax
$LN7@ProcessNet:
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	add	ecx, 941				; 000003adH
	call	?Size@?$List@PAVPluginInterface@@@DataStructures@@QBEIXZ ; DataStructures::List<PluginInterface *>::Size
	cmp	DWORD PTR _i$5[ebp], eax
	jae	SHORT $LN5@ProcessNet

; 4191 : 					rakPeer->messageHandlerList[i]->OnDirectSocketSend((const char*)outBitStream.GetData(), outBitStream.GetNumberOfBytesUsed(), playerId);

	mov	eax, DWORD PTR _i$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	add	ecx, 941				; 000003adH
	call	??A?$List@PAVPluginInterface@@@DataStructures@@QBEAAPAVPluginInterface@@I@Z ; DataStructures::List<PluginInterface *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv634[ebp], ecx
	mov	esi, esp
	sub	esp, 8
	mov	edx, esp
	mov	eax, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [edx], eax
	mov	cx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [edx+4], cx
	lea	ecx, DWORD PTR _outBitStream$6[ebp]
	call	?GetNumberOfBytesUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBytesUsed
	push	eax
	lea	ecx, DWORD PTR _outBitStream$6[ebp]
	call	?GetData@BitStream@RakNet@@QBEPAEXZ	; RakNet::BitStream::GetData
	push	eax
	mov	edx, DWORD PTR tv634[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv634[ebp]
	mov	edx, DWORD PTR [eax+28]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	$LN6@ProcessNet
$LN5@ProcessNet:

; 4192 : 
; 4193 : 				SocketLayer::Instance()->SendTo( rakPeer->connectionSocket, (const char*)outBitStream.GetData(), outBitStream.GetNumberOfBytesUsed(), (char*)rakPeer->PlayerIDToDottedIP(playerId) , playerId.port );

	movzx	eax, WORD PTR _playerId$[ebp+4]
	push	eax
	mov	esi, esp
	sub	esp, 8
	mov	ecx, esp
	mov	edx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	ax, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [ecx+4], ax
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	mov	eax, DWORD PTR [edx+184]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	lea	ecx, DWORD PTR _outBitStream$6[ebp]
	call	?GetNumberOfBytesUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBytesUsed
	push	eax
	lea	ecx, DWORD PTR _outBitStream$6[ebp]
	call	?GetData@BitStream@RakNet@@QBEPAEXZ	; RakNet::BitStream::GetData
	push	eax
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	mov	edx, DWORD PTR [ecx+2070]
	push	edx
	call	?Instance@SocketLayer@@SAPAV1@XZ	; SocketLayer::Instance
	mov	ecx, eax
	call	?SendTo@SocketLayer@@QAEHIPBDHQADG@Z	; SocketLayer::SendTo

; 4194 : #endif
; 4195 : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _outBitStream$6[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _inBitStream$8[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
$LN9@ProcessNet:

; 4196 : 		}

	jmp	$LN78@ProcessNet
$LN11@ProcessNet:

; 4197 : 		// UNCONNECTED MESSAGE Pong with no data.  TODO - Problem - this matches a reliable send of other random data.
; 4198 : 		else if ((unsigned char) data[ 0 ] == ID_PONG && length >= sizeof(unsigned char)+sizeof(RakNetTime) && length < sizeof(unsigned char)+sizeof(RakNetTime)+MAX_OFFLINE_DATA_LENGTH)

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 37					; 00000025H
	jne	$LN3@ProcessNet
	cmp	DWORD PTR _length$[ebp], 5
	jb	SHORT $LN3@ProcessNet
	cmp	DWORD PTR _length$[ebp], 405		; 00000195H
	jae	SHORT $LN3@ProcessNet

; 4199 : 		{
; 4200 : 			packet=AllocPacket(length);

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	call	?AllocPacket@@YAPAUPacket@@I@Z		; AllocPacket
	add	esp, 4
	mov	DWORD PTR _packet$[ebp], eax

; 4201 : 			memcpy(packet->data, data, length);

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _packet$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 4202 : 			packet->bitSize = length * 8;

	mov	eax, DWORD PTR _length$[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR _packet$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 4203 : 			packet->playerId = playerId;

	lea	eax, DWORD PTR _playerId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _packet$[ebp]
	add	ecx, 2
	call	??4PlayerID@@QAEAAU0@ABU0@@Z		; PlayerID::operator=

; 4204 : 			packet->playerIndex = ( PlayerIndex ) rakPeer->GetIndexFromPlayerID( playerId, true );

	push	1
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	call	?GetIndexFromPlayerID@RakPeer@@IAEHUPlayerID@@_N@Z ; RakPeer::GetIndexFromPlayerID
	mov	ecx, DWORD PTR _packet$[ebp]
	mov	WORD PTR [ecx], ax

; 4205 : 			rakPeer->AddPacketToProducer(packet);

	mov	eax, DWORD PTR _packet$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	call	?AddPacketToProducer@RakPeer@@IAEXPAUPacket@@@Z ; RakPeer::AddPacketToProducer
	jmp	$LN78@ProcessNet
$LN3@ProcessNet:

; 4206 : 		}
; 4207 : 		else if ((unsigned char) data[ 0 ] == ID_ADVERTISE_SYSTEM && length >= 2 && length < MAX_OFFLINE_DATA_LENGTH+2)

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _data$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 54					; 00000036H
	jne	SHORT $LN78@ProcessNet
	cmp	DWORD PTR _length$[ebp], 2
	jl	SHORT $LN78@ProcessNet
	cmp	DWORD PTR _length$[ebp], 402		; 00000192H
	jge	SHORT $LN78@ProcessNet

; 4208 : 		{
; 4209 : 			packet=AllocPacket(length);

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	call	?AllocPacket@@YAPAUPacket@@I@Z		; AllocPacket
	add	esp, 4
	mov	DWORD PTR _packet$[ebp], eax

; 4210 : 			memcpy(packet->data, data, length);

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _packet$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 4211 : 			packet->bitSize = length * 8;

	mov	eax, DWORD PTR _length$[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR _packet$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 4212 : 			packet->playerId = playerId;

	lea	eax, DWORD PTR _playerId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _packet$[ebp]
	add	ecx, 2
	call	??4PlayerID@@QAEAAU0@ABU0@@Z		; PlayerID::operator=

; 4213 : 			packet->playerIndex = ( PlayerIndex ) rakPeer->GetIndexFromPlayerID( playerId, true );

	push	1
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	call	?GetIndexFromPlayerID@RakPeer@@IAEHUPlayerID@@_N@Z ; RakPeer::GetIndexFromPlayerID
	mov	ecx, DWORD PTR _packet$[ebp]
	mov	WORD PTR [ecx], ax

; 4214 : 			rakPeer->AddPacketToProducer(packet);

	mov	eax, DWORD PTR _packet$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rakPeer$[ebp]
	call	?AddPacketToProducer@RakPeer@@IAEXPAUPacket@@@Z ; RakPeer::AddPacketToProducer
$LN78@ProcessNet:

; 4215 : 		}
; 4216 : 	}
; 4217 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN102@ProcessNet
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 1376				; 00000560H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
	npad	1
$LN102@ProcessNet:
	DD	9
	DD	$LN101@ProcessNet
$LN101@ProcessNet:
	DD	-40					; ffffffd8H
	DD	6
	DD	$LN91@ProcessNet
	DD	-76					; ffffffb4H
	DD	2
	DD	$LN92@ProcessNet
	DD	-412					; fffffe64H
	DD	273					; 00000111H
	DD	$LN93@ProcessNet
	DD	-472					; fffffe28H
	DD	2
	DD	$LN94@ProcessNet
	DD	-496					; fffffe10H
	DD	2
	DD	$LN95@ProcessNet
	DD	-548					; fffffddcH
	DD	32					; 00000020H
	DD	$LN96@ProcessNet
	DD	-832					; fffffcc0H
	DD	273					; 00000111H
	DD	$LN97@ProcessNet
	DD	-844					; fffffcb4H
	DD	4
	DD	$LN98@ProcessNet
	DD	-1128					; fffffb98H
	DD	273					; 00000111H
	DD	$LN99@ProcessNet
$LN99@ProcessNet:
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	66					; 00000042H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	0
$LN98@ProcessNet:
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	80					; 00000050H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$LN97@ProcessNet:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	66					; 00000042H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	0
$LN96@ProcessNet:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$LN95@ProcessNet:
	DB	99					; 00000063H
	DB	0
$LN94@ProcessNet:
	DB	99					; 00000063H
	DB	0
$LN93@ProcessNet:
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
$LN92@ProcessNet:
	DB	99					; 00000063H
	DB	0
$LN91@ProcessNet:
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	73					; 00000049H
	DB	100					; 00000064H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ProcessNetworkPacket@@YGXIGPBDHPAVRakPeer@@@Z$0:
	lea	ecx, DWORD PTR _temp$17[ebp]
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__unwindfunclet$?ProcessNetworkPacket@@YGXIGPBDHPAVRakPeer@@@Z$1:
	lea	ecx, DWORD PTR _inBitStream$8[ebp]
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__unwindfunclet$?ProcessNetworkPacket@@YGXIGPBDHPAVRakPeer@@@Z$2:
	lea	ecx, DWORD PTR _outBitStream$6[ebp]
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__ehhandler$?ProcessNetworkPacket@@YGXIGPBDHPAVRakPeer@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1380]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ProcessNetworkPacket@@YGXIGPBDHPAVRakPeer@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ProcessNetworkPacket@@YGXIGPBDHPAVRakPeer@@@Z ENDP	; ProcessNetworkPacket
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?ProcessPortUnreachable@@YGXIGPAVRakPeer@@@Z
_TEXT	SEGMENT
_binaryAddress$ = 8					; size = 4
_port$ = 12						; size = 2
_rakPeer$ = 16						; size = 4
?ProcessPortUnreachable@@YGXIGPAVRakPeer@@@Z PROC	; ProcessPortUnreachable, COMDAT

; 3861 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3862 : 	
; 3863 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?ProcessPortUnreachable@@YGXIGPAVRakPeer@@@Z ENDP	; ProcessPortUnreachable
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_ERemoteSystemStruct@RakPeer@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_ERemoteSystemStruct@RakPeer@@QAEPAXI@Z PROC		; RakPeer::RemoteSystemStruct::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector
	push	OFFSET ??1RemoteSystemStruct@RakPeer@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax-4]
	push	ecx
	push	2058					; 0000080aH
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@vector
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@vector:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector
$LN3@vector:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1RemoteSystemStruct@RakPeer@@QAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector:
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_ERemoteSystemStruct@RakPeer@@QAEPAXI@Z ENDP		; RakPeer::RemoteSystemStruct::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1RemoteSystemStruct@RakPeer@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1RemoteSystemStruct@RakPeer@@QAE@XZ PROC		; RakPeer::RemoteSystemStruct::~RemoteSystemStruct, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1RemoteSystemStruct@RakPeer@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2042				; 000007faH
	call	??1RPCMap@@QAE@XZ			; RPCMap::~RPCMap
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1748				; 000006d4H
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 13					; 0000000dH
	call	??1ReliabilityLayer@@QAE@XZ		; ReliabilityLayer::~ReliabilityLayer
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1RemoteSystemStruct@RakPeer@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 13					; 0000000dH
	jmp	??1ReliabilityLayer@@QAE@XZ		; ReliabilityLayer::~ReliabilityLayer
__unwindfunclet$??1RemoteSystemStruct@RakPeer@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1748				; 000006d4H
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__ehhandler$??1RemoteSystemStruct@RakPeer@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1RemoteSystemStruct@RakPeer@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1RemoteSystemStruct@RakPeer@@QAE@XZ ENDP		; RakPeer::RemoteSystemStruct::~RemoteSystemStruct
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0RemoteSystemStruct@RakPeer@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0RemoteSystemStruct@RakPeer@@QAE@XZ PROC		; RakPeer::RemoteSystemStruct::RemoteSystemStruct, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0RemoteSystemStruct@RakPeer@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 13					; 0000000dH
	call	??0ReliabilityLayer@@QAE@XZ		; ReliabilityLayer::ReliabilityLayer
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1748				; 000006d4H
	call	??0BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::BitStream
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2042				; 000007faH
	call	??0RPCMap@@QAE@XZ			; RPCMap::RPCMap
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0RemoteSystemStruct@RakPeer@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 13					; 0000000dH
	jmp	??1ReliabilityLayer@@QAE@XZ		; ReliabilityLayer::~ReliabilityLayer
__unwindfunclet$??0RemoteSystemStruct@RakPeer@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1748				; 000006d4H
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__ehhandler$??0RemoteSystemStruct@RakPeer@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0RemoteSystemStruct@RakPeer@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0RemoteSystemStruct@RakPeer@@QAE@XZ ENDP		; RakPeer::RemoteSystemStruct::RemoteSystemStruct
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?GetRPCMap@RakPeer@@UAEPAURPCMap@@UPlayerID@@@Z
_TEXT	SEGMENT
_rss$1 = -20						; size = 4
_this$ = -8						; size = 4
_playerId$ = 8						; size = 6
?GetRPCMap@RakPeer@@UAEPAURPCMap@@UPlayerID@@@Z PROC	; RakPeer::GetRPCMap, COMDAT
; _this$ = ecx

; 2455 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2456 :     if (playerId==UNASSIGNED_PLAYER_ID)

	push	OFFSET _UNASSIGNED_PLAYER_ID
	lea	ecx, DWORD PTR _playerId$[ebp]
	call	??8PlayerID@@QBE_NABU0@@Z		; PlayerID::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@GetRPCMap

; 2457 : 		return &rpcMap;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2049				; 00000801H
	jmp	SHORT $LN5@GetRPCMap

; 2458 : 	else

	jmp	SHORT $LN5@GetRPCMap
$LN4@GetRPCMap:

; 2459 : 	{
; 2460 : 		RemoteSystemStruct *rss=GetRemoteSystemFromPlayerID(playerId, false, true);

	push	1
	push	0
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRemoteSystemFromPlayerID@RakPeer@@IBEPAURemoteSystemStruct@1@UPlayerID@@_N1@Z ; RakPeer::GetRemoteSystemFromPlayerID
	mov	DWORD PTR _rss$1[ebp], eax

; 2461 : 		if (rss)

	cmp	DWORD PTR _rss$1[ebp], 0
	je	SHORT $LN2@GetRPCMap

; 2462 : 			return &(rss->rpcMap);

	mov	eax, DWORD PTR _rss$1[ebp]
	add	eax, 2042				; 000007faH
	jmp	SHORT $LN5@GetRPCMap

; 2463 : 		else

	jmp	SHORT $LN5@GetRPCMap
$LN2@GetRPCMap:

; 2464 : 			return 0;

	xor	eax, eax
$LN5@GetRPCMap:

; 2465 : 	}
; 2466 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?GetRPCMap@RakPeer@@UAEPAURPCMap@@UPlayerID@@@Z ENDP	; RakPeer::GetRPCMap
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?GetStatistics@RakPeer@@UAEQAURakNetStatisticsStruct@@UPlayerID@@@Z
_TEXT	SEGMENT
$T1 = -456						; size = 196
_rss$2 = -60						; size = 4
_i$3 = -48						; size = 2
_systemStats$4 = -36					; size = 4
_firstWrite$5 = -21					; size = 1
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_playerId$ = 8						; size = 6
?GetStatistics@RakPeer@@UAEQAURakNetStatisticsStruct@@UPlayerID@@@Z PROC ; RakPeer::GetStatistics, COMDAT
; _this$ = ecx

; 2470 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 460				; 000001ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-460]
	mov	ecx, 115				; 00000073H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 2471 : 	if (playerId==UNASSIGNED_PLAYER_ID)

	push	OFFSET _UNASSIGNED_PLAYER_ID
	lea	ecx, DWORD PTR _playerId$[ebp]
	call	??8PlayerID@@QBE_NABU0@@Z		; PlayerID::operator==
	movzx	eax, al
	test	eax, eax
	je	$LN9@GetStatist

; 2472 : 	{
; 2473 : 		bool firstWrite=false;

	mov	BYTE PTR _firstWrite$5[ebp], 0

; 2474 : 		static RakNetStatisticsStruct sum;
; 2475 : 		RakNetStatisticsStruct *systemStats;
; 2476 : 		// Return a crude sum
; 2477 : 		for ( unsigned short i = 0; i < maximumNumberOfPeers; i++ )

	xor	eax, eax
	mov	WORD PTR _i$3[ebp], ax
	jmp	SHORT $LN8@GetStatist
$LN7@GetStatist:
	mov	ax, WORD PTR _i$3[ebp]
	add	ax, 1
	mov	WORD PTR _i$3[ebp], ax
$LN8@GetStatist:
	movzx	eax, WORD PTR _i$3[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+7]
	cmp	eax, edx
	jge	SHORT $LN6@GetStatist

; 2478 : 		{
; 2479 : 			if (remoteSystemList[ i ].isActive)

	movzx	eax, WORD PTR _i$3[ebp]
	imul	ecx, eax, 2058
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+820]
	movzx	ecx, BYTE PTR [eax+ecx]
	test	ecx, ecx
	je	SHORT $LN5@GetStatist

; 2480 : 			{
; 2481 : 				systemStats=remoteSystemList[ i ].reliabilityLayer.GetStatistics();

	movzx	eax, WORD PTR _i$3[ebp]
	imul	ecx, eax, 2058
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+820]
	lea	ecx, DWORD PTR [eax+ecx+13]
	call	?GetStatistics@ReliabilityLayer@@QAEQAURakNetStatisticsStruct@@XZ ; ReliabilityLayer::GetStatistics
	mov	DWORD PTR _systemStats$4[ebp], eax

; 2482 : 				
; 2483 : 				if (firstWrite==false)

	movzx	eax, BYTE PTR _firstWrite$5[ebp]
	test	eax, eax
	jne	SHORT $LN4@GetStatist

; 2484 : 					memcpy(&sum, systemStats, sizeof(RakNetStatisticsStruct));

	push	196					; 000000c4H
	mov	eax, DWORD PTR _systemStats$4[ebp]
	push	eax
	push	OFFSET ?sum@?4??GetStatistics@RakPeer@@UAEQAURakNetStatisticsStruct@@UPlayerID@@@Z@4U3@A
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2485 : 				else

	jmp	SHORT $LN5@GetStatist
$LN4@GetStatist:

; 2486 : 					sum+=*systemStats;

	mov	eax, DWORD PTR _systemStats$4[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, OFFSET ?sum@?4??GetStatistics@RakPeer@@UAEQAURakNetStatisticsStruct@@UPlayerID@@@Z@4U3@A
	call	??YRakNetStatisticsStruct@@QAE?AU0@ABU0@@Z ; RakNetStatisticsStruct::operator+=
$LN5@GetStatist:

; 2487 : 			}
; 2488 : 		}

	jmp	$LN7@GetStatist
$LN6@GetStatist:

; 2489 : 		return &sum;

	mov	eax, OFFSET ?sum@?4??GetStatistics@RakPeer@@UAEQAURakNetStatisticsStruct@@UPlayerID@@@Z@4U3@A
	jmp	SHORT $LN10@GetStatist

; 2490 : 	}
; 2491 : 	else

	jmp	SHORT $LN2@GetStatist
$LN9@GetStatist:

; 2492 : 	{
; 2493 : 		RemoteSystemStruct * rss;
; 2494 : 	rss = GetRemoteSystemFromPlayerID( playerId, false, false );

	push	0
	push	0
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRemoteSystemFromPlayerID@RakPeer@@IBEPAURemoteSystemStruct@1@UPlayerID@@_N1@Z ; RakPeer::GetRemoteSystemFromPlayerID
	mov	DWORD PTR _rss$2[ebp], eax

; 2495 : 		if ( rss && endThreads==false )

	cmp	DWORD PTR _rss$2[ebp], 0
	je	SHORT $LN2@GetStatist
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN2@GetStatist

; 2496 : 			return rss->reliabilityLayer.GetStatistics();

	mov	ecx, DWORD PTR _rss$2[ebp]
	add	ecx, 13					; 0000000dH
	call	?GetStatistics@ReliabilityLayer@@QAEQAURakNetStatisticsStruct@@XZ ; ReliabilityLayer::GetStatistics
	jmp	SHORT $LN10@GetStatist
$LN2@GetStatist:

; 2497 : 	}	
; 2498 : 
; 2499 : 	return 0;

	xor	eax, eax
$LN10@GetStatist:

; 2500 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 460				; 000001ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?GetStatistics@RakPeer@@UAEQAURakNetStatisticsStruct@@UPlayerID@@@Z ENDP ; RakPeer::GetStatistics
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?IsNetworkSimulatorActive@RakPeer@@UAE_NXZ
_TEXT	SEGMENT
tv72 = -208						; size = 4
_this$ = -8						; size = 4
?IsNetworkSimulatorActive@RakPeer@@UAE_NXZ PROC		; RakPeer::IsNetworkSimulatorActive, COMDAT
; _this$ = ecx

; 2447 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2448 : 	return _maxSendBPS>0 || _minExtraPing>0 || _extraPingVariance>0;

	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [eax+2090]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	ja	SHORT $LN3@IsNetworkS
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+2098]
	test	edx, edx
	jg	SHORT $LN3@IsNetworkS
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+2100]
	test	ecx, ecx
	jg	SHORT $LN3@IsNetworkS
	mov	DWORD PTR tv72[ebp], 0
	jmp	SHORT $LN4@IsNetworkS
$LN3@IsNetworkS:
	mov	DWORD PTR tv72[ebp], 1
$LN4@IsNetworkS:
	mov	al, BYTE PTR tv72[ebp]

; 2449 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsNetworkSimulatorActive@RakPeer@@UAE_NXZ ENDP		; RakPeer::IsNetworkSimulatorActive
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?ApplyNetworkSimulator@RakPeer@@UAEXNGG@Z
_TEXT	SEGMENT
_i$1 = -20						; size = 2
_this$ = -8						; size = 4
_maxSendBPS$ = 8					; size = 8
_minExtraPing$ = 16					; size = 2
_extraPingVariance$ = 20				; size = 2
?ApplyNetworkSimulator@RakPeer@@UAEXNGG@Z PROC		; RakPeer::ApplyNetworkSimulator, COMDAT
; _this$ = ecx

; 2427 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2428 : #ifndef _RELEASE
; 2429 : 	if (remoteSystemList)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+820], 0
	je	SHORT $LN1@ApplyNetwo

; 2430 : 	{
; 2431 : 		unsigned short i;
; 2432 : 		for (i=0; i < maximumNumberOfPeers; i++)

	xor	eax, eax
	mov	WORD PTR _i$1[ebp], ax
	jmp	SHORT $LN3@ApplyNetwo
$LN2@ApplyNetwo:
	mov	ax, WORD PTR _i$1[ebp]
	add	ax, 1
	mov	WORD PTR _i$1[ebp], ax
$LN3@ApplyNetwo:
	movzx	eax, WORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+7]
	cmp	eax, edx
	jge	SHORT $LN1@ApplyNetwo

; 2433 : 		//for (i=0; i < remoteSystemListSize; i++)
; 2434 : 			remoteSystemList[i].reliabilityLayer.ApplyNetworkSimulator(maxSendBPS, minExtraPing, extraPingVariance);

	movzx	eax, WORD PTR _extraPingVariance$[ebp]
	push	eax
	movzx	ecx, WORD PTR _minExtraPing$[ebp]
	push	ecx
	sub	esp, 8
	movsd	xmm0, QWORD PTR _maxSendBPS$[ebp]
	movsd	QWORD PTR [esp], xmm0
	movzx	edx, WORD PTR _i$1[ebp]
	imul	eax, edx, 2058
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	lea	ecx, DWORD PTR [edx+eax+13]
	call	?ApplyNetworkSimulator@ReliabilityLayer@@QAEXNII@Z ; ReliabilityLayer::ApplyNetworkSimulator
	jmp	SHORT $LN2@ApplyNetwo
$LN1@ApplyNetwo:

; 2435 : 	}
; 2436 : 
; 2437 : 	_maxSendBPS=maxSendBPS;

	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR _maxSendBPS$[ebp]
	movsd	QWORD PTR [eax+2090], xmm0

; 2438 : 	_minExtraPing=minExtraPing;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _minExtraPing$[ebp]
	mov	WORD PTR [eax+2098], cx

; 2439 : 	_extraPingVariance=extraPingVariance;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _extraPingVariance$[ebp]
	mov	WORD PTR [eax+2100], cx

; 2440 : #endif
; 2441 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?ApplyNetworkSimulator@RakPeer@@UAEXNGG@Z ENDP		; RakPeer::ApplyNetworkSimulator
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?RemoveRouterInterface@RakPeer@@UAEXPAVRouterInterface@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_routerInterface$ = 8					; size = 4
?RemoveRouterInterface@RakPeer@@UAEXPAVRouterInterface@@@Z PROC ; RakPeer::RemoveRouterInterface, COMDAT
; _this$ = ecx

; 2417 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2418 : 	if (router==routerInterface)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2086]
	cmp	ecx, DWORD PTR _routerInterface$[ebp]
	jne	SHORT $LN2@RemoveRout

; 2419 : 		router=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2086], 0
$LN2@RemoveRout:

; 2420 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveRouterInterface@RakPeer@@UAEXPAVRouterInterface@@@Z ENDP ; RakPeer::RemoveRouterInterface
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?SetRouterInterface@RakPeer@@UAEXPAVRouterInterface@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_routerInterface$ = 8					; size = 4
?SetRouterInterface@RakPeer@@UAEXPAVRouterInterface@@@Z PROC ; RakPeer::SetRouterInterface, COMDAT
; _this$ = ecx

; 2412 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2413 : 	router=routerInterface;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _routerInterface$[ebp]
	mov	DWORD PTR [eax+2086], ecx

; 2414 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetRouterInterface@RakPeer@@UAEXPAVRouterInterface@@@Z ENDP ; RakPeer::SetRouterInterface
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?PushBackPacket@RakPeer@@UAEXPAUPacket@@_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_packet$ = 8						; size = 4
_pushAtHead$ = 12					; size = 1
?PushBackPacket@RakPeer@@UAEXPAUPacket@@_N@Z PROC	; RakPeer::PushBackPacket, COMDAT
; _this$ = ecx

; 2396 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2397 : #ifdef _RAKNET_THREADSAFE
; 2398 : 	rakPeerMutexes[packetPool_Mutex].Lock();
; 2399 : #endif
; 2400 : 	RakAssert(packet);

	cmp	DWORD PTR _packet$[ebp], 0
	jne	SHORT $LN5@PushBackPa
	mov	eax, DWORD PTR ?__LINE__Var@?1??PushBackPacket@RakPeer@@UAEXPAUPacket@@_N@Z@4JA
	add	eax, 4
	push	eax
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_1O@HMOJLPKG@?$AAp?$AAa?$AAc?$AAk?$AAe?$AAt?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN5@PushBackPa:

; 2401 : 	if (pushAtHead)

	movzx	eax, BYTE PTR _pushAtHead$[ebp]
	test	eax, eax
	je	SHORT $LN2@PushBackPa

; 2402 : 		packetPool.PushAtHead(packet);

	push	0
	lea	eax, DWORD PTR _packet$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2522				; 000009daH
	call	?PushAtHead@?$Queue@PAUPacket@@@DataStructures@@QAEXABQAUPacket@@I@Z ; DataStructures::Queue<Packet *>::PushAtHead

; 2403 : 	else

	jmp	SHORT $LN3@PushBackPa
$LN2@PushBackPa:

; 2404 : 		packetPool.Push(packet);

	lea	eax, DWORD PTR _packet$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2522				; 000009daH
	call	?Push@?$Queue@PAUPacket@@@DataStructures@@QAEXABQAUPacket@@@Z ; DataStructures::Queue<Packet *>::Push
$LN3@PushBackPa:

; 2405 : #ifdef _RAKNET_THREADSAFE
; 2406 : 	rakPeerMutexes[packetPool_Mutex].Unlock();
; 2407 : #endif
; 2408 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?PushBackPacket@RakPeer@@UAEXPAUPacket@@_N@Z ENDP	; RakPeer::PushBackPacket
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?DetachPlugin@RakPeer@@UAEXPAVPluginInterface@@@Z
_TEXT	SEGMENT
tv76 = -220						; size = 4
_index$ = -20						; size = 4
_this$ = -8						; size = 4
_plugin$ = 8						; size = 4
?DetachPlugin@RakPeer@@UAEXPAVPluginInterface@@@Z PROC	; RakPeer::DetachPlugin, COMDAT
; _this$ = ecx

; 2374 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2375 : 	if (plugin==0)

	cmp	DWORD PTR _plugin$[ebp], 0
	jne	SHORT $LN2@DetachPlug

; 2376 : 		return;

	jmp	$LN3@DetachPlug
$LN2@DetachPlug:

; 2377 : 
; 2378 : 	unsigned int index;
; 2379 : 	index = messageHandlerList.GetIndexOf(plugin);

	mov	eax, DWORD PTR _plugin$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 941				; 000003adH
	call	?GetIndexOf@?$List@PAVPluginInterface@@@DataStructures@@QAEIQAVPluginInterface@@@Z ; DataStructures::List<PluginInterface *>::GetIndexOf
	mov	DWORD PTR _index$[ebp], eax

; 2380 : 	if (index!=MAX_UNSIGNED_LONG)

	cmp	DWORD PTR _index$[ebp], -1
	je	$LN3@DetachPlug

; 2381 : 	{
; 2382 : 		messageHandlerList[index]->OnDetach(this);

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 941				; 000003adH
	call	??A?$List@PAVPluginInterface@@@DataStructures@@QBEAAPAVPluginInterface@@I@Z ; DataStructures::List<PluginInterface *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv76[ebp], ecx
	mov	esi, esp
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR tv76[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv76[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2383 : 		// Unordered list so delete from end for speed
; 2384 : 		messageHandlerList[index]=messageHandlerList[messageHandlerList.Size()-1];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 941				; 000003adH
	call	?Size@?$List@PAVPluginInterface@@@DataStructures@@QBEIXZ ; DataStructures::List<PluginInterface *>::Size
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 941				; 000003adH
	call	??A?$List@PAVPluginInterface@@@DataStructures@@QBEAAPAVPluginInterface@@I@Z ; DataStructures::List<PluginInterface *>::operator[]
	mov	esi, eax
	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 941				; 000003adH
	call	??A?$List@PAVPluginInterface@@@DataStructures@@QBEAAPAVPluginInterface@@I@Z ; DataStructures::List<PluginInterface *>::operator[]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 2385 : 		messageHandlerList.Del();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 941				; 000003adH
	call	?Del@?$List@PAVPluginInterface@@@DataStructures@@QAEXI@Z ; DataStructures::List<PluginInterface *>::Del
$LN3@DetachPlug:

; 2386 : 	}
; 2387 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?DetachPlugin@RakPeer@@UAEXPAVPluginInterface@@@Z ENDP	; RakPeer::DetachPlugin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?AttachPlugin@RakPeer@@UAEXPAVPluginInterface@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_plugin$ = 8						; size = 4
?AttachPlugin@RakPeer@@UAEXPAVPluginInterface@@@Z PROC	; RakPeer::AttachPlugin, COMDAT
; _this$ = ecx

; 2360 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2361 : 	if (messageHandlerList.GetIndexOf(plugin)==MAX_UNSIGNED_LONG)

	mov	eax, DWORD PTR _plugin$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 941				; 000003adH
	call	?GetIndexOf@?$List@PAVPluginInterface@@@DataStructures@@QAEIQAVPluginInterface@@@Z ; DataStructures::List<PluginInterface *>::GetIndexOf
	cmp	eax, -1
	jne	SHORT $LN2@AttachPlug

; 2362 : 	{
; 2363 : 		messageHandlerList.Insert(plugin);

	mov	eax, DWORD PTR _plugin$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 941				; 000003adH
	call	?Insert@?$List@PAVPluginInterface@@@DataStructures@@QAEXQAVPluginInterface@@@Z ; DataStructures::List<PluginInterface *>::Insert

; 2364 : 		plugin->OnAttach(this);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _plugin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _plugin$[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@AttachPlug:

; 2365 : 	}
; 2366 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?AttachPlugin@RakPeer@@UAEXPAVPluginInterface@@@Z ENDP	; RakPeer::AttachPlugin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?GetDecompressionRatio@RakPeer@@UBEMXZ
_TEXT	SEGMENT
tv93 = -232						; size = 4
tv88 = -228						; size = 8
tv84 = -220						; size = 4
tv78 = -216						; size = 8
tv74 = -208						; size = 4
_this$ = -8						; size = 4
?GetDecompressionRatio@RakPeer@@UBEMXZ PROC		; RakPeer::GetDecompressionRatio, COMDAT
; _this$ = ecx

; 2344 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2345 : 	if ( rawBytesReceived > 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2013], 0
	jbe	$LN2@GetDecompr

; 2346 : 	{
; 2347 : 		return ( float ) compressedBytesReceived / ( float ) rawBytesReceived;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2021]
	mov	DWORD PTR tv74[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv74[ebp]
	mov	edx, DWORD PTR tv74[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv78[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv78[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2013]
	mov	DWORD PTR tv84[ebp], ecx
	cvtsi2sd xmm1, DWORD PTR tv84[ebp]
	mov	edx, DWORD PTR tv84[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv88[ebp], xmm1
	cvtsd2ss xmm1, QWORD PTR tv88[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR tv93[ebp], xmm0
	fld	DWORD PTR tv93[ebp]
	jmp	SHORT $LN1@GetDecompr

; 2348 : 	}
; 2349 : 
; 2350 : 	else

	jmp	SHORT $LN1@GetDecompr
$LN2@GetDecompr:

; 2351 : 		return 0.0f;

	fldz
$LN1@GetDecompr:

; 2352 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDecompressionRatio@RakPeer@@UBEMXZ ENDP		; RakPeer::GetDecompressionRatio
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?GetCompressionRatio@RakPeer@@UBEMXZ
_TEXT	SEGMENT
tv93 = -232						; size = 4
tv88 = -228						; size = 8
tv84 = -220						; size = 4
tv78 = -216						; size = 8
tv74 = -208						; size = 4
_this$ = -8						; size = 4
?GetCompressionRatio@RakPeer@@UBEMXZ PROC		; RakPeer::GetCompressionRatio, COMDAT
; _this$ = ecx

; 2329 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2330 : 	if ( rawBytesSent > 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2009], 0
	jbe	$LN2@GetCompres

; 2331 : 	{
; 2332 : 		return ( float ) compressedBytesSent / ( float ) rawBytesSent;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2017]
	mov	DWORD PTR tv74[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv74[ebp]
	mov	edx, DWORD PTR tv74[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv78[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv78[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2009]
	mov	DWORD PTR tv84[ebp], ecx
	cvtsi2sd xmm1, DWORD PTR tv84[ebp]
	mov	edx, DWORD PTR tv84[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv88[ebp], xmm1
	cvtsd2ss xmm1, QWORD PTR tv88[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR tv93[ebp], xmm0
	fld	DWORD PTR tv93[ebp]
	jmp	SHORT $LN1@GetCompres

; 2333 : 	}
; 2334 : 
; 2335 : 	else

	jmp	SHORT $LN1@GetCompres
$LN2@GetCompres:

; 2336 : 		return 0.0f;

	fldz
$LN1@GetCompres:

; 2337 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCompressionRatio@RakPeer@@UBEMXZ ENDP		; RakPeer::GetCompressionRatio
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?DeleteCompressionLayer@RakPeer@@UAE_N_N@Z
_TEXT	SEGMENT
tv92 = -256						; size = 4
tv83 = -256						; size = 4
$T1 = -248						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
$T4 = -212						; size = 4
_this$ = -8						; size = 4
_inputLayer$ = 8					; size = 1
?DeleteCompressionLayer@RakPeer@@UAE_N_N@Z PROC		; RakPeer::DeleteCompressionLayer, COMDAT
; _this$ = ecx

; 2299 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2300 : 	if ( IsActive() )

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@DeleteComp

; 2301 : 		return false;

	xor	al, al
	jmp	$LN6@DeleteComp
$LN5@DeleteComp:

; 2302 : 
; 2303 : 	if ( inputLayer )

	movzx	eax, BYTE PTR _inputLayer$[ebp]
	test	eax, eax
	je	SHORT $LN4@DeleteComp

; 2304 : 	{
; 2305 : 		if ( inputTree )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2001], 0
	je	SHORT $LN3@DeleteComp

; 2306 : 		{
; 2307 : 			delete inputTree;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2001]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T1[ebp], edx
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN8@DeleteComp
	push	1
	mov	ecx, DWORD PTR $T1[ebp]
	call	??_GHuffmanEncodingTree@@QAEPAXI@Z
	mov	DWORD PTR tv83[ebp], eax
	jmp	SHORT $LN9@DeleteComp
$LN8@DeleteComp:
	mov	DWORD PTR tv83[ebp], 0
$LN9@DeleteComp:

; 2308 : 			inputTree = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2001], 0
$LN3@DeleteComp:

; 2309 : 		}
; 2310 : 	}
; 2311 : 
; 2312 : 	else

	jmp	SHORT $LN2@DeleteComp
$LN4@DeleteComp:

; 2313 : 	{
; 2314 : 		if ( outputTree )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2005], 0
	je	SHORT $LN2@DeleteComp

; 2315 : 		{
; 2316 : 			delete outputTree;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2005]
	mov	DWORD PTR $T4[ebp], ecx
	mov	edx, DWORD PTR $T4[ebp]
	mov	DWORD PTR $T3[ebp], edx
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN10@DeleteComp
	push	1
	mov	ecx, DWORD PTR $T3[ebp]
	call	??_GHuffmanEncodingTree@@QAEPAXI@Z
	mov	DWORD PTR tv92[ebp], eax
	jmp	SHORT $LN11@DeleteComp
$LN10@DeleteComp:
	mov	DWORD PTR tv92[ebp], 0
$LN11@DeleteComp:

; 2317 : 			outputTree = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2005], 0
$LN2@DeleteComp:

; 2318 : 		}
; 2319 : 	}
; 2320 : 
; 2321 : 	return true;

	mov	al, 1
$LN6@DeleteComp:

; 2322 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?DeleteCompressionLayer@RakPeer@@UAE_N_N@Z ENDP		; RakPeer::DeleteCompressionLayer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?GenerateCompressionLayer@RakPeer@@UAE_NQAI_N@Z
_TEXT	SEGMENT
tv135 = -268						; size = 4
tv92 = -268						; size = 4
$T2 = -260						; size = 4
$T3 = -248						; size = 4
$T4 = -236						; size = 4
$T5 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_inputFrequencyTable$ = 8				; size = 4
_inputLayer$ = 12					; size = 1
?GenerateCompressionLayer@RakPeer@@UAE_NQAI_N@Z PROC	; RakPeer::GenerateCompressionLayer, COMDAT
; _this$ = ecx

; 2266 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GenerateCompressionLayer@RakPeer@@UAE_NQAI_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-268]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2267 : 	if ( IsActive() )

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@GenerateCo

; 2268 : 		return false;

	xor	al, al
	jmp	$LN4@GenerateCo
$LN3@GenerateCo:

; 2269 : 
; 2270 : 	DeleteCompressionLayer( inputLayer );

	mov	esi, esp
	movzx	eax, BYTE PTR _inputLayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2271 : 
; 2272 : 	if ( inputLayer )

	movzx	eax, BYTE PTR _inputLayer$[ebp]
	test	eax, eax
	je	SHORT $LN2@GenerateCo

; 2273 : 	{
; 2274 : 		inputTree = new HuffmanEncodingTree;

	push	1540					; 00000604H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN6@GenerateCo
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0HuffmanEncodingTree@@QAE@XZ		; HuffmanEncodingTree::HuffmanEncodingTree
	mov	DWORD PTR tv92[ebp], eax
	jmp	SHORT $LN7@GenerateCo
$LN6@GenerateCo:
	mov	DWORD PTR tv92[ebp], 0
$LN7@GenerateCo:
	mov	eax, DWORD PTR tv92[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [ecx+2001], edx

; 2275 : 		inputTree->GenerateFromFrequencyTable( inputFrequencyTable );

	mov	eax, DWORD PTR _inputFrequencyTable$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+2001]
	call	?GenerateFromFrequencyTable@HuffmanEncodingTree@@QAEXQAI@Z ; HuffmanEncodingTree::GenerateFromFrequencyTable

; 2276 : 	}
; 2277 : 
; 2278 : 	else

	jmp	SHORT $LN1@GenerateCo
$LN2@GenerateCo:

; 2279 : 	{
; 2280 : 		outputTree = new HuffmanEncodingTree;

	push	1540					; 00000604H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN8@GenerateCo
	mov	ecx, DWORD PTR $T5[ebp]
	call	??0HuffmanEncodingTree@@QAE@XZ		; HuffmanEncodingTree::HuffmanEncodingTree
	mov	DWORD PTR tv135[ebp], eax
	jmp	SHORT $LN9@GenerateCo
$LN8@GenerateCo:
	mov	DWORD PTR tv135[ebp], 0
$LN9@GenerateCo:
	mov	eax, DWORD PTR tv135[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T4[ebp]
	mov	DWORD PTR [ecx+2005], edx

; 2281 : 		outputTree->GenerateFromFrequencyTable( inputFrequencyTable );

	mov	eax, DWORD PTR _inputFrequencyTable$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+2005]
	call	?GenerateFromFrequencyTable@HuffmanEncodingTree@@QAEXQAI@Z ; HuffmanEncodingTree::GenerateFromFrequencyTable
$LN1@GenerateCo:

; 2282 : 	}
; 2283 : 
; 2284 : 	return true;

	mov	al, 1
$LN4@GenerateCo:

; 2285 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 268				; 0000010cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GenerateCompressionLayer@RakPeer@@UAE_NQAI_N@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?GenerateCompressionLayer@RakPeer@@UAE_NQAI_N@Z$1:
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?GenerateCompressionLayer@RakPeer@@UAE_NQAI_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-272]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GenerateCompressionLayer@RakPeer@@UAE_NQAI_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GenerateCompressionLayer@RakPeer@@UAE_NQAI_N@Z ENDP	; RakPeer::GenerateCompressionLayer
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?GetOutgoingFrequencyTable@RakPeer@@UAE_NQAI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_outputFrequencyTable$ = 8				; size = 4
?GetOutgoingFrequencyTable@RakPeer@@UAE_NQAI@Z PROC	; RakPeer::GetOutgoingFrequencyTable, COMDAT
; _this$ = ecx

; 2237 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 	if ( IsActive() )

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@GetOutgoin

; 2239 : 		return false;

	xor	al, al
	jmp	SHORT $LN3@GetOutgoin
$LN2@GetOutgoin:

; 2240 : 
; 2241 : 	if ( trackFrequencyTable == false )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+2065]
	test	ecx, ecx
	jne	SHORT $LN1@GetOutgoin

; 2242 : 		return false;

	xor	al, al
	jmp	SHORT $LN3@GetOutgoin
$LN1@GetOutgoin:

; 2243 : 
; 2244 : 	memcpy( outputFrequencyTable, frequencyTable, sizeof( unsigned int ) * 256 );

	push	1024					; 00000400H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 977				; 000003d1H
	push	eax
	mov	ecx, DWORD PTR _outputFrequencyTable$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2245 : 
; 2246 : 	return true;

	mov	al, 1
$LN3@GetOutgoin:

; 2247 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetOutgoingFrequencyTable@RakPeer@@UAE_NQAI@Z ENDP	; RakPeer::GetOutgoingFrequencyTable
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?SetCompileFrequencyTable@RakPeer@@UAEX_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_doCompile$ = 8						; size = 1
?SetCompileFrequencyTable@RakPeer@@UAEX_N@Z PROC	; RakPeer::SetCompileFrequencyTable, COMDAT
; _this$ = ecx

; 2218 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2219 : 	trackFrequencyTable = doCompile;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _doCompile$[ebp]
	mov	BYTE PTR [eax+2065], cl

; 2220 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetCompileFrequencyTable@RakPeer@@UAEX_N@Z ENDP	; RakPeer::SetCompileFrequencyTable
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?SetUnreliableTimeout@RakPeer@@UAEXI@Z
_TEXT	SEGMENT
_i$1 = -20						; size = 2
_this$ = -8						; size = 4
_timeoutMS$ = 8						; size = 4
?SetUnreliableTimeout@RakPeer@@UAEXI@Z PROC		; RakPeer::SetUnreliableTimeout, COMDAT
; _this$ = ecx

; 2199 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2200 : 	RakAssert(timeoutMS>=0);

	cmp	DWORD PTR _timeoutMS$[ebp], 0
	jae	SHORT $LN6@SetUnrelia
	mov	eax, DWORD PTR ?__LINE__Var@?1??SetUnreliableTimeout@RakPeer@@UAEXI@Z@4JA
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_1BK@MHECFOMI@?$AAt?$AAi?$AAm?$AAe?$AAo?$AAu?$AAt?$AAM?$AAS?$AA?$DO?$AA?$DN?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN6@SetUnrelia:

; 2201 : 	unreliableTimeout=timeoutMS;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _timeoutMS$[ebp]
	mov	DWORD PTR [eax+2494], ecx

; 2202 : 	for ( unsigned short i = 0; i < maximumNumberOfPeers; i++ )

	xor	eax, eax
	mov	WORD PTR _i$1[ebp], ax
	jmp	SHORT $LN3@SetUnrelia
$LN2@SetUnrelia:
	mov	ax, WORD PTR _i$1[ebp]
	add	ax, 1
	mov	WORD PTR _i$1[ebp], ax
$LN3@SetUnrelia:
	movzx	eax, WORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+7]
	cmp	eax, edx
	jge	SHORT $LN4@SetUnrelia

; 2203 : 		remoteSystemList[ i ].reliabilityLayer.SetUnreliableTimeout(unreliableTimeout);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2494]
	push	ecx
	movzx	edx, WORD PTR _i$1[ebp]
	imul	eax, edx, 2058
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	lea	ecx, DWORD PTR [edx+eax+13]
	call	?SetUnreliableTimeout@ReliabilityLayer@@QAEXI@Z ; ReliabilityLayer::SetUnreliableTimeout
	jmp	SHORT $LN2@SetUnrelia
$LN4@SetUnrelia:

; 2204 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnreliableTimeout@RakPeer@@UAEXI@Z ENDP		; RakPeer::SetUnreliableTimeout
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?SetSplitMessageProgressInterval@RakPeer@@UAEXH@Z
_TEXT	SEGMENT
_i$1 = -20						; size = 2
_this$ = -8						; size = 4
_interval$ = 8						; size = 4
?SetSplitMessageProgressInterval@RakPeer@@UAEXH@Z PROC	; RakPeer::SetSplitMessageProgressInterval, COMDAT
; _this$ = ecx

; 2185 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2186 : 	RakAssert(interval>=0);

	cmp	DWORD PTR _interval$[ebp], 0
	jge	SHORT $LN6@SetSplitMe
	mov	eax, DWORD PTR ?__LINE__Var@?1??SetSplitMessageProgressInterval@RakPeer@@UAEXH@Z@4JA
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_1BI@DGKOLLFG@?$AAi?$AAn?$AAt?$AAe?$AAr?$AAv?$AAa?$AAl?$AA?$DO?$AA?$DN?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN6@SetSplitMe:

; 2187 : 	splitMessageProgressInterval=interval;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _interval$[ebp]
	mov	DWORD PTR [eax+2490], ecx

; 2188 : 	for ( unsigned short i = 0; i < maximumNumberOfPeers; i++ )

	xor	eax, eax
	mov	WORD PTR _i$1[ebp], ax
	jmp	SHORT $LN3@SetSplitMe
$LN2@SetSplitMe:
	mov	ax, WORD PTR _i$1[ebp]
	add	ax, 1
	mov	WORD PTR _i$1[ebp], ax
$LN3@SetSplitMe:
	movzx	eax, WORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+7]
	cmp	eax, edx
	jge	SHORT $LN4@SetSplitMe

; 2189 : 		remoteSystemList[ i ].reliabilityLayer.SetSplitMessageProgressInterval(splitMessageProgressInterval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2490]
	push	ecx
	movzx	edx, WORD PTR _i$1[ebp]
	imul	eax, edx, 2058
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	lea	ecx, DWORD PTR [edx+eax+13]
	call	?SetSplitMessageProgressInterval@ReliabilityLayer@@QAEXH@Z ; ReliabilityLayer::SetSplitMessageProgressInterval
	jmp	SHORT $LN2@SetSplitMe
$LN4@SetSplitMe:

; 2190 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSplitMessageProgressInterval@RakPeer@@UAEXH@Z ENDP	; RakPeer::SetSplitMessageProgressInterval
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?AdvertiseSystem@RakPeer@@UAEXPBDG0H@Z
_TEXT	SEGMENT
tv163 = -536						; size = 4
_i$ = -336						; size = 4
_bitStream$ = -324					; size = 273
_playerId$ = -40					; size = 6
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_host$ = 8						; size = 4
_remotePort$ = 12					; size = 2
_data$ = 16						; size = 4
_dataLength$ = 20					; size = 4
?AdvertiseSystem@RakPeer@@UAEXPBDG0H@Z PROC		; RakPeer::AdvertiseSystem, COMDAT
; _this$ = ecx

; 2099 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AdvertiseSystem@RakPeer@@UAEXPBDG0H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 524				; 0000020cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-536]
	mov	ecx, 131				; 00000083H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2100 : 	if ( IsActive() == false )

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN9@AdvertiseS

; 2101 : 		return ;

	jmp	$LN10@AdvertiseS
$LN9@AdvertiseS:

; 2102 : 
; 2103 : 	if (host==0)

	cmp	DWORD PTR _host$[ebp], 0
	jne	SHORT $LN8@AdvertiseS

; 2104 : 		return;

	jmp	$LN10@AdvertiseS
$LN8@AdvertiseS:

; 2105 : 
; 2106 : 	// This is a security measure.  Don't send data longer than this value
; 2107 : 	assert(dataLength <= MAX_OFFLINE_DATA_LENGTH);

	cmp	DWORD PTR _dataLength$[ebp], 400	; 00000190H
	jle	SHORT $LN12@AdvertiseS
	mov	eax, DWORD PTR ?__LINE__Var@?1??AdvertiseSystem@RakPeer@@UAEXPBDG0H@Z@4JA
	add	eax, 8
	push	eax
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_1EM@PPGDKCEI@?$AAd?$AAa?$AAt?$AAa?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAM?$AAA?$AAX?$AA_?$AAO?$AAF?$AAF?$AAL?$AAI?$AAN?$AAE?$AA_?$AAD?$AAA?$AAT?$AAA?$AA_?$AAL@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN12@AdvertiseS:

; 2108 : 	assert(dataLength>=0);

	cmp	DWORD PTR _dataLength$[ebp], 0
	jge	SHORT $LN13@AdvertiseS
	mov	eax, DWORD PTR ?__LINE__Var@?1??AdvertiseSystem@RakPeer@@UAEXPBDG0H@Z@4JA
	add	eax, 9
	push	eax
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_1BM@DNMMOAPD@?$AAd?$AAa?$AAt?$AAa?$AAL?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?$DO?$AA?$DN?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN13@AdvertiseS:

; 2109 : 
; 2110 : 	// If the host starts with something other than 0, 1, or 2 it's (probably) a domain name.
; 2111 : 	if ( host[ 0 ] < '0' || host[ 0 ] > '2' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _host$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN6@AdvertiseS
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _host$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 50					; 00000032H
	jle	SHORT $LN7@AdvertiseS
$LN6@AdvertiseS:

; 2112 : 	{
; 2113 : #if !defined(_COMPATIBILITY_1)
; 2114 : 		host = ( char* ) SocketLayer::Instance()->DomainNameToIP( host );

	mov	eax, DWORD PTR _host$[ebp]
	push	eax
	call	?Instance@SocketLayer@@SAPAV1@XZ	; SocketLayer::Instance
	mov	ecx, eax
	call	?DomainNameToIP@SocketLayer@@QAEPBDPBD@Z ; SocketLayer::DomainNameToIP
	mov	DWORD PTR _host$[ebp], eax
$LN7@AdvertiseS:

; 2115 : #else
; 2116 : 		return;
; 2117 : #endif
; 2118 : 	}
; 2119 : 
; 2120 : 	PlayerID playerId;
; 2121 : 	IPToPlayerID( host, remotePort, &playerId );

	mov	esi, esp
	lea	eax, DWORD PTR _playerId$[ebp]
	push	eax
	movzx	ecx, WORD PTR _remotePort$[ebp]
	push	ecx
	mov	edx, DWORD PTR _host$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+188]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2122 : 
; 2123 : 	RakNet::BitStream bitStream;

	lea	ecx, DWORD PTR _bitStream$[ebp]
	call	??0BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2124 : 	bitStream.Write((unsigned char)ID_ADVERTISE_SYSTEM);

	push	54					; 00000036H
	lea	ecx, DWORD PTR _bitStream$[ebp]
	call	??$Write@E@BitStream@RakNet@@QAEXE@Z	; RakNet::BitStream::Write<unsigned char>

; 2125 : 	if (dataLength>0)

	cmp	DWORD PTR _dataLength$[ebp], 0
	jle	SHORT $LN5@AdvertiseS

; 2126 : 		bitStream.Write(data, dataLength);

	mov	eax, DWORD PTR _dataLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _bitStream$[ebp]
	call	?Write@BitStream@RakNet@@QAEXPBDH@Z	; RakNet::BitStream::Write

; 2127 : 	else

	jmp	SHORT $LN4@AdvertiseS
$LN5@AdvertiseS:

; 2128 : 		bitStream.Write((unsigned char)0); // Pad

	push	0
	lea	ecx, DWORD PTR _bitStream$[ebp]
	call	??$Write@E@BitStream@RakNet@@QAEXE@Z	; RakNet::BitStream::Write<unsigned char>
$LN4@AdvertiseS:

; 2129 : 
; 2130 : 	unsigned i;
; 2131 : 	for (i=0; i < messageHandlerList.Size(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@AdvertiseS
$LN2@AdvertiseS:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@AdvertiseS:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 941				; 000003adH
	call	?Size@?$List@PAVPluginInterface@@@DataStructures@@QBEIXZ ; DataStructures::List<PluginInterface *>::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN1@AdvertiseS

; 2132 : 		messageHandlerList[i]->OnDirectSocketSend((const char*)bitStream.GetData(), bitStream.GetNumberOfBitsUsed(), playerId);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 941				; 000003adH
	call	??A?$List@PAVPluginInterface@@@DataStructures@@QBEAAPAVPluginInterface@@I@Z ; DataStructures::List<PluginInterface *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv163[ebp], ecx
	mov	esi, esp
	sub	esp, 8
	mov	edx, esp
	mov	eax, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [edx], eax
	mov	cx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [edx+4], cx
	lea	ecx, DWORD PTR _bitStream$[ebp]
	call	?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBitsUsed
	push	eax
	lea	ecx, DWORD PTR _bitStream$[ebp]
	call	?GetData@BitStream@RakNet@@QBEPAEXZ	; RakNet::BitStream::GetData
	push	eax
	mov	edx, DWORD PTR tv163[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv163[ebp]
	mov	edx, DWORD PTR [eax+28]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	$LN2@AdvertiseS
$LN1@AdvertiseS:

; 2133 : 	SocketLayer::Instance()->SendTo( connectionSocket, (const char*)bitStream.GetData(), bitStream.GetNumberOfBytesUsed(), ( char* ) host, remotePort );

	movzx	eax, WORD PTR _remotePort$[ebp]
	push	eax
	mov	ecx, DWORD PTR _host$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _bitStream$[ebp]
	call	?GetNumberOfBytesUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBytesUsed
	push	eax
	lea	ecx, DWORD PTR _bitStream$[ebp]
	call	?GetData@BitStream@RakNet@@QBEPAEXZ	; RakNet::BitStream::GetData
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2070]
	push	eax
	call	?Instance@SocketLayer@@SAPAV1@XZ	; SocketLayer::Instance
	mov	ecx, eax
	call	?SendTo@SocketLayer@@QAEHIPBDHQADG@Z	; SocketLayer::SendTo

; 2134 : 
; 2135 : 
; 2136 : 
; 2137 : 	/*
; 2138 : 	// If the host starts with something other than 0, 1, or 2 it's (probably) a domain name.
; 2139 : 	if ( host[ 0 ] < '0' || host[ 0 ] > '2' )
; 2140 : 	{
; 2141 : #if !defined(_COMPATIBILITY_1)
; 2142 : 		host = ( char* ) SocketLayer::Instance()->DomainNameToIP( host );
; 2143 : #else
; 2144 : 		return;
; 2145 : #endif
; 2146 : 	}
; 2147 : 
; 2148 : 	PlayerID playerId;
; 2149 : 	IPToPlayerID( host, remotePort, &playerId );
; 2150 : 
; 2151 : 	RequestedConnectionStruct *rcs;
; 2152 : #ifdef _RAKNET_THREADSAFE
; 2153 : 	rakPeerMutexes[requestedConnectionList_Mutex].Lock();
; 2154 : #endif
; 2155 : 	rcs = requestedConnectionList.WriteLock();
; 2156 : 	rcs->playerId=playerId;
; 2157 : 	rcs->nextRequestTime=RakNet::GetTime();
; 2158 : 	rcs->requestsMade=0;
; 2159 : 	if (data && dataLength>0)
; 2160 : 	{
; 2161 : 		rcs->data=new char [dataLength];
; 2162 : 		rcs->dataLength=(unsigned short)dataLength;
; 2163 : 		memcpy(rcs->data, data, dataLength);
; 2164 : 	}
; 2165 : 	else
; 2166 : 	{
; 2167 : 		rcs->data=0;
; 2168 : 		rcs->dataLength=0;
; 2169 : 	}
; 2170 : 	rcs->actionToTake=RequestedConnectionStruct::ADVERTISE_SYSTEM;
; 2171 : 	requestedConnectionList.WriteUnlock();
; 2172 : #ifdef _RAKNET_THREADSAFE
; 2173 : 	rakPeerMutexes[requestedConnectionList_Mutex].Unlock();
; 2174 : #endif
; 2175 : 	*/
; 2176 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _bitStream$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
$LN10@AdvertiseS:
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN19@AdvertiseS
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 536				; 00000218H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	npad	3
$LN19@AdvertiseS:
	DD	2
	DD	$LN18@AdvertiseS
$LN18@AdvertiseS:
	DD	-40					; ffffffd8H
	DD	6
	DD	$LN15@AdvertiseS
	DD	-324					; fffffebcH
	DD	273					; 00000111H
	DD	$LN16@AdvertiseS
$LN16@AdvertiseS:
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	0
$LN15@AdvertiseS:
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	73					; 00000049H
	DB	100					; 00000064H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AdvertiseSystem@RakPeer@@UAEXPBDG0H@Z$0:
	lea	ecx, DWORD PTR _bitStream$[ebp]
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__ehhandler$?AdvertiseSystem@RakPeer@@UAEXPBDG0H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-540]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AdvertiseSystem@RakPeer@@UAEXPBDG0H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AdvertiseSystem@RakPeer@@UAEXPBDG0H@Z ENDP		; RakPeer::AdvertiseSystem
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?AllowConnectionResponseIPMigration@RakPeer@@UAEX_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_allow$ = 8						; size = 1
?AllowConnectionResponseIPMigration@RakPeer@@UAEX_N@Z PROC ; RakPeer::AllowConnectionResponseIPMigration, COMDAT
; _this$ = ecx

; 2083 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2084 : 	allowConnectionResponseIPMigration = allow;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _allow$[ebp]
	mov	BYTE PTR [eax+2489], cl

; 2085 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AllowConnectionResponseIPMigration@RakPeer@@UAEX_N@Z ENDP ; RakPeer::AllowConnectionResponseIPMigration
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?IPToPlayerID@RakPeer@@UAEXPBDGPAUPlayerID@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_host$ = 8						; size = 4
_remotePort$ = 12					; size = 2
_playerId$ = 16						; size = 4
?IPToPlayerID@RakPeer@@UAEXPBDGPAUPlayerID@@@Z PROC	; RakPeer::IPToPlayerID, COMDAT
; _this$ = ecx

; 2588 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2589 : 	if ( host == 0 )

	cmp	DWORD PTR _host$[ebp], 0
	jne	SHORT $LN1@IPToPlayer

; 2590 : 		return ;

	jmp	SHORT $LN2@IPToPlayer
$LN1@IPToPlayer:

; 2591 : 
; 2592 : 	playerId->binaryAddress = inet_addr( host );

	mov	esi, esp
	mov	eax, DWORD PTR _host$[ebp]
	push	eax
	call	DWORD PTR __imp__inet_addr@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [ecx], eax

; 2593 : 
; 2594 : 	playerId->port = remotePort;

	mov	eax, DWORD PTR _playerId$[ebp]
	mov	cx, WORD PTR _remotePort$[ebp]
	mov	WORD PTR [eax+4], cx
$LN2@IPToPlayer:

; 2595 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?IPToPlayerID@RakPeer@@UAEXPBDGPAUPlayerID@@@Z ENDP	; RakPeer::IPToPlayerID
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?PlayerIDToDottedIP@RakPeer@@UBEPBDUPlayerID@@@Z
_TEXT	SEGMENT
_in$ = -20						; size = 4
_this$ = -8						; size = 4
_playerId$ = 8						; size = 6
?PlayerIDToDottedIP@RakPeer@@UBEPBDUPlayerID@@@Z PROC	; RakPeer::PlayerIDToDottedIP, COMDAT
; _this$ = ecx

; 2040 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2041 : #if !defined(_COMPATIBILITY_1)
; 2042 : 	in_addr in;
; 2043 : 	in.s_addr = playerId.binaryAddress;

	mov	eax, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR _in$[ebp], eax

; 2044 : 	return inet_ntoa( in );

	mov	esi, esp
	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	call	DWORD PTR __imp__inet_ntoa@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2045 : #else
; 2046 : 	assert(0); // Not supported
; 2047 : 	return 0;
; 2048 : #endif
; 2049 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@PlayerIDTo
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN5@PlayerIDTo:
	DD	1
	DD	$LN4@PlayerIDTo
$LN4@PlayerIDTo:
	DD	-20					; ffffffecH
	DD	4
	DD	$LN3@PlayerIDTo
$LN3@PlayerIDTo:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	0
?PlayerIDToDottedIP@RakPeer@@UBEPBDUPlayerID@@@Z ENDP	; RakPeer::PlayerIDToDottedIP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?GetLocalIP@RakPeer@@UAEPBDI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_index$ = 8						; size = 4
?GetLocalIP@RakPeer@@UAEPBDI@Z PROC			; RakPeer::GetLocalIP, COMDAT
; _this$ = ecx

; 2056 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2057 : #if !defined(_COMPATIBILITY_1)
; 2058 : 	static char ipList[ 10 ][ 16 ];
; 2059 : 
; 2060 : 	if ( index >= 10 )

	cmp	DWORD PTR _index$[ebp], 10		; 0000000aH
	jb	SHORT $LN1@GetLocalIP

; 2061 : 		index = 9;

	mov	DWORD PTR _index$[ebp], 9
$LN1@GetLocalIP:

; 2062 : 
; 2063 : 	memset( ipList, 0, sizeof( char ) * 16 * 10 );

	push	160					; 000000a0H
	push	0
	push	OFFSET ?ipList@?1??GetLocalIP@RakPeer@@UAEPBDI@Z@4PAY0BA@DA
	call	_memset
	add	esp, 12					; 0000000cH

; 2064 : 
; 2065 : 	SocketLayer::Instance()->GetMyIP( ipList );

	push	OFFSET ?ipList@?1??GetLocalIP@RakPeer@@UAEPBDI@Z@4PAY0BA@DA
	call	?Instance@SocketLayer@@SAPAV1@XZ	; SocketLayer::Instance
	mov	ecx, eax
	call	?GetMyIP@SocketLayer@@QAEXQAY0BA@D@Z	; SocketLayer::GetMyIP

; 2066 : 
; 2067 : 	return ipList[ index ];

	mov	eax, DWORD PTR _index$[ebp]
	shl	eax, 4
	add	eax, OFFSET ?ipList@?1??GetLocalIP@RakPeer@@UAEPBDI@Z@4PAY0BA@DA

; 2068 : #else
; 2069 : 	assert(0);
; 2070 : 	return 0;
; 2071 : #endif
; 2072 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetLocalIP@RakPeer@@UAEPBDI@Z ENDP			; RakPeer::GetLocalIP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?GetNumberOfAddresses@RakPeer@@UAEIXZ
_TEXT	SEGMENT
_i$ = -192						; size = 4
_ipList$ = -180						; size = 160
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?GetNumberOfAddresses@RakPeer@@UAEIXZ PROC		; RakPeer::GetNumberOfAddresses, COMDAT
; _this$ = ecx

; 2014 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 388				; 00000184H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-388]
	mov	ecx, 97					; 00000061H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 2015 : #if !defined(_COMPATIBILITY_1)
; 2016 : 	char ipList[ 10 ][ 16 ];
; 2017 : 	memset( ipList, 0, sizeof( char ) * 16 * 10 );

	push	160					; 000000a0H
	push	0
	lea	eax, DWORD PTR _ipList$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2018 : 	SocketLayer::Instance()->GetMyIP( ipList );

	lea	eax, DWORD PTR _ipList$[ebp]
	push	eax
	call	?Instance@SocketLayer@@SAPAV1@XZ	; SocketLayer::Instance
	mov	ecx, eax
	call	?GetMyIP@SocketLayer@@QAEXQAY0BA@D@Z	; SocketLayer::GetMyIP

; 2019 : 
; 2020 : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0
$LN2@GetNumberO:

; 2021 : 
; 2022 : 	while ( ipList[ i ][ 0 ] )

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	lea	ecx, DWORD PTR _ipList$[ebp+eax]
	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR [ecx+eax]
	test	ecx, ecx
	je	SHORT $LN1@GetNumberO

; 2023 : 		i++;

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN2@GetNumberO
$LN1@GetNumberO:

; 2024 : 
; 2025 : 	return i;

	mov	eax, DWORD PTR _i$[ebp]

; 2026 : #else
; 2027 : 	assert(0);
; 2028 : 	return 0;
; 2029 : #endif
; 2030 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@GetNumberO
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 388				; 00000184H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN7@GetNumberO:
	DD	1
	DD	$LN6@GetNumberO
$LN6@GetNumberO:
	DD	-180					; ffffff4cH
	DD	160					; 000000a0H
	DD	$LN5@GetNumberO
$LN5@GetNumberO:
	DB	105					; 00000069H
	DB	112					; 00000070H
	DB	76					; 0000004cH
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
?GetNumberOfAddresses@RakPeer@@UAEIXZ ENDP		; RakPeer::GetNumberOfAddresses
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?GetMTUSize@RakPeer@@UBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetMTUSize@RakPeer@@UBEHXZ PROC			; RakPeer::GetMTUSize, COMDAT
; _this$ = ecx

; 2005 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2006 : 	return MTUSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+2061]

; 2007 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMTUSize@RakPeer@@UBEHXZ ENDP			; RakPeer::GetMTUSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?SetMTUSize@RakPeer@@UAE_NH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_size$ = 8						; size = 4
?SetMTUSize@RakPeer@@UAE_NH@Z PROC			; RakPeer::SetMTUSize, COMDAT
; _this$ = ecx

; 1983 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1984 : 	if ( IsActive() )

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@SetMTUSize

; 1985 : 		return false;

	xor	al, al
	jmp	SHORT $LN5@SetMTUSize
$LN4@SetMTUSize:

; 1986 : 
; 1987 : 	if ( size < 512 )

	cmp	DWORD PTR _size$[ebp], 512		; 00000200H
	jge	SHORT $LN3@SetMTUSize

; 1988 : 		size = 512;

	mov	DWORD PTR _size$[ebp], 512		; 00000200H
	jmp	SHORT $LN2@SetMTUSize
$LN3@SetMTUSize:

; 1989 : 	else if ( size > MAXIMUM_MTU_SIZE )

	cmp	DWORD PTR _size$[ebp], 576		; 00000240H
	jle	SHORT $LN2@SetMTUSize

; 1990 : 		size = MAXIMUM_MTU_SIZE;

	mov	DWORD PTR _size$[ebp], 576		; 00000240H
$LN2@SetMTUSize:

; 1991 : 
; 1992 : 	MTUSize = size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [eax+2061], ecx

; 1993 : 
; 1994 : 	return true;

	mov	al, 1
$LN5@SetMTUSize:

; 1995 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetMTUSize@RakPeer@@UAE_NH@Z ENDP			; RakPeer::SetMTUSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?SetTimeoutTime@RakPeer@@UAEXIUPlayerID@@@Z
_TEXT	SEGMENT
_remoteSystem$ = -20					; size = 4
_this$ = -8						; size = 4
_timeMS$ = 8						; size = 4
_target$ = 12						; size = 6
?SetTimeoutTime@RakPeer@@UAEXIUPlayerID@@@Z PROC	; RakPeer::SetTimeoutTime, COMDAT
; _this$ = ecx

; 1953 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1954 : 	RemoteSystemStruct * remoteSystem = GetRemoteSystemFromPlayerID( target, false, true );

	push	1
	push	0
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _target$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _target$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRemoteSystemFromPlayerID@RakPeer@@IBEPAURemoteSystemStruct@1@UPlayerID@@_N1@Z ; RakPeer::GetRemoteSystemFromPlayerID
	mov	DWORD PTR _remoteSystem$[ebp], eax

; 1955 : 
; 1956 : 	if ( remoteSystem != 0 )

	cmp	DWORD PTR _remoteSystem$[ebp], 0
	je	SHORT $LN2@SetTimeout

; 1957 : 		remoteSystem->reliabilityLayer.SetTimeoutTime(timeMS);

	mov	eax, DWORD PTR _timeMS$[ebp]
	push	eax
	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	add	ecx, 13					; 0000000dH
	call	?SetTimeoutTime@ReliabilityLayer@@QAEXI@Z ; ReliabilityLayer::SetTimeoutTime
$LN2@SetTimeout:

; 1958 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetTimeoutTime@RakPeer@@UAEXIUPlayerID@@@Z ENDP	; RakPeer::SetTimeoutTime
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?GetExternalID@RakPeer@@UBE?AUPlayerID@@U2@@Z
_TEXT	SEGMENT
_inactiveExternalId$ = -36				; size = 6
_i$ = -20						; size = 4
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
_target$ = 12						; size = 6
?GetExternalID@RakPeer@@UBE?AUPlayerID@@U2@@Z PROC	; RakPeer::GetExternalID, COMDAT
; _this$ = ecx

; 1927 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1928 : 	unsigned i;
; 1929 : 	PlayerID inactiveExternalId;
; 1930 : 
; 1931 : 	inactiveExternalId=UNASSIGNED_PLAYER_ID;

	push	OFFSET _UNASSIGNED_PLAYER_ID
	lea	ecx, DWORD PTR _inactiveExternalId$[ebp]
	call	??4PlayerID@@QAEAAU0@ABU0@@Z		; PlayerID::operator=

; 1932 : 
; 1933 : 	// First check for active connection with this playerId
; 1934 : 	for ( i = 0; i < maximumNumberOfPeers; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@GetExterna
$LN6@GetExterna:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@GetExterna:
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+7]
	cmp	DWORD PTR _i$[ebp], ecx
	jae	$LN5@GetExterna

; 1935 : 	{
; 1936 : 		if (remoteSystemList[ i ].playerId == target || target==UNASSIGNED_PLAYER_ID )

	lea	eax, DWORD PTR _target$[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$[ebp], 2058
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+820]
	lea	ecx, DWORD PTR [eax+ecx+1]
	call	??8PlayerID@@QBE_NABU0@@Z		; PlayerID::operator==
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@GetExterna
	push	OFFSET _UNASSIGNED_PLAYER_ID
	lea	ecx, DWORD PTR _target$[ebp]
	call	??8PlayerID@@QBE_NABU0@@Z		; PlayerID::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@GetExterna
$LN3@GetExterna:

; 1937 : 		{
; 1938 : 			if ( remoteSystemList[ i ].isActive )

	imul	eax, DWORD PTR _i$[ebp], 2058
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	movzx	eax, BYTE PTR [edx+eax]
	test	eax, eax
	je	SHORT $LN2@GetExterna

; 1939 : 				return remoteSystemList[ i ].myExternalPlayerId;

	imul	eax, DWORD PTR _i$[ebp], 2058
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	lea	eax, DWORD PTR [edx+eax+7]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	ax, WORD PTR [eax+4]
	mov	WORD PTR [ecx+4], ax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN8@GetExterna

; 1940 : 			else

	jmp	SHORT $LN4@GetExterna
$LN2@GetExterna:

; 1941 : 				inactiveExternalId=remoteSystemList[ i ].myExternalPlayerId;

	imul	eax, DWORD PTR _i$[ebp], 2058
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	lea	eax, DWORD PTR [edx+eax+7]
	push	eax
	lea	ecx, DWORD PTR _inactiveExternalId$[ebp]
	call	??4PlayerID@@QAEAAU0@ABU0@@Z		; PlayerID::operator=
$LN4@GetExterna:

; 1942 : 		}
; 1943 : 	}

	jmp	$LN6@GetExterna
$LN5@GetExterna:

; 1944 : 
; 1945 : 	return inactiveExternalId;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR _inactiveExternalId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _inactiveExternalId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN8@GetExterna:

; 1946 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@GetExterna
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN12@GetExterna:
	DD	1
	DD	$LN11@GetExterna
$LN11@GetExterna:
	DD	-36					; ffffffdcH
	DD	6
	DD	$LN10@GetExterna
$LN10@GetExterna:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	73					; 00000049H
	DB	100					; 00000064H
	DB	0
?GetExternalID@RakPeer@@UBE?AUPlayerID@@U2@@Z ENDP	; RakPeer::GetExternalID
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?GetInternalID@RakPeer@@UBE?AUPlayerID@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetInternalID@RakPeer@@UBE?AUPlayerID@@XZ PROC		; RakPeer::GetInternalID, COMDAT
; _this$ = ecx

; 1913 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1914 : 	return myPlayerId;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 557				; 0000022dH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	ax, WORD PTR [eax+4]
	mov	WORD PTR [ecx+4], ax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1915 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetInternalID@RakPeer@@UBE?AUPlayerID@@XZ ENDP		; RakPeer::GetInternalID
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?SetOfflinePingResponse@RakPeer@@UAEXPBDI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_data$ = 8						; size = 4
_length$ = 12						; size = 4
?SetOfflinePingResponse@RakPeer@@UAEXPBDI@Z PROC	; RakPeer::SetOfflinePingResponse, COMDAT
; _this$ = ecx

; 1895 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1896 : 	assert(length < 400);

	cmp	DWORD PTR _length$[ebp], 400		; 00000190H
	jb	SHORT $LN4@SetOffline
	mov	eax, DWORD PTR ?__LINE__Var@?1??SetOfflinePingResponse@RakPeer@@UAEXPBDI@Z@4JA
	add	eax, 1
	push	eax
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_1BK@PNPFLKAA@?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DM?$AA?5?$AA4?$AA0?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN4@SetOffline:

; 1897 : 
; 1898 : 	rakPeerMutexes[ offlinePingResponse_Mutex ].Lock();

	mov	eax, 24					; 00000018H
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+836]
	call	?Lock@SimpleMutex@@QAEXXZ		; SimpleMutex::Lock

; 1899 : 	offlinePingResponse.Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 284				; 0000011cH
	call	?Reset@BitStream@RakNet@@QAEXXZ		; RakNet::BitStream::Reset

; 1900 : 
; 1901 : 	if ( data && length > 0 )

	cmp	DWORD PTR _data$[ebp], 0
	je	SHORT $LN1@SetOffline
	cmp	DWORD PTR _length$[ebp], 0
	jbe	SHORT $LN1@SetOffline

; 1902 : 		offlinePingResponse.Write( data, length );

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 284				; 0000011cH
	call	?Write@BitStream@RakNet@@QAEXPBDH@Z	; RakNet::BitStream::Write
$LN1@SetOffline:

; 1903 : 
; 1904 : 	rakPeerMutexes[ offlinePingResponse_Mutex ].Unlock();

	mov	eax, 24					; 00000018H
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+836]
	call	?Unlock@SimpleMutex@@QAEXXZ		; SimpleMutex::Unlock

; 1905 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?SetOfflinePingResponse@RakPeer@@UAEXPBDI@Z ENDP	; RakPeer::SetOfflinePingResponse
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?SendStaticData@RakPeer@@UAEXUPlayerID@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_target$ = 8						; size = 6
?SendStaticData@RakPeer@@UAEXUPlayerID@@@Z PROC		; RakPeer::SendStaticData, COMDAT
; _this$ = ecx

; 1882 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1883 : 	SendStaticDataInternal(target, false);

	push	0
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _target$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _target$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendStaticDataInternal@RakPeer@@IAEXUPlayerID@@_N@Z ; RakPeer::SendStaticDataInternal

; 1884 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?SendStaticData@RakPeer@@UAEXUPlayerID@@@Z ENDP		; RakPeer::SendStaticData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?SetRemoteStaticData@RakPeer@@UAEXUPlayerID@@PBDH@Z
_TEXT	SEGMENT
_remoteSystem$1 = -20					; size = 4
_this$ = -8						; size = 4
_playerId$ = 8						; size = 6
_data$ = 16						; size = 4
_length$ = 20						; size = 4
?SetRemoteStaticData@RakPeer@@UAEXUPlayerID@@PBDH@Z PROC ; RakPeer::SetRemoteStaticData, COMDAT
; _this$ = ecx

; 1852 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1853 : 	if ( playerId == myPlayerId )

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 557				; 0000022dH
	push	eax
	lea	ecx, DWORD PTR _playerId$[ebp]
	call	??8PlayerID@@QBE_NABU0@@Z		; PlayerID::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@SetRemoteS

; 1854 : 	{
; 1855 : 		localStaticData.Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 11					; 0000000bH
	call	?Reset@BitStream@RakNet@@QAEXXZ		; RakNet::BitStream::Reset

; 1856 : 
; 1857 : 		if ( data && length > 0 )

	cmp	DWORD PTR _data$[ebp], 0
	je	SHORT $LN3@SetRemoteS
	cmp	DWORD PTR _length$[ebp], 0
	jle	SHORT $LN3@SetRemoteS

; 1858 : 			localStaticData.Write( data, length );

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 11					; 0000000bH
	call	?Write@BitStream@RakNet@@QAEXPBDH@Z	; RakNet::BitStream::Write
$LN3@SetRemoteS:

; 1859 : 	}
; 1860 : 	else

	jmp	SHORT $LN5@SetRemoteS
$LN4@SetRemoteS:

; 1861 : 	{
; 1862 : 		RemoteSystemStruct *remoteSystem = GetRemoteSystemFromPlayerID( playerId, false, true );

	push	1
	push	0
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRemoteSystemFromPlayerID@RakPeer@@IBEPAURemoteSystemStruct@1@UPlayerID@@_N1@Z ; RakPeer::GetRemoteSystemFromPlayerID
	mov	DWORD PTR _remoteSystem$1[ebp], eax

; 1863 : 
; 1864 : 		if ( remoteSystem == 0 )

	cmp	DWORD PTR _remoteSystem$1[ebp], 0
	jne	SHORT $LN1@SetRemoteS

; 1865 : 			return;

	jmp	SHORT $LN5@SetRemoteS
$LN1@SetRemoteS:

; 1866 : 
; 1867 : 		remoteSystem->staticData.Reset();

	mov	ecx, DWORD PTR _remoteSystem$1[ebp]
	add	ecx, 1748				; 000006d4H
	call	?Reset@BitStream@RakNet@@QAEXXZ		; RakNet::BitStream::Reset

; 1868 : 		remoteSystem->staticData.Write( data, length );

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _remoteSystem$1[ebp]
	add	ecx, 1748				; 000006d4H
	call	?Write@BitStream@RakNet@@QAEXPBDH@Z	; RakNet::BitStream::Write
$LN5@SetRemoteS:

; 1869 : 	}
; 1870 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?SetRemoteStaticData@RakPeer@@UAEXUPlayerID@@PBDH@Z ENDP ; RakPeer::SetRemoteStaticData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?GetRemoteStaticData@RakPeer@@UAEPAVBitStream@RakNet@@UPlayerID@@@Z
_TEXT	SEGMENT
_remoteSystem$ = -20					; size = 4
_this$ = -8						; size = 4
_playerId$ = 8						; size = 6
?GetRemoteStaticData@RakPeer@@UAEPAVBitStream@RakNet@@UPlayerID@@@Z PROC ; RakPeer::GetRemoteStaticData, COMDAT
; _this$ = ecx

; 1829 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1830 : 	if ( playerId == myPlayerId )

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 557				; 0000022dH
	push	eax
	lea	ecx, DWORD PTR _playerId$[ebp]
	call	??8PlayerID@@QBE_NABU0@@Z		; PlayerID::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@GetRemoteS

; 1831 : 		return & localStaticData;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 11					; 0000000bH
	jmp	SHORT $LN4@GetRemoteS
$LN3@GetRemoteS:

; 1832 : 
; 1833 : 	RemoteSystemStruct *remoteSystem = GetRemoteSystemFromPlayerID( playerId, false, false );

	push	0
	push	0
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRemoteSystemFromPlayerID@RakPeer@@IBEPAURemoteSystemStruct@1@UPlayerID@@_N1@Z ; RakPeer::GetRemoteSystemFromPlayerID
	mov	DWORD PTR _remoteSystem$[ebp], eax

; 1834 : 
; 1835 : 	if ( remoteSystem )

	cmp	DWORD PTR _remoteSystem$[ebp], 0
	je	SHORT $LN2@GetRemoteS

; 1836 : 		return &(remoteSystem->staticData);

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	add	eax, 1748				; 000006d4H
	jmp	SHORT $LN4@GetRemoteS

; 1837 : 	else

	jmp	SHORT $LN4@GetRemoteS
$LN2@GetRemoteS:

; 1838 : 		return 0;

	xor	eax, eax
$LN4@GetRemoteS:

; 1839 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?GetRemoteStaticData@RakPeer@@UAEPAVBitStream@RakNet@@UPlayerID@@@Z ENDP ; RakPeer::GetRemoteStaticData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?SetOccasionalPing@RakPeer@@UAEX_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_doPing$ = 8						; size = 1
?SetOccasionalPing@RakPeer@@UAEX_N@Z PROC		; RakPeer::SetOccasionalPing, COMDAT
; _this$ = ecx

; 1813 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1814 : 	occasionalPing = doPing;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _doPing$[ebp]
	mov	BYTE PTR [eax+6], cl

; 1815 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetOccasionalPing@RakPeer@@UAEX_N@Z ENDP		; RakPeer::SetOccasionalPing
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?GetLowestPing@RakPeer@@UBEHUPlayerID@@@Z
_TEXT	SEGMENT
_remoteSystem$ = -20					; size = 4
_this$ = -8						; size = 4
_playerId$ = 8						; size = 6
?GetLowestPing@RakPeer@@UBEHUPlayerID@@@Z PROC		; RakPeer::GetLowestPing, COMDAT
; _this$ = ecx

; 1795 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1796 : 	RemoteSystemStruct * remoteSystem = GetRemoteSystemFromPlayerID( playerId, false, false );

	push	0
	push	0
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRemoteSystemFromPlayerID@RakPeer@@IBEPAURemoteSystemStruct@1@UPlayerID@@_N1@Z ; RakPeer::GetRemoteSystemFromPlayerID
	mov	DWORD PTR _remoteSystem$[ebp], eax

; 1797 : 
; 1798 : 	if ( remoteSystem == 0 )

	cmp	DWORD PTR _remoteSystem$[ebp], 0
	jne	SHORT $LN1@GetLowestP

; 1799 : 		return -1;

	or	eax, -1
	jmp	SHORT $LN2@GetLowestP
$LN1@GetLowestP:

; 1800 : 
; 1801 : 	return remoteSystem->lowestPing;

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	movzx	eax, WORD PTR [eax+1738]
$LN2@GetLowestP:

; 1802 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?GetLowestPing@RakPeer@@UBEHUPlayerID@@@Z ENDP		; RakPeer::GetLowestPing
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?GetLastPing@RakPeer@@UBEHUPlayerID@@@Z
_TEXT	SEGMENT
_remoteSystem$ = -20					; size = 4
_this$ = -8						; size = 4
_playerId$ = 8						; size = 6
?GetLastPing@RakPeer@@UBEHUPlayerID@@@Z PROC		; RakPeer::GetLastPing, COMDAT
; _this$ = ecx

; 1775 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1776 : 	RemoteSystemStruct * remoteSystem = GetRemoteSystemFromPlayerID( playerId, false, false );

	push	0
	push	0
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRemoteSystemFromPlayerID@RakPeer@@IBEPAURemoteSystemStruct@1@UPlayerID@@_N1@Z ; RakPeer::GetRemoteSystemFromPlayerID
	mov	DWORD PTR _remoteSystem$[ebp], eax

; 1777 : 
; 1778 : 	if ( remoteSystem == 0 )

	cmp	DWORD PTR _remoteSystem$[ebp], 0
	jne	SHORT $LN3@GetLastPin

; 1779 : 		return -1;

	or	eax, -1
	jmp	SHORT $LN4@GetLastPin
$LN3@GetLastPin:

; 1780 : 
; 1781 : 	if ( remoteSystem->pingAndClockDifferentialWriteIndex == 0 )

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	cmp	DWORD PTR [eax+1734], 0
	jne	SHORT $LN2@GetLastPin

; 1782 : 		return remoteSystem->pingAndClockDifferential[ PING_TIMES_ARRAY_SIZE - 1 ].pingTime;

	mov	eax, 6
	shl	eax, 2
	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	movzx	eax, WORD PTR [ecx+eax+1704]
	jmp	SHORT $LN4@GetLastPin

; 1783 : 	else

	jmp	SHORT $LN4@GetLastPin
$LN2@GetLastPin:

; 1784 : 		return remoteSystem->pingAndClockDifferential[ remoteSystem->pingAndClockDifferentialWriteIndex - 1 ].pingTime;

	mov	eax, DWORD PTR _remoteSystem$[ebp]
	mov	ecx, DWORD PTR [eax+1734]
	sub	ecx, 1
	imul	edx, ecx, 6
	mov	eax, DWORD PTR _remoteSystem$[ebp]
	movzx	eax, WORD PTR [eax+edx+1704]
$LN4@GetLastPin:

; 1785 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?GetLastPing@RakPeer@@UBEHUPlayerID@@@Z ENDP		; RakPeer::GetLastPing
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?GetAveragePing@RakPeer@@UAEHUPlayerID@@@Z
_TEXT	SEGMENT
_remoteSystem$ = -44					; size = 4
_quantity$ = -32					; size = 4
_sum$ = -20						; size = 4
_this$ = -8						; size = 4
_playerId$ = 8						; size = 6
?GetAveragePing@RakPeer@@UAEHUPlayerID@@@Z PROC		; RakPeer::GetAveragePing, COMDAT
; _this$ = ecx

; 1746 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1747 : 	int sum, quantity;
; 1748 : 	RemoteSystemStruct *remoteSystem = GetRemoteSystemFromPlayerID( playerId, false, false );

	push	0
	push	0
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRemoteSystemFromPlayerID@RakPeer@@IBEPAURemoteSystemStruct@1@UPlayerID@@_N1@Z ; RakPeer::GetRemoteSystemFromPlayerID
	mov	DWORD PTR _remoteSystem$[ebp], eax

; 1749 : 
; 1750 : 	if ( remoteSystem == 0 )

	cmp	DWORD PTR _remoteSystem$[ebp], 0
	jne	SHORT $LN8@GetAverage

; 1751 : 		return -1;

	or	eax, -1
	jmp	SHORT $LN9@GetAverage
$LN8@GetAverage:

; 1752 : 
; 1753 : 	for ( sum = 0, quantity = 0; quantity < PING_TIMES_ARRAY_SIZE; quantity++ )

	mov	DWORD PTR _sum$[ebp], 0
	mov	DWORD PTR _quantity$[ebp], 0
	jmp	SHORT $LN7@GetAverage
$LN6@GetAverage:
	mov	eax, DWORD PTR _quantity$[ebp]
	add	eax, 1
	mov	DWORD PTR _quantity$[ebp], eax
$LN7@GetAverage:
	cmp	DWORD PTR _quantity$[ebp], 5
	jge	SHORT $LN5@GetAverage

; 1754 : 	{
; 1755 : 		if ( remoteSystem->pingAndClockDifferential[ quantity ].pingTime == 65535 )

	imul	eax, DWORD PTR _quantity$[ebp], 6
	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	movzx	edx, WORD PTR [ecx+eax+1704]
	cmp	edx, 65535				; 0000ffffH
	jne	SHORT $LN4@GetAverage

; 1756 : 			break;

	jmp	SHORT $LN5@GetAverage

; 1757 : 		else

	jmp	SHORT $LN3@GetAverage
$LN4@GetAverage:

; 1758 : 			sum += remoteSystem->pingAndClockDifferential[ quantity ].pingTime;

	imul	eax, DWORD PTR _quantity$[ebp], 6
	mov	ecx, DWORD PTR _remoteSystem$[ebp]
	movzx	edx, WORD PTR [ecx+eax+1704]
	add	edx, DWORD PTR _sum$[ebp]
	mov	DWORD PTR _sum$[ebp], edx
$LN3@GetAverage:

; 1759 : 	}

	jmp	SHORT $LN6@GetAverage
$LN5@GetAverage:

; 1760 : 
; 1761 : 	if ( quantity > 0 )

	cmp	DWORD PTR _quantity$[ebp], 0
	jle	SHORT $LN2@GetAverage

; 1762 : 		return sum / quantity;

	mov	eax, DWORD PTR _sum$[ebp]
	cdq
	idiv	DWORD PTR _quantity$[ebp]
	jmp	SHORT $LN9@GetAverage

; 1763 : 	else

	jmp	SHORT $LN9@GetAverage
$LN2@GetAverage:

; 1764 : 		return -1;

	or	eax, -1
$LN9@GetAverage:

; 1765 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?GetAveragePing@RakPeer@@UAEHUPlayerID@@@Z ENDP		; RakPeer::GetAveragePing
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?Ping@RakPeer@@UAEXPBDG_N@Z
_TEXT	SEGMENT
tv143 = -536						; size = 4
_i$ = -336						; size = 4
_bitStream$ = -324					; size = 273
_playerId$ = -40					; size = 6
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_host$ = 8						; size = 4
_remotePort$ = 12					; size = 2
_onlyReplyOnAcceptingConnections$ = 16			; size = 1
?Ping@RakPeer@@UAEXPBDG_N@Z PROC			; RakPeer::Ping, COMDAT
; _this$ = ecx

; 1699 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Ping@RakPeer@@UAEXPBDG_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 524				; 0000020cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-536]
	mov	ecx, 131				; 00000083H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1700 : 	if ( host == 0 )

	cmp	DWORD PTR _host$[ebp], 0
	jne	SHORT $LN8@Ping

; 1701 : 		return;

	jmp	$LN9@Ping
$LN8@Ping:

; 1702 : 
; 1703 : //	if ( IsActive() == false )
; 1704 : //		return;
; 1705 : 
; 1706 : 	// If the host starts with something other than 0, 1, or 2 it's (probably) a domain name.
; 1707 : 	if ( host[ 0 ] < '0' || host[ 0 ] > '2' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _host$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN6@Ping
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _host$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 50					; 00000032H
	jle	SHORT $LN7@Ping
$LN6@Ping:

; 1708 : 	{
; 1709 : #if !defined(_COMPATIBILITY_1)
; 1710 : 		host = ( char* ) SocketLayer::Instance()->DomainNameToIP( host );

	mov	eax, DWORD PTR _host$[ebp]
	push	eax
	call	?Instance@SocketLayer@@SAPAV1@XZ	; SocketLayer::Instance
	mov	ecx, eax
	call	?DomainNameToIP@SocketLayer@@QAEPBDPBD@Z ; SocketLayer::DomainNameToIP
	mov	DWORD PTR _host$[ebp], eax
$LN7@Ping:

; 1711 : #else
; 1712 : 		return;
; 1713 : #endif
; 1714 : 	}
; 1715 : 
; 1716 : 	PlayerID playerId;
; 1717 : 	IPToPlayerID( host, remotePort, &playerId );

	mov	esi, esp
	lea	eax, DWORD PTR _playerId$[ebp]
	push	eax
	movzx	ecx, WORD PTR _remotePort$[ebp]
	push	ecx
	mov	edx, DWORD PTR _host$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+188]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1718 : 
; 1719 : 	RakNet::BitStream bitStream( sizeof(unsigned char) + sizeof(RakNetTime) );

	push	5
	lea	ecx, DWORD PTR _bitStream$[ebp]
	call	??0BitStream@RakNet@@QAE@H@Z		; RakNet::BitStream::BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1720 : 	if ( onlyReplyOnAcceptingConnections )

	movzx	eax, BYTE PTR _onlyReplyOnAcceptingConnections$[ebp]
	test	eax, eax
	je	SHORT $LN5@Ping

; 1721 : 		bitStream.Write((unsigned char)ID_PING_OPEN_CONNECTIONS);

	push	4
	lea	ecx, DWORD PTR _bitStream$[ebp]
	call	??$Write@E@BitStream@RakNet@@QAEXE@Z	; RakNet::BitStream::Write<unsigned char>

; 1722 : 	else

	jmp	SHORT $LN4@Ping
$LN5@Ping:

; 1723 : 		bitStream.Write((unsigned char)ID_PING);

	push	3
	lea	ecx, DWORD PTR _bitStream$[ebp]
	call	??$Write@E@BitStream@RakNet@@QAEXE@Z	; RakNet::BitStream::Write<unsigned char>
$LN4@Ping:

; 1724 : 
; 1725 : 	bitStream.Write(RakNet::GetTime());

	call	?GetTime@RakNet@@YAIXZ			; RakNet::GetTime
	push	eax
	lea	ecx, DWORD PTR _bitStream$[ebp]
	call	??$Write@I@BitStream@RakNet@@QAEXI@Z	; RakNet::BitStream::Write<unsigned int>

; 1726 : 
; 1727 : 	unsigned i;
; 1728 : 	for (i=0; i < messageHandlerList.Size(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@Ping
$LN2@Ping:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@Ping:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 941				; 000003adH
	call	?Size@?$List@PAVPluginInterface@@@DataStructures@@QBEIXZ ; DataStructures::List<PluginInterface *>::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN1@Ping

; 1729 : 		messageHandlerList[i]->OnDirectSocketSend((const char*)bitStream.GetData(), bitStream.GetNumberOfBitsUsed(), playerId);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 941				; 000003adH
	call	??A?$List@PAVPluginInterface@@@DataStructures@@QBEAAPAVPluginInterface@@I@Z ; DataStructures::List<PluginInterface *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv143[ebp], ecx
	mov	esi, esp
	sub	esp, 8
	mov	edx, esp
	mov	eax, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [edx], eax
	mov	cx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [edx+4], cx
	lea	ecx, DWORD PTR _bitStream$[ebp]
	call	?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBitsUsed
	push	eax
	lea	ecx, DWORD PTR _bitStream$[ebp]
	call	?GetData@BitStream@RakNet@@QBEPAEXZ	; RakNet::BitStream::GetData
	push	eax
	mov	edx, DWORD PTR tv143[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv143[ebp]
	mov	edx, DWORD PTR [eax+28]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	$LN2@Ping
$LN1@Ping:

; 1730 : 	// No timestamp for 255.255.255.255
; 1731 : 	SocketLayer::Instance()->SendTo( connectionSocket, (const char*)bitStream.GetData(), bitStream.GetNumberOfBytesUsed(), ( char* ) host, remotePort );

	movzx	eax, WORD PTR _remotePort$[ebp]
	push	eax
	mov	ecx, DWORD PTR _host$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _bitStream$[ebp]
	call	?GetNumberOfBytesUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBytesUsed
	push	eax
	lea	ecx, DWORD PTR _bitStream$[ebp]
	call	?GetData@BitStream@RakNet@@QBEPAEXZ	; RakNet::BitStream::GetData
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2070]
	push	eax
	call	?Instance@SocketLayer@@SAPAV1@XZ	; SocketLayer::Instance
	mov	ecx, eax
	call	?SendTo@SocketLayer@@QAEHIPBDHQADG@Z	; SocketLayer::SendTo

; 1732 : 
; 1733 : 
; 1734 : 
; 1735 : 
; 1736 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _bitStream$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
$LN9@Ping:
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN16@Ping
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 536				; 00000218H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN16@Ping:
	DD	2
	DD	$LN15@Ping
$LN15@Ping:
	DD	-40					; ffffffd8H
	DD	6
	DD	$LN12@Ping
	DD	-324					; fffffebcH
	DD	273					; 00000111H
	DD	$LN13@Ping
$LN13@Ping:
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	0
$LN12@Ping:
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	73					; 00000049H
	DB	100					; 00000064H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Ping@RakPeer@@UAEXPBDG_N@Z$0:
	lea	ecx, DWORD PTR _bitStream$[ebp]
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__ehhandler$?Ping@RakPeer@@UAEXPBDG_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-540]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Ping@RakPeer@@UAEXPBDG_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Ping@RakPeer@@UAEXPBDG_N@Z ENDP			; RakPeer::Ping
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?Ping@RakPeer@@UAEXUPlayerID@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_target$ = 8						; size = 6
?Ping@RakPeer@@UAEXUPlayerID@@@Z PROC			; RakPeer::Ping, COMDAT
; _this$ = ecx

; 1683 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1684 : 	PingInternal(target, false);

	push	0
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _target$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _target$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PingInternal@RakPeer@@IAEXUPlayerID@@_N@Z ; RakPeer::PingInternal

; 1685 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?Ping@RakPeer@@UAEXUPlayerID@@@Z ENDP			; RakPeer::Ping
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?IsBanned@RakPeer@@UAE_NPBD@Z
_TEXT	SEGMENT
$T1 = -272						; size = 4
$T2 = -260						; size = 4
_temp$ = -56						; size = 4
_time$ = -44						; size = 4
_characterIndex$ = -32					; size = 4
_banListIndex$ = -20					; size = 4
_this$ = -8						; size = 4
_IP$ = 8						; size = 4
?IsBanned@RakPeer@@UAE_NPBD@Z PROC			; RakPeer::IsBanned, COMDAT
; _this$ = ecx

; 1591 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-276]
	mov	ecx, 69					; 00000045H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1592 : 	unsigned banListIndex, characterIndex;
; 1593 : 	RakNetTime time;
; 1594 : 	BanStruct *temp;
; 1595 : 
; 1596 : 	if ( IP == 0 || IP[ 0 ] == 0 || strlen( IP ) > 15 )

	cmp	DWORD PTR _IP$[ebp], 0
	je	SHORT $LN14@IsBanned
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _IP$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	SHORT $LN14@IsBanned
	mov	eax, DWORD PTR _IP$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	cmp	eax, 15					; 0000000fH
	jbe	SHORT $LN15@IsBanned
$LN14@IsBanned:

; 1597 : 		return false;

	xor	al, al
	jmp	$LN16@IsBanned
$LN15@IsBanned:

; 1598 : 
; 1599 : 	banListIndex = 0;

	mov	DWORD PTR _banListIndex$[ebp], 0

; 1600 : 
; 1601 : 	if ( banList.Size() == 0 )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 929				; 000003a1H
	call	?Size@?$List@PAUBanStruct@RakPeer@@@DataStructures@@QBEIXZ ; DataStructures::List<RakPeer::BanStruct *>::Size
	test	eax, eax
	jne	SHORT $LN13@IsBanned

; 1602 : 		return false; // Skip the mutex if possible

	xor	al, al
	jmp	$LN16@IsBanned
$LN13@IsBanned:

; 1603 : 
; 1604 : 	time = RakNet::GetTime();

	call	?GetTime@RakNet@@YAIXZ			; RakNet::GetTime
	mov	DWORD PTR _time$[ebp], eax

; 1605 : 
; 1606 : 	banListMutex.Lock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 905				; 00000389H
	call	?Lock@SimpleMutex@@QAEXXZ		; SimpleMutex::Lock
$LN12@IsBanned:

; 1607 : 
; 1608 : 	while ( banListIndex < banList.Size() )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 929				; 000003a1H
	call	?Size@?$List@PAUBanStruct@RakPeer@@@DataStructures@@QBEIXZ ; DataStructures::List<RakPeer::BanStruct *>::Size
	cmp	DWORD PTR _banListIndex$[ebp], eax
	jae	$LN11@IsBanned

; 1609 : 	{
; 1610 : 		if (banList[ banListIndex ]->timeout>0 && banList[ banListIndex ]->timeout<time)

	mov	eax, DWORD PTR _banListIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 929				; 000003a1H
	call	??A?$List@PAUBanStruct@RakPeer@@@DataStructures@@QBEAAPAUBanStruct@RakPeer@@I@Z ; DataStructures::List<RakPeer::BanStruct *>::operator[]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+4], 0
	jbe	$LN10@IsBanned
	mov	eax, DWORD PTR _banListIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 929				; 000003a1H
	call	??A?$List@PAUBanStruct@RakPeer@@@DataStructures@@QBEAAPAUBanStruct@RakPeer@@I@Z ; DataStructures::List<RakPeer::BanStruct *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _time$[ebp]
	jae	$LN10@IsBanned

; 1611 : 		{
; 1612 : 			// Delete expired ban
; 1613 : 			temp = banList[ banListIndex ];

	mov	eax, DWORD PTR _banListIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 929				; 000003a1H
	call	??A?$List@PAUBanStruct@RakPeer@@@DataStructures@@QBEAAPAUBanStruct@RakPeer@@I@Z ; DataStructures::List<RakPeer::BanStruct *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _temp$[ebp], ecx

; 1614 : 			banList[ banListIndex ] = banList[ banList.Size() - 1 ];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 929				; 000003a1H
	call	?Size@?$List@PAUBanStruct@RakPeer@@@DataStructures@@QBEIXZ ; DataStructures::List<RakPeer::BanStruct *>::Size
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 929				; 000003a1H
	call	??A?$List@PAUBanStruct@RakPeer@@@DataStructures@@QBEAAPAUBanStruct@RakPeer@@I@Z ; DataStructures::List<RakPeer::BanStruct *>::operator[]
	mov	esi, eax
	mov	eax, DWORD PTR _banListIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 929				; 000003a1H
	call	??A?$List@PAUBanStruct@RakPeer@@@DataStructures@@QBEAAPAUBanStruct@RakPeer@@I@Z ; DataStructures::List<RakPeer::BanStruct *>::operator[]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1615 : 			banList.RemoveAtIndex( banList.Size() - 1 );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 929				; 000003a1H
	call	?Size@?$List@PAUBanStruct@RakPeer@@@DataStructures@@QBEIXZ ; DataStructures::List<RakPeer::BanStruct *>::Size
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 929				; 000003a1H
	call	?RemoveAtIndex@?$List@PAUBanStruct@RakPeer@@@DataStructures@@QAEXI@Z ; DataStructures::List<RakPeer::BanStruct *>::RemoveAtIndex

; 1616 : 			delete [] temp->IP;

	mov	eax, DWORD PTR _temp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1617 : 			delete temp;

	mov	eax, DWORD PTR _temp$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1618 : 		}
; 1619 : 		else

	jmp	$LN9@IsBanned
$LN10@IsBanned:

; 1620 : 		{
; 1621 : 			characterIndex = 0;

	mov	DWORD PTR _characterIndex$[ebp], 0
$LN8@IsBanned:

; 1622 : 
; 1623 : #ifdef _MSC_VER
; 1624 : #pragma warning( disable : 4127 ) // warning C4127: conditional expression is constant
; 1625 : #endif
; 1626 : 			while ( true )

	mov	eax, 1
	test	eax, eax
	je	$LN7@IsBanned

; 1627 : 			{
; 1628 : 				if ( banList[ banListIndex ]->IP[ characterIndex ] == IP[ characterIndex ] )

	mov	eax, DWORD PTR _banListIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 929				; 000003a1H
	call	??A?$List@PAUBanStruct@RakPeer@@@DataStructures@@QBEAAPAUBanStruct@RakPeer@@I@Z ; DataStructures::List<RakPeer::BanStruct *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _characterIndex$[ebp]
	movsx	ecx, BYTE PTR [edx+eax]
	mov	edx, DWORD PTR _IP$[ebp]
	add	edx, DWORD PTR _characterIndex$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN6@IsBanned

; 1629 : 				{
; 1630 : 					// Equal characters
; 1631 : 
; 1632 : 					if ( IP[ characterIndex ] == 0 )

	mov	eax, DWORD PTR _IP$[ebp]
	add	eax, DWORD PTR _characterIndex$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@IsBanned

; 1633 : 					{
; 1634 : 						banListMutex.Unlock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 905				; 00000389H
	call	?Unlock@SimpleMutex@@QAEXXZ		; SimpleMutex::Unlock

; 1635 : 						// End of the string and the strings match
; 1636 : 
; 1637 : 						return true;

	mov	al, 1
	jmp	$LN16@IsBanned
$LN5@IsBanned:

; 1638 : 					}
; 1639 : 
; 1640 : 					characterIndex++;

	mov	eax, DWORD PTR _characterIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _characterIndex$[ebp], eax

; 1641 : 				}
; 1642 : 
; 1643 : 				else

	jmp	SHORT $LN4@IsBanned
$LN6@IsBanned:

; 1644 : 				{
; 1645 : 					if ( banList[ banListIndex ]->IP[ characterIndex ] == 0 || IP[ characterIndex ] == 0 )

	mov	eax, DWORD PTR _banListIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 929				; 000003a1H
	call	??A?$List@PAUBanStruct@RakPeer@@@DataStructures@@QBEAAPAUBanStruct@RakPeer@@I@Z ; DataStructures::List<RakPeer::BanStruct *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _characterIndex$[ebp]
	movsx	ecx, BYTE PTR [edx+eax]
	test	ecx, ecx
	je	SHORT $LN2@IsBanned
	mov	eax, DWORD PTR _IP$[ebp]
	add	eax, DWORD PTR _characterIndex$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@IsBanned
$LN2@IsBanned:

; 1646 : 					{
; 1647 : 						// End of one of the strings
; 1648 : 						break;

	jmp	SHORT $LN7@IsBanned
$LN3@IsBanned:

; 1649 : 					}
; 1650 : 
; 1651 : 					// Characters do not match
; 1652 : 					if ( banList[ banListIndex ]->IP[ characterIndex ] == '*' )

	mov	eax, DWORD PTR _banListIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 929				; 000003a1H
	call	??A?$List@PAUBanStruct@RakPeer@@@DataStructures@@QBEAAPAUBanStruct@RakPeer@@I@Z ; DataStructures::List<RakPeer::BanStruct *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _characterIndex$[ebp]
	movsx	ecx, BYTE PTR [edx+eax]
	cmp	ecx, 42					; 0000002aH
	jne	SHORT $LN1@IsBanned

; 1653 : 					{
; 1654 : 						banListMutex.Unlock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 905				; 00000389H
	call	?Unlock@SimpleMutex@@QAEXXZ		; SimpleMutex::Unlock

; 1655 : 
; 1656 : 						// Domain is banned.
; 1657 : 						return true;

	mov	al, 1
	jmp	SHORT $LN16@IsBanned
$LN1@IsBanned:

; 1658 : 					}
; 1659 : 
; 1660 : 					// Characters do not match and it is not a *
; 1661 : 					break;

	jmp	SHORT $LN7@IsBanned
$LN4@IsBanned:

; 1662 : 				}
; 1663 : 			}

	jmp	$LN8@IsBanned
$LN7@IsBanned:

; 1664 : 
; 1665 : 			banListIndex++;

	mov	eax, DWORD PTR _banListIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _banListIndex$[ebp], eax
$LN9@IsBanned:

; 1666 : 		}
; 1667 : 	}

	jmp	$LN12@IsBanned
$LN11@IsBanned:

; 1668 : 
; 1669 : 	banListMutex.Unlock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 905				; 00000389H
	call	?Unlock@SimpleMutex@@QAEXXZ		; SimpleMutex::Unlock

; 1670 : 
; 1671 : 	// No match found.
; 1672 : 	return false;

	xor	al, al
$LN16@IsBanned:

; 1673 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?IsBanned@RakPeer@@UAE_NPBD@Z ENDP			; RakPeer::IsBanned
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?ClearBanList@RakPeer@@UAEXXZ
_TEXT	SEGMENT
$T1 = -236						; size = 4
$T2 = -224						; size = 4
_index$ = -20						; size = 4
_this$ = -8						; size = 4
?ClearBanList@RakPeer@@UAEXXZ PROC			; RakPeer::ClearBanList, COMDAT
; _this$ = ecx

; 1563 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1564 : 	unsigned index;
; 1565 : 	index = 0;

	mov	DWORD PTR _index$[ebp], 0

; 1566 : 	banListMutex.Lock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 905				; 00000389H
	call	?Lock@SimpleMutex@@QAEXXZ		; SimpleMutex::Lock

; 1567 : 
; 1568 : 	for ( ; index < banList.Size(); index++ )

	jmp	SHORT $LN3@ClearBanLi
$LN2@ClearBanLi:
	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 1
	mov	DWORD PTR _index$[ebp], eax
$LN3@ClearBanLi:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 929				; 000003a1H
	call	?Size@?$List@PAUBanStruct@RakPeer@@@DataStructures@@QBEIXZ ; DataStructures::List<RakPeer::BanStruct *>::Size
	cmp	DWORD PTR _index$[ebp], eax
	jae	SHORT $LN1@ClearBanLi

; 1569 : 	{
; 1570 : 		delete [] banList[ index ]->IP;

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 929				; 000003a1H
	call	??A?$List@PAUBanStruct@RakPeer@@@DataStructures@@QBEAAPAUBanStruct@RakPeer@@I@Z ; DataStructures::List<RakPeer::BanStruct *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1571 : 		delete [] banList[ index ];

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 929				; 000003a1H
	call	??A?$List@PAUBanStruct@RakPeer@@@DataStructures@@QBEAAPAUBanStruct@RakPeer@@I@Z ; DataStructures::List<RakPeer::BanStruct *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1572 : 	}

	jmp	SHORT $LN2@ClearBanLi
$LN1@ClearBanLi:

; 1573 : 
; 1574 : 	banList.Clear();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 929				; 000003a1H
	call	?Clear@?$List@PAUBanStruct@RakPeer@@@DataStructures@@QAEX_N@Z ; DataStructures::List<RakPeer::BanStruct *>::Clear

; 1575 : 
; 1576 : 	banListMutex.Unlock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 905				; 00000389H
	call	?Unlock@SimpleMutex@@QAEXXZ		; SimpleMutex::Unlock

; 1577 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?ClearBanList@RakPeer@@UAEXXZ ENDP			; RakPeer::ClearBanList
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?RemoveFromBanList@RakPeer@@UAEXPBD@Z
_TEXT	SEGMENT
$T1 = -248						; size = 4
$T2 = -236						; size = 4
_temp$ = -32						; size = 4
_index$ = -20						; size = 4
_this$ = -8						; size = 4
_IP$ = 8						; size = 4
?RemoveFromBanList@RakPeer@@UAEXPBD@Z PROC		; RakPeer::RemoveFromBanList, COMDAT
; _this$ = ecx

; 1525 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1526 : 	unsigned index;
; 1527 : 	BanStruct *temp;
; 1528 : 
; 1529 : 	if ( IP == 0 || IP[ 0 ] == 0 || strlen( IP ) > 15 )

	cmp	DWORD PTR _IP$[ebp], 0
	je	SHORT $LN6@RemoveFrom
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _IP$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	SHORT $LN6@RemoveFrom
	mov	eax, DWORD PTR _IP$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	cmp	eax, 15					; 0000000fH
	jbe	SHORT $LN7@RemoveFrom
$LN6@RemoveFrom:

; 1530 : 		return ;

	jmp	$LN8@RemoveFrom
$LN7@RemoveFrom:

; 1531 : 
; 1532 : 	index = 0;

	mov	DWORD PTR _index$[ebp], 0

; 1533 : 	temp=0;

	mov	DWORD PTR _temp$[ebp], 0

; 1534 : 
; 1535 : 	banListMutex.Lock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 905				; 00000389H
	call	?Lock@SimpleMutex@@QAEXXZ		; SimpleMutex::Lock

; 1536 : 
; 1537 : 	for ( ; index < banList.Size(); index++ )

	jmp	SHORT $LN5@RemoveFrom
$LN4@RemoveFrom:
	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 1
	mov	DWORD PTR _index$[ebp], eax
$LN5@RemoveFrom:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 929				; 000003a1H
	call	?Size@?$List@PAUBanStruct@RakPeer@@@DataStructures@@QBEIXZ ; DataStructures::List<RakPeer::BanStruct *>::Size
	cmp	DWORD PTR _index$[ebp], eax
	jae	$LN3@RemoveFrom

; 1538 : 	{
; 1539 : 		if ( strcmp( IP, banList[ index ]->IP ) == 0 )

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 929				; 000003a1H
	call	??A?$List@PAUBanStruct@RakPeer@@@DataStructures@@QBEAAPAUBanStruct@RakPeer@@I@Z ; DataStructures::List<RakPeer::BanStruct *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _IP$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@RemoveFrom

; 1540 : 		{
; 1541 : 			temp = banList[ index ];

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 929				; 000003a1H
	call	??A?$List@PAUBanStruct@RakPeer@@@DataStructures@@QBEAAPAUBanStruct@RakPeer@@I@Z ; DataStructures::List<RakPeer::BanStruct *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _temp$[ebp], ecx

; 1542 : 			banList[ index ] = banList[ banList.Size() - 1 ];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 929				; 000003a1H
	call	?Size@?$List@PAUBanStruct@RakPeer@@@DataStructures@@QBEIXZ ; DataStructures::List<RakPeer::BanStruct *>::Size
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 929				; 000003a1H
	call	??A?$List@PAUBanStruct@RakPeer@@@DataStructures@@QBEAAPAUBanStruct@RakPeer@@I@Z ; DataStructures::List<RakPeer::BanStruct *>::operator[]
	mov	esi, eax
	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 929				; 000003a1H
	call	??A?$List@PAUBanStruct@RakPeer@@@DataStructures@@QBEAAPAUBanStruct@RakPeer@@I@Z ; DataStructures::List<RakPeer::BanStruct *>::operator[]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1543 : 			banList.RemoveAtIndex( banList.Size() - 1 );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 929				; 000003a1H
	call	?Size@?$List@PAUBanStruct@RakPeer@@@DataStructures@@QBEIXZ ; DataStructures::List<RakPeer::BanStruct *>::Size
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 929				; 000003a1H
	call	?RemoveAtIndex@?$List@PAUBanStruct@RakPeer@@@DataStructures@@QAEXI@Z ; DataStructures::List<RakPeer::BanStruct *>::RemoveAtIndex

; 1544 : 			break;

	jmp	SHORT $LN3@RemoveFrom
$LN2@RemoveFrom:

; 1545 : 		}
; 1546 : 	}

	jmp	$LN4@RemoveFrom
$LN3@RemoveFrom:

; 1547 : 
; 1548 : 	banListMutex.Unlock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 905				; 00000389H
	call	?Unlock@SimpleMutex@@QAEXXZ		; SimpleMutex::Unlock

; 1549 : 
; 1550 : 	if (temp)

	cmp	DWORD PTR _temp$[ebp], 0
	je	SHORT $LN8@RemoveFrom

; 1551 : 	{
; 1552 : 		delete [] temp->IP;

	mov	eax, DWORD PTR _temp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1553 : 		delete temp;

	mov	eax, DWORD PTR _temp$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@RemoveFrom:

; 1554 : 	}
; 1555 : 
; 1556 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveFromBanList@RakPeer@@UAEXPBD@Z ENDP		; RakPeer::RemoveFromBanList
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?AddToBanList@RakPeer@@UAEXPBDI@Z
_TEXT	SEGMENT
$T1 = -260						; size = 4
$T2 = -248						; size = 4
_banStruct$ = -44					; size = 4
_time$ = -32						; size = 4
_index$ = -20						; size = 4
_this$ = -8						; size = 4
_IP$ = 8						; size = 4
_milliseconds$ = 12					; size = 4
?AddToBanList@RakPeer@@UAEXPBDI@Z PROC			; RakPeer::AddToBanList, COMDAT
; _this$ = ecx

; 1476 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1477 : 	unsigned index;
; 1478 : 	RakNetTime time = RakNet::GetTime();

	call	?GetTime@RakNet@@YAIXZ			; RakNet::GetTime
	mov	DWORD PTR _time$[ebp], eax

; 1479 : 
; 1480 : 	if ( IP == 0 || IP[ 0 ] == 0 || strlen( IP ) > 15 )

	cmp	DWORD PTR _IP$[ebp], 0
	je	SHORT $LN9@AddToBanLi
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _IP$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	SHORT $LN9@AddToBanLi
	mov	eax, DWORD PTR _IP$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	cmp	eax, 15					; 0000000fH
	jbe	SHORT $LN10@AddToBanLi
$LN9@AddToBanLi:

; 1481 : 		return ;

	jmp	$LN11@AddToBanLi
$LN10@AddToBanLi:

; 1482 : 
; 1483 : 	// If this guy is already in the ban list, do nothing
; 1484 : 	index = 0;

	mov	DWORD PTR _index$[ebp], 0

; 1485 : 
; 1486 : 	banListMutex.Lock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 905				; 00000389H
	call	?Lock@SimpleMutex@@QAEXXZ		; SimpleMutex::Lock

; 1487 : 
; 1488 : 	for ( ; index < banList.Size(); index++ )

	jmp	SHORT $LN8@AddToBanLi
$LN7@AddToBanLi:
	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 1
	mov	DWORD PTR _index$[ebp], eax
$LN8@AddToBanLi:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 929				; 000003a1H
	call	?Size@?$List@PAUBanStruct@RakPeer@@@DataStructures@@QBEIXZ ; DataStructures::List<RakPeer::BanStruct *>::Size
	cmp	DWORD PTR _index$[ebp], eax
	jae	SHORT $LN6@AddToBanLi

; 1489 : 	{
; 1490 : 		if ( strcmp( IP, banList[ index ]->IP ) == 0 )

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 929				; 000003a1H
	call	??A?$List@PAUBanStruct@RakPeer@@@DataStructures@@QBEAAPAUBanStruct@RakPeer@@I@Z ; DataStructures::List<RakPeer::BanStruct *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _IP$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@AddToBanLi

; 1491 : 		{
; 1492 : 			// Already in the ban list.  Just update the time
; 1493 : 			if (milliseconds==0)

	cmp	DWORD PTR _milliseconds$[ebp], 0
	jne	SHORT $LN4@AddToBanLi

; 1494 : 				banList[ index ]->timeout=0; // Infinite

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 929				; 000003a1H
	call	??A?$List@PAUBanStruct@RakPeer@@@DataStructures@@QBEAAPAUBanStruct@RakPeer@@I@Z ; DataStructures::List<RakPeer::BanStruct *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], 0

; 1495 : 			else

	jmp	SHORT $LN3@AddToBanLi
$LN4@AddToBanLi:

; 1496 : 				banList[ index ]->timeout=time+milliseconds;

	mov	esi, DWORD PTR _time$[ebp]
	add	esi, DWORD PTR _milliseconds$[ebp]
	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 929				; 000003a1H
	call	??A?$List@PAUBanStruct@RakPeer@@@DataStructures@@QBEAAPAUBanStruct@RakPeer@@I@Z ; DataStructures::List<RakPeer::BanStruct *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], esi
$LN3@AddToBanLi:

; 1497 : 			banListMutex.Unlock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 905				; 00000389H
	call	?Unlock@SimpleMutex@@QAEXXZ		; SimpleMutex::Unlock

; 1498 : 			return;

	jmp	$LN11@AddToBanLi
$LN5@AddToBanLi:

; 1499 : 		}
; 1500 : 	}

	jmp	$LN7@AddToBanLi
$LN6@AddToBanLi:

; 1501 : 
; 1502 : 	banListMutex.Unlock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 905				; 00000389H
	call	?Unlock@SimpleMutex@@QAEXXZ		; SimpleMutex::Unlock

; 1503 : 
; 1504 : 	BanStruct *banStruct = new BanStruct;

	push	8
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _banStruct$[ebp], eax

; 1505 : 	banStruct->IP = new char [ 16 ];

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR _banStruct$[ebp]
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [eax], ecx

; 1506 : 	if (milliseconds==0)

	cmp	DWORD PTR _milliseconds$[ebp], 0
	jne	SHORT $LN2@AddToBanLi

; 1507 : 		banStruct->timeout=0; // Infinite

	mov	eax, DWORD PTR _banStruct$[ebp]
	mov	DWORD PTR [eax+4], 0

; 1508 : 	else

	jmp	SHORT $LN1@AddToBanLi
$LN2@AddToBanLi:

; 1509 : 		banStruct->timeout=time+milliseconds;

	mov	eax, DWORD PTR _time$[ebp]
	add	eax, DWORD PTR _milliseconds$[ebp]
	mov	ecx, DWORD PTR _banStruct$[ebp]
	mov	DWORD PTR [ecx+4], eax
$LN1@AddToBanLi:

; 1510 : 	strcpy( banStruct->IP, IP );

	mov	eax, DWORD PTR _IP$[ebp]
	push	eax
	mov	ecx, DWORD PTR _banStruct$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_strcpy
	add	esp, 8

; 1511 : 	banListMutex.Lock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 905				; 00000389H
	call	?Lock@SimpleMutex@@QAEXXZ		; SimpleMutex::Lock

; 1512 : 	banList.Insert( banStruct );

	mov	eax, DWORD PTR _banStruct$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 929				; 000003a1H
	call	?Insert@?$List@PAUBanStruct@RakPeer@@@DataStructures@@QAEXQAUBanStruct@RakPeer@@@Z ; DataStructures::List<RakPeer::BanStruct *>::Insert

; 1513 : 	banListMutex.Unlock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 905				; 00000389H
	call	?Unlock@SimpleMutex@@QAEXXZ		; SimpleMutex::Unlock
$LN11@AddToBanLi:

; 1514 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?AddToBanList@RakPeer@@UAEXPBDI@Z ENDP			; RakPeer::AddToBanList
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?GetPlayerIDFromIndex@RakPeer@@UAE?AUPlayerID@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
_index$ = 12						; size = 4
?GetPlayerIDFromIndex@RakPeer@@UAE?AUPlayerID@@H@Z PROC	; RakPeer::GetPlayerIDFromIndex, COMDAT
; _this$ = ecx

; 1456 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1457 : 	// remoteSystemList in user thread
; 1458 : 	//if ( index >= 0 && index < remoteSystemListSize )
; 1459 : 	if ( index >= 0 && index < maximumNumberOfPeers )

	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $LN2@GetPlayerI
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+7]
	cmp	DWORD PTR _index$[ebp], ecx
	jge	SHORT $LN2@GetPlayerI

; 1460 : 		if (remoteSystemList[ index ].connectMode==RakPeer::RemoteSystemStruct::CONNECTED) // Don't give the user players that aren't fully connected, since sends will fail

	imul	eax, DWORD PTR _index$[ebp], 2058
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	cmp	DWORD PTR [edx+eax+2054], 8
	jne	SHORT $LN2@GetPlayerI

; 1461 : 			return remoteSystemList[ index ].playerId;

	imul	eax, DWORD PTR _index$[ebp], 2058
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	lea	eax, DWORD PTR [edx+eax+1]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	ax, WORD PTR [eax+4]
	mov	WORD PTR [ecx+4], ax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@GetPlayerI
$LN2@GetPlayerI:

; 1462 : 
; 1463 : 	return UNASSIGNED_PLAYER_ID;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR _UNASSIGNED_PLAYER_ID
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _UNASSIGNED_PLAYER_ID+4
	mov	WORD PTR [eax+4], dx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@GetPlayerI:

; 1464 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?GetPlayerIDFromIndex@RakPeer@@UAE?AUPlayerID@@H@Z ENDP	; RakPeer::GetPlayerIDFromIndex
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?GetIndexFromPlayerID@RakPeer@@UAEHUPlayerID@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_playerId$ = 8						; size = 6
?GetIndexFromPlayerID@RakPeer@@UAEHUPlayerID@@@Z PROC	; RakPeer::GetIndexFromPlayerID, COMDAT
; _this$ = ecx

; 1441 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1442 : 	return GetIndexFromPlayerID(playerId, false);

	push	0
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexFromPlayerID@RakPeer@@IAEHUPlayerID@@_N@Z ; RakPeer::GetIndexFromPlayerID

; 1443 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?GetIndexFromPlayerID@RakPeer@@UAEHUPlayerID@@@Z ENDP	; RakPeer::GetIndexFromPlayerID
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?CloseConnection@RakPeer@@UAEXUPlayerID@@_NE@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_target$ = 8						; size = 6
_sendDisconnectionNotification$ = 16			; size = 1
_orderingChannel$ = 20					; size = 1
?CloseConnection@RakPeer@@UAEXUPlayerID@@_NE@Z PROC	; RakPeer::CloseConnection, COMDAT
; _this$ = ecx

; 1426 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1427 : 	CloseConnectionInternal(target, sendDisconnectionNotification, false, orderingChannel);

	movzx	eax, BYTE PTR _orderingChannel$[ebp]
	push	eax
	push	0
	movzx	ecx, BYTE PTR _sendDisconnectionNotification$[ebp]
	push	ecx
	sub	esp, 8
	mov	edx, esp
	mov	eax, DWORD PTR _target$[ebp]
	mov	DWORD PTR [edx], eax
	mov	cx, WORD PTR _target$[ebp+4]
	mov	WORD PTR [edx+4], cx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CloseConnectionInternal@RakPeer@@IAEXUPlayerID@@_N1E@Z ; RakPeer::CloseConnectionInternal

; 1428 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?CloseConnection@RakPeer@@UAEXUPlayerID@@_NE@Z ENDP	; RakPeer::CloseConnection
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?RPC@RakPeer@@UAE_NPADPAVBitStream@RakNet@@W4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N5UNetworkID@@1@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uniqueID$ = 8						; size = 4
_bitStream$ = 12					; size = 4
_priority$ = 16						; size = 4
_reliability$ = 20					; size = 4
_orderingChannel$ = 24					; size = 1
_playerId$ = 28						; size = 6
_broadcast$ = 36					; size = 1
_shiftTimestamp$ = 40					; size = 1
_networkID$ = 44					; size = 8
_replyFromTarget$ = 52					; size = 4
?RPC@RakPeer@@UAE_NPADPAVBitStream@RakNet@@W4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N5UNetworkID@@1@Z PROC ; RakPeer::RPC, COMDAT
; _this$ = ecx

; 1409 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1410 : 	if (bitStream)

	cmp	DWORD PTR _bitStream$[ebp], 0
	je	SHORT $LN2@RPC

; 1411 : 		return RPC(uniqueID, (const char*) bitStream->GetData(), bitStream->GetNumberOfBitsUsed(), priority, reliability, orderingChannel, playerId, broadcast, shiftTimestamp, networkID, replyFromTarget);

	mov	esi, esp
	mov	eax, DWORD PTR _replyFromTarget$[ebp]
	push	eax
	mov	ecx, DWORD PTR _networkID$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _networkID$[ebp]
	push	edx
	movzx	eax, BYTE PTR _shiftTimestamp$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _broadcast$[ebp]
	push	ecx
	sub	esp, 8
	mov	edx, esp
	mov	eax, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [edx], eax
	mov	cx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [edx+4], cx
	movzx	edx, BYTE PTR _orderingChannel$[ebp]
	push	edx
	mov	eax, DWORD PTR _reliability$[ebp]
	push	eax
	mov	ecx, DWORD PTR _priority$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBitsUsed
	push	eax
	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	?GetData@BitStream@RakNet@@QBEPAEXZ	; RakNet::BitStream::GetData
	push	eax
	mov	edx, DWORD PTR _uniqueID$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN3@RPC

; 1412 : 	else

	jmp	SHORT $LN3@RPC
$LN2@RPC:

; 1413 : 		return RPC(uniqueID, 0,0, priority, reliability, orderingChannel, playerId, broadcast, shiftTimestamp, networkID, replyFromTarget);

	mov	esi, esp
	mov	eax, DWORD PTR _replyFromTarget$[ebp]
	push	eax
	mov	ecx, DWORD PTR _networkID$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _networkID$[ebp]
	push	edx
	movzx	eax, BYTE PTR _shiftTimestamp$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _broadcast$[ebp]
	push	ecx
	sub	esp, 8
	mov	edx, esp
	mov	eax, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [edx], eax
	mov	cx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [edx+4], cx
	movzx	edx, BYTE PTR _orderingChannel$[ebp]
	push	edx
	mov	eax, DWORD PTR _reliability$[ebp]
	push	eax
	mov	ecx, DWORD PTR _priority$[ebp]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _uniqueID$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@RPC:

; 1414 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	48					; 00000030H
?RPC@RakPeer@@UAE_NPADPAVBitStream@RakNet@@W4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N5UNetworkID@@1@Z ENDP ; RakPeer::RPC
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?RPC@RakPeer@@UAE_NPADPBDIW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N5UNetworkID@@PAVBitStream@RakNet@@@Z
_TEXT	SEGMENT
tv163 = -644						; size = 4
tv133 = -644						; size = 4
tv235 = -641						; size = 1
tv350 = -640						; size = 4
tv345 = -640						; size = 4
tv233 = -640						; size = 4
$T2 = -629						; size = 1
$T3 = -617						; size = 1
$T4 = -605						; size = 1
__$AllocaPad$$ = -404					; size = 4
_stopWaitingTime$5 = -392				; size = 4
_outgoingBitStream$ = -380				; size = 273
_routeSend$ = -93					; size = 1
_sendListIndex$ = -84					; size = 4
_remoteSystemIndex$ = -72				; size = 4
_rpcIndex$ = -57					; size = 1
_sendListSize$ = -48					; size = 4
_sendList$ = -36					; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_uniqueID$ = 8						; size = 4
_data$ = 12						; size = 4
_bitLength$ = 16					; size = 4
_priority$ = 20						; size = 4
_reliability$ = 24					; size = 4
_orderingChannel$ = 28					; size = 1
_playerId$ = 32						; size = 6
_broadcast$ = 40					; size = 1
_shiftTimestamp$ = 44					; size = 1
_networkID$ = 48					; size = 8
_replyFromTarget$ = 56					; size = 4
?RPC@RakPeer@@UAE_NPADPBDIW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N5UNetworkID@@PAVBitStream@RakNet@@@Z PROC ; RakPeer::RPC, COMDAT
; _this$ = ecx

; 1160 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?RPC@RakPeer@@UAE_NPADPBDIW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N5UNetworkID@@PAVBitStream@RakNet@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 632				; 00000278H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-644]
	mov	ecx, 158				; 0000009eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$AllocaPad$$[ebp], 0

; 1161 : #ifdef _DEBUG
; 1162 : 	assert( uniqueID && uniqueID[ 0 ] );

	cmp	DWORD PTR _uniqueID$[ebp], 0
	je	SHORT $LN40@RPC
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _uniqueID$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN41@RPC
$LN40@RPC:
	mov	ecx, DWORD PTR ?__LINE__Var@?1??RPC@RakPeer@@UAE_NPADPBDIW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N5UNetworkID@@PAVBitStream@RakNet@@@Z@4JA
	add	ecx, 2
	push	ecx
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_1DE@MNMFCGFF@?$AAu?$AAn?$AAi?$AAq?$AAu?$AAe?$AAI?$AAD?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAu?$AAn?$AAi?$AAq?$AAu?$AAe?$AAI?$AAD?$AA?$FL?$AA?5?$AA0?$AA?5?$AA?$FN?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN41@RPC:

; 1163 : 	assert(orderingChannel >=0 && orderingChannel < 32);

	movsx	eax, BYTE PTR _orderingChannel$[ebp]
	test	eax, eax
	jl	SHORT $LN42@RPC
	movsx	ecx, BYTE PTR _orderingChannel$[ebp]
	cmp	ecx, 32					; 00000020H
	jl	SHORT $LN43@RPC
$LN42@RPC:
	mov	edx, DWORD PTR ?__LINE__Var@?1??RPC@RakPeer@@UAE_NPADPBDIW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N5UNetworkID@@PAVBitStream@RakNet@@@Z@4JA
	add	edx, 3
	push	edx
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_1FI@DAMMCKDJ@?$AAo?$AAr?$AAd?$AAe?$AAr?$AAi?$AAn?$AAg?$AAC?$AAh?$AAa?$AAn?$AAn?$AAe?$AAl?$AA?5?$AA?$DO?$AA?$DN?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAo?$AAr?$AAd?$AAe?$AAr?$AAi?$AAn?$AAg?$AAC@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN43@RPC:

; 1164 : #endif
; 1165 : 
; 1166 : 	if ( uniqueID == 0 )

	cmp	DWORD PTR _uniqueID$[ebp], 0
	jne	SHORT $LN37@RPC

; 1167 : 		return false;

	xor	al, al
	jmp	$LN38@RPC
$LN37@RPC:

; 1168 : 
; 1169 : 	if ( strlen( uniqueID ) > 256 )

	mov	eax, DWORD PTR _uniqueID$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	cmp	eax, 256				; 00000100H
	jbe	SHORT $LN36@RPC

; 1170 : 	{
; 1171 : #ifdef _DEBUG
; 1172 : 		assert( 0 );

	xor	eax, eax
	jne	SHORT $LN44@RPC
	mov	ecx, DWORD PTR ?__LINE__Var@?1??RPC@RakPeer@@UAE_NPADPBDIW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N5UNetworkID@@PAVBitStream@RakNet@@@Z@4JA
	add	ecx, 12					; 0000000cH
	push	ecx
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_13COJANIEC@?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN44@RPC:

; 1173 : #endif
; 1174 : 		return false; // Unique ID is too long

	xor	al, al
	jmp	$LN38@RPC
$LN36@RPC:

; 1175 : 	}
; 1176 : 	if (replyFromTarget && blockOnRPCReply==true)

	cmp	DWORD PTR _replyFromTarget$[ebp], 0
	je	SHORT $LN35@RPC
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+2085]
	cmp	ecx, 1
	jne	SHORT $LN35@RPC

; 1177 : 	{
; 1178 : 		// TODO - this should be fixed eventually
; 1179 : 		// Prevent a bug where function A calls B (blocking) which calls C back on the sender, which calls D, and C is blocking.
; 1180 : 		// blockOnRPCReply is a shared variable so making it unset would unset both blocks, rather than the lowest on the callstack
; 1181 : 		// Fix by tracking which function the reply is for.
; 1182 : 		return false;

	xor	al, al
	jmp	$LN38@RPC
$LN35@RPC:

; 1183 : 	}
; 1184 : 
; 1185 : 	unsigned *sendList;
; 1186 : //	bool callerAllocationDataUsed;
; 1187 : 	unsigned sendListSize;
; 1188 : 
; 1189 : 	// All this code modifies bcs->data and bcs->numberOfBitsToSend in order to transform an RPC request into an actual packet for SendImmediate
; 1190 : 	RPCIndex rpcIndex; // Index into the list of RPC calls so we know what number to encode in the packet
; 1191 : //	char *userData; // RPC ID (the name of it) and a pointer to the data sent by the user
; 1192 : //	int extraBuffer; // How many data bytes were allocated to hold the RPC header
; 1193 : 	unsigned remoteSystemIndex, sendListIndex; // Iterates into the list of remote systems
; 1194 : //	int dataBlockAllocationLength; // Total number of bytes to allocate for the packet
; 1195 : //	char *writeTarget; // Used to hold either a block of allocated data or the externally allocated data
; 1196 : 
; 1197 : 	sendListSize=0;

	mov	DWORD PTR _sendListSize$[ebp], 0

; 1198 : 	bool routeSend;
; 1199 : 	routeSend=false;

	mov	BYTE PTR _routeSend$[ebp], 0

; 1200 : 
; 1201 : 	if (broadcast==false)

	movzx	eax, BYTE PTR _broadcast$[ebp]
	test	eax, eax
	jne	$LN34@RPC
	mov	eax, 4
	add	eax, 36					; 00000024H
	mov	DWORD PTR tv345[ebp], eax

; 1202 : 	{
; 1203 : #if !defined(_COMPATIBILITY_1)
; 1204 : 		sendList=(unsigned *)alloca(sizeof(unsigned));

	mov	eax, DWORD PTR tv345[ebp]
	call	__alloca_probe_16
	mov	DWORD PTR tv133[ebp], esp
	lea	ecx, DWORD PTR __$AllocaPad$$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv345[ebp]
	mov	ecx, DWORD PTR tv133[ebp]
	call	@_RTC_AllocaHelper@12
	add	DWORD PTR tv133[ebp], 32		; 00000020H
	mov	edx, DWORD PTR tv133[ebp]
	mov	DWORD PTR _sendList$[ebp], edx

; 1205 : #else
; 1206 : 		sendList = new unsigned[1];
; 1207 : #endif
; 1208 : 		remoteSystemIndex=GetIndexFromPlayerID( playerId, false );

	push	0
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexFromPlayerID@RakPeer@@IAEHUPlayerID@@_N@Z ; RakPeer::GetIndexFromPlayerID
	mov	DWORD PTR _remoteSystemIndex$[ebp], eax

; 1209 : 		if (remoteSystemIndex!=(unsigned)-1 &&
; 1210 : 			remoteSystemList[remoteSystemIndex].connectMode!=RemoteSystemStruct::DISCONNECT_ASAP && 
; 1211 : 			remoteSystemList[remoteSystemIndex].connectMode!=RemoteSystemStruct::DISCONNECT_ASAP_SILENTLY && 
; 1212 : 			remoteSystemList[remoteSystemIndex].connectMode!=RemoteSystemStruct::DISCONNECT_ON_NO_ACK)

	cmp	DWORD PTR _remoteSystemIndex$[ebp], -1
	je	SHORT $LN33@RPC
	imul	eax, DWORD PTR _remoteSystemIndex$[ebp], 2058
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	cmp	DWORD PTR [edx+eax+2054], 1
	je	SHORT $LN33@RPC
	imul	eax, DWORD PTR _remoteSystemIndex$[ebp], 2058
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	cmp	DWORD PTR [edx+eax+2054], 2
	je	SHORT $LN33@RPC
	imul	eax, DWORD PTR _remoteSystemIndex$[ebp], 2058
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	cmp	DWORD PTR [edx+eax+2054], 3
	je	SHORT $LN33@RPC

; 1213 : 		{
; 1214 : 			sendList[0]=remoteSystemIndex;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _sendList$[ebp]
	mov	eax, DWORD PTR _remoteSystemIndex$[ebp]
	mov	DWORD PTR [edx+ecx], eax

; 1215 : 			sendListSize=1;

	mov	DWORD PTR _sendListSize$[ebp], 1
	jmp	SHORT $LN32@RPC
$LN33@RPC:

; 1216 : 		}
; 1217 : 		else if (router)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2086], 0
	je	SHORT $LN32@RPC

; 1218 : 			routeSend=true;

	mov	BYTE PTR _routeSend$[ebp], 1
$LN32@RPC:

; 1219 : 	}
; 1220 : 	else

	jmp	$LN30@RPC
$LN34@RPC:

; 1221 : 	{
; 1222 : #if !defined(_COMPATIBILITY_1)
; 1223 : 		sendList=(unsigned *)alloca(sizeof(unsigned)*maximumNumberOfPeers);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+7]
	shl	ecx, 2
	add	ecx, 36					; 00000024H
	mov	DWORD PTR tv350[ebp], ecx
	mov	eax, DWORD PTR tv350[ebp]
	call	__alloca_probe_16
	mov	DWORD PTR tv163[ebp], esp
	lea	edx, DWORD PTR __$AllocaPad$$[ebp]
	push	edx
	mov	edx, DWORD PTR tv350[ebp]
	mov	ecx, DWORD PTR tv163[ebp]
	call	@_RTC_AllocaHelper@12
	add	DWORD PTR tv163[ebp], 32		; 00000020H
	mov	eax, DWORD PTR tv163[ebp]
	mov	DWORD PTR _sendList$[ebp], eax

; 1224 : #else
; 1225 : 		sendList = new unsigned[maximumNumberOfPeers];
; 1226 : #endif
; 1227 : 
; 1228 : 		for ( remoteSystemIndex = 0; remoteSystemIndex < maximumNumberOfPeers; remoteSystemIndex++ )

	mov	DWORD PTR _remoteSystemIndex$[ebp], 0
	jmp	SHORT $LN29@RPC
$LN28@RPC:
	mov	eax, DWORD PTR _remoteSystemIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _remoteSystemIndex$[ebp], eax
$LN29@RPC:
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+7]
	cmp	DWORD PTR _remoteSystemIndex$[ebp], ecx
	jae	SHORT $LN30@RPC

; 1229 : 		{
; 1230 : 			if ( remoteSystemList[ remoteSystemIndex ].isActive && remoteSystemList[ remoteSystemIndex ].playerId != playerId )

	imul	eax, DWORD PTR _remoteSystemIndex$[ebp], 2058
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	movzx	eax, BYTE PTR [edx+eax]
	test	eax, eax
	je	SHORT $LN26@RPC
	lea	eax, DWORD PTR _playerId$[ebp]
	push	eax
	imul	ecx, DWORD PTR _remoteSystemIndex$[ebp], 2058
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+820]
	lea	ecx, DWORD PTR [eax+ecx+1]
	call	??9PlayerID@@QBE_NABU0@@Z		; PlayerID::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN26@RPC

; 1231 : 				sendList[sendListSize++]=remoteSystemIndex;

	mov	eax, DWORD PTR _sendListSize$[ebp]
	mov	ecx, DWORD PTR _sendList$[ebp]
	mov	edx, DWORD PTR _remoteSystemIndex$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx
	mov	eax, DWORD PTR _sendListSize$[ebp]
	add	eax, 1
	mov	DWORD PTR _sendListSize$[ebp], eax
$LN26@RPC:

; 1232 : 		}

	jmp	SHORT $LN28@RPC
$LN30@RPC:

; 1233 : 	}
; 1234 : 
; 1235 : 	if (sendListSize==0 && routeSend==false)

	cmp	DWORD PTR _sendListSize$[ebp], 0
	jne	SHORT $LN25@RPC
	movzx	eax, BYTE PTR _routeSend$[ebp]
	test	eax, eax
	jne	SHORT $LN25@RPC

; 1236 : 	{
; 1237 : #if defined(_COMPATIBILITY_1)
; 1238 : 		delete [] sendList;
; 1239 : #endif
; 1240 : 
; 1241 : 		return false;

	xor	al, al
	jmp	$LN38@RPC
$LN25@RPC:

; 1242 : 	}
; 1243 : 	if (routeSend)

	movzx	eax, BYTE PTR _routeSend$[ebp]
	test	eax, eax
	je	SHORT $LN24@RPC

; 1244 : 		sendListSize=1;

	mov	DWORD PTR _sendListSize$[ebp], 1
$LN24@RPC:

; 1245 : 
; 1246 : 	RakNet::BitStream outgoingBitStream;

	lea	ecx, DWORD PTR _outgoingBitStream$[ebp]
	call	??0BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1247 : 	// remoteSystemList in network thread
; 1248 : 	for (sendListIndex=0; sendListIndex < (unsigned)sendListSize; sendListIndex++)

	mov	DWORD PTR _sendListIndex$[ebp], 0
	jmp	SHORT $LN23@RPC
$LN22@RPC:
	mov	eax, DWORD PTR _sendListIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _sendListIndex$[ebp], eax
$LN23@RPC:
	mov	eax, DWORD PTR _sendListIndex$[ebp]
	cmp	eax, DWORD PTR _sendListSize$[ebp]
	jae	$LN21@RPC

; 1249 : 	{
; 1250 : 		outgoingBitStream.ResetWritePointer(); // Let us write at the start of the data block, rather than at the end

	lea	ecx, DWORD PTR _outgoingBitStream$[ebp]
	call	?ResetWritePointer@BitStream@RakNet@@QAEXXZ ; RakNet::BitStream::ResetWritePointer

; 1251 : 
; 1252 : 		if (shiftTimestamp)

	movzx	eax, BYTE PTR _shiftTimestamp$[ebp]
	test	eax, eax
	je	SHORT $LN20@RPC

; 1253 : 		{
; 1254 : 			outgoingBitStream.Write((unsigned char) ID_TIMESTAMP);

	push	36					; 00000024H
	lea	ecx, DWORD PTR _outgoingBitStream$[ebp]
	call	??$Write@E@BitStream@RakNet@@QAEXE@Z	; RakNet::BitStream::Write<unsigned char>

; 1255 : 			outgoingBitStream.Write(RakNet::GetTime());

	call	?GetTime@RakNet@@YAIXZ			; RakNet::GetTime
	push	eax
	lea	ecx, DWORD PTR _outgoingBitStream$[ebp]
	call	??$Write@I@BitStream@RakNet@@QAEXI@Z	; RakNet::BitStream::Write<unsigned int>
$LN20@RPC:

; 1256 : 		}
; 1257 : 		outgoingBitStream.Write((unsigned char) ID_RPC);

	push	19					; 00000013H
	lea	ecx, DWORD PTR _outgoingBitStream$[ebp]
	call	??$Write@E@BitStream@RakNet@@QAEXE@Z	; RakNet::BitStream::Write<unsigned char>

; 1258 : 		if (routeSend)

	movzx	eax, BYTE PTR _routeSend$[ebp]
	test	eax, eax
	je	SHORT $LN19@RPC

; 1259 : 			rpcIndex=UNDEFINED_RPC_INDEX;

	mov	BYTE PTR _rpcIndex$[ebp], 255		; 000000ffH

; 1260 : 		else

	jmp	SHORT $LN18@RPC
$LN19@RPC:

; 1261 : 			rpcIndex=remoteSystemList[sendList[sendListIndex]].rpcMap.GetIndexFromFunctionName(uniqueID); // Lots of trouble but we can only use remoteSystem->[whatever] in this thread so that is why this command was buffered

	mov	eax, DWORD PTR _uniqueID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sendListIndex$[ebp]
	mov	edx, DWORD PTR _sendList$[ebp]
	imul	eax, DWORD PTR [edx+ecx*4], 2058
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	lea	ecx, DWORD PTR [edx+eax+2042]
	call	?GetIndexFromFunctionName@RPCMap@@QAEEPAD@Z ; RPCMap::GetIndexFromFunctionName
	mov	BYTE PTR _rpcIndex$[ebp], al
$LN18@RPC:

; 1262 : 		if (rpcIndex!=UNDEFINED_RPC_INDEX)

	movzx	eax, BYTE PTR _rpcIndex$[ebp]
	cmp	eax, 255				; 000000ffH
	je	SHORT $LN17@RPC

; 1263 : 		{
; 1264 : 			// We have an RPC name to an index mapping, so write the index
; 1265 : 			outgoingBitStream.Write(false);

	push	0
	lea	ecx, DWORD PTR _outgoingBitStream$[ebp]
	call	??$Write@_N@BitStream@RakNet@@QAEX_N@Z	; RakNet::BitStream::Write<bool>

; 1266 : 			outgoingBitStream.WriteCompressed(rpcIndex);

	movzx	eax, BYTE PTR _rpcIndex$[ebp]
	push	eax
	lea	ecx, DWORD PTR _outgoingBitStream$[ebp]
	call	??$WriteCompressed@E@BitStream@RakNet@@QAEXE@Z ; RakNet::BitStream::WriteCompressed<unsigned char>

; 1267 : 		}
; 1268 : 		else

	jmp	SHORT $LN16@RPC
$LN17@RPC:

; 1269 : 		{
; 1270 : 			// No mapping, so write the encoded RPC name
; 1271 : 			outgoingBitStream.Write(true);

	push	1
	lea	ecx, DWORD PTR _outgoingBitStream$[ebp]
	call	??$Write@_N@BitStream@RakNet@@QAEX_N@Z	; RakNet::BitStream::Write<bool>

; 1272 : 			stringCompressor->EncodeString(uniqueID, 256, &outgoingBitStream);

	push	0
	lea	eax, DWORD PTR _outgoingBitStream$[ebp]
	push	eax
	push	256					; 00000100H
	mov	ecx, DWORD PTR _uniqueID$[ebp]
	push	ecx
	call	?Instance@StringCompressor@@SAPAV1@XZ	; StringCompressor::Instance
	mov	ecx, eax
	call	?EncodeString@StringCompressor@@QAEXPBDHPAVBitStream@RakNet@@H@Z ; StringCompressor::EncodeString
$LN16@RPC:

; 1273 : 		}
; 1274 : 		outgoingBitStream.Write((bool) ((replyFromTarget!=0)==true));

	cmp	DWORD PTR _replyFromTarget$[ebp], 0
	je	SHORT $LN45@RPC
	mov	DWORD PTR tv233[ebp], 1
	jmp	SHORT $LN46@RPC
$LN45@RPC:
	mov	DWORD PTR tv233[ebp], 0
$LN46@RPC:
	cmp	DWORD PTR tv233[ebp], 1
	jne	SHORT $LN47@RPC
	mov	BYTE PTR tv235[ebp], 1
	jmp	SHORT $LN48@RPC
$LN47@RPC:
	mov	BYTE PTR tv235[ebp], 0
$LN48@RPC:
	movzx	eax, BYTE PTR tv235[ebp]
	push	eax
	lea	ecx, DWORD PTR _outgoingBitStream$[ebp]
	call	??$Write@_N@BitStream@RakNet@@QAEX_N@Z	; RakNet::BitStream::Write<bool>

; 1275 : 		outgoingBitStream.WriteCompressed( bitLength );

	mov	eax, DWORD PTR _bitLength$[ebp]
	push	eax
	lea	ecx, DWORD PTR _outgoingBitStream$[ebp]
	call	??$WriteCompressed@I@BitStream@RakNet@@QAEXI@Z ; RakNet::BitStream::WriteCompressed<unsigned int>

; 1276 : 		if (networkID==UNASSIGNED_NETWORK_ID)

	push	OFFSET _UNASSIGNED_NETWORK_ID
	lea	ecx, DWORD PTR _networkID$[ebp]
	call	??8NetworkID@@QBE_NABU0@@Z		; NetworkID::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN15@RPC

; 1277 : 		{
; 1278 : 			// No object ID
; 1279 : 			outgoingBitStream.Write(false);

	push	0
	lea	ecx, DWORD PTR _outgoingBitStream$[ebp]
	call	??$Write@_N@BitStream@RakNet@@QAEX_N@Z	; RakNet::BitStream::Write<bool>

; 1280 : 		}
; 1281 : 		else

	jmp	SHORT $LN14@RPC
$LN15@RPC:

; 1282 : 		{
; 1283 : 			// Encode an object ID.  This will use pointer to class member RPC
; 1284 : 			outgoingBitStream.Write(true);

	push	1
	lea	ecx, DWORD PTR _outgoingBitStream$[ebp]
	call	??$Write@_N@BitStream@RakNet@@QAEX_N@Z	; RakNet::BitStream::Write<bool>

; 1285 : 			outgoingBitStream.Write(networkID);

	mov	eax, DWORD PTR _networkID$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _networkID$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _outgoingBitStream$[ebp]
	call	??$Write@UNetworkID@@@BitStream@RakNet@@QAEXUNetworkID@@@Z ; RakNet::BitStream::Write<NetworkID>
$LN14@RPC:

; 1286 : 		}
; 1287 : 
; 1288 : 
; 1289 : 		if ( bitLength > 0 )

	cmp	DWORD PTR _bitLength$[ebp], 0
	jbe	SHORT $LN13@RPC

; 1290 : 			outgoingBitStream.WriteBits( (const unsigned char *) data, bitLength, false ); // Last param is false to write the raw data originally from another bitstream, rather than shifting from user data

	push	0
	mov	eax, DWORD PTR _bitLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _outgoingBitStream$[ebp]
	call	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z ; RakNet::BitStream::WriteBits

; 1291 : 		else

	jmp	SHORT $LN12@RPC
$LN13@RPC:

; 1292 : 			outgoingBitStream.WriteCompressed( ( unsigned int ) 0 );

	push	0
	lea	ecx, DWORD PTR _outgoingBitStream$[ebp]
	call	??$WriteCompressed@I@BitStream@RakNet@@QAEXI@Z ; RakNet::BitStream::WriteCompressed<unsigned int>
$LN12@RPC:

; 1293 : 
; 1294 : 		if (routeSend)

	movzx	eax, BYTE PTR _routeSend$[ebp]
	test	eax, eax
	je	SHORT $LN11@RPC

; 1295 : 			router->Send((const char*)outgoingBitStream.GetData(), outgoingBitStream.GetNumberOfBitsUsed(), priority,reliability,orderingChannel,playerId);

	mov	esi, esp
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	movzx	eax, BYTE PTR _orderingChannel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _reliability$[ebp]
	push	ecx
	mov	edx, DWORD PTR _priority$[ebp]
	push	edx
	lea	ecx, DWORD PTR _outgoingBitStream$[ebp]
	call	?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBitsUsed
	push	eax
	lea	ecx, DWORD PTR _outgoingBitStream$[ebp]
	call	?GetData@BitStream@RakNet@@QBEPAEXZ	; RakNet::BitStream::GetData
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2086]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+2086]
	mov	edx, DWORD PTR [eax]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1296 : 		else

	jmp	SHORT $LN10@RPC
$LN11@RPC:

; 1297 : 			Send(&outgoingBitStream, priority, reliability, orderingChannel, remoteSystemList[sendList[sendListIndex]].playerId, false);

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR _sendListIndex$[ebp]
	mov	ecx, DWORD PTR _sendList$[ebp]
	imul	edx, DWORD PTR [ecx+eax*4], 2058
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	lea	edx, DWORD PTR [ecx+edx+1]
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR [edx+4]
	mov	WORD PTR [eax+4], dx
	movzx	eax, BYTE PTR _orderingChannel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _reliability$[ebp]
	push	ecx
	mov	edx, DWORD PTR _priority$[ebp]
	push	edx
	lea	eax, DWORD PTR _outgoingBitStream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@RPC:

; 1298 : 	}

	jmp	$LN22@RPC
$LN21@RPC:

; 1299 : 
; 1300 : #if defined(_COMPATIBILITY_1)
; 1301 : 	delete [] sendList;
; 1302 : #endif
; 1303 : 
; 1304 : 	if (replyFromTarget)

	cmp	DWORD PTR _replyFromTarget$[ebp], 0
	je	SHORT $LN9@RPC

; 1305 : 	{
; 1306 : 		blockOnRPCReply=true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+2085], 1

; 1307 : 		// 04/20/06 Just do this transparently.
; 1308 : 		// We have to be able to read blocking packets out of order.  Otherwise, if two systems were to send blocking RPC calls to each other at the same time,
; 1309 : 		// and they also had ordered packets waiting before the block, it would be impossible to unblock.
; 1310 : 		// assert(reliability==RELIABLE || reliability==UNRELIABLE);
; 1311 : 		replyFromTargetBS=replyFromTarget;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _replyFromTarget$[ebp]
	mov	DWORD PTR [eax+2074], ecx

; 1312 : 		replyFromTargetPlayer=playerId;

	lea	eax, DWORD PTR _playerId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2078				; 0000081eH
	call	??4PlayerID@@QAEAAU0@ABU0@@Z		; PlayerID::operator=

; 1313 : 		replyFromTargetBroadcast=broadcast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _broadcast$[ebp]
	mov	BYTE PTR [eax+2084], cl
$LN9@RPC:

; 1314 : 	}
; 1315 : 
; 1316 : 	// Do not enter this loop on blockOnRPCReply because it is a global which could be set to true by an RPC higher on the callstack, where one RPC was called while waiting for another RPC
; 1317 : 	if (replyFromTarget)

	cmp	DWORD PTR _replyFromTarget$[ebp], 0
	je	$LN8@RPC
	mov	BYTE PTR $T4[ebp], 0

; 1318 : //	if (blockOnRPCReply)
; 1319 : 	{
; 1320 : //		Packet *p;
; 1321 : 		RakNetTime stopWaitingTime;
; 1322 : //		RPCIndex arrivedRPCIndex;
; 1323 : //		char uniqueIdentifier[256];
; 1324 : 		if (reliability==UNRELIABLE)

	cmp	DWORD PTR _reliability$[ebp], 0
	jne	SHORT $LN4@RPC

; 1325 : 			if (playerId==UNASSIGNED_PLAYER_ID)

	push	OFFSET _UNASSIGNED_PLAYER_ID
	lea	ecx, DWORD PTR _playerId$[ebp]
	call	??8PlayerID@@QBE_NABU0@@Z		; PlayerID::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@RPC

; 1326 : 				stopWaitingTime=RakNet::GetTime()+1500; // Lets guess the ave. ping is 500.  Not important to be very accurate

	call	?GetTime@RakNet@@YAIXZ			; RakNet::GetTime
	add	eax, 1500				; 000005dcH
	mov	BYTE PTR $T4[ebp], 1
	mov	DWORD PTR _stopWaitingTime$5[ebp], eax

; 1327 : 			else

	jmp	SHORT $LN4@RPC
$LN6@RPC:

; 1328 : 				stopWaitingTime=RakNet::GetTime()+GetAveragePing(playerId)*3;

	call	?GetTime@RakNet@@YAIXZ			; RakNet::GetTime
	mov	esi, eax
	mov	edi, esp
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+124]
	call	eax
	cmp	edi, esp
	call	__RTC_CheckEsp
	imul	ecx, eax, 3
	add	esi, ecx
	mov	BYTE PTR $T4[ebp], 1
	mov	DWORD PTR _stopWaitingTime$5[ebp], esi
$LN4@RPC:

; 1329 : 
; 1330 : 		// For reliable messages, block until we get a reply or the connection is lost
; 1331 : 		// For unreliable messages, block until we get a reply, the connection is lost, or 3X the ping passes
; 1332 : 		while (blockOnRPCReply &&
; 1333 : 			((reliability==RELIABLE || reliability==RELIABLE_ORDERED || reliability==RELIABLE_SEQUENCED) ||
; 1334 : 			RakNet::GetTime() < stopWaitingTime))

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+2085]
	test	ecx, ecx
	je	$LN3@RPC
	cmp	DWORD PTR _reliability$[ebp], 2
	je	SHORT $LN2@RPC
	cmp	DWORD PTR _reliability$[ebp], 3
	je	SHORT $LN2@RPC
	cmp	DWORD PTR _reliability$[ebp], 4
	je	SHORT $LN2@RPC
	cmp	BYTE PTR $T4[ebp], 0
	jne	SHORT $LN50@RPC
	push	OFFSET $LN51@RPC
	call	__RTC_UninitUse
	add	esp, 4
$LN50@RPC:
	call	?GetTime@RakNet@@YAIXZ			; RakNet::GetTime
	cmp	eax, DWORD PTR _stopWaitingTime$5[ebp]
	jae	SHORT $LN3@RPC
$LN2@RPC:

; 1335 : 		{
; 1336 : 
; 1337 : 			RakSleep(30);

	push	30					; 0000001eH
	call	?RakSleep@@YAXI@Z			; RakSleep
	add	esp, 4

; 1338 : 
; 1339 : 			if (routeSend==false && ValidSendTarget(playerId, broadcast)==false)

	movzx	eax, BYTE PTR _routeSend$[ebp]
	test	eax, eax
	jne	SHORT $LN1@RPC
	movzx	eax, BYTE PTR _broadcast$[ebp]
	push	eax
	sub	esp, 8
	mov	ecx, esp
	mov	edx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	ax, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [ecx+4], ax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ValidSendTarget@RakPeer@@IAE_NUPlayerID@@_N@Z ; RakPeer::ValidSendTarget
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@RPC

; 1340 : 				return false;

	mov	BYTE PTR $T2[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _outgoingBitStream$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	al, BYTE PTR $T2[ebp]
	jmp	SHORT $LN38@RPC
$LN1@RPC:

; 1341 : 
; 1342 : 			// I might not support processing other RPCs while blocking on one due to complexities I can't control
; 1343 : 			// Problem is FuncA calls FuncB which calls back to the sender FuncC. Sometimes it is desirable to call FuncC before returning a return value
; 1344 : 			// from FuncB - sometimes not.  There is also a problem with recursion where FuncA calls FuncB which calls FuncA - sometimes valid if
; 1345 : 			// a different control path is taken in FuncA. (This can take many different forms)
; 1346 : 			/*
; 1347 : 			// Same as Receive, but doesn't automatically do RPCs
; 1348 : 			p = ReceiveIgnoreRPC();
; 1349 : 			if (p)
; 1350 : 			{
; 1351 : 				// Process all RPC calls except for those calling the function we are currently blocking in (to prevent recursion).
; 1352 : 				if ( p->data[ 0 ] == ID_RPC )
; 1353 : 				{
; 1354 : 					RakNet::BitStream temp((unsigned char *) p->data, p->length, false);
; 1355 : 					RPCNode *rpcNode;
; 1356 : 					temp.IgnoreBits(8);
; 1357 : 					bool nameIsEncoded;
; 1358 : 					temp.Read(nameIsEncoded);
; 1359 : 					if (nameIsEncoded)
; 1360 : 					{
; 1361 : 						stringCompressor->DecodeString((char*)uniqueIdentifier, 256, &temp);
; 1362 : 					}
; 1363 : 					else
; 1364 : 					{
; 1365 : 						temp.ReadCompressed( arrivedRPCIndex );
; 1366 : 						rpcNode=rpcMap.GetNodeFromIndex( arrivedRPCIndex );
; 1367 : 						if (rpcNode==0)
; 1368 : 						{
; 1369 : 							// Invalid RPC format
; 1370 : #ifdef _DEBUG
; 1371 : 							assert(0);
; 1372 : #endif
; 1373 : 							DeallocatePacket(p);
; 1374 : 							continue;
; 1375 : 						}
; 1376 : 						else
; 1377 : 							strcpy(uniqueIdentifier, rpcNode->uniqueIdentifier);
; 1378 : 					}
; 1379 : 
; 1380 : 					if (strcmp(uniqueIdentifier, uniqueID)!=0)
; 1381 : 					{
; 1382 : 						HandleRPCPacket( ( char* ) p->data, p->length, p->playerId );
; 1383 : 						DeallocatePacket(p);
; 1384 : 					}
; 1385 : 					else
; 1386 : 					{
; 1387 : 						PushBackPacket(p, false);
; 1388 : 					}
; 1389 : 				}
; 1390 : 				else
; 1391 : 				{
; 1392 : 					PushBackPacket(p, false);
; 1393 : 				}
; 1394 : 			}
; 1395 : 			*/
; 1396 : 		}

	jmp	$LN4@RPC
$LN3@RPC:

; 1397 : 
; 1398 : 		blockOnRPCReply=false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+2085], 0
$LN8@RPC:

; 1399 : 	}
; 1400 : 
; 1401 : 	return true;	

	mov	BYTE PTR $T3[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _outgoingBitStream$[ebp]
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	al, BYTE PTR $T3[ebp]
$LN38@RPC:

; 1402 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN56@RPC
	push	DWORD PTR __$AllocaPad$$[ebp]
	call	@_RTC_CheckStackVars2@12
	pop	eax
	pop	edx
	lea	esp, DWORD PTR [ebp-660]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	52					; 00000034H
	npad	3
$LN56@RPC:
	DD	2
	DD	$LN55@RPC
$LN55@RPC:
	DD	-380					; fffffe84H
	DD	273					; 00000111H
	DD	$LN52@RPC
	DD	-404					; fffffe6cH
	DD	4
	DD	$LN53@RPC
$LN53@RPC:
	DB	95					; 0000005fH
	DB	36					; 00000024H
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	36					; 00000024H
	DB	0
$LN52@RPC:
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	103					; 00000067H
	DB	111					; 0000006fH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	66					; 00000042H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	0
$LN51@RPC:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	111					; 0000006fH
	DB	112					; 00000070H
	DB	87					; 00000057H
	DB	97					; 00000061H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RPC@RakPeer@@UAE_NPADPBDIW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N5UNetworkID@@PAVBitStream@RakNet@@@Z$0:
	lea	ecx, DWORD PTR _outgoingBitStream$[ebp]
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__ehhandler$?RPC@RakPeer@@UAE_NPADPBDIW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N5UNetworkID@@PAVBitStream@RakNet@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-648]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?RPC@RakPeer@@UAE_NPADPBDIW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N5UNetworkID@@PAVBitStream@RakNet@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?RPC@RakPeer@@UAE_NPADPBDIW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N5UNetworkID@@PAVBitStream@RakNet@@@Z ENDP ; RakPeer::RPC
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?UnregisterAsRemoteProcedureCall@RakPeer@@UAEXPAD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uniqueID$ = 8						; size = 4
?UnregisterAsRemoteProcedureCall@RakPeer@@UAEXPAD@Z PROC ; RakPeer::UnregisterAsRemoteProcedureCall, COMDAT
; _this$ = ecx

; 1103 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1104 : 	if ( uniqueID == 0 || uniqueID[ 0 ] == 0 )

	cmp	DWORD PTR _uniqueID$[ebp], 0
	je	SHORT $LN1@Unregister
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _uniqueID$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN2@Unregister
$LN1@Unregister:

; 1105 : 		return;

	jmp	SHORT $LN3@Unregister
$LN2@Unregister:

; 1106 : 
; 1107 : // Don't call this while running because if you remove RPCs and add them they will not match the indices on the other systems anymore
; 1108 : #ifdef _DEBUG
; 1109 : 	assert(IsActive()==false);

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@Unregister
	mov	edx, DWORD PTR ?__LINE__Var@?1??UnregisterAsRemoteProcedureCall@RakPeer@@UAEXPAD@Z@4JA
	add	edx, 6
	push	edx
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_1CE@HHNGILKN@?$AAI?$AAs?$AAA?$AAc?$AAt?$AAi?$AAv?$AAe?$AA?$CI?$AA?$CJ?$AA?$DN?$AA?$DN?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN5@Unregister:

; 1110 : 	//assert( strlen( uniqueID ) < 256 );
; 1111 : #endif
; 1112 : 
; 1113 : 	rpcMap.RemoveNode(uniqueID);

	mov	eax, DWORD PTR _uniqueID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2049				; 00000801H
	call	?RemoveNode@RPCMap@@QAEXPAD@Z		; RPCMap::RemoveNode
$LN3@Unregister:

; 1114 : 
; 1115 : 	/*
; 1116 : 	char uppercaseUniqueID[ 256 ];
; 1117 : 
; 1118 : 	strcpy( uppercaseUniqueID, uniqueID );
; 1119 : 
; 1120 : 	int counter = 0;
; 1121 : 
; 1122 : 	while ( uniqueID[ counter ] )
; 1123 : 	{
; 1124 : 		uppercaseUniqueID[ counter ] = ( char ) toupper( uniqueID[ counter ] );
; 1125 : 		counter++;
; 1126 : 	}
; 1127 : 
; 1128 : 	uppercaseUniqueID[ counter ] = 0;
; 1129 : 
; 1130 : 	// Unique ID must exist
; 1131 : #ifdef _DEBUG
; 1132 : 	assert( rpcTree.IsIn( RPCNode( uppercaseUniqueID, 0 ) ) == true );
; 1133 : #endif
; 1134 : 
; 1135 : 	rpcTree.Del( RPCNode( uppercaseUniqueID, 0 ) );
; 1136 : 	*/
; 1137 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?UnregisterAsRemoteProcedureCall@RakPeer@@UAEXPAD@Z ENDP ; RakPeer::UnregisterAsRemoteProcedureCall
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?RegisterClassMemberRPC@RakPeer@@UAEXPADPAX@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uniqueID$ = 8						; size = 4
_functionPointer$ = 12					; size = 4
?RegisterClassMemberRPC@RakPeer@@UAEXPADPAX@Z PROC	; RakPeer::RegisterClassMemberRPC, COMDAT
; _this$ = ecx

; 1086 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1087 : 	if ( uniqueID == 0 || uniqueID[ 0 ] == 0 || functionPointer == 0 )

	cmp	DWORD PTR _uniqueID$[ebp], 0
	je	SHORT $LN1@RegisterCl
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _uniqueID$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	SHORT $LN1@RegisterCl
	cmp	DWORD PTR _functionPointer$[ebp], 0
	jne	SHORT $LN2@RegisterCl
$LN1@RegisterCl:

; 1088 : 		return;

	jmp	SHORT $LN3@RegisterCl
$LN2@RegisterCl:

; 1089 : 
; 1090 : 	rpcMap.AddIdentifierWithFunction(uniqueID, functionPointer, true);

	push	1
	mov	eax, DWORD PTR _functionPointer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _uniqueID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2049				; 00000801H
	call	?AddIdentifierWithFunction@RPCMap@@QAEXPADPAX_N@Z ; RPCMap::AddIdentifierWithFunction
$LN3@RegisterCl:

; 1091 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?RegisterClassMemberRPC@RakPeer@@UAEXPADPAX@Z ENDP	; RakPeer::RegisterClassMemberRPC
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?RegisterAsRemoteProcedureCall@RakPeer@@UAEXPADP6AXPAURPCParameters@@@Z@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uniqueID$ = 8						; size = 4
_functionPointer$ = 12					; size = 4
?RegisterAsRemoteProcedureCall@RakPeer@@UAEXPADP6AXPAURPCParameters@@@Z@Z PROC ; RakPeer::RegisterAsRemoteProcedureCall, COMDAT
; _this$ = ecx

; 1054 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1055 : 	if ( uniqueID == 0 || uniqueID[ 0 ] == 0 || functionPointer == 0 )

	cmp	DWORD PTR _uniqueID$[ebp], 0
	je	SHORT $LN1@RegisterAs
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _uniqueID$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	SHORT $LN1@RegisterAs
	cmp	DWORD PTR _functionPointer$[ebp], 0
	jne	SHORT $LN2@RegisterAs
$LN1@RegisterAs:

; 1056 : 		return;

	jmp	SHORT $LN3@RegisterAs
$LN2@RegisterAs:

; 1057 : 
; 1058 : 	rpcMap.AddIdentifierWithFunction(uniqueID, (void*)functionPointer, false);

	push	0
	mov	eax, DWORD PTR _functionPointer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _uniqueID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2049				; 00000801H
	call	?AddIdentifierWithFunction@RPCMap@@QAEXPADPAX_N@Z ; RPCMap::AddIdentifierWithFunction
$LN3@RegisterAs:

; 1059 : 
; 1060 : 	/*
; 1061 : 	char uppercaseUniqueID[ 256 ];
; 1062 : 
; 1063 : 	int counter = 0;
; 1064 : 
; 1065 : 	while ( uniqueID[ counter ] )
; 1066 : 	{
; 1067 : 		uppercaseUniqueID[ counter ] = ( char ) toupper( uniqueID[ counter ] );
; 1068 : 		counter++;
; 1069 : 	}
; 1070 : 
; 1071 : 	uppercaseUniqueID[ counter ] = 0;
; 1072 : 
; 1073 : 	// Each id must be unique
; 1074 : //#ifdef _DEBUG
; 1075 : //	assert( rpcTree.IsIn( RPCNode( uppercaseUniqueID, functionName ) ) == false );
; 1076 : //#endif
; 1077 : 
; 1078 : 	if (rpcTree.IsIn( RPCNode( uppercaseUniqueID, functionName ) ))
; 1079 : 		return;
; 1080 : 
; 1081 : 	rpcTree.Add( RPCNode( uppercaseUniqueID, functionName ) );
; 1082 : 	*/
; 1083 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?RegisterAsRemoteProcedureCall@RakPeer@@UAEXPADP6AXPAURPCParameters@@@Z@Z ENDP ; RakPeer::RegisterAsRemoteProcedureCall
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?GetMaximumNumberOfPeers@RakPeer@@UBEGXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetMaximumNumberOfPeers@RakPeer@@UBEGXZ PROC		; RakPeer::GetMaximumNumberOfPeers, COMDAT
; _this$ = ecx

; 1039 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1040 : 	return maximumNumberOfPeers;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+7]

; 1041 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMaximumNumberOfPeers@RakPeer@@UBEGXZ ENDP		; RakPeer::GetMaximumNumberOfPeers
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?DeallocatePacket@RakPeer@@UAEXPAUPacket@@@Z
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
_packet$ = 8						; size = 4
?DeallocatePacket@RakPeer@@UAEXPAUPacket@@@Z PROC	; RakPeer::DeallocatePacket, COMDAT
; _this$ = ecx

; 1025 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1026 : 	if ( packet == 0 )

	cmp	DWORD PTR _packet$[ebp], 0
	jne	SHORT $LN2@Deallocate

; 1027 : 		return;

	jmp	SHORT $LN3@Deallocate
$LN2@Deallocate:

; 1028 : 
; 1029 : 	if (packet->deleteData)

	mov	eax, DWORD PTR _packet$[ebp]
	movzx	ecx, BYTE PTR [eax+20]
	test	ecx, ecx
	je	SHORT $LN1@Deallocate

; 1030 : 		delete packet->data;

	mov	eax, DWORD PTR _packet$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Deallocate:

; 1031 : 	free(packet);

	mov	eax, DWORD PTR _packet$[ebp]
	push	eax
	call	_free
	add	esp, 4
$LN3@Deallocate:

; 1032 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?DeallocatePacket@RakPeer@@UAEXPAUPacket@@@Z ENDP	; RakPeer::DeallocatePacket
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?Receive@RakPeer@@UAEPAUPacket@@XZ
_TEXT	SEGMENT
_packet$ = -20						; size = 4
_this$ = -8						; size = 4
?Receive@RakPeer@@UAEPAUPacket@@XZ PROC			; RakPeer::Receive, COMDAT
; _this$ = ecx

; 905  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 906  : 	Packet *packet = ReceiveIgnoreRPC();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReceiveIgnoreRPC@RakPeer@@IAEPAUPacket@@XZ ; RakPeer::ReceiveIgnoreRPC
	mov	DWORD PTR _packet$[ebp], eax
$LN3@Receive:

; 907  : 	while (packet && (packet->data[ 0 ] == ID_RPC || (packet->length>sizeof(unsigned char)+sizeof(RakNetTime) && packet->data[0]==ID_TIMESTAMP && packet->data[sizeof(unsigned char)+sizeof(RakNetTime)]==ID_RPC)))

	cmp	DWORD PTR _packet$[ebp], 0
	je	$LN2@Receive
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _packet$[ebp]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax+ecx]
	cmp	ecx, 19					; 00000013H
	je	SHORT $LN1@Receive
	mov	eax, DWORD PTR _packet$[ebp]
	cmp	DWORD PTR [eax+8], 5
	jbe	$LN2@Receive
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _packet$[ebp]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax+ecx]
	cmp	ecx, 36					; 00000024H
	jne	SHORT $LN2@Receive
	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _packet$[ebp]
	mov	eax, DWORD PTR [edx+16]
	movzx	ecx, BYTE PTR [eax+ecx]
	cmp	ecx, 19					; 00000013H
	jne	SHORT $LN2@Receive
$LN1@Receive:

; 908  : 	{
; 909  : 		// Do RPC calls from the user thread, not the network update thread
; 910  : 		// If we are currently blocking on an RPC reply, send ID_RPC to the blocker to handle rather than handling RPCs automatically
; 911  : 		HandleRPCPacket( ( char* ) packet->data, packet->length, packet->playerId );

	mov	eax, DWORD PTR _packet$[ebp]
	add	eax, 2
	sub	esp, 8
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	ax, WORD PTR [eax+4]
	mov	WORD PTR [ecx+4], ax
	mov	ecx, DWORD PTR _packet$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _packet$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HandleRPCPacket@RakPeer@@IAE_NPBDHUPlayerID@@@Z ; RakPeer::HandleRPCPacket

; 912  : 		DeallocatePacket( packet );

	mov	esi, esp
	mov	eax, DWORD PTR _packet$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 913  : 
; 914  : 		packet = ReceiveIgnoreRPC();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReceiveIgnoreRPC@RakPeer@@IAEPAUPacket@@XZ ; RakPeer::ReceiveIgnoreRPC
	mov	DWORD PTR _packet$[ebp], eax

; 915  : 	}

	jmp	$LN3@Receive
$LN2@Receive:

; 916  : 
; 917  :     return packet;

	mov	eax, DWORD PTR _packet$[ebp]

; 918  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Receive@RakPeer@@UAEPAUPacket@@XZ ENDP			; RakPeer::Receive
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?Send@RakPeer@@UAE_NPAVBitStream@RakNet@@W4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_bitStream$ = 8						; size = 4
_priority$ = 12						; size = 4
_reliability$ = 16					; size = 4
_orderingChannel$ = 20					; size = 1
_playerId$ = 24						; size = 6
_broadcast$ = 32					; size = 1
?Send@RakPeer@@UAE_NPAVBitStream@RakNet@@W4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N@Z PROC ; RakPeer::Send, COMDAT
; _this$ = ecx

; 866  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 867  : #ifdef _DEBUG
; 868  : 	assert( bitStream->GetNumberOfBytesUsed() > 0 );

	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	?GetNumberOfBytesUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBytesUsed
	test	eax, eax
	jg	SHORT $LN9@Send
	mov	eax, DWORD PTR ?__LINE__Var@?1??Send@RakPeer@@UAE_NPAVBitStream@RakNet@@W4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N@Z@4JA
	add	eax, 2
	push	eax
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_1EM@PPKFOLDM@?$AAb?$AAi?$AAt?$AAS?$AAt?$AAr?$AAe?$AAa?$AAm?$AA?9?$AA?$DO?$AAG?$AAe?$AAt?$AAN?$AAu?$AAm?$AAb?$AAe?$AAr?$AAO?$AAf?$AAB?$AAy?$AAt?$AAe?$AAs?$AAU?$AAs?$AAe?$AAd?$AA?$CI@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN9@Send:

; 869  : #endif
; 870  : 
; 871  : 	if ( bitStream->GetNumberOfBytesUsed() == 0 )

	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	?GetNumberOfBytesUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBytesUsed
	test	eax, eax
	jne	SHORT $LN6@Send

; 872  : 		return false;

	xor	al, al
	jmp	$LN7@Send
$LN6@Send:

; 873  : 
; 874  : 	if ( remoteSystemList == 0 || endThreads == true )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+820], 0
	je	SHORT $LN4@Send
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	cmp	ecx, 1
	jne	SHORT $LN5@Send
$LN4@Send:

; 875  : 		return false;

	xor	al, al
	jmp	$LN7@Send
$LN5@Send:

; 876  : 
; 877  : 	if ( broadcast == false && playerId == UNASSIGNED_PLAYER_ID )

	movzx	eax, BYTE PTR _broadcast$[ebp]
	test	eax, eax
	jne	SHORT $LN3@Send
	push	OFFSET _UNASSIGNED_PLAYER_ID
	lea	ecx, DWORD PTR _playerId$[ebp]
	call	??8PlayerID@@QBE_NABU0@@Z		; PlayerID::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@Send

; 878  : 		return false;

	xor	al, al
	jmp	$LN7@Send
$LN3@Send:

; 879  : 
; 880  : 	if (broadcast==false && router && GetIndexFromPlayerID(playerId)==-1)

	movzx	eax, BYTE PTR _broadcast$[ebp]
	test	eax, eax
	jne	$LN2@Send
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2086], 0
	je	$LN2@Send
	mov	esi, esp
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+92]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, -1
	jne	SHORT $LN2@Send

; 881  : 	{
; 882  : 		return router->Send((const char*)bitStream->GetData(), bitStream->GetNumberOfBitsUsed(), priority, reliability, orderingChannel, playerId);

	mov	esi, esp
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	movzx	eax, BYTE PTR _orderingChannel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _reliability$[ebp]
	push	ecx
	mov	edx, DWORD PTR _priority$[ebp]
	push	edx
	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBitsUsed
	push	eax
	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	?GetData@BitStream@RakNet@@QBEPAEXZ	; RakNet::BitStream::GetData
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2086]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+2086]
	mov	edx, DWORD PTR [eax]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN7@Send

; 883  : 	}
; 884  : 	else

	jmp	SHORT $LN1@Send
$LN2@Send:

; 885  : 	{
; 886  : 		// Sends need to be buffered and processed in the update thread because the playerID associated with the reliability layer can change,
; 887  : 		// from that thread, resulting in a send to the wrong player!  While I could mutex the playerID, that is much slower than doing this
; 888  : 		SendBuffered((const char*)bitStream->GetData(), bitStream->GetNumberOfBitsUsed(), priority, reliability, orderingChannel, playerId, broadcast, RemoteSystemStruct::NO_ACTION);

	push	0
	movzx	eax, BYTE PTR _broadcast$[ebp]
	push	eax
	sub	esp, 8
	mov	ecx, esp
	mov	edx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	ax, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [ecx+4], ax
	movzx	ecx, BYTE PTR _orderingChannel$[ebp]
	push	ecx
	mov	edx, DWORD PTR _reliability$[ebp]
	push	edx
	mov	eax, DWORD PTR _priority$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetNumberOfBitsUsed
	push	eax
	mov	ecx, DWORD PTR _bitStream$[ebp]
	call	?GetData@BitStream@RakNet@@QBEPAEXZ	; RakNet::BitStream::GetData
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendBuffered@RakPeer@@IAEXPBDHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_NW4ConnectMode@RemoteSystemStruct@1@@Z ; RakPeer::SendBuffered
$LN1@Send:

; 889  : 	}
; 890  : 	
; 891  : 	return true;

	mov	al, 1
$LN7@Send:

; 892  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?Send@RakPeer@@UAE_NPAVBitStream@RakNet@@W4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N@Z ENDP ; RakPeer::Send
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?Send@RakPeer@@UAE_NPBDHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_data$ = 8						; size = 4
_length$ = 12						; size = 4
_priority$ = 16						; size = 4
_reliability$ = 20					; size = 4
_orderingChannel$ = 24					; size = 1
_playerId$ = 28						; size = 6
_broadcast$ = 36					; size = 1
?Send@RakPeer@@UAE_NPBDHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N@Z PROC ; RakPeer::Send, COMDAT
; _this$ = ecx

; 839  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 840  : #ifdef _DEBUG
; 841  : 	assert( data && length > 0 );

	cmp	DWORD PTR _data$[ebp], 0
	je	SHORT $LN10@Send
	cmp	DWORD PTR _length$[ebp], 0
	jg	SHORT $LN11@Send
$LN10@Send:
	mov	eax, DWORD PTR ?__LINE__Var@?1??Send@RakPeer@@UAE_NPBDHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N@Z@4JA
	add	eax, 2
	push	eax
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_1CG@KMHNBCAF@?$AAd?$AAa?$AAt?$AAa?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAl?$AAe?$AAn?$AAg?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN11@Send:

; 842  : #endif
; 843  : 
; 844  : 	if ( data == 0 || length < 0 )

	cmp	DWORD PTR _data$[ebp], 0
	je	SHORT $LN6@Send
	cmp	DWORD PTR _length$[ebp], 0
	jge	SHORT $LN7@Send
$LN6@Send:

; 845  : 		return false;

	xor	al, al
	jmp	$LN8@Send
$LN7@Send:

; 846  : 
; 847  : 	if ( remoteSystemList == 0 || endThreads == true )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+820], 0
	je	SHORT $LN4@Send
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	cmp	ecx, 1
	jne	SHORT $LN5@Send
$LN4@Send:

; 848  : 		return false;

	xor	al, al
	jmp	$LN8@Send
$LN5@Send:

; 849  : 
; 850  : 	if ( broadcast == false && playerId == UNASSIGNED_PLAYER_ID )

	movzx	eax, BYTE PTR _broadcast$[ebp]
	test	eax, eax
	jne	SHORT $LN3@Send
	push	OFFSET _UNASSIGNED_PLAYER_ID
	lea	ecx, DWORD PTR _playerId$[ebp]
	call	??8PlayerID@@QBE_NABU0@@Z		; PlayerID::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@Send

; 851  : 		return false;

	xor	al, al
	jmp	$LN8@Send
$LN3@Send:

; 852  : 
; 853  : 	if (broadcast==false && router && GetIndexFromPlayerID(playerId)==-1)

	movzx	eax, BYTE PTR _broadcast$[ebp]
	test	eax, eax
	jne	$LN2@Send
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2086], 0
	je	SHORT $LN2@Send
	mov	esi, esp
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+92]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, -1
	jne	SHORT $LN2@Send

; 854  : 	{
; 855  : 		return router->Send(data, BYTES_TO_BITS(length), priority, reliability, orderingChannel, playerId);

	mov	esi, esp
	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [eax+4], dx
	movzx	eax, BYTE PTR _orderingChannel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _reliability$[ebp]
	push	ecx
	mov	edx, DWORD PTR _priority$[ebp]
	push	edx
	mov	eax, DWORD PTR _length$[ebp]
	shl	eax, 3
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2086]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+2086]
	mov	eax, DWORD PTR [edx]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN8@Send

; 856  : 	}
; 857  : 	else

	jmp	SHORT $LN1@Send
$LN2@Send:

; 858  : 	{
; 859  : 		SendBuffered(data, length*8, priority, reliability, orderingChannel, playerId, broadcast, RemoteSystemStruct::NO_ACTION);

	push	0
	movzx	eax, BYTE PTR _broadcast$[ebp]
	push	eax
	sub	esp, 8
	mov	ecx, esp
	mov	edx, DWORD PTR _playerId$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	ax, WORD PTR _playerId$[ebp+4]
	mov	WORD PTR [ecx+4], ax
	movzx	ecx, BYTE PTR _orderingChannel$[ebp]
	push	ecx
	mov	edx, DWORD PTR _reliability$[ebp]
	push	edx
	mov	eax, DWORD PTR _priority$[ebp]
	push	eax
	mov	ecx, DWORD PTR _length$[ebp]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendBuffered@RakPeer@@IAEXPBDHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_NW4ConnectMode@RemoteSystemStruct@1@@Z ; RakPeer::SendBuffered
$LN1@Send:

; 860  : 	}
; 861  : 
; 862  : 	return true;

	mov	al, 1
$LN8@Send:

; 863  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?Send@RakPeer@@UAE_NPBDHW4PacketPriority@@W4PacketReliability@@DUPlayerID@@_N@Z ENDP ; RakPeer::Send
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?GetConnectionList@RakPeer@@UBE_NPAUPlayerID@@PAG@Z
_TEXT	SEGMENT
_index$ = -32						; size = 4
_count$ = -20						; size = 4
_this$ = -8						; size = 4
_remoteSystems$ = 8					; size = 4
_numberOfSystems$ = 12					; size = 4
?GetConnectionList@RakPeer@@UBE_NPAUPlayerID@@PAG@Z PROC ; RakPeer::GetConnectionList, COMDAT
; _this$ = ecx

; 782  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 783  : 	int count, index;
; 784  : 	count=0;

	mov	DWORD PTR _count$[ebp], 0

; 785  : 
; 786  : 	if ( remoteSystemList == 0 || endThreads == true )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+820], 0
	je	SHORT $LN12@GetConnect
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	cmp	ecx, 1
	jne	SHORT $LN13@GetConnect
$LN12@GetConnect:

; 787  : 	{
; 788  : 		*numberOfSystems = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _numberOfSystems$[ebp]
	mov	WORD PTR [ecx], ax

; 789  : 		return false;

	xor	al, al
	jmp	$LN14@GetConnect
$LN13@GetConnect:

; 790  : 	}
; 791  : 
; 792  : 	// This is called a lot so I unrolled the loop
; 793  : 	if ( remoteSystems )

	cmp	DWORD PTR _remoteSystems$[ebp], 0
	je	$LN11@GetConnect

; 794  : 	{
; 795  : 		// remoteSystemList in user thread
; 796  : 		//for ( count = 0, index = 0; index < remoteSystemListSize; ++index )
; 797  : 		for ( count = 0, index = 0; index < maximumNumberOfPeers; ++index )

	mov	DWORD PTR _count$[ebp], 0
	mov	DWORD PTR _index$[ebp], 0
	jmp	SHORT $LN10@GetConnect
$LN9@GetConnect:
	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 1
	mov	DWORD PTR _index$[ebp], eax
$LN10@GetConnect:
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+7]
	cmp	DWORD PTR _index$[ebp], ecx
	jge	SHORT $LN8@GetConnect

; 798  : 			if ( remoteSystemList[ index ].isActive && remoteSystemList[ index ].connectMode==RemoteSystemStruct::CONNECTED)

	imul	eax, DWORD PTR _index$[ebp], 2058
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	movzx	eax, BYTE PTR [edx+eax]
	test	eax, eax
	je	SHORT $LN7@GetConnect
	imul	eax, DWORD PTR _index$[ebp], 2058
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	cmp	DWORD PTR [edx+eax+2054], 8
	jne	SHORT $LN7@GetConnect

; 799  : 			{
; 800  : 				if ( count < *numberOfSystems )

	mov	eax, DWORD PTR _numberOfSystems$[ebp]
	movzx	ecx, WORD PTR [eax]
	cmp	DWORD PTR _count$[ebp], ecx
	jge	SHORT $LN6@GetConnect

; 801  : 					remoteSystems[ count ] = remoteSystemList[ index ].playerId;

	imul	eax, DWORD PTR _index$[ebp], 2058
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	lea	eax, DWORD PTR [edx+eax+1]
	push	eax
	imul	ecx, DWORD PTR _count$[ebp], 6
	add	ecx, DWORD PTR _remoteSystems$[ebp]
	call	??4PlayerID@@QAEAAU0@ABU0@@Z		; PlayerID::operator=
$LN6@GetConnect:

; 802  : 
; 803  : 				++count;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax
$LN7@GetConnect:

; 804  : 			}
; 805  : 	}

	jmp	SHORT $LN9@GetConnect
$LN8@GetConnect:

; 806  : 	else

	jmp	SHORT $LN5@GetConnect
$LN11@GetConnect:

; 807  : 	{
; 808  : 		// remoteSystemList in user thread
; 809  : 		//for ( count = 0, index = 0; index < remoteSystemListSize; ++index )
; 810  : 		for ( count = 0, index = 0; index < maximumNumberOfPeers; ++index )

	mov	DWORD PTR _count$[ebp], 0
	mov	DWORD PTR _index$[ebp], 0
	jmp	SHORT $LN4@GetConnect
$LN3@GetConnect:
	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 1
	mov	DWORD PTR _index$[ebp], eax
$LN4@GetConnect:
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+7]
	cmp	DWORD PTR _index$[ebp], ecx
	jge	SHORT $LN5@GetConnect

; 811  : 			if ( remoteSystemList[ index ].isActive && remoteSystemList[ index ].connectMode==RemoteSystemStruct::CONNECTED)

	imul	eax, DWORD PTR _index$[ebp], 2058
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	movzx	eax, BYTE PTR [edx+eax]
	test	eax, eax
	je	SHORT $LN1@GetConnect
	imul	eax, DWORD PTR _index$[ebp], 2058
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	cmp	DWORD PTR [edx+eax+2054], 8
	jne	SHORT $LN1@GetConnect

; 812  : 				++count;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax
$LN1@GetConnect:

; 813  : 	}

	jmp	SHORT $LN3@GetConnect
$LN5@GetConnect:

; 814  : 
; 815  : 	*numberOfSystems = ( unsigned short ) count;

	mov	eax, DWORD PTR _numberOfSystems$[ebp]
	mov	cx, WORD PTR _count$[ebp]
	mov	WORD PTR [eax], cx

; 816  : 
; 817  : 	return 0;

	xor	al, al
$LN14@GetConnect:

; 818  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?GetConnectionList@RakPeer@@UBE_NPAUPlayerID@@PAG@Z ENDP ; RakPeer::GetConnectionList
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?IsActive@RakPeer@@UBE_NXZ
_TEXT	SEGMENT
tv68 = -208						; size = 4
_this$ = -8						; size = 4
?IsActive@RakPeer@@UBE_NXZ PROC				; RakPeer::IsActive, COMDAT
; _this$ = ecx

; 768  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 769  : 	return endThreads == false;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN3@IsActive
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@IsActive
$LN3@IsActive:
	mov	DWORD PTR tv68[ebp], 0
$LN4@IsActive:
	mov	al, BYTE PTR tv68[ebp]

; 770  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsActive@RakPeer@@UBE_NXZ ENDP				; RakPeer::IsActive
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?Disconnect@RakPeer@@UAEXIE@Z
_TEXT	SEGMENT
tv224 = -328						; size = 4
tv136 = -328						; size = 4
$T1 = -320						; size = 4
$T2 = -308						; size = 4
_temp$ = -104						; size = 4
_packet$ = -92						; size = 4
_systemListSize$ = -80					; size = 2
_time$ = -68						; size = 4
_startWaitingTime$ = -56				; size = 4
_anyActive$ = -41					; size = 1
_j$ = -32						; size = 4
_i$ = -20						; size = 4
_this$ = -8						; size = 4
_blockDuration$ = 8					; size = 4
_orderingChannel$ = 12					; size = 1
?Disconnect@RakPeer@@UAEXIE@Z PROC			; RakPeer::Disconnect, COMDAT
; _this$ = ecx

; 627  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 328				; 00000148H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-328]
	mov	ecx, 82					; 00000052H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 	unsigned i,j;
; 629  : 	bool anyActive;
; 630  : 	RakNetTime startWaitingTime;
; 631  : //	PlayerID playerId;
; 632  : 	RakNetTime time;
; 633  : 	//unsigned short systemListSize = remoteSystemListSize; // This is done for threading reasons
; 634  : 	unsigned short systemListSize = maximumNumberOfPeers;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+7]
	mov	WORD PTR _systemListSize$[ebp], cx

; 635  : 
; 636  : 	if ( blockDuration > 0 )

	cmp	DWORD PTR _blockDuration$[ebp], 0
	jbe	$LN26@Disconnect

; 637  : 	{
; 638  : 		for ( i = 0; i < systemListSize; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN25@Disconnect
$LN24@Disconnect:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN25@Disconnect:
	movzx	eax, WORD PTR _systemListSize$[ebp]
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN23@Disconnect

; 639  : 		{
; 640  : 			// remoteSystemList in user thread
; 641  : 			NotifyAndFlagForDisconnect(remoteSystemList[i].playerId, false, orderingChannel);

	movzx	eax, BYTE PTR _orderingChannel$[ebp]
	push	eax
	push	0
	imul	ecx, DWORD PTR _i$[ebp], 2058
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+820]
	lea	ecx, DWORD PTR [eax+ecx+1]
	sub	esp, 8
	mov	edx, esp
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	cx, WORD PTR [ecx+4]
	mov	WORD PTR [edx+4], cx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NotifyAndFlagForDisconnect@RakPeer@@IAEXUPlayerID@@_NE@Z ; RakPeer::NotifyAndFlagForDisconnect

; 642  : 		}

	jmp	SHORT $LN24@Disconnect
$LN23@Disconnect:

; 643  : 
; 644  : 		time = RakNet::GetTime();

	call	?GetTime@RakNet@@YAIXZ			; RakNet::GetTime
	mov	DWORD PTR _time$[ebp], eax

; 645  : 		startWaitingTime = time;

	mov	eax, DWORD PTR _time$[ebp]
	mov	DWORD PTR _startWaitingTime$[ebp], eax
$LN22@Disconnect:

; 646  : 		while ( time - startWaitingTime < blockDuration )

	mov	eax, DWORD PTR _time$[ebp]
	sub	eax, DWORD PTR _startWaitingTime$[ebp]
	cmp	eax, DWORD PTR _blockDuration$[ebp]
	jae	SHORT $LN26@Disconnect

; 647  : 		{
; 648  : 			anyActive=false;

	mov	BYTE PTR _anyActive$[ebp], 0

; 649  : 			for (j=0; j < systemListSize; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN20@Disconnect
$LN19@Disconnect:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN20@Disconnect:
	movzx	eax, WORD PTR _systemListSize$[ebp]
	cmp	DWORD PTR _j$[ebp], eax
	jae	SHORT $LN18@Disconnect

; 650  : 			{
; 651  : 				// remoteSystemList in user thread
; 652  : 				if (remoteSystemList[j].isActive)

	imul	eax, DWORD PTR _j$[ebp], 2058
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	movzx	eax, BYTE PTR [edx+eax]
	test	eax, eax
	je	SHORT $LN17@Disconnect

; 653  : 				{
; 654  : 					anyActive=true;

	mov	BYTE PTR _anyActive$[ebp], 1

; 655  : 					break;

	jmp	SHORT $LN18@Disconnect
$LN17@Disconnect:

; 656  : 				}
; 657  : 			}

	jmp	SHORT $LN19@Disconnect
$LN18@Disconnect:

; 658  : 
; 659  : 			// If this system is out of packets to send, then stop waiting
; 660  : 			if ( anyActive==false )

	movzx	eax, BYTE PTR _anyActive$[ebp]
	test	eax, eax
	jne	SHORT $LN16@Disconnect

; 661  : 				break;

	jmp	SHORT $LN26@Disconnect
$LN16@Disconnect:

; 662  : 
; 663  : 			// This will probably cause the update thread to run which will probably
; 664  : 			// send the disconnection notification
; 665  : 
; 666  : 			RakSleep(15);

	push	15					; 0000000fH
	call	?RakSleep@@YAXI@Z			; RakSleep
	add	esp, 4

; 667  : 			time = RakNet::GetTime();

	call	?GetTime@RakNet@@YAIXZ			; RakNet::GetTime
	mov	DWORD PTR _time$[ebp], eax

; 668  : 		}

	jmp	SHORT $LN22@Disconnect
$LN26@Disconnect:

; 669  : 	}
; 670  : 
; 671  : 	for (i=0; i < messageHandlerList.Size(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN15@Disconnect
$LN14@Disconnect:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN15@Disconnect:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 941				; 000003adH
	call	?Size@?$List@PAVPluginInterface@@@DataStructures@@QBEIXZ ; DataStructures::List<PluginInterface *>::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN13@Disconnect

; 672  : 	{
; 673  : 		messageHandlerList[i]->OnDisconnect(this);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 941				; 000003adH
	call	??A?$List@PAVPluginInterface@@@DataStructures@@QBEAAPAVPluginInterface@@I@Z ; DataStructures::List<PluginInterface *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv136[ebp], ecx
	mov	esi, esp
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR tv136[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv136[ebp]
	mov	eax, DWORD PTR [edx+20]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 674  : 	}

	jmp	SHORT $LN14@Disconnect
$LN13@Disconnect:

; 675  : 
; 676  : 	if ( endThreads == false )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN11@Disconnect

; 677  : 	{
; 678  : 		// Stop the threads
; 679  : 		endThreads = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+4], 1
$LN11@Disconnect:

; 680  : 
; 681  : 		// Normally the thread will call DecreaseUserCount on termination but if we aren't using threads just do it
; 682  : 		// manually
; 683  : #ifdef __USE_IO_COMPLETION_PORTS
; 684  : 		AsynchronousFileIO::Instance()->DecreaseUserCount();
; 685  : #endif
; 686  : 	}
; 687  : 
; 688  : 	while ( isMainLoopThreadActive )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+5]
	test	ecx, ecx
	je	SHORT $LN10@Disconnect

; 689  : 		RakSleep(15);

	push	15					; 0000000fH
	call	?RakSleep@@YAXI@Z			; RakSleep
	add	esp, 4
	jmp	SHORT $LN11@Disconnect
$LN10@Disconnect:

; 690  : 
; 691  : 	// remoteSystemList in Single thread
; 692  : 	for ( i = 0; i < systemListSize; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN9@Disconnect
$LN8@Disconnect:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN9@Disconnect:
	movzx	eax, WORD PTR _systemListSize$[ebp]
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN7@Disconnect

; 693  : 	{
; 694  : 		// Reserve this reliability layer for ourselves
; 695  : 		remoteSystemList[ i ].isActive = false;

	imul	eax, DWORD PTR _i$[ebp], 2058
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	mov	BYTE PTR [edx+eax], 0

; 696  : 
; 697  : 		// Remove any remaining packets
; 698  : 		remoteSystemList[ i ].reliabilityLayer.Reset(false);

	push	0
	imul	eax, DWORD PTR _i$[ebp], 2058
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	lea	ecx, DWORD PTR [edx+eax+13]
	call	?Reset@ReliabilityLayer@@QAEX_N@Z	; ReliabilityLayer::Reset

; 699  : 	}

	jmp	SHORT $LN8@Disconnect
$LN7@Disconnect:

; 700  : 
; 701  : 	// Clear the lookup table.  Safe to call from the user thread since the network thread is now stopped
; 702  : 	remoteSystemLookup.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 824				; 00000338H
	call	?Clear@?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QAEXXZ ; DataStructures::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>::Clear

; 703  : 
; 704  : 	// Setting maximumNumberOfPeers to 0 allows remoteSystemList to be reallocated in Initialize.
; 705  : 	// Setting remoteSystemListSize prevents threads from accessing the reliability layer
; 706  : 	maximumNumberOfPeers = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+7], ax

; 707  : 	//remoteSystemListSize = 0;
; 708  : 
; 709  : 	// Free any packets the user didn't deallocate
; 710  : 	Packet **packet;
; 711  : #ifdef _RAKNET_THREADSAFE
; 712  : 	rakPeerMutexes[transferToPacketQueue_Mutex].Lock();
; 713  : #endif
; 714  : 	packet=packetSingleProducerConsumer.ReadLock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2498				; 000009c2H
	call	?ReadLock@?$SingleProducerConsumer@PAUPacket@@@DataStructures@@QAEPAPAUPacket@@XZ ; DataStructures::SingleProducerConsumer<Packet *>::ReadLock
	mov	DWORD PTR _packet$[ebp], eax
$LN6@Disconnect:

; 715  : 	while (packet)

	cmp	DWORD PTR _packet$[ebp], 0
	je	SHORT $LN5@Disconnect

; 716  : 	{
; 717  : 		DeallocatePacket(*packet);

	mov	esi, esp
	mov	eax, DWORD PTR _packet$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+60]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp

; 718  : 		packetSingleProducerConsumer.ReadUnlock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2498				; 000009c2H
	call	?ReadUnlock@?$SingleProducerConsumer@PAUPacket@@@DataStructures@@QAEXXZ ; DataStructures::SingleProducerConsumer<Packet *>::ReadUnlock

; 719  : 		packet=packetSingleProducerConsumer.ReadLock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2498				; 000009c2H
	call	?ReadLock@?$SingleProducerConsumer@PAUPacket@@@DataStructures@@QAEPAPAUPacket@@XZ ; DataStructures::SingleProducerConsumer<Packet *>::ReadLock
	mov	DWORD PTR _packet$[ebp], eax

; 720  : 	}

	jmp	SHORT $LN6@Disconnect
$LN5@Disconnect:

; 721  : 	packetSingleProducerConsumer.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2498				; 000009c2H
	call	?Clear@?$SingleProducerConsumer@PAUPacket@@@DataStructures@@QAEXXZ ; DataStructures::SingleProducerConsumer<Packet *>::Clear

; 722  : #ifdef _RAKNET_THREADSAFE
; 723  : 	rakPeerMutexes[transferToPacketQueue_Mutex].Unlock();
; 724  : #endif
; 725  : 
; 726  : #ifdef _RAKNET_THREADSAFE
; 727  : 	rakPeerMutexes[packetPool_Mutex].Lock();
; 728  : #endif
; 729  : 	for (i=0; i < packetPool.Size(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@Disconnect
$LN3@Disconnect:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@Disconnect:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2522				; 000009daH
	call	?Size@?$Queue@PAUPacket@@@DataStructures@@QBEIXZ ; DataStructures::Queue<Packet *>::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN2@Disconnect

; 730  : 		DeallocatePacket(packetPool[i]);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2522				; 000009daH
	call	??A?$Queue@PAUPacket@@@DataStructures@@QBEAAPAUPacket@@I@Z ; DataStructures::Queue<Packet *>::operator[]
	mov	esi, esp
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+60]
	call	edx
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN3@Disconnect
$LN2@Disconnect:

; 731  : 	packetPool.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2522				; 000009daH
	call	?Clear@?$Queue@PAUPacket@@@DataStructures@@QAEXXZ ; DataStructures::Queue<Packet *>::Clear

; 732  : #ifdef _RAKNET_THREADSAFE
; 733  : 	rakPeerMutexes[packetPool_Mutex].Unlock();
; 734  : #endif
; 735  : 
; 736  : 	blockOnRPCReply=false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+2085], 0

; 737  : 
; 738  : 	if ( connectionSocket != INVALID_SOCKET )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2070], -1
	je	SHORT $LN1@Disconnect

; 739  : 	{
; 740  : 		closesocket( connectionSocket );

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2070]
	push	ecx
	call	DWORD PTR __imp__closesocket@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 741  : 		connectionSocket = INVALID_SOCKET;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2070], -1
$LN1@Disconnect:

; 742  : 	}
; 743  : 
; 744  : 	ClearBufferedCommands();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearBufferedCommands@RakPeer@@IAEXXZ	; RakPeer::ClearBufferedCommands

; 745  : 	bytesSentPerSecond = bytesReceivedPerSecond = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+865], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+861], 0

; 746  : 
; 747  : 	ClearRequestedConnectionList();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearRequestedConnectionList@RakPeer@@IAEXXZ ; RakPeer::ClearRequestedConnectionList

; 748  : 
; 749  : #if defined (_WIN32) && defined(USE_WAIT_FOR_MULTIPLE_EVENTS)
; 750  : 	if (recvEvent!=INVALID_HANDLE_VALUE)
; 751  : 	{
; 752  : 		CloseHandle( recvEvent );
; 753  : 		recvEvent = INVALID_HANDLE_VALUE;
; 754  : 	}	
; 755  : #endif
; 756  : 
; 757  : 	// Clear out the reliability layer list in case we want to reallocate it in a successive call to Init.
; 758  : 	RemoteSystemStruct * temp = remoteSystemList;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	mov	DWORD PTR _temp$[ebp], ecx

; 759  : 	remoteSystemList = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+820], 0

; 760  : 	delete [] temp;

	mov	eax, DWORD PTR _temp$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN29@Disconnect
	push	3
	mov	ecx, DWORD PTR $T1[ebp]
	call	??_ERemoteSystemStruct@RakPeer@@QAEPAXI@Z
	mov	DWORD PTR tv224[ebp], eax
	jmp	SHORT $LN27@Disconnect
$LN29@Disconnect:
	mov	DWORD PTR tv224[ebp], 0
$LN27@Disconnect:

; 761  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 328				; 00000148H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?Disconnect@RakPeer@@UAEXIE@Z ENDP			; RakPeer::Disconnect
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?Connect@RakPeer@@UAE_NPBDGPADH@Z
_TEXT	SEGMENT
_numberOfFreeSlots$ = -20				; size = 4
_this$ = -8						; size = 4
_host$ = 8						; size = 4
_remotePort$ = 12					; size = 2
_passwordData$ = 16					; size = 4
_passwordDataLength$ = 20				; size = 4
?Connect@RakPeer@@UAE_NPBDGPADH@Z PROC			; RakPeer::Connect, COMDAT
; _this$ = ecx

; 580  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 581  : 	// If endThreads is true here you didn't call Initialize() first.
; 582  : 	if ( host == 0 || endThreads || connectionSocket == INVALID_SOCKET )

	cmp	DWORD PTR _host$[ebp], 0
	je	SHORT $LN8@Connect
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN8@Connect
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2070], -1
	jne	SHORT $LN9@Connect
$LN8@Connect:

; 583  : 		return false;

	xor	al, al
	jmp	$LN10@Connect
$LN9@Connect:

; 584  : 
; 585  : 	unsigned numberOfFreeSlots;
; 586  : 
; 587  : 	numberOfFreeSlots = 0;

	mov	DWORD PTR _numberOfFreeSlots$[ebp], 0

; 588  : 
; 589  : 	//if (passwordDataLength>MAX_OFFLINE_DATA_LENGTH)
; 590  : 	//	passwordDataLength=MAX_OFFLINE_DATA_LENGTH;
; 591  : 	if (passwordDataLength>255)

	cmp	DWORD PTR _passwordDataLength$[ebp], 255 ; 000000ffH
	jle	SHORT $LN7@Connect

; 592  : 		passwordDataLength=255;

	mov	DWORD PTR _passwordDataLength$[ebp], 255 ; 000000ffH
$LN7@Connect:

; 593  : 
; 594  : 	if (passwordData==0)

	cmp	DWORD PTR _passwordData$[ebp], 0
	jne	SHORT $LN6@Connect

; 595  : 		passwordDataLength=0;

	mov	DWORD PTR _passwordDataLength$[ebp], 0
$LN6@Connect:

; 596  : 
; 597  : 	// Not threadsafe but it's not important enough to lock.  Who is going to change the password a lot during runtime?
; 598  : 	// It won't overflow at least because outgoingPasswordLength is an unsigned char
; 599  : //	if (passwordDataLength>0)
; 600  : //		memcpy(outgoingPassword, passwordData, passwordDataLength);
; 601  : //	outgoingPasswordLength=(unsigned char) passwordDataLength;
; 602  : 
; 603  : 	// If the host starts with something other than 0, 1, or 2 it's (probably) a domain name.
; 604  : 	if ( host[ 0 ] < '0' || host[ 0 ] > '2' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _host$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN4@Connect
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _host$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 50					; 00000032H
	jle	SHORT $LN5@Connect
$LN4@Connect:

; 605  : 	{
; 606  : #if !defined(_COMPATIBILITY_1)
; 607  : 		host = ( char* ) SocketLayer::Instance()->DomainNameToIP( host );

	mov	eax, DWORD PTR _host$[ebp]
	push	eax
	call	?Instance@SocketLayer@@SAPAV1@XZ	; SocketLayer::Instance
	mov	ecx, eax
	call	?DomainNameToIP@SocketLayer@@QAEPBDPBD@Z ; SocketLayer::DomainNameToIP
	mov	DWORD PTR _host$[ebp], eax

; 608  : #else
; 609  : 		return false;
; 610  : #endif
; 611  : 		if (host==0)

	cmp	DWORD PTR _host$[ebp], 0
	jne	SHORT $LN5@Connect

; 612  : 			return false;

	xor	al, al
	jmp	SHORT $LN10@Connect
$LN5@Connect:

; 613  : 	}
; 614  : 
; 615  : 	// Connecting to ourselves in the same instance of the program?
; 616  : 	if ( ( strcmp( host, "127.0.0.1" ) == 0 || strcmp( host, "0.0.0.0" ) == 0 ) && remotePort == myPlayerId.port )

	push	OFFSET ??_C@_09PFCHIMEP@127?40?40?41?$AA@
	mov	eax, DWORD PTR _host$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@Connect
	push	OFFSET ??_C@_07OHKHACFK@0?40?40?40?$AA@
	mov	eax, DWORD PTR _host$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@Connect
$LN1@Connect:
	movzx	eax, WORD PTR _remotePort$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+561]
	cmp	eax, edx
	jne	SHORT $LN2@Connect

; 617  : 		return false;

	xor	al, al
	jmp	SHORT $LN10@Connect
$LN2@Connect:

; 618  : 
; 619  : 	return SendConnectionRequest( host, remotePort, passwordData, passwordDataLength );

	mov	eax, DWORD PTR _passwordDataLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _passwordData$[ebp]
	push	ecx
	movzx	edx, WORD PTR _remotePort$[ebp]
	push	edx
	mov	eax, DWORD PTR _host$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendConnectionRequest@RakPeer@@IAE_NPBDGPADH@Z ; RakPeer::SendConnectionRequest
$LN10@Connect:

; 620  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Connect@RakPeer@@UAE_NPBDGPADH@Z ENDP			; RakPeer::Connect
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?GetIncomingPassword@RakPeer@@UAEXPADPAH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_passwordData$ = 8					; size = 4
_passwordDataLength$ = 12				; size = 4
?GetIncomingPassword@RakPeer@@UAEXPADPAH@Z PROC		; RakPeer::GetIncomingPassword, COMDAT
; _this$ = ecx

; 547  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 548  : 	if (passwordData==0)

	cmp	DWORD PTR _passwordData$[ebp], 0
	jne	SHORT $LN3@GetIncomin

; 549  : 	{
; 550  : 		*passwordDataLength=incomingPasswordLength;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+819]
	mov	edx, DWORD PTR _passwordDataLength$[ebp]
	mov	DWORD PTR [edx], ecx

; 551  : 		return;

	jmp	SHORT $LN4@GetIncomin
$LN3@GetIncomin:

; 552  : 	}
; 553  : 
; 554  : 	if (*passwordDataLength > incomingPasswordLength)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+819]
	mov	edx, DWORD PTR _passwordDataLength$[ebp]
	cmp	DWORD PTR [edx], ecx
	jle	SHORT $LN2@GetIncomin

; 555  : 		*passwordDataLength=incomingPasswordLength;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+819]
	mov	edx, DWORD PTR _passwordDataLength$[ebp]
	mov	DWORD PTR [edx], ecx
$LN2@GetIncomin:

; 556  : 
; 557  : 	if (*passwordDataLength>0)

	mov	eax, DWORD PTR _passwordDataLength$[ebp]
	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN4@GetIncomin

; 558  : 		memcpy(passwordData, incomingPassword, *passwordDataLength);

	mov	eax, DWORD PTR _passwordDataLength$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 563				; 00000233H
	push	edx
	mov	eax, DWORD PTR _passwordData$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN4@GetIncomin:

; 559  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?GetIncomingPassword@RakPeer@@UAEXPADPAH@Z ENDP		; RakPeer::GetIncomingPassword
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?SetIncomingPassword@RakPeer@@UAEXPBDH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_passwordData$ = 8					; size = 4
_passwordDataLength$ = 12				; size = 4
?SetIncomingPassword@RakPeer@@UAEXPBDH@Z PROC		; RakPeer::SetIncomingPassword, COMDAT
; _this$ = ecx

; 528  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 529  : 	//if (passwordDataLength > MAX_OFFLINE_DATA_LENGTH)
; 530  : 	//	passwordDataLength=MAX_OFFLINE_DATA_LENGTH;
; 531  : 
; 532  : 	if (passwordDataLength > 255)

	cmp	DWORD PTR _passwordDataLength$[ebp], 255 ; 000000ffH
	jle	SHORT $LN3@SetIncomin

; 533  : 		passwordDataLength=255;

	mov	DWORD PTR _passwordDataLength$[ebp], 255 ; 000000ffH
$LN3@SetIncomin:

; 534  : 
; 535  : 	if (passwordData==0)

	cmp	DWORD PTR _passwordData$[ebp], 0
	jne	SHORT $LN2@SetIncomin

; 536  : 		passwordDataLength=0;

	mov	DWORD PTR _passwordDataLength$[ebp], 0
$LN2@SetIncomin:

; 537  : 
; 538  : 	// Not threadsafe but it's not important enough to lock.  Who is going to change the password a lot during runtime?
; 539  : 	// It won't overflow at least because incomingPasswordLength is an unsigned char
; 540  : 	if (passwordDataLength>0)

	cmp	DWORD PTR _passwordDataLength$[ebp], 0
	jle	SHORT $LN1@SetIncomin

; 541  : 		memcpy(incomingPassword, passwordData, passwordDataLength);

	mov	eax, DWORD PTR _passwordDataLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _passwordData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 563				; 00000233H
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN1@SetIncomin:

; 542  : 	incomingPasswordLength=(unsigned char)passwordDataLength;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _passwordDataLength$[ebp]
	mov	BYTE PTR [eax+819], cl

; 543  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?SetIncomingPassword@RakPeer@@UAEXPBDH@Z ENDP		; RakPeer::SetIncomingPassword
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?GetMaximumIncomingConnections@RakPeer@@UBEGXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetMaximumIncomingConnections@RakPeer@@UBEGXZ PROC	; RakPeer::GetMaximumIncomingConnections, COMDAT
; _this$ = ecx

; 513  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 514  : 	return maximumIncomingConnections;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+9]

; 515  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMaximumIncomingConnections@RakPeer@@UBEGXZ ENDP	; RakPeer::GetMaximumIncomingConnections
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?SetMaximumIncomingConnections@RakPeer@@UAEXG@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_numberAllowed$ = 8					; size = 2
?SetMaximumIncomingConnections@RakPeer@@UAEXG@Z PROC	; RakPeer::SetMaximumIncomingConnections, COMDAT
; _this$ = ecx

; 504  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 505  : 	maximumIncomingConnections = numberAllowed;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _numberAllowed$[ebp]
	mov	WORD PTR [eax+9], cx

; 506  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetMaximumIncomingConnections@RakPeer@@UAEXG@Z ENDP	; RakPeer::SetMaximumIncomingConnections
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?DisableSecurity@RakPeer@@UAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?DisableSecurity@RakPeer@@UAEXXZ PROC			; RakPeer::DisableSecurity, COMDAT
; _this$ = ecx

; 485  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 486  : #if !defined(_COMPATIBILITY_1)
; 487  : 	if ( endThreads == false )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN1@DisableSec

; 488  : 		return ;

	jmp	SHORT $LN2@DisableSec
$LN1@DisableSec:

; 489  : 
; 490  : 	usingSecurity = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+2444], 0
$LN2@DisableSec:

; 491  : #endif
; 492  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DisableSecurity@RakPeer@@UAEXXZ ENDP			; RakPeer::DisableSecurity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?InitializeSecurity@RakPeer@@UAEXPBD000@Z
_TEXT	SEGMENT
_q$1 = -60						; size = 16
_p$2 = -36						; size = 16
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_pubKeyE$ = 8						; size = 4
_pubKeyN$ = 12						; size = 4
_privKeyP$ = 16						; size = 4
_privKeyQ$ = 20						; size = 4
?InitializeSecurity@RakPeer@@UAEXPBD000@Z PROC		; RakPeer::InitializeSecurity, COMDAT
; _this$ = ecx

; 425  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 426  : #if !defined(_COMPATIBILITY_1)
; 427  : 	if ( endThreads == false )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN10@Initialize

; 428  : 		return ;

	jmp	$LN11@Initialize
$LN10@Initialize:

; 429  : 
; 430  : 	// Setting the client key is e,n,
; 431  : 	// Setting the server key is p,q
; 432  : 	if ( //( privKeyP && privKeyQ && ( pubKeyE || pubKeyN ) ) ||
; 433  : 		//( pubKeyE && pubKeyN && ( privKeyP || privKeyQ ) ) ||
; 434  : 		( privKeyP && privKeyQ == 0 ) ||
; 435  : 		( privKeyQ && privKeyP == 0 ) ||
; 436  : 		( pubKeyE && pubKeyN == 0 ) ||
; 437  : 		( pubKeyN && pubKeyE == 0 ) )

	cmp	DWORD PTR _privKeyP$[ebp], 0
	je	SHORT $LN7@Initialize
	cmp	DWORD PTR _privKeyQ$[ebp], 0
	je	SHORT $LN8@Initialize
$LN7@Initialize:
	cmp	DWORD PTR _privKeyQ$[ebp], 0
	je	SHORT $LN6@Initialize
	cmp	DWORD PTR _privKeyP$[ebp], 0
	je	SHORT $LN8@Initialize
$LN6@Initialize:
	cmp	DWORD PTR _pubKeyE$[ebp], 0
	je	SHORT $LN5@Initialize
	cmp	DWORD PTR _pubKeyN$[ebp], 0
	je	SHORT $LN8@Initialize
$LN5@Initialize:
	cmp	DWORD PTR _pubKeyN$[ebp], 0
	je	SHORT $LN9@Initialize
	cmp	DWORD PTR _pubKeyE$[ebp], 0
	jne	SHORT $LN9@Initialize
$LN8@Initialize:

; 438  : 	{
; 439  : 		// Invalid parameters
; 440  : 		assert( 0 );

	xor	eax, eax
	jne	SHORT $LN9@Initialize
	mov	ecx, DWORD PTR ?__LINE__Var@?1??InitializeSecurity@RakPeer@@UAEXPBD000@Z@4JA
	add	ecx, 15					; 0000000fH
	push	ecx
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_13COJANIEC@?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN9@Initialize:

; 441  : 	}
; 442  : 
; 443  : 	seedMT( (unsigned int) RakNet::GetTime() );

	call	?GetTime@RakNet@@YAIXZ			; RakNet::GetTime
	push	eax
	call	?seedMT@@YAXI@Z				; seedMT
	add	esp, 4

; 444  : 
; 445  : 	GenerateSYNCookieRandomNumber();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GenerateSYNCookieRandomNumber@RakPeer@@IAEXXZ ; RakPeer::GenerateSYNCookieRandomNumber

; 446  : 
; 447  : 	usingSecurity = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+2444], 1

; 448  : 
; 449  : 	if ( privKeyP == 0 && privKeyQ == 0 && pubKeyE == 0 && pubKeyN == 0 )

	cmp	DWORD PTR _privKeyP$[ebp], 0
	jne	SHORT $LN4@Initialize
	cmp	DWORD PTR _privKeyQ$[ebp], 0
	jne	SHORT $LN4@Initialize
	cmp	DWORD PTR _pubKeyE$[ebp], 0
	jne	SHORT $LN4@Initialize
	cmp	DWORD PTR _pubKeyN$[ebp], 0
	jne	SHORT $LN4@Initialize

; 450  : 	{
; 451  : 		keysLocallyGenerated = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+2443], 1

; 452  : 		rsacrypt.generateKeys();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2102				; 00000836H
	call	?generateKeys@?$RSACrypt@$$BY07I@big@@QAEXXZ ; big::RSACrypt<unsigned int [8]>::generateKeys

; 453  : 	}
; 454  : 
; 455  : 	else

	jmp	$LN11@Initialize
$LN4@Initialize:

; 456  : 	{
; 457  : 		if ( pubKeyE && pubKeyN )

	cmp	DWORD PTR _pubKeyE$[ebp], 0
	je	SHORT $LN2@Initialize
	cmp	DWORD PTR _pubKeyN$[ebp], 0
	je	SHORT $LN2@Initialize

; 458  : 		{
; 459  : 			// Save public keys
; 460  : 			memcpy( ( char* ) & publicKeyE, pubKeyE, sizeof( publicKeyE ) );

	push	4
	mov	eax, DWORD PTR _pubKeyE$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2407				; 00000967H
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 461  : 			memcpy( publicKeyN, pubKeyN, sizeof( publicKeyN ) );

	push	32					; 00000020H
	mov	eax, DWORD PTR _pubKeyN$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2411				; 0000096bH
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN2@Initialize:

; 462  : 		}
; 463  : 
; 464  : 		if ( privKeyP && privKeyQ )

	cmp	DWORD PTR _privKeyP$[ebp], 0
	je	SHORT $LN1@Initialize
	cmp	DWORD PTR _privKeyQ$[ebp], 0
	je	SHORT $LN1@Initialize

; 465  : 		{
; 466  : 			BIGHALFSIZE( RSA_BIT_SIZE, p );
; 467  : 			BIGHALFSIZE( RSA_BIT_SIZE, q );
; 468  : 			memcpy( p, privKeyP, sizeof( p ) );

	push	16					; 00000010H
	mov	eax, DWORD PTR _privKeyP$[ebp]
	push	eax
	lea	ecx, DWORD PTR _p$2[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 469  : 			memcpy( q, privKeyQ, sizeof( q ) );

	push	16					; 00000010H
	mov	eax, DWORD PTR _privKeyQ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _q$1[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 470  : 			// Save private keys
; 471  : 			rsacrypt.setPrivateKey( p, q );

	lea	eax, DWORD PTR _q$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _p$2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2102				; 00000836H
	call	??$setPrivateKey@$$BY03I@?$RSACrypt@$$BY07I@big@@QAEXAAY03I0@Z ; big::RSACrypt<unsigned int [8]>::setPrivateKey<unsigned int [4]>
$LN1@Initialize:

; 472  : 		}
; 473  : 
; 474  : 		keysLocallyGenerated = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+2443], 0
$LN11@Initialize:

; 475  : 	}
; 476  : #endif
; 477  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN17@Initialize
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	npad	1
$LN17@Initialize:
	DD	2
	DD	$LN16@Initialize
$LN16@Initialize:
	DD	-36					; ffffffdcH
	DD	16					; 00000010H
	DD	$LN14@Initialize
	DD	-60					; ffffffc4H
	DD	16					; 00000010H
	DD	$LN15@Initialize
$LN15@Initialize:
	DB	113					; 00000071H
	DB	0
$LN14@Initialize:
	DB	112					; 00000070H
	DB	0
?InitializeSecurity@RakPeer@@UAEXPBD000@Z ENDP		; RakPeer::InitializeSecurity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?Initialize@RakPeer@@UAE_NGGHPBD@Z
_TEXT	SEGMENT
tv268 = -464						; size = 4
tv167 = -464						; size = 4
$T2 = -456						; size = 4
$T3 = -444						; size = 4
$T4 = -432						; size = 4
_ProcessPacketsThreadID$5 = -228			; size = 4
_ipList$6 = -216					; size = 160
_localPort2$7 = -48					; size = 2
_i$ = -36						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_maxConnections$ = 8					; size = 2
_localPort$ = 12					; size = 2
__threadSleepTimer$ = 16				; size = 4
_forceHostAddress$ = 20					; size = 4
?Initialize@RakPeer@@UAE_NGGHPBD@Z PROC			; RakPeer::Initialize, COMDAT
; _this$ = ecx

; 239  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Initialize@RakPeer@@UAE_NGGHPBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 452				; 000001c4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-464]
	mov	ecx, 113				; 00000071H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 240  : 	if (IsActive())

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN21@Initialize

; 241  : 		return false;

	xor	al, al
	jmp	$LN22@Initialize
$LN21@Initialize:

; 242  : 
; 243  : 	unsigned i;
; 244  : 
; 245  : 	assert( maxConnections > 0 );

	movzx	eax, WORD PTR _maxConnections$[ebp]
	test	eax, eax
	jg	SHORT $LN24@Initialize
	mov	ecx, DWORD PTR ?__LINE__Var@?1??Initialize@RakPeer@@UAE_NGGHPBD@Z@4JA
	add	ecx, 6
	push	ecx
	push	OFFSET ??_C@_1EI@HJOFFNLF@?$AAz?$AA?3?$AA?2?$AAs?$AAa?$AAm?$AAp?$AAs?$AAr?$AAc?$AA?2?$AA0?$AA2?$AAx?$AAu?$AA1?$AA?2?$AAr?$AAa?$AAk?$AAn?$AAe?$AAt?$AA?2?$AAr?$AAa?$AAk?$AAp?$AAe?$AAe?$AAr?$AA?4@
	push	OFFSET ??_C@_1CG@FBMJBJBI@?$AAm?$AAa?$AAx?$AAC?$AAo?$AAn?$AAn?$AAe?$AAc?$AAt?$AAi?$AAo?$AAn?$AAs?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
	call	__wassert
	add	esp, 12					; 0000000cH
$LN24@Initialize:

; 246  : 
; 247  : 	if ( maxConnections <= 0 )

	movzx	eax, WORD PTR _maxConnections$[ebp]
	test	eax, eax
	jg	SHORT $LN20@Initialize

; 248  : 		return false;

	xor	al, al
	jmp	$LN22@Initialize
$LN20@Initialize:

; 249  : 
; 250  : 	if ( connectionSocket == INVALID_SOCKET )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2070], -1
	jne	SHORT $LN17@Initialize

; 251  : 	{
; 252  : 		connectionSocket = SocketLayer::Instance()->CreateBoundSocket( localPort, true, forceHostAddress );

	mov	eax, DWORD PTR _forceHostAddress$[ebp]
	push	eax
	push	1
	movzx	ecx, WORD PTR _localPort$[ebp]
	push	ecx
	call	?Instance@SocketLayer@@SAPAV1@XZ	; SocketLayer::Instance
	mov	ecx, eax
	call	?CreateBoundSocket@SocketLayer@@QAEIG_NPBD@Z ; SocketLayer::CreateBoundSocket
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2070], eax

; 253  : 
; 254  : 		if ( connectionSocket == INVALID_SOCKET )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2070], -1
	jne	SHORT $LN18@Initialize

; 255  : 			return false;

	xor	al, al
	jmp	$LN22@Initialize
$LN18@Initialize:

; 256  : 
; 257  : 		unsigned short localPort2 = SocketLayer::Instance()->GetLocalPort(connectionSocket);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2070]
	push	ecx
	call	?Instance@SocketLayer@@SAPAV1@XZ	; SocketLayer::Instance
	mov	ecx, eax
	call	?GetLocalPort@SocketLayer@@QAEGI@Z	; SocketLayer::GetLocalPort
	mov	WORD PTR _localPort2$7[ebp], ax

; 258  : 		if (localPort2!=0)

	movzx	eax, WORD PTR _localPort2$7[ebp]
	test	eax, eax
	je	SHORT $LN17@Initialize

; 259  : 			localPort=localPort2;

	mov	ax, WORD PTR _localPort2$7[ebp]
	mov	WORD PTR _localPort$[ebp], ax
$LN17@Initialize:

; 260  : 	}
; 261  : 
; 262  : #if defined (_WIN32) && defined(USE_WAIT_FOR_MULTIPLE_EVENTS)
; 263  : 	if (_threadSleepTimer>0)
; 264  : 	{
; 265  : 		recvEvent=CreateEvent(0,FALSE,FALSE,0);
; 266  : 		WSAEventSelect(connectionSocket,recvEvent,FD_READ);
; 267  : 	}	
; 268  : #endif
; 269  : 
; 270  : 	if ( maximumNumberOfPeers == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+7]
	test	ecx, ecx
	jne	$LN16@Initialize

; 271  : 	{
; 272  : 		// Don't allow more incoming connections than we have peers.
; 273  : 		if ( maximumIncomingConnections > maxConnections )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+9]
	movzx	edx, WORD PTR _maxConnections$[ebp]
	cmp	ecx, edx
	jle	SHORT $LN15@Initialize

; 274  : 			maximumIncomingConnections = maxConnections;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _maxConnections$[ebp]
	mov	WORD PTR [eax+9], cx
$LN15@Initialize:

; 275  : 
; 276  : 		maximumNumberOfPeers = maxConnections;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _maxConnections$[ebp]
	mov	WORD PTR [eax+7], cx

; 277  : 		// 04/19/2006 - Don't overallocate because I'm not longer allowing connected pings.
; 278  : 		// The disconnects are not consistently processed and the process was sloppy and complicated.
; 279  : 		// Allocate 10% extra to handle new connections from players trying to connect when the server is full
; 280  : 		//remoteSystemListSize = maxConnections;// * 11 / 10 + 1;
; 281  : 
; 282  : 		// remoteSystemList in Single thread
; 283  : 		//remoteSystemList = new RemoteSystemStruct[ remoteSystemListSize ];
; 284  : 		remoteSystemList = new RemoteSystemStruct[ maximumNumberOfPeers ];

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+7]
	mov	DWORD PTR $T2[ebp], ecx
	xor	ecx, ecx
	mov	eax, DWORD PTR $T2[ebp]
	mov	edx, 2058				; 0000080aH
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN25@Initialize
	mov	ecx, DWORD PTR $T4[ebp]
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [ecx], edx
	push	OFFSET ??1RemoteSystemStruct@RakPeer@@QAE@XZ
	push	OFFSET ??0RemoteSystemStruct@RakPeer@@QAE@XZ
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	push	2058					; 0000080aH
	mov	ecx, DWORD PTR $T4[ebp]
	add	ecx, 4
	push	ecx
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	edx, DWORD PTR $T4[ebp]
	add	edx, 4
	mov	DWORD PTR tv167[ebp], edx
	jmp	SHORT $LN26@Initialize
$LN25@Initialize:
	mov	DWORD PTR tv167[ebp], 0
$LN26@Initialize:
	mov	eax, DWORD PTR tv167[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR [ecx+820], edx

; 285  : 
; 286  : 
; 287  : 		for ( i = 0; i < maximumNumberOfPeers; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN14@Initialize
$LN13@Initialize:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN14@Initialize:
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+7]
	cmp	DWORD PTR _i$[ebp], ecx
	jae	SHORT $LN12@Initialize

; 288  : 		//for ( i = 0; i < remoteSystemListSize; i++ )
; 289  : 		{
; 290  : 			// remoteSystemList in Single thread
; 291  : 			remoteSystemList[ i ].isActive = false;

	imul	eax, DWORD PTR _i$[ebp], 2058
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+820]
	mov	BYTE PTR [edx+eax], 0

; 292  : 			#ifndef _RELEASE
; 293  : 			remoteSystemList[ i ].reliabilityLayer.ApplyNetworkSimulator(_maxSendBPS, _minExtraPing, _extraPingVariance);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+2100]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, WORD PTR [edx+2098]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	sub	esp, 8
	movsd	xmm0, QWORD PTR [ecx+2090]
	movsd	QWORD PTR [esp], xmm0
	imul	edx, DWORD PTR _i$[ebp], 2058
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+820]
	lea	ecx, DWORD PTR [ecx+edx+13]
	call	?ApplyNetworkSimulator@ReliabilityLayer@@QAEXNII@Z ; ReliabilityLayer::ApplyNetworkSimulator

; 294  : 			#endif
; 295  : 		}

	jmp	SHORT $LN13@Initialize
$LN12@Initialize:

; 296  : 
; 297  : 		// Clear the lookup table.  Safe to call from the user thread since the network thread is now stopped
; 298  : 		remoteSystemLookup.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 824				; 00000338H
	call	?Clear@?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QAEXXZ ; DataStructures::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>::Clear
$LN16@Initialize:

; 299  : 	}
; 300  : 
; 301  : 	// For histogram statistics
; 302  : 	// nextReadBytesTime=0;
; 303  : 	// lastSentBytes=lastReceivedBytes=0;
; 304  : 
; 305  : 	if ( endThreads )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	je	$LN4@Initialize

; 306  : 	{
; 307  : 	//	lastUserUpdateCycle = 0;
; 308  : 
; 309  : 		// Reset the frequency table that we use to save outgoing data
; 310  : 		memset( frequencyTable, 0, sizeof( unsigned int ) * 256 );

	push	1024					; 00000400H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 977				; 000003d1H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 311  : 
; 312  : 		// Reset the statistical data
; 313  : 		rawBytesSent = rawBytesReceived = compressedBytesSent = compressedBytesReceived = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2021], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2017], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2013], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2009], 0

; 314  : 
; 315  : 		updateCycleIsRunning = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+860], 0

; 316  : 		endThreads = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+4], 0

; 317  : 		// Create the threads
; 318  : 		threadSleepTimer = _threadSleepTimer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __threadSleepTimer$[ebp]
	mov	DWORD PTR [eax+2066], ecx

; 319  : 
; 320  : 		ClearBufferedCommands();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearBufferedCommands@RakPeer@@IAEXXZ	; RakPeer::ClearBufferedCommands

; 321  : 
; 322  : #if !defined(_COMPATIBILITY_1)
; 323  : 		char ipList[ 10 ][ 16 ];
; 324  : 		SocketLayer::Instance()->GetMyIP( ipList );

	lea	eax, DWORD PTR _ipList$6[ebp]
	push	eax
	call	?Instance@SocketLayer@@SAPAV1@XZ	; SocketLayer::Instance
	mov	ecx, eax
	call	?GetMyIP@SocketLayer@@QAEXQAY0BA@D@Z	; SocketLayer::GetMyIP

; 325  : 		myPlayerId.port = localPort;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _localPort$[ebp]
	mov	WORD PTR [eax+561], cx

; 326  : 		if (forceHostAddress==0 || forceHostAddress[0]==0)

	cmp	DWORD PTR _forceHostAddress$[ebp], 0
	je	SHORT $LN9@Initialize
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _forceHostAddress$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN10@Initialize
$LN9@Initialize:

; 327  : 			myPlayerId.binaryAddress = inet_addr( ipList[ 0 ] );

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	lea	edx, DWORD PTR _ipList$6[ebp+ecx]
	mov	esi, esp
	push	edx
	call	DWORD PTR __imp__inet_addr@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+557], eax

; 328  : 		else

	jmp	SHORT $LN8@Initialize
$LN10@Initialize:

; 329  : 			myPlayerId.binaryAddress = inet_addr( forceHostAddress );

	mov	esi, esp
	mov	eax, DWORD PTR _forceHostAddress$[ebp]
	push	eax
	call	DWORD PTR __imp__inet_addr@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+557], eax
$LN8@Initialize:

; 330  : #else
; 331  : 		myPlayerId=UNASSIGNED_PLAYER_ID;
; 332  : #endif
; 333  : 		{
; 334  : #ifdef _WIN32
; 335  : 
; 336  : 			if ( isMainLoopThreadActive == false )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+5]
	test	ecx, ecx
	jne	$LN7@Initialize

; 337  : 			{
; 338  : 				unsigned ProcessPacketsThreadID = 0;

	mov	DWORD PTR _ProcessPacketsThreadID$5[ebp], 0

; 339  : #ifdef _COMPATIBILITY_1
; 340  : 				processPacketsThreadHandle = ( HANDLE ) _beginthreadex( NULL, 0, UpdateNetworkLoop, this, 0, &ProcessPacketsThreadID );
; 341  : #else
; 342  : 				processPacketsThreadHandle = ( HANDLE ) _beginthreadex( NULL, MAX_ALLOCA_STACK_ALLOCATION*2, UpdateNetworkLoop, this, 0, &ProcessPacketsThreadID );

	lea	eax, DWORD PTR _ProcessPacketsThreadID$5[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	push	OFFSET ?UpdateNetworkLoop@@YGIPAX@Z	; UpdateNetworkLoop
	push	2097152					; 00200000H
	push	0
	call	__beginthreadex
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+873], eax

; 343  : #endif
; 344  : 
; 345  : 				//BOOL b =  SetThreadPriority(
; 346  : 				//	processPacketsThreadHandle,
; 347  : 				//	THREAD_PRIORITY_HIGHEST
; 348  : 				//	);
; 349  : 
; 350  : 				if ( processPacketsThreadHandle == 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+873], 0
	jne	SHORT $LN6@Initialize

; 351  : 				{
; 352  : 					Disconnect( 0, 0 );

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 353  : 					return false;

	xor	al, al
	jmp	$LN22@Initialize
$LN6@Initialize:

; 354  : 				}
; 355  : 
; 356  : 				// SetThreadPriority(processPacketsThreadHandle, THREAD_PRIORITY_HIGHEST);
; 357  : 
; 358  : 				CloseHandle( processPacketsThreadHandle );

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+873]
	push	ecx
	call	DWORD PTR __imp__CloseHandle@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 359  : 
; 360  : 				processPacketsThreadHandle = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+873], 0
$LN7@Initialize:

; 361  : 
; 362  : 			}
; 363  : 
; 364  : #else
; 365  : 			pthread_attr_t attr;
; 366  : 			pthread_attr_init( &attr );
; 367  : 			pthread_attr_setdetachstate( &attr, PTHREAD_CREATE_DETACHED );
; 368  : 
; 369  : 			//  sched_param sp;
; 370  : 			//  sp.sched_priority = sched_get_priority_max(SCHED_OTHER);
; 371  : 			//  pthread_attr_setschedparam(&attr, &sp);
; 372  : 
; 373  : 			int error;
; 374  : 
; 375  : 			if ( isMainLoopThreadActive == false )
; 376  : 			{
; 377  : 				error = pthread_create( &processPacketsThreadHandle, &attr, &UpdateNetworkLoop, this );
; 378  : 
; 379  : 				if ( error )
; 380  : 				{
; 381  : 					Disconnect( 0 );
; 382  : 					return false;
; 383  : 				}
; 384  : 			}
; 385  : 
; 386  : 			processPacketsThreadHandle = 0;
; 387  : #endif
; 388  : 
; 389  : 
; 390  : 			// Wait for the threads to activate.  When they are active they will set these variables to true
; 391  : 
; 392  : 			while (  /*isRecvfromThreadActive==false || */isMainLoopThreadActive == false )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+5]
	test	ecx, ecx
	jne	SHORT $LN4@Initialize

; 393  : 				RakSleep(10);

	push	10					; 0000000aH
	call	?RakSleep@@YAXI@Z			; RakSleep
	add	esp, 4
	jmp	SHORT $LN7@Initialize
$LN4@Initialize:

; 394  : 
; 395  : 		}
; 396  : 	}
; 397  : 
; 398  : 	for (i=0; i < messageHandlerList.Size(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@Initialize
$LN2@Initialize:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@Initialize:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 941				; 000003adH
	call	?Size@?$List@PAVPluginInterface@@@DataStructures@@QBEIXZ ; DataStructures::List<PluginInterface *>::Size
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN1@Initialize

; 399  : 	{
; 400  : 		messageHandlerList[i]->OnInitialize(this);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 941				; 000003adH
	call	??A?$List@PAVPluginInterface@@@DataStructures@@QBEAAPAVPluginInterface@@I@Z ; DataStructures::List<PluginInterface *>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv268[ebp], ecx
	mov	esi, esp
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR tv268[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv268[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 401  : 	}

	jmp	SHORT $LN2@Initialize
$LN1@Initialize:

; 402  : 
; 403  : 	return true;

	mov	al, 1
$LN22@Initialize:

; 404  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN32@Initialize
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 464				; 000001d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	npad	1
$LN32@Initialize:
	DD	2
	DD	$LN31@Initialize
$LN31@Initialize:
	DD	-216					; ffffff28H
	DD	160					; 000000a0H
	DD	$LN28@Initialize
	DD	-228					; ffffff1cH
	DD	4
	DD	$LN29@Initialize
$LN29@Initialize:
	DB	80					; 00000050H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	115					; 00000073H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	84					; 00000054H
	DB	104					; 00000068H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	73					; 00000049H
	DB	68					; 00000044H
	DB	0
$LN28@Initialize:
	DB	105					; 00000069H
	DB	112					; 00000070H
	DB	76					; 0000004cH
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Initialize@RakPeer@@UAE_NGGHPBD@Z$0:
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?Initialize@RakPeer@@UAE_NGGHPBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-468]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Initialize@RakPeer@@UAE_NGGHPBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Initialize@RakPeer@@UAE_NGGHPBD@Z ENDP			; RakPeer::Initialize
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ??1RakPeer@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1RakPeer@@UAE@XZ PROC					; RakPeer::~RakPeer, COMDAT
; _this$ = ecx

; 209  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1RakPeer@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7RakPeer@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 14		; 0000000eH

; 210  : //	unsigned i;
; 211  : 
; 212  : 	// Free the ban list.
; 213  : 	ClearBanList();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearBanList@RakPeer@@UAEXXZ		; RakPeer::ClearBanList

; 214  : 
; 215  : 	Disconnect( 0, 0);

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Disconnect@RakPeer@@UAEXIE@Z		; RakPeer::Disconnect

; 216  : 
; 217  : 
; 218  : 	StringCompressor::RemoveReference();

	call	?RemoveReference@StringCompressor@@SAXXZ ; StringCompressor::RemoveReference

; 219  : 	StringTable::RemoveReference();

	call	?RemoveReference@StringTable@@SAXXZ	; StringTable::RemoveReference

; 220  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2522				; 000009daH
	call	??1?$Queue@PAUPacket@@@DataStructures@@QAE@XZ ; DataStructures::Queue<Packet *>::~Queue<Packet *>
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2498				; 000009c2H
	call	??1?$SingleProducerConsumer@PAUPacket@@@DataStructures@@QAE@XZ ; DataStructures::SingleProducerConsumer<Packet *>::~SingleProducerConsumer<Packet *>
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2102				; 00000836H
	call	??1?$RSACrypt@$$BY07I@big@@QAE@XZ	; big::RSACrypt<unsigned int [8]>::~RSACrypt<unsigned int [8]>
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2049				; 00000801H
	call	??1RPCMap@@QAE@XZ			; RPCMap::~RPCMap
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2025				; 000007e9H
	call	??1?$SingleProducerConsumer@UBufferedCommandStruct@RakPeer@@@DataStructures@@QAE@XZ ; DataStructures::SingleProducerConsumer<RakPeer::BufferedCommandStruct>::~SingleProducerConsumer<RakPeer::BufferedCommandStruct>
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 953				; 000003b9H
	call	??1?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAE@XZ ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::~SingleProducerConsumer<RakPeer::RequestedConnectionStruct>
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 941				; 000003adH
	call	??1?$List@PAVPluginInterface@@@DataStructures@@QAE@XZ ; DataStructures::List<PluginInterface *>::~List<PluginInterface *>
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 929				; 000003a1H
	call	??1?$List@PAUBanStruct@RakPeer@@@DataStructures@@QAE@XZ ; DataStructures::List<RakPeer::BanStruct *>::~List<RakPeer::BanStruct *>
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 905				; 00000389H
	call	??1SimpleMutex@@QAE@XZ			; SimpleMutex::~SimpleMutex
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 881				; 00000371H
	call	??1SimpleMutex@@QAE@XZ			; SimpleMutex::~SimpleMutex
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	push	OFFSET ??1SimpleMutex@@QAE@XZ		; SimpleMutex::~SimpleMutex
	push	1
	push	24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 836				; 00000344H
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 824				; 00000338H
	call	??1?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>::~OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 284				; 0000011cH
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 11					; 0000000bH
	call	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1RakPeerInterface@@UAE@XZ		; RakPeerInterface::~RakPeerInterface
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1RakPeer@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1RakPeerInterface@@UAE@XZ		; RakPeerInterface::~RakPeerInterface
__unwindfunclet$??1RakPeer@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 11					; 0000000bH
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__unwindfunclet$??1RakPeer@@UAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 284				; 0000011cH
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__unwindfunclet$??1RakPeer@@UAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 824				; 00000338H
	jmp	??1?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>::~OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>
__unwindfunclet$??1RakPeer@@UAE@XZ$4:
	push	OFFSET ??1SimpleMutex@@QAE@XZ		; SimpleMutex::~SimpleMutex
	push	1
	push	24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 836				; 00000344H
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	ret	0
__unwindfunclet$??1RakPeer@@UAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 881				; 00000371H
	jmp	??1SimpleMutex@@QAE@XZ			; SimpleMutex::~SimpleMutex
__unwindfunclet$??1RakPeer@@UAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 905				; 00000389H
	jmp	??1SimpleMutex@@QAE@XZ			; SimpleMutex::~SimpleMutex
__unwindfunclet$??1RakPeer@@UAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 929				; 000003a1H
	jmp	??1?$List@PAUBanStruct@RakPeer@@@DataStructures@@QAE@XZ ; DataStructures::List<RakPeer::BanStruct *>::~List<RakPeer::BanStruct *>
__unwindfunclet$??1RakPeer@@UAE@XZ$8:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 941				; 000003adH
	jmp	??1?$List@PAVPluginInterface@@@DataStructures@@QAE@XZ ; DataStructures::List<PluginInterface *>::~List<PluginInterface *>
__unwindfunclet$??1RakPeer@@UAE@XZ$9:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 953				; 000003b9H
	jmp	??1?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAE@XZ ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::~SingleProducerConsumer<RakPeer::RequestedConnectionStruct>
__unwindfunclet$??1RakPeer@@UAE@XZ$10:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2025				; 000007e9H
	jmp	??1?$SingleProducerConsumer@UBufferedCommandStruct@RakPeer@@@DataStructures@@QAE@XZ ; DataStructures::SingleProducerConsumer<RakPeer::BufferedCommandStruct>::~SingleProducerConsumer<RakPeer::BufferedCommandStruct>
__unwindfunclet$??1RakPeer@@UAE@XZ$11:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2049				; 00000801H
	jmp	??1RPCMap@@QAE@XZ			; RPCMap::~RPCMap
__unwindfunclet$??1RakPeer@@UAE@XZ$12:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2102				; 00000836H
	jmp	??1?$RSACrypt@$$BY07I@big@@QAE@XZ	; big::RSACrypt<unsigned int [8]>::~RSACrypt<unsigned int [8]>
__unwindfunclet$??1RakPeer@@UAE@XZ$13:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2498				; 000009c2H
	jmp	??1?$SingleProducerConsumer@PAUPacket@@@DataStructures@@QAE@XZ ; DataStructures::SingleProducerConsumer<Packet *>::~SingleProducerConsumer<Packet *>
__unwindfunclet$??1RakPeer@@UAE@XZ$14:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2522				; 000009daH
	jmp	??1?$Queue@PAUPacket@@@DataStructures@@QAE@XZ ; DataStructures::Queue<Packet *>::~Queue<Packet *>
__ehhandler$??1RakPeer@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1RakPeer@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1RakPeer@@UAE@XZ ENDP					; RakPeer::~RakPeer
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ??0RakPeer@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0RakPeer@@QAE@XZ PROC					; RakPeer::RakPeer, COMDAT
; _this$ = ecx

; 162  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0RakPeer@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0RakPeerInterface@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7RakPeer@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 11					; 0000000bH
	call	??0BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::BitStream
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 284				; 0000011cH
	call	??0BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::BitStream
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 824				; 00000338H
	call	??0?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	push	OFFSET ??1SimpleMutex@@QAE@XZ		; SimpleMutex::~SimpleMutex
	push	OFFSET ??0SimpleMutex@@QAE@XZ		; SimpleMutex::SimpleMutex
	push	1
	push	24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 836				; 00000344H
	push	eax
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 881				; 00000371H
	call	??0SimpleMutex@@QAE@XZ			; SimpleMutex::SimpleMutex
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 905				; 00000389H
	call	??0SimpleMutex@@QAE@XZ			; SimpleMutex::SimpleMutex
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 929				; 000003a1H
	call	??0?$List@PAUBanStruct@RakPeer@@@DataStructures@@QAE@XZ ; DataStructures::List<RakPeer::BanStruct *>::List<RakPeer::BanStruct *>
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 941				; 000003adH
	call	??0?$List@PAVPluginInterface@@@DataStructures@@QAE@XZ ; DataStructures::List<PluginInterface *>::List<PluginInterface *>
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 953				; 000003b9H
	call	??0?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAE@XZ ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2025				; 000007e9H
	call	??0?$SingleProducerConsumer@UBufferedCommandStruct@RakPeer@@@DataStructures@@QAE@XZ ; DataStructures::SingleProducerConsumer<RakPeer::BufferedCommandStruct>::SingleProducerConsumer<RakPeer::BufferedCommandStruct>
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2049				; 00000801H
	call	??0RPCMap@@QAE@XZ			; RPCMap::RPCMap
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2102				; 00000836H
	call	??0?$RSACrypt@$$BY07I@big@@QAE@XZ	; big::RSACrypt<unsigned int [8]>::RSACrypt<unsigned int [8]>
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2498				; 000009c2H
	call	??0?$SingleProducerConsumer@PAUPacket@@@DataStructures@@QAE@XZ ; DataStructures::SingleProducerConsumer<Packet *>::SingleProducerConsumer<Packet *>
	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2522				; 000009daH
	call	??0?$Queue@PAUPacket@@@DataStructures@@QAE@XZ ; DataStructures::Queue<Packet *>::Queue<Packet *>
	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH

; 163  : 	StringCompressor::AddReference();

	call	?AddReference@StringCompressor@@SAXXZ	; StringCompressor::AddReference

; 164  : 	StringTable::AddReference();

	call	?AddReference@StringTable@@SAXXZ	; StringTable::AddReference

; 165  : 
; 166  : #if !defined(_COMPATIBILITY_1)
; 167  : 	usingSecurity = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+2444], 0

; 168  : #endif
; 169  : 	memset( frequencyTable, 0, sizeof( unsigned int ) * 256 );

	push	1024					; 00000400H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 977				; 000003d1H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 170  : 	rawBytesSent = rawBytesReceived = compressedBytesSent = compressedBytesReceived = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2021], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2017], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2013], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2009], 0

; 171  : 	outputTree = inputTree = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2001], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2005], 0

; 172  : 	connectionSocket = INVALID_SOCKET;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2070], -1

; 173  : 	MTUSize = DEFAULT_MTU_SIZE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2061], 576		; 00000240H

; 174  : 	trackFrequencyTable = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+2065], 0

; 175  : 	maximumIncomingConnections = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+9], ax

; 176  : 	maximumNumberOfPeers = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+7], ax

; 177  : 	//remoteSystemListSize=0;
; 178  : 	remoteSystemList = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+820], 0

; 179  : 	bytesSentPerSecond = bytesReceivedPerSecond = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+865], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+861], 0

; 180  : 	endThreads = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+4], 1

; 181  : 	isMainLoopThreadActive = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+5], 0

; 182  : 	// isRecvfromThreadActive=false;
; 183  : 	occasionalPing = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+6], 0

; 184  : 	connectionSocket = INVALID_SOCKET;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2070], -1

; 185  : 	myPlayerId = UNASSIGNED_PLAYER_ID;

	push	OFFSET _UNASSIGNED_PLAYER_ID
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 557				; 0000022dH
	call	??4PlayerID@@QAEAAU0@ABU0@@Z		; PlayerID::operator=

; 186  : 	allowConnectionResponseIPMigration = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+2489], 0

; 187  : 	blockOnRPCReply=false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+2085], 0

; 188  : 	//incomingPasswordLength=outgoingPasswordLength=0;
; 189  : 	incomingPasswordLength=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+819], 0

; 190  : 	router=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2086], 0

; 191  : 	splitMessageProgressInterval=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2490], 0

; 192  : 	unreliableTimeout=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2494], 0

; 193  : 
; 194  : #if defined (_WIN32) && defined(USE_WAIT_FOR_MULTIPLE_EVENTS)
; 195  : 	recvEvent = INVALID_HANDLE_VALUE;
; 196  : #endif
; 197  : 
; 198  : #ifndef _RELEASE
; 199  : 	_maxSendBPS=0.0;

	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR [eax+2090], xmm0

; 200  : 	_minExtraPing=0;

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+2098], ax

; 201  : 	_extraPingVariance=0;

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+2100], ax

; 202  : #endif
; 203  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0RakPeer@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1RakPeerInterface@@UAE@XZ		; RakPeerInterface::~RakPeerInterface
__unwindfunclet$??0RakPeer@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 11					; 0000000bH
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__unwindfunclet$??0RakPeer@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 284				; 0000011cH
	jmp	??1BitStream@RakNet@@QAE@XZ		; RakNet::BitStream::~BitStream
__unwindfunclet$??0RakPeer@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 824				; 00000338H
	jmp	??1?$OrderedList@UPlayerID@@UPlayerIDAndIndex@@$1?PlayerIDAndIndexComp@@YAHABU1@ABU2@@Z@DataStructures@@QAE@XZ ; DataStructures::OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>::~OrderedList<PlayerID,PlayerIDAndIndex,&PlayerIDAndIndexComp>
__unwindfunclet$??0RakPeer@@QAE@XZ$4:
	push	OFFSET ??1SimpleMutex@@QAE@XZ		; SimpleMutex::~SimpleMutex
	push	1
	push	24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 836				; 00000344H
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	ret	0
__unwindfunclet$??0RakPeer@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 881				; 00000371H
	jmp	??1SimpleMutex@@QAE@XZ			; SimpleMutex::~SimpleMutex
__unwindfunclet$??0RakPeer@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 905				; 00000389H
	jmp	??1SimpleMutex@@QAE@XZ			; SimpleMutex::~SimpleMutex
__unwindfunclet$??0RakPeer@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 929				; 000003a1H
	jmp	??1?$List@PAUBanStruct@RakPeer@@@DataStructures@@QAE@XZ ; DataStructures::List<RakPeer::BanStruct *>::~List<RakPeer::BanStruct *>
__unwindfunclet$??0RakPeer@@QAE@XZ$8:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 941				; 000003adH
	jmp	??1?$List@PAVPluginInterface@@@DataStructures@@QAE@XZ ; DataStructures::List<PluginInterface *>::~List<PluginInterface *>
__unwindfunclet$??0RakPeer@@QAE@XZ$9:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 953				; 000003b9H
	jmp	??1?$SingleProducerConsumer@URequestedConnectionStruct@RakPeer@@@DataStructures@@QAE@XZ ; DataStructures::SingleProducerConsumer<RakPeer::RequestedConnectionStruct>::~SingleProducerConsumer<RakPeer::RequestedConnectionStruct>
__unwindfunclet$??0RakPeer@@QAE@XZ$10:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2025				; 000007e9H
	jmp	??1?$SingleProducerConsumer@UBufferedCommandStruct@RakPeer@@@DataStructures@@QAE@XZ ; DataStructures::SingleProducerConsumer<RakPeer::BufferedCommandStruct>::~SingleProducerConsumer<RakPeer::BufferedCommandStruct>
__unwindfunclet$??0RakPeer@@QAE@XZ$11:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2049				; 00000801H
	jmp	??1RPCMap@@QAE@XZ			; RPCMap::~RPCMap
__unwindfunclet$??0RakPeer@@QAE@XZ$12:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2102				; 00000836H
	jmp	??1?$RSACrypt@$$BY07I@big@@QAE@XZ	; big::RSACrypt<unsigned int [8]>::~RSACrypt<unsigned int [8]>
__unwindfunclet$??0RakPeer@@QAE@XZ$13:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2498				; 000009c2H
	jmp	??1?$SingleProducerConsumer@PAUPacket@@@DataStructures@@QAE@XZ ; DataStructures::SingleProducerConsumer<Packet *>::~SingleProducerConsumer<Packet *>
__unwindfunclet$??0RakPeer@@QAE@XZ$14:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2522				; 000009daH
	jmp	??1?$Queue@PAUPacket@@@DataStructures@@QAE@XZ ; DataStructures::Queue<Packet *>::~Queue<Packet *>
__ehhandler$??0RakPeer@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0RakPeer@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0RakPeer@@QAE@XZ ENDP					; RakPeer::RakPeer
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeer.cpp
;	COMDAT ?PlayerIDAndIndexComp@@YAHABUPlayerID@@ABUPlayerIDAndIndex@@@Z
_TEXT	SEGMENT
_key$ = 8						; size = 4
_data$ = 12						; size = 4
?PlayerIDAndIndexComp@@YAHABUPlayerID@@ABUPlayerIDAndIndex@@@Z PROC ; PlayerIDAndIndexComp, COMDAT

; 81   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 82   : 	if (key < data.playerId)

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	call	??MPlayerID@@QBE_NABU0@@Z		; PlayerID::operator<
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@PlayerIDAn

; 83   : 		return -1;

	or	eax, -1
	jmp	SHORT $LN3@PlayerIDAn
$LN2@PlayerIDAn:

; 84   : 	if (key==data.playerId)

	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	call	??8PlayerID@@QBE_NABU0@@Z		; PlayerID::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@PlayerIDAn

; 85   : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN3@PlayerIDAn
$LN1@PlayerIDAn:

; 86   : 	return 1;

	mov	eax, 1
$LN3@PlayerIDAn:

; 87   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?PlayerIDAndIndexComp@@YAHABUPlayerID@@ABUPlayerIDAndIndex@@@Z ENDP ; PlayerIDAndIndexComp
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??4PlayerIDAndIndex@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??4PlayerIDAndIndex@@QAEAAU0@ABU0@@Z PROC		; PlayerIDAndIndex::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4PlayerID@@QAEAAU0@ABU0@@Z		; PlayerID::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	mov	DWORD PTR [eax+6], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4PlayerIDAndIndex@@QAEAAU0@ABU0@@Z ENDP		; PlayerIDAndIndex::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\raknetstatistics.h
;	COMDAT ??YRakNetStatisticsStruct@@QAE?AU0@ABU0@@Z
_TEXT	SEGMENT
_i$ = -20						; size = 4
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
_other$ = 12						; size = 4
??YRakNetStatisticsStruct@@QAE?AU0@ABU0@@Z PROC		; RakNetStatisticsStruct::operator+=, COMDAT
; _this$ = ecx

; 114  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 115  : 		unsigned i;
; 116  : 		for (i=0; i < NUMBER_OF_PRIORITIES; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@operator
$LN2@operator:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@operator:
	cmp	DWORD PTR _i$[ebp], 4
	jae	SHORT $LN1@operator

; 117  : 		{
; 118  : 			messageSendBuffer[i]+=other.messageSendBuffer[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _other$[ebp]
	add	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 119  : 			messagesSent[i]+=other.messagesSent[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+16]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _other$[ebp]
	add	edx, DWORD PTR [ecx+eax*4+16]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+16], edx

; 120  : 			messageDataBitsSent[i]+=other.messageDataBitsSent[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+32]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _other$[ebp]
	add	edx, DWORD PTR [ecx+eax*4+32]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+32], edx

; 121  : 			messageTotalBitsSent[i]+=other.messageTotalBitsSent[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+48]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _other$[ebp]
	add	edx, DWORD PTR [ecx+eax*4+48]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+48], edx

; 122  : 		}

	jmp	$LN2@operator
$LN1@operator:

; 123  : 
; 124  : 		packetsContainingOnlyAcknowlegements+=other.packetsContainingOnlyAcknowlegements;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR _other$[ebp]
	add	ecx, DWORD PTR [edx+64]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+64], ecx

; 125  : 		acknowlegementsSent+=other.packetsContainingOnlyAcknowlegements;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	edx, DWORD PTR _other$[ebp]
	add	ecx, DWORD PTR [edx+64]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+68], ecx

; 126  : 		acknowlegementsPending+=other.acknowlegementsPending;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR _other$[ebp]
	add	ecx, DWORD PTR [edx+72]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+72], ecx

; 127  : 		acknowlegementBitsSent+=other.acknowlegementBitsSent;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR _other$[ebp]
	add	ecx, DWORD PTR [edx+76]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+76], ecx

; 128  : 		packetsContainingOnlyAcknowlegementsAndResends+=other.packetsContainingOnlyAcknowlegementsAndResends;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	edx, DWORD PTR _other$[ebp]
	add	ecx, DWORD PTR [edx+80]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+80], ecx

; 129  : 		messageResends+=other.messageResends;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	edx, DWORD PTR _other$[ebp]
	add	ecx, DWORD PTR [edx+84]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+84], ecx

; 130  : 		messageDataBitsResent+=other.messageDataBitsResent;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	edx, DWORD PTR _other$[ebp]
	add	ecx, DWORD PTR [edx+88]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+88], ecx

; 131  : 		messagesTotalBitsResent+=other.messagesTotalBitsResent;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	edx, DWORD PTR _other$[ebp]
	add	ecx, DWORD PTR [edx+92]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+92], ecx

; 132  : 		messagesOnResendQueue+=other.messagesOnResendQueue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	edx, DWORD PTR _other$[ebp]
	add	ecx, DWORD PTR [edx+96]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+96], ecx

; 133  : 		numberOfUnsplitMessages+=other.numberOfUnsplitMessages;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR _other$[ebp]
	add	ecx, DWORD PTR [edx+100]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+100], ecx

; 134  : 		numberOfSplitMessages+=other.numberOfSplitMessages;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	edx, DWORD PTR _other$[ebp]
	add	ecx, DWORD PTR [edx+104]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+104], ecx

; 135  : 		totalSplits+=other.totalSplits;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	edx, DWORD PTR _other$[ebp]
	add	ecx, DWORD PTR [edx+108]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+108], ecx

; 136  : 		packetsSent+=other.packetsSent;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	mov	edx, DWORD PTR _other$[ebp]
	add	ecx, DWORD PTR [edx+112]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+112], ecx

; 137  : 		encryptionBitsSent+=other.encryptionBitsSent;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	mov	edx, DWORD PTR _other$[ebp]
	add	ecx, DWORD PTR [edx+116]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+116], ecx

; 138  : 		totalBitsSent+=other.totalBitsSent;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+120]
	mov	edx, DWORD PTR _other$[ebp]
	add	ecx, DWORD PTR [edx+120]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+120], ecx

; 139  : 		sequencedMessagesOutOfOrder+=other.sequencedMessagesOutOfOrder;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+124]
	mov	edx, DWORD PTR _other$[ebp]
	add	ecx, DWORD PTR [edx+124]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+124], ecx

; 140  : 		sequencedMessagesInOrder+=other.sequencedMessagesInOrder;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	mov	edx, DWORD PTR _other$[ebp]
	add	ecx, DWORD PTR [edx+128]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+128], ecx

; 141  : 		orderedMessagesOutOfOrder+=other.orderedMessagesOutOfOrder;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+132]
	mov	edx, DWORD PTR _other$[ebp]
	add	ecx, DWORD PTR [edx+132]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+132], ecx

; 142  : 		orderedMessagesInOrder+=other.orderedMessagesInOrder;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	mov	edx, DWORD PTR _other$[ebp]
	add	ecx, DWORD PTR [edx+136]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+136], ecx

; 143  : 		packetsReceived+=other.packetsReceived;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	mov	edx, DWORD PTR _other$[ebp]
	add	ecx, DWORD PTR [edx+140]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+140], ecx

; 144  : 		packetsWithBadCRCReceived+=other.packetsWithBadCRCReceived;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	mov	edx, DWORD PTR _other$[ebp]
	add	ecx, DWORD PTR [edx+144]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+144], ecx

; 145  : 		bitsReceived+=other.bitsReceived;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR _other$[ebp]
	add	ecx, DWORD PTR [edx+148]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+148], ecx

; 146  : 		bitsWithBadCRCReceived+=other.bitsWithBadCRCReceived;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	mov	edx, DWORD PTR _other$[ebp]
	add	ecx, DWORD PTR [edx+152]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+152], ecx

; 147  : 		acknowlegementsReceived+=other.acknowlegementsReceived;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	mov	edx, DWORD PTR _other$[ebp]
	add	ecx, DWORD PTR [edx+156]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+156], ecx

; 148  : 		duplicateAcknowlegementsReceived+=other.duplicateAcknowlegementsReceived;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+160]
	mov	edx, DWORD PTR _other$[ebp]
	add	ecx, DWORD PTR [edx+160]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+160], ecx

; 149  : 		messagesReceived+=other.messagesReceived;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR _other$[ebp]
	add	ecx, DWORD PTR [edx+164]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+164], ecx

; 150  : 		invalidMessagesReceived+=other.invalidMessagesReceived;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	mov	edx, DWORD PTR _other$[ebp]
	add	ecx, DWORD PTR [edx+168]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+168], ecx

; 151  : 		duplicateMessagesReceived+=other.duplicateMessagesReceived;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+172]
	mov	edx, DWORD PTR _other$[ebp]
	add	ecx, DWORD PTR [edx+172]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+172], ecx

; 152  : 		messagesWaitingForReassembly+=other.messagesWaitingForReassembly;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+176]
	mov	edx, DWORD PTR _other$[ebp]
	add	ecx, DWORD PTR [edx+176]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+176], ecx

; 153  : 		internalOutputQueueSize+=other.internalOutputQueueSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+180]
	mov	edx, DWORD PTR _other$[ebp]
	add	ecx, DWORD PTR [edx+180]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+180], ecx

; 154  : 
; 155  : 		return *this;

	mov	ecx, 49					; 00000031H
	mov	esi, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 156  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??YRakNetStatisticsStruct@@QAE?AU0@ABU0@@Z ENDP		; RakNetStatisticsStruct::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Read@UNetworkID@@@BitStream@RakNet@@QAE_NAAUNetworkID@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 4
??$Read@UNetworkID@@@BitStream@RakNet@@QAE_NAAUNetworkID@@@Z PROC ; RakNet::BitStream::Read<NetworkID>, COMDAT
; _this$ = ecx

; 1044 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1045 : 		if (NetworkID::IsPeerToPeerMode()) // Use the function rather than directly access the member or DLL users will get an undefined external error

	call	?IsPeerToPeerMode@NetworkID@@SA_NXZ	; NetworkID::IsPeerToPeerMode
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@Read

; 1046 : 			Read(var.playerId);

	mov	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$Read@UPlayerID@@@BitStream@RakNet@@QAE_NAAUPlayerID@@@Z ; RakNet::BitStream::Read<PlayerID>
$LN1@Read:

; 1047 : 		return Read(var.localSystemId);

	mov	eax, DWORD PTR _var$[ebp]
	add	eax, 6
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$Read@G@BitStream@RakNet@@QAE_NAAG@Z	; RakNet::BitStream::Read<unsigned short>

; 1048 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$Read@UNetworkID@@@BitStream@RakNet@@QAE_NAAUNetworkID@@@Z ENDP ; RakNet::BitStream::Read<NetworkID>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Read@G@BitStream@RakNet@@QAE_NAAG@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 4
??$Read@G@BitStream@RakNet@@QAE_NAAG@Z PROC		; RakNet::BitStream::Read<unsigned short>, COMDAT
; _this$ = ecx

; 987  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 988  : #ifdef _MSC_VER
; 989  : #pragma warning(disable:4127)   // conditional expression is constant
; 990  : #endif
; 991  : 		if (sizeof(var)==1)

	xor	eax, eax
	je	SHORT $LN2@Read

; 992  : 			return ReadBits( ( unsigned char* ) &var, sizeof(templateType) * 8, true );

	push	1
	push	16					; 00000010H
	mov	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadBits@BitStream@RakNet@@QAE_NPAEH_N@Z ; RakNet::BitStream::ReadBits
	jmp	SHORT $LN3@Read

; 993  : 		else

	jmp	SHORT $LN3@Read
$LN2@Read:

; 994  : 		{
; 995  : #ifndef __BITSTREAM_NATIVE_END
; 996  : #ifdef _MSC_VER
; 997  : #pragma warning(disable:4244)   // '=' : conversion from 'unsigned long' to 'unsigned short', possible loss of data
; 998  : #endif
; 999  : 			if (DoEndianSwap())
; 1000 : 			{
; 1001 : 				unsigned char output[sizeof(templateType)];
; 1002 : 				if (ReadBits( ( unsigned char* ) output, sizeof(templateType) * 8, true ))
; 1003 : 				{
; 1004 : 					ReverseBytes(output, (unsigned char*)&var, sizeof(templateType));
; 1005 : 					return true;
; 1006 : 				}
; 1007 : 				return false;
; 1008 : 			}
; 1009 : 			else
; 1010 : #endif
; 1011 : 				return ReadBits( ( unsigned char* ) & var, sizeof(templateType) * 8, true );

	push	1
	push	16					; 00000010H
	mov	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadBits@BitStream@RakNet@@QAE_NPAEH_N@Z ; RakNet::BitStream::ReadBits
$LN3@Read:

; 1012 : 		}
; 1013 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$Read@G@BitStream@RakNet@@QAE_NAAG@Z ENDP		; RakNet::BitStream::Read<unsigned short>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Read@I@BitStream@RakNet@@QAE_NAAI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 4
??$Read@I@BitStream@RakNet@@QAE_NAAI@Z PROC		; RakNet::BitStream::Read<unsigned int>, COMDAT
; _this$ = ecx

; 987  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 988  : #ifdef _MSC_VER
; 989  : #pragma warning(disable:4127)   // conditional expression is constant
; 990  : #endif
; 991  : 		if (sizeof(var)==1)

	xor	eax, eax
	je	SHORT $LN2@Read

; 992  : 			return ReadBits( ( unsigned char* ) &var, sizeof(templateType) * 8, true );

	push	1
	push	32					; 00000020H
	mov	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadBits@BitStream@RakNet@@QAE_NPAEH_N@Z ; RakNet::BitStream::ReadBits
	jmp	SHORT $LN3@Read

; 993  : 		else

	jmp	SHORT $LN3@Read
$LN2@Read:

; 994  : 		{
; 995  : #ifndef __BITSTREAM_NATIVE_END
; 996  : #ifdef _MSC_VER
; 997  : #pragma warning(disable:4244)   // '=' : conversion from 'unsigned long' to 'unsigned short', possible loss of data
; 998  : #endif
; 999  : 			if (DoEndianSwap())
; 1000 : 			{
; 1001 : 				unsigned char output[sizeof(templateType)];
; 1002 : 				if (ReadBits( ( unsigned char* ) output, sizeof(templateType) * 8, true ))
; 1003 : 				{
; 1004 : 					ReverseBytes(output, (unsigned char*)&var, sizeof(templateType));
; 1005 : 					return true;
; 1006 : 				}
; 1007 : 				return false;
; 1008 : 			}
; 1009 : 			else
; 1010 : #endif
; 1011 : 				return ReadBits( ( unsigned char* ) & var, sizeof(templateType) * 8, true );

	push	1
	push	32					; 00000020H
	mov	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadBits@BitStream@RakNet@@QAE_NPAEH_N@Z ; RakNet::BitStream::ReadBits
$LN3@Read:

; 1012 : 		}
; 1013 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$Read@I@BitStream@RakNet@@QAE_NAAI@Z ENDP		; RakNet::BitStream::Read<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Read@UPlayerID@@@BitStream@RakNet@@QAE_NAAUPlayerID@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 4
??$Read@UPlayerID@@@BitStream@RakNet@@QAE_NAAUPlayerID@@@Z PROC ; RakNet::BitStream::Read<PlayerID>, COMDAT
; _this$ = ecx

; 1035 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1036 : 		Read(var.binaryAddress);

	mov	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$Read@I@BitStream@RakNet@@QAE_NAAI@Z	; RakNet::BitStream::Read<unsigned int>

; 1037 : 		return Read(var.port);

	mov	eax, DWORD PTR _var$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$Read@G@BitStream@RakNet@@QAE_NAAG@Z	; RakNet::BitStream::Read<unsigned short>

; 1038 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$Read@UPlayerID@@@BitStream@RakNet@@QAE_NAAUPlayerID@@@Z ENDP ; RakNet::BitStream::Read<PlayerID>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z
_TEXT	SEGMENT
tv82 = -208						; size = 4
_this$ = -8						; size = 4
_var$ = 8						; size = 4
??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z PROC		; RakNet::BitStream::Read<bool>, COMDAT
; _this$ = ecx

; 1019 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1020 : 		if ( readOffset + 1 > numberOfBitsUsed )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [edx]
	jle	SHORT $LN3@Read

; 1021 : 			return false;

	xor	al, al
	jmp	SHORT $LN4@Read
$LN3@Read:

; 1022 : 
; 1023 : 		if ( data[ readOffset >> 3 ] & ( 0x80 >> ( readOffset++ % 8 ) ) )   // Is it faster to just write it out here?

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sar	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	movzx	edx, BYTE PTR [eax+ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -2147483641			; 80000007H
	jns	SHORT $LN6@Read
	dec	ecx
	or	ecx, -8					; fffffff8H
	inc	ecx
$LN6@Read:
	mov	eax, 128				; 00000080H
	sar	eax, cl
	and	edx, eax
	mov	DWORD PTR tv82[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx
	cmp	DWORD PTR tv82[ebp], 0
	je	SHORT $LN2@Read

; 1024 : 			var = true;

	mov	eax, DWORD PTR _var$[ebp]
	mov	BYTE PTR [eax], 1

; 1025 : 		else

	jmp	SHORT $LN1@Read
$LN2@Read:

; 1026 : 			var = false;

	mov	eax, DWORD PTR _var$[ebp]
	mov	BYTE PTR [eax], 0
$LN1@Read:

; 1027 : 
; 1028 : 		return true;

	mov	al, 1
$LN4@Read:

; 1029 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??$Read@_N@BitStream@RakNet@@QAE_NAA_N@Z ENDP		; RakNet::BitStream::Read<bool>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Write@UNetworkID@@@BitStream@RakNet@@QAEXUNetworkID@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 8
??$Write@UNetworkID@@@BitStream@RakNet@@QAEXUNetworkID@@@Z PROC ; RakNet::BitStream::Write<NetworkID>, COMDAT
; _this$ = ecx

; 774  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 		if (NetworkID::IsPeerToPeerMode()) // Use the function rather than directly access the member or DLL users will get an undefined external error

	call	?IsPeerToPeerMode@NetworkID@@SA_NXZ	; NetworkID::IsPeerToPeerMode
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@Write

; 776  : 			Write(var.playerId);

	sub	esp, 8
	mov	eax, esp
	mov	ecx, DWORD PTR _var$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR _var$[ebp+4]
	mov	WORD PTR [eax+4], dx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$Write@UPlayerID@@@BitStream@RakNet@@QAEXUPlayerID@@@Z ; RakNet::BitStream::Write<PlayerID>
$LN1@Write:

; 777  : 		Write(var.localSystemId);

	movzx	eax, WORD PTR _var$[ebp+6]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$Write@G@BitStream@RakNet@@QAEXG@Z	; RakNet::BitStream::Write<unsigned short>

; 778  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$Write@UNetworkID@@@BitStream@RakNet@@QAEXUNetworkID@@@Z ENDP ; RakNet::BitStream::Write<NetworkID>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Write@G@BitStream@RakNet@@QAEXG@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 2
??$Write@G@BitStream@RakNet@@QAEXG@Z PROC		; RakNet::BitStream::Write<unsigned short>, COMDAT
; _this$ = ecx

; 729  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 730  : #ifdef _MSC_VER
; 731  : #pragma warning(disable:4127)   // conditional expression is constant
; 732  : #endif
; 733  : 		if (sizeof(var)==1)

	xor	eax, eax
	je	SHORT $LN2@Write

; 734  : 			WriteBits( ( unsigned char* ) & var, sizeof( templateType ) * 8, true );

	push	1
	push	16					; 00000010H
	lea	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z ; RakNet::BitStream::WriteBits

; 735  : 		else

	jmp	SHORT $LN3@Write
$LN2@Write:

; 736  : 		{
; 737  : #ifndef __BITSTREAM_NATIVE_END
; 738  : 			if (DoEndianSwap())
; 739  : 			{
; 740  : 				unsigned char output[sizeof(templateType)];
; 741  : 				ReverseBytes((unsigned char*)&var, output, sizeof(templateType));
; 742  : 				WriteBits( ( unsigned char* ) output, sizeof(templateType) * 8, true );
; 743  : 			}
; 744  : 			else
; 745  : #endif
; 746  : 				WriteBits( ( unsigned char* ) & var, sizeof(templateType) * 8, true );

	push	1
	push	16					; 00000010H
	lea	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z ; RakNet::BitStream::WriteBits
$LN3@Write:

; 747  : 		}
; 748  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$Write@G@BitStream@RakNet@@QAEXG@Z ENDP		; RakNet::BitStream::Write<unsigned short>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Write@I@BitStream@RakNet@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 4
??$Write@I@BitStream@RakNet@@QAEXI@Z PROC		; RakNet::BitStream::Write<unsigned int>, COMDAT
; _this$ = ecx

; 729  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 730  : #ifdef _MSC_VER
; 731  : #pragma warning(disable:4127)   // conditional expression is constant
; 732  : #endif
; 733  : 		if (sizeof(var)==1)

	xor	eax, eax
	je	SHORT $LN2@Write

; 734  : 			WriteBits( ( unsigned char* ) & var, sizeof( templateType ) * 8, true );

	push	1
	push	32					; 00000020H
	lea	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z ; RakNet::BitStream::WriteBits

; 735  : 		else

	jmp	SHORT $LN3@Write
$LN2@Write:

; 736  : 		{
; 737  : #ifndef __BITSTREAM_NATIVE_END
; 738  : 			if (DoEndianSwap())
; 739  : 			{
; 740  : 				unsigned char output[sizeof(templateType)];
; 741  : 				ReverseBytes((unsigned char*)&var, output, sizeof(templateType));
; 742  : 				WriteBits( ( unsigned char* ) output, sizeof(templateType) * 8, true );
; 743  : 			}
; 744  : 			else
; 745  : #endif
; 746  : 				WriteBits( ( unsigned char* ) & var, sizeof(templateType) * 8, true );

	push	1
	push	32					; 00000020H
	lea	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WriteBits@BitStream@RakNet@@QAEXPBEH_N@Z ; RakNet::BitStream::WriteBits
$LN3@Write:

; 747  : 		}
; 748  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$Write@I@BitStream@RakNet@@QAEXI@Z ENDP		; RakNet::BitStream::Write<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Write@UPlayerID@@@BitStream@RakNet@@QAEXUPlayerID@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 6
??$Write@UPlayerID@@@BitStream@RakNet@@QAEXUPlayerID@@@Z PROC ; RakNet::BitStream::Write<PlayerID>, COMDAT
; _this$ = ecx

; 765  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 766  : 		Write(var.binaryAddress);

	mov	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$Write@I@BitStream@RakNet@@QAEXI@Z	; RakNet::BitStream::Write<unsigned int>

; 767  : 		Write(var.port);

	movzx	eax, WORD PTR _var$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$Write@G@BitStream@RakNet@@QAEXG@Z	; RakNet::BitStream::Write<unsigned short>

; 768  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$Write@UPlayerID@@@BitStream@RakNet@@QAEXUPlayerID@@@Z ENDP ; RakNet::BitStream::Write<PlayerID>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ??$Write@_N@BitStream@RakNet@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_var$ = 8						; size = 1
??$Write@_N@BitStream@RakNet@@QAEX_N@Z PROC		; RakNet::BitStream::Write<bool>, COMDAT
; _this$ = ecx

; 754  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 755  : 		if ( var )

	movzx	eax, BYTE PTR _var$[ebp]
	test	eax, eax
	je	SHORT $LN2@Write

; 756  : 			Write1();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Write1@BitStream@RakNet@@QAEXXZ	; RakNet::BitStream::Write1

; 757  : 		else

	jmp	SHORT $LN3@Write
$LN2@Write:

; 758  : 			Write0();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Write0@BitStream@RakNet@@QAEXXZ	; RakNet::BitStream::Write0
$LN3@Write:

; 759  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$Write@_N@BitStream@RakNet@@QAEX_N@Z ENDP		; RakNet::BitStream::Write<bool>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ?GetData@BitStream@RakNet@@QBEPAEXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetData@BitStream@RakNet@@QBEPAEXZ PROC		; RakNet::BitStream::GetData, COMDAT
; _this$ = ecx

; 397  : 		inline unsigned char* GetData( void ) const {return data;}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetData@BitStream@RakNet@@QBEPAEXZ ENDP		; RakNet::BitStream::GetData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ?GetNumberOfUnreadBits@BitStream@RakNet@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetNumberOfUnreadBits@BitStream@RakNet@@QBEHXZ PROC	; RakNet::BitStream::GetNumberOfUnreadBits, COMDAT
; _this$ = ecx

; 382  : 		inline int GetNumberOfUnreadBits( void ) const {return numberOfBitsUsed - readOffset;}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR [ecx+8]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumberOfUnreadBits@BitStream@RakNet@@QBEHXZ ENDP	; RakNet::BitStream::GetNumberOfUnreadBits
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ?GetNumberOfBytesUsed@BitStream@RakNet@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetNumberOfBytesUsed@BitStream@RakNet@@QBEHXZ PROC	; RakNet::BitStream::GetNumberOfBytesUsed, COMDAT
; _this$ = ecx

; 373  : 		inline int GetNumberOfBytesUsed( void ) const {return BITS_TO_BYTES( numberOfBitsUsed );}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	add	eax, 7
	sar	eax, 3
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumberOfBytesUsed@BitStream@RakNet@@QBEHXZ ENDP	; RakNet::BitStream::GetNumberOfBytesUsed
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ?GetWriteOffset@BitStream@RakNet@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetWriteOffset@BitStream@RakNet@@QBEHXZ PROC		; RakNet::BitStream::GetWriteOffset, COMDAT
; _this$ = ecx

; 370  : 		inline int GetWriteOffset( void ) const {return numberOfBitsUsed;}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWriteOffset@BitStream@RakNet@@QBEHXZ ENDP		; RakNet::BitStream::GetWriteOffset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\bitstream.h
;	COMDAT ?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ PROC	; RakNet::BitStream::GetNumberOfBitsUsed, COMDAT
; _this$ = ecx

; 369  : 		inline int GetNumberOfBitsUsed( void ) const {return GetWriteOffset();}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetWriteOffset@BitStream@RakNet@@QBEHXZ ; RakNet::BitStream::GetWriteOffset
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumberOfBitsUsed@BitStream@RakNet@@QBEHXZ ENDP	; RakNet::BitStream::GetNumberOfBitsUsed
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\socketlayer.h
;	COMDAT ?Instance@SocketLayer@@SAPAV1@XZ
_TEXT	SEGMENT
?Instance@SocketLayer@@SAPAV1@XZ PROC			; SocketLayer::Instance, COMDAT

; 60   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 61   : 		return & I;

	mov	eax, OFFSET ?I@SocketLayer@@0V1@A	; SocketLayer::I

; 62   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Instance@SocketLayer@@SAPAV1@XZ ENDP			; SocketLayer::Instance
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GRakPeerInterface@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GRakPeerInterface@@UAEPAXI@Z PROC			; RakPeerInterface::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1RakPeerInterface@@UAE@XZ		; RakPeerInterface::~RakPeerInterface
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GRakPeerInterface@@UAEPAXI@Z ENDP			; RakPeerInterface::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0RakPeerInterface@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0RakPeerInterface@@QAE@XZ PROC			; RakPeerInterface::RakPeerInterface, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7RakPeerInterface@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0RakPeerInterface@@QAE@XZ ENDP			; RakPeerInterface::RakPeerInterface
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\rakpeerinterface.h
;	COMDAT ??1RakPeerInterface@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1RakPeerInterface@@UAE@XZ PROC			; RakPeerInterface::~RakPeerInterface, COMDAT
; _this$ = ecx

; 42   : 	virtual ~RakPeerInterface()	{}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7RakPeerInterface@@6B@
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1RakPeerInterface@@UAE@XZ ENDP			; RakPeerInterface::~RakPeerInterface
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\networktypes.h
;	COMDAT ??4PlayerID@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_input$ = 8						; size = 4
??4PlayerID@@QAEAAU0@ABU0@@Z PROC			; PlayerID::operator=, COMDAT
; _this$ = ecx

; 74   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 75   : 		binaryAddress = input.binaryAddress;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _input$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 76   : 		port = input.port;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _input$[ebp]
	mov	dx, WORD PTR [ecx+4]
	mov	WORD PTR [eax+4], dx

; 77   : 		return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 78   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4PlayerID@@QAEAAU0@ABU0@@Z ENDP			; PlayerID::operator=
_TEXT	ENDS
END
