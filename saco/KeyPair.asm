; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.31101.0 

	TITLE	Z:\sampsrc\02Xu1\saco\archive\KeyPair.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?ms_dwRSAKeySize@CKeyPair@@0KA			; CKeyPair::ms_dwRSAKeySize
_DATA	SEGMENT
?ms_dwRSAKeySize@CKeyPair@@0KA DD 0400H			; CKeyPair::ms_dwRSAKeySize
_DATA	ENDS
PUBLIC	??0CKeyPair@@QAE@PAVCCryptoContext@@@Z		; CKeyPair::CKeyPair
PUBLIC	??1CKeyPair@@QAE@XZ				; CKeyPair::~CKeyPair
PUBLIC	?LoadFromMemory@CKeyPair@@QAEXKPAEE@Z		; CKeyPair::LoadFromMemory
PUBLIC	?ReleaseKey@CKeyPair@@QAEXXZ			; CKeyPair::ReleaseKey
PUBLIC	?GetContainer@CKeyPair@@QAEKXZ			; CKeyPair::GetContainer
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	?GetProvider@CCryptoContext@@QAEKXZ:PROC	; CCryptoContext::GetProvider
EXTRN	?xCryptCallDestroyKey@@YGHK@Z:PROC		; xCryptCallDestroyKey
EXTRN	?xCryptCallImportKey@@YGHKPAEKKKPAK@Z:PROC	; xCryptCallImportKey
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\archive\keypair.cpp
;	COMDAT ?GetContainer@CKeyPair@@QAEKXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetContainer@CKeyPair@@QAEKXZ PROC			; CKeyPair::GetContainer, COMDAT
; _this$ = ecx

; 179  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 180  : 	return m_hCryptKey;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 181  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetContainer@CKeyPair@@QAEKXZ ENDP			; CKeyPair::GetContainer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\archive\keypair.cpp
;	COMDAT ?ReleaseKey@CKeyPair@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?ReleaseKey@CKeyPair@@QAEXXZ PROC			; CKeyPair::ReleaseKey, COMDAT
; _this$ = ecx

; 46   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 	// Destroy the key pair
; 48   : 	CRYPT(DestroyKey)(m_hCryptKey);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?xCryptCallDestroyKey@@YGHK@Z		; xCryptCallDestroyKey

; 49   : 	m_hCryptKey = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 50   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?ReleaseKey@CKeyPair@@QAEXXZ ENDP			; CKeyPair::ReleaseKey
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\archive\keypair.cpp
;	COMDAT ?LoadFromMemory@CKeyPair@@QAEXKPAEE@Z
_TEXT	SEGMENT
$T1 = -260						; size = 4
$T2 = -248						; size = 4
_hCryptProv$ = -44					; size = 4
_i$3 = -32						; size = 4
_pbKeyBlob$ = -20					; size = 4
_this$ = -8						; size = 4
_dwPubKeySize$ = 8					; size = 4
_pbPubKeyBlob$ = 12					; size = 4
_bytXORKey$ = 16					; size = 1
?LoadFromMemory@CKeyPair@@QAEXKPAEE@Z PROC		; CKeyPair::LoadFromMemory, COMDAT
; _this$ = ecx

; 153  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 154  : 	BYTE *pbKeyBlob;
; 155  : 
; 156  : 	// Un-XOR keys from memory
; 157  : 	if (bytXORKey != 0) {

	movzx	eax, BYTE PTR _bytXORKey$[ebp]
	test	eax, eax
	je	SHORT $LN6@LoadFromMe

; 158  : 		pbKeyBlob = new BYTE[dwPubKeySize];

	mov	eax, DWORD PTR _dwPubKeySize$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR _pbKeyBlob$[ebp], ecx

; 159  : 		for(DWORD i=0; i<dwPubKeySize; i++)

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN5@LoadFromMe
$LN4@LoadFromMe:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN5@LoadFromMe:
	mov	eax, DWORD PTR _i$3[ebp]
	cmp	eax, DWORD PTR _dwPubKeySize$[ebp]
	jae	SHORT $LN3@LoadFromMe

; 160  : 			pbKeyBlob[i] = pbPubKeyBlob[i] ^ bytXORKey;

	mov	eax, DWORD PTR _pbPubKeyBlob$[ebp]
	add	eax, DWORD PTR _i$3[ebp]
	movzx	ecx, BYTE PTR [eax]
	movzx	edx, BYTE PTR _bytXORKey$[ebp]
	xor	ecx, edx
	mov	eax, DWORD PTR _pbKeyBlob$[ebp]
	add	eax, DWORD PTR _i$3[ebp]
	mov	BYTE PTR [eax], cl
	jmp	SHORT $LN4@LoadFromMe
$LN3@LoadFromMe:
	jmp	SHORT $LN2@LoadFromMe
$LN6@LoadFromMe:

; 161  : 	} else {
; 162  : 		pbKeyBlob = pbPubKeyBlob;

	mov	eax, DWORD PTR _pbPubKeyBlob$[ebp]
	mov	DWORD PTR _pbKeyBlob$[ebp], eax
$LN2@LoadFromMe:

; 163  : 	}
; 164  : 
; 165  : 	// Import the key
; 166  : 	HCRYPTPROV hCryptProv = m_pContext->GetProvider();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetProvider@CCryptoContext@@QAEKXZ	; CCryptoContext::GetProvider
	mov	DWORD PTR _hCryptProv$[ebp], eax

; 167  : 	CRYPT(ImportKey)(hCryptProv, pbKeyBlob, dwPubKeySize, NULL, NULL, &m_hCryptKey);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _dwPubKeySize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbKeyBlob$[ebp]
	push	edx
	mov	eax, DWORD PTR _hCryptProv$[ebp]
	push	eax
	call	?xCryptCallImportKey@@YGHKPAEKKKPAK@Z	; xCryptCallImportKey

; 168  : 
; 169  : 	// Clean up
; 170  : 	if (bytXORKey != 0) {

	movzx	eax, BYTE PTR _bytXORKey$[ebp]
	test	eax, eax
	je	SHORT $LN7@LoadFromMe

; 171  : 		delete[] pbKeyBlob;

	mov	eax, DWORD PTR _pbKeyBlob$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@LoadFromMe:

; 172  : 	}
; 173  : 
; 174  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?LoadFromMemory@CKeyPair@@QAEXKPAEE@Z ENDP		; CKeyPair::LoadFromMemory
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\archive\keypair.cpp
;	COMDAT ??1CKeyPair@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1CKeyPair@@QAE@XZ PROC				; CKeyPair::~CKeyPair, COMDAT
; _this$ = ecx

; 27   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 28   : 	if (m_hCryptKey != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@CKeyPair

; 29   : 		ReleaseKey();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReleaseKey@CKeyPair@@QAEXXZ		; CKeyPair::ReleaseKey
$LN2@CKeyPair:

; 30   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1CKeyPair@@QAE@XZ ENDP				; CKeyPair::~CKeyPair
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\archive\keypair.cpp
;	COMDAT ??0CKeyPair@@QAE@PAVCCryptoContext@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pContext$ = 8						; size = 4
??0CKeyPair@@QAE@PAVCCryptoContext@@@Z PROC		; CKeyPair::CKeyPair, COMDAT
; _this$ = ecx

; 19   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 20   : 	m_pContext = pContext;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pContext$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 21   : 	m_hCryptKey = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 22   : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0CKeyPair@@QAE@PAVCCryptoContext@@@Z ENDP		; CKeyPair::CKeyPair
_TEXT	ENDS
END
