; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.31101.0 

	TITLE	Z:\sampsrc\02Xu1\saco\net\objectpool.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_BSS	SEGMENT
?s_ulongLastCall@?1??Process@CObjectPool@@QAEXXZ@4KA DD 01H DUP (?) ; `CObjectPool::Process'::`2'::s_ulongLastCall
_BSS	ENDS
PUBLIC	??0CObjectPool@@QAE@XZ				; CObjectPool::CObjectPool
PUBLIC	??1CObjectPool@@QAE@XZ				; CObjectPool::~CObjectPool
PUBLIC	?New@CObjectPool@@QAEHEHU_VECTOR@@0@Z		; CObjectPool::New
PUBLIC	?Delete@CObjectPool@@QAEHE@Z			; CObjectPool::Delete
PUBLIC	?GetSlotState@CObjectPool@@QAEHE@Z		; CObjectPool::GetSlotState
PUBLIC	?FindIDFromGtaPtr@CObjectPool@@QAEHPAU_ENTITY_TYPE@@@Z ; CObjectPool::FindIDFromGtaPtr
PUBLIC	?Process@CObjectPool@@QAEXXZ			; CObjectPool::Process
PUBLIC	__real@447a0000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	?Process@CObject@@QAEXM@Z:PROC			; CObject::Process
EXTRN	?NewObject@CGame@@QAEPAVCObject@@HMMMU_VECTOR@@@Z:PROC ; CGame::NewObject
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	?pGame@@3PAVCGame@@A:DWORD			; pGame
EXTRN	__fltused:DWORD
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\net\objectpool.cpp
;	COMDAT ?Process@CObjectPool@@QAEXXZ
_TEXT	SEGMENT
tv95 = -252						; size = 8
tv92 = -244						; size = 4
_i$1 = -41						; size = 1
_fElapsedTime$ = -32					; size = 4
_ulongTick$ = -20					; size = 4
_this$ = -8						; size = 4
?Process@CObjectPool@@QAEXXZ PROC			; CObjectPool::Process, COMDAT
; _this$ = ecx

; 78   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 79   : 	static unsigned long s_ulongLastCall = 0;
; 80   : 	if (!s_ulongLastCall) s_ulongLastCall = GetTickCount();

	cmp	DWORD PTR ?s_ulongLastCall@?1??Process@CObjectPool@@QAEXXZ@4KA, 0
	jne	SHORT $LN5@Process
	mov	esi, esp
	call	DWORD PTR __imp__GetTickCount@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR ?s_ulongLastCall@?1??Process@CObjectPool@@QAEXXZ@4KA, eax
$LN5@Process:

; 81   : 	unsigned long ulongTick = GetTickCount();

	mov	esi, esp
	call	DWORD PTR __imp__GetTickCount@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ulongTick$[ebp], eax

; 82   : 	float fElapsedTime = ((float)(ulongTick - s_ulongLastCall)) / 1000.0f;

	mov	eax, DWORD PTR _ulongTick$[ebp]
	sub	eax, DWORD PTR ?s_ulongLastCall@?1??Process@CObjectPool@@QAEXXZ@4KA
	mov	DWORD PTR tv92[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv92[ebp]
	mov	ecx, DWORD PTR tv92[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv95[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv95[ebp]
	divss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR _fElapsedTime$[ebp], xmm0

; 83   : 	// Get elapsed time in seconds
; 84   : 	for (BYTE i = 0; i < MAX_OBJECTS; i++)

	mov	BYTE PTR _i$1[ebp], 0
	jmp	SHORT $LN4@Process
$LN3@Process:
	mov	al, BYTE PTR _i$1[ebp]
	add	al, 1
	mov	BYTE PTR _i$1[ebp], al
$LN4@Process:
	movzx	eax, BYTE PTR _i$1[ebp]
	cmp	eax, 255				; 000000ffH
	jge	SHORT $LN2@Process

; 85   : 	{
; 86   : 		if (m_bObjectSlotState[i]) m_pObjects[i]->Process(fElapsedTime);

	movzx	eax, BYTE PTR _i$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $LN1@Process
	push	ecx
	movss	xmm0, DWORD PTR _fElapsedTime$[ebp]
	movss	DWORD PTR [esp], xmm0
	movzx	eax, BYTE PTR _i$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+1020]
	call	?Process@CObject@@QAEXM@Z		; CObject::Process
$LN1@Process:

; 87   : 	}

	jmp	SHORT $LN3@Process
$LN2@Process:

; 88   : 	s_ulongLastCall = ulongTick;

	mov	eax, DWORD PTR _ulongTick$[ebp]
	mov	DWORD PTR ?s_ulongLastCall@?1??Process@CObjectPool@@QAEXXZ@4KA, eax

; 89   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Process@CObjectPool@@QAEXXZ ENDP			; CObjectPool::Process
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\net\objectpool.cpp
;	COMDAT ?FindIDFromGtaPtr@CObjectPool@@QAEHPAU_ENTITY_TYPE@@@Z
_TEXT	SEGMENT
_x$ = -20						; size = 4
_this$ = -8						; size = 4
_pGtaObject$ = 8					; size = 4
?FindIDFromGtaPtr@CObjectPool@@QAEHPAU_ENTITY_TYPE@@@Z PROC ; CObjectPool::FindIDFromGtaPtr, COMDAT
; _this$ = ecx

; 66   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 67   : 	int x=1;

	mov	DWORD PTR _x$[ebp], 1
$LN3@FindIDFrom:

; 68   : 
; 69   : 	while(x!=MAX_OBJECTS) {

	cmp	DWORD PTR _x$[ebp], 255			; 000000ffH
	je	SHORT $LN2@FindIDFrom

; 70   : 		if(pGtaObject == m_pObjects[x]->m_pEntity) return x;

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+1020]
	mov	eax, DWORD PTR _pGtaObject$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN1@FindIDFrom
	mov	eax, DWORD PTR _x$[ebp]
	jmp	SHORT $LN4@FindIDFrom
$LN1@FindIDFrom:

; 71   : 		x++;

	mov	eax, DWORD PTR _x$[ebp]
	add	eax, 1
	mov	DWORD PTR _x$[ebp], eax

; 72   : 	}

	jmp	SHORT $LN3@FindIDFrom
$LN2@FindIDFrom:

; 73   : 
; 74   : 	return (-1);

	or	eax, -1
$LN4@FindIDFrom:

; 75   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?FindIDFromGtaPtr@CObjectPool@@QAEHPAU_ENTITY_TYPE@@@Z ENDP ; CObjectPool::FindIDFromGtaPtr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\net\objectpool.h
;	COMDAT ?GetSlotState@CObjectPool@@QAEHE@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_byteObjectID$ = 8					; size = 1
?GetSlotState@CObjectPool@@QAEHE@Z PROC			; CObjectPool::GetSlotState, COMDAT
; _this$ = ecx

; 25   : 	BOOL GetSlotState(BYTE byteObjectID) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 26   : 		if(byteObjectID > MAX_OBJECTS) { return FALSE; }

	movzx	eax, BYTE PTR _byteObjectID$[ebp]
	cmp	eax, 255				; 000000ffH
	jle	SHORT $LN1@GetSlotSta
	xor	eax, eax
	jmp	SHORT $LN2@GetSlotSta
$LN1@GetSlotSta:

; 27   : 		return m_bObjectSlotState[byteObjectID];

	movzx	eax, BYTE PTR _byteObjectID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
$LN2@GetSlotSta:

; 28   : 	};

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetSlotState@CObjectPool@@QAEHE@Z ENDP			; CObjectPool::GetSlotState
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\net\objectpool.cpp
;	COMDAT ?Delete@CObjectPool@@QAEHE@Z
_TEXT	SEGMENT
tv91 = -232						; size = 4
$T1 = -224						; size = 4
$T2 = -212						; size = 4
_this$ = -8						; size = 4
_byteObjectID$ = 8					; size = 1
?Delete@CObjectPool@@QAEHE@Z PROC			; CObjectPool::Delete, COMDAT
; _this$ = ecx

; 31   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 32   : 	if(!GetSlotState(byteObjectID) || !m_pObjects[byteObjectID])

	movzx	eax, BYTE PTR _byteObjectID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSlotState@CObjectPool@@QAEHE@Z	; CObjectPool::GetSlotState
	test	eax, eax
	je	SHORT $LN1@Delete
	movzx	eax, BYTE PTR _byteObjectID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4+1020], 0
	jne	SHORT $LN2@Delete
$LN1@Delete:

; 33   : 	{
; 34   : 		return FALSE; // Vehicle already deleted or not used.

	xor	eax, eax
	jmp	SHORT $LN3@Delete
$LN2@Delete:

; 35   : 	}
; 36   : 
; 37   : 	m_bObjectSlotState[byteObjectID] = FALSE;

	movzx	eax, BYTE PTR _byteObjectID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4], 0

; 38   : 	delete m_pObjects[byteObjectID];

	movzx	eax, BYTE PTR _byteObjectID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+1020]
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN5@Delete
	mov	esi, esp
	push	1
	mov	ecx, DWORD PTR $T1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv91[ebp], eax
	jmp	SHORT $LN6@Delete
$LN5@Delete:
	mov	DWORD PTR tv91[ebp], 0
$LN6@Delete:

; 39   : 	m_pObjects[byteObjectID] = NULL;

	movzx	eax, BYTE PTR _byteObjectID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+1020], 0

; 40   : 
; 41   : 	return TRUE;

	mov	eax, 1
$LN3@Delete:

; 42   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Delete@CObjectPool@@QAEHE@Z ENDP			; CObjectPool::Delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\net\objectpool.cpp
;	COMDAT ?New@CObjectPool@@QAEHEHU_VECTOR@@0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_byteObjectID$ = 8					; size = 1
_iModel$ = 12						; size = 4
_vecPos$ = 16						; size = 12
_vecRot$ = 28						; size = 12
?New@CObjectPool@@QAEHEHU_VECTOR@@0@Z PROC		; CObjectPool::New, COMDAT
; _this$ = ecx

; 45   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 46   : 	if (m_pObjects[byteObjectID] != NULL)

	movzx	eax, BYTE PTR _byteObjectID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4+1020], 0
	je	SHORT $LN2@New

; 47   : 	{
; 48   : 		Delete(byteObjectID);

	movzx	eax, BYTE PTR _byteObjectID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Delete@CObjectPool@@QAEHE@Z		; CObjectPool::Delete
$LN2@New:

; 49   : 	}
; 50   : 
; 51   : 	m_pObjects[byteObjectID] = pGame->NewObject(iModel, vecPos.X, vecPos.Y, vecPos.Z, vecRot);

	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	ecx, DWORD PTR _vecRot$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _vecRot$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _vecRot$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	push	ecx
	movss	xmm0, DWORD PTR _vecPos$[ebp+8]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _vecPos$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _vecPos$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _iModel$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?pGame@@3PAVCGame@@A	; pGame
	call	?NewObject@CGame@@QAEPAVCObject@@HMMMU_VECTOR@@@Z ; CGame::NewObject
	movzx	ecx, BYTE PTR _byteObjectID$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+1020], eax

; 52   : 
; 53   : 	if (m_pObjects[byteObjectID])

	movzx	eax, BYTE PTR _byteObjectID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4+1020], 0
	je	SHORT $LN1@New

; 54   : 	{
; 55   : 		m_bObjectSlotState[byteObjectID] = TRUE;

	movzx	eax, BYTE PTR _byteObjectID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4], 1

; 56   : 
; 57   : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $LN3@New
$LN1@New:

; 58   : 	}
; 59   : 
; 60   : 	return FALSE; // Will only be called if m_pObjects[byteObjectID] is null

	xor	eax, eax
$LN3@New:

; 61   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?New@CObjectPool@@QAEHEHU_VECTOR@@0@Z ENDP		; CObjectPool::New
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\net\objectpool.cpp
;	COMDAT ??1CObjectPool@@QAE@XZ
_TEXT	SEGMENT
_i$1 = -20						; size = 4
_this$ = -8						; size = 4
??1CObjectPool@@QAE@XZ PROC				; CObjectPool::~CObjectPool, COMDAT
; _this$ = ecx

; 23   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 24   : 	for(int i = 0; i < MAX_OBJECTS; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN3@CObjectPoo
$LN2@CObjectPoo:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN3@CObjectPoo:
	cmp	DWORD PTR _i$1[ebp], 255		; 000000ffH
	jge	SHORT $LN4@CObjectPoo

; 25   : 	{
; 26   : 		Delete(i);

	movzx	eax, BYTE PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Delete@CObjectPool@@QAEHE@Z		; CObjectPool::Delete

; 27   : 	}

	jmp	SHORT $LN2@CObjectPoo
$LN4@CObjectPoo:

; 28   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1CObjectPool@@QAE@XZ ENDP				; CObjectPool::~CObjectPool
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\net\objectpool.cpp
;	COMDAT ??0CObjectPool@@QAE@XZ
_TEXT	SEGMENT
_byteObjectID$1 = -17					; size = 1
_this$ = -8						; size = 4
??0CObjectPool@@QAE@XZ PROC				; CObjectPool::CObjectPool, COMDAT
; _this$ = ecx

; 14   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 15   : 	for(BYTE byteObjectID = 0; byteObjectID < MAX_OBJECTS; byteObjectID++)

	mov	BYTE PTR _byteObjectID$1[ebp], 0
	jmp	SHORT $LN3@CObjectPoo
$LN2@CObjectPoo:
	mov	al, BYTE PTR _byteObjectID$1[ebp]
	add	al, 1
	mov	BYTE PTR _byteObjectID$1[ebp], al
$LN3@CObjectPoo:
	movzx	eax, BYTE PTR _byteObjectID$1[ebp]
	cmp	eax, 255				; 000000ffH
	jge	SHORT $LN4@CObjectPoo

; 16   : 	{
; 17   : 		m_bObjectSlotState[byteObjectID]	= FALSE;

	movzx	eax, BYTE PTR _byteObjectID$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4], 0

; 18   : 		m_pObjects[byteObjectID]			= NULL;

	movzx	eax, BYTE PTR _byteObjectID$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+1020], 0

; 19   : 	}

	jmp	SHORT $LN2@CObjectPoo
$LN4@CObjectPoo:

; 20   : };

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CObjectPool@@QAE@XZ ENDP				; CObjectPool::CObjectPool
_TEXT	ENDS
END
