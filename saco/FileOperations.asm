; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.31101.0 

	TITLE	Z:\sampsrc\02Xu1\raknet\FileOperations.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?WriteFileWithDirectories@@YA_NPBDPADI@Z	; WriteFileWithDirectories
PUBLIC	?IsSlash@@YA_NE@Z				; IsSlash
PUBLIC	?AddSlash@@YAXPAD@Z				; AddSlash
PUBLIC	?QuoteIfSpaces@@YAXPAD@Z			; QuoteIfSpaces
PUBLIC	?DirectoryExists@@YA_NPBD@Z			; DirectoryExists
PUBLIC	??_C@_02GMLFBBN@wb?$AA@				; `string'
PUBLIC	??_C@_03EMIMMIHL@?$CK?4?$CK?$AA@		; `string'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_fclose:PROC
EXTRN	_fopen:PROC
EXTRN	_fwrite:PROC
EXTRN	_strcpy:PROC
EXTRN	_strcat:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	__mkdir:PROC
EXTRN	__findclose:PROC
EXTRN	__findfirst64i32:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_03EMIMMIHL@?$CK?4?$CK?$AA@
CONST	SEGMENT
??_C@_03EMIMMIHL@?$CK?4?$CK?$AA@ DB '*.*', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb?$AA@
CONST	SEGMENT
??_C@_02GMLFBBN@wb?$AA@ DB 'wb', 00H			; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\fileoperations.cpp
;	COMDAT ?DirectoryExists@@YA_NPBD@Z
_TEXT	SEGMENT
_baseDirWithStars$ = -884				; size = 560
_dir$ = -316						; size = 4
_fileInfo$ = -304					; size = 296
__$ArrayPad$ = -4					; size = 4
_directory$ = 8						; size = 4
?DirectoryExists@@YA_NPBD@Z PROC			; DirectoryExists, COMDAT

; 114  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1080				; 00000438H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-1080]
	mov	ecx, 270				; 0000010eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 115  : 	_finddata_t fileInfo;
; 116  : 	intptr_t dir;
; 117  : 	char baseDirWithStars[560];
; 118  : 	strcpy(baseDirWithStars, directory);

	mov	eax, DWORD PTR _directory$[ebp]
	push	eax
	lea	ecx, DWORD PTR _baseDirWithStars$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 119  : 	AddSlash(baseDirWithStars);

	lea	eax, DWORD PTR _baseDirWithStars$[ebp]
	push	eax
	call	?AddSlash@@YAXPAD@Z			; AddSlash
	add	esp, 4

; 120  : 	strcat(baseDirWithStars, "*.*");

	push	OFFSET ??_C@_03EMIMMIHL@?$CK?4?$CK?$AA@
	lea	eax, DWORD PTR _baseDirWithStars$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 121  : 	dir=_findfirst(baseDirWithStars, &fileInfo );

	lea	eax, DWORD PTR _fileInfo$[ebp]
	push	eax
	lea	ecx, DWORD PTR _baseDirWithStars$[ebp]
	push	ecx
	call	__findfirst64i32
	add	esp, 8
	mov	DWORD PTR _dir$[ebp], eax

; 122  : 	if (dir==-1)

	cmp	DWORD PTR _dir$[ebp], -1
	jne	SHORT $LN1@DirectoryE

; 123  : 		return false;

	xor	al, al
	jmp	SHORT $LN2@DirectoryE
$LN1@DirectoryE:

; 124  : 	_findclose(dir);

	mov	eax, DWORD PTR _dir$[ebp]
	push	eax
	call	__findclose
	add	esp, 4

; 125  : 	return true;

	mov	al, 1
$LN2@DirectoryE:

; 126  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@DirectoryE
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 1080				; 00000438H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN7@DirectoryE:
	DD	2
	DD	$LN6@DirectoryE
$LN6@DirectoryE:
	DD	-304					; fffffed0H
	DD	296					; 00000128H
	DD	$LN4@DirectoryE
	DD	-884					; fffffc8cH
	DD	560					; 00000230H
	DD	$LN5@DirectoryE
$LN5@DirectoryE:
	DB	98					; 00000062H
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	68					; 00000044H
	DB	105					; 00000069H
	DB	114					; 00000072H
	DB	87					; 00000057H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	115					; 00000073H
	DB	0
$LN4@DirectoryE:
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	102					; 00000066H
	DB	111					; 0000006fH
	DB	0
?DirectoryExists@@YA_NPBD@Z ENDP			; DirectoryExists
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\fileoperations.cpp
;	COMDAT ?QuoteIfSpaces@@YAXPAD@Z
_TEXT	SEGMENT
_len$1 = -32						; size = 4
_hasSpace$ = -17					; size = 1
_i$ = -8						; size = 4
_str$ = 8						; size = 4
?QuoteIfSpaces@@YAXPAD@Z PROC				; QuoteIfSpaces, COMDAT

; 128  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 129  : 	unsigned i;
; 130  : 	bool hasSpace=false;

	mov	BYTE PTR _hasSpace$[ebp], 0

; 131  : 	for (i=0; str[i]; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN5@QuoteIfSpa
$LN4@QuoteIfSpa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN5@QuoteIfSpa:
	mov	eax, DWORD PTR _str$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@QuoteIfSpa

; 132  : 	{
; 133  : 		if (str[i]==' ')

	mov	eax, DWORD PTR _str$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN2@QuoteIfSpa

; 134  : 		{
; 135  : 			hasSpace=true;

	mov	BYTE PTR _hasSpace$[ebp], 1

; 136  : 			break;

	jmp	SHORT $LN3@QuoteIfSpa
$LN2@QuoteIfSpa:

; 137  : 		}
; 138  : 	}

	jmp	SHORT $LN4@QuoteIfSpa
$LN3@QuoteIfSpa:

; 139  : 	if (hasSpace)

	movzx	eax, BYTE PTR _hasSpace$[ebp]
	test	eax, eax
	je	SHORT $LN6@QuoteIfSpa

; 140  : 	{
; 141  : 		int len=(int)strlen(str);

	mov	eax, DWORD PTR _str$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _len$1[ebp], eax

; 142  : 		memmove(str+1, str, len);

	mov	eax, DWORD PTR _len$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _str$[ebp]
	push	ecx
	mov	edx, DWORD PTR _str$[ebp]
	add	edx, 1
	push	edx
	call	_memmove
	add	esp, 12					; 0000000cH

; 143  : 		str[0]='\"';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _str$[ebp]
	mov	BYTE PTR [edx+ecx], 34			; 00000022H

; 144  : 		str[len]='\"';

	mov	eax, DWORD PTR _str$[ebp]
	add	eax, DWORD PTR _len$1[ebp]
	mov	BYTE PTR [eax], 34			; 00000022H

; 145  : 		str[len+1]=0;

	mov	eax, DWORD PTR _str$[ebp]
	add	eax, DWORD PTR _len$1[ebp]
	mov	BYTE PTR [eax+1], 0
$LN6@QuoteIfSpa:

; 146  : 	}
; 147  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?QuoteIfSpaces@@YAXPAD@Z ENDP				; QuoteIfSpaces
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\fileoperations.cpp
;	COMDAT ?AddSlash@@YAXPAD@Z
_TEXT	SEGMENT
_lastCharIndex$ = -8					; size = 4
_input$ = 8						; size = 4
?AddSlash@@YAXPAD@Z PROC				; AddSlash, COMDAT

; 100  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 101  : 	if (input==0 || input[0]==0)

	cmp	DWORD PTR _input$[ebp], 0
	je	SHORT $LN4@AddSlash
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _input$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN5@AddSlash
$LN4@AddSlash:

; 102  : 		return;

	jmp	SHORT $LN6@AddSlash
$LN5@AddSlash:

; 103  : 
; 104  : 	int lastCharIndex=(int) strlen(input)-1;

	mov	eax, DWORD PTR _input$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	sub	eax, 1
	mov	DWORD PTR _lastCharIndex$[ebp], eax

; 105  : 	if (input[lastCharIndex]=='\\')

	mov	eax, DWORD PTR _input$[ebp]
	add	eax, DWORD PTR _lastCharIndex$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	jne	SHORT $LN3@AddSlash

; 106  : 		input[lastCharIndex]='/';

	mov	eax, DWORD PTR _input$[ebp]
	add	eax, DWORD PTR _lastCharIndex$[ebp]
	mov	BYTE PTR [eax], 47			; 0000002fH
	jmp	SHORT $LN6@AddSlash
$LN3@AddSlash:

; 107  : 	else if (input[lastCharIndex]!='/')

	mov	eax, DWORD PTR _input$[ebp]
	add	eax, DWORD PTR _lastCharIndex$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	je	SHORT $LN6@AddSlash

; 108  : 	{
; 109  : 		input[lastCharIndex+1]='/';

	mov	eax, DWORD PTR _input$[ebp]
	add	eax, DWORD PTR _lastCharIndex$[ebp]
	mov	BYTE PTR [eax+1], 47			; 0000002fH

; 110  : 		input[lastCharIndex+2]=0;

	mov	eax, DWORD PTR _input$[ebp]
	add	eax, DWORD PTR _lastCharIndex$[ebp]
	mov	BYTE PTR [eax+2], 0
$LN6@AddSlash:

; 111  : 	}
; 112  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?AddSlash@@YAXPAD@Z ENDP				; AddSlash
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\fileoperations.cpp
;	COMDAT ?IsSlash@@YA_NE@Z
_TEXT	SEGMENT
tv68 = -196						; size = 4
_c$ = 8							; size = 1
?IsSlash@@YA_NE@Z PROC					; IsSlash, COMDAT

; 95   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 49					; 00000031H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 96   : 	return c=='/' || c=='\\';

	movzx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN3@IsSlash
	movzx	ecx, BYTE PTR _c$[ebp]
	cmp	ecx, 92					; 0000005cH
	je	SHORT $LN3@IsSlash
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@IsSlash
$LN3@IsSlash:
	mov	DWORD PTR tv68[ebp], 1
$LN4@IsSlash:
	mov	al, BYTE PTR tv68[ebp]

; 97   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSlash@@YA_NE@Z ENDP					; IsSlash
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\raknet\fileoperations.cpp
;	COMDAT ?WriteFileWithDirectories@@YA_NPBDPADI@Z
_TEXT	SEGMENT
$T1 = -260						; size = 4
$T2 = -248						; size = 4
$T3 = -236						; size = 4
_pathCopy$ = -32					; size = 4
_fp$ = -20						; size = 4
_index$ = -8						; size = 4
_path$ = 8						; size = 4
_data$ = 12						; size = 4
_dataLength$ = 16					; size = 4
?WriteFileWithDirectories@@YA_NPBDPADI@Z PROC		; WriteFileWithDirectories, COMDAT

; 18   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-264]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 19   : 	int index;
; 20   : 	FILE *fp;
; 21   : 	char *pathCopy;
; 22   : #ifndef _WIN32
; 23   : 
; 24   : 	char *systemCommand;
; 25   : #endif
; 26   : 
; 27   : 	if ( path == 0 || path[ 0 ] == 0 )

	cmp	DWORD PTR _path$[ebp], 0
	je	SHORT $LN8@WriteFileW
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _path$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN9@WriteFileW
$LN8@WriteFileW:

; 28   : 		return false;

	xor	al, al
	jmp	$LN10@WriteFileW
$LN9@WriteFileW:

; 29   : 
; 30   : #ifndef _WIN32
; 31   : 
; 32   : 	systemCommand = new char [ strlen( path ) + 1 + 6 ];
; 33   : 
; 34   : #endif
; 35   : 
; 36   : 	pathCopy = new char [ strlen( path ) + 1 ];

	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR _pathCopy$[ebp], ecx

; 37   : 
; 38   : 	strcpy( pathCopy, path );

	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pathCopy$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 39   : 
; 40   : 	index = 0;

	mov	DWORD PTR _index$[ebp], 0
$LN7@WriteFileW:

; 41   : 
; 42   : 	while ( pathCopy[ index ] )

	mov	eax, DWORD PTR _pathCopy$[ebp]
	add	eax, DWORD PTR _index$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN6@WriteFileW

; 43   : 	{
; 44   : 		if ( pathCopy[ index ] == '/' || pathCopy[ index ] == '\\')

	mov	eax, DWORD PTR _pathCopy$[ebp]
	add	eax, DWORD PTR _index$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	je	SHORT $LN4@WriteFileW
	mov	eax, DWORD PTR _pathCopy$[ebp]
	add	eax, DWORD PTR _index$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	jne	SHORT $LN5@WriteFileW
$LN4@WriteFileW:

; 45   : 		{
; 46   : 			pathCopy[ index ] = 0;

	mov	eax, DWORD PTR _pathCopy$[ebp]
	add	eax, DWORD PTR _index$[ebp]
	mov	BYTE PTR [eax], 0

; 47   : #ifdef _WIN32
; 48   : 			_mkdir( pathCopy );

	mov	eax, DWORD PTR _pathCopy$[ebp]
	push	eax
	call	__mkdir
	add	esp, 4

; 49   : #else
; 50   : 
; 51   : 			mkdir( pathCopy, 0744 );
; 52   : #endif
; 53   : 
; 54   : 			pathCopy[ index ] = '/';

	mov	eax, DWORD PTR _pathCopy$[ebp]
	add	eax, DWORD PTR _index$[ebp]
	mov	BYTE PTR [eax], 47			; 0000002fH
$LN5@WriteFileW:

; 55   : 		}
; 56   : 
; 57   : 		index++;

	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 1
	mov	DWORD PTR _index$[ebp], eax

; 58   : 	}

	jmp	SHORT $LN7@WriteFileW
$LN6@WriteFileW:

; 59   : 
; 60   : 	if (data && dataLength)

	cmp	DWORD PTR _data$[ebp], 0
	je	SHORT $LN3@WriteFileW
	cmp	DWORD PTR _dataLength$[ebp], 0
	je	SHORT $LN3@WriteFileW

; 61   : 	{
; 62   : 		fp = fopen( path, "wb" );

	push	OFFSET ??_C@_02GMLFBBN@wb?$AA@
	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax

; 63   : 
; 64   : 		if ( fp == 0 )

	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN2@WriteFileW

; 65   : 		{
; 66   : 			delete [] pathCopy;

	mov	eax, DWORD PTR _pathCopy$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 67   : #ifndef _WIN32
; 68   : 			delete [] systemCommand;
; 69   : #endif
; 70   : 			return false;

	xor	al, al
	jmp	SHORT $LN10@WriteFileW
$LN2@WriteFileW:

; 71   : 		}
; 72   : 
; 73   : 		fwrite( data, 1, dataLength, fp );

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dataLength$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _data$[ebp]
	push	edx
	call	_fwrite
	add	esp, 16					; 00000010H

; 74   : 
; 75   : 		fclose( fp );

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 76   : 	}
; 77   : 	else

	jmp	SHORT $LN1@WriteFileW
$LN3@WriteFileW:

; 78   : 	{
; 79   : #ifdef _WIN32
; 80   : 		_mkdir( pathCopy );

	mov	eax, DWORD PTR _pathCopy$[ebp]
	push	eax
	call	__mkdir
	add	esp, 4
$LN1@WriteFileW:

; 81   : #else
; 82   : 		mkdir( pathCopy, 0744 );
; 83   : #endif
; 84   : 	}
; 85   : 
; 86   : 	delete [] pathCopy;

	mov	eax, DWORD PTR _pathCopy$[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 87   : #ifndef _WIN32
; 88   : 	delete [] systemCommand;
; 89   : #endif
; 90   : 
; 91   : 
; 92   : 	return true;

	mov	al, 1
$LN10@WriteFileW:

; 93   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?WriteFileWithDirectories@@YA_NPBDPADI@Z ENDP		; WriteFileWithDirectories
_TEXT	ENDS
END
