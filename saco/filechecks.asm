; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.31101.0 

	TITLE	Z:\sampsrc\02Xu1\saco\filechecks.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?IsCheckableFile@@YAHPAD@Z			; IsCheckableFile
PUBLIC	?CheckFileHash@@YAXHPAX@Z			; CheckFileHash
PUBLIC	?GetFileNameHash@@YAHPAD@Z			; GetFileNameHash
EXTRN	_strlen:PROC
EXTRN	?MD5Init@@YAXPAUMD5Context@@@Z:PROC		; MD5Init
EXTRN	?MD5Update@@YAXPAUMD5Context@@PBEI@Z:PROC	; MD5Update
EXTRN	?MD5Final@@YAXQAEPAUMD5Context@@@Z:PROC		; MD5Final
EXTRN	?Arch_SetFilePointer@@YGKPAXJPAJK@Z:PROC	; Arch_SetFilePointer
EXTRN	?Arch_ReadFile@@YGHPAX0KPAKPAU_OVERLAPPED@@@Z:PROC ; Arch_ReadFile
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	?pFileSystem@@3PAVCFileSystem@@A:DWORD		; pFileSystem
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\filechecks.cpp
;	COMDAT ?GetFileNameHash@@YAHPAD@Z
_TEXT	SEGMENT
tv75 = -232						; size = 4
_c$1 = -29						; size = 1
_len$ = -20						; size = 4
_dwHash$ = -8						; size = 4
_szFileName$ = 8					; size = 4
?GetFileNameHash@@YAHPAD@Z PROC				; GetFileNameHash, COMDAT

; 139  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 140  : 	// Based on a Jenkins hash
; 141  : 	int dwHash = 0;

	mov	DWORD PTR _dwHash$[ebp], 0

; 142  : 	char* len = strlen(szFileName) + szFileName;

	mov	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, DWORD PTR _szFileName$[ebp]
	mov	DWORD PTR _len$[ebp], eax
$LN2@GetFileNam:

; 143  : 	while (szFileName < len)

	mov	eax, DWORD PTR _szFileName$[ebp]
	cmp	eax, DWORD PTR _len$[ebp]
	jae	SHORT $LN1@GetFileNam

; 144  : 	{
; 145  : 		char c = *szFileName;

	mov	eax, DWORD PTR _szFileName$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _c$1[ebp], cl

; 146  : 		dwHash += (c > 'Z' || c < 'A') ? (c) : (c | 0x20); // Lower case

	movsx	eax, BYTE PTR _c$1[ebp]
	cmp	eax, 90					; 0000005aH
	jg	SHORT $LN5@GetFileNam
	movsx	ecx, BYTE PTR _c$1[ebp]
	cmp	ecx, 65					; 00000041H
	jl	SHORT $LN5@GetFileNam
	movsx	edx, BYTE PTR _c$1[ebp]
	or	edx, 32					; 00000020H
	mov	DWORD PTR tv75[ebp], edx
	jmp	SHORT $LN6@GetFileNam
$LN5@GetFileNam:
	movsx	eax, BYTE PTR _c$1[ebp]
	mov	DWORD PTR tv75[ebp], eax
$LN6@GetFileNam:
	mov	ecx, DWORD PTR _dwHash$[ebp]
	add	ecx, DWORD PTR tv75[ebp]
	mov	DWORD PTR _dwHash$[ebp], ecx

; 147  : 		dwHash += (dwHash << 10);

	mov	eax, DWORD PTR _dwHash$[ebp]
	shl	eax, 10					; 0000000aH
	add	eax, DWORD PTR _dwHash$[ebp]
	mov	DWORD PTR _dwHash$[ebp], eax

; 148  : 		dwHash ^= (dwHash >> 6);

	mov	eax, DWORD PTR _dwHash$[ebp]
	sar	eax, 6
	xor	eax, DWORD PTR _dwHash$[ebp]
	mov	DWORD PTR _dwHash$[ebp], eax

; 149  : 		szFileName++;

	mov	eax, DWORD PTR _szFileName$[ebp]
	add	eax, 1
	mov	DWORD PTR _szFileName$[ebp], eax

; 150  : 	}

	jmp	SHORT $LN2@GetFileNam
$LN1@GetFileNam:

; 151  : 	dwHash += (dwHash << 3);

	mov	eax, DWORD PTR _dwHash$[ebp]
	mov	ecx, DWORD PTR _dwHash$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR _dwHash$[ebp], edx

; 152  : 	dwHash ^= (dwHash >> 11);

	mov	eax, DWORD PTR _dwHash$[ebp]
	sar	eax, 11					; 0000000bH
	xor	eax, DWORD PTR _dwHash$[ebp]
	mov	DWORD PTR _dwHash$[ebp], eax

; 153  : 	dwHash += (dwHash << 15);

	mov	eax, DWORD PTR _dwHash$[ebp]
	shl	eax, 15					; 0000000fH
	add	eax, DWORD PTR _dwHash$[ebp]
	mov	DWORD PTR _dwHash$[ebp], eax

; 154  : 	return dwHash;

	mov	eax, DWORD PTR _dwHash$[ebp]

; 155  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFileNameHash@@YAHPAD@Z ENDP				; GetFileNameHash
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\filechecks.cpp
;	COMDAT ?CheckFileHash@@YAXHPAX@Z
_TEXT	SEGMENT
_lDistanceHigh$1 = -1272				; size = 4
_byteDigest$2 = -1260					; size = 16
_dwDataToRead$3 = -1236					; size = 4
_mdCTX$4 = -1224					; size = 88
_szBuffer$5 = -1128					; size = 1024
_dwWasRead$6 = -96					; size = 4
_mdHash$7 = -84						; size = 4
_pItem$8 = -72						; size = 4
_i$9 = -57						; size = 1
_bFound$10 = -48					; size = 4
_byteCount$11 = -33					; size = 1
_pbData$12 = -24					; size = 4
_dwFileIndex$ = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
_dwFileHash$ = 8					; size = 4
_hFile$ = 12						; size = 4
?CheckFileHash@@YAXHPAX@Z PROC				; CheckFileHash, COMDAT

; 52   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1468				; 000005bcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-1468]
	mov	ecx, 367				; 0000016fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 53   : 	DWORD dwFileIndex = ((CArchiveFS*)pFileSystem)->GetFileIndex(0xa848b69a);

	mov	esi, esp
	push	-1471629670				; a848b69aH
	mov	eax, DWORD PTR ?pFileSystem@@3PAVCFileSystem@@A ; pFileSystem
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?pFileSystem@@3PAVCFileSystem@@A ; pFileSystem
	mov	eax, DWORD PTR [edx+28]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _dwFileIndex$[ebp], eax

; 54   : 	
; 55   : 	if (dwFileIndex != FS_INVALID_FILE)

	cmp	DWORD PTR _dwFileIndex$[ebp], -1
	je	$LN14@CheckFileH

; 56   : 	{
; 57   : 
; 58   : 		BYTE *pbData = pFileSystem->GetFileData(dwFileIndex);

	mov	esi, esp
	mov	eax, DWORD PTR _dwFileIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?pFileSystem@@3PAVCFileSystem@@A ; pFileSystem
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?pFileSystem@@3PAVCFileSystem@@A ; pFileSystem
	mov	eax, DWORD PTR [edx+20]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pbData$12[ebp], eax

; 59   : 		BYTE byteCount = *pbData++; // Get and jump over header

	mov	eax, DWORD PTR _pbData$12[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _byteCount$11[ebp], cl
	mov	edx, DWORD PTR _pbData$12[ebp]
	add	edx, 1
	mov	DWORD PTR _pbData$12[ebp], edx

; 60   : 		
; 61   : 		// Search the tree
; 62   : 		BOOL bFound = FALSE;

	mov	DWORD PTR _bFound$10[ebp], 0

; 63   : 		BYTE i = 0;

	mov	BYTE PTR _i$9[ebp], 0
$LN12@CheckFileH:

; 64   : 		BINARY_TREE* pItem;
; 65   : 
; 66   : 		while (!bFound && i < byteCount)

	cmp	DWORD PTR _bFound$10[ebp], 0
	jne	SHORT $LN11@CheckFileH
	movzx	eax, BYTE PTR _i$9[ebp]
	movzx	ecx, BYTE PTR _byteCount$11[ebp]
	cmp	eax, ecx
	jge	SHORT $LN11@CheckFileH

; 67   : 		{
; 68   : 			pItem = (BINARY_TREE*)(pbData + (i * sizeof (BINARY_TREE)));

	movzx	eax, BYTE PTR _i$9[ebp]
	mov	ecx, DWORD PTR _pbData$12[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR _pItem$8[ebp], edx

; 69   : 			if (pItem->dwFileHash == dwFileHash)

	mov	eax, DWORD PTR _pItem$8[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _dwFileHash$[ebp]
	jne	SHORT $LN10@CheckFileH

; 70   : 			{
; 71   : 				i = pItem->byteData;

	mov	eax, DWORD PTR _pItem$8[ebp]
	mov	cl, BYTE PTR [eax+6]
	mov	BYTE PTR _i$9[ebp], cl

; 72   : 				bFound = TRUE;

	mov	DWORD PTR _bFound$10[ebp], 1
	jmp	SHORT $LN9@CheckFileH
$LN10@CheckFileH:

; 73   : 			}
; 74   : 			else if (pItem->dwFileHash < dwFileHash)

	mov	eax, DWORD PTR _pItem$8[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _dwFileHash$[ebp]
	jge	SHORT $LN8@CheckFileH

; 75   : 			{
; 76   : 				i = pItem->byteRight;

	mov	eax, DWORD PTR _pItem$8[ebp]
	mov	cl, BYTE PTR [eax+5]
	mov	BYTE PTR _i$9[ebp], cl

; 77   : 			}
; 78   : 			else

	jmp	SHORT $LN9@CheckFileH
$LN8@CheckFileH:

; 79   : 			{
; 80   : 				i = pItem->byteLeft;

	mov	eax, DWORD PTR _pItem$8[ebp]
	mov	cl, BYTE PTR [eax+4]
	mov	BYTE PTR _i$9[ebp], cl
$LN9@CheckFileH:

; 81   : 			}
; 82   : 		}

	jmp	SHORT $LN12@CheckFileH
$LN11@CheckFileH:

; 83   : #ifndef _DEBUG
; 84   : 		if (i >= byteCount)
; 85   : 		{
; 86   : 			// IPL/IDL loaded not in the official list
; 87   : 			MarkAsModdedGame();
; 88   : 			return;
; 89   : 		}
; 90   : #endif
; 91   : 		
; 92   : 		// Jump over the header and tree blocks into the data block
; 93   : 		MD5_DATA* mdHash = (MD5_DATA*)(pbData + (byteCount * sizeof (BINARY_TREE)) + (i * sizeof (MD5_DATA)));

	movzx	eax, BYTE PTR _byteCount$11[ebp]
	mov	ecx, DWORD PTR _pbData$12[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	movzx	eax, BYTE PTR _i$9[ebp]
	shl	eax, 4
	add	edx, eax
	mov	DWORD PTR _mdHash$7[ebp], edx

; 94   : 
; 95   : 		DWORD dwWasRead;
; 96   : 		BYTE szBuffer[1024];
; 97   : 		
; 98   : 		MD5_CTX mdCTX;
; 99   : 		MD5Init(&mdCTX);

	lea	eax, DWORD PTR _mdCTX$4[ebp]
	push	eax
	call	?MD5Init@@YAXPAUMD5Context@@@Z		; MD5Init
	add	esp, 4

; 100  : 		DWORD dwDataToRead = 1024;

	mov	DWORD PTR _dwDataToRead$3[ebp], 1024	; 00000400H
$LN6@CheckFileH:

; 101  : 		
; 102  : 		while (Arch_ReadFile(hFile, (LPVOID)szBuffer, dwDataToRead, &dwWasRead, NULL) && dwWasRead)

	push	0
	lea	eax, DWORD PTR _dwWasRead$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwDataToRead$3[ebp]
	push	ecx
	lea	edx, DWORD PTR _szBuffer$5[ebp]
	push	edx
	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	call	?Arch_ReadFile@@YGHPAX0KPAKPAU_OVERLAPPED@@@Z ; Arch_ReadFile
	test	eax, eax
	je	SHORT $LN5@CheckFileH
	cmp	DWORD PTR _dwWasRead$6[ebp], 0
	je	SHORT $LN5@CheckFileH

; 103  : 		{
; 104  : 			MD5Update(&mdCTX, szBuffer, dwWasRead);

	mov	eax, DWORD PTR _dwWasRead$6[ebp]
	push	eax
	lea	ecx, DWORD PTR _szBuffer$5[ebp]
	push	ecx
	lea	edx, DWORD PTR _mdCTX$4[ebp]
	push	edx
	call	?MD5Update@@YAXPAUMD5Context@@PBEI@Z	; MD5Update
	add	esp, 12					; 0000000cH

; 105  : 		}

	jmp	SHORT $LN6@CheckFileH
$LN5@CheckFileH:

; 106  : 		
; 107  : 		BYTE byteDigest[16];
; 108  : 		MD5Final(byteDigest, &mdCTX);

	lea	eax, DWORD PTR _mdCTX$4[ebp]
	push	eax
	lea	ecx, DWORD PTR _byteDigest$2[ebp]
	push	ecx
	call	?MD5Final@@YAXQAEPAUMD5Context@@@Z	; MD5Final
	add	esp, 8

; 109  : 		
; 110  : 		LONG lDistanceHigh = 0;

	mov	DWORD PTR _lDistanceHigh$1[ebp], 0

; 111  : 		Arch_SetFilePointer(hFile, 0, &lDistanceHigh, FILE_BEGIN);

	push	0
	lea	eax, DWORD PTR _lDistanceHigh$1[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _hFile$[ebp]
	push	ecx
	call	?Arch_SetFilePointer@@YGKPAXJPAJK@Z	; Arch_SetFilePointer

; 112  : 
; 113  : 		/*
; 114  : #ifdef _DEBUG
; 115  : 		FILE* g = fopen("blaone.txt", "a");
; 116  : 		if (g)
; 117  : 		{
; 118  : 			fprintf(g, "%02x%02x%02x%02x %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\r\n", (dwFileHash >> 24) & 0xFF, (dwFileHash >> 16) & 0xFF, (dwFileHash >> 8) & 0xFF, (dwFileHash >> 0) & 0xFF, byteDigest[0], byteDigest[1], byteDigest[2], byteDigest[3], byteDigest[4], byteDigest[5], byteDigest[6], byteDigest[7], byteDigest[8], byteDigest[9], byteDigest[10], byteDigest[11], byteDigest[12], byteDigest[13], byteDigest[14], byteDigest[15]);
; 119  : 			fprintf(g, "         %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\r\n", mdHash->byteData[0], mdHash->byteData[1], mdHash->byteData[2], mdHash->byteData[3], mdHash->byteData[4], mdHash->byteData[5], mdHash->byteData[6], mdHash->byteData[7], mdHash->byteData[8], mdHash->byteData[9], mdHash->byteData[10], mdHash->byteData[11], mdHash->byteData[12], mdHash->byteData[13], mdHash->byteData[14], mdHash->byteData[15]);
; 120  : 			fclose(g);
; 121  : 		}
; 122  : #endif*/
; 123  : 		
; 124  : 		for (i = 0; i < 16; i++)

	mov	BYTE PTR _i$9[ebp], 0
	jmp	SHORT $LN4@CheckFileH
$LN3@CheckFileH:
	mov	al, BYTE PTR _i$9[ebp]
	add	al, 1
	mov	BYTE PTR _i$9[ebp], al
$LN4@CheckFileH:
	movzx	eax, BYTE PTR _i$9[ebp]
	cmp	eax, 16					; 00000010H
	jge	SHORT $LN14@CheckFileH

; 125  : 		{
; 126  : 			if ((BYTE)byteDigest[i] != (BYTE)mdHash->byteData[i])
; 127  : 			{
; 128  : 				// Tell main that there's a mod
; 129  : #ifndef _DEBUG
; 130  : 				MarkAsModdedGame();
; 131  : 				break;
; 132  : #endif
; 133  : 			}
; 134  : 		}

	jmp	SHORT $LN3@CheckFileH
$LN14@CheckFileH:

; 135  : 	}
; 136  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN22@CheckFileH
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 1468				; 000005bcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN22@CheckFileH:
	DD	5
	DD	$LN21@CheckFileH
$LN21@CheckFileH:
	DD	-96					; ffffffa0H
	DD	4
	DD	$LN16@CheckFileH
	DD	-1128					; fffffb98H
	DD	1024					; 00000400H
	DD	$LN17@CheckFileH
	DD	-1224					; fffffb38H
	DD	88					; 00000058H
	DD	$LN18@CheckFileH
	DD	-1260					; fffffb14H
	DD	16					; 00000010H
	DD	$LN19@CheckFileH
	DD	-1272					; fffffb08H
	DD	4
	DD	$LN20@CheckFileH
$LN20@CheckFileH:
	DB	108					; 0000006cH
	DB	68					; 00000044H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	72					; 00000048H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	104					; 00000068H
	DB	0
$LN19@CheckFileH:
	DB	98					; 00000062H
	DB	121					; 00000079H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	68					; 00000044H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
$LN18@CheckFileH:
	DB	109					; 0000006dH
	DB	100					; 00000064H
	DB	67					; 00000043H
	DB	84					; 00000054H
	DB	88					; 00000058H
	DB	0
$LN17@CheckFileH:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$LN16@CheckFileH:
	DB	100					; 00000064H
	DB	119					; 00000077H
	DB	87					; 00000057H
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	82					; 00000052H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	0
?CheckFileHash@@YAXHPAX@Z ENDP				; CheckFileHash
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File z:\sampsrc\02xu1\saco\filechecks.cpp
;	COMDAT ?IsCheckableFile@@YAHPAD@Z
_TEXT	SEGMENT
tv69 = -200						; size = 4
tv68 = -196						; size = 4
_szExt$ = 8						; size = 4
?IsCheckableFile@@YAHPAD@Z PROC				; IsCheckableFile, COMDAT

; 30   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-200]
	mov	ecx, 50					; 00000032H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 31   : 	// Obfuscate the code in the dll slightly to make tracing it harder
; 32   : 	// very hard coded and messy but should detect ide and ipl case insensitively
; 33   : 	if ((*szExt++ & 0xDF) != 'I') return FALSE;

	mov	eax, DWORD PTR _szExt$[ebp]
	movsx	ecx, BYTE PTR [eax]
	and	ecx, 223				; 000000dfH
	mov	DWORD PTR tv68[ebp], ecx
	mov	edx, DWORD PTR _szExt$[ebp]
	add	edx, 1
	mov	DWORD PTR _szExt$[ebp], edx
	cmp	DWORD PTR tv68[ebp], 73			; 00000049H
	je	SHORT $LN9@IsCheckabl
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN10@IsCheckabl
$LN9@IsCheckabl:
	mov	DWORD PTR tv69[ebp], 0
$LN10@IsCheckabl:
	cmp	DWORD PTR tv69[ebp], 0
	je	SHORT $LN6@IsCheckabl
	xor	eax, eax
	jmp	SHORT $LN7@IsCheckabl
$LN6@IsCheckabl:

; 34   : 	if ((*szExt | 0x20) + 7 != 'k')

	mov	eax, DWORD PTR _szExt$[ebp]
	movsx	ecx, BYTE PTR [eax]
	or	ecx, 32					; 00000020H
	add	ecx, 7
	cmp	ecx, 107				; 0000006bH
	je	SHORT $LN5@IsCheckabl

; 35   : 	{
; 36   : 		if ((*szExt & 0xDF) - 17 == '?')

	mov	eax, DWORD PTR _szExt$[ebp]
	movsx	ecx, BYTE PTR [eax]
	and	ecx, 223				; 000000dfH
	sub	ecx, 17					; 00000011H
	cmp	ecx, 63					; 0000003fH
	jne	SHORT $LN4@IsCheckabl

; 37   : 		{
; 38   : 			szExt++;

	mov	eax, DWORD PTR _szExt$[ebp]
	add	eax, 1
	mov	DWORD PTR _szExt$[ebp], eax

; 39   : 			if (((*szExt | 0x20) - 'k') == 1) return TRUE;

	mov	eax, DWORD PTR _szExt$[ebp]
	movsx	ecx, BYTE PTR [eax]
	or	ecx, 32					; 00000020H
	sub	ecx, 107				; 0000006bH
	cmp	ecx, 1
	jne	SHORT $LN4@IsCheckabl
	mov	eax, 1
	jmp	SHORT $LN7@IsCheckabl
$LN4@IsCheckabl:

; 40   : 		}
; 41   : 	}
; 42   : 	else

	jmp	SHORT $LN2@IsCheckabl
$LN5@IsCheckabl:

; 43   : 	{
; 44   : 		if (((*++szExt & 0xDF) - 'E')) return FALSE;

	mov	eax, DWORD PTR _szExt$[ebp]
	add	eax, 1
	mov	DWORD PTR _szExt$[ebp], eax
	mov	ecx, DWORD PTR _szExt$[ebp]
	movsx	edx, BYTE PTR [ecx]
	and	edx, 223				; 000000dfH
	sub	edx, 69					; 00000045H
	je	SHORT $LN1@IsCheckabl
	xor	eax, eax
	jmp	SHORT $LN7@IsCheckabl
$LN1@IsCheckabl:

; 45   : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $LN7@IsCheckabl
$LN2@IsCheckabl:

; 46   : 	}
; 47   : 
; 48   : 	return FALSE;

	xor	eax, eax
$LN7@IsCheckabl:

; 49   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsCheckableFile@@YAHPAD@Z ENDP				; IsCheckableFile
_TEXT	ENDS
END
